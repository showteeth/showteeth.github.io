<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-05-02T16:26:43.158Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ps-报告当前系统的进程状态</title>
    <link href="http://showteeth.tech/posts/33990.html"/>
    <id>http://showteeth.tech/posts/33990.html</id>
    <published>2019-05-02T14:14:13.000Z</published>
    <updated>2019-05-02T16:26:43.158Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中查看<strong>静态进程信息的命令ps</strong>，主要学习了<code>-A</code>、<code>-u</code>、<code>-N</code>、<code>显示所有进程信息(-ef)</code>、<code>信息更多地显示所有进程信息(-aux)</code>、<code>依据进程信息进行排序</code>、<code>-C</code>、<code>-o</code>、<code>实时监控进程状态</code>等。</p></div><a id="more"></a><h2 id="ps命令简介"><a href="#ps命令简介" class="headerlink" title="ps命令简介"></a>ps命令简介</h2><p>Linux中的ps命令是Process Status的缩写，用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p>linux上进程有5种状态以及在ps中对应的状态码：<br><table><tr><th width="30%">状态</th><th width="40%">说明</th><th width="30%">ps中的状态码</th></tr><tr><td>运行 runnable (on run queue)</td><td>正在运行或在运行队列中等待</td><td>R</td></tr><tr><td>中断 sleeping</td><td>休眠中, 受阻, 在等待某个条件的形成或接受到信号</td><td>S</td></tr><tr><td>不可中断 uninterruptible sleep (usually IO)</td><td>收到信号不唤醒和不可运行, 进程必须等待直到有中断发生</td><td>D</td></tr><tr><td>僵死 a defunct (”zombie”) process</td><td>进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放</td><td>Z</td></tr><tr><td>停止 traced or stopped</td><td>进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行</td><td>T</td></tr></table></p><hr><h2 id="ps命令参数"><a href="#ps命令参数" class="headerlink" title="ps命令参数"></a>ps命令参数</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>a</code></td><td>显示所有进程(with tty)，包括其他其他用户的进程<br></td></tr><tr><td><code>-a</code></td><td>显示所有进程(with tty)，但不包括会话的领导进程(session leaders)</td></tr><tr><td><code>-A, -e</code></td><td>显示所有进程</td></tr><tr><td><code>c</code></td><td>显示进程的真实名称</td></tr><tr><td><code>-N</code></td><td>反向选择，相当于！</td></tr><tr><td><code>e</code></td><td>命令之后显示环境，user、name、path等</td></tr><tr><td><code>-f</code></td><td>信息全部列出，通常和其他选项联用</td></tr><tr><td><code>-H</code></td><td>显示树状结构</td></tr><tr><td><code>r</code></td><td>显示当前终端正在运行的进程</td></tr><tr><td><code>T</code></td><td>显示当前终端的所有进程</td></tr><tr><td><code>-u</code></td><td>指定用户的所有进程</td></tr><tr><td><code>-k、--sort</code></td><td>对进程信息进行排序，+表示升序，-表示降序</td></tr><tr><td><code>-C</code></td><td>根据command名称进行过滤</td></tr></table><hr><h2 id="ps输出结果说明"><a href="#ps输出结果说明" class="headerlink" title="ps输出结果说明"></a>ps输出结果说明</h2><ul><li><code>UID、USER</code>：该命令是由哪个用户产生的。</li><li><code>PID</code>：进程的ID号。</li><li><code>%CPU</code>：该进程占用CPU资源的百分比。</li><li><code>%MEM</code>：该进城占用物理内存的百分比。</li><li><code>VSZ</code>：该进程占用虚拟内存的大小，单位KB。</li><li><code>RSS</code>：该进程占用实际物理内存的大小，单位KB。</li><li><code>TTY</code>：该进程在哪个终端中运行。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地字符界面终端，tty7是图形终端。pst/0-255代表虚拟终端。</li><li><code>STAT</code>：由两个字符组成的状态码，用于表示当前进程的状态：<ul><li>第一个字符：<ul><li><code>R</code>：运行</li><li><code>S</code>：睡眠</li><li><code>T</code>：停止状态</li><li><code>Z</code>：僵死</li></ul></li><li>第二个字符：<ul><li><code>s</code>：包含<strong>子进程</strong></li><li><code>+</code>：位于<strong>前台</strong></li><li><code>&lt;</code>：进程正以<strong>高优先级</strong>运行</li><li><code>N</code>：进程正以<strong>低优先级</strong>运行</li><li><code>L</code>：进程在内存中存在锁定页面</li><li><code>s</code>：进程是<strong>会话领导者（session leader）</strong></li><li><code>l</code>：进程是<strong>多线程</strong>的</li></ul></li></ul></li><li><code>START</code>：该进程的启动时间</li><li><code>TIME</code>：该进程占用CPU的运算时间，注意不是系统时间</li><li><code>COMMAND</code>：产生此进程的命令</li></ul><hr><h2 id="ps使用实例"><a href="#ps使用实例" class="headerlink" title="ps使用实例"></a>ps使用实例</h2><h3 id="A-显示所有进程信息"><a href="#A-显示所有进程信息" class="headerlink" title="-A-显示所有进程信息"></a>-A-显示所有进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -A</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:10:40 systemd</span><br><span class="line">    2 ?        00:00:01 kthreadd</span><br><span class="line">    3 ?        00:00:01 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 kworker/0:0H</span><br><span class="line">    7 ?        00:00:03 migration/0</span><br></pre></td></tr></table></figure><hr><h3 id="u-显示指定用户信息"><a href="#u-显示指定用户信息" class="headerlink" title="-u-显示指定用户信息"></a>-u-显示指定用户信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示root的进程信息</span></span><br><span class="line">ps -u root u</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  root         1  0.0  0.0  52096  4584 ?        Ss    2018  10:41 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line">  root         8  0.0  0.0      0     0 ?        S     2018   0:00 [rcu_bh]</span><br><span class="line">  root         9  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/0]</span><br><span class="line">  root        10  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/1]</span><br></pre></td></tr></table></figure><p>说明：最后的<code>u</code>参数用来<strong>决定以针对用户的格式输出</strong>，由<code>User</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>VSZ</code>, <code>RSS</code>, <code>TTY</code>, <code>STAT</code>, <code>START</code>, <code>TIME</code> 和 <code>COMMAND</code>这几列组成.</p><hr><h3 id="N-反向选择"><a href="#N-反向选择" class="headerlink" title="-N-反向选择"></a>-N-反向选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非root用户的进程信息</span></span><br><span class="line">ps -u root u -N</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  dbus       784  0.0  0.0  35048  1036 ?        Ssl   2018   0:50 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">  polkitd    915  0.0  0.0 632008  2000 ?        Ssl   2018   0:13 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">  user+  3453  0.0  0.0 145612  2300 ?        S    May02   0:00 sshd: user@pts/1</span><br><span class="line">  user+  3454  0.0  0.0 115508  2272 pts/1    Ss   May02   0:01 -bash</span><br><span class="line">  user+ 15238  0.0  0.0 145612  2172 ?        S    00:31   0:00 sshd: user@pts/2</span><br><span class="line">  user+ 15239  0.0  0.0 115508  2228 pts/2    Ss+  00:31   0:00 -bash</span><br><span class="line">  yaojiac+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 </span><br><span class="line">  user+ 17931  0.0  0.0 155268  1860 pts/1    R+   01:07   0:00 ps -u root u -N</span><br><span class="line">  rstudio+ 21690  0.0  0.0 212740  5480 ?        Ssl  Apr10   4:41 /usr/lib/rstudio-server/bin/rserver</span><br></pre></td></tr></table></figure><hr><h3 id="显示所有进程信息"><a href="#显示所有进程信息" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h3><p>显示完整的命令信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">  UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">  root         1     0  0  2018 ?        00:10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2     0  0  2018 ?        00:00:01 [kthreadd]</span><br><span class="line">  root         3     2  0  2018 ?        00:00:01 [ksoftirqd/0]</span><br><span class="line">  root         5     2  0  2018 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">  root         7     2  0  2018 ?        00:00:03 [migration/0]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="显示所有进程信息，信息更多"><a href="#显示所有进程信息，信息更多" class="headerlink" title="显示所有进程信息，信息更多"></a>显示所有进程信息，信息更多</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  root         1  0.0  0.0  52096  4624 ?        Ss    2018  10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line">  root         8  0.0  0.0      0     0 ?        S     2018   0:00 [rcu_bh]</span><br><span class="line">  root         9  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/0]</span><br><span class="line">  root        10  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/1]</span><br><span class="line">  root        11  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/2]</span><br></pre></td></tr></table></figure><div class="note info"><p>与<code>ps -ef</code>相比，<code>ps -aux</code>信息更多，包括了<code>%CPU</code>、<code>%MEM</code>等信息，两者的<code>cmd</code>和<code>command</code>是相同的</p></div><hr><h3 id="依据进程信息进行排序"><a href="#依据进程信息进行排序" class="headerlink" title="依据进程信息进行排序"></a>依据进程信息进行排序</h3><p>参数说明：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">k,    --sort        specify sort order as: [+|-]key[,[+|-]key[,...]]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>多个key之间使用<strong>逗号分隔</strong></li><li><code>+</code>表示<strong>升序</strong>，<code>-</code>表示<strong>降序</strong></li><li>支持的sort key可以查看<a href="http://linuxcommand.org/lc3_man_pages/ps1.html" target="_blank" rel="noopener">这个链接中的STANDARD FORMAT SPECIFIERS</a></li></ul></div><hr><h4 id="依据进程的CPU使用排序"><a href="#依据进程的CPU使用排序" class="headerlink" title="依据进程的CPU使用排序"></a>依据进程的CPU使用排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降序排列，+pcpu</span></span><br><span class="line">ps -aux --sort +pcpu</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 15072  118  2.5 1890184 1247420 pts/2 R+   00:28   0:02 sh test.sh</span><br><span class="line">  root         1  0.0  0.0  52096  4624 ?        Ss    2018  10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升序排列，+pcpu</span></span><br><span class="line">ps -aux --sort +pcpu</span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 </span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 15072  100 22.5 11214456 11102608 pts/2 R+ 00:28   0:46 sh test.sh</span><br></pre></td></tr></table></figure><hr><h4 id="依据进程的内存使用排序"><a href="#依据进程的内存使用排序" class="headerlink" title="依据进程的内存使用排序"></a>依据进程的内存使用排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据内存使用进行降序排列</span></span><br><span class="line">ps -aux --sort -pmem </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 </span><br><span class="line">  yaojiac+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 </span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  root     15933  0.0  0.0 341804 13380 ?        Ssl   2018   0:01 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br></pre></td></tr></table></figure><hr><h3 id="C-通过command名称过滤"><a href="#C-通过command名称过滤" class="headerlink" title="-C-通过command名称过滤"></a>-C-通过command名称过滤</h3><p>使用 -C 参数，后面跟你要找的进程的名字:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -fC jupyterhub</span><br><span class="line">  root     30495     1  0 Apr30 ?        00:00:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>参数是带有顺序的</strong>，不能使用<code>-Cf</code>，使用<code>-fC</code>是正确的</p></div><hr><h3 id="o-指定输出字段"><a href="#o-指定输出字段" class="headerlink" title="-o-指定输出字段"></a>-o-指定输出字段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出字段</span></span><br><span class="line">ps -o pid,ppid,pgrp,session,tpgid,comm</span><br><span class="line">    PID  PPID  PGRP  SESS TPGID COMMAND</span><br><span class="line">  3454  3453  3454  3454 13946 bash</span><br><span class="line">  13946  3454 13946  3454 13946 ps</span><br></pre></td></tr></table></figure><p>支持的输出字段可以查看<a href="http://linuxcommand.org/lc3_man_pages/ps1.html" target="_blank" rel="noopener">这个链接中的STANDARD FORMAT SPECIFIERS</a></p><hr><h3 id="实时监控进程状态"><a href="#实时监控进程状态" class="headerlink" title="实时监控进程状态"></a>实时监控进程状态</h3><p>ps 命令会显示你系统当前的进程状态，但是这个结果是静态的，如果我们需要像上面提到的通过CPU和内存的使用率来筛选进程，并且我们希望结果能够每秒刷新一次，我们可以将<code>ps</code>命令和<code>watch</code>命令结合起来：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每10秒更新一次</span></span><br><span class="line">watch -n 10 <span class="string">'ps -aux --sort -pmem | head -n 20'</span></span><br><span class="line">  Every 10.0s: ps -aux --sort -pmem | head -n 20                                                                                                 Fri May  3 00:53:36 2019</span><br><span class="line"></span><br><span class="line">  USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783</span><br><span class="line">  yaojiac+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460</span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  root     15933  0.0  0.0 341804 12992 ?        Ssl   2018   0:01 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line">  rstudio+ 21690  0.0  0.0 212740  5480 ?        Ssl  Apr10   4:41 /usr/lib/rstudio-server/bin/rserver</span><br><span class="line">  root  3448  0.0  0.0 145612  5156 ?        Ss   May02   0:00 sshd: user [priv]</span><br></pre></td></tr></table></figure><p></p><p><mark>这里的动态查看<strong>并不像<code>top</code>或者<code>htop</code>命令</strong>一样，使用<code>ps</code>的好处是你能够<strong>自定义显示你想查看的字段</strong></mark>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定用户的信息，并按照内存使用进行降序排序</span></span><br><span class="line">watch -n 10 <span class="string">'ps -u user u --sort -pmem | head -n 20'</span></span><br><span class="line">  Every 10.0s: ps -u user u --sort -pmem | head -n 20                                                                                     Fri May  3 00:56:12 2019</span><br><span class="line"></span><br><span class="line">  USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783</span><br><span class="line">  user+ 17081  0.0  0.0 157560  2528 pts/1    S+   00:55   0:00 watch -n 10 ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+  3453  0.0  0.0 145612  2300 ?        S    May02   0:00 sshd: user@pts/1</span><br><span class="line">  user+  3454  0.0  0.0 115508  2272 pts/1    Ss   May02   0:01 -bash</span><br><span class="line">  user+ 15239  0.0  0.0 115508  2228 pts/2    Ss+  00:31   0:00 -bash</span><br><span class="line">  user+ 15238  0.0  0.0 145612  2172 ?        S    00:31   0:00 sshd: user@pts/2</span><br><span class="line">  user+ 17120  0.0  0.0 155264  1832 pts/1    R+   00:56   0:00 ps -U user -u --sort -pmem</span><br><span class="line">  user+ 17119  0.0  0.0 113124  1364 pts/1    S+   00:56   0:00 sh -c ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+ 17118  0.0  0.0 157556   936 pts/1    S+   00:56   0:00 watch -n 10 ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+ 17121  0.0  0.0 107904   672 pts/1    S+   00:56   0:00 head -n 20</span><br></pre></td></tr></table></figure><p></p><p>说明：最后的<code>u</code>参数用来<strong>决定以针对用户的格式输出</strong>，由<code>User</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>VSZ</code>, <code>RSS</code>, <code>TTY</code>, <code>STAT</code>, <code>START</code>, <code>TIME</code> 和 <code>COMMAND</code>这几列组成.</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="noopener">每天一个linux命令（41）：ps命令</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" target="_blank" rel="noopener">4. ps 进程查看器</a></li><li><a href="https://www.jianshu.com/p/784d594a78aa" target="_blank" rel="noopener">Linux命令-5 ps</a></li><li><a href="https://linux.cn/article-4743-1.html" target="_blank" rel="noopener">10个重要的Linux ps命令实战</a></li><li><a href="https://segmentfault.com/a/1190000014730535#articleHeader1" target="_blank" rel="noopener">Linux 进程管理（1）- 查看进程：ps,pstree,top,htop,bg,fg,jobs</a></li><li><a href="http://os.51cto.com/art/201101/244090.htm" target="_blank" rel="noopener">如何在Linux中查看所有正在运行的进程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中查看&lt;strong&gt;静态进程信息的命令ps&lt;/strong&gt;，主要学习了&lt;code&gt;-A&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;、&lt;code&gt;-N&lt;/code&gt;、&lt;code&gt;显示所有进程信息(-ef)&lt;/code&gt;、&lt;code&gt;信息更多地显示所有进程信息(-aux)&lt;/code&gt;、&lt;code&gt;依据进程信息进行排序&lt;/code&gt;、&lt;code&gt;-C&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;实时监控进程状态&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rsnyc-远程数据同步</title>
    <link href="http://showteeth.tech/posts/8376.html"/>
    <id>http://showteeth.tech/posts/8376.html</id>
    <published>2019-05-02T01:23:22.000Z</published>
    <updated>2019-05-02T15:37:29.462Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中进行<strong>远程数据同步的命令rsync</strong>，相比于功能相近的<a href="http://showteeth.tech/posts/2539.html">scp命令</a>，其可以实现<strong>增量同步</strong>；主要学习了<code>本地目录之间的同步</code>、<code>本地与远程之间的同步</code>、<code>-t</code>、<code>-a</code>、<code>-r</code>、<code>-R</code>、<code>-l</code>、<code>-L</code>、<code>--backup</code>、<code>--backup-dir</code>、<code>--existing</code>、<code>--ignore-existing</code>、<code>--remove-source-files</code>、<code>--exclude</code>、<code>--delete</code>、<code>--max-size</code>等参数。</p></div><a id="more"></a><h2 id="rsync命令简介"><a href="#rsync命令简介" class="headerlink" title="rsync命令简介"></a>rsync命令简介</h2><p><code>rsync</code>是可以<strong>实现增量备份</strong>的工具。配合任务计划，<code>rsync</code>能实现<strong>定时或间隔同步</strong>，配合<code>inotify</code>或<code>sersync</code>，可以实现<strong>触发式的实时同步</strong>。</p><p><code>rsync</code>可以实现<a href="http://showteeth.tech/posts/2539.html">scp</a>的远程拷贝(<strong><code>rsync</code>不支持远程到远程的拷贝，但<code>scp</code>支持</strong>)、<code>cp</code>的本地拷贝、<code>rm</code>删除和<code>&quot;ls -l&quot;</code>显示文件列表等功能。但需要注意的是，<code>rsync</code>的最终目的或者说其<strong>原始目的是实现两端主机的文件同步</strong>，因此实现的<code>scp/cp/rm</code>等功能仅仅只是同步的辅助手段，且<code>rsync</code>实现这些功能的方式和这些命令是不一样的。本篇文章将简单介绍rsync的使用方法和它常用的功能。</p><hr><h2 id="rsync同步说明"><a href="#rsync同步说明" class="headerlink" title="rsync同步说明"></a>rsync同步说明</h2><p><code>rsync</code>的目的是<strong>实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步(scp可以实现)</strong>。</p><p>不考虑rsync的实现细节，就文件同步而言，涉及了<strong>源文件和目标文件</strong>的概念，还涉及了<strong>以哪边文件为同步基准</strong>。例如，想让目标主机上的文件和本地文件保持同步，则是以本地文件为同步基准，将本地文件作为源文件推送到目标主机上。反之，如果想让本地主机上的文件和目标主机上的文件保持同步，则目标主机上的文件为同步基准，实现方式是将目标主机上的文件作为源文件拉取到本地。当然，要保持本地的两个文件相互同步，rsync也一样能实现，这就像Linux中cp命令一样，以本地某文件作为源，另一文件作为目标文件，但请注意，虽然rsync和cp能达到相同的目的，但它们的实现方式是不一样的。实际上，如果<strong>简单理解的话，可以将其当成复制命令来理解</strong>：</p><ul><li><strong>本地和远程同步</strong>，就是将<strong>远程的文件复制到本地</strong>，覆盖本地原有文件的内容</li><li><strong>远程和本地同步</strong>，就是将<strong>本地的文件复制到远程</strong>，覆盖远程原有文件的内容</li></ul><p>既然是文件同步，在同步过程中必然会涉及到源和目标两文件之间<strong>版本控制</strong>的问题，例如是否要删除源主机上没有但目标上多出来的文件，目标文件比源文件更新(newer than source)时是否仍要保持同步，遇到软链接时是拷贝软链接本身还是拷贝软链接所指向的文件，目标文件已存在时是否要先对其做个备份等等。</p><p><code>rsync</code>同步过程中由<strong>两部分模式</strong>组成：<strong>决定哪些文件需要同步的检查模式</strong>以及<strong>文件同步时的同步模式</strong>：</p><ul><li><p><strong>检查模式是指按照指定规则来检查哪些文件需要被同步</strong>，例如哪些文件是明确被排除不传输的。<strong>默认情况下</strong>，<code>rsync</code>使用<code>&quot;quick check&quot;</code>算法快速检查源文件和目标文件的<strong>大小</strong>、<strong>mtime(修改时间)是否一致</strong>，如果<strong>不一致则需要传输</strong>。当然，也可以通过在<code>rsync</code>命令行中指定某些选项来<strong>改变quick check的检查模式</strong>，比如<code>&quot;--size-only&quot;</code>选项表示<code>&quot;quick check&quot;</code>将仅检查文件大小不同的文件作为待传输文件。rsync支持非常多的选项，其中检查模式的自定义性是非常有弹性的。</p></li><li><p><strong>同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作</strong>。例如上文所说的是否要先删除源主机上没有但目标主机上有的文件，是否要先备份已存在的目标文件，是否要追踪链接文件等额外操作。rsync也提供非常多的选项使得同步模式变得更具弹性。</p></li><li><p>相对来说，<strong>为<code>rsync</code>手动指定同步模式的选项更常见一些</strong>，只有在有特殊需求时才指定检查模式，因为大多数检查模式选项都可能会影响<code>rsync</code>的性能。</p></li></ul><hr><h2 id="rsync命令格式"><a href="#rsync命令格式" class="headerlink" title="rsync命令格式"></a>rsync命令格式</h2><h3 id="通用命令格式"><a href="#通用命令格式" class="headerlink" title="通用命令格式"></a>通用命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync options <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><hr><h3 id="本地路径之间的同步"><a href="#本地路径之间的同步" class="headerlink" title="本地路径之间的同步"></a>本地路径之间的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地路径之间的同步</span></span><br><span class="line">Local:  rsync [OPTION...] SRC... [DEST]</span><br></pre></td></tr></table></figure><hr><h3 id="本地和远程的同步"><a href="#本地和远程的同步" class="headerlink" title="本地和远程的同步"></a>本地和远程的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地和远程的同步 </span></span><br><span class="line">Access via remote shell:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br></pre></td></tr></table></figure><hr><h3 id="本地和远程的同步-rsync-daemon"><a href="#本地和远程的同步-rsync-daemon" class="headerlink" title="本地和远程的同步(rsync daemon)"></a>本地和远程的同步(rsync daemon)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access via rsync daemon:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]</span><br><span class="line">        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST</span><br><span class="line">        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</span><br></pre></td></tr></table></figure><div class="note info"><ul><li><strong>前两者</strong>的本质是<strong>通过管道通信，即使是远程shell</strong>；而<strong>第三种方式</strong>则是<strong>让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接</strong>。</li><li>命令中的<strong>第一个路径参数</strong>一定是源文件路径，即<strong>作为同步基准的一方</strong>，<strong>可以同时指定多个源文件路径</strong>。<strong>最后一个路径参数则是目标文件路径</strong>，也就是<strong>待同步方</strong>。路径的格式可以是<code>本地路径</code>，也可以是使用<code>user@host:path</code>或<code>user@host::path</code>的远程路径，如果主机和path路径之间使用<strong>单个冒号</strong>隔开，表示使用的是<strong>远程shell通信方式</strong>，而使用<strong>双冒号</strong>隔开的则表示的是连接<code>rsync daemon</code>。另外，连接<code>rsync daemon</code>时，还提供了<strong>URL格式</strong>的路径表述方式<code>rsync://user@host/path</code>。</li><li>如果<strong>仅有一个SRC或DEST参数</strong>，则将以类似于<code>&quot;ls -l&quot;</code>的方式<strong>列出源文件列表(只有一个路径参数，总会认为是源文件)，而不是复制文件</strong>。</li><li>另外，使用<code>rsync</code>一定要注意的一点是，源路径如果是一个目录的话，<strong>带上尾随斜线</strong>和<strong>不带尾随斜线</strong>是<strong>不一样</strong>的，<strong>不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身</strong>。</li></ul></div><hr><h2 id="rsync参数说明"><a href="#rsync参数说明" class="headerlink" title="rsync参数说明"></a>rsync参数说明</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-v</code></td><td><code>--verbose</code></td><td>显示rsync过程中详细信息，可以使用"-vvvv"获取更详细信息</td></tr><tr><td><code>-P</code></td><td></td><td>显示文件传输的进度信息(实际上"-P"="--partial --progress"，其中的"--progress"才是显示进度信息的)</td></tr><tr><td><code>-n</code></td><td><code>--dry-run</code></td><td>仅测试传输，而不实际传输，常和"-vvvv"配合使用来查看rsync是如何工作的</td></tr><tr><td><code>-a</code></td><td><code>--archive</code></td><td>归档模式，表示递归传输并保持文件属性，等同于"-rtopgDl"(不带-H,-A,-X)</td></tr><tr><td><code>-r</code></td><td><code>--recursive</code></td><td>递归</td></tr><tr><td><code>-t</code></td><td><code>--times</code></td><td>保持mtime属性。强烈建议任何时候都加上"-t"，否则目标文件mtime会设置为系统时间，导致下次更新检查出mtime不同从而导致增量传输无效</td></tr><tr><td><code>-o</code></td><td><code>--owner</code></td><td>保持owner属性(属主)</td></tr><tr><td><code>-g</code></td><td><code>--group</code></td><td>保持group属性(属组)</td></tr><tr><td><code>-p</code></td><td><code>--perms</code></td><td>保持perms属性(权限，不包括特殊权限)</td></tr><tr><td><code>-D</code></td><td></td><td>是"--device --specials"选项的组合，即也拷贝设备文件和特殊文件</td></tr><tr><td><code>-l</code></td><td><code>--links</code></td><td>如果文件是软链接文件，则会拷贝软链接，默认情况下会忽略链接的同步</td></tr><tr><td><code>-L</code></td><td><code>--copy-links</code></td><td>如果文件是软链接文件，则会拷贝软链接指向的文件或目录，而不是单纯的保留软链接形式，默认情况下会忽略链接的同步</td></tr><tr><td><code>-z</code></td><td></td><td>传输时进行压缩提高效率</td></tr><tr><td><code>-R</code></td><td><code>--relative</code></td><td>使用相对路径，意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例</td></tr><tr><td></td><td><code>--size-only</code></td><td>默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。</td></tr><tr><td><code>-u</code></td><td><code>--update</code></td><td>仅在源mtime比目标已存在文件的mtime新时才拷贝，注意，该选项是接收端判断的，不会影响删除行为</td></tr><tr><td><code>-d</code></td><td><code>--dirs</code></td><td>以不递归的方式拷贝目录本身，默认递归时，如果源为"dir1/file1"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1</td></tr><tr><td></td><td><code>--max-size</code></td><td>限制rsync传输的最大文件大小，可以使用单位后缀，还可以是一个小数值(例如："--max-size=1.5m")</td></tr><tr><td></td><td><code>--min-size</code></td><td>限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件</td></tr><tr><td></td><td><code>--exclude</code></td><td>指定排除规则来排除不需要传输的文件</td></tr><tr><td></td><td><code>--delete</code></td><td>以SRC为主，对DEST进行同步。多则删之，少则补之。注意"--delete"是在接收端执行的，所以它是在exclude/include规则生效之后才执行的</td></tr><tr><td><code>-b</code></td><td><code>--backup</code></td><td>对目标上已存在的文件做一个备份，备份的文件名后默认使用"~"做后缀</td></tr><tr><td></td><td><code>--backup-dir</code></td><td>指定备份文件的保存路径，不指定时默认和待备份文件保存在同一目录下</td></tr><tr><td><code>-e</code></td><td></td><td>指定所要使用的远程shell程序，默认为ssh，可以用来指定端口号</td></tr><tr><td></td><td><code>--port</code></td><td>连接daemon时使用的端口号，默认为873端口</td></tr><tr><td></td><td><code>--password-file</code></td><td>daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码</td></tr><tr><td><code>-W</code></td><td><code>--whole-file</code></td><td>rsync将不再使用增量传输，而是全量传输，在网络带宽高于磁盘带宽时，该选项比增量传输更高效</td></tr><tr><td></td><td><code>--existing</code></td><td>要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。</td></tr><tr><td></td><td><code>--ignore-existing</code></td><td>要求只更新目标端不存在的文件，和"--existing"结合使用有特殊功能，见下文示例</td></tr><tr><td></td><td><code>--remove-source-files</code></td><td>要求删除源端已经成功传输的文件</td></tr></table><hr><h2 id="rsync使用实例"><a href="#rsync使用实例" class="headerlink" title="rsync使用实例"></a>rsync使用实例</h2><h3 id="本地之间的同步"><a href="#本地之间的同步" class="headerlink" title="本地之间的同步"></a>本地之间的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将scp目录下的test.txt同步到当前目录中</span></span><br><span class="line"><span class="comment"># 默认是不会显示进度信息的，和scp不同</span></span><br><span class="line">rsync /home/user/learn/linux_learn/scp/test.txt ./</span><br></pre></td></tr></table></figure><div class="note info"><p>注意事项：</p><ul><li>只要目的端文件内容和源端不一样，就会触发数据同步，<code>rsync</code>会确保两边的文件内容一样</li><li>默认情况下，<strong><code>rsync</code>不会同步文件的“modify time”</strong>，凡是有数据同步的文件，<strong>目的端的文件的“modify time”总是会被修改为最新时刻的时间(同步发生的时间)</strong>，而默认情况下rsync会检查<strong>源文件和目标文件的大小</strong>、<strong>mtime(修改时间)是否一致，如果不一致则需要传输</strong>，这样时间发生改变会使得源文件和目的端文件内容总是不同，<strong>导致增量同步无效</strong></li><li><code>rsync</code><strong>不会太关注目的端文件的<code>rwx</code>权限</strong>，如果目的端<strong>没有</strong>此文件，那么权限会保持<strong>与源端一致</strong>；如果目的端<strong>有此文件</strong>，则权限<strong>不会随着源端变更</strong></li></ul></div><hr><h3 id="t-保持mtime属性"><a href="#t-保持mtime属性" class="headerlink" title="-t-保持mtime属性"></a>-t-保持mtime属性</h3><p>为了解决默认情况下rsync会将目的端同步文件的modify time修改为当前时间从而导致增量同步无效的问题，可以使用-t来在同步文件时保留mtime属性：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步，保留mtime属性</span></span><br><span class="line">rsync -r -v -t /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 时间和远程文件的保持一致</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行同步</span></span><br><span class="line"><span class="comment"># 因为时间戳是相同的，且文件内容也是相同的，所以不会进行再次同步</span></span><br><span class="line">rsync -r -v -t  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 129 bytes  received 13 bytes  284.00 bytes/sec</span><br><span class="line">total size is 271119920  speedup is 1909295.21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用-t参数</span></span><br><span class="line">rsync -r -v  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"><span class="comment"># 这里的时间就是当前时间</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 21:50 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 21:50 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行同步</span></span><br><span class="line"><span class="comment"># 因为时间戳是不同的，所以还会进行同步</span></span><br><span class="line">rsync -r -v  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"></span><br><span class="line">sent 271153227 bytes  received 51 bytes  180768852.00 bytes/sec</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意事项：</p><ul><li><code>-t</code>参数会保留远程(源端)文件的modify time属性，下次再进行同步时，如果远程文件没有修改，就不会再次同步，真正的增量同步</li><li>不加<code>-t</code>参数会使得当前文件的modify time为同步操作发生的时间，从而使得远程文件和当前文件的modify time一直不同，重复运行会一直同步，即使远程文件没有修改，这使得增量同步无效</li><li><strong>为了防止文件时间戳和大小一致，但是内容不一致的情况</strong>，可以使用<code>-I</code>参数：<strong>don’t skip files that match in size and mod-time</strong>，但是这<strong>会影响rsync的性能</strong></li></ul></div><hr><h3 id="a-归档模式"><a href="#a-归档模式" class="headerlink" title="-a-归档模式"></a>-a-归档模式</h3><p>rsync的<code>-a</code>选项是archive的意思，加了之后有以下作用：</p><ul><li>递归模式</li><li>同步软链接</li><li>同步权限</li><li>同步时间戳</li><li>同步属主和属组</li></ul><hr><h3 id="本地和远程同步"><a href="#本地和远程同步" class="headerlink" title="本地和远程同步"></a>本地和远程同步</h3><p>和<code>scp</code>命令一样，<code>rsync</code>也是<strong>默认使用的是22端口连接远程服务器</strong>，如果想要<strong>指定服务器端口</strong>需要使用<code>-e</code>来<strong>指定ssh连接参数</strong>，如<code>端口</code>、<code>连接的用户</code>、<code>ssh选项</code>等：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定端口为12000</span></span><br><span class="line">rsync -r -v -e <span class="string">"ssh -p 12000 "</span> wangjb@166.111.152.116:/Share/home/wangjb/user/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./</span><br><span class="line">wangjb@166.111.152.116<span class="string">'s password: </span></span><br><span class="line"><span class="string">receiving incremental file list</span></span><br><span class="line"><span class="string">B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sent 115306 bytes  received 66000 bytes  10988.24 bytes/sec</span></span><br><span class="line"><span class="string">total size is 271119851  speedup is 1495.37</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="r-递归同步文件夹内容"><a href="#r-递归同步文件夹内容" class="headerlink" title="-r-递归同步文件夹内容"></a>-r-递归同步文件夹内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将scp目录下的test目录及其内容递归地复制到当前目录中的test目录</span></span><br><span class="line">rsync -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><div class="note info"><p>使用<code>-r</code>选项，<code>rsync</code>会进入到文件夹里去检查，而<strong>不会只对文件夹本身做“quick check”的(检查文件夹的大小和时间戳)</strong></p></div><hr><h3 id="R-保留目录结构"><a href="#R-保留目录结构" class="headerlink" title="-R-保留目录结构"></a>-R-保留目录结构</h3><p>默认情况下，同步只是针对的最后指定的文件或者目录，上层目录不会进行同步，如果有时需要保留目录结构，可以使用-R参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-R会保留目录结构</span></span><br><span class="line">rsync -R -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能使用相对路径，如果使用会报错</span></span><br><span class="line">rsync -R -r ../scp/<span class="built_in">test</span> ./</span><br><span class="line">found <span class="string">".."</span> dir <span class="keyword">in</span> relative path: ../scp/<span class="built_in">test</span></span><br><span class="line">rsync error: syntax or usage error (code 1) at flist.c(2130) [sender=3.0.9]</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终生成的路径</span></span><br><span class="line">/home/user/learn/linux_learn/rsync/(当前目录)home/user/learn/linux_learn/scp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>由于不能使用相对路径，有时候我们并不需要从根目录进行保留目录结构，只希望<strong>保留一部分目录结构</strong>，这是<strong>可以使用<code>.</code>表示保留目录结构的起始位置</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从linux_learn开始保留目录结构</span></span><br><span class="line">rsync -R -r /home/user/learn/./linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终生成的路径</span></span><br><span class="line">/home/user/learn/linux_learn/rsync/(当前目录)linux_learn/scp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-R</code>参数表示<strong>使用相对路径</strong>，此<strong>相对路径是以目标目录为根的</strong>，例如<code>/home/user/learn/linux_learn/scp/test ./</code>表示使用当前目录来替换最开始的<code>/</code>目录</li><li><code>-R</code>指定的<strong>source目录必须使用绝对路径</strong>，不能使用相对路径</li><li><code>-R</code>可以指定<strong>保留部分目录结构</strong>，在完整的绝对路径中想要保留的目录结构之前加上<code>./</code>即可</li></ul></div><hr><h3 id="l-保留原始链接形式"><a href="#l-保留原始链接形式" class="headerlink" title="-l-保留原始链接形式"></a>-l-保留原始链接形式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程文件</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">lrwxrwxrwx. 1 user user        12 May  2 22:10 test2.txt -&gt; ../test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -v -t -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 默认会跳过链接文件</span></span><br><span class="line">skipping non-regular file <span class="string">"test/test2.txt"</span></span><br><span class="line"></span><br><span class="line">sent 271153253 bytes  received 54 bytes  180768871.33 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步，保留软连接</span></span><br><span class="line">rsync -v -t -r -l /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 保留软链接形式</span></span><br><span class="line"><span class="built_in">test</span>/test2.txt -&gt; ../test2.txt</span><br><span class="line"></span><br><span class="line">sent 271153269 bytes  received 57 bytes  180768884.00 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程文件</span></span><br><span class="line"><span class="comment"># 得到了和当前文件相同的软连接，相对路径的软连接会失效</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">lrwxrwxrwx. 1 user user        12 May  2 22:10 test2.txt -&gt; ../test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="L-复制链接指向的文件或目录"><a href="#L-复制链接指向的文件或目录" class="headerlink" title="-L-复制链接指向的文件或目录"></a>-L-复制链接指向的文件或目录</h3><p>上述的参数-l虽会保留软链接，但如果不是同一台机器以及链接不是使用的绝对路径都会使得链接失效，较为有效地做法是复制链接指向的文件，可以使用-L参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步，复制链接指向的文件或目录</span></span><br><span class="line">rsync -v -t -r -L /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 直接复制了链接指向的文件</span></span><br><span class="line"><span class="built_in">test</span>/test2.txt</span><br><span class="line"></span><br><span class="line">sent 271153307 bytes  received 73 bytes  180768920.00 bytes/sec</span><br><span class="line">total size is 271119935  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前文件</span></span><br><span class="line"><span class="comment"># 不再是链接，而是文件</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        15 May  2 22:09 test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–backup-已存在的目录备份"><a href="#–backup-已存在的目录备份" class="headerlink" title="–backup-已存在的目录备份"></a>–backup-已存在的目录备份</h3><p>如果在<strong>进行同步时希望保留当前的文件</strong>，可以使用<code>--backup</code>来进行备份，默认的备份文件使用”<code>~</code>“做后缀，可以使用<code>--suffix</code>指定备份后缀：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步的同时进行备份</span></span><br><span class="line">rsync -r --backup /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost <span class="built_in">test</span>]$ ll</span><br><span class="line">total 529536</span><br><span class="line"><span class="comment"># 默认的原始的文件使用了~</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:09 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 12:35 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart~</span><br></pre></td></tr></table></figure><p></p><p>指定原始文件的备份后缀：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--suffix指定备份文件的后缀</span></span><br><span class="line">rsync -r --backup --suffix <span class="string">".backup"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost <span class="built_in">test</span>]$ ll</span><br><span class="line">total 794304</span><br><span class="line"><span class="comment"># 设置了备份文件后缀为backup</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:11 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 12:35 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart~</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:09 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.backup</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–backup-dir-指定备份目录"><a href="#–backup-dir-指定备份目录" class="headerlink" title="–backup-dir-指定备份目录"></a>–backup-dir-指定备份目录</h3><p>将<strong>当前的文件备份到指定的目录中</strong>，而不是默认的当前目录，<strong>默认是不会给文件增加后缀的</strong>，可以<strong>使用<code>--suffix</code>指定备份后缀</strong>，注意<strong>必须和<code>--backup</code>一同使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前文件备份到backup目录下，如果目录不存在就创建</span></span><br><span class="line">rsync -r --backup --backup-dir ./backup /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定备份文件后缀</span></span><br><span class="line">rsync -r --backup --backup-dir ./backup --suffix <span class="string">".test"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–existing-只更新目标端存在的文件"><a href="#–existing-只更新目标端存在的文件" class="headerlink" title="–existing-只更新目标端存在的文件"></a>–existing-只更新目标端存在的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只更新当前目录下存在文件</span></span><br><span class="line">rsync -r --existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为当前目录下没有和test目录下共有的文件，所以没有进行同步</span></span><br></pre></td></tr></table></figure><p></p><p>在当前目录下创建一个和远程目录中相同的文件test.txt，并在远程的test.txt中写入内容，而当前目录的test.txt为空：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  1 23:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -r --existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现了相同文件的同步</span></span><br><span class="line">-rw-rw-r--. 1 user user 69 May  2 13:35 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–ignore-existing-只更新目标端不存在的文件"><a href="#–ignore-existing-只更新目标端不存在的文件" class="headerlink" title="–ignore-existing-只更新目标端不存在的文件"></a>–ignore-existing-只更新目标端不存在的文件</h3><p>和上面的<code>--existing</code>参数相反，<code>--ignore-existing</code>只更新当面不存在的文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:43 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -r --ignore-existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 已存在的test.txt没有更新</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:44 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user         0 May  2 13:43 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–remove-source-files-删除远程文件"><a href="#–remove-source-files-删除远程文件" class="headerlink" title="–remove-source-files-删除远程文件"></a>–remove-source-files-删除远程文件</h3><p>使用该选项后，<strong>远程已经更新成功的文件都会被删除</strong>，远程所有<strong>未传输或未传输成功的文件都不会被移除</strong>。未传输成功的原因有多种，如<code>exclude</code>排除了，<code>&quot;quick check&quot;</code>未选项该文件，传输中断等等。总之，显示在<code>&quot;rsync -v&quot;</code>被传输列表中的文件<strong>都会被移除</strong>。如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:43 test.txt</span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  1 23:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 同步完成之后删除远程已经同步好的文件</span></span><br><span class="line">rsync -r -v --ignore-existing --remove-source-files /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:50 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user         0 May  2 13:43 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line"><span class="comment"># 同步完成的文件被删除了</span></span><br><span class="line">-rw-rw-r--. 1 user user 69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–exclude-指定排除规则"><a href="#–exclude-指定排除规则" class="headerlink" title="–exclude-指定排除规则"></a>–exclude-指定排除规则</h3><p>上面使用<code>--existing</code>和<code>--ignore-existing</code>来仅对已经存在或者不存在的文件进行更新，实际上就是一种排除规则，如果希望对某一类文件的同步进行排除可以使用<code>--exclude</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 排除所有txt后缀文件</span></span><br><span class="line">rsync -r -v --exclude <span class="string">"*.txt"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"></span><br><span class="line">sent 271153093 bytes  received 32 bytes  180768750.00 bytes/sec</span><br><span class="line">total size is 271119851  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:01 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>一个<code>--exclude</code>只能指定一条规则</strong>，要<strong>指定多条排除规则</strong>，需要<strong>使用多个<code>--exclude</code>选项</strong>，或者将排除规则<strong>写入到文件中</strong>，然后使用<code>--exclude-from</code>选项读取该规则文件</li><li>除了<code>--exclude</code>排除规则，还有<code>--include</code>包含规则，顾名思义，它就是<strong>筛选出要进行传输的文件</strong>，所以<code>include</code>规则也称为传输规则。它的使用方法和<code>--exclude</code>一样。<strong>如果一个文件即能匹配排除规则，又能匹配包含规则，则先匹配到的立即生效，生效后就不再进行任何匹配</strong></li><li>最重要的一点是它的<strong>作用时间</strong>。当发送端敲出rsync命令后，rsync将立即扫描命令行中给定的文件和目录(扫描过程中还会按照目录进行排序，将同一个目录的文件放在相邻的位置)，这称为拷贝树(copy tree)，扫描完成后将待传输的文件或目录记录到文件列表中，然后将文件列表传输给接收端。而<strong>筛选规则的作用时刻是在扫描拷贝树时</strong>，所以会<strong>根据规则来匹配并决定文件是否记录到文件列表中(严格地说是会记录到文件列表中的，只不过排除的文件会被标记为hide隐藏起来)</strong>，只有记录到了文件列表中的文件或目录才是真正需要传输的内容。换句话说，<strong>筛选规则的生效时间在rsync整个同步过程中是非常靠前的，它会影响很多选项的操作对象，最典型的如<code>--delete</code></strong>。</li></ul></div><hr><h3 id="rsync中的匹配规则"><a href="#rsync中的匹配规则" class="headerlink" title="rsync中的匹配规则"></a>rsync中的匹配规则</h3><p>以下是rsync中的规则种类，不解之处请结合下文的<code>--delete</code>分析：</p><ul><li><p><code>exclude规则</code>：即<strong>排除规则</strong>，只作用于<strong>发送端</strong>，<strong>被排除的文件不会进入文件列表</strong>(实际上是加上隐藏规则进行隐藏)</p></li><li><p><code>include规则</code>：即<strong>包含规则</strong>，也称为传输规则，<strong>只作用于发送端</strong>，被包含的文件将明确记录到文件列表中</p></li><li><p><code>hide规则</code>：即<strong>隐藏规则</strong>，<strong>只作用于发送端</strong>，隐藏后的文件对于接收端来说是看不见的，<strong>也就是说接收端会认为它不存在于源端</strong></p></li><li><p><code>show规则</code>：即<strong>显示规则</strong>，<strong>只作用于发送端</strong>，<strong>是隐藏规则的反向规则</strong></p></li><li><p><code>protect规则</code>：即<strong>保护规则</strong>，该规则<strong>只作用于接收端</strong>，<strong>被保护的文件不会被删除掉</strong></p></li><li><p><code>risk规则</code>：即<strong>取消保护规则</strong>，<strong>是protect的反向规则</strong></p></li></ul><p>除此之外，还有一种规则是<code>clear规则</code>，作用是<strong>删除include/exclude规则列表</strong></p><hr><h3 id="–delete-得到和远程目录完全相同的目录"><a href="#–delete-得到和远程目录完全相同的目录" class="headerlink" title="–delete-得到和远程目录完全相同的目录"></a>–delete-得到和远程目录完全相同的目录</h3><p>使用”–delete”选项后，接收端的rsync会先删除目标目录(当前目录)下已经存在，但源端(远程)目录不存在的文件，也就是”多则删之，少则补之”：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 14:17 test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 先删除当前目录中存在但是远程目录不存在的文件，然后进行同步</span></span><br><span class="line">rsync -r --delete -v /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line">deleting <span class="built_in">test</span>/test2.txt</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"></span><br><span class="line">sent 271153227 bytes  received 51 bytes  108461311.20 bytes/sec</span><br><span class="line">total size is 271119920  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># test2.txt已经被删除</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:19 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br></pre></td></tr></table></figure><p></p><p><code>--delete</code>与<code>--exclude</code>联用，<code>--exclude</code>可以将某些文件排除在同步文件之外，而这些文件在被排除在同步文件之外后，当前目录存在的这些被排除的文件会不会被<code>--delete</code>删除是关键？结果是<mark><code>--exclude</code>排除的文件不会被<code>--delete</code>删除</mark>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:19 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 排除所有txt后缀的文件</span></span><br><span class="line"><span class="comment"># 也就是说不会对当前目录中的txt文件依据远程文件进行同步</span></span><br><span class="line">rsync -v -r --delete --exclude <span class="string">"*.txt"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"></span><br><span class="line">sent 271153093 bytes  received 32 bytes  180768750.00 bytes/sec</span><br><span class="line">total size is 271119851  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 虽然txt文件没有没同步， 但是也没有被删除</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 18:37 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于<code>--exclude</code>排除的文件不会被<code>--delete</code>删除的原理请参考<a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">这篇文章</a></p></div><p><code>--delete</code>与<code>--existing</code>和<code>--ignore-existing</code>结合使用时，<strong>文件不会被传输</strong>，<strong>但会删除receiver端额外多出的文件</strong>，<u>个人理解其过程可能是先<code>--existing</code>得到的传输文件列表中都是当前文件和远程共有的文件，再次使用<code>--ignore-existing</code>时是仅传输不存在的文件，此时的文件列表不包含当前目录不存在的文件，所以不会进行传输，<code>--delete</code>会进行删除操作</u>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">$ mkdir a b</span><br><span class="line">$ touch a/&#123;1..4&#125;.txt</span><br><span class="line">$ touch b/a.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--delete</span></span><br><span class="line">$ rsync -nrv --delete a/ b/</span><br><span class="line">sending incremental file list</span><br><span class="line">deleting a.log</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"> </span><br><span class="line">sent 118 bytes  received 33 bytes  302.00 bytes/sec</span><br><span class="line">total size is 0  speedup is 0.00 (DRY RUN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--delete并结合--existing、--ignore-existing</span></span><br><span class="line">$ rsync -nrv --existing --ignore-existing --delete a/ b/</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="comment"># 只进行了删除操作</span></span><br><span class="line">deleting a.log</span><br><span class="line"> </span><br><span class="line">sent 106 bytes  received 21 bytes  254.00 bytes/sec</span><br><span class="line">total size is 0  speedup is 0.00 (DRY RUN)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–max-size-不传输大文件"><a href="#–max-size-不传输大文件" class="headerlink" title="–max-size-不传输大文件"></a>–max-size-不传输大文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同步大于100M的文件</span></span><br><span class="line">rsync -v -t -r --max-size <span class="string">"100m"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 忽略了链接文件</span></span><br><span class="line">skipping non-regular file <span class="string">"test/test2.txt"</span></span><br><span class="line"></span><br><span class="line">sent 267 bytes  received 35 bytes  604.00 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 897748.12</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">第2章 rsync(一)：基本命令和用法</a></li><li><a href="http://man.linuxde.net/rsync" target="_blank" rel="noopener">rsync命令</a></li><li><a href="http://roclinux.cn/?p=2643" target="_blank" rel="noopener">《rsync同步的艺术》–linux命令五分钟系列之四十二</a></li><li><a href="https://www.linuxprobe.com/rsync-use-sample.html" target="_blank" rel="noopener">rsync 使用示例</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中进行&lt;strong&gt;远程数据同步的命令rsync&lt;/strong&gt;，相比于功能相近的&lt;a href=&quot;http://showteeth.tech/posts/2539.html&quot;&gt;scp命令&lt;/a&gt;，其可以实现&lt;strong&gt;增量同步&lt;/strong&gt;；主要学习了&lt;code&gt;本地目录之间的同步&lt;/code&gt;、&lt;code&gt;本地与远程之间的同步&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-R&lt;/code&gt;、&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-L&lt;/code&gt;、&lt;code&gt;--backup&lt;/code&gt;、&lt;code&gt;--backup-dir&lt;/code&gt;、&lt;code&gt;--existing&lt;/code&gt;、&lt;code&gt;--ignore-existing&lt;/code&gt;、&lt;code&gt;--remove-source-files&lt;/code&gt;、&lt;code&gt;--exclude&lt;/code&gt;、&lt;code&gt;--delete&lt;/code&gt;、&lt;code&gt;--max-size&lt;/code&gt;等参数。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>scp-跨平台复制命令</title>
    <link href="http://showteeth.tech/posts/2539.html"/>
    <id>http://showteeth.tech/posts/2539.html</id>
    <published>2019-05-01T02:16:40.000Z</published>
    <updated>2019-05-02T00:42:16.981Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中用于<strong>远程复制命令scp</strong>，其主要功能包括：<strong>复制远程文件到当前服务器文件或目录</strong>、<strong>复制远程目录到当前服务器目录</strong>、<strong>复制当前文件到远程服务器文件或目录</strong>、<strong>复制当前目录到远程目录</strong>，其中重要和常用的参数是<code>-P</code>、<code>-r</code>；<strong>需要特别注意<code>scp</code>和<code>cp</code>以及<code>rsnyc</code>命令的区别</strong>。</p></div><a id="more"></a><h2 id="scp命令简介"><a href="#scp命令简介" class="headerlink" title="scp命令简介"></a>scp命令简介</h2><p><code>scp</code>是<code>secure copy</code>的简写，用于在Linux下进行<strong>远程拷贝文件</strong>的命令，和它类似的命令有<code>cp</code>，不过 <strong><code>cp</code>只是在本机进行拷贝不能跨服务器</strong>，而且<strong>scp传输是加密的</strong>。当<strong>你服务器硬盘变为只读 <code>read only system</code>时，用scp可以帮你把文件移出来</strong>。</p><p>与<code>scp</code>命令类似的工具有<a href="http://showteeth.tech/posts/8376.html">rsync</a>，两者的功能类似，但是<strong>区别主要表现在资源占用和速度上</strong>：</p><ul><li><strong><code>scp</code>消耗资源少，不会提高多少系统负荷</strong>，在这一点上，<code>rsync</code>就远远不及它了</li><li><strong><code>rsync</code>比<code>scp</code>会快一点，但当小文件多的情况下，<code>rsync</code>会导致硬盘<code>I/O</code>非常高，而<code>scp</code>基本不影响系统正常使用</strong></li></ul><hr><h2 id="scp命令格式"><a href="#scp命令格式" class="headerlink" title="scp命令格式"></a>scp命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">Usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure><hr><h2 id="scp参数说明"><a href="#scp参数说明" class="headerlink" title="scp参数说明"></a>scp参数说明</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>-1</code></td><td>强制scp命令使用协议ssh1</td></tr><tr><td><code>-2</code></td><td>强制scp命令使用协议ssh2</td></tr><tr><td><code>-4</code></td><td>强制scp命令只使用IPv4寻址</td></tr><tr><td><code>-6</code></td><td>强制scp命令只使用IPv6寻址</td></tr><tr><td><code>-B</code></td><td>使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td><code>-C</code></td><td>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</td></tr><tr><td><strong><code>-p</code></strong></td><td>保留原文件的修改时间，访问时间和访问权限</td></tr><tr><td><code>-q</code></td><td>不显示传输进度条</td></tr><tr><td><strong><code>-r</code></strong></td><td>递归复制整个目录</td></tr><tr><td><strong><code>-v</code></strong></td><td>详细方式显示输出，scp和ssh(1)会显示出整个过程的调试信息，这些信息用于调试连接，验证和配置问题</td></tr><tr><td><code>-c</code></td><td><code>cipher</code> 以cipher将数据传输进行加密，这个选项将直接传递给ssh</td></tr><tr><td><code>-F</code></td><td><code>ssh_config</code> 指定一个替代的ssh配置文件，此参数直接传递给ssh</td></tr><tr><td><code>-i</code></td><td><code>identity_file</code> 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</td></tr><tr><td><code>-l</code></td><td><code>limit</code> 限定用户所能使用的带宽，以Kbit/s为单位</td></tr><tr><td><code>-o</code></td><td><code>ssh_option</code> 如果习惯于使用ssh_config(5)中的参数传递方式</td></tr><tr><td><code>-S</code></td><td><code>program</code> 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项</td></tr><tr><td><strong><code>-P</code></strong></td><td><code>port</code> 注意是大写的P, port是指定数据传输用到的端口号</td></tr></table><hr><h2 id="scp具体使用"><a href="#scp具体使用" class="headerlink" title="scp具体使用"></a>scp具体使用</h2><h3 id="本地到远程"><a href="#本地到远程" class="headerlink" title="本地到远程"></a>本地到远程</h3><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p><strong>命令形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用形式</span></span><br><span class="line">scp [可选参数] source_file remote_username@remote_ip:target_file_or_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中指定传输目的服务器username</span></span><br><span class="line"><span class="comment"># 复制到文件夹，文件名称保持不变</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_username@remote_ip:remote_folder</span><br><span class="line"><span class="comment"># 复制到文件，复制并改名</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_username@remote_ip:remote_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中不指定传输目的服务器username</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_ip:remote_folder</span><br><span class="line"><span class="variable">$scp</span> local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>如果<strong>在命令中指定了目的服务器的用户名</strong>，命令执行后只需要<strong>输入对应的用户密码</strong>；</li><li>如果在命令中<strong>不指定目的服务器的用户名</strong>，命令执行后<strong>默认的用户名和当前服务器的用户名相同</strong>，<strong>输入密码</strong></li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接这么写会报错</span></span><br><span class="line">scp B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp</span><br></pre></td></tr></table></figure><p>直接按照上面的写法会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host 166.111.152.101 port 22: Connection refused</span><br><span class="line">lost connection</span><br></pre></td></tr></table></figure><p></p><p>出错原因是没有指定port，而<mark>scp默认的port是22，如果端口号不是22的话就会出错</mark>，可以<strong>使用<code>-P</code>来指定端口号</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-P指定端口</span></span><br><span class="line"><span class="comment"># 如果端口不是22</span></span><br><span class="line"><span class="comment"># 复制到文件夹，文件名称保持不变</span></span><br><span class="line">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp </span><br><span class="line"><span class="comment"># 需要输入目的服务器username的密码</span></span><br><span class="line">username@166.111.152.101<span class="string">'s password:  </span></span><br><span class="line"><span class="string"># 显示传输进度 </span></span><br><span class="line"><span class="string">B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart                                                                         100%  259MB   8.6MB/s   00:30</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 复制到文件，相当于复制并且修改文件名称</span></span><br><span class="line"><span class="string">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp/test.txt</span></span><br></pre></td></tr></table></figure><p></p><p><strong>不指定目的服务器的用户名，那么默认目的服务器用户名和当前服务器用户名相同</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令中没有指定用户名</span></span><br><span class="line">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart 166.111.152.101:/home/username/learn/linux_learn/scp/test.txt</span><br><span class="line"><span class="comment"># 默认的用户名和当前服务器用户名相同</span></span><br><span class="line">local_username@166.111.152.101<span class="string">'s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># local_username和username不同，导致了权限错误</span></span><br><span class="line"><span class="string">scp: /home/username/learn/linux_learn/scp/test.txt: Permission denied</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h4><p>使用<code>-r</code>参数来进行递归复制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令中指定目的服务器的username</span></span><br><span class="line"><span class="variable">$scp</span> -r local_folder remote_username@remote_ip:remote_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在命令中指定目的服务器的username，默认和当前服务器的username相同</span></span><br><span class="line"><span class="variable">$scp</span> -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure><p></p><h3 id="远程到本地"><a href="#远程到本地" class="headerlink" title="远程到本地"></a>远程到本地</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用形式</span></span><br><span class="line"><span class="comment"># 其实就是将前面的scp后面接着的远程和本地文件换个位置</span></span><br><span class="line">scp [可选参数] remote_username@remote_ip:source_file target_file_or_folder</span><br></pre></td></tr></table></figure><h4 id="复制文件-1"><a href="#复制文件-1" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制到本地目录</span></span><br><span class="line">scp -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到本地文件，相当于复制并改名</span></span><br><span class="line">scp -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./test.txt</span><br></pre></td></tr></table></figure><hr><h4 id="复制目录-1"><a href="#复制目录-1" class="headerlink" title="复制目录"></a>复制目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-r参数来进行递归复制</span></span><br><span class="line">scp -r -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html" target="_blank" rel="noopener">scp 跨机远程拷贝</a></li><li><a href="https://www.cnblogs.com/peida/archive/2013/03/15/2960802.html" target="_blank" rel="noopener">每天一个linux命令（60）：scp命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中用于&lt;strong&gt;远程复制命令scp&lt;/strong&gt;，其主要功能包括：&lt;strong&gt;复制远程文件到当前服务器文件或目录&lt;/strong&gt;、&lt;strong&gt;复制远程目录到当前服务器目录&lt;/strong&gt;、&lt;strong&gt;复制当前文件到远程服务器文件或目录&lt;/strong&gt;、&lt;strong&gt;复制当前目录到远程目录&lt;/strong&gt;，其中重要和常用的参数是&lt;code&gt;-P&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;；&lt;strong&gt;需要特别注意&lt;code&gt;scp&lt;/code&gt;和&lt;code&gt;cp&lt;/code&gt;以及&lt;code&gt;rsnyc&lt;/code&gt;命令的区别&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>read-从键盘或文件中获取输入</title>
    <link href="http://showteeth.tech/posts/59492.html"/>
    <id>http://showteeth.tech/posts/59492.html</id>
    <published>2019-04-30T14:06:36.000Z</published>
    <updated>2019-05-01T02:14:08.525Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><code>read</code>是linux中<strong>获取键盘或文件输入</strong>并将<strong>结果保存在若干变量或数组中的命令</strong>，其主要参数包括：<code>-p</code>、<code>-a</code>、<code>-d</code>、<code>-e</code>、<code>-i</code>、<code>-s</code>、<code>-t</code>、<code>-n</code>、<code>-r</code>、<code>-u</code>；需要特别注意这里学习的关于<strong>使用管道符读取文件</strong>时涉及到的<strong>自定义变量生命周期</strong>的问题。</p></div><a id="more"></a><h2 id="read命令简介"><a href="#read命令简介" class="headerlink" title="read命令简介"></a>read命令简介</h2><p><code>read</code>命令可以<strong>获取键盘或者文件输入</strong>并<strong>赋值给变量或数组</strong>。</p><hr><h2 id="read命令格式"><a href="#read命令格式" class="headerlink" title="read命令格式"></a>read命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage: </span><br><span class="line">  <span class="built_in">read</span> [-ers] [-a array] [-d delim] </span><br><span class="line">       [-i text] [-n nchars] [-N nchars] </span><br><span class="line">       [-p prompt] [-t timeout] [-u fd] [name ...]</span><br></pre></td></tr></table></figure><hr><h2 id="read参数说明"><a href="#read参数说明" class="headerlink" title="read参数说明"></a>read参数说明</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>-a</code></td><td>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符</td></tr><tr><td><code>-d</code></td><td>后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。</td></tr><tr><td><code>-p</code></td><td>后面跟提示信息，即在输入前打印提示信息。</td></tr><tr><td><code>-e</code></td><td>在输入的时候可以使用命令补全功能。</td></tr><tr><td><code>-i</code></td><td>设置默认用于补全的prefix，必须和前面的<code>-e</code>一同使用才有用</td></tr><tr><td><code>-n</code></td><td>后跟一个数字，定义输入文本的长度，很实用。</td></tr><tr><td><code>-r</code></td><td>屏蔽<code>\</code>，如果没有该选项，则<code>\</code>作为一个转义字符(续行)，有的话<code>\</code>就是个正常的字符了。</td></tr><tr><td><code>-s</code></td><td>安静模式，在输入字符时不在屏幕上显示，例如login时输入密码。</td></tr><tr><td><code>-t</code></td><td>后面跟秒数，定义输入字符的等待时间。</td></tr><tr><td><code>-u</code></td><td>后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</td></tr></table><hr><h2 id="read用法实例"><a href="#read用法实例" class="headerlink" title="read用法实例"></a>read用法实例</h2><h3 id="默认读取"><a href="#默认读取" class="headerlink" title="默认读取"></a>默认读取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下echo输出内容之后会换行</span></span><br><span class="line"><span class="comment"># -n参数可以不换行</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"please input your name:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取键盘输入，并保存在name变量中</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出变量并正常退出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line">  please input your name:<span class="built_in">test</span></span><br><span class="line">  welcome !!! <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>如果在read之后<strong>没有使用参数进行接收键盘输入</strong>，则读取的值会<strong>存放在一个叫作 <code>$REPLY</code> 的环境变量中</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 没有指定接收键盘输入的变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name and place:"</span></span><br><span class="line"><span class="comment"># 默认会存放在$REPLY中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome <span class="variable">$REPLY</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh test_2.sh </span><br><span class="line"><span class="comment"># 还是能正常输出</span></span><br><span class="line">please input your name and place:<span class="built_in">test</span></span><br><span class="line">welcome <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="p-输入提示语"><a href="#p-输入提示语" class="headerlink" title="-p-输入提示语"></a>-p-输入提示语</h3><p>上面为了达到输入提示语的效果借助了<code>echo</code>命令，其实<code>read</code>命令的参数<code>-p</code>可以起到<strong>输入提示语</strong>的效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo  -n "please input your name:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p参数替换echo进行输入提示</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name:"</span>  name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 效果和使用echo是一样的</span></span><br><span class="line">  please input your name:<span class="built_in">test</span></span><br><span class="line">  welcome !!! <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="一次读入多个变量"><a href="#一次读入多个变量" class="headerlink" title="一次读入多个变量"></a>一次读入多个变量</h3><p>变量的数目是根据read定义的变量数目决定的：</p><ul><li>read后面变量数目等于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read后面有两格变量name和city，所以可以读取两个变量</span></span><br><span class="line"><span class="comment"># 使用空格分隔变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name and city: "</span>  name city</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span> from <span class="variable">$city</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入两个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 传递给name和city变量</span></span><br><span class="line">  please input your name and city: <span class="built_in">test</span> beijing</span><br><span class="line">  welcome !!! <span class="built_in">test</span> from beijing</span><br></pre></td></tr></table></figure><p></p><ul><li>read后面变量数目小于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入三个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 第一个空格分隔的字符传递给name，剩下的传递给另一个变量</span></span><br><span class="line">please input your name and city: <span class="built_in">test</span> beijing haidian</span><br><span class="line">welcome !!! <span class="built_in">test</span> from beijing haidian</span><br></pre></td></tr></table></figure><ul><li>read后面变量数目大于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入一个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 字符传递给第一个变量name，剩下的变量为空</span></span><br><span class="line">please input your name and city: <span class="built_in">test</span></span><br><span class="line">welcome !!! <span class="built_in">test</span> from</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>如果read后面的参数数目<strong>等于</strong>键盘输入的空格分隔的字符数目，则<strong>参数和输入一一对应</strong></li><li>如果read后面的参数数目<strong>大于</strong>键盘输入的空格分隔的字符数目，则<strong>不足的参数为空</strong></li><li>如果read后面的参数数目<strong>小于</strong>键盘输入的空格分隔的字符数目，则<strong>多余的空格分隔的字符赋值在最后一个变量</strong></li></ul></div><hr><h3 id="a-数组变量"><a href="#a-数组变量" class="headerlink" title="-a-数组变量"></a>-a-数组变量</h3><p>默认情况下，read将读取的字符存储在不同的变量中，如果想要储存在<a href="http://showteeth.tech/posts/46714.html">数组</a>中，可以使用-a参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -a参数后面是指定的存储数组的变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"get var by array: "</span> -a  array</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"print <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh a.sh </span><br><span class="line">  get var by array: as ad af</span><br><span class="line">  <span class="built_in">print</span> as</span><br><span class="line">  <span class="built_in">print</span> ad</span><br><span class="line">  <span class="built_in">print</span> af</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="d-指定读取结束字符"><a href="#d-指定读取结束字符" class="headerlink" title="-d-指定读取结束字符"></a>-d-指定读取结束字符</h3><p>如果希望使用特定的字符来控制读取停止位置，可以使用-d参数，注意之后-d后面指定字符的第一个字符有用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里-d参数指定了end字符</span></span><br><span class="line"><span class="comment"># 其实只有开头的e起到作用了</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"get var by array: "</span> -d end -a array</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"print <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh d.sh </span><br><span class="line"><span class="comment"># 输入的时候遇到e字符就会停止接收</span></span><br><span class="line"><span class="comment"># 然后直接执行后面的输出</span></span><br><span class="line">get var by array: ads ada eprint ads</span><br><span class="line"><span class="built_in">print</span> ada</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="t-输入等待时间"><a href="#t-输入等待时间" class="headerlink" title="-t-输入等待时间"></a>-t-输入等待时间</h3><p>设置输入等待时间，如果长时间不输入，read命令返回一个<strong>非零退出状态</strong>，可以结合<code>if</code>命令进行处理：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -t 5 -p <span class="string">"please input your name within 5s:"</span> name</span><br><span class="line"><span class="comment"># 输出read命令的退出状态</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"></span><br><span class="line"><span class="comment"># if命令本来就是判断条件测试语句的退出状态</span></span><br><span class="line"><span class="comment"># 如果非零则执行else的结果</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">"please input your name within 5s:"</span> name</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"sorry, too slow"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test_t.sh </span><br><span class="line"><span class="comment"># 不进行输入，返回退出状态为142</span></span><br><span class="line">please input your name within 5s:142</span><br><span class="line"><span class="comment"># 使用if条件测试进行处理，输出自定义的内容</span></span><br><span class="line">please input your name within 5s:sorry, too slow</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-输入内容不显示"><a href="#s-输入内容不显示" class="headerlink" title="-s-输入内容不显示"></a>-s-输入内容不显示</h3><p>默认的read会将输入显示在屏幕上，而在输入时可能会遇到一些信息不希望被人看到，这时可以使用<code>-s</code>参数(实际上，数据是显示的，只是 read 命令将<strong>文本颜色设置成与背景相同的颜色</strong>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 使用-s参数来不显示屏幕输入内容</span></span><br><span class="line"><span class="built_in">read</span> -s -p <span class="string">"please input your code:"</span> password</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hehe, your password is <span class="variable">$password</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test_s.sh </span><br><span class="line"><span class="comment"># 注意这里不会换行</span></span><br><span class="line">please input your code:hehe, your password is <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-输入字符长度"><a href="#n-输入字符长度" class="headerlink" title="-n-输入字符长度"></a>-n-输入字符长度</h3><p>read可以使用-n参数来控制读取的输入字符长度，当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -n 1 -p <span class="string">"Do you want to continue [Y/N]?"</span> answer</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span></span><br><span class="line">Y | y)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"fine ,continue"</span>;;</span><br><span class="line">N | n)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"ok,good bye"</span>;;</span><br><span class="line">*)</span><br><span class="line">     <span class="built_in">echo</span> <span class="string">"error choice"</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./n.sh </span><br><span class="line"><span class="comment"># 本来准备输入yes，但是输入y之后就默认指定后面的echo命令</span></span><br><span class="line"><span class="comment"># 压根没有给输入yes的可能性</span></span><br><span class="line">Do you want to <span class="built_in">continue</span> [Y/N]?yfine ,<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>输入长度达到<code>-n</code>指定的长度之后<strong>立即停止接受输入</strong>，并<strong>执行后续的命令</strong>，<strong>不管是不是还在输入</strong>.</p></div><hr><h3 id="u-读取文件内容"><a href="#u-读取文件内容" class="headerlink" title="-u-读取文件内容"></a>-u-读取文件内容</h3><p>读取文件内容常常使用在循环中：</p><ul><li>使用文件操作符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成了编号为 3 的文件描述符</span></span><br><span class="line"><span class="comment"># 这个编号可以自定义，默认的1和2分别为标准输出和标准错误输出</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt; test.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用-u 3来读取文件内容</span></span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -u 3 var</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 使用了命令计算并赋值</span></span><br><span class="line">        <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭3号文件描述符</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&amp;-</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./u_1.sh </span><br><span class="line">  Line 1:19248</span><br><span class="line">  Line 2:19247</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 3</span><br></pre></td></tr></table></figure><p></p><ul><li>使用管道：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="comment"># 这里使用了管道而不是上面的文件描述符</span></span><br><span class="line"><span class="comment"># 使用更为简单</span></span><br><span class="line">cat test.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sh u_2.sh </span><br><span class="line">  Line 1:19248</span><br><span class="line">  Line 2:19247</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  <span class="comment"># 注意这里的line的计数为1，而不是3</span></span><br><span class="line">  Line no is 1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>上面最后<strong>输出的line计数为1而不是实际的3</strong>是由于管道导致的。我们知道，<strong>管道的两边一般需要新建进程</strong>，当执行完 while 语句后，新进程也就结束了，而脚本中 count 是新进程中的自定义变量，<strong>进程结束后该变量也就消失了（自定义变量的生命周期结束）</strong>。当脚本<strong>执行 echo 时，显示的 count 变量是脚本中第一行定义的变量的值，而不是 while 语句中的那个 count 变量了</strong>，因而输出的结果当然就是 1 了。</p></div><ul><li>重定向：</li></ul><p>为了使用简单(不使用文件描述符)，而又需要避免管道带来的问题，可以使用重定向：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line"><span class="comment"># 这里使用了重定向，形式为cmd &lt; file</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line 1:19248</span><br><span class="line">Line 2:19247</span><br><span class="line">Line 3:19246</span><br><span class="line">finished</span><br><span class="line"><span class="comment"># 这里输出了正确的结果3</span></span><br><span class="line">Line no is 3</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="r-屏蔽转移和续行"><a href="#r-屏蔽转移和续行" class="headerlink" title="-r-屏蔽转移和续行"></a>-r-屏蔽转移和续行</h3><p>常规情况下，在文件中使用<code>\</code>可以表示续行操作，这样在读取文件的时候也会将其当做续行符，从而将多行文本当成一行文本：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改test.txt文件，加入续行符</span></span><br><span class="line">cat test.txt </span><br><span class="line">  19248 \</span><br><span class="line">  19247 \</span><br><span class="line">  19246</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行前面的读取文件命令</span></span><br><span class="line">sh u_3.sh </span><br><span class="line">  <span class="comment"># 读取的结果都在同一行</span></span><br><span class="line">  Line 1:19248 19247 19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 1</span><br></pre></td></tr></table></figure><p></p><p>如果需要忽略续行符<code>\</code>，可以使用read的<code>-r</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=0</span><br><span class="line"><span class="comment"># 加入-r参数表示忽略续行符</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line"><span class="comment"># 这里使用了重定向，形式为cmd &lt; file</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sh u_4.sh </span><br><span class="line">  <span class="comment"># 忽略了续行符</span></span><br><span class="line">  <span class="comment"># 当做3行读取</span></span><br><span class="line">  Line 1:19248 \</span><br><span class="line">  Line 2:19247 \</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 3</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="e-输入补全"><a href="#e-输入补全" class="headerlink" title="-e-输入补全"></a>-e-输入补全</h3><p>在输入时进行tab补全功能：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -e -p <span class="string">"输入文件名:"</span> str </span><br><span class="line">输入文件名:<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 上面输入test之后按下两次tab键就可以输出当前目录下匹配test的文件信息</span></span><br><span class="line">test.sh    test_s.sh  test_t.sh  test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="i-设置默认用于补全的prefix"><a href="#i-设置默认用于补全的prefix" class="headerlink" title="-i-设置默认用于补全的prefix"></a>-i-设置默认用于补全的prefix</h3><p>如果需要给变量设置<strong>默认用于补全的prefix</strong>，自动进行填充，需要使用read的<code>-i</code>参数，注意这<strong>个必须结合<code>-e</code>参数进行使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认的prefix</span></span><br><span class="line"><span class="comment"># 自动填充到输入，再结合tab进行补全</span></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"test"</span></span><br><span class="line"><span class="comment"># -i必须结合-e参数一同使用</span></span><br><span class="line"><span class="built_in">read</span> -e -i <span class="string">"<span class="variable">$test</span>"</span> -p <span class="string">"please input your name: "</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh i.sh </span><br><span class="line"><span class="comment"># 与前面单独使用-e不同的是，这里的test是自动填充的prefix</span></span><br><span class="line">please input your name: <span class="built_in">test</span></span><br><span class="line">test.sh    test_s.sh  test_t.sh  test.txt</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.runoob.com/linux/linux-comm-read.html" target="_blank" rel="noopener">Linux read 命令</a></li><li><a href="http://c.biancheng.net/linux/read.html" target="_blank" rel="noopener">read命令_Linux read命令：读取从键盘或文件输入的数据</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;read&lt;/code&gt;是linux中&lt;strong&gt;获取键盘或文件输入&lt;/strong&gt;并将&lt;strong&gt;结果保存在若干变量或数组中的命令&lt;/strong&gt;，其主要参数包括：&lt;code&gt;-p&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;；需要特别注意这里学习的关于&lt;strong&gt;使用管道符读取文件&lt;/strong&gt;时涉及到的&lt;strong&gt;自定义变量生命周期&lt;/strong&gt;的问题。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>time-计算命令执行花费的时间</title>
    <link href="http://showteeth.tech/posts/21450.html"/>
    <id>http://showteeth.tech/posts/21450.html</id>
    <published>2019-04-25T15:22:52.000Z</published>
    <updated>2019-04-25T16:18:08.781Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>计算命令执行花费的时间</strong>的命令<code>time</code>，其输出包括三个时间<code>real</code>、<code>user</code> 和 <code>sys</code>，其中real是最终花费的时间；一般情况下<code>real=user+sys</code>，但如果命令是多核执行，也有可能是<code>real_time&lt;user_time+sys_time</code>，同时由于<code>usr time+sys time</code><strong>不包括其他进程的执行时间和进程阻塞时间的</strong>，所以<code>real_time&gt;user_time+sys_time</code>也是非常有可能的；最后<strong>前后两次执行同一个命令，输出的时间可能不同</strong>，这是因为<strong>第一次执行命令系统会建立缓存</strong>使得第二次执行的时间缩短。</p></div><a id="more"></a><h2 id="time命令简介"><a href="#time命令简介" class="headerlink" title="time命令简介"></a>time命令简介</h2><p>time命令用于统计执行指定命令所花费的总时间。</p><hr><h2 id="time命令格式"><a href="#time命令格式" class="headerlink" title="time命令格式"></a>time命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time <span class="built_in">command</span></span><br></pre></td></tr></table></figure><hr><h2 id="time使用讲解"><a href="#time使用讲解" class="headerlink" title="time使用讲解"></a>time使用讲解</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time ls</span><br><span class="line">test1.txt  test2.txt</span><br><span class="line"></span><br><span class="line">real0m0.002s</span><br><span class="line">user0m0.001s</span><br><span class="line">sys0m0.001s</span><br></pre></td></tr></table></figure><p>执行<code>time ls</code>之后会得到三个输出，<code>real</code>、<code>user</code> 和 <code>sys</code>，它们都代表什么含义呢？哪个才是 <code>ls</code> 命令的执行时间呢？下面我们就一起来看看这三个统计时间：</p><ul><li><code>real</code>：<strong>从进程 <code>ls</code> 开始执行到完成所耗费的 CPU 总时间</strong>。该时间包括 <strong><code>ls</code> 进程执行时实际使用的 CPU 时间</strong>，<strong><code>ls</code> 进程耗费在阻塞上的时间（如等待完成 I/O 操作）</strong>和<strong>其他进程所耗费的时间（Linux 是多进程系统，ls 在执行过程中，可能会有别的进程抢占 CPU）</strong>。</li><li><code>user</code>：进程 <code>ls</code> 执行<mark>用户态</mark>代码所耗费的 CPU 时间。该时间<strong>仅指 ls 进程执行时实际使用的 CPU 时间</strong>，而<strong>不包括其他进程所使用的时间和本进程阻塞的时间</strong>。</li><li><code>sys</code>：进程 <code>ls</code> 在<mark>内核态</mark>运行所耗费的 CPU 时间，即<strong>执行内核系统调用所耗费的 CPU 时间</strong>。</li></ul><div class="note info"><p>关于<strong>用户态</strong>和<strong>内核态</strong>：</p><ul><li>在内核态，代码拥有完全的，不受任何限制的访问底层硬件的能力。可以执行任意的CPU指令，访问任意的内存地址。内核态通常情况下，都是为那些最底层的，由操作系统提供的，可信可靠的代码来运行的。内核态的代码崩溃将是灾难性的，它会影响到整个系统。</li><li>在用户态，代码不具备直接访问硬件或者访问内存的能力，而必须借助操作系统提供的可靠的，底层的APIs来访问硬件或者内存。由于这种隔离带来的保护作用，用户态的代码崩溃（Crash），系统是可以恢复的。我们大多数的代码都是运行在用户态的。</li></ul></div><p>现在，我们应该对这三个时间非常清楚了吧。<code>ls</code> 命令的真正执行时间是多少？答案就是 <code>user+sys</code> 的时间，但<mark>一般情况下</mark>，<code>real=user+sys</code>，因而我们就<strong>使用 <code>real</code> 的时间作为 <code>ls</code> 的执行时间了</strong>（注意，<strong>这里会有几个坑，我们将在后面进行介绍</strong>）。</p><hr><h2 id="几个误区及解释"><a href="#几个误区及解释" class="headerlink" title="几个误区及解释"></a>几个误区及解释</h2><h3 id="real-time-user-time-sys-time"><a href="#real-time-user-time-sys-time" class="headerlink" title="real_time=user_time+sys_time"></a>real_time=user_time+sys_time</h3><p>如果你认为上面的等式一定成立的话，那么请你再理解一下前面关于 <code>real</code>、<code>user</code>和 <code>sys</code> 的介绍。在前面的表述中，<code>real time</code> 是<strong>包含了其他进程的执行时间和进程阻塞时间的</strong>，而 <code>usr time+sys time</code> 显然是<strong>不包括其他进程的执行时间和进程阻塞时间的</strong>。因此，<code>real_time&gt;user_time+sys_time</code>是非常有可能的。</p><hr><h3 id="real-time-gt-user-time-sys-time"><a href="#real-time-gt-user-time-sys-time" class="headerlink" title="real_time&gt;user_time+sys_time"></a>real_time&gt;user_time+sys_time</h3><p>根据上面的分析，这个关系式应该是成立的吧？嘿嘿，不一定哟。一般来说，在<strong>单核 CPU 系统</strong>中，<strong>这个关系式是成立的</strong>，但如果我们的系统是<strong>多核 CPU</strong> 的话，而有些程序是能够<strong>同时利用到多核 CPU 的计算能力的</strong>，在这种情况下这个关系式就不成立了。</p><p>程序利用<strong>多核 CPU 的计算能力</strong>，可以并行地处理多项事务。就像一件工作，原来是一个 CPU 核去做，现在是两个 CPU 核并行做，那么完成同样工作所花费的总时间是 <code>user_time+sys_time</code>，而两个人并行做却能够在更短的时间内完成，耗时为 <code>real_time</code>。因此，这种情况下，便出现了 <code>real_time&lt;user_time+sys_time</code> 的情况。</p><hr><h3 id="real-time-lt-user-time-sys-time"><a href="#real-time-lt-user-time-sys-time" class="headerlink" title="real_time&lt;user_time+sys_time"></a>real_time&lt;user_time+sys_time</h3><p>多核情况下，<code>real_time&lt;user_time+sys_time</code> 是成立的，那单核呢？显然<code>real_time&gt;user_time+sys_time</code>是有可能成立的。</p><p>上面的三个误区有点绕，但结论很重要，就是 <code>real_time</code> 和 <code>user_time+sys_time</code> 的<strong>大小关系不是恒久不变的</strong>，你需要了解你的 Linux 服务器，<strong>是单核</strong>，<strong>还是多核</strong>，这样才能正确地确定它们的关系。</p><hr><h2 id="前后执行同样命令时间不同"><a href="#前后执行同样命令时间不同" class="headerlink" title="前后执行同样命令时间不同"></a>前后执行同样命令时间不同</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次执行</span></span><br><span class="line">[roc@roclinux ~]$ time sudo find / -name mysql.sh</span><br><span class="line">  /etc/profile.d/mysql.sh</span><br><span class="line">  </span><br><span class="line">  real    0m6.776s</span><br><span class="line">  user    0m1.101s</span><br><span class="line">  sys 0m1.363s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次执行</span></span><br><span class="line">[roc@roclinux ~]$ time sudo find / -name mysql.sh</span><br><span class="line">/etc/profile.d/mysql.sh</span><br><span class="line"> </span><br><span class="line">  real    0m3.059s</span><br><span class="line">  user    0m1.189s</span><br><span class="line">  sys 0m1.435s</span><br></pre></td></tr></table></figure><p>咦，怎么 <code>real</code> 的时间缩减到了 3.059 秒了，生生<strong>少了 3 秒多钟</strong>，这又是怎么回事呢？<strong>为什么同样的命令在第二次执行时快这么多呢？</strong></p><p>这个现象<strong>跟 Linux 操作系统的运行原理有关</strong>，<mark><code>find</code> 命令在第一次执行后，系统会对一些文件做缓存，在第二次执行时，就正好使用到了这些缓存中的数据，因此执行速度就变快了很多</mark>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/time.html" target="_blank" rel="noopener">time命令_Linux time命令：测量命令的执行时间或者系统资源的使用情况</a></li><li><a href="https://codingstandards.iteye.com/blog/798788" target="_blank" rel="noopener">我使用过的Linux命令之time - 测定一个命令的资源使用情况</a></li><li><a href="http://man.linuxde.net/time" target="_blank" rel="noopener">time命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;计算命令执行花费的时间&lt;/strong&gt;的命令&lt;code&gt;time&lt;/code&gt;，其输出包括三个时间&lt;code&gt;real&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;sys&lt;/code&gt;，其中real是最终花费的时间；一般情况下&lt;code&gt;real=user+sys&lt;/code&gt;，但如果命令是多核执行，也有可能是&lt;code&gt;real_time&amp;lt;user_time+sys_time&lt;/code&gt;，同时由于&lt;code&gt;usr time+sys time&lt;/code&gt;&lt;strong&gt;不包括其他进程的执行时间和进程阻塞时间的&lt;/strong&gt;，所以&lt;code&gt;real_time&amp;gt;user_time+sys_time&lt;/code&gt;也是非常有可能的；最后&lt;strong&gt;前后两次执行同一个命令，输出的时间可能不同&lt;/strong&gt;，这是因为&lt;strong&gt;第一次执行命令系统会建立缓存&lt;/strong&gt;使得第二次执行的时间缩短。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>xargs-给其他命令传递参数</title>
    <link href="http://showteeth.tech/posts/30003.html"/>
    <id>http://showteeth.tech/posts/30003.html</id>
    <published>2019-04-25T06:30:08.000Z</published>
    <updated>2019-04-25T15:14:15.630Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了非常强大的能<strong>给其他命令传递参数的命令</strong><code>xargs</code>，需要特别注意的是<code>xargs</code><strong>传递的是后一个命令的参数</strong>，而<code>管道符</code><strong>传递的是前一个命令的结果，一个字符串而已</strong>；主要学习了<code>-a</code>、<code>-d</code>、<code>-n</code>、<code>-I</code>、<code>-t</code>、<code>-p</code>、<code>-L</code>等参数，同时也学习了<strong>其与<code>find</code>命令结合进行很多很强大的操作</strong>！</p></div><a id="more"></a><h2 id="xargs命令简介"><a href="#xargs命令简介" class="headerlink" title="xargs命令简介"></a>xargs命令简介</h2><ul><li><code>xargs</code> 是<strong>给命令传递参数</strong>的一个过滤器，也是<strong>组合多个命令</strong>的一个工具，其能够捕获一个命令的输出，然后传递给另外一个命令</li><li><code>xargs</code> 可以<strong>将管道或标准输入（stdin）数据转换成命令行参数</strong>，也<strong>能够从文件的输出中读取数据</strong></li><li><code>xargs</code> 也可以<strong>将单行或多行文本输入转换为其他格式</strong>，例如<strong>多行变单行</strong>，<strong>单行变多行</strong></li><li><code>xargs</code> 默认的命令是 <code>echo</code>，这意味着通过管道传递给 <code>xargs</code> 的输入将会包含换行和空白，不过通过 <code>xargs</code> 的处理，换行和空白将被空格取代</li><li><code>xargs</code> 一般是和管道一起使用</li></ul><hr><h2 id="xargs和管道符"><a href="#xargs和管道符" class="headerlink" title="xargs和管道符"></a>xargs和管道符</h2><p>通过上述功能的总结可以发现其实xargs命令和管道符的作用比较类似，两者都能够组合命令，但是两者在有些地方也存在区别或者不适用的地方，下面以cat命令为例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"><span class="comment"># 测试文件1 </span></span><br><span class="line">  I am test1 file</span><br><span class="line">cat test2.txt </span><br><span class="line"><span class="comment"># 测试文件2</span></span><br><span class="line">  I am test2 file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用管道查看test1.txt的内容</span></span><br><span class="line"><span class="built_in">echo</span> test1.txt |cat -</span><br><span class="line"><span class="comment"># 输出的就是前面echo的结果</span></span><br><span class="line">  test1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而使用xargs</span></span><br><span class="line"><span class="built_in">echo</span> test1.txt |xargs cat -</span><br><span class="line"><span class="comment"># 可以查看test.txt的具体内容</span></span><br><span class="line">  I am test1 file</span><br></pre></td></tr></table></figure><p></p><p>总结一下关于管道符和<code>xargs</code>：</p><ul><li><strong>管道符</strong>：把前一个命令<strong>原本要输出到屏幕的标准正常数据</strong>当作是<strong>后一个命令的标准输入</strong></li><li><code>xargs</code>:将前一个命令的标准输出传递给下一个命令，<strong>作为它的参数</strong></li><li>可以发现，<mark>两者最主要的区别是，管道符处理的是直接前一个命令的结果(字符串)，而xargs是将前一个命令的结果作为参数</mark>，可以通过上面的示例感受一下</li><li>一些需要<strong>处理文件名的命令</strong>，如<code>rm</code>、<code>cp</code>、<code>mv</code>等命令就需要使用<code>xargs</code>，而另一些可以<strong>直接处理具体文本内容的</strong>，就可以直接使用管道符，例如<code>grep</code></li></ul><hr><h2 id="xargs命令格式"><a href="#xargs命令格式" class="headerlink" title="xargs命令格式"></a>xargs命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  xargs [OPTION]... COMMAND INITIAL-ARGS...</span><br><span class="line">  <span class="comment"># 注意，后面的command是在xargs的参数后面</span></span><br><span class="line">  front-command | xargs -option later-command</span><br><span class="line"></span><br><span class="line">Run COMMAND with arguments INITIAL-ARGS and more arguments <span class="built_in">read</span> from input.</span><br></pre></td></tr></table></figure><hr><h2 id="xargs命令参数"><a href="#xargs命令参数" class="headerlink" title="xargs命令参数"></a>xargs命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-0</code></td><td><code>--null</code></td><td>Items are separated by a null(<code>'\0'</code>), not whitespace</td></tr><tr><td><code>-a</code></td><td><code>--arg-file=FILE</code></td><td>从文件读取参数，而不是标准输入</td></tr><tr><td><code>-d</code></td><td><code>--delimiter=CHARACTER</code></td><td>自定义参数定界符</td></tr><tr><td><code>-E END</code></td><td></td><td>END出现位置之后的参数都会被忽略</td></tr><tr><td><code>-I R</code></td><td></td><td>same as --replace=R (R must be specified)</td></tr><tr><td><code>-i</code></td><td><code>--replace=[R]</code></td><td>当xargs command 后有多个参数时，调整参数位置，R默认是<code>{}</code></td></tr><tr><td><code>-L,-l</code></td><td><code>--max-lines=MAX-LINES</code></td><td>从标准输入一次读取 num 行送给 command 命令</td></tr><tr><td><code>-n</code></td><td><code>--max-args=MAX-ARGS</code></td><td>指定一次处理的参数个数</td></tr><tr><td><code>-P</code></td><td><code>--max-procs=MAX-PROCS</code></td><td>修改最大的进程数，默认是1，为0时候为as many as it can</td></tr><tr><td><code>-p</code></td><td><code>--interactive</code></td><td>当每次执行一个argument的时候询问一次用户</td></tr><tr><td><code>-r</code></td><td>--no-run-if-empty</td><td>当xargs的输入为空的时候则停止xargs，不加这个参数会至少执行一次</td></tr><tr><td><code>-s</code></td><td><code>--max-chars=MAX-CHARS</code></td><td>xargs 后面那个命令的最大命令行字符数(包括命令的长度、参数的长度等)</td></tr><tr><td></td><td><code>--show-limits</code></td><td>Show limits on command-line length.</td></tr><tr><td><code>-t</code></td><td><code>--verbose</code></td><td>Print commands before executing them</td></tr></table><hr><h2 id="xargs使用实例"><a href="#xargs使用实例" class="headerlink" title="xargs使用实例"></a>xargs使用实例</h2><h3 id="a-从文件中读取参数"><a href="#a-从文件中读取参数" class="headerlink" title="-a-从文件中读取参数"></a>-a-从文件中读取参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">""</span> |xargs -a test1.txt </span><br><span class="line"><span class="comment"># 从文件中读取参数</span></span><br><span class="line">I am test1 file</span><br></pre></td></tr></table></figure><hr><h3 id="d-设置参数定界符"><a href="#d-设置参数定界符" class="headerlink" title="-d-设置参数定界符"></a>-d-设置参数定界符</h3><p>默认情况下<code>xargs</code>将其标准输入中的内容以<strong>空白(包括空格、Tab、回车换行等)分割</strong>成多个之后当作命令行参数传递给其后面的命令，也可以通过<code>-d</code>参数指定：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'11@22@33'</span> | xargs</span><br><span class="line"><span class="comment"># xargs默认命令是echo</span></span><br><span class="line"><span class="comment"># 等同于echo '11@22@33' | xargs echo</span></span><br><span class="line">  11@22@33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置定界符为@</span></span><br><span class="line"><span class="comment"># 注意echo命令要在xargs参数的后面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'11@22@33'</span> | xargs -d <span class="string">"@"</span> <span class="built_in">echo</span></span><br><span class="line">11 22 33</span><br><span class="line"><span class="comment"># 这个会有一个空行，不知道为什么</span></span><br><span class="line"><span class="comment"># 如果不加-d参数就不会出现空行</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-每次处理的参数个数"><a href="#n-每次处理的参数个数" class="headerlink" title="-n-每次处理的参数个数"></a>-n-每次处理的参数个数</h3><p>默认情况下，<code>xargs</code>后面的命令一次会处理所有的参数，可以通过-n参数指定每次处理的参数个数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1 2 3 4 5 6 7 8 9"</span> |xargs -n 3</span><br><span class="line"><span class="comment"># 每次输出3个</span></span><br><span class="line">  1 2 3</span><br><span class="line">  4 5 6</span><br><span class="line">  7 8 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的执行过程等价于</span></span><br><span class="line"><span class="built_in">echo</span> 1 2 3</span><br><span class="line"><span class="built_in">echo</span> 4 5 6</span><br><span class="line"><span class="built_in">echo</span> 7 8 9</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="E-指定停止解析参数字符"><a href="#E-指定停止解析参数字符" class="headerlink" title="-E-指定停止解析参数字符"></a>-E-指定停止解析参数字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定停止解析参数字符为33</span></span><br><span class="line"><span class="comment"># 包括33在内的后续字符都不会作为参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 33 44"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22</span><br></pre></td></tr></table></figure><p>注意，是完全以<code>-E</code>指定的停止解析字符<strong>完全相同</strong>才可以：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含233以及33，最终会在33的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 233 44 33 55 66"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22 233 44</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含332以及33，最终会在33的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 332 44 33 55 66"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22 332 44</span><br></pre></td></tr></table></figure><p></p><p>注意，如果<strong>同时指定了<code>-d</code>参数</strong>，<strong>则<code>-E</code>参数会失效</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定-d的同时指定-E</span></span><br><span class="line"><span class="comment"># -E失效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 33 44 "</span> | xargs -d <span class="string">" "</span> -E <span class="string">"33"</span></span><br><span class="line">11 22 33 44 </span><br><span class="line"><span class="comment"># 这里会出现一个空行</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="I-调整参数位置"><a href="#I-调整参数位置" class="headerlink" title="-I-调整参数位置"></a>-I-调整参数位置</h3><p>如果<code>xargs</code>后面的命令需要多个参数时，可以使用<code>-I</code>来<strong>指定替换字符串</strong>，并<strong>将其放在合适的位置</strong>，这个<strong>替换字符串在 <code>xargs</code> 扩展时会被替换掉</strong>，当 <code>-I</code> 与 <code>xargs</code> 结合使用，<strong>每一个参数命令都会被执行一次</strong>，例如将当前目录下所有的文件复制到另一个目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先这个任务直接使用管道符是不能完成的</span></span><br><span class="line">ls *.txt|cp - ../csplit/</span><br><span class="line">  cp: cannot <span class="built_in">stat</span> ‘-’: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果直接使用xargs会报错</span></span><br><span class="line"><span class="comment"># 默认是将前一个参数的结果放在了最后，而txt不是一个目录</span></span><br><span class="line"><span class="comment"># 所以报错</span></span><br><span class="line">ls *.txt|xargs cp  ../csplit/</span><br><span class="line">  cp: target ‘test2.txt’ is not a directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的用法</span></span><br><span class="line"><span class="comment"># 使用-I参数指定&#123;&#125;为替换字符串</span></span><br><span class="line"><span class="comment"># 在cp命令中使用&#123;&#125;指代xargs传递给cp的参数</span></span><br><span class="line">ls *.txt | xargs -I &#123;&#125;  cp &#123;&#125; ../csplit/</span><br><span class="line"><span class="comment"># 指定@为替换字符串</span></span><br><span class="line">ls *.txt | xargs -I @  cp @ ../csplit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令之前先显示命令</span></span><br><span class="line">ls *.txt | xargs -t -I @  cp @ ../csplit/</span><br><span class="line">cp test1.txt ../csplit/ </span><br><span class="line">cp test2.txt ../csplit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于使用-i，只是-i有默认值，而-I没有默认值，必须要指定</span></span><br><span class="line"><span class="comment"># -i默认就是&#123;&#125;，但是使用-I一定要加上&#123;&#125;</span></span><br><span class="line">ls *.txt | xargs -i  cp &#123;&#125; ../csplit/</span><br></pre></td></tr></table></figure><p></p><p><strong>还可以使用多次替换符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给所有的文件重命名</span></span><br><span class="line"><span class="comment"># 加上后缀</span></span><br><span class="line">ls *.txt |xargs -I &#123;&#125; mv &#123;&#125; &#123;&#125;.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上前缀</span></span><br><span class="line">ls *.bak |xargs -I &#123;&#125; mv &#123;&#125; test_&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-I(-i)</code>参数在命令需要多个参数且参数位置有限制时很适用，例如<code>cp</code>、<code>mv</code>命令</li><li><code>-I(-i)</code>指定的替换字符串用于表示<code>xargs</code>传递给命令的参数使用的位置</li><li><code>-I</code>没有默认值，必须要指定替换字符串，而<code>-i</code>有默认值为<code>{}</code>，可以不用指定</li><li>当 <code>-I</code> 与 <code>xargs</code> 结合使用，<strong>每一个参数命令都会被执行一次</strong>，正如上面的<code>ls *.txt | xargs -t -I @ cp @ ../csplit/</code>是进行了两次的cp，而不是一次全部cp</li></ul></div><hr><h3 id="t-在执行命令之前先输出命令"><a href="#t-在执行命令之前先输出命令" class="headerlink" title="-t-在执行命令之前先输出命令"></a>-t-在执行命令之前先输出命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt | xargs -t -I @  cp @ ../csplit/</span><br><span class="line"><span class="comment"># 显示会执行的命令</span></span><br><span class="line">  cp test1.txt ../csplit/ </span><br><span class="line">  cp test2.txt ../csplit/</span><br></pre></td></tr></table></figure><hr><h3 id="p-执行命令之前询问"><a href="#p-执行命令之前询问" class="headerlink" title="-p-执行命令之前询问"></a>-p-执行命令之前询问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt | xargs -p -I @  cp @ ../csplit/</span><br><span class="line"><span class="comment"># 进行询问</span></span><br><span class="line">  cp test1.txt ../csplit/ ?...y</span><br><span class="line">  cp test2.txt ../csplit/ ?...y</span><br></pre></td></tr></table></figure><hr><h3 id="L-每次读取多少行作为输入"><a href="#L-每次读取多少行作为输入" class="headerlink" title="-L-每次读取多少行作为输入"></a>-L-每次读取多少行作为输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"><span class="comment"># 测试文件 </span></span><br><span class="line">  I am test1 file</span><br><span class="line">  test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs -L 1 <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 每次读取一行作为输入</span></span><br><span class="line">  I am test1 file</span><br><span class="line">  test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs -L 2 <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 每次读取二行作为输入</span></span><br><span class="line"><span class="comment"># 两行的文本会合并</span></span><br><span class="line">  I am test1 file test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs  <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 默认是所有行作为输入</span></span><br><span class="line">  I am test1 file test2 test2</span><br></pre></td></tr></table></figure><div class="note info"><p>注意：<code>-L</code> 和 <code>-n</code> 参数是互相排斥的</p></div><hr><h3 id="结合find命令"><a href="#结合find命令" class="headerlink" title="结合find命令"></a>结合find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># find命令默认输出结果以\n进行换行</span></span><br><span class="line">  ./test1.txt</span><br><span class="line">  ./test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-print0表示在每条结果后面加上 '\0' 而不是换行</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0</span><br><span class="line">  ./test1.txt./test2.txt(base) [user@localhost xargs]$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># -print0参数刚好可以与xargs的-0参数对应</span></span><br><span class="line"><span class="comment"># -0参数表示使用\0分割参数</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0 |xargs -0 </span><br><span class="line">  ./test1.txt ./test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-d参数也能达到一样的效果</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0 |xargs -d <span class="string">"\0"</span></span><br><span class="line">  ./test1.txt ./test2.txt</span><br></pre></td></tr></table></figure><p>指定<code>-print0</code>以及设置<code>-0</code>参数的意义在于：如果查找到的文件名中包含空格，不使用<code>-print0</code>那么<code>find</code>命令会将结果使用<code>\n</code>隔开并输出，而<code>xargs</code>对空白进行分割，换行、空格、tab都属于空白，所以会将<code>find</code>文件名分成两部分，这样会出错；而使用<code>-print0</code>结合<code>-0</code>参数后，前后都是使用<code>&#39;\0&#39;</code>分割不同的文件名，这样可以保证文件名不被分割。下面是一个示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们创建了3个日志文件, 且故意让文件名称中都含有空格</span></span><br><span class="line">[roc@roclinux ~]$ <span class="keyword">for</span>((i=0;i&lt;3;i++)); <span class="keyword">do</span> touch <span class="string">"test <span class="variable">$&#123;i&#125;</span>.log"</span>;<span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们列出创建的文件</span></span><br><span class="line">[roc@roclinux ~]$ ls -1F</span><br><span class="line"><span class="built_in">test</span> 0.log</span><br><span class="line"><span class="built_in">test</span> 1.log</span><br><span class="line"><span class="built_in">test</span> 2.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们来运行xargs命令, 发现报错了</span></span><br><span class="line"><span class="comment"># 因为xargs将test 0.log文件分割为了test和0.log文件，然后根本不存在这两个文件</span></span><br><span class="line">[roc@roclinux ~]$  find . -name <span class="string">'*.log'</span> -<span class="built_in">print</span> | xargs rm</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘1.log’: No such file or directory</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘0.log’: No such file or directory</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘2.log’: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-print0和-0结合可以完美解决问题</span></span><br><span class="line">find . -name <span class="string">'*.log'</span> -print0 | xargs -0 rm -f</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>xargs</code> 的<code>-0</code>选项<strong>不仅可以将分隔符从默认的空格变成 NULL</strong>，还会<strong>将单引号、双引号、反斜线等统统默认为是普通字符</strong>。所以说，<strong><code>-0</code>选项特别适合处理命令参数中含有引号、空格、反斜线的情况</strong>。</p></div><hr><h3 id="结合rm命令"><a href="#结合rm命令" class="headerlink" title="结合rm命令"></a>结合rm命令</h3><p>如果一次删除的文件太多，使用<code>rm *.file</code>可能会遇到<code>Argument list too long</code>错误，这是因为<code>rm</code> 可接受的参数长度达到了极限，这其实并非 <code>rm</code>的错，而是系统限制了参数的长度，通过下面的命令可以查看到系统的参数长度限制值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统对参数长度的限制</span></span><br><span class="line">getconf ARG_MAX</span><br><span class="line">  2097152</span><br></pre></td></tr></table></figure><p></p><p>解决办法可以是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.file'</span> -<span class="built_in">print</span> | xargs rm -rf</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><h4 id="在所有文件中查找字符串"><a href="#在所有文件中查找字符串" class="headerlink" title="在所有文件中查找字符串"></a>在所有文件中查找字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ <span class="string">"*.log"</span> |xargs grep -ri <span class="string">"test"</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/wangqiguo/p/6464234.html" target="_blank" rel="noopener">xargs命令详解，xargs与管道的区别</a></li><li><a href="http://c.biancheng.net/linux/xargs.html" target="_blank" rel="noopener">xargs命令_Linux xargs命令：一个给其他命令传递参数的过滤器</a></li><li><a href="http://www.runoob.com/linux/linux-comm-xargs.html" target="_blank" rel="noopener">Linux xargs 命令</a></li><li><a href="https://blog.csdn.net/tommy_wxie/article/details/77715203" target="_blank" rel="noopener">linux 管道传递参数xargs 用法</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了非常强大的能&lt;strong&gt;给其他命令传递参数的命令&lt;/strong&gt;&lt;code&gt;xargs&lt;/code&gt;，需要特别注意的是&lt;code&gt;xargs&lt;/code&gt;&lt;strong&gt;传递的是后一个命令的参数&lt;/strong&gt;，而&lt;code&gt;管道符&lt;/code&gt;&lt;strong&gt;传递的是前一个命令的结果，一个字符串而已&lt;/strong&gt;；主要学习了&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-I&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-p&lt;/code&gt;、&lt;code&gt;-L&lt;/code&gt;等参数，同时也学习了&lt;strong&gt;其与&lt;code&gt;find&lt;/code&gt;命令结合进行很多很强大的操作&lt;/strong&gt;！&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>printf-格式化输出字符串</title>
    <link href="http://showteeth.tech/posts/47162.html"/>
    <id>http://showteeth.tech/posts/47162.html</id>
    <published>2019-04-24T15:32:21.000Z</published>
    <updated>2019-04-25T03:43:03.187Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中进行格式化输出字符串的命令printf，除了<strong>格式化输出之外</strong>还能对其进行修饰，<strong>这些修饰包括</strong>：<code>指定输出宽度</code>、<code>填充不足位数</code>、<code>指定精度</code>、<code>使用多个格式替换符</code>、<code>对齐输出</code>、<code>输出正负值</code>等。</p></div><a id="more"></a><h2 id="printf命令简介"><a href="#printf命令简介" class="headerlink" title="printf命令简介"></a>printf命令简介</h2><p><code>printf</code>命令可以进行<strong>格式化输出字符串</strong>，这是其与<code>echo</code>命令不同的地方，也是其特征；<code>printf</code> 由 <code>POSIX</code>标准所定义，因此<strong>使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好</strong>；具体的功能包括：</p><ul><li><strong>指定输出宽度</strong></li><li><strong>填充不足位数</strong></li><li><strong>指定精度</strong></li><li><strong>使用多个格式替换符</strong></li><li><strong>对齐输出</strong></li><li><strong>输出正负值</strong></li></ul><hr><h2 id="printf命令格式"><a href="#printf命令格式" class="headerlink" title="printf命令格式"></a>printf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> %[输出最少宽度][．精度][类型] 字符或数字1 字符或数字2 ....</span><br></pre></td></tr></table></figure><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="http://showteeth.tech/posts/39761.html">echo</a>可以用来进行<strong>字符串的输出</strong>，还可以用来<strong>输出转义字符</strong>，同时还可以用来进行<strong>带颜色的文字和背景输出</strong>，看到这里不禁要问：echo已经可以进行这么多的输出，<strong>为什么这里还要学习printf命令呢？</strong>其实原因很简单：</p><ul><li>学习<code>csplit</code>时，其中的<code>-b</code>参数指定前缀时也需要使用<code>printf</code>的格式输出</li><li>使用seq命令产生序列时可以指定<code>-f</code>参数来进行格式化的输出</li></ul><p>这么多命令需要使用<code>printf</code>命令足以见得其重要性，其实<code>printf</code>的<strong>主要作用就是用来进行格式化输出</strong>，这是其区别于<code>echo</code>的最主要的特征，也是其存在的意义。在有些应用情境下，使用printf比使用echo命令更便捷：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个字符串换行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用echo</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"abc\ndef\nghi\njkl"</span></span><br><span class="line"><span class="comment"># 需要在每个字符串后面添加\n转义字符</span></span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line">  ghi</span><br><span class="line">  jkl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用printf</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line"><span class="comment"># 可以直接使用"%s\n"为所有的字符串添加相同的格式</span></span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line">  ghi</span><br><span class="line">  jkl</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="printf格式替换符"><a href="#printf格式替换符" class="headerlink" title="printf格式替换符"></a>printf格式替换符</h2><h3 id="格式替换符的作用"><a href="#格式替换符的作用" class="headerlink" title="格式替换符的作用"></a>格式替换符的作用</h3><p>前面使用了<code>&quot;%s\n&quot;</code>来对每个输出进行格式化，那么<code>&quot;%s\n&quot;</code>是什么呢，为什么能够用来进行标准化呢？</p><p><code>&quot;%s&quot;</code>相当于一个<strong>替身演员</strong>，我们使用<code>&quot;%s&quot;</code><strong>代替传入的参数</strong>，也就是说， <code>&quot;%s&quot;</code>代替了命令3中的<code>abc</code>，代替了<code>def</code>，代替了<code>ghi</code>，<strong>代替了每一个传入的参数</strong>，在我们指定的”格式”中，它代表了每一个传入的参数，所以，如果我们指定的格式为<code>&quot;%s\n&quot;</code>，当abc被当做参数传入printf命令时，printf就会把<code>&quot;%s\n&quot;</code>中的<code>%s</code>替换成<code>abc</code>，于是，abc就变成了我们指定的格式”abc\n”，最终printf输出的就是格式化后的”abc\n”，以此类推，每一段文本都被当做一个参数传入printf命令，然后按照指定的格式输出了，具体的工作机制可以使用参考下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/格式替换符.png" alt="格式替换符.png"></p><p>了解上面<strong>替身演员</strong>的作用机制之后，我们可以进行随心所欲的输出格式自定义，例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"(%s)\n"</span> <span class="string">"abc"</span> <span class="string">"def"</span>  <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line">  (abc)</span><br><span class="line">  (def)</span><br><span class="line">  (ghi)</span><br><span class="line">  (jkl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意，默认情况下，printf输出的字符不会换行，如需换行需要指定\n</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"(%s)\t"</span> <span class="string">"abc"</span> <span class="string">"def"</span>  <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line">(abc)(def)(ghi)(jkl)(base) [user@localhost seq]</span><br></pre></td></tr></table></figure><p></p><p>而 <strong>“替身演员”只是我给<code>&quot;%s&quot;</code>起的一个外号</strong>，它的真名叫 <strong>“格式替换符”</strong>，而printf中，”格式替换符”不只有”%s”一种，<strong>“%s”代替了每一个传入的参数，并将他们转化成了”字符串类型”</strong>，<strong>针对不同的需求，我们可以设置不同的格式替换符</strong>，例如，如果需要指定<strong>浮点型</strong>，可以使用<code>%f</code>，如果需要<strong>指定整数</strong>，可以使用<code>%d</code>。</p><hr><h3 id="常用的格式替换符"><a href="#常用的格式替换符" class="headerlink" title="常用的格式替换符"></a>常用的格式替换符</h3><table><tr><th width="20%">格式替换符</th><th width="80%">说明</th></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%f</code></td><td>浮点格式（也就是我们概念中的float或者double）</td></tr><tr><td><code>%e(%E)</code></td><td>浮点格式，使用的是科学计数法，大小写e、E区别在于科学计数法的e是大写还是小写</td></tr><tr><td><code>%g(%G)</code></td><td>浮点数不显无意义的0</td></tr><tr><td><code>%d、%i</code></td><td>有符号十进制整数</td></tr><tr><td><code>%b</code></td><td>相对应的参数中包含转义字符时，可以使用此替换符进行替换，对应的转义字符会被转义</td></tr><tr><td><code>%c</code></td><td>ASCII字符，显示相对应参数的第一个字符</td></tr><tr><td><code>%o</code></td><td>不带正负号的八进制值</td></tr><tr><td><code>%u</code></td><td>不带正负号的十进制值</td></tr><tr><td><code>%x</code></td><td>不带正负号的十六进制值，使用a至f表示10至15</td></tr><tr><td><code>%X</code></td><td>不带正负号的十六进制值，使用A至F表示10至15</td></tr><tr><td><code>%%</code></td><td>表示"%"本身</td></tr></table><hr><h2 id="printf转义字符"><a href="#printf转义字符" class="headerlink" title="printf转义字符"></a>printf转义字符</h2><p>关于转义字符的内容直接参考echo命令中的转义字符，两者基本上是一样的，<a href="http://showteeth.tech/posts/39761.html">具体链接</a></p><hr><h2 id="printf格式替换符修饰信息"><a href="#printf格式替换符修饰信息" class="headerlink" title="printf格式替换符修饰信息"></a>printf格式替换符修饰信息</h2><h3 id="指定输出位数"><a href="#指定输出位数" class="headerlink" title="指定输出位数"></a>指定输出位数</h3><p><strong>使用形式</strong>：<code>&quot;m%f\n&quot;</code>，其中m表示输出的位数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认情况下，浮点会保留小数点后6位</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%1f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 如果指定位数为1，默认输出还是原始长度</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%10f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 如果指定位数为10，则会使用空格填充两个</span></span><br><span class="line">    1.000000</span><br><span class="line">    2.000000</span><br><span class="line">    3.000000</span><br><span class="line">    4.000000</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>通过上面的实例可以得出如下结论：</p><ul><li>如果指定的位数<strong>小于</strong>原始输出位数，则会<strong>保留原始长度</strong></li><li>如果指定的位数<strong>大于</strong>原始输出位数，<strong>默认会使用空格填充不足的位数</strong></li></ul></div><hr><h3 id="填充不足位数"><a href="#填充不足位数" class="headerlink" title="填充不足位数"></a>填充不足位数</h3><p><strong>使用形式</strong>：<code>&quot;0m%f\n&quot;</code>，其中m表示输出的位数，0表示不足位数使用0填充<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%10f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认在输出位数没有达到指定时，会使用空格进行填充</span></span><br><span class="line">    1.000000</span><br><span class="line">    2.000000</span><br><span class="line">    3.000000</span><br><span class="line">    4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%010f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 可以指定使用0来填充不足的位数</span></span><br><span class="line">  001.000000</span><br><span class="line">  002.000000</span><br><span class="line">  003.000000</span><br><span class="line">  004.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%010s\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 好像不会对字符串进行填充0</span></span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">          4</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>只能使用<code>0</code>或<code>空格</code>来进行填充</li><li>对字符串<code>&quot;%s&quot;</code>好像不能使用0填充</li></ul></div><hr><h3 id="指定精度"><a href="#指定精度" class="headerlink" title="指定精度"></a>指定精度</h3><p><strong>使用形式</strong>：<code>&quot;.n%f\n&quot;</code>，其中<code>.n</code>表示精度，也就是小数点后保留的位数；<code>&quot;.n%d\n&quot;</code>，如果用在整数上，会使用0填充<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%.4f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认情况是保留六位小数</span></span><br><span class="line"><span class="comment"># 这里指定保留四位小数</span></span><br><span class="line">  1.0000</span><br><span class="line">  2.0000</span><br><span class="line">  3.0000</span><br><span class="line">  4.0000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整数使用精度则会达到填充0的效果</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%.4d\n"</span> 1 2 3 4</span><br><span class="line">  0001</span><br><span class="line">  0002</span><br><span class="line">  0003</span><br><span class="line">  0004</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>可以和前面的指定输出位数联合使用</li><li>对整数使用精度则会达到填充0的效果</li></ul></div><hr><h3 id="使用多个格式替换符"><a href="#使用多个格式替换符" class="headerlink" title="使用多个格式替换符"></a>使用多个格式替换符</h3><p><strong>使用形式</strong>：<code>&quot;%s %s\n&quot;</code>，多个格式替换符连用，每个格式替换符代表一个参数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s\n"</span> a b c d e f</span><br><span class="line"><span class="comment"># 每两个进行一次换行</span></span><br><span class="line">  a b</span><br><span class="line">  c d</span><br><span class="line">  e f</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s%s\n"</span> a b c d e f</span><br><span class="line"><span class="comment"># 每个参数之间的间隔取决于格式替换符之间的间隔</span></span><br><span class="line">  ab</span><br><span class="line">  <span class="built_in">cd</span></span><br><span class="line">  ef</span><br></pre></td></tr></table></figure><p></p><p>如果指定的”格式”中包含<strong>两个”格式替换符”</strong>，那么printf每次进行”格式化”操作时，就会<strong>传入两个参数</strong>，然后<strong>前一个参数对应第一个替换符</strong>，<strong>后一个参数对应第二个替换符</strong>，当本次格式化操作完成以后，再传入下一波参数，具体的工作机制如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/多个格式替换符.png" alt="多个格式替换符.png"></p><hr><h3 id="对齐输出"><a href="#对齐输出" class="headerlink" title="对齐输出"></a>对齐输出</h3><p><strong>使用形式</strong>：<code>&quot;%-s&quot;</code>，<code>-</code>表示左对齐，不加表示右对齐<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s %s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># 输出上述信息得到的结果会存在错位现象</span></span><br><span class="line"><span class="comment"># 原因：第一行宽度与后面每行对应的宽度不一致</span></span><br><span class="line"><span class="comment"># 指定的话需要结合系统编码，utf-8中文是3个字节</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果 男 18 60 </span><br><span class="line">  香蕉 男 18 80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%6s %6s %4s %4s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># 输出也没有对齐</span></span><br><span class="line"><span class="comment"># 第二行的男字节宽度为3，会填补3个空格</span></span><br><span class="line"><span class="comment"># 默认是右对齐</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果    男   18   60 </span><br><span class="line">  香蕉    男   18   80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-4s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># "-"表示左对齐</span></span><br><span class="line"><span class="comment"># 不加的时候表示右对齐</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果 男    18   60   </span><br><span class="line">  香蕉 男    18   80</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="输出正负值"><a href="#输出正负值" class="headerlink" title="输出正负值"></a>输出正负值</h3><p><strong>使用形式</strong>：<code>&quot;%+d&quot;</code>，<code>+</code>表示在正值前面加上<code>+</code>符号<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-4d \n"</span> 苹果 男 18 60 香蕉 男 18 -80</span><br><span class="line">苹果 男    18   60   </span><br><span class="line">香蕉 男    18   -80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-+4d \n"</span> 苹果 男 18 60 香蕉 男 18 -80</span><br><span class="line"><span class="comment"># 加了+使得整数会显示+，可以个负数的输出保持对齐</span></span><br><span class="line">苹果 男    18   +60  </span><br><span class="line">香蕉 男    18   -80</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/1411" target="_blank" rel="noopener">printf命令详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/48666563" target="_blank" rel="noopener">C语言 printf详解</a></li><li><a href="http://man.linuxde.net/printf" target="_blank" rel="noopener">printf命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中进行格式化输出字符串的命令printf，除了&lt;strong&gt;格式化输出之外&lt;/strong&gt;还能对其进行修饰，&lt;strong&gt;这些修饰包括&lt;/strong&gt;：&lt;code&gt;指定输出宽度&lt;/code&gt;、&lt;code&gt;填充不足位数&lt;/code&gt;、&lt;code&gt;指定精度&lt;/code&gt;、&lt;code&gt;使用多个格式替换符&lt;/code&gt;、&lt;code&gt;对齐输出&lt;/code&gt;、&lt;code&gt;输出正负值&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>seq-产生固定步长整数</title>
    <link href="http://showteeth.tech/posts/1152.html"/>
    <id>http://showteeth.tech/posts/1152.html</id>
    <published>2019-04-24T06:53:38.000Z</published>
    <updated>2019-04-25T03:38:15.537Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中常用的用来产生等间隔序列的命令<code>seq</code>，主要参数包括<code>-w</code>、<code>-f</code>、<code>-s</code>。</p></div><a id="more"></a><h2 id="seq命令简介"><a href="#seq命令简介" class="headerlink" title="seq命令简介"></a>seq命令简介</h2><p><code>seq</code>命令可以<strong>用来产生从指定起始位点到终止位点固定步长的数字序列</strong>，这个序列<strong>可以是整数也可以是小数</strong>，在输出结果时，可以进行<strong>等宽输出</strong>、<strong>格式化输出</strong>、<strong>指定分隔符输出</strong>。</p><hr><h2 id="seq命令格式"><a href="#seq命令格式" class="headerlink" title="seq命令格式"></a>seq命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><hr><h2 id="seq命令参数"><a href="#seq命令参数" class="headerlink" title="seq命令参数"></a>seq命令参数</h2><table><thead><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--format=FORMAT</code></td><td>使用printf 样式的浮点格式来进行格式化输出，不能和<code>-w</code>一起用</td></tr><tr><td><code>-s</code></td><td><code>--separator=STRING</code></td><td>指定输出分隔符，默认是换行符<code>\n</code></td></tr><tr><td><code>-w</code></td><td><code>--equal-width</code></td><td>输出等宽的结果，默认使用0来补全，不能和<code>-f</code>一起用</td></tr></tbody></table><hr><h2 id="seq使用实例"><a href="#seq使用实例" class="headerlink" title="seq使用实例"></a>seq使用实例</h2><h3 id="seq默认行为"><a href="#seq默认行为" class="headerlink" title="seq默认行为"></a>seq默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5</span><br><span class="line"><span class="comment"># 如果给定两个数字，则一个为起始，一个为终止，步长为1</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">seq 2 1</span><br><span class="line"><span class="comment"># 没有输出结果，步长还是默认为1</span></span><br><span class="line"><span class="comment"># 即使起始大于终止</span></span><br><span class="line"></span><br><span class="line">seq 5</span><br><span class="line"><span class="comment"># 如果只指定一个数字，则这个数字是终止数字，起始和步长都为1</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">seq 1 0.5 2</span><br><span class="line"><span class="comment"># 步长可以为小数</span></span><br><span class="line"><span class="comment"># 起始和终止都可以为小数</span></span><br><span class="line">  1.0</span><br><span class="line">  1.5</span><br><span class="line">  2.0</span><br></pre></td></tr></table></figure><p>可以设置负的<code>INCREMENT</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 2 -1 1</span><br><span class="line"><span class="comment"># 生成递减的序列</span></span><br><span class="line">  2</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-设置序列输出间隔符"><a href="#s-设置序列输出间隔符" class="headerlink" title="-s-设置序列输出间隔符"></a>-s-设置序列输出间隔符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq 1 4</span><br><span class="line"><span class="comment"># 默认是通过换行符隔开</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line"></span><br><span class="line">seq -s <span class="string">','</span> 1 4</span><br><span class="line"><span class="comment"># 指定分隔符为逗号</span></span><br><span class="line">  1,2,3,4</span><br></pre></td></tr></table></figure><p>如果想<strong>要指定带有特殊意义的字符作为分隔符，就需要结合<code>echo</code>输出转义字符</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq -s <span class="string">"\t"</span> 1 4</span><br><span class="line"><span class="comment"># 如果直接指定\t，输出结果不能达到理想的效果</span></span><br><span class="line">  1\t2\t3\t4</span><br><span class="line"></span><br><span class="line">seq -s <span class="string">"<span class="variable">$(echo -e "\t")</span>"</span> 1 4</span><br><span class="line"><span class="comment"># 使用echo -e输出结果进行指定</span></span><br><span class="line">  1234</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>指定<strong>转义字符</strong>时需要<strong>借助<code>echo -e</code>进行输出</strong>，直接指定会出错</p></div><hr><h3 id="w-设置等宽输出"><a href="#w-设置等宽输出" class="headerlink" title="-w-设置等宽输出"></a>-w-设置等宽输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">seq 5 10</span><br><span class="line"><span class="comment"># 默认行为</span></span><br><span class="line">  5</span><br><span class="line">  6</span><br><span class="line">  7</span><br><span class="line">  8</span><br><span class="line">  9</span><br><span class="line">  10</span><br><span class="line"></span><br><span class="line">seq -w 5 10</span><br><span class="line"><span class="comment"># 设置输出的序列等宽</span></span><br><span class="line"><span class="comment"># 宽度由最大数字的宽度决定</span></span><br><span class="line">  05</span><br><span class="line">  06</span><br><span class="line">  07</span><br><span class="line">  08</span><br><span class="line">  09</span><br><span class="line">  10</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-w</code>参数不能和<code>-f</code>参数连用</p></div><hr><h3 id="f-进行格式化输出"><a href="#f-进行格式化输出" class="headerlink" title="-f-进行格式化输出"></a>-f-进行格式化输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5</span><br><span class="line"><span class="comment"># 默认情况</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">seq -f <span class="string">"%g"</span> 1 5</span><br><span class="line"><span class="comment"># %g表示浮点数不显无意义的零"0"</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而真正的浮点数</span></span><br><span class="line">seq -f <span class="string">"%f"</span> 1 5</span><br><span class="line"><span class="comment"># 后面有很多没有意义的0</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line">  5.000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 科学计数法</span></span><br><span class="line">seq -f <span class="string">"%e"</span> 1 5</span><br><span class="line">  1.000000e+00</span><br><span class="line">  2.000000e+00</span><br><span class="line">  3.000000e+00</span><br><span class="line">  4.000000e+00</span><br><span class="line">  5.000000e+00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出位宽</span></span><br><span class="line">seq -f <span class="string">"%3g"</span> 5 10</span><br><span class="line"><span class="comment"># 输出的位宽为3，宽度不足3的使用空格填充</span></span><br><span class="line">    5</span><br><span class="line">    6</span><br><span class="line">    7</span><br><span class="line">    8</span><br><span class="line">    9</span><br><span class="line">  10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0填充位宽不足的</span></span><br><span class="line">seq -f <span class="string">"%03g"</span> 5 10</span><br><span class="line"><span class="comment"># 这个如果将位宽设置为2，就和-w参数相同</span></span><br><span class="line"><span class="comment"># 但是-w参数可以自动识别最大宽度</span></span><br><span class="line">  005</span><br><span class="line">  006</span><br><span class="line">  007</span><br><span class="line">  008</span><br><span class="line">  009</span><br><span class="line">  010</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加前缀输出</span></span><br><span class="line">seq -f <span class="string">"dir%g"</span> 1 5</span><br><span class="line"><span class="comment"># 添加前缀为dir</span></span><br><span class="line">  dir1</span><br><span class="line">  dir2</span><br><span class="line">  dir3</span><br><span class="line">  dir4</span><br><span class="line">  dir5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合其他命令使用</span></span><br><span class="line">mkdir $(seq -f <span class="string">'dir%g'</span> 1 5)</span><br></pre></td></tr></table></figure><div class="note info"><p>更多关于<code>printf</code>格式化输出的内容请参考<a href="http://showteeth.tech/posts/47162.html">这篇文章</a></p></div><hr><h3 id="其他可以得到指定步长整数的方法"><a href="#其他可以得到指定步长整数的方法" class="headerlink" title="其他可以得到指定步长整数的方法"></a>其他可以得到指定步长整数的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 使用花括号进行拓展</span></span><br><span class="line"><span class="comment"># 默认步长为1 </span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 指定步长为2</span></span><br><span class="line">  1</span><br><span class="line">  3 </span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..f..2&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 还可以对字母进行指定步长输出</span></span><br><span class="line">  a</span><br><span class="line">  c</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/128" target="_blank" rel="noopener">seq命令详解</a></li><li><a href="http://man.linuxde.net/seq" target="_blank" rel="noopener">seq命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中常用的用来产生等间隔序列的命令&lt;code&gt;seq&lt;/code&gt;，主要参数包括&lt;code&gt;-w&lt;/code&gt;、&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shuf-随机打乱文件</title>
    <link href="http://showteeth.tech/posts/50731.html"/>
    <id>http://showteeth.tech/posts/50731.html</id>
    <published>2019-04-23T15:14:29.000Z</published>
    <updated>2019-04-23T16:17:14.408Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>对文件以及命令行输入进行随机打乱的命令<code>shuf</code></strong>，主要参数包括<code>-e</code>、<code>-i</code>、<code>-n</code>、<code>-o</code>、<code>-r</code>等。</p></div><a id="more"></a><h2 id="shuf简介"><a href="#shuf简介" class="headerlink" title="shuf简介"></a>shuf简介</h2><p><code>shuf</code>命令可以<strong>对文件或者命令行输入进行随机打乱并输出到标准输出或者指定的文件中</strong>，还<strong>可以指定<code>shuf</code>的随机模式(有放回地抽取)</strong></p><hr><h2 id="shuf命令格式"><a href="#shuf命令格式" class="headerlink" title="shuf命令格式"></a>shuf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: shuf [OPTION]... [FILE]</span><br><span class="line">  or:  shuf -e [OPTION]... [ARG]...</span><br><span class="line">  or:  shuf -i LO-HI [OPTION]...</span><br><span class="line"></span><br><span class="line">Write a random permutation of the input lines to standard output.</span><br></pre></td></tr></table></figure><hr><h2 id="shuf参数"><a href="#shuf参数" class="headerlink" title="shuf参数"></a>shuf参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-e</code></td><td><code>--echo</code></td><td>将参数作为输入信息进行随机打乱</td></tr><tr><td><code>-i</code></td><td><code>--input-range=LO-HI</code></td><td>在特定范围内生成随机数</td></tr><tr><td><code>-n</code></td><td><code>--head-count=COUNT</code></td><td>最大输出行数</td></tr><tr><td><code>-o</code></td><td><code>--output=FILE</code></td><td>指定输出文件</td></tr><tr><td></td><td><code>--random-source=FILE</code></td><td>get random bytes from FILE</td></tr><tr><td><code>-r</code></td><td><code>--repeat</code></td><td>有放回地抽取，需要结合<code>-n</code>参数一同使用</td></tr><tr><td><code>-z</code></td><td><code>--zero-terminated</code></td><td>以0 结束行而非换行符</td></tr></table><hr><h2 id="shuf使用实例"><a href="#shuf使用实例" class="headerlink" title="shuf使用实例"></a>shuf使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line6</span><br><span class="line">  line7</span><br><span class="line">  line8</span><br><span class="line">  line9</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="shuf默认行为"><a href="#shuf默认行为" class="headerlink" title="shuf默认行为"></a>shuf默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shuf test.txt</span><br><span class="line"><span class="comment"># 将test.txt随机打乱 </span></span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line7</span><br><span class="line">  line5</span><br><span class="line">  line10</span><br><span class="line">  line6</span><br><span class="line">  line8</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line1</span><br></pre></td></tr></table></figure><hr><h3 id="e-将参数作为输入信息进行随机打乱"><a href="#e-将参数作为输入信息进行随机打乱" class="headerlink" title="-e-将参数作为输入信息进行随机打乱"></a>-e-将参数作为输入信息进行随机打乱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shuf -e <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"mbc"</span></span><br><span class="line">  mbc</span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line"></span><br><span class="line">a=badad</span><br><span class="line">b=asdf</span><br><span class="line">c=sadfa</span><br><span class="line">shuf -e <span class="variable">$a</span> <span class="variable">$b</span> <span class="variable">$c</span></span><br><span class="line"><span class="comment"># 变量拓展</span></span><br><span class="line">  badad</span><br><span class="line">  sadfa</span><br><span class="line">  asdf</span><br></pre></td></tr></table></figure><hr><h3 id="i-在指定范围内生成随机数"><a href="#i-在指定范围内生成随机数" class="headerlink" title="-i-在指定范围内生成随机数"></a>-i-在指定范围内生成随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成1-10范围内的随机数</span></span><br><span class="line"><span class="comment"># 包括1和10</span></span><br><span class="line">shuf -i 1-10</span><br><span class="line">  3</span><br><span class="line">  7</span><br><span class="line">  4</span><br><span class="line">  6</span><br><span class="line">  1</span><br><span class="line">  9</span><br><span class="line">  2</span><br><span class="line">  5</span><br><span class="line">  10</span><br><span class="line">  8</span><br></pre></td></tr></table></figure><hr><h3 id="n-最大输出行数"><a href="#n-最大输出行数" class="headerlink" title="-n-最大输出行数"></a>-n-最大输出行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出随机打乱后结果的其中3行</span></span><br><span class="line">shuf -n 3 test.txt</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line9</span><br></pre></td></tr></table></figure><hr><h3 id="o-指定输出文件"><a href="#o-指定输出文件" class="headerlink" title="-o-指定输出文件"></a>-o-指定输出文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机打乱并将结果输出到shuf.txt</span></span><br><span class="line">shuf test.txt -o shuf.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">cat shuf.txt </span><br><span class="line">  line7</span><br><span class="line">  line1</span><br><span class="line">  line4</span><br><span class="line">  line6</span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line3</span><br><span class="line">  line5</span><br><span class="line">  line8</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="r-有放回地抽取"><a href="#r-有放回地抽取" class="headerlink" title="-r-有放回地抽取"></a>-r-有放回地抽取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有放回的抽取15行结果</span></span><br><span class="line">shuf -n 15 -r test.txt </span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line8</span><br><span class="line">  line1</span><br><span class="line">  line6</span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line1</span><br><span class="line">  line10</span><br><span class="line">  line7</span><br><span class="line">  line10</span><br><span class="line">  line10</span><br><span class="line">  line8</span><br></pre></td></tr></table></figure><div class="note info"><p><strong><code>-r</code>参数一定要结合<code>-n</code>参数一同使用</strong>，不然会一直运行有放回地抽取，<strong>相当于死循环</strong>，一直输出</p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.cn/article-9635-1.html" target="_blank" rel="noopener">给初学者看的 shuf 命令教程</a></li><li><a href="https://www.howtoforge.com/linux-shuf-command/" target="_blank" rel="noopener">Linux shuf Command Tutorial for Beginners (with Examples)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;对文件以及命令行输入进行随机打乱的命令&lt;code&gt;shuf&lt;/code&gt;&lt;/strong&gt;，主要参数包括&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shell中的float问题</title>
    <link href="http://showteeth.tech/posts/61435.html"/>
    <id>http://showteeth.tech/posts/61435.html</id>
    <published>2019-04-20T01:51:47.000Z</published>
    <updated>2019-04-23T15:09:17.380Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了shell中<strong>处理浮点比较</strong>相关的内容，主要学习了<strong>使用<code>awk</code>以及<code>bc</code>命令来进行浮点比较和运算</strong>，此前还有一篇<a href="http://showteeth.tech/posts/28430.html">相关的文章</a></p></div><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在编写shell脚本的时候<strong>发现shell中使用浮点的比较</strong>会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 0.1 -lt 1 ]];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  -bash: [[: 0.1: syntax error: invalid arithmetic operator (error token is <span class="string">".1"</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>shell是不支持浮点的，不管是浮点的运算还是浮点的比较</p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="使用awk"><a href="#使用awk" class="headerlink" title="使用awk"></a>使用awk</h3><p>awk是支持浮点，包括运算以及比较：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点运算</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2/3&#125;'</span></span><br><span class="line">  0.666667</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&lt;3&#125;'</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&gt;3&#125;'</span></span><br><span class="line"><span class="comment"># 假则不输出结果</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用bc"><a href="#使用bc" class="headerlink" title="使用bc"></a>使用bc</h3><p>bc是shell中支持浮点相关方法的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点计算，如果结果小于0，会省略0，这里使用方法加上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br><span class="line"><span class="comment"># 输出结果，保留两位小数</span></span><br><span class="line">  0.66</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点的比较</span></span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &gt;= 0.3"</span></span><br><span class="line"><span class="comment"># 假值返回0</span></span><br><span class="line">  0</span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &lt;= 0.3"</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>注意<code>&lt;&lt;&lt;</code>、<code>&lt;&lt;</code>、<code>&lt;</code>的区别</strong>：</p><ul><li><code>&lt;</code>：表示从文件file中读取</li><li><code>&lt;&lt;</code>：表示从命令行读取到指定的结束字符</li><li><code>&lt;&lt;&lt;</code>：读取后面紧接的字符串</li><li>具体的用法实例参考<a href="http://showteeth.tech/posts/55603.html">文章</a><br><br></li></ul><p>关于浮点运算可以参考之前的<a href="http://showteeth.tech/posts/28430.html">文章</a></p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/2424770/floating-point-comparison-in-shell-script" target="_blank" rel="noopener">Floating Point Comparison in Shell Script</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了shell中&lt;strong&gt;处理浮点比较&lt;/strong&gt;相关的内容，主要学习了&lt;strong&gt;使用&lt;code&gt;awk&lt;/code&gt;以及&lt;code&gt;bc&lt;/code&gt;命令来进行浮点比较和运算&lt;/strong&gt;，此前还有一篇&lt;a href=&quot;http://showteeth.tech/posts/28430.html&quot;&gt;相关的文章&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据竞赛Top解决方案开源整理</title>
    <link href="http://showteeth.tech/posts/49396.html"/>
    <id>http://showteeth.tech/posts/49396.html</id>
    <published>2019-04-15T03:46:19.000Z</published>
    <updated>2019-04-15T07:22:25.958Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。</p></div><a id="more"></a><h2 id="纯数据竞赛"><a href="#纯数据竞赛" class="headerlink" title="纯数据竞赛"></a>纯数据竞赛</h2><h3 id="2018科大讯飞AI营销算法大赛"><a href="#2018科大讯飞AI营销算法大赛" class="headerlink" title="2018科大讯飞AI营销算法大赛"></a>2018科大讯飞AI营销算法大赛</h3><ul><li><strong>Rank1</strong>：<a href="https://zhuanlan.zhihu.com/p/47807544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47807544</a></li></ul><hr><h3 id="2018-IJCAI-阿里妈妈搜索广告转化预测"><a href="#2018-IJCAI-阿里妈妈搜索广告转化预测" class="headerlink" title="2018 IJCAI 阿里妈妈搜索广告转化预测"></a>2018 IJCAI 阿里妈妈搜索广告转化预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/plantsgo/ijcai-2018" target="_blank" rel="noopener">https://github.com/plantsgo/ijcai-2018</a></li><li><strong>Rank2</strong>：<ul><li><a href="https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution" target="_blank" rel="noopener">https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution</a></li><li><a href="https://blog.csdn.net/Bryan__/article/details/80600189" target="_blank" rel="noopener">https://blog.csdn.net/Bryan__/article/details/80600189</a></li></ul></li><li><strong>Rank3</strong>: <a href="https://github.com/luoda888/2018-IJCAI-top3" target="_blank" rel="noopener">https://github.com/luoda888/2018-IJCAI-top3</a></li><li><strong>Rank8</strong>: <a href="https://github.com/fanfanda/ijcai_2018" target="_blank" rel="noopener">https://github.com/fanfanda/ijcai_2018</a></li><li><strong>Rank8</strong>: <a href="https://github.com/Gene20/IJCAI-18" target="_blank" rel="noopener">https://github.com/Gene20/IJCAI-18</a></li><li><strong>Rank9（第一赛季）</strong>：<a href="https://github.com/yuxiaowww/IJCAI-18-TIANCHI" target="_blank" rel="noopener">https://github.com/yuxiaowww/IJCAI-18-TIANCHI</a></li><li><strong>Rank29</strong>: <a href="https://github.com/bettenW/IJCAI18_Tianchi_Rank29" target="_blank" rel="noopener">https://github.com/bettenW/IJCAI18_Tianchi_Rank29</a></li><li><strong>Rank41</strong>: <a href="https://github.com/cmlaughing/IJCAI-18" target="_blank" rel="noopener">https://github.com/cmlaughing/IJCAI-18</a></li><li><strong>Rank48</strong>: <a href="https://github.com/YunaQiu/IJCAI-18alimama" target="_blank" rel="noopener">https://github.com/YunaQiu/IJCAI-18alimama</a></li><li><strong>Rank53</strong>: <a href="https://github.com/altmanWang/IJCAI-18-CVR" target="_blank" rel="noopener">https://github.com/altmanWang/IJCAI-18-CVR</a></li><li><strong>Rank60</strong>: <a href="https://github.com/Chenyaorui/ijcai_2018" target="_blank" rel="noopener">https://github.com/Chenyaorui/ijcai_2018</a></li><li><strong>Rank81</strong>: <a href="https://github.com/wzp123456/IJCAI_18" target="_blank" rel="noopener">https://github.com/wzp123456/IJCAI_18</a></li><li><strong>Rank94</strong>: <a href="https://github.com/Yangtze121/-IJCAI-18-" target="_blank" rel="noopener">https://github.com/Yangtze121/-IJCAI-18-</a></li></ul><hr><h3 id="2018腾讯广告算法大赛"><a href="#2018腾讯广告算法大赛" class="headerlink" title="2018腾讯广告算法大赛"></a>2018腾讯广告算法大赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/DiligentPanda/Tencent_Ads_Algo_2018" target="_blank" rel="noopener">https://github.com/DiligentPanda/Tencent_Ads_Algo_2018</a></li><li><strong>Rank6</strong>: <a href="https://github.com/nzc/tencent-contest" target="_blank" rel="noopener">https://github.com/nzc/tencent-contest</a></li><li><strong>Rank7</strong>: <a href="https://github.com/guoday/Tencent2018_Lookalike_Rank7th" target="_blank" rel="noopener">https://github.com/guoday/Tencent2018_Lookalike_Rank7th</a></li><li><strong>Rank9</strong>: <a href="https://github.com/ouwenjie03/tencent-ad-game" target="_blank" rel="noopener">https://github.com/ouwenjie03/tencent-ad-game</a></li><li><strong>Rank10</strong>: <a href="https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th" target="_blank" rel="noopener">https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th</a></li><li><strong>rank10（初赛）</strong>: <a href="https://github.com/ShawnyXiao/2018-Tencent-Lookalike" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-Tencent-Lookalike</a></li><li><strong>Rank11</strong>:<ul><li><a href="https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest" target="_blank" rel="noopener">https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest</a></li><li><a href="https://my.oschina.net/xtzggbmkk/blog/1865680" target="_blank" rel="noopener">https://my.oschina.net/xtzggbmkk/blog/1865680</a></li></ul></li><li><strong>Rank26</strong>: <a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="noopener">https://github.com/zsyandjyhouse/TencentAD_contest</a></li><li><strong>Rank33</strong>: <a href="https://github.com/John-Yao/Tencent_Social_Ads2018" target="_blank" rel="noopener">https://github.com/John-Yao/Tencent_Social_Ads2018</a></li><li><strong>Rank69</strong>: <a href="https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest" target="_blank" rel="noopener">https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest</a></li></ul><hr><h3 id="2018高校大数据挑战赛-快手活跃用户预测"><a href="#2018高校大数据挑战赛-快手活跃用户预测" class="headerlink" title="2018高校大数据挑战赛-快手活跃用户预测"></a>2018高校大数据挑战赛-快手活跃用户预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://github.com/drop-out/RNN-Active-User-Forecast" target="_blank" rel="noopener">https://github.com/drop-out/RNN-Active-User-Forecast</a></li><li><a href="https://zhuanlan.zhihu.com/p/42622063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42622063</a></li></ul></li><li><strong>Rank4</strong>: <a href="https://github.com/chantcalf/2018-Rank4-" target="_blank" rel="noopener">https://github.com/chantcalf/2018-Rank4-</a></li><li><strong>Rank13(初赛 a榜rank2 b榜rank5)</strong>: <a href="https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions" target="_blank" rel="noopener">https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions</a></li><li><strong>Rank15</strong>: <a href="https://github.com/sunwantong/Kuaishou-Active-User" target="_blank" rel="noopener">https://github.com/sunwantong/Kuaishou-Active-User</a></li><li><strong>Rank20</strong>: <a href="https://github.com/bigzhao/Kuaishou_2018_rank20th" target="_blank" rel="noopener">https://github.com/bigzhao/Kuaishou_2018_rank20th</a></li><li><strong>Rank28(初赛 a榜rank1 b榜rank2)</strong>：<ul><li><a href="https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-" target="_blank" rel="noopener">https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-</a></li><li><a href="https://github.com/FNo0/2018-KUAISHOU-Top28" target="_blank" rel="noopener">https://github.com/FNo0/2018-KUAISHOU-Top28</a></li></ul></li></ul><hr><h3 id="2018JDATA-用户购买时间预测"><a href="#2018JDATA-用户购买时间预测" class="headerlink" title="2018JDATA 用户购买时间预测"></a>2018JDATA 用户购买时间预测</h3><ul><li><strong>Rank9</strong>：<a href="https://zhuanlan.zhihu.com/p/45141799" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45141799</a></li></ul><hr><h3 id="2018-DF风机叶片开裂预警"><a href="#2018-DF风机叶片开裂预警" class="headerlink" title="2018 DF风机叶片开裂预警"></a>2018 DF风机叶片开裂预警</h3><ul><li><strong>Rank2</strong>：<a href="https://github.com/SY575/DF-Early-warning-of-the-wind-power-system" target="_blank" rel="noopener">https://github.com/SY575/DF-Early-warning-of-the-wind-power-system</a></li></ul><hr><h3 id="2018-DF光伏发电量预测"><a href="#2018-DF光伏发电量预测" class="headerlink" title="2018 DF光伏发电量预测"></a>2018 DF光伏发电量预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168</a></li><li><a href="https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g</a></li></ul></li></ul><hr><h3 id="AI全球挑战者大赛-违约用户风险预测"><a href="#AI全球挑战者大赛-违约用户风险预测" class="headerlink" title="AI全球挑战者大赛-违约用户风险预测"></a>AI全球挑战者大赛-违约用户风险预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/chenkkkk/User-loan-risk-prediction" target="_blank" rel="noopener">https://github.com/chenkkkk/User-loan-risk-prediction</a></li></ul><hr><h3 id="2016融360-用户贷款风险预测"><a href="#2016融360-用户贷款风险预测" class="headerlink" title="2016融360-用户贷款风险预测"></a>2016融360-用户贷款风险预测</h3><ul><li><strong>Rank7</strong>：<a href="https://github.com/hczheng/Rong360" target="_blank" rel="noopener">https://github.com/hczheng/Rong360</a></li></ul><hr><h3 id="2016-CCF-020优惠券使用预测"><a href="#2016-CCF-020优惠券使用预测" class="headerlink" title="2016 CCF-020优惠券使用预测"></a>2016 CCF-020优惠券使用预测</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="noopener">https://github.com/wepe/O2O-Coupon-Usage-Forecast</a></li></ul><hr><h3 id="2016-ccf-农产品价格预测"><a href="#2016-ccf-农产品价格预测" class="headerlink" title="2016 ccf-农产品价格预测"></a>2016 ccf-农产品价格预测</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/xing89qs/CCF_Product" target="_blank" rel="noopener">https://github.com/xing89qs/CCF_Product</a></li><li><strong>Rank35</strong>: <a href="https://github.com/wqlin/ccf-price-prediction" target="_blank" rel="noopener">https://github.com/wqlin/ccf-price-prediction</a></li></ul><hr><h3 id="2016-ccf-客户用电异常"><a href="#2016-ccf-客户用电异常" class="headerlink" title="2016 ccf-客户用电异常"></a>2016 ccf-客户用电异常</h3><ul><li><strong>Rank4</strong>: <a href="https://github.com/AbnerYang/2016CCF-StateGrid" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-StateGrid</a></li></ul><hr><h3 id="2016-ccf-搜狗的用户画像比赛"><a href="#2016-ccf-搜狗的用户画像比赛" class="headerlink" title="2016 ccf-搜狗的用户画像比赛"></a>2016 ccf-搜狗的用户画像比赛</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/hengchao0248/ccf2016_sougou" target="_blank" rel="noopener">https://github.com/hengchao0248/ccf2016_sougou</a></li><li><strong>Rank3</strong>: <a href="https://github.com/AbnerYang/2016CCF-SouGou" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-SouGou</a></li><li><strong>Rank5</strong>:<ul><li><a href="https://github.com/dhdsjy/2016_CCFsougou" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou</a></li><li><a href="https://github.com/dhdsjy/2016_CCFsougou2" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou2</a></li><li><a href="https://github.com/prozhuchen/2016CCF-sougou" target="_blank" rel="noopener">https://github.com/prozhuchen/2016CCF-sougou</a></li><li><a href="https://github.com/coderSkyChen/2016CCF_BDCI_Sougou" target="_blank" rel="noopener">https://github.com/coderSkyChen/2016CCF_BDCI_Sougou</a></li></ul></li></ul><hr><h3 id="2016-ccf-联通的用户轨迹"><a href="#2016-ccf-联通的用户轨迹" class="headerlink" title="2016 ccf-联通的用户轨迹"></a>2016 ccf-联通的用户轨迹</h3><ul><li><strong>RankX</strong>: <a href="https://github.com/xuguanggen/2016CCF-unicom" target="_blank" rel="noopener">https://github.com/xuguanggen/2016CCF-unicom</a></li></ul><hr><h3 id="2016-ccf-Human-or-Robots"><a href="#2016-ccf-Human-or-Robots" class="headerlink" title="2016 ccf-Human or Robots"></a>2016 ccf-Human or Robots</h3><ul><li><strong>Rank6</strong>: <a href="https://github.com/pickou/ccf_human_or_robot" target="_blank" rel="noopener">https://github.com/pickou/ccf_human_or_robot</a></li></ul><hr><h3 id="菜鸟-需求预测与分仓规划"><a href="#菜鸟-需求预测与分仓规划" class="headerlink" title="菜鸟-需求预测与分仓规划"></a>菜鸟-需求预测与分仓规划</h3><ul><li><strong>Rank6</strong>:<a href="https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning" target="_blank" rel="noopener">https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning</a></li><li><strong>Rank10</strong>: <a href="https://github.com/xing89qs/TianChi_CaiNiao_Season2" target="_blank" rel="noopener">https://github.com/xing89qs/TianChi_CaiNiao_Season2</a></li></ul><hr><p><br></p><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="2018-DC达观-文本智能处理挑战"><a href="#2018-DC达观-文本智能处理挑战" class="headerlink" title="2018 DC达观-文本智能处理挑战"></a>2018 DC达观-文本智能处理挑战</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess</a></li><li><strong>Rank4</strong>: <a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li><li><strong>Rank10</strong>: <a href="https://github.com/moneyDboat/data_grand" target="_blank" rel="noopener">https://github.com/moneyDboat/data_grand</a></li><li><strong>Rank18</strong>: <a href="https://github.com/nlpjoe/daguan-classify-2018" target="_blank" rel="noopener">https://github.com/nlpjoe/daguan-classify-2018</a></li><li><strong>RankX</strong>: <a href="https://github.com/yanqiangmiffy/daguan" target="_blank" rel="noopener">https://github.com/yanqiangmiffy/daguan</a></li></ul><hr><h3 id="智能客服问题相似度算法设计——第三届魔镜杯大赛"><a href="#智能客服问题相似度算法设计——第三届魔镜杯大赛" class="headerlink" title="智能客服问题相似度算法设计——第三届魔镜杯大赛"></a>智能客服问题相似度算法设计——第三届魔镜杯大赛</h3><ul><li><strong>rank6</strong>：<a href="https://github.com/qrfaction/paipaidai" target="_blank" rel="noopener">https://github.com/qrfaction/paipaidai</a></li><li><strong>rank12</strong>：<a href="https://www.jianshu.com/p/827dd447daf9" target="_blank" rel="noopener">https://www.jianshu.com/p/827dd447daf9</a> <a href="https://github.com/LittletreeZou/Question-Pairs-Matching" target="_blank" rel="noopener">https://github.com/LittletreeZou/Question-Pairs-Matching</a></li><li><strong>Rank16</strong>：<a href="https://github.com/guoday/PaiPaiDai2018_rank16" target="_blank" rel="noopener">https://github.com/guoday/PaiPaiDai2018_rank16</a></li><li><strong>Rank29</strong>: <a href="https://github.com/wangjiaxin24/daguan_NLP" target="_blank" rel="noopener">https://github.com/wangjiaxin24/daguan_NLP</a></li></ul><hr><h3 id="2018JD-Dialog-Challenge-任务导向型对话系统挑战赛"><a href="#2018JD-Dialog-Challenge-任务导向型对话系统挑战赛" class="headerlink" title="2018JD Dialog Challenge 任务导向型对话系统挑战赛"></a>2018JD Dialog Challenge 任务导向型对话系统挑战赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/zengbin93/jddc_solution_4th" target="_blank" rel="noopener">https://github.com/zengbin93/jddc_solution_4th</a></li></ul><hr><h3 id="2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛"><a href="#2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛" class="headerlink" title="2018CIKM AnalytiCup  – 阿里小蜜机器人跨语言短文本匹配算法竞赛"></a>2018CIKM AnalytiCup – 阿里小蜜机器人跨语言短文本匹配算法竞赛</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/zake7749/Closer" target="_blank" rel="noopener">https://github.com/zake7749/Closer</a></li><li><strong>Rank12</strong>：<a href="https://github.com/Leputa/CIKM-AnalytiCup-2018" target="_blank" rel="noopener">https://github.com/Leputa/CIKM-AnalytiCup-2018</a></li><li><strong>Rank18</strong>: <a href="https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018" target="_blank" rel="noopener">https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018</a></li></ul><hr><p><br></p><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h3 id="Kaggle-TGS"><a href="#Kaggle-TGS" class="headerlink" title="Kaggle-TGS"></a>Kaggle-TGS</h3><ul><li><strong>Rank56</strong>：<a href="https://github.com/Gary-Deeplearning/TGS-Sal" target="_blank" rel="noopener">https://github.com/Gary-Deeplearning/TGS-Sal</a></li></ul><hr><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><h3 id="经验文章"><a href="#经验文章" class="headerlink" title="经验文章"></a>经验文章</h3><ul><li><p><strong>介绍featexp 一个帮助理解特征的工具包</strong>：<a href="http://www.sohu.com/a/273552971_129720" target="_blank" rel="noopener">http://www.sohu.com/a/273552971_129720</a></p></li><li><p>Ask Me Anything session with a Kaggle Grandmaster Vladimir I. Iglovikov PDF：<a href="https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ</a></p></li></ul><hr><h3 id="大佬的Github"><a href="#大佬的Github" class="headerlink" title="大佬的Github"></a>大佬的Github</h3><ul><li><strong>植物</strong> ：<a href="https://github.com/plantsgo" target="_blank" rel="noopener">https://github.com/plantsgo</a></li><li><strong>wepon</strong> ：<a href="https://github.com/wepe" target="_blank" rel="noopener">https://github.com/wepe</a></li><li><strong>Snake</strong>：<a href="https://github.com/luoda888" target="_blank" rel="noopener">https://github.com/luoda888</a></li><li><strong>Drop-out</strong>：<a href="https://github.com/drop-out" target="_blank" rel="noopener">https://github.com/drop-out</a></li><li><strong>金老师的知乎</strong>：<a href="https://zhuanlan.zhihu.com/jlbookworm" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/jlbookworm</a></li><li><strong>渣大</strong>：<a href="https://github.com/nzc" target="_blank" rel="noopener">https://github.com/nzc</a></li><li><strong>郭大</strong>：<a href="https://github.com/guoday" target="_blank" rel="noopener">https://github.com/guoday</a></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>数据比赛资讯</strong>：<a href="https://github.com/iphysresearch/DataSciComp" target="_blank" rel="noopener">https://github.com/iphysresearch/DataSciComp</a></li><li><strong>ApacheCN 的kaggle资料链接</strong>：<a href="https://github.com/apachecn/kaggle" target="_blank" rel="noopener">https://github.com/apachecn/kaggle</a></li><li><strong>Kaggle top方案整理</strong>：<a href="https://github.com/EliotAndres/kaggle-past-solutions" target="_blank" rel="noopener">https://github.com/EliotAndres/kaggle-past-solutions</a></li></ul><hr><h3 id="团队联系方式"><a href="#团队联系方式" class="headerlink" title="团队联系方式"></a>团队联系方式</h3><ul><li><strong>Smile</strong> qq:240485545 Email:<a href="mailto:smile.xuhc@gmail.com" target="_blank" rel="noopener">smile.xuhc@gmail.com</a></li><li><strong>PUSH</strong> qq:1471386635 Email：<a href="mailto:1471386635@qq.com" target="_blank" rel="noopener">1471386635@qq.com</a></li><li><strong>dive2space</strong> qq: 1124361357 Email:<a href="mailto:dive2space@qq.com" target="_blank" rel="noopener">dive2space@qq.com</a></li></ul><hr><h2 id="来源链接"><a href="#来源链接" class="headerlink" title="来源链接"></a>来源链接</h2><p><a href="https://mp.weixin.qq.com/s/_4QG0dWhh784lF0n1wymcw" target="_blank" rel="noopener">竞赛|数据竞赛Top解决方案开源整理</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://showteeth.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="竞赛" scheme="http://showteeth.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="开源代码" scheme="http://showteeth.tech/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>anaconda管理软件和环境</title>
    <link href="http://showteeth.tech/posts/42087.html"/>
    <id>http://showteeth.tech/posts/42087.html</id>
    <published>2019-04-14T02:49:27.000Z</published>
    <updated>2019-04-15T14:49:51.909Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><ul><li>印象笔记里面的两篇文章</li><li>斌斌师兄的脚本看看(里面有2和3兼容的问题)</li></ul><p>主要想解决的问题：</p><ul><li>环境备份的问题—多台集群环境如何管理</li><li>软件冲突时如何将软件安装在另一个环境中，使用的时候是怎么使用的呢？—直接找到环境的bin目录，然后将给软件指定alias指定到这个目录？</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>csplit-根据文本内容切割文件</title>
    <link href="http://showteeth.tech/posts/1958.html"/>
    <id>http://showteeth.tech/posts/1958.html</id>
    <published>2019-04-12T13:34:07.000Z</published>
    <updated>2019-04-14T01:26:35.109Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux常用的按照文件内容来对文件进行分割的命令csplit，前面学习的split主要是根据文件的外部信息进行的分割；主要学习了利用pattern模式分割以及参数使用；patern方面主要学习了<code>INTEGER</code>、<code>/REGEXP/[OFFSET]</code>、<code>{INTEGER}</code>、<code>{*}</code>以及<code>%REGEXP%[OFFSET]</code>；参数主要学习了<code>-f</code>、<code>-b</code>、<code>-n</code>、<code>-z</code>、<code>-k</code>和<code>-s</code>。</p></div><a id="more"></a><h2 id="csplit简介"><a href="#csplit简介" class="headerlink" title="csplit简介"></a>csplit简介</h2><p><code>csplit</code>主要是依据<strong>文件内容</strong>来进行切割文件，与<code>split</code>不同，<code>split</code>只是<strong>依据文件外部的信息</strong>，包括<strong>大小</strong>、<strong>行数</strong>以及<strong>分割得到的文件数目</strong>来进行限制。</p><hr><h2 id="csplit命令格式"><a href="#csplit命令格式" class="headerlink" title="csplit命令格式"></a>csplit命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  csplit [OPTION]... FILE PATTERN...</span><br></pre></td></tr></table></figure><p><strong>默认输出</strong>：</p><ul><li>每个小文件的字节数目</li><li>文件名为xx00、xx01这种</li></ul><h2 id="csplit-options参数"><a href="#csplit-options参数" class="headerlink" title="csplit options参数"></a>csplit options参数</h2><table><thead><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td><code>-suffix-format=FORMAT</code></td><td>预预设的输出格式其文件名称为xx00，xx01等，用户可以通过改变format来改变输出的文件名；</td></tr><tr><td><code>-f</code></td><td><code>--prefix=PREFIX</code></td><td>设置输出文件名的前缀，替换默认的xx</td></tr><tr><td><code>-k</code></td><td><code>--keep-files</code></td><td>就算发生错误或者终止运行，也不删除已经输出的文件</td></tr><tr><td><code>-n</code></td><td><code>--digits=DIGITS</code></td><td>默认输出的文件后缀为两位数字，这个参数可以修改后缀数字的数目，默认为2</td></tr><tr><td><code>-s</code></td><td><code>--quiet, --silent</code></td><td>静默输出，不显示执行过程</td></tr><tr><td><code>-z</code></td><td><code>--elide-empty-files</code></td><td>删除(不输出)空的输出文件</td></tr></tbody></table><hr><h2 id="csplit-匹配模式"><a href="#csplit-匹配模式" class="headerlink" title="csplit 匹配模式"></a>csplit 匹配模式</h2><p><escepe></escepe></p><p><table><br><thead><br><tr><br><th width="15%">参数</th><br><th width="85%">说明</th><br></tr><br></thead><br><tbody><br><tr><br><td><code>INTEGER</code></td><br><td>使用行数来分割文件(不包括指定的行数)</td><br></tr><br><tr><br><td><code>/REGEXP/[OFFSET]</code></td><br><td>使用REGEXP来分割文件(不包含REGEXP行)</td><br></tr><br><tr><br><td><code>%REGEXP%[OFFSET]</code></td><br><td>跳过REGEXP之前的行，从之后的行开始输出</td><br></tr><br><tr><br><td><code>{INTEGER}</code></td><br><td>重复前面的pattern指定的次数</td><br></tr><br><tr><br><td><code>{*}</code></td><br><td>尽可能多地重复前面的pattern</td><br></tr><br></tbody><br></table><br></p><hr><p><br></p><h2 id="csplit匹配模式使用实例"><a href="#csplit匹配模式使用实例" class="headerlink" title="csplit匹配模式使用实例"></a>csplit匹配模式使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat server.log </span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-3</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><hr><h3 id="INTEGER-按行划分"><a href="#INTEGER-按行划分" class="headerlink" title="INTEGER-按行划分"></a>INTEGER-按行划分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割为前一行 和 剩余的行</span></span><br><span class="line"><span class="comment"># 注意是不包括数字指定的行</span></span><br><span class="line">csplit server.log 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出划分得到的小文件的字节大小</span></span><br><span class="line">  9</span><br><span class="line">  273</span><br></pre></td></tr></table></figure><p><strong>输出内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user   9 Apr 13 16:15 xx00</span><br><span class="line">-rw-rw-r--. 1 user user 273 Apr 13 16:15 xx01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不包括第二行</span></span><br><span class="line">cat xx00</span><br><span class="line">  SERVER-1</span><br></pre></td></tr></table></figure><p></p><p>也可以指定<strong>多个整数</strong>来分割：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定多行文本进行划分</span></span><br><span class="line"><span class="comment"># 分别得到0-1、2-4、5-6、7-最后的文件</span></span><br><span class="line">csplit server.log 2 5 7</span><br><span class="line">  9</span><br><span class="line">  63</span><br><span class="line">  30</span><br><span class="line">  180</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user   9 Apr 13 16:20 xx00</span><br><span class="line">-rw-rw-r--. 1 user user  63 Apr 13 16:20 xx01</span><br><span class="line">-rw-rw-r--. 1 user user  30 Apr 13 16:20 xx02</span><br><span class="line">-rw-rw-r--. 1 user user 180 Apr 13 16:20 xx03</span><br><span class="line"></span><br><span class="line"><span class="comment"># server.log的第2、3、4行</span></span><br><span class="line">cat xx01</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="REGEXP-OFFSET-匹配分割文件"><a href="#REGEXP-OFFSET-匹配分割文件" class="headerlink" title="/REGEXP/[OFFSET]-匹配分割文件"></a>/REGEXP/[OFFSET]-匹配分割文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以SERVER-2为模式进行分割</span></span><br><span class="line"><span class="comment"># 不包括模式匹配上的这一行</span></span><br><span class="line">csplit server.log /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 16:43 xx00</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 16:43 xx01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不包括SERVER-2这一行</span></span><br><span class="line">cat xx00</span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br></pre></td></tr></table></figure><p></p><p><strong>匹配的是pattern第一次出现的位置</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上述测试文件的SERVER-3修改为SERVER-2</span></span><br><span class="line">csplit server.log /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第一次出现SERVER的位置分割</span></span><br><span class="line"><span class="comment"># 因为SERVER出现在第一行，所以第一个文件大小为0</span></span><br><span class="line">csplit server.log /SERVER*/ </span><br><span class="line">  0</span><br><span class="line">  282</span><br></pre></td></tr></table></figure><p></p><p><strong>第一次匹配输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从第一次匹配到SERVER-2的位置进行分割</span></span><br><span class="line">more xx01</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><p><strong>指定模式之后的偏移</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以SERVER-2为模式进行分割</span></span><br><span class="line"><span class="comment">#  并且向下移一行，这样就包括了模式匹配上的那一行</span></span><br><span class="line"><span class="comment"># 偏移+表示向下多输出一行</span></span><br><span class="line"><span class="comment"># -表示向上少输出一样</span></span><br><span class="line">csplit server.log /SERVER-2/+1</span><br><span class="line">  102</span><br><span class="line">  180</span><br></pre></td></tr></table></figure><p></p><p><strong>偏移后的输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SERVER-1</span><br><span class="line">[con] 10.10.10.1 suc</span><br><span class="line">[con] 10.10.10.2 fai</span><br><span class="line">[dis] 10.10.10.3 pen</span><br><span class="line">[con] 10.10.10.4 suc</span><br><span class="line">SERVER-2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>REGEXP</code>匹配的是第一次出现的位置，只会在<strong>第一次出现位置</strong>处切割</li><li>可以设置<code>[OFFSET]</code>来进行匹配行的上下偏移</li></ul></div><hr><h3 id="INTEGER-和-重复前面的pattern"><a href="#INTEGER-和-重复前面的pattern" class="headerlink" title="{INTEGER}和{*}-重复前面的pattern"></a>{INTEGER}和{*}-重复前面的pattern</h3><p>前面的<code>/REGEXP/[OFFSET]</code>只会在第一次出现pattern的位置进行切割，如果想要在所有的pattern匹配位置进行切割，可以借助<code>{INTEGER}</code>和<code>{*}</code>分别进行<strong>指定次数的重复</strong>pattern以及<strong>任意次数的重复</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复前面的pettern一次</span></span><br><span class="line"><span class="comment"># 是重复一次，原本中有2个SERVER-2，只用重复一次即可</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;1&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置重复两次会出错</span></span><br><span class="line"><span class="comment"># 这种情况不会有结果输出</span></span><br><span class="line"><span class="comment"># 可以借助后面的-k参数来保留结果</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复任意次数</span></span><br><span class="line"><span class="comment"># 这样可以避免出现不知道pettern出现几次而出现错误</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;*&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  96</span><br></pre></td></tr></table></figure><p></p><p><strong>结果输出</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost csplit]$ cat xx00 </span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br><span class="line">(base) [user@localhost csplit]$ cat xx01</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">(base) [user@localhost csplit]$ cat xx02</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>{INTEGER}</code>和<code>{*}</code>可以有效<strong>解决<code>/REGEXP/[OFFSET]</code>只会对第一次出现的pattern进行分割的问题</strong>，<strong>重复指定的次数</strong>或者<strong>任意多次</strong>的pattern来对文件进行分割，从而达到<strong>将文件从所有出现pattern的位置进行切割的目的</strong>；</p></div><hr><h3 id="REGEXP-OFFSET-逃过模式之前的行"><a href="#REGEXP-OFFSET-逃过模式之前的行" class="headerlink" title="%REGEXP%[OFFSET]-逃过模式之前的行"></a>%REGEXP%[OFFSET]-逃过模式之前的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过SERVER-2之前的行</span></span><br><span class="line"><span class="comment"># 这里剩下的部分会包含模式这一行</span></span><br><span class="line"><span class="comment"># 相当于把按模式分割的前面几个文件给删掉了</span></span><br><span class="line">csplit server.log %SERVER-2%</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat xx00</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-3</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><p>这个和前面的<code>/REGEXP/[OFFSET]</code>相同，都可以指定<code>[OFFSET]</code>偏移量。</p><hr><h2 id="csplit参数使用实例"><a href="#csplit参数使用实例" class="headerlink" title="csplit参数使用实例"></a>csplit参数使用实例</h2><h3 id="f-设置输出前缀"><a href="#f-设置输出前缀" class="headerlink" title="-f-设置输出前缀"></a>-f-设置输出前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出文件前缀为test</span></span><br><span class="line"><span class="comment"># 以SERVER-2为分割</span></span><br><span class="line">csplit server.log -f <span class="built_in">test</span> /SERVER-2/</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 16:09 test00</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 16:09 test01</span><br><span class="line"></span><br><span class="line">cat test00 </span><br><span class="line"><span class="comment"># 输出内容不包含匹配行</span></span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="b-设置输出文件名称格式"><a href="#b-设置输出文件名称格式" class="headerlink" title="-b-设置输出文件名称格式"></a>-b-设置输出文件名称格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置输出文件名格式之后加上.log后缀</span></span><br><span class="line"><span class="comment"># 设置文件名称等宽，并使用0填充 --&gt; 02d</span></span><br><span class="line">csplit server.log -f <span class="built_in">test</span> -b <span class="string">"%02d.log"</span> /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况是两位的数字后缀，并且指定输出格式一定要是02d，用0填充</span></span><br><span class="line"><span class="comment"># 如果不加0表示用0填充，那么会出现空格填充的情况</span></span><br><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:22 test00.log</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 18:22 test01.log</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-设置后缀数字数目"><a href="#n-设置后缀数字数目" class="headerlink" title="-n-设置后缀数字数目"></a>-n-设置后缀数字数目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csplit server.log -f <span class="built_in">test</span> -b <span class="string">"%03d.log"</span> -n 3 /SERVER-2/</span><br><span class="line">93</span><br><span class="line">189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:28 test000.log</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 18:28 test001.log</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="k-保留运行错误的结果文件"><a href="#k-保留运行错误的结果文件" class="headerlink" title="-k-保留运行错误的结果文件"></a>-k-保留运行错误的结果文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的这个示例</span></span><br><span class="line"><span class="comment"># 因为存在错误，所以不会得到结果文件</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上-k参数来避免这种情况</span></span><br><span class="line"><span class="comment"># 依然后提示错误信息</span></span><br><span class="line"><span class="comment"># 但是会得到能够正确分割的文件</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125; -k</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:33 xx00</span><br><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:33 xx01</span><br><span class="line">-rw-rw-r--. 1 user user  96 Apr 13 18:33 xx02</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="z-不输出空文件"><a href="#z-不输出空文件" class="headerlink" title="-z-不输出空文件"></a>-z-不输出空文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下会输出文件大小为0的文件</span></span><br><span class="line">csplit server.log /SERVER/</span><br><span class="line">  0</span><br><span class="line">  282</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-z参数就不会输出空文件</span></span><br><span class="line">csplit server.log /SERVER/ -z</span><br><span class="line">  282</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds1/csplit.htm" target="_blank" rel="noopener">csplit 命令</a></li><li><a href="http://man.linuxde.net/csplit" target="_blank" rel="noopener">csplit命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux常用的按照文件内容来对文件进行分割的命令csplit，前面学习的split主要是根据文件的外部信息进行的分割；主要学习了利用pattern模式分割以及参数使用；patern方面主要学习了&lt;code&gt;INTEGER&lt;/code&gt;、&lt;code&gt;/REGEXP/[OFFSET]&lt;/code&gt;、&lt;code&gt;{INTEGER}&lt;/code&gt;、&lt;code&gt;{*}&lt;/code&gt;以及&lt;code&gt;%REGEXP%[OFFSET]&lt;/code&gt;；参数主要学习了&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-z&lt;/code&gt;、&lt;code&gt;-k&lt;/code&gt;和&lt;code&gt;-s&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看CPU型号、内存、硬盘等信息</title>
    <link href="http://showteeth.tech/posts/9853.html"/>
    <id>http://showteeth.tech/posts/9853.html</id>
    <published>2019-04-12T03:33:53.000Z</published>
    <updated>2019-04-13T09:53:32.152Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习和总结了Linux中查看CPU型号、内存、硬盘等信息的命令，便于日常使用查询。</p></div><a id="more"></a><h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><p>CPU相关的信息都保存在<code>/proc/cpuinfo</code>文件中</p><h3 id="查看CPU个数"><a href="#查看CPU个数" class="headerlink" title="查看CPU个数"></a>查看CPU个数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="查看CPU核数"><a href="#查看CPU核数" class="headerlink" title="查看CPU核数"></a>查看CPU核数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">cpu cores: 6</span><br></pre></td></tr></table></figure><hr><h3 id="查看CPU型号"><a href="#查看CPU型号" class="headerlink" title="查看CPU型号"></a>查看CPU型号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">'model name'</span> |uniq</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz</span><br></pre></td></tr></table></figure><hr><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><p>内存信息保存在<code>/proc/meminfo</code>中</p><h3 id="查看内存大小"><a href="#查看内存大小" class="headerlink" title="查看内存大小"></a>查看内存大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo | grep MemTotal</span><br><span class="line"><span class="comment"># 输出内存大小，Kb为单位</span></span><br><span class="line"><span class="comment"># 大小为49G</span></span><br><span class="line">MemTotal:       49219420 kB</span><br></pre></td></tr></table></figure><hr><h3 id="查看内存条数"><a href="#查看内存条数" class="headerlink" title="查看内存条数"></a>查看内存条数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dmidecode |grep -A16 <span class="string">"Memory Device$"</span></span><br><span class="line"><span class="comment"># 实验室集群安装了6个8G的，还有8个卡槽没有安装内存条</span></span><br><span class="line">  Memory Device</span><br><span class="line">    Array Handle: 0x002F</span><br><span class="line">    Error Information Handle: Not Provided</span><br><span class="line">    Total Width: 72 bits</span><br><span class="line">    Data Width: 64 bits</span><br><span class="line">    Size: 8192 MB      <span class="comment"># 这里安装了一个8G的内存</span></span><br><span class="line">    Form Factor: DIMM</span><br><span class="line">    Set: None</span><br><span class="line">    Locator: DIMM1_CPU1</span><br><span class="line">    Bank Locator: Not Specified</span><br><span class="line">    Type: Other</span><br><span class="line">    Type Detail: Synchronous</span><br><span class="line">    Speed: 2400 MHz</span><br><span class="line">    Manufacturer: Undefined</span><br><span class="line">    Serial Number: 131087AA</span><br><span class="line">    Asset Tag: DIMM1_CPU1_AssetTag</span><br><span class="line">    Part Number: KHX2400C15/8G</span><br></pre></td></tr></table></figure><hr><h2 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h2><h3 id="查看硬盘大小"><a href="#查看硬盘大小" class="headerlink" title="查看硬盘大小"></a>查看硬盘大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l | grep Disk</span><br><span class="line"><span class="comment"># 输出的硬盘信息</span></span><br><span class="line">  Disk /dev/sda: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00097e63</span><br><span class="line">  Disk /dev/sdb: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00091a2b</span><br><span class="line">  Disk /dev/sdc: 4000.8 GB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00000000</span><br><span class="line">  Disk /dev/sdd: 2000.4 GB, 2000398934016 bytes, 3907029168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x4120a342</span><br><span class="line">  Disk /dev/mapper/centos-root: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">  Disk /dev/mapper/centos-swap: 8388 MB, 8388608000 bytes, 16384000 sectors</span><br><span class="line">  Disk /dev/mapper/centos-home: 1937.7 GB, 1937730699264 bytes, 3784630272 sectors</span><br></pre></td></tr></table></figure><hr><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><h3 id="查看Linux系统信息"><a href="#查看Linux系统信息" class="headerlink" title="查看Linux系统信息"></a>查看Linux系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">Linux localhost.localdomain 3.10.0-327.18.2.el7.x86_64 <span class="comment">#1 SMP Thu May 12 11:03:55 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/97157.htm" target="_blank" rel="noopener">Linux下查看CPU型号,内存大小,硬盘空间的命令(详解)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习和总结了Linux中查看CPU型号、内存、硬盘等信息的命令，便于日常使用查询。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>split-按大小分割文件</title>
    <link href="http://showteeth.tech/posts/41178.html"/>
    <id>http://showteeth.tech/posts/41178.html</id>
    <published>2019-04-11T14:37:37.000Z</published>
    <updated>2019-04-12T02:08:22.298Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux中用于按照<strong>指定的需求(大小、行数、文件数目)拆分文件的命令</strong><code>split</code>，是<code>cat</code>命令合并文件功能的反向操作；主要参数包括：<code>-l</code>、<code>-b(K、M、T，默认是bytes)</code>、<code>-d(--numeric-suffixes=num)</code>、<code>文件前缀</code>、<code>-a(默认为2)</code>、<code>--additional-suffix=str</code>、<code>-n(N、K/N、l/N、l/K/N)</code>、<code>-e</code>等参数；最后可以通过<code>md5sum</code>命令检查split之后cat命令合并得到的文件和原始文件相比<strong>是否完整</strong>。</p></div><a id="more"></a><h2 id="split简介"><a href="#split简介" class="headerlink" title="split简介"></a>split简介</h2><p><code>Linux split</code>命令可以将一个大文件分割成指定大小的很多个小文件，并且拆分速度非常的快，可以看成是<code>cat</code>命令合并文件功能的反操作，其主要<strong>特点</strong>：</p><ul><li>可以指定子文件的行数、大小以及子文件的数目</li><li>指定大小以及子文件数目(默认情况)会对一行甚至是一个单词的内容进行切割，指定子文件数目中可以读这种情况进行调整</li><li>指定的文件前缀名需要放在split文件之后，不然会报错，前缀默认为x</li><li>可以指定文件的后缀(数字、字符)以及后缀的数目，后缀默认是从aa开始递增的两位字符</li><li>可以文件添加统一的后缀(作为文件的拓展名)</li></ul><h2 id="split命令格式"><a href="#split命令格式" class="headerlink" title="split命令格式"></a>split命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  split [OPTION]... [INPUT [PREFIX]]</span><br></pre></td></tr></table></figure><ul><li>Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ..</li><li><strong>default size</strong> is 1000 lines</li><li><strong>default PREFIX</strong> is ‘x’</li><li><strong>With no INPU</strong>T, or when INPUT is <code>-</code>, read standard input</li></ul><hr><h2 id="split参数"><a href="#split参数" class="headerlink" title="split参数"></a>split参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-l</code></td><td><code>--lines=NUMBER</code></td><td>指定每多少行切成一个小文件</td></tr><tr><td><code>-b</code></td><td><code>--bytes=SIZE</code></td><td>指定每多少字节切成一个小文件，单位可以是K、M、G</td></tr><tr><td><code>-d</code></td><td><code>--numeric-suffixes[=FROM]</code></td><td>使用数字作为小文件名称的后缀，默认从0开始(使用from调节)</td></tr><tr><td></td><td><code>--additional-suffix=SUFFIX</code></td><td>小文件名称的后缀，默认从 aa 开始</td></tr><tr><td><code>-n</code></td><td><code>--number=CHUNKS</code></td><td>分得的文件(CHUNKS)数目</td></tr><tr><td><code>-a</code></td><td><code>--suffix-length=N</code></td><td>后缀长度，默认是2，也就是按 aa、ab、ac 这样的格式依次编号</td></tr><tr><td><code>-C</code></td><td><code>--line-bytes=SIZE</code></td><td>put at most SIZE bytes of lines per output file</td></tr><tr><td><code>-e</code></td><td><code>--elide-empty-files</code></td><td>在使用-n参数的时候不产生空的文件</td></tr><tr><td></td><td><code>--verbose</code></td><td>显示分割进度</td></tr></table><p><strong>CHUNKS</strong>:</p><table><tr><th width="15%">参数</th><th width="85%">说明</th></tr><tr><td><code>N</code></td><td>分割为N个文件</td></tr><tr><td><code>K/N</code></td><td>将N个文件中的第K个输出到标准输出</td></tr><tr><td><code>l/N</code></td><td><strong>在不分割行</strong>的情况下分割为N个文件</td></tr><tr><td><code>l/K/N</code></td><td>将<strong>在不分割行</strong>的情况下得到的N个文件中的第K个输出到标准输出</td></tr><tr><td><code>r/N</code></td><td>like 'l' but use round robin distribution</td></tr><tr><td><code>r/K/N</code></td><td>likewise but only output Kth of N to stdout</td></tr></table><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="l-指定每个文件的行数"><a href="#l-指定每个文件的行数" class="headerlink" title="-l-指定每个文件的行数"></a>-l-指定每个文件的行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件的行数</span></span><br><span class="line">wc -l test.txt </span><br><span class="line">  51 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个文件10行</span></span><br><span class="line">split -l 10 test.txt</span><br><span class="line">  <span class="comment"># 生成6个文件</span></span><br><span class="line">  <span class="comment"># 其中最后一个文件只有一行</span></span><br><span class="line">-rw-rw-r--. 1 user user 5779 Apr 12 00:10 test.txt</span><br><span class="line">-rw-rw-r--. 1 user user  338 Apr 12 00:12 xaa</span><br><span class="line">-rw-rw-r--. 1 user user 1900 Apr 12 00:12 xab</span><br><span class="line">-rw-rw-r--. 1 user user 1513 Apr 12 00:12 xac</span><br><span class="line">-rw-rw-r--. 1 user user 1523 Apr 12 00:12 xad</span><br><span class="line">-rw-rw-r--. 1 user user  432 Apr 12 00:12 xae</span><br><span class="line">-rw-rw-r--. 1 user user   73 Apr 12 00:12 xaf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="comment"># 空行也算行</span></span><br><span class="line"><span class="comment"># 换行算一行，不进行切割</span></span><br><span class="line">cat -n xac</span><br><span class="line">     1</span><br><span class="line">     2In particular, Anaconda Distribution contains re-distributable, run-time, shared-library files from the Intel(TM) Math Kernel Library (<span class="string">"MKL binaries"</span>). You are specifically authorized to use the MKL binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the MKL binaries with Anaconda Distribution or <span class="keyword">in</span> the conda package that contains them. Use and redistribution of the MKL binaries are subject to the licensing terms located at https://software.intel.com/en-us/license/intel-simplified-software-license. If needed, instructions <span class="keyword">for</span> removing the MKL binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line">     3</span><br><span class="line">     4Anaconda Distribution also contains cuDNN software binaries from NVIDIA Corporation (<span class="string">"cuDNN binaries"</span>). You are specifically authorized to use the cuDNN binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the cuDNN binaries with an Anaconda Distribution package that contains them. If needed, instructions <span class="keyword">for</span> removing the cuDNN binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line">     5</span><br><span class="line">     6</span><br><span class="line">     7Anaconda Distribution also contains Visual Studio Code software binaries from Microsoft Corporation (<span class="string">"VS Code"</span>). You are specifically authorized to use VS Code with your installation of Anaconda Distribution. Use of VS Code is subject to the licensing terms located at https://code.visualstudio.com/License.</span><br><span class="line">     8</span><br><span class="line">     9Cryptography Notice</span><br><span class="line">    10===================</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>不足指定行数的也放在一个文件中</li><li>空行也算行</li><li>一行文本太长换行的话算一行，不进行切割</li></ul></div><hr><h3 id="b-指定分割文件大小"><a href="#b-指定分割文件大小" class="headerlink" title="-b-指定分割文件大小"></a>-b-指定分割文件大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认单位是b</span></span><br><span class="line">split -b 1000 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 可以和前面-l的输出结果对比</span></span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xab</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xac</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xad</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:35 xaf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看输出文件内容</span></span><br><span class="line"><span class="comment"># 会对一行的内容甚至的一个单词进行切割</span></span><br><span class="line">cat xab</span><br><span class="line">  DING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANACONDA, INC. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"></span><br><span class="line">  Notice of Third Party Software Licenses</span><br><span class="line">  =======================================</span><br><span class="line"></span><br><span class="line">  Anaconda Distribution contains open <span class="built_in">source</span> software packages from third parties. These are available on an <span class="string">"as is"</span> basis and subject to their individual license agreements. These licenses are available <span class="keyword">in</span> Anaconda Distribution or at http://docs.anaconda.com/anaconda/pkg-docs. Any binary packages of thes</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>不同于<code>-l</code>参数会<strong>保留行的完整性</strong>，<code>-b</code>参数<strong>会对同一行甚至同一个单词进行切割</strong></li><li><code>-b</code>参数可以指定的单位包括<code>K</code>、<code>M</code>、<code>G</code>，<strong>默认是字节</strong></li></ul></div><hr><h3 id="指定文件名前缀"><a href="#指定文件名前缀" class="headerlink" title="指定文件名前缀"></a>指定文件名前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件的前缀需要放在split文件之后</span></span><br><span class="line"><span class="comment"># 不然会报错</span></span><br><span class="line">split <span class="built_in">test</span> -b 1000 test.txt</span><br><span class="line">  split: cannot open ‘<span class="built_in">test</span>’ <span class="keyword">for</span> reading: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到的文件的前缀为test</span></span><br><span class="line"><span class="comment"># 替换默认的前缀x</span></span><br><span class="line">split -b 1000 test.txt <span class="built_in">test</span></span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testab</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testac</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testad</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testae</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:38 testaf</span><br></pre></td></tr></table></figure><hr><h3 id="d-指定数字后缀"><a href="#d-指定数字后缀" class="headerlink" title="-d-指定数字后缀"></a>-d-指定数字后缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的后缀的aa开始的</span></span><br><span class="line"><span class="comment"># 这里指定以数字作为后缀</span></span><br><span class="line"><span class="comment"># 默认后缀从0开始</span></span><br><span class="line">split -b 1000 -d test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x00</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x01</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x02</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x03</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x04</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:45 x05</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置后缀从10开始</span></span><br><span class="line"><span class="comment"># 注意这里只能使用完整的参数形式，不能使用-d这种简写的</span></span><br><span class="line">split -b 1000 --numeric-suffixes=10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x10</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x11</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x12</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x13</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x14</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:49 x15</span><br></pre></td></tr></table></figure><hr><h3 id="a-设置后缀的长度"><a href="#a-设置后缀的长度" class="headerlink" title="-a-设置后缀的长度"></a>-a-设置后缀的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置数字后缀的长度为3</span></span><br><span class="line">split -b 1000 -a 3 -d test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x000</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x001</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x002</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x003</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x004</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:47 x005</span><br></pre></td></tr></table></figure><hr><h3 id="在文件名最后添加额外的后缀"><a href="#在文件名最后添加额外的后缀" class="headerlink" title="在文件名最后添加额外的后缀"></a>在文件名最后添加额外的后缀</h3><p>这里额外的后缀和前面的数字和默认字符串后缀不同，这个后缀是统一的(<strong>可以用来指定文件格式</strong>)，所有文件的都相同，而前面的数字和默认字符串后缀会随着文件数目而变化：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定额外的后缀为test</span></span><br><span class="line">split -b 1000 --numeric-suffixes=10 --additional-suffix=<span class="string">'.txt'</span>  test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x10.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x11.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x12.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x13.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x14.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 01:33 x15.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-设置文件的数目"><a href="#n-设置文件的数目" class="headerlink" title="-n-设置文件的数目"></a>-n-设置文件的数目</h3><h4 id="N-分割为N个文件"><a href="#N-分割为N个文件" class="headerlink" title="N-分割为N个文件"></a>N-分割为N个文件</h4><p><strong>以文件大小为依据平均分割为N个文件</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定分割的文件数目为10</span></span><br><span class="line"><span class="comment"># 注意和前面的-b、-l区分，这里的数目是固定的</span></span><br><span class="line"><span class="comment"># 每个文件的大小是相同的，最后一个文件可能大或者小</span></span><br><span class="line">split -n 10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xad</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xai</span><br><span class="line">  -rw-rw-r--. 1 user user  586 Apr 12 00:55 xaj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看其中一个文件内容，发现有些行被中间截断了</span></span><br><span class="line">cat xaf</span><br><span class="line">  n are available at http://www.anaconda.com.</span><br><span class="line"></span><br><span class="line">  Anaconda Distribution also contains cuDNN software binaries from NVIDIA Corporation (<span class="string">"cuDNN binaries"</span>). You are specifically authorized to use the cuDNN binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the cuDNN binaries with an Anaconda Distribution package that contains them. If needed, instructions <span class="keyword">for</span> removing the cuDNN binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Anaconda Distribution also contains Visual Studio Code softw</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>前面的<code>-l</code>、<code>-b</code>参数是按照<strong>指定行数或者大小来分割文件</strong>，<strong>文件数目不可控</strong>；而<code>-n</code>指定<strong>分割得到的文件数目</strong>，<strong>数目多少是可控的</strong>，并且<strong>除最后一个文件外，大小是相同的</strong>；</li><li><code>-n</code>参数会依据文件大小<strong>严格分割</strong>得到n个文件，<strong>可能会对同一行甚至是一个单词的内容进行切割</strong>，这个<strong>和<code>-b</code>参数类似</strong>;</li></ul></div><hr><h4 id="K-N-将N个文件中的第K个输出到标准输出"><a href="#K-N-将N个文件中的第K个输出到标准输出" class="headerlink" title="K/N-将N个文件中的第K个输出到标准输出"></a>K/N-将N个文件中的第K个输出到标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在屏幕输出分割得到的10个文件中的第1个</span></span><br><span class="line"><span class="comment"># 不会得到分割的文件</span></span><br><span class="line"><span class="comment"># 还是会对行进行分割</span></span><br><span class="line">split -n 1/10 test.txt </span><br><span class="line">  ===================================</span><br><span class="line">  Anaconda End User License Agreement</span><br><span class="line">  ===================================</span><br><span class="line"></span><br><span class="line">  Copyright 2015, Anaconda, Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">  Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of <span class="built_in">source</span> code must retain the above copyright notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright notice, this list of conditions and the</span><br></pre></td></tr></table></figure><hr><h4 id="l-N-在不分割行的情况下分割为N个文件"><a href="#l-N-在不分割行的情况下分割为N个文件" class="headerlink" title="l/N-在不分割行的情况下分割为N个文件"></a>l/N-在不分割行的情况下分割为N个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不分割行的情况下分割为10个文件</span></span><br><span class="line"><span class="comment"># 分割得到10个文件，保持了行的连续性</span></span><br><span class="line"><span class="comment"># 可能会得到大小为0的文件，不一定在最后</span></span><br><span class="line">split -n l/10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  674 Apr 12 01:21 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  940 Apr 12 01:21 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  624 Apr 12 01:21 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  691 Apr 12 01:21 xad</span><br><span class="line">  -rw-rw-r--. 1 user user    0 Apr 12 01:21 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  781 Apr 12 01:21 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  535 Apr 12 01:21 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  650 Apr 12 01:21 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  378 Apr 12 01:21 xai</span><br><span class="line">  -rw-rw-r--. 1 user user  506 Apr 12 01:21 xaj</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-n l/N</code>：在<strong>指定分割得到的文件数目</strong>的<strong>同时保留了每个文件中行的完整性</strong></p></div><hr><h4 id="e-在使用-n参数的时候不产生空的文件"><a href="#e-在使用-n参数的时候不产生空的文件" class="headerlink" title="-e-在使用-n参数的时候不产生空的文件"></a>-e-在使用-n参数的时候不产生空的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不输出空的文件</span></span><br><span class="line"><span class="comment"># 对比前面的-n l/10，这里不产生空的文件(前面的xae)</span></span><br><span class="line">split -n l/10 -e test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  674 Apr 12 01:30 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  940 Apr 12 01:30 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  624 Apr 12 01:30 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  691 Apr 12 01:30 xad</span><br><span class="line">  -rw-rw-r--. 1 user user  781 Apr 12 01:30 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  535 Apr 12 01:30 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  650 Apr 12 01:30 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  378 Apr 12 01:30 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  506 Apr 12 01:30 xai</span><br></pre></td></tr></table></figure><hr><h4 id="l-K-N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出"><a href="#l-K-N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出" class="headerlink" title="l/K/N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出"></a>l/K/N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类似于前面的K/N</span></span><br><span class="line"><span class="comment"># 直接在屏幕输出分割得到的10个文件中的第1个</span></span><br><span class="line"><span class="comment"># 只是保留了行的完整性</span></span><br><span class="line">split -n l/1/10 test.txt </span><br><span class="line">  ===================================</span><br><span class="line">  Anaconda End User License Agreement</span><br><span class="line">  ===================================</span><br><span class="line"></span><br><span class="line">  Copyright 2015, Anaconda, Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">  Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of <span class="built_in">source</span> code must retain the above copyright notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer <span class="keyword">in</span> the documentation and/or other materials provided with the distribution.</span><br></pre></td></tr></table></figure><hr><h3 id="cat合并并校验文件"><a href="#cat合并并校验文件" class="headerlink" title="cat合并并校验文件"></a>cat合并并校验文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先拆分为3个文件</span></span><br><span class="line">split -n 3 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1926 Apr 12 09:37 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1926 Apr 12 09:37 xab</span><br><span class="line">  -rw-rw-r--. 1 user user 1927 Apr 12 09:37 xac</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看原始的md5值</span></span><br><span class="line">md5sum test.txt </span><br><span class="line">  27272b6fb8e9e0b22f8f0f5afc6e1346  test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并文件</span></span><br><span class="line">cat xa&#123;a..c&#125; &gt;merged.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看合并后文件的md5值</span></span><br><span class="line">md5sum merged.txt </span><br><span class="line">  27272b6fb8e9e0b22f8f0f5afc6e1346  merged.txt</span><br></pre></td></tr></table></figure><div class="note info"><p>对<strong>split之后的文件</strong>进行<strong>cat操作得到的文件md5值和原始文件相同</strong></p></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/split.html" target="_blank" rel="noopener">split命令_Linux split命令：切割（拆分）文件</a></li><li></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了linux中用于按照&lt;strong&gt;指定的需求(大小、行数、文件数目)拆分文件的命令&lt;/strong&gt;&lt;code&gt;split&lt;/code&gt;，是&lt;code&gt;cat&lt;/code&gt;命令合并文件功能的反向操作；主要参数包括：&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-b(K、M、T，默认是bytes)&lt;/code&gt;、&lt;code&gt;-d(--numeric-suffixes=num)&lt;/code&gt;、&lt;code&gt;文件前缀&lt;/code&gt;、&lt;code&gt;-a(默认为2)&lt;/code&gt;、&lt;code&gt;--additional-suffix=str&lt;/code&gt;、&lt;code&gt;-n(N、K/N、l/N、l/K/N)&lt;/code&gt;、&lt;code&gt;-e&lt;/code&gt;等参数；最后可以通过&lt;code&gt;md5sum&lt;/code&gt;命令检查split之后cat命令合并得到的文件和原始文件相比&lt;strong&gt;是否完整&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>paste-合并文件</title>
    <link href="http://showteeth.tech/posts/22454.html"/>
    <id>http://showteeth.tech/posts/22454.html</id>
    <published>2019-04-11T13:41:51.000Z</published>
    <updated>2019-04-14T00:51:25.154Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中常用的<strong>合并文件命令</strong><code>paste</code>，主要参数包括<code>-s</code>、<code>-d</code>，这个参数与<code>cut</code>命令的功能相反；<strong>与<code>cat</code>命令相比</strong>，<code>paste</code><strong>默认按行合并</strong>，如果指定<code>-s</code>参数之后进行<strong>先在一个文件内部按指定的分隔符将所有的行合并</strong>，<strong>然后在所有的文件之间按列合并</strong>。</p></div><a id="more"></a><h2 id="paste简介"><a href="#paste简介" class="headerlink" title="paste简介"></a>paste简介</h2><p><code>paste</code>命令主要用来将多个文件的内容合并(<strong>按行或者按列合并</strong>)，与<code>cut</code>命令完成的功能刚好相反。<br>特点：</p><ul><li>可以指定分隔符</li><li>可以先在一个文件内部按指定的分隔符将所有的行合并，然后在所有的文件之间按列合并</li><li>注意与cat命令合并文件的区别：<ul><li>cat只能按列合并文件</li><li>paste默认按行合并，如果指定-s参数之后进行先在一个文件内部按指定的分隔符将所有的行合并，然后在所有的文件之间按列合并</li></ul></li></ul><h2 id="paste命令格式"><a href="#paste命令格式" class="headerlink" title="paste命令格式"></a>paste命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  paste [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p>Write lines consisting of the sequentially corresponding lines from each FILE, separated by TABs, to standard output.<br>With <strong>no FILE</strong>, or when FILE is <code>-</code>, <strong>read standard input</strong>.</p><hr><h2 id="paste命令参数"><a href="#paste命令参数" class="headerlink" title="paste命令参数"></a>paste命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-d</code></td><td><code>--delimiters=LIST</code></td><td>设置分割字符，默认为tab</td></tr><tr><td><code>-s</code></td><td><code>--serial</code></td><td>先在文件内部按指定的分隔符合并行，然后所有的文件之间按列合并</td></tr></table><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat test1.txt<br>1<br>2<br>3</p></blockquote><blockquote><p>cat test2.txt<br>a<br>b<br>c</p></blockquote><blockquote><p>cat test3.txt<br>d<br>e<br>f<br>g</p></blockquote><blockquote><p>cat test4.txt<br>a<br>c<br>b</p></blockquote><hr><h3 id="默认连接文件"><a href="#默认连接文件" class="headerlink" title="默认连接文件"></a>默认连接文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下以tab分隔两个不同的文件内容</span></span><br><span class="line">paste test1.txt test2.txt |cat -T</span><br><span class="line"><span class="comment"># cat -T显示tab为^I</span></span><br><span class="line">  1^Ia</span><br><span class="line">  2^Ib</span><br><span class="line">  3^Ic</span><br></pre></td></tr></table></figure><hr><h3 id="d-设置分隔符"><a href="#d-设置分隔符" class="headerlink" title="-d-设置分隔符"></a>-d-设置分隔符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置分隔符为$</span></span><br><span class="line">paste -d <span class="string">'$'</span> test1.txt test2.txt</span><br><span class="line">1<span class="variable">$a</span></span><br><span class="line">2<span class="variable">$b</span></span><br><span class="line">3<span class="variable">$c</span></span><br></pre></td></tr></table></figure><hr><h3 id="s-设置按列合并"><a href="#s-设置按列合并" class="headerlink" title="-s-设置按列合并"></a>-s-设置按列合并</h3><p><code>-s</code>参数相当于<strong>先将每一个文件内部按照指定的分隔符进行合并</strong>，然后<strong>再和另一个文件按列进行合并</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paste -d <span class="string">'$'</span> -s test1.txt test2.txt </span><br><span class="line">  <span class="comment"># 先在文件内部合并为一行，然后两个文件按列合并</span></span><br><span class="line">  1<span class="variable">$2</span><span class="variable">$3</span></span><br><span class="line">  a<span class="variable">$b</span><span class="variable">$c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独的一个文件内部合并为一行</span></span><br><span class="line">paste -d <span class="string">'$'</span> -s test1.txt </span><br><span class="line">1<span class="variable">$2</span><span class="variable">$3</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="行数不同"><a href="#行数不同" class="headerlink" title="行数不同"></a>行数不同</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于合并的文件如果行数不同，则会空行</span></span><br><span class="line"><span class="comment"># 不会报错</span></span><br><span class="line">paste test1.txt test3.txt </span><br><span class="line">  1d</span><br><span class="line">  2e</span><br><span class="line">  3f</span><br><span class="line">    g</span><br></pre></td></tr></table></figure><hr><h3 id="文件未排序"><a href="#文件未排序" class="headerlink" title="文件未排序"></a>文件未排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paste test1.txt test4.txt </span><br><span class="line"><span class="comment"># 文件未排序也能正常合并</span></span><br><span class="line">  1a</span><br><span class="line">  2c</span><br><span class="line">  3b</span><br></pre></td></tr></table></figure><hr><h3 id="cat-按列合并"><a href="#cat-按列合并" class="headerlink" title="cat-按列合并"></a>cat-按列合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt test2.txt </span><br><span class="line"><span class="comment"># 按列合并</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br></pre></td></tr></table></figure><hr><h3 id="标准输出的特殊用法"><a href="#标准输出的特殊用法" class="headerlink" title="标准输出的特殊用法"></a>标准输出的特殊用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[user@localhost paste]$ cat test1.txt |paste -</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"><span class="comment"># 一个-表示从前面读取一行用于合并</span></span><br><span class="line"><span class="comment"># 可以将一行看做一个文件</span></span><br><span class="line">[user@localhost paste]$ cat test1.txt |paste - -</span><br><span class="line">12</span><br><span class="line">3</span><br><span class="line">[user@localhost paste]$ cat test1.txt |paste - - -</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中常用的&lt;strong&gt;合并文件命令&lt;/strong&gt;&lt;code&gt;paste&lt;/code&gt;，主要参数包括&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;，这个参数与&lt;code&gt;cut&lt;/code&gt;命令的功能相反；&lt;strong&gt;与&lt;code&gt;cat&lt;/code&gt;命令相比&lt;/strong&gt;，&lt;code&gt;paste&lt;/code&gt;&lt;strong&gt;默认按行合并&lt;/strong&gt;，如果指定&lt;code&gt;-s&lt;/code&gt;参数之后进行&lt;strong&gt;先在一个文件内部按指定的分隔符将所有的行合并&lt;/strong&gt;，&lt;strong&gt;然后在所有的文件之间按列合并&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Windows和Linux下使用tree命令</title>
    <link href="http://showteeth.tech/posts/15686.html"/>
    <id>http://showteeth.tech/posts/15686.html</id>
    <published>2019-04-07T12:38:56.000Z</published>
    <updated>2019-04-10T06:47:40.885Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><code>tree</code>命令可以<strong>以树的形式显示文件夹的结构</strong>，便于观察，这里记录了在<code>windows</code>和<code>linux</code>平台上安装和使用<code>tree</code>命令的过程。</p></div><a id="more"></a><h2 id="windows下简便用法"><a href="#windows下简便用法" class="headerlink" title="windows下简便用法"></a>windows下简便用法</h2><p>在<code>git bash</code>中使用命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd //c tree</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文件夹 PATH 列表</span><br><span class="line">卷序列号为 AC83-2977</span><br><span class="line">D:.</span><br><span class="line">├─docs</span><br><span class="line">│  ├─css</span><br><span class="line">│  ├─img</span><br><span class="line">│  ├─js</span><br><span class="line">│  ├─projects</span><br><span class="line">│  ├─resource</span><br><span class="line">│  └─software</span><br><span class="line">└─site</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：这个在<code>cmd</code>中<strong>不能使用</strong></p></div><hr><h2 id="windows下安装使用"><a href="#windows下安装使用" class="headerlink" title="windows下安装使用"></a>windows下安装使用</h2><ul><li><p>从<a href="http://gnuwin32.sourceforge.net/packages/tree.htm" target="_blank" rel="noopener">这个链接</a>中下载<a href="http://downloads.sourceforge.net/gnuwin32/tree-1.5.2.2-setup.exe" target="_blank" rel="noopener">tree-1.5.2.2-setup.exe</a>文件，然后进行常规的<strong>安装步骤</strong>，<strong>得到</strong><code>tree.exe</code>文件;</p></li><li><p>然后将<strong>安装得到</strong>的<code>tree.exe</code>文件<strong>复制到Git的安装目录</strong>：<code>C:\Program Files\Git\usr\bin</code>，注意<strong>一定要是usr下的这个目录</strong>，<strong>不能直接放在git下的bin目录</strong>;</p></li><li><p>最后在<code>git bash</code>下就可以使用tree命令了，<code>cmd</code>下在执行tree-1.5.2.2-setup.exe安装之后就可以使用，<strong>不过使用局限较大，只有两个参数，默认显示所有的文件夹，可以使用<code>/F</code>显示所有的文件</strong>:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd下使用</span></span><br><span class="line"><span class="comment"># 不加参数，直接指定文件夹</span></span><br><span class="line">tree chIA-drop</span><br><span class="line">  文件夹 PATH 列表</span><br><span class="line">  卷序列号为 CC05-4904</span><br><span class="line">  C:\USERS\user\DESKTOP\CHIA-DROP</span><br><span class="line">  └─scripts</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd下查看命令帮助</span></span><br><span class="line">tree /?</span><br><span class="line">以图形显示驱动器或路径的文件夹结构。</span><br><span class="line"></span><br><span class="line">TREE [drive:][path] [/F] [/A]</span><br><span class="line"><span class="comment"># 可以发现cmd下只有两个参数</span></span><br><span class="line">   /F   显示每个文件夹中文件的名称。</span><br><span class="line">   /A   使用 ASCII 字符，而不使用扩展字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># git bash下可以正常使用</span></span><br></pre></td></tr></table></figure><hr><h2 id="Linux下安装使用"><a href="#Linux下安装使用" class="headerlink" title="Linux下安装使用"></a>Linux下安装使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要管理员权限</span></span><br><span class="line">yum install tree -y</span><br></pre></td></tr></table></figure><hr><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree命令行参数：</span><br><span class="line"></span><br><span class="line">-a 显示所有文件和目录。</span><br><span class="line">-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span><br><span class="line">-C 在文件和目录清单加上色彩，便于区分各种类型。</span><br><span class="line">-d 显示目录名称而非内容。</span><br><span class="line">-D 列出文件或目录的更改时间。</span><br><span class="line">-f 在每个文件或目录之前，显示完整的相对路径名称。</span><br><span class="line">-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"="</span>,<span class="string">"@"</span>,<span class="string">"|"</span>号。</span><br><span class="line">-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span><br><span class="line">-i 不以阶梯状列出文件或目录名称。</span><br><span class="line">-I 不显示符合范本样式的文件或目录名称。</span><br><span class="line">-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span><br><span class="line">-n 不在文件和目录清单加上色彩。</span><br><span class="line">-N 直接列出文件和目录名称，包括控制字符。</span><br><span class="line">-p 列出权限标示。</span><br><span class="line">-P 只显示符合范本样式的文件或目录名称。</span><br><span class="line">-q 用<span class="string">"?"</span>号取代控制字符，列出文件和目录名称。</span><br><span class="line">-s 列出文件或目录大小。</span><br><span class="line">-t 用文件和目录的更改时间排序。</span><br><span class="line">-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span><br><span class="line">-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.computerhope.com/unix/tree.htm" target="_blank" rel="noopener">Linux tree command</a></li><li><a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener">tree(1) - Linux man page</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;tree&lt;/code&gt;命令可以&lt;strong&gt;以树的形式显示文件夹的结构&lt;/strong&gt;，便于观察，这里记录了在&lt;code&gt;windows&lt;/code&gt;和&lt;code&gt;linux&lt;/code&gt;平台上安装和使用&lt;code&gt;tree&lt;/code&gt;命令的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tree" scheme="http://showteeth.tech/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="http://showteeth.tech/posts/43102.html"/>
    <id>http://showteeth.tech/posts/43102.html</id>
    <published>2019-04-05T04:05:20.000Z</published>
    <updated>2019-04-05T10:29:55.173Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了<strong>使用xx-net进行科学上网的过程，包括安装、配置以及在使用中遇到的问题和解决</strong>；最后采取的科学上网策略是在蓝灯流量没使用完之前<strong>先使用蓝灯</strong>，蓝灯流量用完之后<strong>再使用xx-net</strong>。</p></div><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>XX-net</strong>：</p><ul><li><strong>下载地址</strong>：<a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="noopener">地址</a></li><li><strong>使用chrome浏览器的配置</strong>：<a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">Chrome</a></li></ul><p><strong>优点</strong>：</p><ul><li><strong>免费</strong></li><li>操作简单</li><li><strong>速度还可以</strong></li><li><strong>比较稳定</strong></li></ul><p><strong>蓝灯</strong>：</p><ul><li>下载地址：<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">地址</a></li><li><strong>优点</strong>：<ul><li>稳定</li><li>速度很快</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>免费</strong>的只有500M流量每个月</li><li><strong>专业版</strong>的每年要差不多180RMB(好贵。。。)</li></ul></li></ul><div class="note info"><p>所以可以<strong>先使用蓝灯(快)</strong>啊，然后等蓝灯<strong>流量用完之后再使用xx-net(免费、慢)</strong>，感觉自己有点小机灵~~~~</p></div><p>接下来<strong>主要介绍自己安装配置xx-net的步骤和遇到的问题</strong>，<strong>蓝灯的使用非常简单，直接下载安装就可以使用了</strong>。</p><hr><h2 id="安装配置过程"><a href="#安装配置过程" class="headerlink" title="安装配置过程"></a>安装配置过程</h2><h3 id="运行start-bat"><a href="#运行start-bat" class="headerlink" title="运行start.bat"></a>运行start.bat</h3><p>通过执行start.bat来完成xx-net的相关配置，我在这一步遇到了<code>运行之后浏览器不能上网，并且出现错误</code>，具体的解决方案见出现的问题及解决章节。</p><p>正常运行完成之后就会得到一个<strong>XX-NET的快捷方式</strong>，以后只用<strong>双击这个快捷方式</strong>就可以运行xx-net。</p><hr><h3 id="设置ipv6"><a href="#设置ipv6" class="headerlink" title="设置ipv6"></a>设置ipv6</h3><p>按照xx-net的说明，其主要有<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener"><code>GAE_proxy</code>和<code>X-Tunnel</code></a>，其中的<strong>GAE_proxy是免费</strong>的，有免费的当然使用免费的呀，但是其需要<code>开启IPV6</code>，可以按照官方给定的教程来来开启，官方提供了<a href="https://github.com/XX-net/XX-Net/wiki/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFIPv6" target="_blank" rel="noopener">mac、windows(7、10)、Linux的不同开启说明</a>，我这里选择了<a href="https://github.com/XX-net/XX-Net/wiki/IPv6-Win10" target="_blank" rel="noopener">win10教程</a>，其中有个简单的开启方法：运行<code>code\default\gae_proxy\local\ipv6_tunnel</code>目录下的<code>enable_ipv6.bat</code>文件即可开启，当然<strong>也可以手动开启</strong>，具体按照上面的教程。</p><hr><h3 id="设置自动代理"><a href="#设置自动代理" class="headerlink" title="设置自动代理"></a>设置自动代理</h3><p>ipv6开启之后再按照<a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">官方设置代理教程</a>的简单方法就可以访问谷歌等国外网站，但是<strong>这的缺点是</strong>：<strong>访问国内网站(不用科学上网的网站)也会很慢</strong>，这个时候就可以<strong>使用谷歌的浏览器插件来进行自动代理切换</strong>，这个在官方的设置代理教程中也有给出。</p><p><a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8#%E6%96%B9%E6%A1%88%E4%BA%8C%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E5%88%87%E6%8D%A2%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener">具体步骤</a></p><ul><li>建议在谷歌浏览器插件中下载安装<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a></li></ul><hr><h2 id="出现的问题以及解决"><a href="#出现的问题以及解决" class="headerlink" title="出现的问题以及解决"></a>出现的问题以及解决</h2><h3 id="启动start-bat之后浏览器不能上网，并且出现错误"><a href="#启动start-bat之后浏览器不能上网，并且出现错误" class="headerlink" title="启动start.bat之后浏览器不能上网，并且出现错误"></a>启动start.bat之后浏览器不能上网，并且出现错误</h3><p>错误信息如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/xx-net错误.png" alt="xx-net错误.png"></p><ul><li>首先，<strong>解决浏览器不能上网</strong>：chrome浏览器设置—&gt;高级设置—&gt;系统(打开代理设置)—&gt;局域网(LAN)设置按下图修改</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/xx-net不能上网.png" alt="xx-net不能上网.png"></p><ul><li><p>接下来，<strong>修改xx-net配置文件</strong>：<code>XX-Net-3.13.1\data\launcher\config.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules:</span><br><span class="line">  gae_proxy: &#123;auto_start: 1&#125;</span><br><span class="line">  launcher: &#123;allow_remote_connect: 0, control_port: 8085, last_run_version: 3.13.1,</span><br><span class="line">    proxy: pac&#125;</span><br><span class="line">  smart_router: &#123;auto_start: 1&#125;</span><br><span class="line">  <span class="comment"># 将这里的1改为0</span></span><br><span class="line">  x_tunnel: &#123;auto_start: 1&#125;</span><br><span class="line">update: &#123;last_path: <span class="string">'C:\Users\user\Desktop\XX-Net-3.13.1\XX-Net-3.13.1\code\default\launcher'</span>,</span><br><span class="line">  postUpdateStat: noChange, uuid: a58ace84-79fb-4dd5-bcc8-8c36e7cde706&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>然后再次执行start.bat即可</strong></p></li></ul><hr><h2 id="其他工具和方法"><a href="#其他工具和方法" class="headerlink" title="其他工具和方法"></a>其他工具和方法</h2><ul><li>youtube上的这个视频介绍了一种使用<strong>shadowsocks</strong>的方法，使用免费的ip和密码来实现翻墙，具体的<a href="https://www.youtube.com/watch?v=D81vP_o0-6o" target="_blank" rel="noopener">视频链接</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录了&lt;strong&gt;使用xx-net进行科学上网的过程，包括安装、配置以及在使用中遇到的问题和解决&lt;/strong&gt;；最后采取的科学上网策略是在蓝灯流量没使用完之前&lt;strong&gt;先使用蓝灯&lt;/strong&gt;，蓝灯流量用完之后&lt;strong&gt;再使用xx-net&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之subprocess-子进程管理</title>
    <link href="http://showteeth.tech/posts/57519.html"/>
    <id>http://showteeth.tech/posts/57519.html</id>
    <published>2019-04-04T00:57:21.000Z</published>
    <updated>2019-04-04T10:02:44.740Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python常用模块<code>subprocess</code>，这是一个<strong>子进程管理的模块</strong>，用来<strong>在Python代码中执行操作系统级别的命令</strong>(如linux下的命令行命令)；主要学习了其中的两大API：<code>subprocess.run()</code>和<code>subprocess.Popen()</code>，学习了如何<strong>传递要执行的命令</strong>、如何<strong>获取命令的退出状态码(returncode)</strong>、<strong>输出(stdout)</strong>、<strong>错误(stderr)</strong>以及<strong>如何与进程交互</strong>等。</p></div><a id="more"></a><h2 id="subprocess模块简介"><a href="#subprocess模块简介" class="headerlink" title="subprocess模块简介"></a>subprocess模块简介</h2><p><code>subprocess</code>模块主要用于<strong>创建</strong>子进程，并<strong>连接它们的输入、输出和错误管道</strong>，<strong>获取它们的返回状态</strong>。通俗地说就是通过这个模块，你可以<strong>在Python的代码里执行操作系统级别的命令</strong>，比如<code>ipconfig</code>、<code>du -sh</code>等等。<code>subprocess</code>模块替代了一些老的模块(<code>os</code>模块)和函数，比如：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system</span><br><span class="line">os.spawn*</span><br></pre></td></tr></table></figure><p></p><p><code>subprocess</code>过去版本中的<code>call()</code>，<code>check_call()</code>和<code>check_output()</code>已经被<code>run()</code>方法取代了，<code>run()</code>方法为3.5版本新增。</p><p><strong>大多数情况下</strong>，<strong>推荐使用<code>run()</code>方法调用子进程，执行操作系统命令</strong>。在<strong>更高级</strong>的使用场景，你还可以使用<code>Popen</code>接口。<strong>其实run()方法在底层调用的就是Popen接口。</strong></p><hr><h2 id="运行外部命令-subprocess-run"><a href="#运行外部命令-subprocess-run" class="headerlink" title="运行外部命令-subprocess.run()"></a>运行外部命令-subprocess.run()</h2><h3 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.run(args, *, stdin=<span class="keyword">None</span>, input=<span class="keyword">None</span>,\</span><br><span class="line">               stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, shell=<span class="keyword">False</span>, \</span><br><span class="line">               timeout=<span class="keyword">None</span>, check=<span class="keyword">False</span>, \</span><br><span class="line">               encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>执行<code>args</code>参数所表示的命令，等待命令结束，并返回一个<code>CompletedProcess</code>实例，可以获取其属性的值。</p><hr><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>args</code>：表示<strong>要执行的命令</strong>，必须是<strong>一个字符串</strong>或者<strong>字符串参数列表</strong>；<strong>推荐使用字符串列表</strong>的形式，这样可以处理任何必要的转义和引用参数(例如，允许文件名中的空格)，如果传递<strong>单个字符串</strong>，则<code>shell</code>必须为True，<strong>或者</strong>字符串必须简单地命名要执行的程序而不指定任何参数</li><li><code>stdin</code>、<code>stdout</code>和<code>stderr</code>：<strong>子进程的标准输入</strong>、<strong>输出</strong>和<strong>错误</strong>；其值可以是：<ul><li><code>subprocess.PIPE</code>：表示为子进程创建新的管道</li><li><code>subprocess.DEVNULL</code>：表示使用<code>os.devnull</code>，类似于Linux下的/dev/nulls</li><li><strong>一个已经存在的文件描述符</strong></li><li><strong>已经打开的文件对象</strong></li><li><strong>None</strong>，这是<strong>默认的设置</strong>，表示什么都不做，结果输出到父进程上(如控制台)</li><li>另外，<code>stderr</code>可以合并到<code>stdout</code>里一起输出</li></ul></li><li><code>timeout</code>：<strong>设置命令超时时间</strong>；如果<strong>命令执行时间超时</strong>，<strong>子进程将被杀死</strong>，并弹出<code>TimeoutExpired</code>异常</li><li><code>check</code>：如果该参数设置为<code>True</code>，并且进程<strong>退出状态码不是0</strong>，则弹出<code>CalledProcessError</code>异常</li><li><code>encoding</code>：如果<strong>指定了该参数</strong>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>可以接收或输出<strong>字符串</strong>数据，并以该编码方式编码，<strong>否则只接收或输出bytes类</strong>型的数据</li><li><code>shell</code>：如果该参数为True，将<strong>通过操作系统的shell执行指定的命令</strong></li></ul><div class="note info"><p>关于<a href="https://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">文件描述符和文件对象的区别</a>：</p><ul><li><strong>文件描述符</strong>是Linux内核为了<strong>高效管理已被打开的文件或其他输入输出资源所创建的索引</strong>，其是一个非负整数(通常是小整数)，<strong>用于指代被打开的文件或其他输入输出资源</strong>，<strong>所有执行I/O操作的系统调用都通过文件描述符</strong>；常见的，<strong>0(标准输入)</strong>、<strong>1(标准输出)</strong>、<strong>2(标准错误输出)</strong>都是文件描述符(程序开始时这三个就已经存在，然后打开的第一个文件的文件描述符就是3)。(In <strong>Unix and related</strong> computer operating systems, a <strong>file descriptor (FD, less frequently fildes)</strong> is an abstract indicator (handle) <strong>used to access a file</strong> or <strong>other input/output resource</strong>, such as a pipe or network socket.)</li><li><strong>每一个文件描述符会与一个打开文件相对应</strong>，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为<strong>每一个进程</strong>维护了一个<strong>文件描述符表</strong>，该表的<strong>值都是从0开始的</strong>，所以<strong>在不同的进程中你会看到相同的文件描述符</strong>，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。</li><li><strong>文件对象</strong>是在文件被打开时创建的一个<code>file</code>结构组成，Python的<code>open()</code>方法就是打开并创建一个文件对象</li></ul></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="args参数使用-字符串和字符串列表"><a href="#args参数使用-字符串和字符串列表" class="headerlink" title="args参数使用-字符串和字符串列表"></a>args参数使用-字符串和字符串列表</h4><p><code>args</code>参数表示<strong>要执行的命令</strong>，必须是<strong>一个字符串</strong>或者<strong>字符串参数列表</strong>；<strong>推荐使用字符串列表</strong>的形式，这样可以<strong>避免转义以及其他会被 shell 解析的特殊字符</strong>，如果传递<strong>单个字符串</strong>，则<code>shell</code>必须为True，<strong>或者</strong>字符串必须简单地命名要执行的程序而不指定任何参数:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单个字符串</span></span><br><span class="line">subprocess.run(<span class="string">"ls"</span>)</span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls'</span>, returncode=<span class="number">0</span>)</span><br><span class="line">subprocess.run(<span class="string">'ls'</span>)</span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls'</span>, returncode=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 当单个字符串中间有空格时会出错</span></span><br><span class="line"><span class="comment"># 这样会导致命令不能传递参数</span></span><br><span class="line">subprocess.run(<span class="string">'ls -l'</span>) <span class="keyword">or</span> subprocess.run(<span class="string">"ls -l"</span>)</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">472</span>, <span class="keyword">in</span> run</span><br><span class="line">      <span class="keyword">with</span> Popen(*popenargs, **kwargs) <span class="keyword">as</span> process:</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">775</span>, <span class="keyword">in</span> __init__</span><br><span class="line">      restore_signals, start_new_session)</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">1522</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">      <span class="keyword">raise</span> child_exception_type(errno_num, err_msg, err_filename)</span><br><span class="line">  FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'ls -l'</span>: <span class="string">'ls -l'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单个字符串传递参数，并且制定shell=True</span></span><br><span class="line"><span class="comment"># 就可以传递参数了</span></span><br><span class="line">subprocess.run(<span class="string">"ls -l"</span>,shell=<span class="keyword">True</span>)</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls -l'</span>, returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用的是字符串列表，针对上面不能传递参数的行为就可以改善</span></span><br><span class="line"><span class="comment"># 避免转义引号以及其他会被 shell 解析的特殊字符</span></span><br><span class="line"><span class="comment"># 如果需要传递参数不需要指定shell=True</span></span><br><span class="line">subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>])</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-l'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在使用字符串列表之后还指定了shell=True</span></span><br><span class="line"><span class="comment"># 只会执行字符串列表的第一个</span></span><br><span class="line"><span class="comment"># 字符串列表剩余部分会被舍弃</span></span><br><span class="line">subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>],shell=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 只输出了ls的结果</span></span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-l'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的返回结果都是CompletedProcess 实例，包含进程退出码以及输出等信息</span></span><br><span class="line"><span class="comment"># 可以通过属性的方式获取其值</span></span><br><span class="line">test=subprocess.run(<span class="string">"ls -l"</span>,shell=<span class="keyword">True</span>)</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line"><span class="comment"># 获取命令的退出状态码</span></span><br><span class="line">test.returncode</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>总结一下args参数的用法：</p><ul><li>如果命令是<strong>字符串</strong>，并且<strong>中间存在空格(给命令传递了参数)</strong>，<strong>必须</strong>加上参数<code>shell=True</code>，不然运行会出错，<strong>或者</strong>就<strong>是运行不加参数的命令(命令不能带空格)</strong></li><li>命令是<strong>字符串列表</strong>时，<strong>可以使用带参数的命令</strong>，这个时候就<strong>不能添加参数</strong><code>shell=True</code>，如果加上了<strong>不会出错</strong>，但是<strong>参数就会失效，只会运行单独的命令</strong></li><li>在<strong>不加</strong><code>shell=True</code>参数运行命令时，<strong>字符串不能存在空格(如<code>[&quot;ls&quot; &quot;-l &quot;]</code>、<code>&quot;ls &quot;</code>)</strong>，运行会报错</li><li>以上均为linux上的情况，<strong>windows下使用更加随意</strong>，<code>subprocess.run(&quot;ls -l&quot;)</code>、<code>subprocess.run(&quot;ls -l&quot;,shell=True)</code>、<code>subprocess.run([&quot;ls&quot;,&quot;-l&quot;])</code>、<code>subprocess.run([&quot;ls&quot;,&quot;-l&quot;],shell=True)</code><strong>运行结果都是一样的</strong>，都是<strong>正确</strong>答案。</li></ul></div><hr><h4 id="stdin、stdout和stderr-控制子进程的输入、输出和错误"><a href="#stdin、stdout和stderr-控制子进程的输入、输出和错误" class="headerlink" title="stdin、stdout和stderr-控制子进程的输入、输出和错误"></a>stdin、stdout和stderr-控制子进程的输入、输出和错误</h4><p><code>stdin</code>、<code>stdout</code>和<code>stderr</code>：<strong>子进程的标准输入</strong>、<strong>输出</strong>和<strong>错误</strong>；其值可以是：</p><ul><li><code>subprocess.PIPE</code>：表示为子进程创建新的管道</li><li><code>subprocess.DEVNULL</code>：表示使用<code>os.devnull</code></li><li><strong>一个已经存在的文件描述符</strong></li><li><strong>已经打开的文件对象</strong></li><li><strong>None</strong>，这是<strong>默认的设置</strong>，表示什么都不做，结果输出到父进程上</li><li>另外，<code>stderr</code>可以合并到<code>stdout</code>里一起输出</li></ul><p>默认情况下，由 <code>run()</code> 启动的进程的<strong>标准输入输出渠道绑定在了父进程上</strong>，那就意味着<strong>调用程序不能捕获命令的输出(前面实例中直接输出在控制台上)</strong>，给 <code>stdout</code> 和 <code>stderr</code> 参数传递 <code>PIPE</code> 可以捕获输出用于后续处理:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子进程创建新的管道</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE)</span><br><span class="line">completed</span><br><span class="line">  <span class="comment"># 看到返回的这个实例中间的stdout中有结果</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-1'</span>], returncode=<span class="number">0</span>, stdout=<span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不创建管道作为对比</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>])</span><br><span class="line">  test1.txt</span><br><span class="line">  test2.txt</span><br><span class="line">  test3.txt</span><br><span class="line">  test4.txt</span><br><span class="line">  test5.txt</span><br><span class="line">completed</span><br><span class="line">  <span class="comment"># 这个返回的实例中不包含结果，结果被输出在上面的屏幕上</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-1'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要输出子进程的返回值</span></span><br><span class="line"><span class="comment"># 同样是通过获取属性的值</span></span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 可以看到返回的结果是byte类型的</span></span><br><span class="line">  <span class="comment"># 这是以为我们没有设置encoding参数</span></span><br><span class="line">  <span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用utf-8进行解码</span></span><br><span class="line">completed.stdout.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接设置encoding参数就不用进行decode操作</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 直接返回字符串，不用进行decode操作</span></span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="stdin-使用文件与进程交互"><a href="#stdin-使用文件与进程交互" class="headerlink" title="stdin-使用文件与进程交互"></a>stdin-使用文件与进程交互</h4><p>前面提到<code>stdin</code>可以传入一个文件对象，这里将需要<strong>执行的命令</strong>写入文件，从而达到<strong>与进程通信的目的</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux下，先进入Python环境，然后执行文件中的命令</span></span><br><span class="line">fd = open(<span class="string">"cmd.txt"</span>,<span class="string">'r'</span>)</span><br><span class="line">ret = subprocess.run(<span class="string">"python"</span>, stdin=fd, stdout=subprocess.PIPE,shell=<span class="keyword">True</span>)</span><br><span class="line">print(ret.stdout)</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  <span class="string">b'hello world\\!\n'</span></span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="check-检查退出码"><a href="#check-检查退出码" class="headerlink" title="check-检查退出码"></a>check-检查退出码</h4><p><code>check</code>：如果该参数设置为<code>True</code>，并且进程<strong>退出状态码(<code>CompletedProcess</code> 的 <code>returncode</code> 属性)不是0</strong>，则弹出<code>CalledProcessError</code>异常:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用check=True，即使命令错误了，也不会报错</span></span><br><span class="line">subprocess.run([<span class="string">'false'</span>])</span><br><span class="line">  <span class="comment"># 命令执行不成功，返回状态码为1</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'false'</span>], returncode=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加check=True</span></span><br><span class="line"><span class="comment"># 会对命令的执行状态码进行检查，如果执行失败(不为0)，就报错</span></span><br><span class="line">subprocess.run([<span class="string">'false'</span>], check=<span class="keyword">True</span>)</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">487</span>, <span class="keyword">in</span> run</span><br><span class="line">      output=stdout, stderr=stderr)</span><br><span class="line">  subprocess.CalledProcessError: Command <span class="string">'['</span>false<span class="string">']'</span> returned non-zero exit status <span class="number">1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subprocess.run([<span class="string">'false'</span>], check=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  ERROR: Command <span class="string">'['</span>false<span class="string">']'</span> returned non-zero exit status <span class="number">1.</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="encoding-输入、输出、错误编码方式"><a href="#encoding-输入、输出、错误编码方式" class="headerlink" title="encoding-输入、输出、错误编码方式"></a>encoding-输入、输出、错误编码方式</h4><p><code>encoding</code>：如果<strong>指定了该参数</strong>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>可以接收或输出<strong>字符串</strong>数据，并以该编码方式编码，<strong>否则只接收或输出bytes类</strong>型的数据:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子进程创建新的管道</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要输出子进程的返回值</span></span><br><span class="line"><span class="comment"># 同样是通过获取属性的值</span></span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 可以看到返回的结果是byte类型的</span></span><br><span class="line">  <span class="comment"># 这是以为我们没有设置encoding参数</span></span><br><span class="line">  <span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用utf-8进行解码</span></span><br><span class="line">completed.stdout.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接设置encoding参数就不用进行decode操作</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 直接返回字符串，不用进行decode操作</span></span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="CompletedProcess类"><a href="#CompletedProcess类" class="headerlink" title="CompletedProcess类"></a>CompletedProcess类</h3><p><code>run()</code>方法的返回值，表示<strong>一个进程结束了</strong>，<code>CompletedProcess</code>类有下面这些属性：</p><table><tr><th width="20%">属性</th><th width="80%">说明</th></tr><tr><td><code>args</code></td><td>进程运行的命令，通常是个字符串列表或字符串</td></tr><tr><td><code>returncode</code></td><td>进程结束状态返回码，0表示命令成功状态，非0表示不成功</td></tr><tr><td><code>stdout</code></td><td>获取子进程的stdout，通常为bytes类型序列(可以通过<code>ecoding</code>参数调整)，None表示没有捕获值。如果在调用run()方法时，设置了参数<code>stderr=subprocess.STDOUT</code>，则错误信息会和stdout一起输出，此时stderr的值是None</td></tr><tr><td><code>stderr</code></td><td>获取子进程的错误信息，通常为bytes类型序列，None表示没有捕获值</td></tr><tr><td><code>check_returncode()</code></td><td>用于检查返回码。如果返回状态码不为零，弹出<code>CalledProcessError</code>异常</td></tr></table><hr><h3 id="subprocess-DEVNULL-抑制输出"><a href="#subprocess-DEVNULL-抑制输出" class="headerlink" title="subprocess.DEVNULL-抑制输出"></a>subprocess.DEVNULL-抑制输出</h3><p>某些情况下，<strong>输出不应该被展示和捕获</strong>，使用 <code>subprocess.DEVNULL</code> 抑制输出流(Linux下的/dev/null)：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span></span><br><span class="line"><span class="comment"># 上述命令会有一个错误输出to stderr</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    completed = subprocess.run(</span><br><span class="line">        <span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>,</span><br><span class="line">        shell=<span class="keyword">True</span>,</span><br><span class="line">        stdout=subprocess.DEVNULL,</span><br><span class="line">        stderr=subprocess.DEVNULL,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'returncode:'</span>, completed.returncode)</span><br><span class="line">    print(<span class="string">'stdout is &#123;!r&#125;'</span>.format(completed.stdout))</span><br><span class="line">    print(<span class="string">'stderr is &#123;!r&#125;'</span>.format(completed.stderr))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行结果不会输出到控制台，应为设置了stdout和stderr</span></span><br><span class="line"><span class="comment"># 同时也不会被捕获，因为设置的值为subprocess.DEVNULL，相当于是无底洞</span></span><br><span class="line">returncode: <span class="number">1</span></span><br><span class="line">stdout <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line">stderr <span class="keyword">is</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="subprocess-STDOUT-合并标准错误和输出"><a href="#subprocess-STDOUT-合并标准错误和输出" class="headerlink" title="subprocess.STDOUT-合并标准错误和输出"></a>subprocess.STDOUT-合并标准错误和输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    completed = subprocess.run(</span><br><span class="line">        <span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>,</span><br><span class="line">        shell=<span class="keyword">True</span>,</span><br><span class="line">        stdout=subprocess.PIPE,</span><br><span class="line">        stderr=subprocess.STDOUT,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'returncode:'</span>, completed.returncode)</span><br><span class="line">    print(<span class="string">'stdout is &#123;!r&#125;'</span>.format(completed.stdout))</span><br><span class="line">    print(<span class="string">'stderr is &#123;!r&#125;'</span>.format(completed.stderr))</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CompletedProcess类</span></span><br><span class="line">CompletedProcess(args=<span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>, returncode=<span class="number">1</span>, stdout=<span class="string">b'to stdout\nto stderr\n'</span>)</span><br><span class="line"></span><br><span class="line">returncode: <span class="number">1</span></span><br><span class="line"><span class="comment"># stdout合并了stderr的输出</span></span><br><span class="line">stdout <span class="keyword">is</span> <span class="string">b'to stdout\nto stderr\n'</span></span><br><span class="line"><span class="comment"># 输出在了stdout中，所以这里就成了空值</span></span><br><span class="line">stderr <span class="keyword">is</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：错误输出合并输出在了<code>stdout</code>中之后，<code>CompletedProcess</code>实例中的 <strong><code>stderr</code>属性就成了空值</strong></p></div><hr><p><br></p><h2 id="更高级的使用场景-subprocess-Popen"><a href="#更高级的使用场景-subprocess-Popen" class="headerlink" title="更高级的使用场景-subprocess.Popen()"></a>更高级的使用场景-subprocess.Popen()</h2><h3 id="命令形式-1"><a href="#命令形式-1" class="headerlink" title="命令形式"></a>命令形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.Popen(args, bufsize=<span class="number">-1</span>, executable=<span class="keyword">None</span>, \</span><br><span class="line">                 stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, preexec_fn=<span class="keyword">None</span>, \</span><br><span class="line">                 close_fds=<span class="keyword">True</span>, shell=<span class="keyword">False</span>, cwd=<span class="keyword">None</span>, env=<span class="keyword">None</span>, \</span><br><span class="line">                 universal_newlines=<span class="keyword">None</span>, startupinfo=<span class="keyword">None</span>, \</span><br><span class="line">                 creationflags=<span class="number">0</span>, restore_signals=<span class="keyword">True</span>, \</span><br><span class="line">                 start_new_session=<span class="keyword">False</span>, pass_fds=(), *, \</span><br><span class="line">                 encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, text=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>功能与<code>run()</code>方法基本类同，但是它的<strong>返回值是一个<code>Popen</code>实例</strong>，而<strong>不是<code>CompletedProcess</code>实例</strong></p><hr><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><p>大部分的参数都和<code>subprocess.run()</code>中的用法相同，这里列出几个这里特有的参数：</p><ul><li><code>cwd</code>： 如果该参数值<strong>不是None</strong>，则该函数将会在执行这个子进程之前<strong>改变当前工作目录</strong></li><li><code>env</code>： 用于<strong>指定子进程的环境变量</strong>，如果<code>env=None</code>，那么子进程的环境变量将<strong>从父进程中继承</strong>；如果<code>env!=None</code>，它的值必须是一个<strong>映射对象</strong></li></ul><hr><h3 id="可调用方法"><a href="#可调用方法" class="headerlink" title="可调用方法"></a>可调用方法</h3><table><tr><th width="30%">方法</th><th width="70%">描述</th></tr><tr><td><code>Popen.poll()</code></td><td>用于检查子进程（命令）是否已经执行结束，没结束返回None，结束后返回状态码</td></tr><tr><td><code>Popen.wait(timeout=None)</code></td><td>等待子进程结束，并返回状态码；如果在timeout指定的秒数之后进程还没有结束，将会抛出一个TimeoutExpired异常</td></tr><tr><td><code>Popen.communicate(input=None, timeout=None)</code></td><td>该方法可用来与进程进行交互，比如发送数据到stdin，从stdout和stderr读取数据，直到到达文件末尾</td></tr><tr><td><code>Popen.send_signal(signal)</code></td><td>发送指定的信号给这个子进程</td></tr><tr><td><code>Popen.terminate()</code></td><td>停止该子进程</td></tr><tr><td><code>Popen.kill()</code></td><td>杀死该子进程</td></tr></table><div class="note info"><p>关于<code>Popen.communicate()</code>方法的说明：</p><ul><li>该方法中的可选参数 <code>input</code> 应该是将<strong>被发送给子进程的数据</strong>，或者如没有数据发送给子进程，该参数应该是None。<code>input</code>参数的数据类型必须是<strong>字节串</strong>，如果<code>universal_newlines</code>参数值为<code>True</code>(或者<strong>设置<code>encoding</code>参数</strong>)，则<code>input</code>参数的数据类型<strong>必须是字符串</strong></li><li>该方法返回一个<code>元组(stdout_data, stderr_data)</code>，这些数据将会是<strong>字节串或字符串(如果<code>universal_newlines</code>的值为<code>True</code>,或者设置<code>encoding</code>参数)</strong></li><li>如果在<code>timeout</code>指定的秒数后该进程还没有结束，将会抛出一个<code>TimeoutExpired</code>异常，<strong>捕获这个异常</strong>，然后<strong>重新尝试通信不会丢失任何输出的数据</strong>，但是超时之后子进程并没有被杀死，为了合理的清除相应的内容，一个好的应用应该手动杀死这个子进程来结束通信</li><li>需要注意的是，这里读取的数据是<strong>缓冲在内存中</strong>的，所以，如果<strong>数据大小非常大或者是无限的，就不应该使用这个方法</strong></li></ul></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="获取命令结果"><a href="#获取命令结果" class="headerlink" title="获取命令结果"></a>获取命令结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p = subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">"ls"</span>,<span class="string">"-l"</span>], stdout=subprocess.PIPE)</span><br><span class="line"><span class="comment"># 返回的p和前面的不同</span></span><br><span class="line">p</span><br><span class="line">  &lt;subprocess.Popen object at <span class="number">0x7fcddff8a710</span>&gt;</span><br><span class="line"><span class="comment"># 使用属性的read方法获取结果</span></span><br><span class="line"><span class="comment"># read()只能读取一次，再读取一次结果就为空(读取一遍后文件指针到最后了)</span></span><br><span class="line">p.stdout.read()</span><br><span class="line">  <span class="string">b'total 4\n-rw-rw-r-- 1 user user 23 Apr  4 15:26 cmd.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test1.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test2.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test3.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test4.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用decode将输出的字节串解码为utf-8，并输出结果</span></span><br><span class="line">print(p.stdout.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">  total <span class="number">4</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">23</span> Apr  <span class="number">4</span> <span class="number">15</span>:<span class="number">26</span> cmd.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br></pre></td></tr></table></figure><hr><h4 id="修改工作目录"><a href="#修改工作目录" class="headerlink" title="修改工作目录"></a>修改工作目录</h4><p><code>cwd</code>： 如果该参数值<strong>不是None</strong>，则该函数将会在执行这个子进程之前<strong>改变当前工作目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>,cwd=<span class="string">"./test"</span>)</span><br><span class="line"><span class="comment"># 使用decode将输出的字节串解码为utf-8，并输出结果</span></span><br><span class="line">print(p.stdout.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">46</span> cwd1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">46</span> cwd2.txt</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="Popen-communicate-使用"><a href="#Popen-communicate-使用" class="headerlink" title="Popen.communicate()使用"></a>Popen.communicate()使用</h4><ul><li>该方法返回一个<code>元组(stdout_data, stderr_data)</code>，这些数据将会是<strong>字节串或字符串(如果<code>universal_newlines</code>的值为<code>True</code>,或者设置<code>encoding</code>参数)</strong></li></ul><p><strong>与进程交互实例一</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj.stdin.write(<span class="string">'print(1)'</span>)</span><br><span class="line">  <span class="comment"># 直接输入字符会报错</span></span><br><span class="line">  <span class="comment"># 只能输入字节串</span></span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  TypeError: a bytes-like object <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="string">'str'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用encoding或者universal_newlines</span></span><br><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,\</span><br><span class="line">                        encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                       stdout=subprocess.PIPE, stderr=subprocess.PIPE,\</span><br><span class="line">                       universal_newlines=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用obj.stdin.write来传递命令</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(1)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(2)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(3)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取返回的输出值和错误</span></span><br><span class="line">out,err = obj.communicate()</span><br><span class="line">out</span><br><span class="line">  <span class="string">'1\n2\n'</span></span><br><span class="line">err</span><br><span class="line">  <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用obj.communicate()的input参数来传递命令</span></span><br><span class="line">out,err = obj.communicate(input=<span class="string">'print(1)'</span>)</span><br><span class="line">out</span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  <span class="string">'1\n'</span></span><br><span class="line">err</span><br><span class="line">  <span class="string">''</span></span><br></pre></td></tr></table></figure><p></p><p><strong>与进程交互实例二</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'cat -; echo "to stderr" 1&gt;&amp;2'</span></span><br><span class="line"><span class="comment"># 获取标准输入</span></span><br><span class="line"><span class="comment"># 并且得到标准错误输出</span></span><br><span class="line">proc = subprocess.Popen(</span><br><span class="line">    <span class="string">'cat -; echo "to stderr" 1&gt;&amp;2'</span>,</span><br><span class="line">    shell=<span class="keyword">True</span>,</span><br><span class="line">    stdin=subprocess.PIPE,</span><br><span class="line">    stdout=subprocess.PIPE,</span><br><span class="line">    stderr=subprocess.PIPE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前面没有设置encoding参数以及universal_newlines参数</span></span><br><span class="line"><span class="comment"># 这使用encode来将字符串编码为字节串</span></span><br><span class="line">msg = <span class="string">'through stdin to stdout'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">stdout_value, stderr_value = proc.communicate(msg)</span><br><span class="line"><span class="comment"># 使用decode来将字节串解码为字符串</span></span><br><span class="line">print(<span class="string">'pass through:'</span>, repr(stdout_value.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">  <span class="comment"># 输出标准输出，cat -的运行结果</span></span><br><span class="line">  <span class="keyword">pass</span> through: <span class="string">'through stdin to stdout'</span></span><br><span class="line">print(<span class="string">'stderr      :'</span>, repr(stderr_value.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">  <span class="comment"># 输出标准错误，echo "to stderr" 1&gt;&amp;2的运行结果</span></span><br><span class="line">  <span class="comment"># 1&gt;&amp;2将标准输出重定向到标准错误输出</span></span><br><span class="line">  stderr      : <span class="string">'to stderr\n'</span></span><br></pre></td></tr></table></figure><p></p><p><strong>实现shell中管道符的实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">p1 = subprocess.Popen([<span class="string">'ls'</span>, <span class="string">'-l'</span>], stdout=subprocess.PIPE)</span><br><span class="line"><span class="comment"># 这里设置p2的输入为p1的输出</span></span><br><span class="line">p2 = subprocess.Popen([<span class="string">'grep'</span>, <span class="string">'cmd'</span>], stdin=p1.stdout, stdout=subprocess.PIPE)</span><br><span class="line">out,err = p2.communicate()</span><br><span class="line">out</span><br><span class="line">  <span class="string">b'-rw-rw-r-- 1 user user 23 Apr  4 15:26 cmd.txt\n'</span></span><br><span class="line">err</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果<strong>不想将结果输出在控制台上</strong>，可以设置<code>stdout</code>和<code>stderr</code>来<strong>捕获输出</strong></li><li>如果希望命令的运行不成功(退出状态码不为0)就爆出异常，可以设置<code>check=True</code>以及异常捕获</li><li>在使用<strong>字符串与进程通信</strong>以及<strong>输出结果</strong>的时候，需要注意设置<code>encoding</code>以及<code>universal_newlines</code>参数，不然<strong>命令会报错</strong>或者<strong>输出得到的是字节串</strong></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" target="_blank" rel="noopener">subprocess — Subprocess management</a></li><li><a href="http://www.liujiangblog.com/course/python/55" target="_blank" rel="noopener">subprocess</a></li><li><a href="https://www.cnblogs.com/yyds/p/7288916.html#4179829" target="_blank" rel="noopener">Python之系统交互（subprocess）</a></li><li><a href="https://learnku.com/docs/pymotw/subprocess-spawning-additional-processes/3419" target="_blank" rel="noopener">11.2. subprocess — 生成多余进程</a></li><li><a href="https://www.cnblogs.com/vamei/archive/2012/09/23/2698014.html" target="_blank" rel="noopener">Python标准库06 子进程 (subprocess包)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python常用模块&lt;code&gt;subprocess&lt;/code&gt;，这是一个&lt;strong&gt;子进程管理的模块&lt;/strong&gt;，用来&lt;strong&gt;在Python代码中执行操作系统级别的命令&lt;/strong&gt;(如linux下的命令行命令)；主要学习了其中的两大API：&lt;code&gt;subprocess.run()&lt;/code&gt;和&lt;code&gt;subprocess.Popen()&lt;/code&gt;，学习了如何&lt;strong&gt;传递要执行的命令&lt;/strong&gt;、如何&lt;strong&gt;获取命令的退出状态码(returncode)&lt;/strong&gt;、&lt;strong&gt;输出(stdout)&lt;/strong&gt;、&lt;strong&gt;错误(stderr)&lt;/strong&gt;以及&lt;strong&gt;如何与进程交互&lt;/strong&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之字符串与字符编码(转载)</title>
    <link href="http://showteeth.tech/posts/59082.html"/>
    <id>http://showteeth.tech/posts/59082.html</id>
    <published>2019-04-03T01:11:24.000Z</published>
    <updated>2019-04-04T01:22:39.997Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，围绕Python中的字符串与字符编码<strong>比较了Python2和Python3在字节与字符串默认行为上的不同</strong>、<strong>结合Python源代码执行过程讲解了设置字符编码的作用</strong>以及<strong>不同字符编码之间的转换</strong>，是一篇非常实用和重要的文章。</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>Python中的字符编码是个老生常谈的话题，同行们都写过很多这方面的文章。有的人云亦云，也有的写得很深入。近日看到某知名培训机构的教学视频中再次谈及此问题，讲解的还是不尽人意，所以才想写这篇文字。一方面，梳理一下相关知识，另一方面，希望给其他人些许帮助。</p><blockquote><p><code>Python2</code>的 <strong><em>默认编码</em></strong> 是<code>ASCII</code>，<strong>不能识别中文字符</strong>，<strong>需要显式指定字符编码</strong>；<code>Python3</code>的 <strong><em>默认编码</em></strong> 为<code>Unicode</code>，<strong>可以识别中文字符</strong>。</p></blockquote><p>相信大家在很多文章中都看到过类似上面这样“对Python中中文处理”的解释，也相信大家在最初看到这样的解释的时候确实觉得明白了。可是时间久了之后，再重复遇到相关问题就会觉得貌似理解的又不是那么清楚了。如果我们了解上面说的默认编码的作用是什么，我们就会更清晰的明白那句话的含义。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><hr><h3 id="字符与字节"><a href="#字符与字节" class="headerlink" title="字符与字节"></a>字符与字节</h3><p><strong>一个字符不等价于一个字节</strong>，字符是人类能够识别的符号，而这些符号要保存到计算的存储中就需要用计算机能够识别的字节来表示。一个字符往往有多种表示方法，不同的表示方法会使用不同的字节数。这里所说的不同的表示方法就是指字符编码，比如字母<code>A-Z</code>都可以用<code>ASCII</code>码表示（占用一个字节），也可以用<code>UNICODE</code>表示（占两个字节），还可以用<code>UTF-8</code>表示（占用一个字节）。<strong>字符编码的作用就是将人类可识别的字符转换为机器可识别的字节码，以及反向过程</strong>。</p><p><strong><em>UNICDOE才是真正的字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串</em></strong> 。关于这点，我们可以在Python的官方文档中经常可以看到这样的描述<code>&quot;Unicode string&quot; , &quot; translating a Unicode string into a sequence of bytes&quot;</code></p><p>我们写代码是写在文件中的，而字符是以字节形式保存在文件中的，因此当我们在文件中定义个字符串时被当做字节串也是可以理解的。但是，我们需要的是字符串，而不是字节串。一个优秀的编程语言，应该严格区分两者的关系并提供巧妙的完美的支持。JAVA语言就很好，以至于了解Python和PHP之前我从来没有考虑过这些不应该由程序员来处理的问题。遗憾的是，很多编程语言试图混淆“字符串”和“字节串”，他们把字节串当做字符串来使用，PHP和Python2都属于这种编程语言。最能说明这个问题的操作就是取一个包含中文字符的字符串的长度：</p><ul><li>对字符串取长度，结果应该是所有字符的个数，无论中文还是英文</li><li>对字符串对应的字节串取长度，就跟编码(encode)过程使用的字符编码有关了(比如：UTF-8编码，一个中文字符需要用3个字节来表示；GBK编码，一个中文字符需要2个字节来表示)</li></ul><p><strong>注意</strong>：<code>Windows</code>的cmd终端字符编码默认为<code>GBK</code>，因此在cmd输入的中文字符需要用两个字节表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'Hello,中国'</span>  <span class="comment"># 字节串，长度为字节个数 = len('Hello,')+len('中国') = 6+2*2 = 10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">u'Hello,中国'</span>  <span class="comment"># 字符串，长度为字符个数 = len('Hello,')+len('中国') = 6+2 = 8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = unicode(a, <span class="string">'gbk'</span>)  <span class="comment"># 其实b的定义方式是c定义方式的简写，都是将一个GBK编码的字节串解码（decode）为一个Uniocde字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(a), len(a))</span><br><span class="line">(&lt;type <span class="string">'str'</span>&gt;, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(b), len(b))</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(c), len(c))</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">8</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>Python3中对字符串的支持做了很大的改动，具体内容会在下面介绍。</p><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>先做下科普：UNICODE字符编码，也是一张字符与数字的映射，但是这里的数字被称为<code>代码点(code point)</code>, <strong>实际上就是十六进制的数字</strong>。</p><p>Python官方文档中对Unicode字符串、字节串与编码之间的关系有这样一段描述：</p><blockquote><p>Unicode字符串是一个代码点（code point）序列，代码点取值范围为0到0x10FFFF（对应的十进制为1114111）。这个代码点序列在存储（包括内存和物理磁盘）中需要被表示为一组字节(0到255之间的值)，而将<strong>Unicode字符串转换为字节序列的规则称为编码</strong>。</p></blockquote><p>这里说的编码不是指字符编码，而是指编码的过程以及这个过程中所使用到的 <strong><em>Unicode字符的代码点与字节的映射规则</em></strong> 。这个映射不必是简单的一对一映射，因此编码过程也不必处理每个可能的Unicode字符，例如：</p><p><strong>将<code>Unicode字符串</code>转换为<code>ASCII编码</code></strong>的规则很简单–对于每个代码点：</p><ul><li>如果代码点数值&lt;128，则每个字节与代码点的值相同</li><li>如果代码点数值&gt;=128，则Unicode字符串无法在此编码中进行表示（这种情况下，Python会引发一个UnicodeEncodeError异常）</li></ul><p><strong>将<code>Unicode字符串</code>转换为<code>UTF-8编码</code></strong>使用以下规则：</p><ul><li>如果代码点数值&lt;128，则由相应的字节值表示（与Unicode转ASCII字节一样）</li><li>如果代码点数值&gt;=128，则将其转换为一个2个字节，3个字节或4个字节的序列，该序列中的每个字节都在128到255之间。</li></ul><div class="note info"><p>简单总结：</p><ul><li><strong><em>编码(encode)</em></strong> ：将Unicode<strong>字符串</strong>（中的代码点)<strong>转换</strong>特定字符编码对应的<strong>字节串</strong>的过程和规则</li><li><strong><em>解码(decode)</em></strong> ：将特定字符编码的<strong>字节串转换</strong>为对应的Unicode<strong>字符串</strong>(中的代码点)的过程和规则</li></ul></div><p>可见，无论是编码还是解码，都需要一个重要因素，就是 <strong><em>特定的字符编码</em></strong> 。因为一个字符用不同的字符编码进行编码后的字节值以及字节个数大部分情况下是不同的，反之亦然。</p><h2 id="Python中的默认编码"><a href="#Python中的默认编码" class="headerlink" title="Python中的默认编码"></a>Python中的默认编码</h2><hr><h3 id="Python源代码文件的执行过程"><a href="#Python源代码文件的执行过程" class="headerlink" title="Python源代码文件的执行过程"></a>Python源代码文件的执行过程</h3><p>我们都知道，<strong>磁盘上的文件都是以二进制格式存放的</strong>，其中<strong>文本文件都是以某种特定编码的字节形式存放的</strong>。对于<strong>程序源代码文件的字符编码是由<code>编辑器指定</code>的</strong>，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为<code>UTF-8</code>，那么Python代码被保存到磁盘时就会被转换为<code>UTF-8</code>编码对应的字节（<strong>encode过程</strong>）后写入磁盘。当<strong>执行Python代码</strong>文件中的代码时，<strong>Python解释器</strong>在读取Python代码文件中的字节串之后，需要<strong>将其转换为UNICODE字符串</strong>（<strong>decode过程</strong>）之后才执行后续操作。</p><p>上面已经解释过，这个<strong>转换过程（decode，解码）需要我们指定文件中保存的字节使用的字符编码是什么</strong>，才能知道这些字节在UNICODE这张万国码和统一码中找到其对应的代码点是什么。这里指定字符编码的方式大家都很熟悉，如下所示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用来指示Python解释器使用什么字符编码来将读取的字节串如何转化为字符串</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python字符编码过程_1.png" alt="Python字符编码过程_1.png"></p><h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><p>那么，如果我们<strong>没有在代码文件开始的部分指定字符编码</strong>，Python解释器就会使用哪种字符编码把从代码文件中读取到的字节转换为UNICODE代码点呢？就像我们配置某些软件时，有很多默认选项一样，需要在<strong>Python解释器内部设置默认的字符编码来解决这个问题</strong>，这就是文章开头所说的“默认编码”。因此大家所说的Python中文字符问题就可以总结为一句话： <strong><em>当无法通过默认的字符编码对字节进行转换时，就会出现解码错误(UnicodeEncodeError)</em></strong> 。</p><p><code>Python2</code>和<code>Python3</code>的解释器使用的<strong>默认编码是不一样</strong>的，我们可以通过<code>sys.getdefaultencoding()</code>来获取默认编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">'ascii'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><p>因此，对于<code>Python2</code>来讲，<strong>Python解释器</strong>在读取到中文字符的字节码尝试解码操作时，会<strong>先查看当前代码文件头部</strong>是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果<strong>没有指定则使用默认字符编码<code>&quot;ASCII&quot;</code>进行解码</strong>导致解码<strong>失败，导致如下错误</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p></p><p>对于<code>Python3</code>来讲，<strong>执行过程是一样的</strong>，只是Python3的<strong>解释器以<code>&quot;UTF-8&quot;</code>作为默认编码</strong>，但是这<strong>并不表示可以完全兼容中文问题</strong>。比如我们<strong>在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的</strong>。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，导致如下错误：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>创建一个工程之后<strong>先确认该工程的字符编码是否已经设置为UTF-8(编辑器设置中设置)</strong> —&gt;<strong>用于指示代码会使用什么字符编码方式保存为字节串</strong></li><li>为了兼容Python2和Python3，在<strong>代码头部声明字符编码：<code>-*- coding:utf-8 -*-</code></strong> —&gt;<strong>用于指示Python解释器使用什么字符编码将读取的字节串转化为字符串</strong></li><li>另外地，在<strong>读写文件内容的时候也需要指定正确的文件字符的编码方式</strong>，这部分在<a href="http://showteeth.tech/posts/57951.html">Python系列之文件读写(转载)</a>中有所讲解。</li></ul><h2 id="Python2与Python3中对字符串的支持"><a href="#Python2与Python3中对字符串的支持" class="headerlink" title="Python2与Python3中对字符串的支持"></a>Python2与Python3中对字符串的支持</h2><hr><p>其实Python3中对字符串支持的改进，不仅仅是更改了默认编码，而是重新进行了字符串的实现，而且它已经实现了对UNICODE的内置支持，从这方面来讲Python已经和JAVA一样优秀。下面我们来看下 <strong><code>Python2</code>与<code>Python3</code>中对字符串的支持有什么区别</strong>：</p><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><p><code>Python2</code>中对字符串的支持由以下三个类提供:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">str</span><span class="params">(basestring)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">unicode</span><span class="params">(basestring)</span></span></span><br></pre></td></tr></table></figure><p></p><p>执行<code>help(str)</code>和<code>help(bytes)</code>会发现结果<strong>都是str类的定义</strong>，这也说明<code>Python2</code>中 <strong><code>str</code>就是字节串</strong>，而后来的 <strong><code>unicode</code>对象对应才是真正的字符串</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'你好'</span></span><br><span class="line">b = <span class="string">u'你好'</span></span><br><span class="line"></span><br><span class="line">print(type(a), len(a))</span><br><span class="line">print(type(b), len(b))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;type <span class="string">'str'</span>&gt;, <span class="number">6</span>)</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><p><code>Python3</code>中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可以认为<code>Python3</code>中的<code>str</code>和<code>unicode</code><strong>合二为一</strong>了。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(object)</span></span></span><br></pre></td></tr></table></figure><p></p><p>实际上，Python3中已经意识到之前的错误，开始明确的区分字符串与字节。因此<code>Python3</code>中的 <strong><code>str</code>已经是真正的字符串</strong>，而<strong>字节是用单独的<code>bytes</code>类来表示</strong>。也就是说，<strong><code>Python3</code>默认定义的就是字符串，实现了对<code>UNICODE</code>的内置支持</strong>，减轻了程序员对字符串处理的负担。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'你好'</span></span><br><span class="line">b = <span class="string">u'你好'</span></span><br><span class="line">c = <span class="string">'你好'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line"></span><br><span class="line">print(type(a), len(a))</span><br><span class="line">print(type(b), len(b))</span><br><span class="line">print(type(c), len(c))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt; 2</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt; 4</span></span><br></pre></td></tr></table></figure><p></p><h2 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h2><hr><p>上面提到，<strong>UNICODE<code>字符串</code></strong>可以与<strong>任意字符编码的<code>字节</code></strong>进行<strong>相互转换</strong>，如图：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python字符串与字节的转换.png" alt="Python字符串与字节的转换.png"></p><p>那么大家很容易想到一个问题，就是不同的字符编码的字节可以通过Unicode相互转换吗？答案是肯定的。</p><h3 id="Python2中的字符串进行字符编码转换"><a href="#Python2中的字符串进行字符编码转换" class="headerlink" title="Python2中的字符串进行字符编码转换"></a>Python2中的字符串进行字符编码转换</h3><p><strong>转换过程</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节串--&gt;decode('原来的字符编码')--&gt;Unicode字符串--&gt;encode('新的字符编码')--&gt;字节串</span><br></pre></td></tr></table></figure><p></p><p><strong>转换实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python2中的utf_8_a为字节串</span></span><br><span class="line">utf_8_a = <span class="string">'我爱中国'</span></span><br><span class="line"><span class="comment"># 先将字节串decode为字符串，然后再将字符串encode为字节串</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gbk'</span>)</span><br><span class="line"><span class="comment"># 再使用decode转化为字符串输出</span></span><br><span class="line">print(gbk_a.decode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我爱中国</span><br></pre></td></tr></table></figure><h3 id="Python3中的字符串进行字符编码转换"><a href="#Python3中的字符串进行字符编码转换" class="headerlink" title="Python3中的字符串进行字符编码转换"></a>Python3中的字符串进行字符编码转换</h3><p>因为Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码，其过程为：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串--&gt;encode('新的字符编码')--&gt;字节串</span><br></pre></td></tr></table></figure><p></p><p><strong>转换实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">utf_8_a = <span class="string">'我爱中国'</span></span><br><span class="line">gbk_a = utf_8_a.encode(<span class="string">'gbk'</span>)</span><br><span class="line">print(gbk_a.decode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我爱中国</span><br></pre></td></tr></table></figure><p></p><p><strong>最后需要说明的是</strong>，<strong>Unicode不是有道词典</strong>，也不是google翻译器，它<strong>并不能把一个中文翻译成一个英文</strong>。正确的字符编码的转换过程只是把<strong>同一个字符的字节表现形式改变</strong>了，而<strong>字符本身的符号是不应该发生变化</strong>的，因此并不是所有的字符编码之间的转换都是有意义的。怎么理解这句话呢？比如GBK编码的“中国”转成UTF-8字符编码后，仅仅是由4个字节变成了6个字节来表示，但其字符表现形式还应该是“中国”，而不应该变成“你好”或者“China”。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">Python中的字符串与字符编码</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，围绕Python中的字符串与字符编码&lt;strong&gt;比较了Python2和Python3在字节与字符串默认行为上的不同&lt;/strong&gt;、&lt;strong&gt;结合Python源代码执行过程讲解了设置字符编码的作用&lt;/strong&gt;以及&lt;strong&gt;不同字符编码之间的转换&lt;/strong&gt;，是一篇非常实用和重要的文章。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
</feed>
