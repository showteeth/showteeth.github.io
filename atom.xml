<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-05-11T14:15:55.346Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jupyter NoteBook 的快捷键使用指南(转载)</title>
    <link href="http://showteeth.tech/posts/36813.html"/>
    <id>http://showteeth.tech/posts/36813.html</id>
    <published>2019-05-11T13:24:30.000Z</published>
    <updated>2019-05-11T14:15:55.346Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要介绍了jupyter中常用的快捷键。jupyter中的快捷键主要包括两种：<strong>命令模式的快捷键</strong>和<strong>编辑模式的快捷键</strong>，两张模式之间的切换：从<strong>命令模式进入编辑模式</strong>需按 <code>Enter</code> 键，从<strong>编辑模式切换到命令模式</strong>需按 <code>Esc</code> 键。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Jupyter Notebook 有两种键盘输入模式：<strong>命令模式</strong>和<strong>编辑模式</strong>，这与 <code>Vim</code> 有些类似。</p><ul><li><strong>在编辑模式下</strong>，可以往单元中键入代码或文本，此时单元格被<strong>绿色的框线</strong>包围，且命令模式下的快捷键不生效</li><li><strong>在命令模式下</strong>，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时的单元格<strong>被蓝色的框线</strong>包围，且编辑模式下的快捷键不生效。</li></ul><p>从<strong>命令模式进入编辑模式</strong>需按 <code>Enter</code> 键，从<strong>编辑模式切换到命令模式</strong>需按 <code>Esc</code> 键。</p><p>以下两表分别是对命令和编辑两种模式下快捷键的简单说明.</p><hr><h2 id="命令模式快捷键（按-Esc-键开启）"><a href="#命令模式快捷键（按-Esc-键开启）" class="headerlink" title="命令模式快捷键（按 Esc 键开启）"></a>命令模式快捷键（按 Esc 键开启）</h2><p>注意要使用这里面的快捷键<mark>需要先使用ESC键开启命令模式快捷键</mark>：<br><table><thead><tr><th width="10%">快捷键</th><th width="20%">作用</th><th width="70%">说明</th></tr></thead><tbody><tr><td>Enter</td><td>转入编辑模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下个单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td><strong>Alt-Enter</strong></td><td>运行本单元，在其下插入新单元</td><td>新单元默认为编辑模式</td></tr><tr><td><strong>Y</strong></td><td>单元转入代码状态</td><td></td></tr><tr><td><strong>M</strong></td><td>单元转入 markdown 状态</td><td></td></tr><tr><td>R</td><td>单元转入 raw 状态</td><td></td></tr><tr><td><strong>ALT + UP</strong></td><td>单元格上移</td><td></td></tr><tr><td><strong>ALT + DOWN</strong></td><td>单元格下移</td><td></td></tr><tr><td>1</td><td>设定 1 级标题</td><td>仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态</td></tr><tr><td>2</td><td>设定 2 级标题</td><td></td></tr><tr><td>3</td><td>设定 3 级标题</td><td></td></tr><tr><td>4</td><td>设定 4 级标题</td><td></td></tr><tr><td>5</td><td>设定 5 级标题</td><td></td></tr><tr><td>6</td><td>设定 6 级标题</td><td></td></tr><tr><td>Up</td><td>选中上方单元</td><td></td></tr><tr><td>K</td><td>选中上方单元</td><td></td></tr><tr><td>Down</td><td>选中下方单元</td><td></td></tr><tr><td>J</td><td>选中下方单元</td><td></td></tr><tr><td><strong>Shift-K</strong></td><td>连续选择上方单元</td><td></td></tr><tr><td><strong>Shift-J</strong></td><td>连续选择下方单元</td><td></td></tr><tr><td>A</td><td>在上方插入新单元</td><td></td></tr><tr><td>B</td><td>在下方插入新单元</td><td></td></tr><tr><td>X</td><td>剪切选中的单元</td><td></td></tr><tr><td>C</td><td>复制选中的单元</td><td></td></tr><tr><td>Shift-V</td><td>粘贴到上方单元</td><td></td></tr><tr><td>V</td><td>粘贴到下方单元</td><td></td></tr><tr><td>Z</td><td>恢复删除的最后一个单元</td><td></td></tr><tr><td>D,D</td><td>删除选中的单元</td><td>连续按两个 D 键</td></tr><tr><td>Shift-M</td><td>合并选中的单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>L</td><td>开关行号</td><td>编辑框的行号是可以开启和关闭的</td></tr><tr><td>O</td><td>转换输出</td><td></td></tr><tr><td>Shift-O</td><td>转换输出滚动</td><td></td></tr><tr><td>Esc</td><td>关闭页面</td><td></td></tr><tr><td>Q</td><td>关闭页面</td><td></td></tr><tr><td>H</td><td>显示快捷键帮助</td><td></td></tr><tr><td>I,I</td><td>中断 NoteBook 内核</td><td></td></tr><tr><td>0,0</td><td>重启 NoteBook 内核</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Shift-Space</td><td>向上滚动</td><td></td></tr><tr><td>Space</td><td>向下滚动</td><td></td></tr></tbody></table></p><hr><h2 id="编辑模式快捷键（-按-Enter-键启动）"><a href="#编辑模式快捷键（-按-Enter-键启动）" class="headerlink" title="编辑模式快捷键（ 按 Enter 键启动）"></a>编辑模式快捷键（ 按 Enter 键启动）</h2><p>注意要使用这里面的快捷键<mark>需要先使用Enter键开启编辑模式快捷键</mark>：<br><table><thead><tr><th width="10%">快捷键</th><th width="20%">作用</th><th width="70%">说明</th></tr></thead><tbody><tr><td>Tab</td><td>代码补全或缩进</td><td></td></tr><tr><td>Shift-Tab</td><td>提示</td><td>输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 <code>?</code> 再运行会显示更加详细的帮助</td></tr><tr><td>Ctrl-]</td><td>缩进</td><td>向右缩进</td></tr><tr><td>Ctrl-[</td><td>解除缩进</td><td>向左缩进</td></tr><tr><td>Ctrl-A</td><td>全选</td><td></td></tr><tr><td>Ctrl-Z</td><td>撤销</td><td></td></tr><tr><td>Ctrl-Shift-Z</td><td>重做</td><td></td></tr><tr><td>Ctrl-Y</td><td>重做</td><td></td></tr><tr><td>Ctrl-Home</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-Up</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-End</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Down</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Left</td><td>跳到左边一个字首</td><td></td></tr><tr><td>Ctrl-Right</td><td>跳到右边一个字首</td><td></td></tr><tr><td>Ctrl-Backspace</td><td>删除前面一个字</td><td></td></tr><tr><td>Ctrl-Delete</td><td>删除后面一个字</td><td></td></tr><tr><td>Esc</td><td>切换到命令模式</td><td></td></tr><tr><td>Ctrl-M</td><td>切换到命令模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下一单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在下面插入一单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Ctrl-Shift--</td><td>分割单元</td><td>按光标所在行进行分割</td></tr><tr><td>Ctrl-Shift-Subtract</td><td>分割单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Up</td><td>光标上移或转入上一单元</td><td></td></tr><tr><td>Down</td><td>光标下移或转入下一单元</td><td></td></tr><tr><td>Ctrl-/</td><td>注释整行/撤销注释</td><td>仅代码状态有效</td></tr></tbody></table></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://opus.konghy.cn/ipynb/jupyter-notebook-keyboard-shortcut.html" target="_blank" rel="noopener">Jupyter NoteBook 的快捷键使用指南</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，主要介绍了jupyter中常用的快捷键。jupyter中的快捷键主要包括两种：&lt;strong&gt;命令模式的快捷键&lt;/strong&gt;和&lt;strong&gt;编辑模式的快捷键&lt;/strong&gt;，两张模式之间的切换：从&lt;strong&gt;命令模式进入编辑模式&lt;/strong&gt;需按 &lt;code&gt;Enter&lt;/code&gt; 键，从&lt;strong&gt;编辑模式切换到命令模式&lt;/strong&gt;需按 &lt;code&gt;Esc&lt;/code&gt; 键。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Python/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之numpy-数组与矩阵运算(一)：数组创建</title>
    <link href="http://showteeth.tech/posts/24507.html"/>
    <id>http://showteeth.tech/posts/24507.html</id>
    <published>2019-05-11T12:37:02.000Z</published>
    <updated>2019-05-12T08:35:09.438Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用numpy<strong>创建数组的一些方法</strong>，包括 <strong><code>从列表或元组创建</code></strong>、<strong><code>创建特殊的数组(预分配数组、全0、全1、填充数组、单位矩阵、对角矩阵、上下三角矩阵)</code></strong>，期间也对numpy <strong><code>数组的属性</code></strong>以及 <strong><code>支持的数据类型</code></strong>进行了学习；还学习了 <strong>创建数列的方法</strong>，包括 <strong><code>指定步长的数列</code></strong>、<strong><code>指定数列长度的数列(等差、等比数列)</code></strong>；也学习了<strong>创建内容随机并且符合某种分布的numpy.random</strong>中的一些常见方法。</p></div><a id="more"></a><h2 id="numpy简介"><a href="#numpy简介" class="headerlink" title="numpy简介"></a>numpy简介</h2><p>NumPy 代表 “Numeric Python”，是一个由多维数组对象和用于处理数组的例程集合组成的库。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算，这类数值计算广泛用于以下任务：</p><ul><li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li><li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li><li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li></ul><hr><h2 id="由列表或者元组创建数组"><a href="#由列表或者元组创建数组" class="headerlink" title="由列表或者元组创建数组"></a>由列表或者元组创建数组</h2><p>使用的方法为<code>np.array(list or tuple)或者np.asarray(list or tuple)</code>，<strong>数据类型</strong>将由原序列中的元素类型推导而来。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = <span class="keyword">None</span>, copy = <span class="keyword">True</span>, order = <span class="string">'K'</span>, subok = <span class="keyword">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the input to an array.</span></span><br><span class="line">numpy.asarray(a, dtype = <span class="keyword">None</span>, order = <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>函数参数说明</strong>：<br><table><thead><tr><th width="10%">名称</th><th width="90%">描述</th></tr></thead><tbody><tr><td>object</td><td>数组或嵌套的数列</td></tr><tr><td>dtype</td><td>数组元素的数据类型，可选</td></tr><tr><td>copy</td><td>对象是否需要复制，可选</td></tr><tr><td>order</td><td>创建数组的样式(数据在内存中存储的方向)，C为行方向，F为列方向</td></tr><tr><td>subok</td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一维列表创建一维数组</span></span><br><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr1 = np.array(dt1)</span><br><span class="line">arr1  <span class="comment"># 一行六列的数组</span></span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维列表创建二维数组</span></span><br><span class="line">dt2=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">arr2=np.array(dt2)</span><br><span class="line">arr2</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最小维度为2</span></span><br><span class="line"><span class="comment"># dt1是一维的列表，设置最小维度为2</span></span><br><span class="line"><span class="comment"># 使得创建的数组是2维数组，和由二维列表创建的dt2维度相同</span></span><br><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr1 = np.array(dt1,ndmin=<span class="number">2</span>)</span><br><span class="line">arr1</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一维元组创建</span></span><br><span class="line">dt3 = np.array((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">dt3</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由二维元组创建</span></span><br><span class="line">dt4 = np.array(((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)))</span><br><span class="line">dt4</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p></p><p>注意：<strong>如果序列中的元素类型不统一，会将所有的转化为同一种类型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表中的元素类型不统一，包括字符串和数字</span></span><br><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'6'</span>]</span><br><span class="line">arr1 = np.array(dt1)</span><br><span class="line">arr1</span><br><span class="line">  <span class="comment"># 返回的结果是'&lt;U21'，数字和字符串的mix</span></span><br><span class="line">  array([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>], dtype=<span class="string">'&lt;U21'</span>)</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>不想让数组自动推断序列的元素数据类型(防止出现上面那种不想看到的结果)</strong>，可以在数组创建时，<strong>直接指定数据类型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'6'</span>]</span><br><span class="line">arr1 = np.array(dt1,dtype=<span class="string">'int16'</span>)</span><br><span class="line">arr1</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], dtype=int16)</span><br></pre></td></tr></table></figure><p></p><p>关于可以指定的数据类型，可以参考<a href="#numpy%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">下面的numpy支持的数据类型</a></p><p>如果创建的时候没有指定数据类型，在<strong>后期直接转换数据类型有可能会出错，得不到想要的结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'6'</span>]</span><br><span class="line">arr1 = np.array(dt1,dtype=<span class="string">'int16'</span>)</span><br><span class="line">arr1</span><br><span class="line">  array([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>], dtype=<span class="string">'&lt;U21'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续数据类型的转换</span></span><br><span class="line">arr1.dtype=<span class="string">'int16'</span></span><br><span class="line">arr1</span><br><span class="line">  <span class="comment"># 输出结果和真是的结果相差较大</span></span><br><span class="line">  <span class="comment"># 实际上就是将上面的unicode转化为了int16，不会得到1,2,3,4,5,6这种结果</span></span><br><span class="line">  array([<span class="number">49</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        .............</span><br><span class="line">        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">      dtype=int16)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>可以由其他的序列直接创建numpy数组，原始的序列是几维的，创建得到的数组就是几维的</li><li>如果序列中<strong>存在多种数据类型(尤其是数组中存在数字和字符这种mix)</strong>，最好的解决方法就是<strong>在创建数组的同时指定数据类型(默认创建时numpy会进行统一数据类型处理)</strong>，以免得到自己不想要的结果，影响后续的计算</li><li>上述两个函数将列表或元组转换为数组其实并没有什么差别，<code>numpy.asarray</code>是将输入转化为数组，而<code>np.array</code>是创建数组，还可以<strong>从可迭代对象中建立数组</strong>等，更多的方法请查看<a href="https://www.runoob.com/numpy/numpy-array-from-existing-data.html" target="_blank" rel="noopener">这个链接</a>.</li></ul></div><hr><h2 id="numpy中的数据类型"><a href="#numpy中的数据类型" class="headerlink" title="numpy中的数据类型"></a>numpy中的数据类型</h2><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型:<br><table><thead><tr><th width="10%">名称</th><th width="90%">描述</th></tr></thead><tbody><tr><td>bool_</td><td>布尔型数据类型（True 或者 False）</td></tr><tr><td>int_</td><td>默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr><td>intc</td><td>与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr><td>intp</td><td>用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr><td>int8</td><td>字节（-128 to 127）</td></tr><tr><td>int16</td><td>整数（-32768 to 32767）</td></tr><tr><td>int32</td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td>int64</td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td>uint8</td><td>无符号整数（0 to 255）</td></tr><tr><td>uint16</td><td>无符号整数（0 to 65535）</td></tr><tr><td>uint32</td><td>无符号整数（0 to 4294967295）</td></tr><tr><td>uint64</td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td>float_</td><td>float64 类型的简写</td></tr><tr><td>float16</td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td>float32</td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td>float64</td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td>complex_</td><td>complex128 类型的简写，即 128 位复数</td></tr><tr><td>complex64</td><td>复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td>complex128</td><td>复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table></p><p>有时候我们会看到一些特殊的情况，比如前面的<code>dtype=&#39;&lt;U21&#39;</code>，这个是什么含义呢？U其实代表的是Unicode类型，具体的每个内建类型都有一个唯一定义它的字符代码，如下：</p><table><thead><tr><th width="10%">字符</th><th width="90%">对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>(有符号) 整型</td></tr><tr><td>u</td><td>无符号整型 integer</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>(Python) 对象</td></tr><tr><td>S, a</td><td>(byte-)字符串</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据 (void)</td></tr></tbody></table><hr><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>在NumPy中维度(dimensions)叫做轴(axis)，轴的个数叫做秩(rank)。上面由一维列表或者元组创建的数组都是一个秩为1的数组，因为它们只有一个轴，如<code>array([1, 2, 3, 4, 5, 6])</code>，且这个轴的长度为6；而由二维列表或者元组创建的数组都是秩为2的数组。</p><p>在使用中的很多时候需要声明 <code>axis</code>：</p><ul><li><code>axis=0</code>，表示沿着第 0 轴进行操作，即<strong>对每一列进行操作</strong></li><li><code>axis=1</code>，表示沿着第1轴进行操作，即<strong>对每一行进行操作</strong></li></ul><p>NumPy的数组类被称作<code>ndarray</code>，通常被称作数组，相比于标准Python库类<code>array.array</code>，<code>ndarray</code>提供了更多的对象属性：<br><table><thead><tr><th width="10%">属性</th><th width="90%">说明</th></tr></thead><tbody><tr><td>ndarray.ndim</td><td>秩，即轴的数量或维度的数量，如二维数组的秩就是2</td></tr><tr><td>ndarray.shape</td><td>数组的维度，返回一个元组。一个n排m列的矩阵，它的shape属性将是(n,m)，这个元组的长度显然是秩，即ndim属性</td></tr><tr><td>ndarray.size</td><td>数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td>ndarray.dtype</td><td>ndarray 对象的元素类型</td></tr><tr><td>ndarray.itemsize</td><td>ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td>ndarray.flags</td><td>ndarray 对象的内存信息</td></tr><tr><td>ndarray.real</td><td>ndarray元素的实部</td></tr><tr><td>ndarray.imag</td><td>ndarray 元素的虚部</td></tr><tr><td>ndarray.data</td><td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dt4</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组的秩，即维度数目</span></span><br><span class="line">dt4.ndim</span><br><span class="line">  <span class="comment"># 返回2表示为2维数组</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组维度</span></span><br><span class="line">dt4.shape</span><br><span class="line"><span class="comment"># 返回的元组表示数组为二维数组，且每一维的长度分别为2和3</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组大小</span></span><br><span class="line">dt4.size</span><br><span class="line">  <span class="comment"># 返回为6，上面的每一位长度的乘积 </span></span><br><span class="line">  <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组的数据类型</span></span><br><span class="line">dt4.dtype</span><br><span class="line">  dtype(<span class="string">'int64'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建特殊数组"><a href="#创建特殊数组" class="headerlink" title="创建特殊数组"></a>创建特殊数组</h2><p>通常，数组的元素开始都是未知的，但是它的大小已知。因此，<strong>NumPy提供了一些使用占位符创建数组的函数</strong>。</p><h3 id="创建预分配数组-np-empty-empty-like"><a href="#创建预分配数组-np-empty-empty-like" class="headerlink" title="创建预分配数组-np.empty()|empty_like()"></a>创建预分配数组-np.empty()|empty_like()</h3><p>预分配数组<strong>只是初始化了数组尺寸</strong>，但是不保证元素值为0或者1，<strong>其内容是随机并且依赖与内存状态的</strong>，<strong>默认创建得到的数据类型都为float</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = float, order = <span class="string">'C'</span>)</span><br><span class="line"><span class="comment"># shape为数组的维度，可以使用元组或者列表，为了和np.shape的返回值保持一致，使用元组最好</span></span><br><span class="line"><span class="comment"># order有"C"和"F"两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序</span></span><br><span class="line"><span class="comment"># order一般用不上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以a为模板，创建相同维度的预分配数组</span></span><br><span class="line">numpy.empty_like(a, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="comment"># 返回一个内容随机的数组</span></span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据模板创建</span></span><br><span class="line">dt3.shape</span><br><span class="line">  <span class="comment"># dt3是一个一维的数组</span></span><br><span class="line">  (<span class="number">3</span>,)</span><br><span class="line"><span class="comment"># 创建一个和dt3同shape的数组</span></span><br><span class="line">np.empty_like(dt4)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建全0-全1数组-np-zeros-ones"><a href="#创建全0-全1数组-np-zeros-ones" class="headerlink" title="创建全0|全1数组-np.zeros()|ones()"></a>创建全0|全1数组-np.zeros()|ones()</h3><p>和前面的<code>empty</code>函数不同的是，这里创建的数组的内容都为<code>0(np.zeros)</code>或<code>1(np.ones)</code>，而<strong>非随机</strong>，<strong>默认创建得到的数据类型都为float</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = float, order = <span class="string">'C'</span>)</span><br><span class="line">numpy.ones(shape, dtype = <span class="keyword">None</span>, order = <span class="string">'C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以a为模板，创建相同维度的全1或0数组</span></span><br><span class="line">np.ones_like(a, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br><span class="line">np.zeros_like(a, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建全1数组</span></span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="comment"># 数组的内容全为1</span></span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全0数组</span></span><br><span class="line">np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="comment"># 数组的内容全为0 </span></span><br><span class="line">  array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以dt3为模板创建相同维度的全1数组</span></span><br><span class="line">np.ones_like(dt3)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 以dt3为模板创建相同维度的全0数组</span></span><br><span class="line">np.zeros_like(dt3)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建填充数组"><a href="#创建填充数组" class="headerlink" title="创建填充数组"></a>创建填充数组</h3><p>前面的几个创建数组的方式，要么内容是全随机的，要么是全为0或1的数组，如果希望使用指定的值来填充数组，得到全为指定值的数据可以使用np.full函数。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.full(shape, fill_value, dtype=<span class="keyword">None</span>, order=<span class="string">'C'</span>)</span><br><span class="line"></span><br><span class="line">np.full_like(a, fill_value, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个2行3列，内容全为0.2的数组</span></span><br><span class="line">np.full((<span class="number">2</span>,<span class="number">3</span>),<span class="number">0.2</span>)</span><br><span class="line">  <span class="comment"># 输出2行3列，内容全为0.2的数组</span></span><br><span class="line">  array([[<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">       [<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建单位矩阵-np-identity-eye"><a href="#创建单位矩阵-np-identity-eye" class="headerlink" title="创建单位矩阵-np.identity()|eye()"></a>创建单位矩阵-np.identity()|eye()</h3><p>单位矩阵是指<strong>对角线上元素全为1</strong>并且<strong>除此以外元素全都为0</strong>的矩阵，严格的单位阵使用 <code>np.identity()</code> 命令创建，非严格的单位矩阵可以使用<code>np.eye()</code>创建。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.identity(n, dtype=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">np.eye(N, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C')</span><br><span class="line"><span class="comment"># N：行数</span></span><br><span class="line"><span class="comment"># M：列数</span></span><br><span class="line"><span class="comment"># k：对角线的索引，默认是主对角线，大于0表示偏上的对角线，小于0表示偏下的对角线</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建3行3列的单位矩阵</span></span><br><span class="line">np.identity(<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建2行3列的单位矩阵</span></span><br><span class="line"><span class="comment"># 默认的对角线索引为0</span></span><br><span class="line">np.eye(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建2行3列的单位矩阵，对角线索引为1，向上平移</span></span><br><span class="line">np.eye(<span class="number">2</span>,<span class="number">3</span>,k=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建2行3列的单位矩阵，对角线索引为-1，向下平移</span></span><br><span class="line">np.eye(<span class="number">2</span>,<span class="number">3</span>,k=<span class="number">-1</span>)</span><br><span class="line">  array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>np.identity()</code>创建的是严格的单位矩阵，首先，<strong>矩阵是正方矩阵(行数和列数相同)</strong>，其次，只有<strong>主对角线的元素为1</strong></li><li><code>np.eye()</code>创建的是非严格的单位矩阵，对应地，矩阵<strong>不一定是正方矩阵</strong>，并且<strong>元素为1的对角线位置可以调整</strong></li></ul></div><hr><h3 id="创建对角矩阵-np-diagflat"><a href="#创建对角矩阵-np-diagflat" class="headerlink" title="创建对角矩阵-np.diagflat()"></a>创建对角矩阵-np.diagflat()</h3><p>对角矩阵是一个主对角线之外的元素皆为0的矩阵，对角线上的元素可以为0或其他值，单位矩阵就是对角矩阵的一种，其对角线上的元素为1。对角矩阵的创建使用<code>np.diagflat()</code>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.diagflat(array_like, k=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># array_like：类似数组的序列，可以是列表、数组、元组，序列的元素数目表示了矩阵的行数(在未指定k的前提下)</span></span><br><span class="line"><span class="comment"># 序列的每个元素依次填充在对角矩阵的每一行对应的位置</span></span><br><span class="line"><span class="comment"># k：对角线的索引位置</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建对角线元素为1,2,3,4的对角矩阵</span></span><br><span class="line"><span class="comment"># 列表元素数目为2，所以对角矩阵为4行4列</span></span><br><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 也可以使用二维的列表创建</span></span><br><span class="line">np.diagflat([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对角矩阵对角线填充位置开始于1</span></span><br><span class="line"><span class="comment"># 此时的元素数目为4，但是因为设置了k=1，所以行数和列数都变为了5</span></span><br><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],k=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建上下三角矩阵"><a href="#创建上下三角矩阵" class="headerlink" title="创建上下三角矩阵"></a>创建上下三角矩阵</h3><p>下三角矩阵是指对角线上方的元素全部为0的矩阵，同样的，上三角矩阵是指对角线下方的元素全部为0的矩阵。创建这种矩阵，numpy提供了几种函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建下三角矩阵，且下三角中的元素全为1</span></span><br><span class="line">np.tri(N, M=<span class="keyword">None</span>, k=<span class="number">0</span>, dtype=&lt;<span class="class"><span class="keyword">class</span> '<span class="title">float</span>'&gt;)</span></span><br><span class="line"><span class="class"># <span class="title">N</span>：行数</span></span><br><span class="line"><span class="class"># <span class="title">M</span>：列数</span></span><br><span class="line"><span class="class"># <span class="title">k</span>：对角线的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 创建下三角矩阵，下三角内容的填充由<span class="title">array_like</span>内容中选取</span></span><br><span class="line"><span class="class"># 相当于先使用<span class="title">array_like</span>创建矩阵，然后将上三角的内容设置为0</span></span><br><span class="line"><span class="class"><span class="title">np</span>.<span class="title">tril</span><span class="params">(array_like, k=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 创建上三角矩阵，上三角内容的填充由<span class="title">array_like</span>内容中选取</span></span><br><span class="line"><span class="class"># 相当于先使用<span class="title">array_like</span>创建矩阵，然后将下三角的内容设置为0</span></span><br><span class="line"><span class="class"><span class="title">np</span>.<span class="title">triu</span><span class="params">(array_like, k=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建不严格的下三角矩阵，2行3列</span></span><br><span class="line"><span class="comment"># 且下三角矩阵的元素为1</span></span><br><span class="line">np.tri(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建严格的下三角矩阵，3行3列</span></span><br><span class="line">np.tri(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建上三角矩阵，内容从指定的array_like中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将下三角的内容设置为0</span></span><br><span class="line">np.triu([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]], <span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建下三角矩阵，内容从指定的array_like中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将上三角的内容设置为0</span></span><br><span class="line">np.triu([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]], <span class="number">0</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建数列"><a href="#创建数列" class="headerlink" title="创建数列"></a>创建数列</h2><h3 id="创建指定步长的数列"><a href="#创建指定步长的数列" class="headerlink" title="创建指定步长的数列"></a>创建指定步长的数列</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange([start,] stop[, step,], dtype=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong>：<br><table><thead><tr><th width="10%">参数</th><th width="90%">描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>起始值，默认为<code>0</code></td></tr><tr><td><code>stop</code></td><td>终止值（不包含）</td></tr><tr><td><code>step</code></td><td>步长，默认为<code>1</code></td></tr><tr><td><code>dtype</code></td><td>返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建从1开始，到5结束(不包括5)，步长为1的数列</span></span><br><span class="line">np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建指定长度的数组"><a href="#创建指定长度的数组" class="headerlink" title="创建指定长度的数组"></a>创建指定长度的数组</h3><h4 id="等差数组"><a href="#等差数组" class="headerlink" title="等差数组"></a>等差数组</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="keyword">True</span>, retstep=<span class="keyword">False</span>, dtype=<span class="keyword">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong>：<br><table><thead><tr><th width="10%">参数</th><th width="90%">描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>序列的起始值</td></tr><tr><td><code>stop</code></td><td>序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td><code>num</code></td><td>要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td><code>endpoint</code></td><td>该值为 <code>ture</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是True。</td></tr><tr><td><code>retstep</code></td><td>如果为 True 时，生成的数组中会显示间距，反之不显示。</td></tr><tr><td><code>dtype</code></td><td><code>ndarray</code> 的数据类型</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建从1到9，长度为10的等差数列</span></span><br><span class="line"><span class="comment"># 默认是包括9的</span></span><br><span class="line">np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">  array([<span class="number">1.</span>        , <span class="number">1.88888889</span>, <span class="number">2.77777778</span>, <span class="number">3.66666667</span>, <span class="number">4.55555556</span>,</span><br><span class="line">        <span class="number">5.44444444</span>, <span class="number">6.33333333</span>, <span class="number">7.22222222</span>, <span class="number">8.11111111</span>, <span class="number">9.</span>        ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置不包括9 </span></span><br><span class="line">np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>,endpoint=<span class="keyword">False</span>)</span><br><span class="line">  array([<span class="number">1.</span> , <span class="number">1.8</span>, <span class="number">2.6</span>, <span class="number">3.4</span>, <span class="number">4.2</span>, <span class="number">5.</span> , <span class="number">5.8</span>, <span class="number">6.6</span>, <span class="number">7.4</span>, <span class="number">8.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示间距</span></span><br><span class="line"><span class="comment"># 返回数组和间距构成的元组</span></span><br><span class="line">np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>,retstep=<span class="keyword">True</span>)</span><br><span class="line">  (array([<span class="number">1.</span>        , <span class="number">1.88888889</span>, <span class="number">2.77777778</span>, <span class="number">3.66666667</span>, <span class="number">4.55555556</span>,</span><br><span class="line">        <span class="number">5.44444444</span>, <span class="number">6.33333333</span>, <span class="number">7.22222222</span>, <span class="number">8.11111111</span>, <span class="number">9.</span>        ]),</span><br><span class="line"> <span class="number">0.8888888888888888</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>与前面的<code>np.arange()</code>相比：</p><ul><li><code>np.linspace()</code>：不能指定间距，但可以显示间距</li><li><code>np.linspace()</code>：可以设置长度；默认是包含endpoint(可以设置为不包含)，而<code>np.arange()</code>默认是不包含，并且不可以设置</li></ul></div><hr><h4 id="等比数组"><a href="#等比数组" class="headerlink" title="等比数组"></a>等比数组</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="keyword">True</span>, base=<span class="number">10.0</span>, dtype=<span class="keyword">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong>：<br><table><thead><tr><th width="10%">参数</th><th width="90%">描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>序列的起始值，实际起始值为：base ** start</td></tr><tr><td><code>stop</code></td><td>序列的终止值为，实际起始值为：base ** stop。如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td><code>num</code></td><td>要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td><code>endpoint</code></td><td>该值为 <code>ture</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是True。</td></tr><tr><td><code>base</code></td><td>对数 log 的底数。</td></tr><tr><td><code>dtype</code></td><td><code>ndarray</code> 的数据类型</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是以10为底</span></span><br><span class="line">np.logspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 实际上是从10^1-10^2，长度为10的等比数列</span></span><br><span class="line">  array([ <span class="number">10.</span>        ,  <span class="number">12.91549665</span>,  <span class="number">16.68100537</span>,  <span class="number">21.5443469</span> ,</span><br><span class="line">          <span class="number">27.82559402</span>,  <span class="number">35.93813664</span>,  <span class="number">46.41588834</span>,  <span class="number">59.94842503</span>,</span><br><span class="line">          <span class="number">77.42636827</span>, <span class="number">100.</span>        ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置以2为底</span></span><br><span class="line"><span class="comment"># 从2^0-2^9，长度为10的等比数列</span></span><br><span class="line">np.logspace(<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,base=<span class="number">2</span>)  </span><br><span class="line">  array([  <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">4.</span>,   <span class="number">8.</span>,  <span class="number">16.</span>,  <span class="number">32.</span>,  <span class="number">64.</span>, <span class="number">128.</span>, <span class="number">256.</span>, <span class="number">512.</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建随机且符合某种分布的数组-np-random"><a href="#创建随机且符合某种分布的数组-np-random" class="headerlink" title="创建随机且符合某种分布的数组-np.random"></a>创建随机且符合某种分布的数组-np.random</h2><p>在实际使用中，经常需要用到numpy的随机函数，由于随机函数random的功能比较多，经常会混淆或记不住，下面就学习和列举几种比较常用的。</p><h3 id="0-1-之间的随机数-numpy-random-rand"><a href="#0-1-之间的随机数-numpy-random-rand" class="headerlink" title="[0,1)之间的随机数-numpy.random.rand()"></a>[0,1)之间的随机数-numpy.random.rand()</h3><p><code>rand</code>函数根据给定维度生成<code>[0,1)</code>之间的数据，<strong>包含0，不包含1</strong>.</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.rand(d0, d1, ..., dn)</span><br><span class="line"><span class="comment"># dn表示维度信息</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生一个四行两列的随机数组</span></span><br><span class="line"><span class="comment"># 元素的取值范围为[0,1)</span></span><br><span class="line">np.random.rand(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">  array([[<span class="number">0.6126271</span> , <span class="number">0.84776825</span>],</span><br><span class="line">       [<span class="number">0.5572775</span> , <span class="number">0.02186394</span>],</span><br><span class="line">       [<span class="number">0.51725555</span>, <span class="number">0.76771822</span>],</span><br><span class="line">       [<span class="number">0.65649717</span>, <span class="number">0.80120975</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="N-0-1-的标准正态分布-numpy-random-randn"><a href="#N-0-1-的标准正态分布-numpy-random-randn" class="headerlink" title="N(0,1)的标准正态分布-numpy.random.randn()"></a>N(0,1)的标准正态分布-numpy.random.randn()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randn(d0, d1, ..., dn)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生一个3行2列的标准正太分布</span></span><br><span class="line">np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">  array([[ <span class="number">1.79853947</span>,  <span class="number">0.57042178</span>],</span><br><span class="line">       [<span class="number">-0.07007952</span>, <span class="number">-1.45797489</span>],</span><br><span class="line">       [ <span class="number">0.82423002</span>, <span class="number">-0.4111874</span> ]])</span><br></pre></td></tr></table></figure><p></p><p>如果想要产生的<strong>不是标准正太分布</strong>可以变换：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生一个N(3, 6.25)的正太分布</span></span><br><span class="line"><span class="comment"># 2.5 * 2.5 = 6.25</span></span><br><span class="line"><span class="number">2.5</span> * np.random.randn(<span class="number">2</span>, <span class="number">4</span>) + <span class="number">3</span></span><br><span class="line">  array([[ <span class="number">3.87050085</span>,  <span class="number">4.90415633</span>,  <span class="number">0.86676374</span>,  <span class="number">1.07284953</span>],</span><br><span class="line">       [ <span class="number">2.1834204</span> ,  <span class="number">1.54992813</span>, <span class="number">-2.60284824</span>,  <span class="number">3.54083072</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="low-high-范围内的随机整数-numpy-random-randint"><a href="#low-high-范围内的随机整数-numpy-random-randint" class="headerlink" title="[low,high)范围内的随机整数-numpy.random.randint()"></a>[low,high)范围内的随机整数-numpy.random.randint()</h3><p>前面几个函数得到的都是随机的浮点型数，如果想要得到随机整数，可以使用<code>numpy.random.randint()</code>函数。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randint(low, high=<span class="keyword">None</span>, size=<span class="keyword">None</span>, dtype=<span class="string">'l'</span>)</span><br><span class="line"><span class="comment"># size:shape</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生10个在0-3范围内的随机整数</span></span><br><span class="line">np.random.randint(<span class="number">3</span>,size=<span class="number">10</span>)</span><br><span class="line">  array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生一个2行3列的，元素在0-3范围内的随机整数</span></span><br><span class="line">np.random.randint(<span class="number">3</span>,size=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="固定随机数-numpy-random-seed"><a href="#固定随机数-numpy-random-seed" class="headerlink" title="固定随机数-numpy.random.seed()"></a>固定随机数-numpy.random.seed()</h3><p>默认情况下，每次运行一遍上面的几个函数，得到的结果都会和前一次的不同，需要需要每次运行得到的随机数相同，可以使用<code>numpy.random.seed()</code>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(seed=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首次运行</span></span><br><span class="line">np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">0.22489862</span>, <span class="number">0.53165975</span>, <span class="number">0.57325016</span>],</span><br><span class="line">       [<span class="number">0.75665698</span>, <span class="number">0.14746711</span>, <span class="number">0.7346116</span> ]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行</span></span><br><span class="line">  array([[<span class="number">0.51628755</span>, <span class="number">0.41312364</span>, <span class="number">0.3912831</span> ],</span><br><span class="line">        [<span class="number">0.92598188</span>, <span class="number">0.88553487</span>, <span class="number">0.22607687</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定seed，多次运行都不会变</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line">np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">0.69646919</span>, <span class="number">0.28613933</span>, <span class="number">0.22685145</span>],</span><br><span class="line">       [<span class="number">0.55131477</span>, <span class="number">0.71946897</span>, <span class="number">0.42310646</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/214798dd8f93" target="_blank" rel="noopener">为什么你用不好Numpy的random函数？</a></li><li><a href="https://segmentfault.com/a/1190000016097466" target="_blank" rel="noopener">numpy-random函数</a></li></ul><hr><h2 id="np-random函数总结"><a href="#np-random函数总结" class="headerlink" title="np.random函数总结"></a>np.random函数总结</h2><h3 id="简单的随机数据"><a href="#简单的随机数据" class="headerlink" title="简单的随机数据"></a>简单的随机数据</h3><table><tr><th width="20%">函数</th><th width="80%">说明</th></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand" target="_blank" rel="noopener">rand</a>(d0, d1, ..., dn)</td><td>[0,1)之间的随机值，dn表示维度信息</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn" target="_blank" rel="noopener">randn</a>(d0, d1, ..., dn)</td><td>标准正态分布，可以进行变换得到非标准正太分布</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint" target="_blank" rel="noopener">randint</a>(low[, high, size])</td><td>位于半开区间 [low, high)的随机整数，不指定high的情况下是从[0,low)</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_integers.html#numpy.random.random_integers" target="_blank" rel="noopener">random_integers</a>(low[, high, size])</td><td>位于闭区间 [low, high]的随机整数，不指定high的情况下是从[1,low]</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_sample.html#numpy.random.random_sample" target="_blank" rel="noopener">random_sample</a>([size])</td><td>在半开区间 [0.0, 1.0)的随机浮点数，可以变换(b - a) * random_sample() + a；与此类似的还有<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random.html#numpy.random.random" target="_blank" rel="noopener">random</a>([size])、<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf" target="_blank" rel="noopener">ranf</a>([size])、<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.sample.html#numpy.random.sample" target="_blank" rel="noopener">sample</a>([size])</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" target="_blank" rel="noopener">choice</a>(a[, size, replace, p])</td><td>从一个给定的一维数组生成一个随机样本</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.bytes.html#numpy.random.bytes" target="_blank" rel="noopener">bytes</a>(length)</td><td>返回随机字节</td></tr></table><hr><h3 id="重新排列数组"><a href="#重新排列数组" class="headerlink" title="重新排列数组"></a>重新排列数组</h3><table><tr><th width="15%">函数</th><th width="85%">说明</th></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html#numpy.random.shuffle" target="_blank" rel="noopener">shuffle</a>(array)</td><td>打乱array的顺序，原位修改</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.permutation.html#numpy.random.permutation" target="_blank" rel="noopener">permutation</a>(array)</td><td>返回array的一个随机排列</td></tr></table><hr><h3 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h3><table><tr><th width="20%">函数</th><th width="80%">说明</th></tr><tr><td>beta(a, b[, size])</td><td>贝塔分布样本，在 [0, 1]内。</td></tr><tr><td>binomial(n, p[, size])</td><td>二项分布的样本。</td></tr><tr><td>chisquare(df[, size])</td><td>卡方分布样本。</td></tr><tr><td>dirichlet(alpha[, size])</td><td>狄利克雷分布样本。</td></tr><tr><td>exponential([scale, size])</td><td>指数分布</td></tr><tr><td>f(dfnum, dfden[, size])</td><td>F分布样本。</td></tr><tr><td>gamma(shape[, scale, size])</td><td>伽马分布</td></tr><tr><td>geometric(p[, size])</td><td>几何分布</td></tr><tr><td>gumbel([loc, scale, size])</td><td>耿贝尔分布。</td></tr><tr><td>hypergeometric(ngood, nbad, nsample[, size])</td><td>超几何分布样本。</td></tr><tr><td>laplace([loc, scale, size])</td><td>拉普拉斯或双指数分布样本</td></tr><tr><td>logistic([loc, scale, size])</td><td>Logistic分布样本</td></tr><tr><td>lognormal([mean, sigma, size])</td><td>对数正态分布</td></tr><tr><td>logseries(p[, size])</td><td>对数级数分布。</td></tr><tr><td>multinomial(n, pvals[, size])</td><td>多项分布</td></tr><tr><td>multivariate_normal(mean, cov[, size])</td><td>多元正态分布</td></tr><tr><td>negative_binomial(n, p[, size])</td><td>负二项分布</td></tr><tr><td>noncentral_chisquare(df, nonc[, size])</td><td>非中心卡方分布</td></tr><tr><td>noncentral_f(dfnum, dfden, nonc[, size])</td><td>非中心F分布</td></tr><tr><td>normal([loc, scale, size])</td><td>正态(高斯)分布</td></tr><tr><td>pareto(a[, size])</td><td>帕累托（Lomax）分布</td></tr><tr><td>poisson([lam, size])</td><td>泊松分布</td></tr><tr><td>power(a[, size])</td><td>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</td></tr><tr><td>rayleigh([scale, size])</td><td>Rayleigh 分布</td></tr><tr><td>standard_cauchy([size])</td><td>标准柯西分布</td></tr><tr><td>standard_exponential([size])</td><td>标准的指数分布</td></tr><tr><td>standard_gamma(shape[, size])</td><td>标准伽马分布</td></tr><tr><td>standard_normal([size])</td><td>标准正态分布 (mean=0, stdev=1).</td></tr><tr><td>standard_t(df[, size])</td><td>Standard Student’s t distribution with df degrees of freedom.</td></tr><tr><td>triangular(left, mode, right[, size])</td><td>三角形分布</td></tr><tr><td>uniform([low, high, size])</td><td>均匀分布</td></tr><tr><td>vonmises(mu, kappa[, size])</td><td>von Mises分布</td></tr><tr><td>wald(mean, scale[, size])</td><td>瓦尔德（逆高斯）分布</td></tr><tr><td>weibull(a[, size])</td><td>Weibull 分布</td></tr><tr><td>zipf(a[, size])</td><td>齐普夫分布</td></tr></table><hr><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h3><table><tr><th width="15%">函数</th><th width="85%">说明</th></tr><tr><td>RandomState</td><td>Container for the Mersenne Twister pseudo-random number generator.</td></tr><tr><td>seed([seed])</td><td>Seed the generator.</td></tr><tr><td>get_state()</td><td>Return a tuple representing the internal state of the generator.</td></tr><tr><td>set_state(state)</td><td>Set the internal state of the generator from a tuple.</td></tr></table><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.cnblogs.com/hhh5460/p/4324967.html" target="_blank" rel="noopener">numpy的random模块</a></li></ul><hr><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了使用numpy&lt;strong&gt;创建数组的一些方法&lt;/strong&gt;，包括 &lt;strong&gt;&lt;code&gt;从列表或元组创建&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;创建特殊的数组(预分配数组、全0、全1、填充数组、单位矩阵、对角矩阵、上下三角矩阵)&lt;/code&gt;&lt;/strong&gt;，期间也对numpy &lt;strong&gt;&lt;code&gt;数组的属性&lt;/code&gt;&lt;/strong&gt;以及 &lt;strong&gt;&lt;code&gt;支持的数据类型&lt;/code&gt;&lt;/strong&gt;进行了学习；还学习了 &lt;strong&gt;创建数列的方法&lt;/strong&gt;，包括 &lt;strong&gt;&lt;code&gt;指定步长的数列&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;指定数列长度的数列(等差、等比数列)&lt;/code&gt;&lt;/strong&gt;；也学习了&lt;strong&gt;创建内容随机并且符合某种分布的numpy.random&lt;/strong&gt;中的一些常见方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之jupyter中dataframe美化</title>
    <link href="http://showteeth.tech/posts/62040.html"/>
    <id>http://showteeth.tech/posts/62040.html</id>
    <published>2019-05-09T13:24:29.000Z</published>
    <updated>2019-05-11T12:37:58.052Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了对jupyter中<strong>美化dataframe显示的语法</strong>，主要包括用于<strong>控制显示</strong>的<code>dataframe.style.apply()</code>、<code>dataframe.style.applymap()</code>以及<strong>控制显示格式</strong>的<code>dataframe.style.format()</code>以及一些<strong>内置的用法</strong>。</p></div><a id="more"></a><h2 id="styling"><a href="#styling" class="headerlink" title="styling"></a>styling</h2><p>在pandas 0.17.1之后的版本中出现了可以formatting以及displaying dataframe的Styler object，其主要是通过添加css样式达到的目的，接下来就学习一下吧。</p><hr><h2 id="pandas的apply相关函数"><a href="#pandas的apply相关函数" class="headerlink" title="pandas的apply相关函数"></a>pandas的apply相关函数</h2><p>pandas中<code>apply(func)</code>可以将函数<strong>作用于行或者列的数据</strong>，而<code>applymap(func)</code>可以<strong>作用于table中的单个数据</strong>，在这里也结合了appy相关的函数：</p><ul><li><code>Styler.applymap(func)</code> for elementwise styles</li><li><code>Styler.apply(func, axis=0)</code> for columnwise styles</li><li><code>Styler.apply(func, axis=1)</code> for rowwise styles</li><li><code>Styler.apply(func, axis=None)</code> for tablewise styles</li></ul><hr><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df=pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="通过阈值控制颜色"><a href="#通过阈值控制颜色" class="headerlink" title="通过阈值控制颜色"></a>通过阈值控制颜色</h2><ul><li><p>定义函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showColor</span><span class="params">(val)</span>:</span></span><br><span class="line">    color= <span class="string">'red'</span> <span class="keyword">if</span> val &gt;<span class="number">0</span> <span class="keyword">else</span> <span class="string">'green'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'color:%s'</span> %color</span><br></pre></td></tr></table></figure></li><li><p>应用函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.style.applymap(showColor)</span><br></pre></td></tr></table></figure></li><li><p>展示效果<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/20190509213357.png" alt="20190509213357.png"></p></li></ul><hr><h2 id="只对指定列进行操作"><a href="#只对指定列进行操作" class="headerlink" title="只对指定列进行操作"></a>只对指定列进行操作</h2><p>注意这里的<code>subset</code>以及<code>pd.IndexSlice</code>的用法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># applymap只作用于前五行的后五列</span></span><br><span class="line">df.style.applymap(showColor,subset=pd.IndexSlice[:<span class="number">5</span>,<span class="number">5</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># applymap只作用于第三行的第5到8列，注意是包括第八列</span></span><br><span class="line">df.style.applymap(showColor,subset=pd.IndexSlice[<span class="number">2</span>,<span class="number">5</span>:<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># applymap作用于第四行的不连续的列</span></span><br><span class="line">df.style.applymap(showColor,subset=pd.IndexSlice[<span class="number">3</span>,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]])</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_2.png" alt="dataframe_bautify_2.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_3.png" alt="dataframe_bautify_3.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_4.png" alt="dataframe_bautify_4.png"></p><hr><h2 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h2><ul><li><p>定义函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给每一列最低的添加黄色的背景色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_bg</span><span class="params">(col)</span>:</span></span><br><span class="line">    <span class="comment"># 涉及到运算符顺序</span></span><br><span class="line">    <span class="comment"># 赋值运算符优先级较低</span></span><br><span class="line">    c=col==col.max()</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'background-color:yellow'</span> <span class="keyword">if</span> v <span class="keyword">else</span> <span class="string">''</span> <span class="keyword">for</span> v <span class="keyword">in</span> c]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_bg_2</span><span class="params">(col)</span>:</span></span><br><span class="line">    <span class="comment"># np.sign为符号函数，大于0的为1，小于0的为0</span></span><br><span class="line">    s=np.sign(col)==np.sign(col.max())</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'background-color:blue'</span> <span class="keyword">if</span> v <span class="keyword">else</span> <span class="string">'background-color:red'</span> <span class="keyword">for</span> v <span class="keyword">in</span> s]</span><br></pre></td></tr></table></figure></li><li><p>应用函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.style.apply(show_bg)</span><br></pre></td></tr></table></figure></li><li><p>展示效果</p></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_5.png" alt="dataframe_bautify_5.png"></p><ul><li>使用内置的函数实现：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内置的方法实现对最大值上背景色</span></span><br><span class="line"><span class="comment"># 默认颜色为黄色，可以通过color设置</span></span><br><span class="line">df.style.highlight_max(color=<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_6.png" alt="dataframe_bautify_6.png"></p><hr><h2 id="组合上面的颜色以及背景色"><a href="#组合上面的颜色以及背景色" class="headerlink" title="组合上面的颜色以及背景色"></a>组合上面的颜色以及背景色</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apply函数的subset直接指定列就行</span></span><br><span class="line">df.style.applymap(showColor).apply(show_bg,subset=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_7.png" alt="dataframe_bautify_7.png"></p><hr><h2 id="实现百分比显示"><a href="#实现百分比显示" class="headerlink" title="实现百分比显示"></a>实现百分比显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的bar显示</span></span><br><span class="line">df.style.bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的bar显示</span></span><br><span class="line">df.style.bar(subset=[<span class="string">'A'</span>, <span class="string">'B'</span>], align=<span class="string">'mid'</span>, color=[<span class="string">'#d65f5f'</span>, <span class="string">'#5fba7d'</span>])</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_8.png" alt="dataframe_bautify_8.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_10.png" alt="dataframe_bautify_10.png"></p><hr><h2 id="设置数据格式"><a href="#设置数据格式" class="headerlink" title="设置数据格式"></a>设置数据格式</h2><p>和上面的使用<code>df.style.apply</code>等不同，这里使用<code>df.style.format</code>进行格式的控制，具体对格式的控制参考<a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" target="_blank" rel="noopener">format函数</a>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百分比显示，小数点后保留两位</span></span><br><span class="line"><span class="comment"># 但是不能写到文件</span></span><br><span class="line">df.style.format(<span class="string">"&#123;:.2%&#125;"</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_9.png" alt="dataframe_bautify_9.png"></p><hr><h2 id="更多的用法"><a href="#更多的用法" class="headerlink" title="更多的用法"></a>更多的用法</h2><p>还支持想excel中的色阶操作以及鼠标滑动上去之后方法显示数据的效果等，具体请<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/style.html" target="_blank" rel="noopener">参考官方文档</a></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/style.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://blog.csdn.net/xiaodongxiexie/article/details/71202279" target="_blank" rel="noopener">jupyter notebook中美化pandas中DataFrame的输出</a></li><li><a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" target="_blank" rel="noopener">format函数</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了对jupyter中&lt;strong&gt;美化dataframe显示的语法&lt;/strong&gt;，主要包括用于&lt;strong&gt;控制显示&lt;/strong&gt;的&lt;code&gt;dataframe.style.apply()&lt;/code&gt;、&lt;code&gt;dataframe.style.applymap()&lt;/code&gt;以及&lt;strong&gt;控制显示格式&lt;/strong&gt;的&lt;code&gt;dataframe.style.format()&lt;/code&gt;以及一些&lt;strong&gt;内置的用法&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Python/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jupyter进一步配置和使用</title>
    <link href="http://showteeth.tech/posts/21776.html"/>
    <id>http://showteeth.tech/posts/21776.html</id>
    <published>2019-05-06T09:28:23.000Z</published>
    <updated>2019-05-11T12:37:58.062Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录关于jupyter的一下小工具，包括<code>ipywidgets</code>、<code>qgrid</code>、<code>输出矢量图</code>、<code>管理conda环境</code>、<code>markdown设置锚定</code>、<code>加载网页源代码或者本地python程序</code>、<code>运行本地python程序</code>等.</p></div><a id="more"></a><h2 id="ipywidgets"><a href="#ipywidgets" class="headerlink" title="ipywidgets"></a>ipywidgets</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可以实现 jupyter notebook 笔记本的交互式控件操作，个人觉得在于matplotlib进行画图配合上具有比较好的效果。</p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用conda安装</span></span><br><span class="line">conda install -c conda-forge ipywidgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># jupyter安装在base的server</span></span><br><span class="line"><span class="comment"># kernel安装在py36</span></span><br><span class="line">conda install -n base -c conda-forge widgetsnbextension</span><br><span class="line">conda install -n py36 -c conda-forge ipywidgets</span><br></pre></td></tr></table></figure><hr><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">官方文档</a>上面有很多使用的示例，个人感觉这个插件与matplotlib结合起来进行绘图可能是比较好的选择，以下是一些示例：</p><ul><li><p><a href="https://stackoverflow.com/questions/40122837/interactive-matplotlib-using-ipywidgets" target="_blank" rel="noopener">通过调整w来调整图像的显示范围</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from ipywidgets import *</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">x = np.linspace(0, 2 * np.pi)</span><br><span class="line"><span class="comment">## 通过调整w来调整图像的显示范围</span></span><br><span class="line">def update(w = 1.0):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(1, 1, 1)</span><br><span class="line">    ax.plot(x, np.sin(w * x))</span><br><span class="line"></span><br><span class="line">    fig.canvas.draw()</span><br><span class="line"></span><br><span class="line">interact(update);</span><br></pre></td></tr></table></figure></li><li><p>调整直线的斜率和截距</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">from ipywidgets import interactive</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def f(m, b):</span><br><span class="line">    plt.figure(2)</span><br><span class="line">    x = np.linspace(-10, 10, num=1000)</span><br><span class="line">    plt.plot(x, m * x + b)</span><br><span class="line">    plt.ylim(-5, 5)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">interactive_plot = interactive(f, m=(-2.0, 2.0), b=(-3, 3, 0.5))     </span><br><span class="line"><span class="comment"># m代表范围</span></span><br><span class="line">output = interactive_plot.children[-1]</span><br><span class="line">output.layout.height = <span class="string">'350px'</span></span><br><span class="line">interactive_plot</span><br></pre></td></tr></table></figure></li><li><p><a href="https://ipython-books.github.io/33-mastering-widgets-in-the-jupyter-notebook/" target="_blank" rel="noopener">多个选框，包括颜色、线宽、grid等</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@widgets.interact_manual(</span><br><span class="line">    color=[<span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'green'</span>], lw=(1., 10.))</span><br><span class="line">def plot(freq=1., color=<span class="string">'blue'</span>, lw=2, grid=True):</span><br><span class="line">    t = np.linspace(-1., +1., 1000)</span><br><span class="line">    fig, ax = plt.subplots(1, 1, figsize=(8, 6))</span><br><span class="line">    ax.plot(t, np.sin(2 * np.pi * freq * t),</span><br><span class="line">            lw=lw, color=color)</span><br><span class="line">    ax.grid(grid)</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://blog.csdn.net/sinat_26917383/article/details/84345407" target="_blank" rel="noopener">Jupyter notebook最简原型界面设计 - ipywidgets与lineup_widget</a></li><li><a href="https://github.com/jupyter-widgets/ipywidgets" target="_blank" rel="noopener">github官网</a></li><li><a href="https://www.zhihu.com/question/59392251" target="_blank" rel="noopener">知乎展示</a></li></ul><hr><h2 id="qgrid"><a href="#qgrid" class="headerlink" title="qgrid"></a>qgrid</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>主要针对的是<strong>pandas的dataframe</strong>，可以通过直观的<strong>滚动</strong>、<strong>排序</strong>和<strong>过滤</strong>控件来探索DataFrame，以及通过双击单元格来<strong>编辑</strong>DataFrame。</p><hr><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用conda安装</span></span><br><span class="line">conda install qgrid</span><br></pre></td></tr></table></figure><p>安装之后在python中调用发现<code>ModuleNotFoundError: No module named &#39;qgrid&#39;</code>，然后使用pip重新安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install qgrid</span><br></pre></td></tr></table></figure><p></p><p>然后调用发现<code>AttributeError: module &#39;numpy&#39; has no attribute &#39;__version__&#39;</code>，搜索得知是numpy的问题，重新安装或者升级numpy：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip numpy</span><br></pre></td></tr></table></figure><p></p><p>设置在nbextension中使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jupyter nbextension <span class="built_in">enable</span> --py --sys-prefix qgrid</span><br><span class="line">  Enabling notebook extension qgrid/extension...</span><br><span class="line">        - Validating: OK</span><br></pre></td></tr></table></figure><p></p><p>配置完成之后可以尝试如下示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import qgrid</span><br><span class="line">randn = np.random.randn</span><br><span class="line">df_types = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'A'</span> : pd.Series([<span class="string">'2013-01-01'</span>, <span class="string">'2013-01-02'</span>, <span class="string">'2013-01-03'</span>, <span class="string">'2013-01-04'</span>,</span><br><span class="line">               <span class="string">'2013-01-05'</span>, <span class="string">'2013-01-06'</span>, <span class="string">'2013-01-07'</span>, <span class="string">'2013-01-08'</span>, <span class="string">'2013-01-09'</span>],index=list(range(9)),dtype=<span class="string">'datetime64[ns]'</span>),</span><br><span class="line">    <span class="string">'B'</span> : pd.Series(randn(9),index=list(range(9)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">    <span class="string">'C'</span> : pd.Categorical([<span class="string">"washington"</span>, <span class="string">"adams"</span>, <span class="string">"washington"</span>, <span class="string">"madison"</span>, <span class="string">"lincoln"</span>,<span class="string">"jefferson"</span>, <span class="string">"hamilton"</span>, <span class="string">"roosevelt"</span>, <span class="string">"kennedy"</span>]),</span><br><span class="line">    <span class="string">'D'</span> : [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"buzz"</span>, <span class="string">"bippity"</span>,<span class="string">"boppity"</span>, <span class="string">"foo"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"zoo"</span>] &#125;)</span><br><span class="line">df_types[<span class="string">'E'</span>] = df_types[<span class="string">'D'</span>] == <span class="string">'foo'</span></span><br><span class="line">qgrid_widget = qgrid.show_grid(df_types, show_toolbar=True)</span><br><span class="line">qgrid_widget</span><br></pre></td></tr></table></figure><p></p><p>如果没有显示可以刷新jupyter。</p><hr><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>默认情况下，jupyter的dataframe不会显示全部的dataframe，使用qgrid之后可以显示全部的数据，并且可以设置显示的数目，防止占据太大的空间，具体的<a href="https://hub.mybinder.org/user/quantopian-qgrid-notebooks-odradvv1/notebooks/index.ipynb" target="_blank" rel="noopener">各种示例集合</a>。</p><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/quantopian/qgrid" target="_blank" rel="noopener">官方github</a></li><li><a href="https://qgrid.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a></li></ul><hr><h2 id="输出矢量图"><a href="#输出矢量图" class="headerlink" title="输出矢量图"></a>输出矢量图</h2><p>默认情况下jupyter会得到png，看着非常不清晰，为了克服这种情况，可以使用如下配置，将输出设置为svg格式的矢量图(放大不会使其模糊)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jupyter中输出矢量图</span></span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = <span class="string">'svg'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为矢量图</span></span><br><span class="line">plt.savefig(<span class="string">'tmp.pdf'</span>, bbox_inches=<span class="string">'tight'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="管理conda环境"><a href="#管理conda环境" class="headerlink" title="管理conda环境"></a>管理conda环境</h2><p>使用的包为nb_conda，官方的介绍：Provides Conda environment and package access extension from within Jupyter.</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul><li>将使用conda创建的环境与Jupyter Notebook相关联，便于在Jupyter Notebook中使用不同的虚拟环境</li><li>可以在线管理(增加、删除、复制)虚拟环境以及安装package</li></ul><hr><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure><hr><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用界面和简要功能：<img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/nb_conda.png" alt="nb_conda.png"></p><hr><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>使用下面的命令卸载nb_conda包：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canda remove nb_conda</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/33105153" target="_blank" rel="noopener">Jupyter Notebook介绍、安装及使用教程</a></li></ul><hr><h2 id="Markdown在文中设置链接并定位"><a href="#Markdown在文中设置链接并定位" class="headerlink" title="Markdown在文中设置链接并定位"></a>Markdown在文中设置链接并定位</h2><p>在使用Markdown编辑文档时，难免会遇到<strong>需要在文中设定链接跳转查看</strong>，定位在文档中的其他位置便于查看，因为Markdown可以完美的兼容html语法，因此这种功能可以通过html语法当中“a标签”的索引用法来实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在跳转部位和和插入链接一样的形式</span></span><br><span class="line"><span class="comment"># 不过链接修改为锚定的形式</span></span><br><span class="line">[添加链接的正文](<span class="comment">#自定义索引词)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在需要跳转到的位置添加a标签</span></span><br><span class="line"><span class="comment"># id和前面的锚定#后面的相同</span></span><br><span class="line">&lt;a id=自定义索引词&gt;跳转提示&lt;/a&gt;</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="加载指定网页源代码或本地python文件"><a href="#加载指定网页源代码或本地python文件" class="headerlink" title="加载指定网页源代码或本地python文件"></a>加载指定网页源代码或本地python文件</h2><h3 id="加载网页源代码"><a href="#加载网页源代码" class="headerlink" title="加载网页源代码"></a>加载网页源代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load URL</span><br></pre></td></tr></table></figure><hr><h3 id="加载本地python文件"><a href="#加载本地python文件" class="headerlink" title="加载本地python文件"></a>加载本地python文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load Python文件的绝对路径</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Python文件的后缀为<code>.py</code></li><li><code>%load</code>后跟的是Python文件的<strong>绝对路径</strong></li><li>输入命令后，<strong>可以按CTRL 回车来执行命令</strong><ul><li><strong>第一次执行</strong>，是将本地的Python文件内容<strong>加载到单元格内</strong>。此时，Jupyter Notebook会自动将<code>%load</code>命令注释掉（即在前边加井号<code>#</code>），以便在执行已加载的文件代码时不重复执行该命令；</li><li><strong>第二次执行</strong>，则是执行已加载文件的代码</li></ul></li></ul><hr><h2 id="直接运行本地python文件"><a href="#直接运行本地python文件" class="headerlink" title="直接运行本地python文件"></a>直接运行本地python文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%run Python文件的绝对路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用shell命令的形式</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">!python3 Python文件的绝对路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">!python Python文件的绝对路径</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.zhihu.com/question/59392251" target="_blank" rel="noopener">如何优雅地使用 Jupyter？</a></li><li><a href="http://clarkchen.github.io/2017/06/05/Jupyter%E5%8F%A6%E7%B1%BB%E5%85%A8%E5%AE%B6%E6%A1%B6/" target="_blank" rel="noopener">Jupyter DashBoards 另类全家桶</a></li><li><a href="https://zhuanlan.zhihu.com/p/33105153" target="_blank" rel="noopener">Jupyter Notebook介绍、安装及使用教程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录关于jupyter的一下小工具，包括&lt;code&gt;ipywidgets&lt;/code&gt;、&lt;code&gt;qgrid&lt;/code&gt;、&lt;code&gt;输出矢量图&lt;/code&gt;、&lt;code&gt;管理conda环境&lt;/code&gt;、&lt;code&gt;markdown设置锚定&lt;/code&gt;、&lt;code&gt;加载网页源代码或者本地python程序&lt;/code&gt;、&lt;code&gt;运行本地python程序&lt;/code&gt;等.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Python/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pv-命令执行的进度信息</title>
    <link href="http://showteeth.tech/posts/6226.html"/>
    <id>http://showteeth.tech/posts/6226.html</id>
    <published>2019-05-03T15:52:49.000Z</published>
    <updated>2019-05-04T02:41:20.401Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中用于<strong>显示命令执行进度信息的命令pv</strong>，这个命令<strong>需要安装</strong>；该<strong>命令主要起到管道的作用，标准输入或文件流入，然后流出到标准输出，在这个过程中统计进度信息</strong>；主要学习了<code>-L</code>、<code>-n</code>、<code>匀速打印字符</code>、<code>结合gzip</code>、<code>结合grep</code>、<code>结合wc</code>等。</p></div><a id="more"></a><h2 id="pv命令简介"><a href="#pv命令简介" class="headerlink" title="pv命令简介"></a>pv命令简介</h2><p><code>pv</code>命令 <code>Pipe Viewer</code> 的简称，由Andrew Wood 开发，其作用是<strong>通过管道显示数据处理进度的信息</strong>，这些信息包括<strong>已经耗费的时间</strong>、<strong>完成的百分比(通过进度条显示)</strong>、<strong>当前的速度</strong>、<strong>全部传输的数据</strong>以及<strong>估计剩余的时间</strong>等。</p><p>为了实现上述功能<strong>需要将该命令插入到两个进程之间的管道中</strong>，并佐以合适的选项，<mark>它的<strong>标准输入</strong>经由它<strong>到达其标准输出</strong>, 同时<strong>进度信息会显示在标准错误上</strong></mark>，<code>pv</code>依次<strong>拷贝FILE中的数据到其标准输出</strong>( <code>-</code> 表示标准输入)，如果FILE未提供仅仅拷贝标准输入。<mark><strong>该命令行的行为与cat类似</strong></mark>。</p><hr><h2 id="pv安装"><a href="#pv安装" class="headerlink" title="pv安装"></a>pv安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在root目录下使用yum安装</span></span><br><span class="line">yum install pv</span><br></pre></td></tr></table></figure><hr><h2 id="pv命令格式"><a href="#pv命令格式" class="headerlink" title="pv命令格式"></a>pv命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方</span></span><br><span class="line">Usage: </span><br><span class="line">  pv [OPTION] [FILE]...</span><br><span class="line">Concatenate FILE(s), or standard input, to standard output,</span><br><span class="line">with monitoring.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line"><span class="comment"># 查看文件，并显示进度</span></span><br><span class="line">pv file</span><br><span class="line">pv [options] file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件进度</span></span><br><span class="line">pv file &gt; output_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看command进行的进度</span></span><br><span class="line">pv [options] | <span class="built_in">command</span></span><br><span class="line">pv [options] | <span class="built_in">command</span> &gt; output_filename</span><br><span class="line">command1| pv | command2</span><br></pre></td></tr></table></figure><hr><h2 id="pv命令参数"><a href="#pv命令参数" class="headerlink" title="pv命令参数"></a>pv命令参数</h2><h3 id="信息显示开关"><a href="#信息显示开关" class="headerlink" title="信息显示开关"></a>信息显示开关</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-p</code></td><td><code>--progress</code></td><td>显示进度条</td></tr><tr><td><code>-t</code></td><td><code>--timer</code></td><td>打开计时器，这将显示pv的总耗用时间</td></tr><tr><td><code>-e</code></td><td><code>--eta</code></td><td>预测完成需要多长时间</td></tr><tr><td><code>-r</code></td><td><code>--rate</code></td><td>显示当前的数据传输速率</td></tr><tr><td><code>-a</code></td><td><code>--average-rate</code></td><td>显示当前的平均数据传输速率</td></tr><tr><td><code>-b</code></td><td><code>--bytes</code></td><td>显示到目前为止传输的数据总量</td></tr><tr><td><code>-F</code></td><td><code>--format FORMAT</code></td><td>设置输出样式</td></tr><tr><td><code>-n</code></td><td><code>--numeric</code></td><td>每行显示一个数字百分比(不带百分号)，用来替代通常的可视进度条，注意，如果使用-n，则不需要-f</td></tr><tr><td><code>-q</code></td><td><code>--quiet</code></td><td>不显示任何传输信息</td></tr></table><hr><h3 id="输出修饰符"><a href="#输出修饰符" class="headerlink" title="输出修饰符"></a>输出修饰符</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-W</code></td><td><code>--wait</code></td><td>等到第一个字节被转移后，才显示进展信息或计算任何ETAs</td></tr><tr><td><code>-s</code></td><td><code>--size SIZE</code></td><td>假设在计算百分比和ETAs时要传输的数据总量是SIZE字节</td></tr><tr><td><code>-l</code></td><td><code>--line-mode</code></td><td>不是计数字节，而是计数行(换行字符)</td></tr><tr><td><code>-i</code></td><td><code>--interval SEC</code></td><td>隔多久更新一次，默认设置是每秒钟更新一次，注意，这可以是小数，比如0.1</td></tr><tr><td><code>-w</code></td><td><code>--width WIDTH</code></td><td>设置终端宽</td></tr><tr><td><code>-H</code></td><td><code>--height HEIGHT</code></td><td>设置终端行高</td></tr><tr><td><code>-N</code></td><td><code>--name NAME</code></td><td>使用NAME作为输出信息的前缀</td></tr><tr><td><code>-f</code></td><td><code>--force</code></td><td>强制输出</td></tr><tr><td><code>-c</code></td><td><code>--cursor</code></td><td>使用游标定位转义序列而不是仅使用回车符</td></tr></table><hr><h3 id="数据传输修饰符"><a href="#数据传输修饰符" class="headerlink" title="数据传输修饰符"></a>数据传输修饰符</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-L</code></td><td><code>--rate-limit RATE</code></td><td>设置每秒传输最大字节数</td></tr><tr><td><code>-B</code></td><td><code>--buffer-size BYTES</code></td><td>设置传输缓冲区大小</td></tr><tr><td><code>-E</code></td><td><code>--skip-errors</code></td><td>skip read errors in input</td></tr><tr><td><code>-S</code></td><td><code>--stop-at-size</code></td><td>传输指定的大小后停止传输</td></tr><tr><td><code>-R</code></td><td><code>--remote PID</code></td><td>如果PID是已经在运行的pv的一个实例，那么-R PID将使该实例可以接收新的参数设置</td></tr></table><hr><h2 id="pv退出状态"><a href="#pv退出状态" class="headerlink" title="pv退出状态"></a>pv退出状态</h2><table><tr><th width="10%">退出状态</th><th width="90%">说明</th></tr><tr><td><code>0</code></td><td>没有问题</td></tr><tr><td><code>1</code></td><td><code>-R</code>或<code>-P</code>选项存在问题</td></tr><tr><td><code>2</code></td><td>无法访问</td></tr><tr><td><code>4</code></td><td>输入文件与输出文件相同</td></tr><tr><td><code>8</code></td><td>关闭文件或移动到下一个文件时发生内部错误</td></tr><tr><td><code>16</code></td><td>一个或多个输入文件传输数据时出错</td></tr><tr><td><code>32</code></td><td>捕获的信号导致提前退出</td></tr><tr><td><code>64</code></td><td>内存分配失败</td></tr></table><hr><h2 id="pv使用实例"><a href="#pv使用实例" class="headerlink" title="pv使用实例"></a>pv使用实例</h2><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><p>实际上pv命令就是相当于把文件打开，然后输出到标准输出，进入后面的管道：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pv B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart &gt;../rsync/test.txt</span><br><span class="line">  258MiB 0:00:00 [1.13GiB/s] [=======================================================================================================================&gt;] 100%</span><br></pre></td></tr></table></figure><p></p><p><strong>默认情况下</strong>：</p><ul><li><code>-p --progress</code>：带进度条的完成比例</li><li><code>-t --timer</code>：已消耗时间</li><li><code>-e --eta</code>：预估剩余时间</li><li><code>-r --rate</code>：已传输总量</li><li><code>-b --bytes</code>：数据量总量</li><li><code>-W --wait</code>：等到第一个字节被转移后，才显示进展信息或计算任何ETAs</li></ul><hr><h3 id="L-传输限速"><a href="#L-传输限速" class="headerlink" title="-L-传输限速"></a>-L-传输限速</h3><p>上面默认的传输速率是<code>1.13GiB/s</code>，很快，这里将其限制为<code>1m/s</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pv -L 1m B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart &gt;../rsync/test.txt</span><br><span class="line">  20MiB 0:00:20 [1.01MiB/s] [=======&gt;                                                                                                                 ]  7% ETA 0:03:58</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-每行显示一个数字百分比"><a href="#n-每行显示一个数字百分比" class="headerlink" title="-n-每行显示一个数字百分比"></a>-n-每行显示一个数字百分比</h3><p>默认情况下会显示传输进度条，如果不想显示传输进度条可以使用<code>-n</code>参数来输出传输的整数百分比，不带百分号的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pv -n -L 1m B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart &gt;../rsync/test.txt</span><br><span class="line">  0</span><br><span class="line">  0</span><br><span class="line">  1</span><br><span class="line">  1</span><br><span class="line">  1</span><br><span class="line">  2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="匀速打印字符"><a href="#匀速打印字符" class="headerlink" title="匀速打印字符"></a>匀速打印字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置每秒打印5个字符，而不是一次全部显示</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Tecmint[dot]com is a community of Linux Nerds and Geeks"</span> | pv -qL 5</span><br><span class="line">  Tecmint[dot]com is a community of Linux Nerds and Geeks</span><br></pre></td></tr></table></figure><hr><h3 id="结合gzip"><a href="#结合gzip" class="headerlink" title="结合gzip"></a>结合gzip</h3><p>显示压缩进度：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pv B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart |gzip - &gt;test.log</span><br><span class="line">  127MiB 0:00:06 [21.6MiB/s] [==========================================================&gt;                                                              ] 49% ETA 0:00:06</span><br></pre></td></tr></table></figure><p></p><p><strong>使用管道的好处在于</strong>：<strong>不用指定参数来保留原始文件</strong>，因为处理的是标准输入而不是原始文件</p><hr><h3 id="结合grep"><a href="#结合grep" class="headerlink" title="结合grep"></a>结合grep</h3><p>查找内容时，对于较大的文件，可能会比较慢，并且没有任何输出也不知道进行了多少，加上pv命令可以显示查找进度：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">samtools view LJ_mt_677_1_paired.bam |pv |grep <span class="string">"ST-E00243:634:HYCT5CCXY:3:2117:20202:10996"</span></span><br><span class="line">  ST-E00243:634:HYCT5CCXY:3:2117:20202:10996..........YS:i:-16YT:Z:CP</span><br><span class="line">  ST-E00243:634:HYCT5CCXY:3:2117:20202:10996..........YS:i:0YT:Z:CP</span><br><span class="line">  3.5GiB 0:00:44 [79.7MiB/s] [                                                                                                                        &lt;=&gt;              ]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="结合wc"><a href="#结合wc" class="headerlink" title="结合wc"></a>结合wc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示统计行数的进度</span></span><br><span class="line">samtools view LJ_mt_677_1_paired.bam |pv |wc -l</span><br><span class="line">  3.5GiB 0:00:44 [79.9MiB/s] [                                                                                                                        &lt;=&gt;              ]</span><br><span class="line">  8981682</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.rootopen.com/command/bash/pv" target="_blank" rel="noopener">pv 通过管道监控数据的进度</a></li><li><a href="https://linux.cn/article-6734-1.html" target="_blank" rel="noopener">如何使用 pv 命令监控 linux 命令的执行进度</a></li><li><a href="https://juejin.im/entry/5862a9491b69e675fcd8b68d" target="_blank" rel="noopener">Linux 命令 PV 显示当前在命令行执行的进度信息，管道查看器</a></li><li><a href="https://www.jianshu.com/p/64becdd8927c" target="_blank" rel="noopener">利用pv命令监视数据的处理进度</a></li><li><a href="http://blog.topspeedsnail.com/archives/2748" target="_blank" rel="noopener">Linux：使用pv命令显示执行进度</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中用于&lt;strong&gt;显示命令执行进度信息的命令pv&lt;/strong&gt;，这个命令&lt;strong&gt;需要安装&lt;/strong&gt;；该&lt;strong&gt;命令主要起到管道的作用，标准输入或文件流入，然后流出到标准输出，在这个过程中统计进度信息&lt;/strong&gt;；主要学习了&lt;code&gt;-L&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;匀速打印字符&lt;/code&gt;、&lt;code&gt;结合gzip&lt;/code&gt;、&lt;code&gt;结合grep&lt;/code&gt;、&lt;code&gt;结合wc&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>获取时间日期格式和延时</title>
    <link href="http://showteeth.tech/posts/52406.html"/>
    <id>http://showteeth.tech/posts/52406.html</id>
    <published>2019-05-03T08:50:23.000Z</published>
    <updated>2019-05-03T12:06:10.688Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中用于<strong>获取时间日期格式和延时的两个命令date和sleep</strong>；主要学习了<strong>date</strong>命令中的<code>-d</code>、<code>-u</code>、<code>-s</code>、<code>自定义显示日期和时间</code>、<code>-n</code>，<strong>sleep</strong>命令中的<code>常规用法</code>、<code>不同时间尺度的混用</code>、<code>浮点型时间设置</code>以及<code>usleep进行微秒级休眠</code>。</p></div><a id="more"></a><h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><h3 id="date命令简介"><a href="#date命令简介" class="headerlink" title="date命令简介"></a>date命令简介</h3><p><code>date</code>用于<strong>获取和设置操作系统的时间和日期</strong>，同时也能<strong>自定义日期和时间的显示格式</strong>。</p><hr><h3 id="date命令格式"><a href="#date命令格式" class="headerlink" title="date命令格式"></a>date命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义格式</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line"><span class="comment"># 使用已有的格式</span></span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">Display the current time <span class="keyword">in</span> the given FORMAT, or <span class="built_in">set</span> the system date.</span><br></pre></td></tr></table></figure><hr><h3 id="date命令参数"><a href="#date命令参数" class="headerlink" title="date命令参数"></a>date命令参数</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-d</code></td><td><code>--date=STRING</code></td><td>显示字符串所指的日期与时间，字符串前后必须加上双引号<br></td></tr><tr><td><code>-f</code></td><td><code>--file=DATEFILE</code></td><td>和-d类似，一次读取DATEFILE的一行</td></tr><tr><td><code>-s</code></td><td><code>--set=STRING</code></td><td>根据字符串来设置日期与时间，字符串前后必须加上双引号</td></tr><tr><td><code>-u</code></td><td><code>--utc、--universal</code></td><td>显示或设置世界标准时间</td></tr><tr><td><code>-r</code></td><td><code>--reference=FILE</code></td><td>显示文件的最后修改时间</td></tr><tr><td><code>-R</code></td><td><code>--rfc-2822</code></td><td>输出RFC 2822格式日期或时间，格式为：星期, 日-月-年, 小时:分钟:秒 时区</td></tr><tr><td><code>-I[TIMESPEC]</code></td><td><code>--iso-8601[=TIMESPEC]</code></td><td>显示ISO 8601格式的日期或时间</td></tr></table><hr><h3 id="date自定义格式字段"><a href="#date自定义格式字段" class="headerlink" title="date自定义格式字段"></a>date自定义格式字段</h3><div align="center"><table><tbody><tr><th width="10%"><p>&nbsp;</p></th><th width="10%"><p align="center">符号</p></th><th width="20%"><p align="center">意义</p></th><th width="60%"><p align="center">描述</p></th></tr><tr><td rowspan="2"><p align="center">年</p></td><td><p>%y</p></td><td><p>年(后两位)</p></td><td><p>last two digits of year (00..99)</p></td></tr><tr><td><p><strong><span style="color:red">%Y</span></strong></p></td><td><p><strong><span style="color:red">年</span></strong></p></td><td><p>year</p></td></tr><tr><td rowspan="3"><p align="center">月</p></td><td><p><span style="color:red">%m</span></p></td><td><p><span style="color:red">月</span></p></td><td><p>month (01..12)</p></td></tr><tr><td><p><strong><span style="color:red">%h、%b</span></strong></p></td><td><p><strong><span style="color:red">月的简称</span></strong></p></td><td><p>month (Jan..Dec)</p></td></tr><tr><td><p><strong><span style="color:red">%B</span></strong></p></td><td><p><strong><span style="color:red">月的全称</span></strong></p></td><td><p>month (January..December)</p></td></tr><tr><td rowspan="6"><p align="center">&nbsp;</p><p align="center">日</p></td><td><p>%j</p></td><td><p>年中天</p></td><td><p>day of year (001..366)</p></td></tr><tr><td><p><strong><span style="color:red">%d</span></strong></p></td><td><p><strong><span style="color:red">月中天</span></strong></p></td><td><p>day of month (如01)</p></td></tr><tr><td><p>%w</p></td><td><p>周中天</p></td><td><p>day of week (0..6); 0 is Sunday</p></td></tr><tr><td><p>%u</p></td><td><p>周中天</p></td><td><p>day of week (1..7); 1 is Monday</p></td></tr><tr><td><p>%a</p></td><td><p>周中天,星期的简称</p></td><td><p>day of week (Sun..Sat)</p></td></tr><tr><td><p>%A</p></td><td><p>周中天,星期的全称</p></td><td><p>day of week (Sunday..Saturday)</p></td></tr><tr><td rowspan="2"><p align="center">周</p></td><td><p>%U</p></td><td><p>年中周(00-53)</p></td><td><p>week number of year with Sunday as first day</p></td></tr><tr><td><p>%W</p></td><td><p>年中周(00-53)</p></td><td><p>week number of year with Monday as first day</p></td></tr><tr><td rowspan="4"><p align="center">时</p></td><td><p><strong><span style="color:red">%H</span></strong></p></td><td><p><strong><span style="color:red">时(24时制)</span></strong></p></td><td><p>hour (00..23)</p></td></tr><tr><td><p>%I</p></td><td><p>时(12时制)</p></td><td><p>hour (01..12)</p></td></tr><tr><td><p>%k</p></td><td><p>时(24时制)</p></td><td><p>hour (0..23)</p></td></tr><tr><td><p>%l</p></td><td><p>时(12时制)</p></td><td><p>hour (1..12)</p></td></tr><tr><td><p align="center">分</p></td><td><p><strong><span style="color:red">%M</span></strong></p></td><td><p><strong><span style="color:red">分</span></strong></p></td><td><p>minute (00..59)</p></td></tr><tr><td rowspan="3"><p align="center">秒</p></td><td><p><strong><span style="color:red">%S</span></strong></p></td><td><p><strong><span style="color:red">秒</span></strong></p></td><td><p>second (00..60)</p></td></tr><tr><td><p><strong><span style="color:red">%N</span></strong></p></td><td><p><strong><span style="color:red">纳秒</span></strong></p></td><td><p>ns of current minute</p></td></tr><tr><td><p><strong><span style="color:red">%s</span></strong></p></td><td><p><strong><span style="color:red">秒</span></strong></p></td><td><p>从1970-01-01到目前时间的秒数总数</p></td></tr><tr><td><p align="center">上午</p><p align="center">下午</p></td><td><p><strong><span style="color:red">%p</span></strong></p></td><td><p><strong><span style="color:red">显示出AM或PM</span></strong></p></td><td><p>显示出AM或PM</p></td></tr><tr><td rowspan="4"><p align="center">完整</p><p align="center">格式</p></td><td><p><strong><span style="color:red">%T</span></strong></p></td><td><p><strong><span style="color:red">完整时间</span></strong></p></td><td><p>time; same as %H:%M:%S</p></td></tr><tr><td><p>%r</p></td><td><p>完整时间，12小时制</p></td><td><p>time; same as hh:mm:ss %p</p></td></tr><tr><td><p><strong><span style="color:red">%x、%D</span></strong></p></td><td><p><strong><span style="color:red">日期完整格式</span></strong></p></td><td><p>date; same as %m/%d/%y</p></td></tr><tr><td><p><strong><span style="color:red">%F</span></strong></p></td><td><p><strong><span style="color:red">日期完整格式</span></strong></p></td><td><p>date; same as %Y-%m-%d</p></td></tr><tr><td><p align="center">日期和时间</p></td><td><p><strong><span style="color:red">%c</span></strong></p></td><td><p><strong><span style="color:red">显示日期和时间</span></strong></p></td><td><p>Tue Nov 20 14:12:58 2012</p></td></tr><tr><td><p align="center">时区</p></td><td><p><strong><span style="color:red">%Z</span></strong></p></td><td><p><strong><span style="color:red">显示时区，日期域</span></strong></p></td><td><p>CST、EST</p></td></tr><tr><td rowspan="2"><p align="center">特殊</p><p align="center">格式</p></td><td><p>%n</p></td><td><p>换行</p></td><td><p>a newline</p></td></tr><tr><td><p>%t</p></td><td><p>tab键</p></td><td><p>a tab</p></td></tr></tbody></table></div><hr><h3 id="date使用实例"><a href="#date使用实例" class="headerlink" title="date使用实例"></a>date使用实例</h3><h4 id="u-显示世界标准时间"><a href="#u-显示世界标准时间" class="headerlink" title="-u-显示世界标准时间"></a>-u-显示世界标准时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -u</span><br><span class="line">  Fri May  3 23:15:35 UTC 2019</span><br></pre></td></tr></table></figure><hr><h4 id="d-显示指定的日期和时间"><a href="#d-显示指定的日期和时间" class="headerlink" title="-d-显示指定的日期和时间"></a>-d-显示指定的日期和时间</h4><p><code>-d</code>参数可以用来描述获取什么时候的时间，描述的方式非常开放，<strong>但不能使用”now”关键字</strong>，其他的如<strong>3天前”3 days ago”</strong>，<strong>3天后”3 days”</strong>，<strong>昨天”yesterday”</strong>，<strong>下周一”next Monday”</strong>等等：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示一天之前的此刻时间</span></span><br><span class="line">date -d <span class="string">"1 day ago"</span></span><br><span class="line">  Thu May  2 18:45:08 EDT 2019</span><br><span class="line"><span class="comment"># 显示一天之后的此刻时间</span></span><br><span class="line">date -d <span class="string">"1 day"</span></span><br><span class="line">  Sat May  4 18:47:44 EDT 2019</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2秒之后的时间</span></span><br><span class="line">date &amp;&amp; date -d <span class="string">"2 seconds"</span></span><br><span class="line">  Fri May  3 18:46:43 EDT 2019</span><br><span class="line">  Fri May  3 18:46:45 EDT 2019</span><br><span class="line"><span class="comment"># 2秒之前的时间</span></span><br><span class="line">date &amp;&amp; date -d <span class="string">"2 seconds ago"</span></span><br><span class="line">  Fri May  3 18:47:16 EDT 2019</span><br><span class="line">  Fri May  3 18:47:14 EDT 2019</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定时间之前的时间</span></span><br><span class="line">date -d <span class="string">"2018-02-19 3 days ago"</span></span><br><span class="line">  Fri Feb 16 00:00:00 EST 2018</span><br><span class="line">date -d <span class="string">"2018-02-19 - 3 days"</span></span><br><span class="line">  Fri Feb 16 00:00:00 EST 2018</span><br><span class="line"><span class="comment"># 指定时间之后的时间</span></span><br><span class="line">date -d <span class="string">"2018-02-19  3 days"</span></span><br><span class="line">  Thu Feb 22 00:00:00 EST 2018</span><br><span class="line">date -d <span class="string">"2018-02-19 + 3 days"</span></span><br><span class="line">  Thu Feb 22 00:00:00 EST 2018</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="s-设置时间和日期"><a href="#s-设置时间和日期" class="headerlink" title="-s-设置时间和日期"></a>-s-设置时间和日期</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置当前时间，只有root权限才能设置，其他只能查看</span></span><br><span class="line">date -s          </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置成20120523，这样会把具体时间设置成空00:00:00</span></span><br><span class="line">date -s 20120523   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置具体时间，不会对日期做更改</span></span><br><span class="line">date -s 01:01:01           </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样可以设置全部时间</span></span><br><span class="line">date -s <span class="string">"01:01:01 2012-05-23"</span>  </span><br><span class="line">date -s <span class="string">"01:01:01 20120523"</span>    </span><br><span class="line">date -s <span class="string">"2012-05-23 01:01:01"</span>  </span><br><span class="line">date -s <span class="string">"20120523 01:01:01"</span></span><br></pre></td></tr></table></figure><hr><h4 id="自定义输出格式"><a href="#自定义输出格式" class="headerlink" title="自定义输出格式"></a>自定义输出格式</h4><p><code>date [OPTION] [+format]</code>，其中<code>+</code>表示<strong>从前面的时间中获取其中的格式部分</strong>，如<code>date -d &quot;yesterday&quot; +&quot;%Y&quot;</code>获取的是昨天的年份部分：</p><h5 id="结合-d"><a href="#结合-d" class="headerlink" title="结合-d"></a>结合-d</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %F:%Y-%m-%d</span></span><br><span class="line">date -d <span class="string">"3 days ago"</span> +%F</span><br><span class="line">  2019-04-30</span><br><span class="line"></span><br><span class="line"><span class="comment"># %c：日期和时间</span></span><br><span class="line"><span class="comment"># 其中的时间是%r</span></span><br><span class="line">date -d <span class="string">"3 days ago"</span> +%c</span><br><span class="line">  Tue 30 Apr 2019 07:02:03 PM EDT</span><br><span class="line"></span><br><span class="line"><span class="comment"># %r：显示时间，12小时制（hh:mm:ss %p）</span></span><br><span class="line">date -d <span class="string">"3 days ago"</span> +%r</span><br><span class="line">  07:03:07 PM</span><br></pre></td></tr></table></figure><hr><h5 id="n-换行显示"><a href="#n-换行显示" class="headerlink" title="-n-换行显示"></a>-n-换行显示</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示完时间之后，日期换行显示</span></span><br><span class="line">date -d <span class="string">"2018-02-19  3 days"</span> +<span class="string">"%T%n%D"</span></span><br><span class="line">  00:00:00</span><br><span class="line">  02/22/18</span><br></pre></td></tr></table></figure><hr><h5 id="直接定义"><a href="#直接定义" class="headerlink" title="直接定义"></a>直接定义</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">"%F %T"</span></span><br><span class="line">  2019-05-03 19:11:15</span><br><span class="line"></span><br><span class="line">date +<span class="string">"%Y-%m-%d %H:%M:%S"</span></span><br><span class="line">  2019-05-03 19:10:58</span><br></pre></td></tr></table></figure><hr><h5 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h5><p>给定一个日期，计算该日期所在星期的星期一是几月几号，例如，2018-05-12是星期六，那么星期一是2018-05-07:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">src_date=<span class="string">"2018-05-12"</span></span><br><span class="line"><span class="comment"># 先判断给定的日期是星期几</span></span><br><span class="line">src_weekday=`date -d <span class="variable">$src_date</span> +%w`</span><br><span class="line"><span class="comment"># src_weekday=6</span></span><br><span class="line">Mon_date=`date -d <span class="string">"<span class="variable">$src_date</span> - <span class="variable">$(( src_weekday - 1 )</span>) days"</span> +%F`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$Mon_date</span></span><br><span class="line"><span class="comment"># 2018-05-07</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="sleep命令"><a href="#sleep命令" class="headerlink" title="sleep命令"></a>sleep命令</h2><h3 id="sleep命令简介"><a href="#sleep命令简介" class="headerlink" title="sleep命令简介"></a>sleep命令简介</h3><p><code>sleep</code>命令可以用来<strong>将目前动作延迟一段时间</strong>，默认情况下，<code>sleep</code> 的进程是<strong>不占用 CPU 时间的</strong>.</p><hr><h3 id="sleep命令格式"><a href="#sleep命令格式" class="headerlink" title="sleep命令格式"></a>sleep命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: sleep NUMBER[SUFFIX]...</span><br><span class="line">  or:  sleep OPTION</span><br></pre></td></tr></table></figure><p><strong>suffix</strong>:</p><ul><li><code>s</code>：表示秒</li><li><code>m</code>：表示分钟</li><li><code>h</code>：表示小时</li><li><code>d</code>：表示天</li></ul><div class="note info"><ul><li><strong>最大支持的休眠单位为天</strong>，如果需要更大的单位如月，需要用天转化</li><li><strong>NUMBER可以是浮点型的数值</strong>，例如0.003s、0.1m表示的是6s</li></ul></div><h3 id="sleep使用实例"><a href="#sleep使用实例" class="headerlink" title="sleep使用实例"></a>sleep使用实例</h3><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠1s</span></span><br><span class="line">date ; sleep 1s ;date</span><br><span class="line">  Fri May  3 20:35:43 EDT 2019</span><br><span class="line">  Fri May  3 20:35:44 EDT 2019</span><br><span class="line"></span><br><span class="line"><span class="comment"># 休眠1分钟</span></span><br><span class="line">date ; sleep 1m ;date</span><br><span class="line">  Fri May  3 20:36:19 EDT 2019</span><br><span class="line">  Fri May  3 20:37:19 EDT 2019</span><br></pre></td></tr></table></figure><hr><h4 id="时间混用"><a href="#时间混用" class="headerlink" title="时间混用"></a>时间混用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠1分钟30s</span></span><br><span class="line">date ; sleep 1m 30s;date</span><br><span class="line">  Fri May  3 20:37:46 EDT 2019</span><br><span class="line">  Fri May  3 20:39:16 EDT 2019</span><br></pre></td></tr></table></figure><div class="note info"><p>不同的时间尺度连用时需要注意<strong>时间尺度之间一定要有空格隔开</strong></p></div><hr><h4 id="浮点型的时间"><a href="#浮点型的时间" class="headerlink" title="浮点型的时间"></a>浮点型的时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠半分钟</span></span><br><span class="line"><span class="comment"># 和30s的效果是相同的</span></span><br><span class="line">date ; sleep 0.5m;date</span><br><span class="line">  Fri May  3 20:41:24 EDT 2019</span><br><span class="line">  Fri May  3 20:41:54 EDT 2019</span><br></pre></td></tr></table></figure><hr><h4 id="usleep-微秒级的休眠命令"><a href="#usleep-微秒级的休眠命令" class="headerlink" title="usleep-微秒级的休眠命令"></a>usleep-微秒级的休眠命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠1000微秒，即1毫秒</span></span><br><span class="line">usleep 1000</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/date" target="_blank" rel="noopener">date命令</a></li><li><a href="https://www.cnblogs.com/peida/archive/2012/12/13/2815687.html" target="_blank" rel="noopener">每天一个linux命令（37）：date命令</a></li><li><a href="https://linux.cn/article-2406-1.html" target="_blank" rel="noopener">Linux date命令 - 显示和设置系统日期与时间</a></li><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7427262.html" target="_blank" rel="noopener">date、sleep和usleep命令</a></li><li><a href="http://c.biancheng.net/linux/sleep.html" target="_blank" rel="noopener">sleep命令_Linux sleep命令：让程序暂停或休眠一段时间</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中用于&lt;strong&gt;获取时间日期格式和延时的两个命令date和sleep&lt;/strong&gt;；主要学习了&lt;strong&gt;date&lt;/strong&gt;命令中的&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;自定义显示日期和时间&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;，&lt;strong&gt;sleep&lt;/strong&gt;命令中的&lt;code&gt;常规用法&lt;/code&gt;、&lt;code&gt;不同时间尺度的混用&lt;/code&gt;、&lt;code&gt;浮点型时间设置&lt;/code&gt;以及&lt;code&gt;usleep进行微秒级休眠&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>du-显示目录或文件大小</title>
    <link href="http://showteeth.tech/posts/30062.html"/>
    <id>http://showteeth.tech/posts/30062.html</id>
    <published>2019-05-03T03:42:50.000Z</published>
    <updated>2019-05-03T08:38:14.533Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中用于<strong>统计目录或文件大小的命令du</strong>，主要学习了：<code>-h</code>、<code>-S</code>、<code>-s</code>、<code>-c</code>、<code>-a</code>、<code>--exclude</code>、<code>--max-depth</code>、<code>结合sort命令</code>、<code>-t</code>、<code>关于单位名称</code>、<code>与ls输出结果的差别原因</code>。</p></div><a id="more"></a><h2 id="du命令简介"><a href="#du命令简介" class="headerlink" title="du命令简介"></a>du命令简介</h2><p><code>du</code> 命令，全称是 disk usage，用来展示文件或者文件夹磁盘使用量的统计信息.</p><hr><h1 id="du命令格式"><a href="#du命令格式" class="headerlink" title="du命令格式"></a>du命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: du [OPTION]... [FILE]...</span><br><span class="line">  or:  du [OPTION]... --files0-from=F</span><br><span class="line">Summarize disk usage of each FILE, recursively <span class="keyword">for</span> directories.</span><br></pre></td></tr></table></figure><hr><h2 id="du命令参数"><a href="#du命令参数" class="headerlink" title="du命令参数"></a>du命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-a</code></td><td><code>-all</code></td><td>显示目录中单个文件的大小，而不是笼统的显示目录大小<br></td></tr><tr><td><code>-b</code></td><td><code>--bytes</code></td><td>显示目录或文件大小时，以byte为单位</td></tr><tr><td><code>-c</code></td><td><code>--total</code></td><td>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</td></tr><tr><td><code>-s</code></td><td><code>--summarize</code></td><td>仅显示总计，只列出最后加总的值</td></tr><tr><td><code>-k</code></td><td></td><td>以KB(1024bytes)为单位输出</td></tr><tr><td><code>-m</code></td><td></td><td>以MB为单位输出</td></tr><tr><td><code>-h</code></td><td><code>--human-readable</code></td><td>以K、M、G为单位，提高信息的可读性</td></tr><tr><td></td><td><code>--si</code></td><td>与<code>-h</code>参数相同，但是K、M、G是以1000为换算单位</td></tr><tr><td><code>-P</code></td><td><code>--no-dereference</code></td><td>不显示所有符号链接的源文件大小，这么默认情况</td></tr><tr><td><code>-L</code></td><td><code>--dereference</code></td><td>显示所有符号链接的源文件大小</td></tr><tr><td><code>-D</code></td><td><code>--dereference-args</code></td><td>显示指定符号链接的源文件大小</td></tr><tr><td><code>-S</code></td><td><code>--separate-dirs</code></td><td>显示个别目录的大小时，并不含其子目录的大小</td></tr><tr><td></td><td><code>--exclude=PATTERN</code></td><td>排除指定的目录或文件</td></tr><tr><td><code>-X</code></td><td><code>--exclude-from=FILE</code></td><td>从文件中读取排除的规则</td></tr><tr><td><code>-d</code></td><td>-<code>-max-depth=N</code></td><td>统计指定深度的目录大小，当<code>--max-depth=0</code>时，效果同<code>-s</code>相同</td></tr><tr><td><code>-t</code></td><td>-<code>--threshold=SIZE</code></td><td>只输出大小大于某个特定值的文件</td></tr></table><hr><h2 id="du命令使用实例"><a href="#du命令使用实例" class="headerlink" title="du命令使用实例"></a>du命令使用实例</h2><h3 id="目录信息"><a href="#目录信息" class="headerlink" title="目录信息"></a>目录信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -alh</span><br><span class="line">  total 259M</span><br><span class="line">  drwxrwxr-x. 3 user user 4.0K May  3 13:24 .</span><br><span class="line">  drwxrwxr-x. 4 user user 4.0K May  3 00:27 ..</span><br><span class="line">  -rw-rw-r--. 1 user user 259M May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  drwxrwxr-x. 3 user user   24 May  3 13:25 backup</span><br><span class="line">  -rw-rw-r--. 1 user user  14K May  3 00:16 test1.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  11K May  3 00:17 test2.txt</span><br><span class="line">  -rw-rw-r--. 1 user user   69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="默认用法"><a href="#默认用法" class="headerlink" title="默认用法"></a>默认用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计当前文件夹的大小</span></span><br><span class="line">du .</span><br><span class="line"><span class="comment"># 默认是以K为单位</span></span><br><span class="line">  264768./backup/backup_test</span><br><span class="line">  264768./backup</span><br><span class="line">  529572.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计指定文件大小</span></span><br><span class="line">du test1.txt </span><br><span class="line">  16test1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计多个文件大小</span></span><br><span class="line">du test1.txt test2.txt </span><br><span class="line">  16test1.txt</span><br><span class="line">  12test2.txt</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>默认会显示文件夹以及子文件夹大小</strong>，<strong>不会具体显示文件夹中文件的大小</strong></p></div><hr><h3 id="h-人性化显示大小"><a href="#h-人性化显示大小" class="headerlink" title="-h-人性化显示大小"></a>-h-人性化显示大小</h3><p>和<code>ls</code>命令一样，<code>du</code>命令也可以使用<code>-h</code>参数来以人类可读的形式展示磁盘使用量的单位名称(<code>K、M、G</code>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以人类可读的形式显示大小</span></span><br><span class="line">du -h .</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="S-统计目录但不包括子目录的大小"><a href="#S-统计目录但不包括子目录的大小" class="headerlink" title="-S-统计目录但不包括子目录的大小"></a>-S-统计目录但不包括子目录的大小</h3><p>默认情况下，du统计的目录大小会包括子目录的大小，这就会造成一种重复统计大小的情况，如果想只显示当前目录中除子目录以外文件的大小的大小，可以使用-S参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以与上面默认的情况对比</span></span><br><span class="line"><span class="comment"># backup目录只能自由子目录backup_test，所以除去子目录大小后，其大小为0</span></span><br><span class="line">du -Sh .</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  0./backup</span><br><span class="line">  259M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-只显示总和大小"><a href="#s-只显示总和大小" class="headerlink" title="-s-只显示总和大小"></a>-s-只显示总和大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与默认显示每个文件夹以及子文件夹的大小不同</span></span><br><span class="line"><span class="comment"># 只显示了总的大小</span></span><br><span class="line">du -sh .</span><br><span class="line">  518M.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示给定的文件大小</span></span><br><span class="line"><span class="comment"># 这个和默认的情况没啥区别</span></span><br><span class="line">du -sh B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart  test2.txt </span><br><span class="line">  259MB2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  12Ktest2.txt</span><br></pre></td></tr></table></figure><hr><h3 id="c-所有目录以及总大小"><a href="#c-所有目录以及总大小" class="headerlink" title="-c-所有目录以及总大小"></a>-c-所有目录以及总大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前目录所有目录以及总大小</span></span><br><span class="line">du -ch .</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br><span class="line">  518Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示给定的文件总和大小</span></span><br><span class="line">du -ch B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart  test2.txt </span><br><span class="line">  259MB2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  12Ktest2.txt</span><br><span class="line">  259Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示给定文件和目录的总和大小</span></span><br><span class="line">du -ch backup/ test1.txt </span><br><span class="line">  259Mbackup/backup_test</span><br><span class="line">  259Mbackup/</span><br><span class="line">  16Ktest1.txt</span><br><span class="line">  259Mtotal</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-c</code>参数相当于是一个加和的操作，先得到给定的文件或者目录的大小，然后将这些大小加和起来得到total</p></div><hr><h3 id="a-显示所有文件和目录大小"><a href="#a-显示所有文件和目录大小" class="headerlink" title="-a-显示所有文件和目录大小"></a>-a-显示所有文件和目录大小</h3><p><strong>默认情况下</strong>，du后面如果跟着文件夹，<strong>统计的只有文件夹或者子文件夹的大小</strong>，如果想要<strong>查看所有文件和文件夹的大小</strong>，可以使用<code>-a</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有文件和目录大小</span></span><br><span class="line">du -ah .</span><br><span class="line">  4.0K./test.txt</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–exclude-排除统计文件或目录"><a href="#–exclude-排除统计文件或目录" class="headerlink" title="–exclude-排除统计文件或目录"></a>–exclude-排除统计文件或目录</h3><p>如果使用了-a参数，那么指定目录下所有的文件和子目录大小都会显示，即使是隐藏文件或文件夹(以<code>.</code>开头)，如果不想显示这些文件，可以使用–exclude进行规则的限制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有的文件和目录大小</span></span><br><span class="line">du -ah .</span><br><span class="line">  6.8M    ./wordpress-4.4.1.tar.gz</span><br><span class="line">  3.4M    ./curl-7.34.0.tar.gz</span><br><span class="line">  980K    ./soft/redis-2.6.16.tar.gz</span><br><span class="line">  40M     ./soft/go1.1.2.Linux-amd64.tar.gz</span><br><span class="line">  120K    ./soft/.abc</span><br><span class="line">  0       ./.bbc/ddd</span><br><span class="line">  0       ./.bbc/.ccc</span><br><span class="line">  51M     .</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用--exclude结合通配符</span></span><br><span class="line"><span class="comment"># 将以.开头的文件或目录大小排除在外 </span></span><br><span class="line">du -ah --exclude=<span class="string">"*/.*"</span> .</span><br><span class="line">  6.8M    ./wordpress-4.4.1.tar.gz</span><br><span class="line">  3.4M    ./curl-7.34.0.tar.gz</span><br><span class="line">  980K    ./soft/redis-2.6.16.tar.gz</span><br><span class="line">  40M     ./soft/go1.1.2.Linux-amd64.tar.gz</span><br><span class="line">  41M     ./soft</span><br><span class="line">  51M     .</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–max-depth-限制统计深度"><a href="#–max-depth-限制统计深度" class="headerlink" title="–max-depth-限制统计深度"></a>–max-depth-限制统计深度</h3><p>文件夹是可以嵌套的，有的时候，我们只想展示第一级或第二级子文件夹的信息，而不希望 <code>du</code> 统计的层次太深，那么我们可以用 <code>--max-depth</code> 选项来进行控制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结合-c参数，--max-depth=0</span></span><br><span class="line"><span class="comment"># 相当于使用了-s参数</span></span><br><span class="line">du --max-depth=0 -ch .</span><br><span class="line">  518M.</span><br><span class="line">  518Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合-c参数，--max-depth=1</span></span><br><span class="line"><span class="comment"># 只会显示当前和子目录，不会显示子目录的子目录</span></span><br><span class="line">du --max-depth=1 -ch .</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br><span class="line">  518Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合-a参数，--max-depth=1</span></span><br><span class="line"><span class="comment"># 显示了当前目录下所有的文件大小以及子目录大小</span></span><br><span class="line">du --max-depth=1 -ah .</span><br><span class="line">  4.0K./test.txt</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="结合sort命令"><a href="#结合sort命令" class="headerlink" title="结合sort命令"></a>结合sort命令</h3><p>按照文件或文件夹大小进行降序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">du -ah .  |sort -hr</span><br><span class="line">  518M.</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  4.0K./test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于<code>sort</code> <code>-n</code>和<code>-h</code>参数的区别：</p><ul><li><code>-n</code>选项，按<strong>数值进行比较</strong>，只会<strong>傻傻地比较数字</strong>，它会<strong>认为 98 K大于 2G</strong></li><li><code>-h</code>选项，会更加聪明，先<strong>优先比较单位（G&gt;M&gt;K）</strong>，然后<strong>再对数值进行比较</strong></li></ul></div><hr><h3 id="t-只输出大小大于某个特定值的文件"><a href="#t-只输出大小大于某个特定值的文件" class="headerlink" title="-t-只输出大小大于某个特定值的文件"></a>-t-只输出大小大于某个特定值的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只输出大于100m的文件</span></span><br><span class="line">du -ah . -t 100m</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><hr><h3 id="关于单位名称"><a href="#关于单位名称" class="headerlink" title="关于单位名称"></a>关于单位名称</h3><p>默认的单位是K，当然也可以通过指定<code>-b</code>、<code>-k</code>、<code>-m</code>来分别设置以<code>bytes</code>、<code>KB</code>、<code>MB</code>为单位，其实这些<code>-k</code>、<code>-m</code>对单位的设置都是通过<code>--block-size</code>来控制的：</p><ul><li><code>--block-size=1(-b)</code>，则表示使用<code>bytes</code>为单位</li><li><code>--block-size=1K(-k)</code>，则表示使用<code>KB</code>为单位</li><li><code>--block-size=1M(-m)</code>，则表示使用<code>MB</code>为单位</li></ul><hr><h3 id="du和ls结果的差异"><a href="#du和ls结果的差异" class="headerlink" title="du和ls结果的差异"></a>du和ls结果的差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有一个文件, 里面只输入了a、b两个英文字母</span></span><br><span class="line">cat &lt;&lt; EOF &gt;test3.txt</span><br><span class="line">  &gt; ab</span><br><span class="line">  &gt; EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#用下面的方法, 我们可以把文件中的控制字符也展示出来, 发现除了a、b外还包括了一个结尾符</span></span><br><span class="line">cat -E test3.txt </span><br><span class="line">  ab$</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用ls来查看大小, 发现展示的是3字节</span></span><br><span class="line">ls -alh test3.txt </span><br><span class="line">  -rw-rw-r--. 1 user user 3 May  3 17:06 test3.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用du来查看大小, 竟然展示的是4KB字节</span></span><br><span class="line">du -h test3.txt </span><br><span class="line">  4.0Ktest3.txt</span><br></pre></td></tr></table></figure><p><code>du</code> 命令的作者也太粗心了吧，竟然连字母个数都数不清么？冤枉啊！其实，<code>du</code> 和 <code>ls</code> 在展示文件大小时，是<strong>存在着本质区别</strong>的：</p><ul><li><code>du</code> 展示的是<strong>磁盘空间占用量</strong></li><li><code>ls</code> 展示的是<strong>文件内容的大小</strong></li></ul><p>可能这两句话还不足以让你理解两者的区别，我们举一个形象的例子。中秋节时，中国人走亲访友时都会购买月饼礼盒，月饼的体积可以认为是文件内容大小，而加上包装礼盒的总体积可以认为是磁盘空间使用量。</p><p>那么，在 Linux 的世界里，每个文件也要有包装么？要想解答这个问题，我们就要<strong>简单介绍下 Linux 文件系统的原理了</strong>：文件系统进驻磁盘之初，就会<strong>将磁盘按照固定数据块（block）大小进行分隔切块，通常情况下每一个固定数据块大小会被设定为 4096bytes，也就是 4KB</strong>，与此同时，大部分文件系统规定：</p><ul><li>一个数据块中最多存放一个文件的内容，<strong>当没存满时，剩余的空间不得被其他文件使用</strong></li><li>当一个文件的内容较大时，则<strong>可以存储到多个数据块中</strong></li></ul><p><mark>文件 test3.txt 中<strong>只有三个字符，两个可见字符（ab）和一个控制字符（$）</strong>，因此，这个<strong>文件的内容大小就是 3bytes</strong>，但是<strong>由于 Linux 文件系统的限制，它需要占用一个数据块来存储这个文件，因此这个文件实际占用的磁盘空间就是 4KB 了</strong>。</mark></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/du.html" target="_blank" rel="noopener">du命令_Linux du命令：查看文件夹和文件的磁盘占用情况</a></li><li><a href="http://sunyongfeng.com/201412/shell/du.html" target="_blank" rel="noopener">Linux命令行查看目录及子目录大小 - du</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中用于&lt;strong&gt;统计目录或文件大小的命令du&lt;/strong&gt;，主要学习了：&lt;code&gt;-h&lt;/code&gt;、&lt;code&gt;-S&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;--exclude&lt;/code&gt;、&lt;code&gt;--max-depth&lt;/code&gt;、&lt;code&gt;结合sort命令&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;关于单位名称&lt;/code&gt;、&lt;code&gt;与ls输出结果的差别原因&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>pgrep-使用进程名直接查找pid等信息</title>
    <link href="http://showteeth.tech/posts/22799.html"/>
    <id>http://showteeth.tech/posts/22799.html</id>
    <published>2019-05-03T02:31:57.000Z</published>
    <updated>2019-05-03T03:49:15.347Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>直接通过进程名查找pid以及进程名和完整命令行的命令pgrep</strong>，其是<a href="http://showteeth.tech/posts/33990.html">ps</a>结合<code>awk</code>、<code>grep</code>命令查找信息的一个<strong>简写命令</strong>；主要学习了<code>-l</code>、<code>-a</code>、<code>-f</code>、<code>-x</code>等。</p></div><a id="more"></a><h2 id="pgrep命令简介"><a href="#pgrep命令简介" class="headerlink" title="pgrep命令简介"></a>pgrep命令简介</h2><p><code>pgrep</code>命令<strong>以名称为依据</strong>从运行进程队列中查找进程，并<strong>显示查找到的进程id</strong>。每一个进程ID以一个十进制数表示，通过一个分割字符串和下一个ID分开，默认的分割字符串是一个新行。</p><p>前面学习了<a href="http://showteeth.tech/posts/33990.html">查看静态进程信息的命令ps</a>，在实际使用中经常会遇到需要查看某个任务的pid信息，这个时候如果使用ps命令就需要结合awk和grep等命令，显得比较繁琐，如查看jupyterhub相关名称的pid需要使用<code>ps -auxf |grep &quot;jupyterhub&quot; |grep -v &quot;grep&quot; |awk &#39;{print $2}&#39;</code>，这么长的命令写着不是很方便，那么有没有可以简化的方法呢？pgrep就是为了解决这一问题而生的，pgrep相当于<code>ps -eo pid,cmd | awk &#39;{print $1,$2}&#39; | grep KeyWord</code>，可以直接得到命令的pid。</p><div class="note info"><p>pgrep是根据进程名来查找得到pid，并且其对匹配的字符数目也有限制，<strong>默认只能匹配进程的前15个字符</strong>:</p><blockquote><p>ps aux includes the full command line (path and parameters), while pgrep only looks at the first 15 characters of the executable’s names</p></blockquote><p>这个可以结合<strong>后面的参数<code>-f</code>进行全字符的匹配</strong></p></div><p>与<code>pgrep</code>相对应的还有一个<code>pkill</code>命令，<strong>和<code>pgrep</code>用法完全相同</strong>，不过个人感觉还是使用<code>pgrep</code>查找到<strong>想要的pid</strong>之后结合<code>xargs</code>和<code>kill</code>进行操作比较好。</p><hr><h2 id="pgrep命令格式"><a href="#pgrep命令格式" class="headerlink" title="pgrep命令格式"></a>pgrep命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> pgrep [options] &lt;pattern&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="pgrep命令参数"><a href="#pgrep命令参数" class="headerlink" title="pgrep命令参数"></a>pgrep命令参数</h2><table><thead><tr><th width="10%">选项</th><th width="90%">说明</th></tr></thead><tbody><tr><td>-<code>-d</code></td><td>定义输出的多个进程之间的分隔符（默认使用换行符）</td></tr><tr><td><code>-l</code></td><td>列出pid 和 进程名</td></tr><tr><td><code>-a</code></td><td>列出pid 和 完整的命令</td></tr><tr><td><code>-v</code></td><td>否定匹配，即列出除了查找的进程以外的其他进程</td></tr><tr><td><code>-w</code></td><td>列出所有的TID</td></tr><tr><td><code>-c</code></td><td>统计匹配到的所有进程数量</td></tr><tr><td><code>-f</code></td><td>用进程全名去匹配，包括参数</td></tr><tr><td><code>-g</code></td><td>匹配列出的进程组ID</td></tr><tr><td><code>-G</code></td><td>其后跟着一组group id，该命令在搜索时，仅考虑group列表中的进程。</td></tr><tr><td><code>-n</code></td><td>表示如果该程序有多个进程正在运行，则仅查找最新的，即最后启动的。</td></tr><tr><td><code>-o</code></td><td>表示如果该程序有多个进程正在运行，则仅查找最老的，即最先启动的（多个进程时即父进程PID）。</td></tr><tr><td><code>-P</code></td><td>根据父进程PID，找出所有子进程的pid</td></tr><tr><td><code>-s</code></td><td>匹配会话ID</td></tr><tr><td><code>-t</code></td><td>通过控制终端匹配</td></tr><tr><td><code>-u</code></td><td>其后跟着一组有效用户ID(effetive user id)，该命令在搜索时，仅考虑该effective user列表中的进程。</td></tr><tr><td><code>-U</code></td><td>其后跟着一组实际用户ID(real user id)，该命令在搜索时，仅考虑该real user列表中的进程。</td></tr><tr><td><code>-x</code></td><td>表示进程的名字必须完全匹配, 以上的选项均可以部分匹配。</td></tr><tr><td><code>-F</code></td><td>从文件中读取PID</td></tr><tr><td><code>-L</code></td><td>如果PID文件未锁定，则失败</td></tr></tbody></table><hr><h2 id="pgrep使用实例"><a href="#pgrep使用实例" class="headerlink" title="pgrep使用实例"></a>pgrep使用实例</h2><h3 id="ps查看命令信息"><a href="#ps查看命令信息" class="headerlink" title="ps查看命令信息"></a>ps查看命令信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -auxf |grep <span class="string">"jupyterhub"</span> |grep -v <span class="string">"grep"</span></span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user2"</span></span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   1:06 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:23  \_ /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user"</span></span><br></pre></td></tr></table></figure><p>可以发现输出结果中<strong>第三个为子进程</strong>。</p><hr><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下只会显示pid</span></span><br><span class="line">pgrep  jupyterhub</span><br><span class="line">  17668</span><br><span class="line">  30495</span><br></pre></td></tr></table></figure><p><mark>这里只会显示父进程的信息，<strong>不会显示子进程的pid</strong></mark></p><hr><h3 id="l-列出pid和进程名"><a href="#l-列出pid和进程名" class="headerlink" title="-l-列出pid和进程名"></a>-l-列出pid和进程名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出pid和进程名</span></span><br><span class="line"><span class="comment"># 但没有列出命令信息，不是很完善</span></span><br><span class="line">pgrep  -l jupyterhub</span><br><span class="line">  17668 jupyterhub-sing</span><br><span class="line">  30495 jupyterhub</span><br></pre></td></tr></table></figure><p><mark>这里只会显示父进程的信息，<strong>不会显示子进程的pid</strong></mark></p><hr><h3 id="a-列出pid和完整命令"><a href="#a-列出pid和完整命令" class="headerlink" title="-a-列出pid和完整命令"></a>-a-列出pid和完整命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示了pid和完整的命令，信息较全</span></span><br><span class="line">pgrep  -a jupyterhub</span><br><span class="line">  17668 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user2"</span></span><br><span class="line">  30495 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><p><mark>这里只会显示父进程的信息，<strong>不会显示子进程的pid</strong></mark></p><hr><h3 id="f-匹配整个命令行"><a href="#f-匹配整个命令行" class="headerlink" title="-f-匹配整个命令行"></a>-f-匹配整个命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现是使用-f参数可以得到三个pid</span></span><br><span class="line"><span class="comment"># 也就是包括了子进程的信息</span></span><br><span class="line">pgrep -f <span class="string">"jupyterhub"</span></span><br><span class="line">  17668</span><br><span class="line">  30495</span><br><span class="line">  30529</span><br></pre></td></tr></table></figure><p>结合<code>-a</code>使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pgrep -af <span class="string">"jupyterhub"</span></span><br><span class="line">  17668 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user2"</span></span><br><span class="line">  30495 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br><span class="line">  30529 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user"</span></span><br></pre></td></tr></table></figure><p></p><p><mark>使用-f参数既可以显示父进程pid，<strong>也会显示子进程的pid</strong></mark></p><hr><h3 id="x-精确匹配进程名"><a href="#x-精确匹配进程名" class="headerlink" title="-x-精确匹配进程名"></a>-x-精确匹配进程名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不包括子进程的进程名称</span></span><br><span class="line"><span class="comment"># 是模糊匹配</span></span><br><span class="line">pgrep -l <span class="string">"jupyterhub"</span></span><br><span class="line">  17668 jupyterhub-sing</span><br><span class="line">  30495 jupyterhub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确匹配进程名</span></span><br><span class="line"><span class="comment"># 排除了jupyterhub-sing的结果</span></span><br><span class="line">pgrep -ax <span class="string">"jupyterhub"</span></span><br><span class="line">  30495 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://xiaqunfeng.cc/2017/02/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94pgrep%E5%92%8Cpkill/" target="_blank" rel="noopener">Linux命令——pgrep和pkill</a></li><li><a href="http://www.361way.com/pgrep/3650.html" target="_blank" rel="noopener">pgrep无法匹配问题</a></li><li><a href="http://man.linuxde.net/pgrep" target="_blank" rel="noopener">pgrep命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;直接通过进程名查找pid以及进程名和完整命令行的命令pgrep&lt;/strong&gt;，其是&lt;a href=&quot;http://showteeth.tech/posts/33990.html&quot;&gt;ps&lt;/a&gt;结合&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;命令查找信息的一个&lt;strong&gt;简写命令&lt;/strong&gt;；主要学习了&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-x&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>ps-报告当前系统的进程状态</title>
    <link href="http://showteeth.tech/posts/33990.html"/>
    <id>http://showteeth.tech/posts/33990.html</id>
    <published>2019-05-02T14:14:13.000Z</published>
    <updated>2019-05-03T03:29:02.901Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>查看静态进程信息的命令ps</strong>，主要学习了<code>-A</code>、<code>-u</code>、<code>-N</code>、<code>显示所有进程信息(-ef)</code>、<code>信息更多地显示所有进程信息(-aux)</code>、<code>依据进程信息进行排序</code>、<code>-C</code>、<code>-o</code>、<code>实时监控进程状态</code>等；如果希望直接得到<strong>进程的pid、命令行以及进程名等信息</strong>，可以直接使用<a href="http://showteeth.tech/posts/22799.html">pgrep命令</a>。</p></div><a id="more"></a><h2 id="ps命令简介"><a href="#ps命令简介" class="headerlink" title="ps命令简介"></a>ps命令简介</h2><p>Linux中的<code>ps</code>命令是<code>Process Status</code>的缩写，用来<strong>列出系统中当前运行的那些进</strong>程。<code>ps</code>命令列出的是<strong>当前那些进程的快照</strong>，就是<strong>执行ps命令的那个时刻的那些进程</strong>，是静态的，如果想要<strong>动态的显示进程信息，就可以使用top命令</strong>。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 <code>ps</code> 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p>linux上进程有5种状态以及在<code>ps</code>中对应的状态码：<br><table><tr><th width="30%">状态</th><th width="40%">说明</th><th width="30%">ps中的状态码</th></tr><tr><td>运行 runnable (on run queue)</td><td>正在运行或在运行队列中等待</td><td>R</td></tr><tr><td>中断 sleeping</td><td>休眠中, 受阻, 在等待某个条件的形成或接受到信号</td><td>S</td></tr><tr><td>不可中断 uninterruptible sleep (usually IO)</td><td>收到信号不唤醒和不可运行, 进程必须等待直到有中断发生</td><td>D</td></tr><tr><td>僵死 a defunct (”zombie”) process</td><td>进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放</td><td>Z</td></tr><tr><td>停止 traced or stopped</td><td>进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行</td><td>T</td></tr></table></p><hr><h2 id="ps命令参数"><a href="#ps命令参数" class="headerlink" title="ps命令参数"></a>ps命令参数</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>a</code></td><td>显示所有进程(with tty)，包括其他其他用户的进程<br></td></tr><tr><td><code>-a</code></td><td>显示所有进程(with tty)，但不包括会话的领导进程(session leaders)</td></tr><tr><td><code>-A, -e</code></td><td>显示所有进程</td></tr><tr><td><code>c</code></td><td>显示进程的真实名称</td></tr><tr><td><code>-N</code></td><td>反向选择，相当于！</td></tr><tr><td><code>e</code></td><td>命令之后显示环境，user、name、path等</td></tr><tr><td><code>-f</code></td><td>信息全部列出，通常和其他选项联用</td></tr><tr><td><code>-H</code></td><td>显示树状结构</td></tr><tr><td><code>r</code></td><td>显示当前终端正在运行的进程</td></tr><tr><td><code>T</code></td><td>显示当前终端的所有进程</td></tr><tr><td><code>-u</code></td><td>指定用户的所有进程</td></tr><tr><td><code>-k、--sort</code></td><td>对进程信息进行排序，+表示升序，-表示降序</td></tr><tr><td><code>-C</code></td><td>根据command名称进行过滤</td></tr></table><hr><h2 id="ps输出结果说明"><a href="#ps输出结果说明" class="headerlink" title="ps输出结果说明"></a>ps输出结果说明</h2><ul><li><code>UID、USER</code>：该命令是由哪个用户产生的。</li><li><code>PID</code>：进程的ID号。</li><li><code>%CPU</code>：该进程占用CPU资源的百分比。</li><li><code>%MEM</code>：该进城占用物理内存的百分比。</li><li><code>VSZ</code>：该进程占用虚拟内存的大小，单位KB。</li><li><code>RSS</code>：该进程占用实际物理内存的大小，单位KB。</li><li><code>TTY</code>：该进程在哪个终端中运行。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地字符界面终端，tty7是图形终端。pst/0-255代表虚拟终端。</li><li><code>STAT</code>：由两个字符组成的状态码，用于表示当前进程的状态：<ul><li>第一个字符：<ul><li><code>R</code>：运行</li><li><code>S</code>：睡眠</li><li><code>T</code>：停止状态</li><li><code>Z</code>：僵死</li></ul></li><li>第二个字符：<ul><li><code>s</code>：包含<strong>子进程</strong></li><li><code>+</code>：位于<strong>前台</strong></li><li><code>&lt;</code>：进程正以<strong>高优先级</strong>运行</li><li><code>N</code>：进程正以<strong>低优先级</strong>运行</li><li><code>L</code>：进程在内存中存在锁定页面</li><li><code>s</code>：进程是<strong>会话领导者（session leader）</strong></li><li><code>l</code>：进程是<strong>多线程</strong>的</li></ul></li></ul></li><li><code>START</code>：该进程的启动时间</li><li><code>TIME</code>：该进程占用CPU的运算时间，注意不是系统时间</li><li><code>COMMAND</code>：产生此进程的命令</li></ul><hr><h2 id="ps使用实例"><a href="#ps使用实例" class="headerlink" title="ps使用实例"></a>ps使用实例</h2><h3 id="A-显示所有进程信息"><a href="#A-显示所有进程信息" class="headerlink" title="-A-显示所有进程信息"></a>-A-显示所有进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -A</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:10:40 systemd</span><br><span class="line">    2 ?        00:00:01 kthreadd</span><br><span class="line">    3 ?        00:00:01 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 kworker/0:0H</span><br><span class="line">    7 ?        00:00:03 migration/0</span><br></pre></td></tr></table></figure><hr><h3 id="u-显示指定用户信息"><a href="#u-显示指定用户信息" class="headerlink" title="-u-显示指定用户信息"></a>-u-显示指定用户信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示root的进程信息</span></span><br><span class="line">ps -u root u</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  root         1  0.0  0.0  52096  4584 ?        Ss    2018  10:41 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line">  root         8  0.0  0.0      0     0 ?        S     2018   0:00 [rcu_bh]</span><br><span class="line">  root         9  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/0]</span><br><span class="line">  root        10  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/1]</span><br></pre></td></tr></table></figure><p>说明：最后的<code>u</code>参数用来<strong>决定以针对用户的格式输出</strong>，由<code>User</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>VSZ</code>, <code>RSS</code>, <code>TTY</code>, <code>STAT</code>, <code>START</code>, <code>TIME</code> 和 <code>COMMAND</code>这几列组成.</p><hr><h3 id="N-反向选择"><a href="#N-反向选择" class="headerlink" title="-N-反向选择"></a>-N-反向选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非root用户的进程信息</span></span><br><span class="line">ps -u root u -N</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  dbus       784  0.0  0.0  35048  1036 ?        Ssl   2018   0:50 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">  polkitd    915  0.0  0.0 632008  2000 ?        Ssl   2018   0:13 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">  user+  3453  0.0  0.0 145612  2300 ?        S    May02   0:00 sshd: user@pts/1</span><br><span class="line">  user+  3454  0.0  0.0 115508  2272 pts/1    Ss   May02   0:01 -bash</span><br><span class="line">  user+ 15238  0.0  0.0 145612  2172 ?        S    00:31   0:00 sshd: user@pts/2</span><br><span class="line">  user+ 15239  0.0  0.0 115508  2228 pts/2    Ss+  00:31   0:00 -bash</span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 </span><br><span class="line">  user+ 17931  0.0  0.0 155268  1860 pts/1    R+   01:07   0:00 ps -u root u -N</span><br><span class="line">  rstudio+ 21690  0.0  0.0 212740  5480 ?        Ssl  Apr10   4:41 /usr/lib/rstudio-server/bin/rserver</span><br></pre></td></tr></table></figure><hr><h3 id="显示所有进程信息"><a href="#显示所有进程信息" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h3><p>显示完整的命令信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">  UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">  root         1     0  0  2018 ?        00:10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2     0  0  2018 ?        00:00:01 [kthreadd]</span><br><span class="line">  root         3     2  0  2018 ?        00:00:01 [ksoftirqd/0]</span><br><span class="line">  root         5     2  0  2018 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">  root         7     2  0  2018 ?        00:00:03 [migration/0]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="显示所有进程信息，信息更多"><a href="#显示所有进程信息，信息更多" class="headerlink" title="显示所有进程信息，信息更多"></a>显示所有进程信息，信息更多</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  root         1  0.0  0.0  52096  4624 ?        Ss    2018  10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line">  root         8  0.0  0.0      0     0 ?        S     2018   0:00 [rcu_bh]</span><br><span class="line">  root         9  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/0]</span><br><span class="line">  root        10  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/1]</span><br><span class="line">  root        11  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/2]</span><br></pre></td></tr></table></figure><div class="note info"><p>与<code>ps -ef</code>相比，<code>ps -aux</code>信息更多，包括了<code>%CPU</code>、<code>%MEM</code>等信息，两者的<code>cmd</code>和<code>command</code>是相同的</p></div><hr><h3 id="依据进程信息进行排序"><a href="#依据进程信息进行排序" class="headerlink" title="依据进程信息进行排序"></a>依据进程信息进行排序</h3><p>参数说明：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">k,    --sort        specify sort order as: [+|-]key[,[+|-]key[,...]]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>多个key之间使用<strong>逗号分隔</strong></li><li><code>+</code>表示<strong>升序</strong>，<code>-</code>表示<strong>降序</strong></li><li>支持的sort key可以查看<a href="http://linuxcommand.org/lc3_man_pages/ps1.html" target="_blank" rel="noopener">这个链接中的STANDARD FORMAT SPECIFIERS</a></li></ul></div><hr><h4 id="依据进程的CPU使用排序"><a href="#依据进程的CPU使用排序" class="headerlink" title="依据进程的CPU使用排序"></a>依据进程的CPU使用排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降序排列，+pcpu</span></span><br><span class="line">ps -aux --sort +pcpu</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 15072  118  2.5 1890184 1247420 pts/2 R+   00:28   0:02 sh test.sh</span><br><span class="line">  root         1  0.0  0.0  52096  4624 ?        Ss    2018  10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升序排列，+pcpu</span></span><br><span class="line">ps -aux --sort +pcpu</span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 </span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 15072  100 22.5 11214456 11102608 pts/2 R+ 00:28   0:46 sh test.sh</span><br></pre></td></tr></table></figure><hr><h4 id="依据进程的内存使用排序"><a href="#依据进程的内存使用排序" class="headerlink" title="依据进程的内存使用排序"></a>依据进程的内存使用排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据内存使用进行降序排列</span></span><br><span class="line">ps -aux --sort -pmem </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 </span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 </span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  root     15933  0.0  0.0 341804 13380 ?        Ssl   2018   0:01 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br></pre></td></tr></table></figure><hr><h3 id="C-通过command名称过滤"><a href="#C-通过command名称过滤" class="headerlink" title="-C-通过command名称过滤"></a>-C-通过command名称过滤</h3><p>使用 -C 参数，后面跟你要找的进程的名字:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -fC jupyterhub</span><br><span class="line">  root     30495     1  0 Apr30 ?        00:00:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>参数是带有顺序的</strong>，不能使用<code>-Cf</code>，使用<code>-fC</code>是正确的</p></div><hr><h3 id="o-指定输出字段"><a href="#o-指定输出字段" class="headerlink" title="-o-指定输出字段"></a>-o-指定输出字段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出字段</span></span><br><span class="line">ps -o pid,ppid,pgrp,session,tpgid,comm</span><br><span class="line">    PID  PPID  PGRP  SESS TPGID COMMAND</span><br><span class="line">  3454  3453  3454  3454 13946 bash</span><br><span class="line">  13946  3454 13946  3454 13946 ps</span><br></pre></td></tr></table></figure><p>支持的输出字段可以查看<a href="http://linuxcommand.org/lc3_man_pages/ps1.html" target="_blank" rel="noopener">这个链接中的STANDARD FORMAT SPECIFIERS</a></p><hr><h3 id="实时监控进程状态"><a href="#实时监控进程状态" class="headerlink" title="实时监控进程状态"></a>实时监控进程状态</h3><p>ps 命令会显示你系统当前的进程状态，但是这个结果是静态的，如果我们需要像上面提到的通过CPU和内存的使用率来筛选进程，并且我们希望结果能够每秒刷新一次，我们可以将<code>ps</code>命令和<code>watch</code>命令结合起来：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每10秒更新一次</span></span><br><span class="line">watch -n 10 <span class="string">'ps -aux --sort -pmem | head -n 20'</span></span><br><span class="line">  Every 10.0s: ps -aux --sort -pmem | head -n 20                                                                                                 Fri May  3 00:53:36 2019</span><br><span class="line"></span><br><span class="line">  USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783</span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460</span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  root     15933  0.0  0.0 341804 12992 ?        Ssl   2018   0:01 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line">  rstudio+ 21690  0.0  0.0 212740  5480 ?        Ssl  Apr10   4:41 /usr/lib/rstudio-server/bin/rserver</span><br><span class="line">  root  3448  0.0  0.0 145612  5156 ?        Ss   May02   0:00 sshd: user [priv]</span><br></pre></td></tr></table></figure><p></p><p><mark>这里的动态查看<strong>并不像<code>top</code>或者<code>htop</code>命令</strong>一样，使用<code>ps</code>的好处是你能够<strong>自定义显示你想查看的字段</strong></mark>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定用户的信息，并按照内存使用进行降序排序</span></span><br><span class="line">watch -n 10 <span class="string">'ps -u user u --sort -pmem | head -n 20'</span></span><br><span class="line">  Every 10.0s: ps -u user u --sort -pmem | head -n 20                                                                                     Fri May  3 00:56:12 2019</span><br><span class="line"></span><br><span class="line">  USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783</span><br><span class="line">  user+ 17081  0.0  0.0 157560  2528 pts/1    S+   00:55   0:00 watch -n 10 ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+  3453  0.0  0.0 145612  2300 ?        S    May02   0:00 sshd: user@pts/1</span><br><span class="line">  user+  3454  0.0  0.0 115508  2272 pts/1    Ss   May02   0:01 -bash</span><br><span class="line">  user+ 15239  0.0  0.0 115508  2228 pts/2    Ss+  00:31   0:00 -bash</span><br><span class="line">  user+ 15238  0.0  0.0 145612  2172 ?        S    00:31   0:00 sshd: user@pts/2</span><br><span class="line">  user+ 17120  0.0  0.0 155264  1832 pts/1    R+   00:56   0:00 ps -U user -u --sort -pmem</span><br><span class="line">  user+ 17119  0.0  0.0 113124  1364 pts/1    S+   00:56   0:00 sh -c ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+ 17118  0.0  0.0 157556   936 pts/1    S+   00:56   0:00 watch -n 10 ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+ 17121  0.0  0.0 107904   672 pts/1    S+   00:56   0:00 head -n 20</span><br></pre></td></tr></table></figure><p></p><p>说明：最后的<code>u</code>参数用来<strong>决定以针对用户的格式输出</strong>，由<code>User</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>VSZ</code>, <code>RSS</code>, <code>TTY</code>, <code>STAT</code>, <code>START</code>, <code>TIME</code> 和 <code>COMMAND</code>这几列组成.</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="noopener">每天一个linux命令（41）：ps命令</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" target="_blank" rel="noopener">4. ps 进程查看器</a></li><li><a href="https://www.jianshu.com/p/784d594a78aa" target="_blank" rel="noopener">Linux命令-5 ps</a></li><li><a href="https://linux.cn/article-4743-1.html" target="_blank" rel="noopener">10个重要的Linux ps命令实战</a></li><li><a href="https://segmentfault.com/a/1190000014730535#articleHeader1" target="_blank" rel="noopener">Linux 进程管理（1）- 查看进程：ps,pstree,top,htop,bg,fg,jobs</a></li><li><a href="http://os.51cto.com/art/201101/244090.htm" target="_blank" rel="noopener">如何在Linux中查看所有正在运行的进程</a></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/es-unix-sysadmin1.html" target="_blank" rel="noopener">进程管理技巧</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;查看静态进程信息的命令ps&lt;/strong&gt;，主要学习了&lt;code&gt;-A&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;、&lt;code&gt;-N&lt;/code&gt;、&lt;code&gt;显示所有进程信息(-ef)&lt;/code&gt;、&lt;code&gt;信息更多地显示所有进程信息(-aux)&lt;/code&gt;、&lt;code&gt;依据进程信息进行排序&lt;/code&gt;、&lt;code&gt;-C&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;实时监控进程状态&lt;/code&gt;等；如果希望直接得到&lt;strong&gt;进程的pid、命令行以及进程名等信息&lt;/strong&gt;，可以直接使用&lt;a href=&quot;http://showteeth.tech/posts/22799.html&quot;&gt;pgrep命令&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>rsnyc-远程数据同步</title>
    <link href="http://showteeth.tech/posts/8376.html"/>
    <id>http://showteeth.tech/posts/8376.html</id>
    <published>2019-05-02T01:23:22.000Z</published>
    <updated>2019-05-02T15:37:29.462Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中进行<strong>远程数据同步的命令rsync</strong>，相比于功能相近的<a href="http://showteeth.tech/posts/2539.html">scp命令</a>，其可以实现<strong>增量同步</strong>；主要学习了<code>本地目录之间的同步</code>、<code>本地与远程之间的同步</code>、<code>-t</code>、<code>-a</code>、<code>-r</code>、<code>-R</code>、<code>-l</code>、<code>-L</code>、<code>--backup</code>、<code>--backup-dir</code>、<code>--existing</code>、<code>--ignore-existing</code>、<code>--remove-source-files</code>、<code>--exclude</code>、<code>--delete</code>、<code>--max-size</code>等参数。</p></div><a id="more"></a><h2 id="rsync命令简介"><a href="#rsync命令简介" class="headerlink" title="rsync命令简介"></a>rsync命令简介</h2><p><code>rsync</code>是可以<strong>实现增量备份</strong>的工具。配合任务计划，<code>rsync</code>能实现<strong>定时或间隔同步</strong>，配合<code>inotify</code>或<code>sersync</code>，可以实现<strong>触发式的实时同步</strong>。</p><p><code>rsync</code>可以实现<a href="http://showteeth.tech/posts/2539.html">scp</a>的远程拷贝(<strong><code>rsync</code>不支持远程到远程的拷贝，但<code>scp</code>支持</strong>)、<code>cp</code>的本地拷贝、<code>rm</code>删除和<code>&quot;ls -l&quot;</code>显示文件列表等功能。但需要注意的是，<code>rsync</code>的最终目的或者说其<strong>原始目的是实现两端主机的文件同步</strong>，因此实现的<code>scp/cp/rm</code>等功能仅仅只是同步的辅助手段，且<code>rsync</code>实现这些功能的方式和这些命令是不一样的。本篇文章将简单介绍rsync的使用方法和它常用的功能。</p><hr><h2 id="rsync同步说明"><a href="#rsync同步说明" class="headerlink" title="rsync同步说明"></a>rsync同步说明</h2><p><code>rsync</code>的目的是<strong>实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步(scp可以实现)</strong>。</p><p>不考虑rsync的实现细节，就文件同步而言，涉及了<strong>源文件和目标文件</strong>的概念，还涉及了<strong>以哪边文件为同步基准</strong>。例如，想让目标主机上的文件和本地文件保持同步，则是以本地文件为同步基准，将本地文件作为源文件推送到目标主机上。反之，如果想让本地主机上的文件和目标主机上的文件保持同步，则目标主机上的文件为同步基准，实现方式是将目标主机上的文件作为源文件拉取到本地。当然，要保持本地的两个文件相互同步，rsync也一样能实现，这就像Linux中cp命令一样，以本地某文件作为源，另一文件作为目标文件，但请注意，虽然rsync和cp能达到相同的目的，但它们的实现方式是不一样的。实际上，如果<strong>简单理解的话，可以将其当成复制命令来理解</strong>：</p><ul><li><strong>本地和远程同步</strong>，就是将<strong>远程的文件复制到本地</strong>，覆盖本地原有文件的内容</li><li><strong>远程和本地同步</strong>，就是将<strong>本地的文件复制到远程</strong>，覆盖远程原有文件的内容</li></ul><p>既然是文件同步，在同步过程中必然会涉及到源和目标两文件之间<strong>版本控制</strong>的问题，例如是否要删除源主机上没有但目标上多出来的文件，目标文件比源文件更新(newer than source)时是否仍要保持同步，遇到软链接时是拷贝软链接本身还是拷贝软链接所指向的文件，目标文件已存在时是否要先对其做个备份等等。</p><p><code>rsync</code>同步过程中由<strong>两部分模式</strong>组成：<strong>决定哪些文件需要同步的检查模式</strong>以及<strong>文件同步时的同步模式</strong>：</p><ul><li><p><strong>检查模式是指按照指定规则来检查哪些文件需要被同步</strong>，例如哪些文件是明确被排除不传输的。<strong>默认情况下</strong>，<code>rsync</code>使用<code>&quot;quick check&quot;</code>算法快速检查源文件和目标文件的<strong>大小</strong>、<strong>mtime(修改时间)是否一致</strong>，如果<strong>不一致则需要传输</strong>。当然，也可以通过在<code>rsync</code>命令行中指定某些选项来<strong>改变quick check的检查模式</strong>，比如<code>&quot;--size-only&quot;</code>选项表示<code>&quot;quick check&quot;</code>将仅检查文件大小不同的文件作为待传输文件。rsync支持非常多的选项，其中检查模式的自定义性是非常有弹性的。</p></li><li><p><strong>同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作</strong>。例如上文所说的是否要先删除源主机上没有但目标主机上有的文件，是否要先备份已存在的目标文件，是否要追踪链接文件等额外操作。rsync也提供非常多的选项使得同步模式变得更具弹性。</p></li><li><p>相对来说，<strong>为<code>rsync</code>手动指定同步模式的选项更常见一些</strong>，只有在有特殊需求时才指定检查模式，因为大多数检查模式选项都可能会影响<code>rsync</code>的性能。</p></li></ul><hr><h2 id="rsync命令格式"><a href="#rsync命令格式" class="headerlink" title="rsync命令格式"></a>rsync命令格式</h2><h3 id="通用命令格式"><a href="#通用命令格式" class="headerlink" title="通用命令格式"></a>通用命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync options <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><hr><h3 id="本地路径之间的同步"><a href="#本地路径之间的同步" class="headerlink" title="本地路径之间的同步"></a>本地路径之间的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地路径之间的同步</span></span><br><span class="line">Local:  rsync [OPTION...] SRC... [DEST]</span><br></pre></td></tr></table></figure><hr><h3 id="本地和远程的同步"><a href="#本地和远程的同步" class="headerlink" title="本地和远程的同步"></a>本地和远程的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地和远程的同步 </span></span><br><span class="line">Access via remote shell:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br></pre></td></tr></table></figure><hr><h3 id="本地和远程的同步-rsync-daemon"><a href="#本地和远程的同步-rsync-daemon" class="headerlink" title="本地和远程的同步(rsync daemon)"></a>本地和远程的同步(rsync daemon)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access via rsync daemon:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]</span><br><span class="line">        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST</span><br><span class="line">        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</span><br></pre></td></tr></table></figure><div class="note info"><ul><li><strong>前两者</strong>的本质是<strong>通过管道通信，即使是远程shell</strong>；而<strong>第三种方式</strong>则是<strong>让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接</strong>。</li><li>命令中的<strong>第一个路径参数</strong>一定是源文件路径，即<strong>作为同步基准的一方</strong>，<strong>可以同时指定多个源文件路径</strong>。<strong>最后一个路径参数则是目标文件路径</strong>，也就是<strong>待同步方</strong>。路径的格式可以是<code>本地路径</code>，也可以是使用<code>user@host:path</code>或<code>user@host::path</code>的远程路径，如果主机和path路径之间使用<strong>单个冒号</strong>隔开，表示使用的是<strong>远程shell通信方式</strong>，而使用<strong>双冒号</strong>隔开的则表示的是连接<code>rsync daemon</code>。另外，连接<code>rsync daemon</code>时，还提供了<strong>URL格式</strong>的路径表述方式<code>rsync://user@host/path</code>。</li><li>如果<strong>仅有一个SRC或DEST参数</strong>，则将以类似于<code>&quot;ls -l&quot;</code>的方式<strong>列出源文件列表(只有一个路径参数，总会认为是源文件)，而不是复制文件</strong>。</li><li>另外，使用<code>rsync</code>一定要注意的一点是，源路径如果是一个目录的话，<strong>带上尾随斜线</strong>和<strong>不带尾随斜线</strong>是<strong>不一样</strong>的，<strong>不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身</strong>。</li></ul></div><hr><h2 id="rsync参数说明"><a href="#rsync参数说明" class="headerlink" title="rsync参数说明"></a>rsync参数说明</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-v</code></td><td><code>--verbose</code></td><td>显示rsync过程中详细信息，可以使用"-vvvv"获取更详细信息</td></tr><tr><td><code>-P</code></td><td></td><td>显示文件传输的进度信息(实际上"-P"="--partial --progress"，其中的"--progress"才是显示进度信息的)</td></tr><tr><td><code>-n</code></td><td><code>--dry-run</code></td><td>仅测试传输，而不实际传输，常和"-vvvv"配合使用来查看rsync是如何工作的</td></tr><tr><td><code>-a</code></td><td><code>--archive</code></td><td>归档模式，表示递归传输并保持文件属性，等同于"-rtopgDl"(不带-H,-A,-X)</td></tr><tr><td><code>-r</code></td><td><code>--recursive</code></td><td>递归</td></tr><tr><td><code>-t</code></td><td><code>--times</code></td><td>保持mtime属性。强烈建议任何时候都加上"-t"，否则目标文件mtime会设置为系统时间，导致下次更新检查出mtime不同从而导致增量传输无效</td></tr><tr><td><code>-o</code></td><td><code>--owner</code></td><td>保持owner属性(属主)</td></tr><tr><td><code>-g</code></td><td><code>--group</code></td><td>保持group属性(属组)</td></tr><tr><td><code>-p</code></td><td><code>--perms</code></td><td>保持perms属性(权限，不包括特殊权限)</td></tr><tr><td><code>-D</code></td><td></td><td>是"--device --specials"选项的组合，即也拷贝设备文件和特殊文件</td></tr><tr><td><code>-l</code></td><td><code>--links</code></td><td>如果文件是软链接文件，则会拷贝软链接，默认情况下会忽略链接的同步</td></tr><tr><td><code>-L</code></td><td><code>--copy-links</code></td><td>如果文件是软链接文件，则会拷贝软链接指向的文件或目录，而不是单纯的保留软链接形式，默认情况下会忽略链接的同步</td></tr><tr><td><code>-z</code></td><td></td><td>传输时进行压缩提高效率</td></tr><tr><td><code>-R</code></td><td><code>--relative</code></td><td>使用相对路径，意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例</td></tr><tr><td></td><td><code>--size-only</code></td><td>默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。</td></tr><tr><td><code>-u</code></td><td><code>--update</code></td><td>仅在源mtime比目标已存在文件的mtime新时才拷贝，注意，该选项是接收端判断的，不会影响删除行为</td></tr><tr><td><code>-d</code></td><td><code>--dirs</code></td><td>以不递归的方式拷贝目录本身，默认递归时，如果源为"dir1/file1"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1</td></tr><tr><td></td><td><code>--max-size</code></td><td>限制rsync传输的最大文件大小，可以使用单位后缀，还可以是一个小数值(例如："--max-size=1.5m")</td></tr><tr><td></td><td><code>--min-size</code></td><td>限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件</td></tr><tr><td></td><td><code>--exclude</code></td><td>指定排除规则来排除不需要传输的文件</td></tr><tr><td></td><td><code>--delete</code></td><td>以SRC为主，对DEST进行同步。多则删之，少则补之。注意"--delete"是在接收端执行的，所以它是在exclude/include规则生效之后才执行的</td></tr><tr><td><code>-b</code></td><td><code>--backup</code></td><td>对目标上已存在的文件做一个备份，备份的文件名后默认使用"~"做后缀</td></tr><tr><td></td><td><code>--backup-dir</code></td><td>指定备份文件的保存路径，不指定时默认和待备份文件保存在同一目录下</td></tr><tr><td><code>-e</code></td><td></td><td>指定所要使用的远程shell程序，默认为ssh，可以用来指定端口号</td></tr><tr><td></td><td><code>--port</code></td><td>连接daemon时使用的端口号，默认为873端口</td></tr><tr><td></td><td><code>--password-file</code></td><td>daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码</td></tr><tr><td><code>-W</code></td><td><code>--whole-file</code></td><td>rsync将不再使用增量传输，而是全量传输，在网络带宽高于磁盘带宽时，该选项比增量传输更高效</td></tr><tr><td></td><td><code>--existing</code></td><td>要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。</td></tr><tr><td></td><td><code>--ignore-existing</code></td><td>要求只更新目标端不存在的文件，和"--existing"结合使用有特殊功能，见下文示例</td></tr><tr><td></td><td><code>--remove-source-files</code></td><td>要求删除源端已经成功传输的文件</td></tr></table><hr><h2 id="rsync使用实例"><a href="#rsync使用实例" class="headerlink" title="rsync使用实例"></a>rsync使用实例</h2><h3 id="本地之间的同步"><a href="#本地之间的同步" class="headerlink" title="本地之间的同步"></a>本地之间的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将scp目录下的test.txt同步到当前目录中</span></span><br><span class="line"><span class="comment"># 默认是不会显示进度信息的，和scp不同</span></span><br><span class="line">rsync /home/user/learn/linux_learn/scp/test.txt ./</span><br></pre></td></tr></table></figure><div class="note info"><p>注意事项：</p><ul><li>只要目的端文件内容和源端不一样，就会触发数据同步，<code>rsync</code>会确保两边的文件内容一样</li><li>默认情况下，<strong><code>rsync</code>不会同步文件的“modify time”</strong>，凡是有数据同步的文件，<strong>目的端的文件的“modify time”总是会被修改为最新时刻的时间(同步发生的时间)</strong>，而默认情况下rsync会检查<strong>源文件和目标文件的大小</strong>、<strong>mtime(修改时间)是否一致，如果不一致则需要传输</strong>，这样时间发生改变会使得源文件和目的端文件内容总是不同，<strong>导致增量同步无效</strong></li><li><code>rsync</code><strong>不会太关注目的端文件的<code>rwx</code>权限</strong>，如果目的端<strong>没有</strong>此文件，那么权限会保持<strong>与源端一致</strong>；如果目的端<strong>有此文件</strong>，则权限<strong>不会随着源端变更</strong></li></ul></div><hr><h3 id="t-保持mtime属性"><a href="#t-保持mtime属性" class="headerlink" title="-t-保持mtime属性"></a>-t-保持mtime属性</h3><p>为了解决默认情况下rsync会将目的端同步文件的modify time修改为当前时间从而导致增量同步无效的问题，可以使用-t来在同步文件时保留mtime属性：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步，保留mtime属性</span></span><br><span class="line">rsync -r -v -t /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 时间和远程文件的保持一致</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行同步</span></span><br><span class="line"><span class="comment"># 因为时间戳是相同的，且文件内容也是相同的，所以不会进行再次同步</span></span><br><span class="line">rsync -r -v -t  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 129 bytes  received 13 bytes  284.00 bytes/sec</span><br><span class="line">total size is 271119920  speedup is 1909295.21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用-t参数</span></span><br><span class="line">rsync -r -v  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"><span class="comment"># 这里的时间就是当前时间</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 21:50 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 21:50 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行同步</span></span><br><span class="line"><span class="comment"># 因为时间戳是不同的，所以还会进行同步</span></span><br><span class="line">rsync -r -v  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"></span><br><span class="line">sent 271153227 bytes  received 51 bytes  180768852.00 bytes/sec</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意事项：</p><ul><li><code>-t</code>参数会保留远程(源端)文件的modify time属性，下次再进行同步时，如果远程文件没有修改，就不会再次同步，真正的增量同步</li><li>不加<code>-t</code>参数会使得当前文件的modify time为同步操作发生的时间，从而使得远程文件和当前文件的modify time一直不同，重复运行会一直同步，即使远程文件没有修改，这使得增量同步无效</li><li><strong>为了防止文件时间戳和大小一致，但是内容不一致的情况</strong>，可以使用<code>-I</code>参数：<strong>don’t skip files that match in size and mod-time</strong>，但是这<strong>会影响rsync的性能</strong></li></ul></div><hr><h3 id="a-归档模式"><a href="#a-归档模式" class="headerlink" title="-a-归档模式"></a>-a-归档模式</h3><p>rsync的<code>-a</code>选项是archive的意思，加了之后有以下作用：</p><ul><li>递归模式</li><li>同步软链接</li><li>同步权限</li><li>同步时间戳</li><li>同步属主和属组</li></ul><hr><h3 id="本地和远程同步"><a href="#本地和远程同步" class="headerlink" title="本地和远程同步"></a>本地和远程同步</h3><p>和<code>scp</code>命令一样，<code>rsync</code>也是<strong>默认使用的是22端口连接远程服务器</strong>，如果想要<strong>指定服务器端口</strong>需要使用<code>-e</code>来<strong>指定ssh连接参数</strong>，如<code>端口</code>、<code>连接的用户</code>、<code>ssh选项</code>等：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定端口为12000</span></span><br><span class="line">rsync -r -v -e <span class="string">"ssh -p 12000 "</span> wangjb@166.111.152.116:/Share/home/wangjb/user/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./</span><br><span class="line">wangjb@166.111.152.116<span class="string">'s password: </span></span><br><span class="line"><span class="string">receiving incremental file list</span></span><br><span class="line"><span class="string">B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sent 115306 bytes  received 66000 bytes  10988.24 bytes/sec</span></span><br><span class="line"><span class="string">total size is 271119851  speedup is 1495.37</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="r-递归同步文件夹内容"><a href="#r-递归同步文件夹内容" class="headerlink" title="-r-递归同步文件夹内容"></a>-r-递归同步文件夹内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将scp目录下的test目录及其内容递归地复制到当前目录中的test目录</span></span><br><span class="line">rsync -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><div class="note info"><p>使用<code>-r</code>选项，<code>rsync</code>会进入到文件夹里去检查，而<strong>不会只对文件夹本身做“quick check”的(检查文件夹的大小和时间戳)</strong></p></div><hr><h3 id="R-保留目录结构"><a href="#R-保留目录结构" class="headerlink" title="-R-保留目录结构"></a>-R-保留目录结构</h3><p>默认情况下，同步只是针对的最后指定的文件或者目录，上层目录不会进行同步，如果有时需要保留目录结构，可以使用-R参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-R会保留目录结构</span></span><br><span class="line">rsync -R -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能使用相对路径，如果使用会报错</span></span><br><span class="line">rsync -R -r ../scp/<span class="built_in">test</span> ./</span><br><span class="line">found <span class="string">".."</span> dir <span class="keyword">in</span> relative path: ../scp/<span class="built_in">test</span></span><br><span class="line">rsync error: syntax or usage error (code 1) at flist.c(2130) [sender=3.0.9]</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终生成的路径</span></span><br><span class="line">/home/user/learn/linux_learn/rsync/(当前目录)home/user/learn/linux_learn/scp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>由于不能使用相对路径，有时候我们并不需要从根目录进行保留目录结构，只希望<strong>保留一部分目录结构</strong>，这是<strong>可以使用<code>.</code>表示保留目录结构的起始位置</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从linux_learn开始保留目录结构</span></span><br><span class="line">rsync -R -r /home/user/learn/./linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终生成的路径</span></span><br><span class="line">/home/user/learn/linux_learn/rsync/(当前目录)linux_learn/scp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-R</code>参数表示<strong>使用相对路径</strong>，此<strong>相对路径是以目标目录为根的</strong>，例如<code>/home/user/learn/linux_learn/scp/test ./</code>表示使用当前目录来替换最开始的<code>/</code>目录</li><li><code>-R</code>指定的<strong>source目录必须使用绝对路径</strong>，不能使用相对路径</li><li><code>-R</code>可以指定<strong>保留部分目录结构</strong>，在完整的绝对路径中想要保留的目录结构之前加上<code>./</code>即可</li></ul></div><hr><h3 id="l-保留原始链接形式"><a href="#l-保留原始链接形式" class="headerlink" title="-l-保留原始链接形式"></a>-l-保留原始链接形式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程文件</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">lrwxrwxrwx. 1 user user        12 May  2 22:10 test2.txt -&gt; ../test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -v -t -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 默认会跳过链接文件</span></span><br><span class="line">skipping non-regular file <span class="string">"test/test2.txt"</span></span><br><span class="line"></span><br><span class="line">sent 271153253 bytes  received 54 bytes  180768871.33 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步，保留软连接</span></span><br><span class="line">rsync -v -t -r -l /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 保留软链接形式</span></span><br><span class="line"><span class="built_in">test</span>/test2.txt -&gt; ../test2.txt</span><br><span class="line"></span><br><span class="line">sent 271153269 bytes  received 57 bytes  180768884.00 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程文件</span></span><br><span class="line"><span class="comment"># 得到了和当前文件相同的软连接，相对路径的软连接会失效</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">lrwxrwxrwx. 1 user user        12 May  2 22:10 test2.txt -&gt; ../test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="L-复制链接指向的文件或目录"><a href="#L-复制链接指向的文件或目录" class="headerlink" title="-L-复制链接指向的文件或目录"></a>-L-复制链接指向的文件或目录</h3><p>上述的参数-l虽会保留软链接，但如果不是同一台机器以及链接不是使用的绝对路径都会使得链接失效，较为有效地做法是复制链接指向的文件，可以使用-L参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步，复制链接指向的文件或目录</span></span><br><span class="line">rsync -v -t -r -L /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 直接复制了链接指向的文件</span></span><br><span class="line"><span class="built_in">test</span>/test2.txt</span><br><span class="line"></span><br><span class="line">sent 271153307 bytes  received 73 bytes  180768920.00 bytes/sec</span><br><span class="line">total size is 271119935  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前文件</span></span><br><span class="line"><span class="comment"># 不再是链接，而是文件</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        15 May  2 22:09 test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–backup-已存在的目录备份"><a href="#–backup-已存在的目录备份" class="headerlink" title="–backup-已存在的目录备份"></a>–backup-已存在的目录备份</h3><p>如果在<strong>进行同步时希望保留当前的文件</strong>，可以使用<code>--backup</code>来进行备份，默认的备份文件使用”<code>~</code>“做后缀，可以使用<code>--suffix</code>指定备份后缀：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步的同时进行备份</span></span><br><span class="line">rsync -r --backup /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost <span class="built_in">test</span>]$ ll</span><br><span class="line">total 529536</span><br><span class="line"><span class="comment"># 默认的原始的文件使用了~</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:09 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 12:35 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart~</span><br></pre></td></tr></table></figure><p></p><p>指定原始文件的备份后缀：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--suffix指定备份文件的后缀</span></span><br><span class="line">rsync -r --backup --suffix <span class="string">".backup"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost <span class="built_in">test</span>]$ ll</span><br><span class="line">total 794304</span><br><span class="line"><span class="comment"># 设置了备份文件后缀为backup</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:11 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 12:35 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart~</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:09 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.backup</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–backup-dir-指定备份目录"><a href="#–backup-dir-指定备份目录" class="headerlink" title="–backup-dir-指定备份目录"></a>–backup-dir-指定备份目录</h3><p>将<strong>当前的文件备份到指定的目录中</strong>，而不是默认的当前目录，<strong>默认是不会给文件增加后缀的</strong>，可以<strong>使用<code>--suffix</code>指定备份后缀</strong>，注意<strong>必须和<code>--backup</code>一同使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前文件备份到backup目录下，如果目录不存在就创建</span></span><br><span class="line">rsync -r --backup --backup-dir ./backup /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定备份文件后缀</span></span><br><span class="line">rsync -r --backup --backup-dir ./backup --suffix <span class="string">".test"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–existing-只更新目标端存在的文件"><a href="#–existing-只更新目标端存在的文件" class="headerlink" title="–existing-只更新目标端存在的文件"></a>–existing-只更新目标端存在的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只更新当前目录下存在文件</span></span><br><span class="line">rsync -r --existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为当前目录下没有和test目录下共有的文件，所以没有进行同步</span></span><br></pre></td></tr></table></figure><p></p><p>在当前目录下创建一个和远程目录中相同的文件test.txt，并在远程的test.txt中写入内容，而当前目录的test.txt为空：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  1 23:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -r --existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现了相同文件的同步</span></span><br><span class="line">-rw-rw-r--. 1 user user 69 May  2 13:35 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–ignore-existing-只更新目标端不存在的文件"><a href="#–ignore-existing-只更新目标端不存在的文件" class="headerlink" title="–ignore-existing-只更新目标端不存在的文件"></a>–ignore-existing-只更新目标端不存在的文件</h3><p>和上面的<code>--existing</code>参数相反，<code>--ignore-existing</code>只更新当面不存在的文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:43 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -r --ignore-existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 已存在的test.txt没有更新</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:44 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user         0 May  2 13:43 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–remove-source-files-删除远程文件"><a href="#–remove-source-files-删除远程文件" class="headerlink" title="–remove-source-files-删除远程文件"></a>–remove-source-files-删除远程文件</h3><p>使用该选项后，<strong>远程已经更新成功的文件都会被删除</strong>，远程所有<strong>未传输或未传输成功的文件都不会被移除</strong>。未传输成功的原因有多种，如<code>exclude</code>排除了，<code>&quot;quick check&quot;</code>未选项该文件，传输中断等等。总之，显示在<code>&quot;rsync -v&quot;</code>被传输列表中的文件<strong>都会被移除</strong>。如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:43 test.txt</span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  1 23:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 同步完成之后删除远程已经同步好的文件</span></span><br><span class="line">rsync -r -v --ignore-existing --remove-source-files /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:50 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user         0 May  2 13:43 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line"><span class="comment"># 同步完成的文件被删除了</span></span><br><span class="line">-rw-rw-r--. 1 user user 69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–exclude-指定排除规则"><a href="#–exclude-指定排除规则" class="headerlink" title="–exclude-指定排除规则"></a>–exclude-指定排除规则</h3><p>上面使用<code>--existing</code>和<code>--ignore-existing</code>来仅对已经存在或者不存在的文件进行更新，实际上就是一种排除规则，如果希望对某一类文件的同步进行排除可以使用<code>--exclude</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 排除所有txt后缀文件</span></span><br><span class="line">rsync -r -v --exclude <span class="string">"*.txt"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"></span><br><span class="line">sent 271153093 bytes  received 32 bytes  180768750.00 bytes/sec</span><br><span class="line">total size is 271119851  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:01 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>一个<code>--exclude</code>只能指定一条规则</strong>，要<strong>指定多条排除规则</strong>，需要<strong>使用多个<code>--exclude</code>选项</strong>，或者将排除规则<strong>写入到文件中</strong>，然后使用<code>--exclude-from</code>选项读取该规则文件</li><li>除了<code>--exclude</code>排除规则，还有<code>--include</code>包含规则，顾名思义，它就是<strong>筛选出要进行传输的文件</strong>，所以<code>include</code>规则也称为传输规则。它的使用方法和<code>--exclude</code>一样。<strong>如果一个文件即能匹配排除规则，又能匹配包含规则，则先匹配到的立即生效，生效后就不再进行任何匹配</strong></li><li>最重要的一点是它的<strong>作用时间</strong>。当发送端敲出rsync命令后，rsync将立即扫描命令行中给定的文件和目录(扫描过程中还会按照目录进行排序，将同一个目录的文件放在相邻的位置)，这称为拷贝树(copy tree)，扫描完成后将待传输的文件或目录记录到文件列表中，然后将文件列表传输给接收端。而<strong>筛选规则的作用时刻是在扫描拷贝树时</strong>，所以会<strong>根据规则来匹配并决定文件是否记录到文件列表中(严格地说是会记录到文件列表中的，只不过排除的文件会被标记为hide隐藏起来)</strong>，只有记录到了文件列表中的文件或目录才是真正需要传输的内容。换句话说，<strong>筛选规则的生效时间在rsync整个同步过程中是非常靠前的，它会影响很多选项的操作对象，最典型的如<code>--delete</code></strong>。</li></ul></div><hr><h3 id="rsync中的匹配规则"><a href="#rsync中的匹配规则" class="headerlink" title="rsync中的匹配规则"></a>rsync中的匹配规则</h3><p>以下是rsync中的规则种类，不解之处请结合下文的<code>--delete</code>分析：</p><ul><li><p><code>exclude规则</code>：即<strong>排除规则</strong>，只作用于<strong>发送端</strong>，<strong>被排除的文件不会进入文件列表</strong>(实际上是加上隐藏规则进行隐藏)</p></li><li><p><code>include规则</code>：即<strong>包含规则</strong>，也称为传输规则，<strong>只作用于发送端</strong>，被包含的文件将明确记录到文件列表中</p></li><li><p><code>hide规则</code>：即<strong>隐藏规则</strong>，<strong>只作用于发送端</strong>，隐藏后的文件对于接收端来说是看不见的，<strong>也就是说接收端会认为它不存在于源端</strong></p></li><li><p><code>show规则</code>：即<strong>显示规则</strong>，<strong>只作用于发送端</strong>，<strong>是隐藏规则的反向规则</strong></p></li><li><p><code>protect规则</code>：即<strong>保护规则</strong>，该规则<strong>只作用于接收端</strong>，<strong>被保护的文件不会被删除掉</strong></p></li><li><p><code>risk规则</code>：即<strong>取消保护规则</strong>，<strong>是protect的反向规则</strong></p></li></ul><p>除此之外，还有一种规则是<code>clear规则</code>，作用是<strong>删除include/exclude规则列表</strong></p><hr><h3 id="–delete-得到和远程目录完全相同的目录"><a href="#–delete-得到和远程目录完全相同的目录" class="headerlink" title="–delete-得到和远程目录完全相同的目录"></a>–delete-得到和远程目录完全相同的目录</h3><p>使用”–delete”选项后，接收端的rsync会先删除目标目录(当前目录)下已经存在，但源端(远程)目录不存在的文件，也就是”多则删之，少则补之”：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 14:17 test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 先删除当前目录中存在但是远程目录不存在的文件，然后进行同步</span></span><br><span class="line">rsync -r --delete -v /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line">deleting <span class="built_in">test</span>/test2.txt</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"></span><br><span class="line">sent 271153227 bytes  received 51 bytes  108461311.20 bytes/sec</span><br><span class="line">total size is 271119920  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># test2.txt已经被删除</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:19 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br></pre></td></tr></table></figure><p></p><p><code>--delete</code>与<code>--exclude</code>联用，<code>--exclude</code>可以将某些文件排除在同步文件之外，而这些文件在被排除在同步文件之外后，当前目录存在的这些被排除的文件会不会被<code>--delete</code>删除是关键？结果是<mark><code>--exclude</code>排除的文件不会被<code>--delete</code>删除</mark>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:19 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 排除所有txt后缀的文件</span></span><br><span class="line"><span class="comment"># 也就是说不会对当前目录中的txt文件依据远程文件进行同步</span></span><br><span class="line">rsync -v -r --delete --exclude <span class="string">"*.txt"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"></span><br><span class="line">sent 271153093 bytes  received 32 bytes  180768750.00 bytes/sec</span><br><span class="line">total size is 271119851  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 虽然txt文件没有没同步， 但是也没有被删除</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 18:37 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于<code>--exclude</code>排除的文件不会被<code>--delete</code>删除的原理请参考<a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">这篇文章</a></p></div><p><code>--delete</code>与<code>--existing</code>和<code>--ignore-existing</code>结合使用时，<strong>文件不会被传输</strong>，<strong>但会删除receiver端额外多出的文件</strong>，<u>个人理解其过程可能是先<code>--existing</code>得到的传输文件列表中都是当前文件和远程共有的文件，再次使用<code>--ignore-existing</code>时是仅传输不存在的文件，此时的文件列表不包含当前目录不存在的文件，所以不会进行传输，<code>--delete</code>会进行删除操作</u>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">$ mkdir a b</span><br><span class="line">$ touch a/&#123;1..4&#125;.txt</span><br><span class="line">$ touch b/a.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--delete</span></span><br><span class="line">$ rsync -nrv --delete a/ b/</span><br><span class="line">sending incremental file list</span><br><span class="line">deleting a.log</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"> </span><br><span class="line">sent 118 bytes  received 33 bytes  302.00 bytes/sec</span><br><span class="line">total size is 0  speedup is 0.00 (DRY RUN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--delete并结合--existing、--ignore-existing</span></span><br><span class="line">$ rsync -nrv --existing --ignore-existing --delete a/ b/</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="comment"># 只进行了删除操作</span></span><br><span class="line">deleting a.log</span><br><span class="line"> </span><br><span class="line">sent 106 bytes  received 21 bytes  254.00 bytes/sec</span><br><span class="line">total size is 0  speedup is 0.00 (DRY RUN)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–max-size-不传输大文件"><a href="#–max-size-不传输大文件" class="headerlink" title="–max-size-不传输大文件"></a>–max-size-不传输大文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同步大于100M的文件</span></span><br><span class="line">rsync -v -t -r --max-size <span class="string">"100m"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 忽略了链接文件</span></span><br><span class="line">skipping non-regular file <span class="string">"test/test2.txt"</span></span><br><span class="line"></span><br><span class="line">sent 267 bytes  received 35 bytes  604.00 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 897748.12</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">第2章 rsync(一)：基本命令和用法</a></li><li><a href="http://man.linuxde.net/rsync" target="_blank" rel="noopener">rsync命令</a></li><li><a href="http://roclinux.cn/?p=2643" target="_blank" rel="noopener">《rsync同步的艺术》–linux命令五分钟系列之四十二</a></li><li><a href="https://www.linuxprobe.com/rsync-use-sample.html" target="_blank" rel="noopener">rsync 使用示例</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中进行&lt;strong&gt;远程数据同步的命令rsync&lt;/strong&gt;，相比于功能相近的&lt;a href=&quot;http://showteeth.tech/posts/2539.html&quot;&gt;scp命令&lt;/a&gt;，其可以实现&lt;strong&gt;增量同步&lt;/strong&gt;；主要学习了&lt;code&gt;本地目录之间的同步&lt;/code&gt;、&lt;code&gt;本地与远程之间的同步&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-R&lt;/code&gt;、&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-L&lt;/code&gt;、&lt;code&gt;--backup&lt;/code&gt;、&lt;code&gt;--backup-dir&lt;/code&gt;、&lt;code&gt;--existing&lt;/code&gt;、&lt;code&gt;--ignore-existing&lt;/code&gt;、&lt;code&gt;--remove-source-files&lt;/code&gt;、&lt;code&gt;--exclude&lt;/code&gt;、&lt;code&gt;--delete&lt;/code&gt;、&lt;code&gt;--max-size&lt;/code&gt;等参数。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>scp-跨平台复制命令</title>
    <link href="http://showteeth.tech/posts/2539.html"/>
    <id>http://showteeth.tech/posts/2539.html</id>
    <published>2019-05-01T02:16:40.000Z</published>
    <updated>2019-05-02T00:42:16.981Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中用于<strong>远程复制命令scp</strong>，其主要功能包括：<strong>复制远程文件到当前服务器文件或目录</strong>、<strong>复制远程目录到当前服务器目录</strong>、<strong>复制当前文件到远程服务器文件或目录</strong>、<strong>复制当前目录到远程目录</strong>，其中重要和常用的参数是<code>-P</code>、<code>-r</code>；<strong>需要特别注意<code>scp</code>和<code>cp</code>以及<code>rsnyc</code>命令的区别</strong>。</p></div><a id="more"></a><h2 id="scp命令简介"><a href="#scp命令简介" class="headerlink" title="scp命令简介"></a>scp命令简介</h2><p><code>scp</code>是<code>secure copy</code>的简写，用于在Linux下进行<strong>远程拷贝文件</strong>的命令，和它类似的命令有<code>cp</code>，不过 <strong><code>cp</code>只是在本机进行拷贝不能跨服务器</strong>，而且<strong>scp传输是加密的</strong>。当<strong>你服务器硬盘变为只读 <code>read only system</code>时，用scp可以帮你把文件移出来</strong>。</p><p>与<code>scp</code>命令类似的工具有<a href="http://showteeth.tech/posts/8376.html">rsync</a>，两者的功能类似，但是<strong>区别主要表现在资源占用和速度上</strong>：</p><ul><li><strong><code>scp</code>消耗资源少，不会提高多少系统负荷</strong>，在这一点上，<code>rsync</code>就远远不及它了</li><li><strong><code>rsync</code>比<code>scp</code>会快一点，但当小文件多的情况下，<code>rsync</code>会导致硬盘<code>I/O</code>非常高，而<code>scp</code>基本不影响系统正常使用</strong></li></ul><hr><h2 id="scp命令格式"><a href="#scp命令格式" class="headerlink" title="scp命令格式"></a>scp命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">Usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure><hr><h2 id="scp参数说明"><a href="#scp参数说明" class="headerlink" title="scp参数说明"></a>scp参数说明</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>-1</code></td><td>强制scp命令使用协议ssh1</td></tr><tr><td><code>-2</code></td><td>强制scp命令使用协议ssh2</td></tr><tr><td><code>-4</code></td><td>强制scp命令只使用IPv4寻址</td></tr><tr><td><code>-6</code></td><td>强制scp命令只使用IPv6寻址</td></tr><tr><td><code>-B</code></td><td>使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td><code>-C</code></td><td>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</td></tr><tr><td><strong><code>-p</code></strong></td><td>保留原文件的修改时间，访问时间和访问权限</td></tr><tr><td><code>-q</code></td><td>不显示传输进度条</td></tr><tr><td><strong><code>-r</code></strong></td><td>递归复制整个目录</td></tr><tr><td><strong><code>-v</code></strong></td><td>详细方式显示输出，scp和ssh(1)会显示出整个过程的调试信息，这些信息用于调试连接，验证和配置问题</td></tr><tr><td><code>-c</code></td><td><code>cipher</code> 以cipher将数据传输进行加密，这个选项将直接传递给ssh</td></tr><tr><td><code>-F</code></td><td><code>ssh_config</code> 指定一个替代的ssh配置文件，此参数直接传递给ssh</td></tr><tr><td><code>-i</code></td><td><code>identity_file</code> 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</td></tr><tr><td><code>-l</code></td><td><code>limit</code> 限定用户所能使用的带宽，以Kbit/s为单位</td></tr><tr><td><code>-o</code></td><td><code>ssh_option</code> 如果习惯于使用ssh_config(5)中的参数传递方式</td></tr><tr><td><code>-S</code></td><td><code>program</code> 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项</td></tr><tr><td><strong><code>-P</code></strong></td><td><code>port</code> 注意是大写的P, port是指定数据传输用到的端口号</td></tr></table><hr><h2 id="scp具体使用"><a href="#scp具体使用" class="headerlink" title="scp具体使用"></a>scp具体使用</h2><h3 id="本地到远程"><a href="#本地到远程" class="headerlink" title="本地到远程"></a>本地到远程</h3><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p><strong>命令形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用形式</span></span><br><span class="line">scp [可选参数] source_file remote_username@remote_ip:target_file_or_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中指定传输目的服务器username</span></span><br><span class="line"><span class="comment"># 复制到文件夹，文件名称保持不变</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_username@remote_ip:remote_folder</span><br><span class="line"><span class="comment"># 复制到文件，复制并改名</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_username@remote_ip:remote_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中不指定传输目的服务器username</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_ip:remote_folder</span><br><span class="line"><span class="variable">$scp</span> local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>如果<strong>在命令中指定了目的服务器的用户名</strong>，命令执行后只需要<strong>输入对应的用户密码</strong>；</li><li>如果在命令中<strong>不指定目的服务器的用户名</strong>，命令执行后<strong>默认的用户名和当前服务器的用户名相同</strong>，<strong>输入密码</strong></li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接这么写会报错</span></span><br><span class="line">scp B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp</span><br></pre></td></tr></table></figure><p>直接按照上面的写法会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host 166.111.152.101 port 22: Connection refused</span><br><span class="line">lost connection</span><br></pre></td></tr></table></figure><p></p><p>出错原因是没有指定port，而<mark>scp默认的port是22，如果端口号不是22的话就会出错</mark>，可以<strong>使用<code>-P</code>来指定端口号</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-P指定端口</span></span><br><span class="line"><span class="comment"># 如果端口不是22</span></span><br><span class="line"><span class="comment"># 复制到文件夹，文件名称保持不变</span></span><br><span class="line">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp </span><br><span class="line"><span class="comment"># 需要输入目的服务器username的密码</span></span><br><span class="line">username@166.111.152.101<span class="string">'s password:  </span></span><br><span class="line"><span class="string"># 显示传输进度 </span></span><br><span class="line"><span class="string">B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart                                                                         100%  259MB   8.6MB/s   00:30</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 复制到文件，相当于复制并且修改文件名称</span></span><br><span class="line"><span class="string">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp/test.txt</span></span><br></pre></td></tr></table></figure><p></p><p><strong>不指定目的服务器的用户名，那么默认目的服务器用户名和当前服务器用户名相同</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令中没有指定用户名</span></span><br><span class="line">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart 166.111.152.101:/home/username/learn/linux_learn/scp/test.txt</span><br><span class="line"><span class="comment"># 默认的用户名和当前服务器用户名相同</span></span><br><span class="line">local_username@166.111.152.101<span class="string">'s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># local_username和username不同，导致了权限错误</span></span><br><span class="line"><span class="string">scp: /home/username/learn/linux_learn/scp/test.txt: Permission denied</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h4><p>使用<code>-r</code>参数来进行递归复制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令中指定目的服务器的username</span></span><br><span class="line"><span class="variable">$scp</span> -r local_folder remote_username@remote_ip:remote_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在命令中指定目的服务器的username，默认和当前服务器的username相同</span></span><br><span class="line"><span class="variable">$scp</span> -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure><p></p><h3 id="远程到本地"><a href="#远程到本地" class="headerlink" title="远程到本地"></a>远程到本地</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用形式</span></span><br><span class="line"><span class="comment"># 其实就是将前面的scp后面接着的远程和本地文件换个位置</span></span><br><span class="line">scp [可选参数] remote_username@remote_ip:source_file target_file_or_folder</span><br></pre></td></tr></table></figure><h4 id="复制文件-1"><a href="#复制文件-1" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制到本地目录</span></span><br><span class="line">scp -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到本地文件，相当于复制并改名</span></span><br><span class="line">scp -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./test.txt</span><br></pre></td></tr></table></figure><hr><h4 id="复制目录-1"><a href="#复制目录-1" class="headerlink" title="复制目录"></a>复制目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-r参数来进行递归复制</span></span><br><span class="line">scp -r -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html" target="_blank" rel="noopener">scp 跨机远程拷贝</a></li><li><a href="https://www.cnblogs.com/peida/archive/2013/03/15/2960802.html" target="_blank" rel="noopener">每天一个linux命令（60）：scp命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中用于&lt;strong&gt;远程复制命令scp&lt;/strong&gt;，其主要功能包括：&lt;strong&gt;复制远程文件到当前服务器文件或目录&lt;/strong&gt;、&lt;strong&gt;复制远程目录到当前服务器目录&lt;/strong&gt;、&lt;strong&gt;复制当前文件到远程服务器文件或目录&lt;/strong&gt;、&lt;strong&gt;复制当前目录到远程目录&lt;/strong&gt;，其中重要和常用的参数是&lt;code&gt;-P&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;；&lt;strong&gt;需要特别注意&lt;code&gt;scp&lt;/code&gt;和&lt;code&gt;cp&lt;/code&gt;以及&lt;code&gt;rsnyc&lt;/code&gt;命令的区别&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>read-从键盘或文件中获取输入</title>
    <link href="http://showteeth.tech/posts/59492.html"/>
    <id>http://showteeth.tech/posts/59492.html</id>
    <published>2019-04-30T14:06:36.000Z</published>
    <updated>2019-05-01T02:14:08.525Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><code>read</code>是linux中<strong>获取键盘或文件输入</strong>并将<strong>结果保存在若干变量或数组中的命令</strong>，其主要参数包括：<code>-p</code>、<code>-a</code>、<code>-d</code>、<code>-e</code>、<code>-i</code>、<code>-s</code>、<code>-t</code>、<code>-n</code>、<code>-r</code>、<code>-u</code>；需要特别注意这里学习的关于<strong>使用管道符读取文件</strong>时涉及到的<strong>自定义变量生命周期</strong>的问题。</p></div><a id="more"></a><h2 id="read命令简介"><a href="#read命令简介" class="headerlink" title="read命令简介"></a>read命令简介</h2><p><code>read</code>命令可以<strong>获取键盘或者文件输入</strong>并<strong>赋值给变量或数组</strong>。</p><hr><h2 id="read命令格式"><a href="#read命令格式" class="headerlink" title="read命令格式"></a>read命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage: </span><br><span class="line">  <span class="built_in">read</span> [-ers] [-a array] [-d delim] </span><br><span class="line">       [-i text] [-n nchars] [-N nchars] </span><br><span class="line">       [-p prompt] [-t timeout] [-u fd] [name ...]</span><br></pre></td></tr></table></figure><hr><h2 id="read参数说明"><a href="#read参数说明" class="headerlink" title="read参数说明"></a>read参数说明</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>-a</code></td><td>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符</td></tr><tr><td><code>-d</code></td><td>后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。</td></tr><tr><td><code>-p</code></td><td>后面跟提示信息，即在输入前打印提示信息。</td></tr><tr><td><code>-e</code></td><td>在输入的时候可以使用命令补全功能。</td></tr><tr><td><code>-i</code></td><td>设置默认用于补全的prefix，必须和前面的<code>-e</code>一同使用才有用</td></tr><tr><td><code>-n</code></td><td>后跟一个数字，定义输入文本的长度，很实用。</td></tr><tr><td><code>-r</code></td><td>屏蔽<code>\</code>，如果没有该选项，则<code>\</code>作为一个转义字符(续行)，有的话<code>\</code>就是个正常的字符了。</td></tr><tr><td><code>-s</code></td><td>安静模式，在输入字符时不在屏幕上显示，例如login时输入密码。</td></tr><tr><td><code>-t</code></td><td>后面跟秒数，定义输入字符的等待时间。</td></tr><tr><td><code>-u</code></td><td>后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</td></tr></table><hr><h2 id="read用法实例"><a href="#read用法实例" class="headerlink" title="read用法实例"></a>read用法实例</h2><h3 id="默认读取"><a href="#默认读取" class="headerlink" title="默认读取"></a>默认读取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下echo输出内容之后会换行</span></span><br><span class="line"><span class="comment"># -n参数可以不换行</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"please input your name:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取键盘输入，并保存在name变量中</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出变量并正常退出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line">  please input your name:<span class="built_in">test</span></span><br><span class="line">  welcome !!! <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>如果在read之后<strong>没有使用参数进行接收键盘输入</strong>，则读取的值会<strong>存放在一个叫作 <code>$REPLY</code> 的环境变量中</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 没有指定接收键盘输入的变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name and place:"</span></span><br><span class="line"><span class="comment"># 默认会存放在$REPLY中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome <span class="variable">$REPLY</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh test_2.sh </span><br><span class="line"><span class="comment"># 还是能正常输出</span></span><br><span class="line">please input your name and place:<span class="built_in">test</span></span><br><span class="line">welcome <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="p-输入提示语"><a href="#p-输入提示语" class="headerlink" title="-p-输入提示语"></a>-p-输入提示语</h3><p>上面为了达到输入提示语的效果借助了<code>echo</code>命令，其实<code>read</code>命令的参数<code>-p</code>可以起到<strong>输入提示语</strong>的效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo  -n "please input your name:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p参数替换echo进行输入提示</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name:"</span>  name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 效果和使用echo是一样的</span></span><br><span class="line">  please input your name:<span class="built_in">test</span></span><br><span class="line">  welcome !!! <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="一次读入多个变量"><a href="#一次读入多个变量" class="headerlink" title="一次读入多个变量"></a>一次读入多个变量</h3><p>变量的数目是根据read定义的变量数目决定的：</p><ul><li>read后面变量数目等于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read后面有两格变量name和city，所以可以读取两个变量</span></span><br><span class="line"><span class="comment"># 使用空格分隔变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name and city: "</span>  name city</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span> from <span class="variable">$city</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入两个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 传递给name和city变量</span></span><br><span class="line">  please input your name and city: <span class="built_in">test</span> beijing</span><br><span class="line">  welcome !!! <span class="built_in">test</span> from beijing</span><br></pre></td></tr></table></figure><p></p><ul><li>read后面变量数目小于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入三个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 第一个空格分隔的字符传递给name，剩下的传递给另一个变量</span></span><br><span class="line">please input your name and city: <span class="built_in">test</span> beijing haidian</span><br><span class="line">welcome !!! <span class="built_in">test</span> from beijing haidian</span><br></pre></td></tr></table></figure><ul><li>read后面变量数目大于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入一个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 字符传递给第一个变量name，剩下的变量为空</span></span><br><span class="line">please input your name and city: <span class="built_in">test</span></span><br><span class="line">welcome !!! <span class="built_in">test</span> from</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>如果read后面的参数数目<strong>等于</strong>键盘输入的空格分隔的字符数目，则<strong>参数和输入一一对应</strong></li><li>如果read后面的参数数目<strong>大于</strong>键盘输入的空格分隔的字符数目，则<strong>不足的参数为空</strong></li><li>如果read后面的参数数目<strong>小于</strong>键盘输入的空格分隔的字符数目，则<strong>多余的空格分隔的字符赋值在最后一个变量</strong></li></ul></div><hr><h3 id="a-数组变量"><a href="#a-数组变量" class="headerlink" title="-a-数组变量"></a>-a-数组变量</h3><p>默认情况下，read将读取的字符存储在不同的变量中，如果想要储存在<a href="http://showteeth.tech/posts/46714.html">数组</a>中，可以使用-a参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -a参数后面是指定的存储数组的变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"get var by array: "</span> -a  array</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"print <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh a.sh </span><br><span class="line">  get var by array: as ad af</span><br><span class="line">  <span class="built_in">print</span> as</span><br><span class="line">  <span class="built_in">print</span> ad</span><br><span class="line">  <span class="built_in">print</span> af</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="d-指定读取结束字符"><a href="#d-指定读取结束字符" class="headerlink" title="-d-指定读取结束字符"></a>-d-指定读取结束字符</h3><p>如果希望使用特定的字符来控制读取停止位置，可以使用-d参数，注意之后-d后面指定字符的第一个字符有用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里-d参数指定了end字符</span></span><br><span class="line"><span class="comment"># 其实只有开头的e起到作用了</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"get var by array: "</span> -d end -a array</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"print <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh d.sh </span><br><span class="line"><span class="comment"># 输入的时候遇到e字符就会停止接收</span></span><br><span class="line"><span class="comment"># 然后直接执行后面的输出</span></span><br><span class="line">get var by array: ads ada eprint ads</span><br><span class="line"><span class="built_in">print</span> ada</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="t-输入等待时间"><a href="#t-输入等待时间" class="headerlink" title="-t-输入等待时间"></a>-t-输入等待时间</h3><p>设置输入等待时间，如果长时间不输入，read命令返回一个<strong>非零退出状态</strong>，可以结合<code>if</code>命令进行处理：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -t 5 -p <span class="string">"please input your name within 5s:"</span> name</span><br><span class="line"><span class="comment"># 输出read命令的退出状态</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"></span><br><span class="line"><span class="comment"># if命令本来就是判断条件测试语句的退出状态</span></span><br><span class="line"><span class="comment"># 如果非零则执行else的结果</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">"please input your name within 5s:"</span> name</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"sorry, too slow"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test_t.sh </span><br><span class="line"><span class="comment"># 不进行输入，返回退出状态为142</span></span><br><span class="line">please input your name within 5s:142</span><br><span class="line"><span class="comment"># 使用if条件测试进行处理，输出自定义的内容</span></span><br><span class="line">please input your name within 5s:sorry, too slow</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-输入内容不显示"><a href="#s-输入内容不显示" class="headerlink" title="-s-输入内容不显示"></a>-s-输入内容不显示</h3><p>默认的read会将输入显示在屏幕上，而在输入时可能会遇到一些信息不希望被人看到，这时可以使用<code>-s</code>参数(实际上，数据是显示的，只是 read 命令将<strong>文本颜色设置成与背景相同的颜色</strong>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 使用-s参数来不显示屏幕输入内容</span></span><br><span class="line"><span class="built_in">read</span> -s -p <span class="string">"please input your code:"</span> password</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hehe, your password is <span class="variable">$password</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test_s.sh </span><br><span class="line"><span class="comment"># 注意这里不会换行</span></span><br><span class="line">please input your code:hehe, your password is <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-输入字符长度"><a href="#n-输入字符长度" class="headerlink" title="-n-输入字符长度"></a>-n-输入字符长度</h3><p>read可以使用-n参数来控制读取的输入字符长度，当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -n 1 -p <span class="string">"Do you want to continue [Y/N]?"</span> answer</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span></span><br><span class="line">Y | y)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"fine ,continue"</span>;;</span><br><span class="line">N | n)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"ok,good bye"</span>;;</span><br><span class="line">*)</span><br><span class="line">     <span class="built_in">echo</span> <span class="string">"error choice"</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./n.sh </span><br><span class="line"><span class="comment"># 本来准备输入yes，但是输入y之后就默认指定后面的echo命令</span></span><br><span class="line"><span class="comment"># 压根没有给输入yes的可能性</span></span><br><span class="line">Do you want to <span class="built_in">continue</span> [Y/N]?yfine ,<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>输入长度达到<code>-n</code>指定的长度之后<strong>立即停止接受输入</strong>，并<strong>执行后续的命令</strong>，<strong>不管是不是还在输入</strong>.</p></div><hr><h3 id="u-读取文件内容"><a href="#u-读取文件内容" class="headerlink" title="-u-读取文件内容"></a>-u-读取文件内容</h3><p>读取文件内容常常使用在循环中：</p><ul><li>使用文件操作符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成了编号为 3 的文件描述符</span></span><br><span class="line"><span class="comment"># 这个编号可以自定义，默认的1和2分别为标准输出和标准错误输出</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt; test.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用-u 3来读取文件内容</span></span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -u 3 var</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 使用了命令计算并赋值</span></span><br><span class="line">        <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭3号文件描述符</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&amp;-</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./u_1.sh </span><br><span class="line">  Line 1:19248</span><br><span class="line">  Line 2:19247</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 3</span><br></pre></td></tr></table></figure><p></p><ul><li>使用管道：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="comment"># 这里使用了管道而不是上面的文件描述符</span></span><br><span class="line"><span class="comment"># 使用更为简单</span></span><br><span class="line">cat test.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sh u_2.sh </span><br><span class="line">  Line 1:19248</span><br><span class="line">  Line 2:19247</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  <span class="comment"># 注意这里的line的计数为1，而不是3</span></span><br><span class="line">  Line no is 1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>上面最后<strong>输出的line计数为1而不是实际的3</strong>是由于管道导致的。我们知道，<strong>管道的两边一般需要新建进程</strong>，当执行完 while 语句后，新进程也就结束了，而脚本中 count 是新进程中的自定义变量，<strong>进程结束后该变量也就消失了（自定义变量的生命周期结束）</strong>。当脚本<strong>执行 echo 时，显示的 count 变量是脚本中第一行定义的变量的值，而不是 while 语句中的那个 count 变量了</strong>，因而输出的结果当然就是 1 了。</p></div><ul><li>重定向：</li></ul><p>为了使用简单(不使用文件描述符)，而又需要避免管道带来的问题，可以使用重定向：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line"><span class="comment"># 这里使用了重定向，形式为cmd &lt; file</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line 1:19248</span><br><span class="line">Line 2:19247</span><br><span class="line">Line 3:19246</span><br><span class="line">finished</span><br><span class="line"><span class="comment"># 这里输出了正确的结果3</span></span><br><span class="line">Line no is 3</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="r-屏蔽转移和续行"><a href="#r-屏蔽转移和续行" class="headerlink" title="-r-屏蔽转移和续行"></a>-r-屏蔽转移和续行</h3><p>常规情况下，在文件中使用<code>\</code>可以表示续行操作，这样在读取文件的时候也会将其当做续行符，从而将多行文本当成一行文本：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改test.txt文件，加入续行符</span></span><br><span class="line">cat test.txt </span><br><span class="line">  19248 \</span><br><span class="line">  19247 \</span><br><span class="line">  19246</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行前面的读取文件命令</span></span><br><span class="line">sh u_3.sh </span><br><span class="line">  <span class="comment"># 读取的结果都在同一行</span></span><br><span class="line">  Line 1:19248 19247 19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 1</span><br></pre></td></tr></table></figure><p></p><p>如果需要忽略续行符<code>\</code>，可以使用read的<code>-r</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=0</span><br><span class="line"><span class="comment"># 加入-r参数表示忽略续行符</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line"><span class="comment"># 这里使用了重定向，形式为cmd &lt; file</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sh u_4.sh </span><br><span class="line">  <span class="comment"># 忽略了续行符</span></span><br><span class="line">  <span class="comment"># 当做3行读取</span></span><br><span class="line">  Line 1:19248 \</span><br><span class="line">  Line 2:19247 \</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 3</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="e-输入补全"><a href="#e-输入补全" class="headerlink" title="-e-输入补全"></a>-e-输入补全</h3><p>在输入时进行tab补全功能：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -e -p <span class="string">"输入文件名:"</span> str </span><br><span class="line">输入文件名:<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 上面输入test之后按下两次tab键就可以输出当前目录下匹配test的文件信息</span></span><br><span class="line">test.sh    test_s.sh  test_t.sh  test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="i-设置默认用于补全的prefix"><a href="#i-设置默认用于补全的prefix" class="headerlink" title="-i-设置默认用于补全的prefix"></a>-i-设置默认用于补全的prefix</h3><p>如果需要给变量设置<strong>默认用于补全的prefix</strong>，自动进行填充，需要使用read的<code>-i</code>参数，注意这<strong>个必须结合<code>-e</code>参数进行使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认的prefix</span></span><br><span class="line"><span class="comment"># 自动填充到输入，再结合tab进行补全</span></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"test"</span></span><br><span class="line"><span class="comment"># -i必须结合-e参数一同使用</span></span><br><span class="line"><span class="built_in">read</span> -e -i <span class="string">"<span class="variable">$test</span>"</span> -p <span class="string">"please input your name: "</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh i.sh </span><br><span class="line"><span class="comment"># 与前面单独使用-e不同的是，这里的test是自动填充的prefix</span></span><br><span class="line">please input your name: <span class="built_in">test</span></span><br><span class="line">test.sh    test_s.sh  test_t.sh  test.txt</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.runoob.com/linux/linux-comm-read.html" target="_blank" rel="noopener">Linux read 命令</a></li><li><a href="http://c.biancheng.net/linux/read.html" target="_blank" rel="noopener">read命令_Linux read命令：读取从键盘或文件输入的数据</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;read&lt;/code&gt;是linux中&lt;strong&gt;获取键盘或文件输入&lt;/strong&gt;并将&lt;strong&gt;结果保存在若干变量或数组中的命令&lt;/strong&gt;，其主要参数包括：&lt;code&gt;-p&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;；需要特别注意这里学习的关于&lt;strong&gt;使用管道符读取文件&lt;/strong&gt;时涉及到的&lt;strong&gt;自定义变量生命周期&lt;/strong&gt;的问题。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>time-计算命令执行花费的时间</title>
    <link href="http://showteeth.tech/posts/21450.html"/>
    <id>http://showteeth.tech/posts/21450.html</id>
    <published>2019-04-25T15:22:52.000Z</published>
    <updated>2019-04-25T16:18:08.781Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>计算命令执行花费的时间</strong>的命令<code>time</code>，其输出包括三个时间<code>real</code>、<code>user</code> 和 <code>sys</code>，其中real是最终花费的时间；一般情况下<code>real=user+sys</code>，但如果命令是多核执行，也有可能是<code>real_time&lt;user_time+sys_time</code>，同时由于<code>usr time+sys time</code><strong>不包括其他进程的执行时间和进程阻塞时间的</strong>，所以<code>real_time&gt;user_time+sys_time</code>也是非常有可能的；最后<strong>前后两次执行同一个命令，输出的时间可能不同</strong>，这是因为<strong>第一次执行命令系统会建立缓存</strong>使得第二次执行的时间缩短。</p></div><a id="more"></a><h2 id="time命令简介"><a href="#time命令简介" class="headerlink" title="time命令简介"></a>time命令简介</h2><p>time命令用于统计执行指定命令所花费的总时间。</p><hr><h2 id="time命令格式"><a href="#time命令格式" class="headerlink" title="time命令格式"></a>time命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time <span class="built_in">command</span></span><br></pre></td></tr></table></figure><hr><h2 id="time使用讲解"><a href="#time使用讲解" class="headerlink" title="time使用讲解"></a>time使用讲解</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time ls</span><br><span class="line">test1.txt  test2.txt</span><br><span class="line"></span><br><span class="line">real0m0.002s</span><br><span class="line">user0m0.001s</span><br><span class="line">sys0m0.001s</span><br></pre></td></tr></table></figure><p>执行<code>time ls</code>之后会得到三个输出，<code>real</code>、<code>user</code> 和 <code>sys</code>，它们都代表什么含义呢？哪个才是 <code>ls</code> 命令的执行时间呢？下面我们就一起来看看这三个统计时间：</p><ul><li><code>real</code>：<strong>从进程 <code>ls</code> 开始执行到完成所耗费的 CPU 总时间</strong>。该时间包括 <strong><code>ls</code> 进程执行时实际使用的 CPU 时间</strong>，<strong><code>ls</code> 进程耗费在阻塞上的时间（如等待完成 I/O 操作）</strong>和<strong>其他进程所耗费的时间（Linux 是多进程系统，ls 在执行过程中，可能会有别的进程抢占 CPU）</strong>。</li><li><code>user</code>：进程 <code>ls</code> 执行<mark>用户态</mark>代码所耗费的 CPU 时间。该时间<strong>仅指 ls 进程执行时实际使用的 CPU 时间</strong>，而<strong>不包括其他进程所使用的时间和本进程阻塞的时间</strong>。</li><li><code>sys</code>：进程 <code>ls</code> 在<mark>内核态</mark>运行所耗费的 CPU 时间，即<strong>执行内核系统调用所耗费的 CPU 时间</strong>。</li></ul><div class="note info"><p>关于<strong>用户态</strong>和<strong>内核态</strong>：</p><ul><li>在内核态，代码拥有完全的，不受任何限制的访问底层硬件的能力。可以执行任意的CPU指令，访问任意的内存地址。内核态通常情况下，都是为那些最底层的，由操作系统提供的，可信可靠的代码来运行的。内核态的代码崩溃将是灾难性的，它会影响到整个系统。</li><li>在用户态，代码不具备直接访问硬件或者访问内存的能力，而必须借助操作系统提供的可靠的，底层的APIs来访问硬件或者内存。由于这种隔离带来的保护作用，用户态的代码崩溃（Crash），系统是可以恢复的。我们大多数的代码都是运行在用户态的。</li></ul></div><p>现在，我们应该对这三个时间非常清楚了吧。<code>ls</code> 命令的真正执行时间是多少？答案就是 <code>user+sys</code> 的时间，但<mark>一般情况下</mark>，<code>real=user+sys</code>，因而我们就<strong>使用 <code>real</code> 的时间作为 <code>ls</code> 的执行时间了</strong>（注意，<strong>这里会有几个坑，我们将在后面进行介绍</strong>）。</p><hr><h2 id="几个误区及解释"><a href="#几个误区及解释" class="headerlink" title="几个误区及解释"></a>几个误区及解释</h2><h3 id="real-time-user-time-sys-time"><a href="#real-time-user-time-sys-time" class="headerlink" title="real_time=user_time+sys_time"></a>real_time=user_time+sys_time</h3><p>如果你认为上面的等式一定成立的话，那么请你再理解一下前面关于 <code>real</code>、<code>user</code>和 <code>sys</code> 的介绍。在前面的表述中，<code>real time</code> 是<strong>包含了其他进程的执行时间和进程阻塞时间的</strong>，而 <code>usr time+sys time</code> 显然是<strong>不包括其他进程的执行时间和进程阻塞时间的</strong>。因此，<code>real_time&gt;user_time+sys_time</code>是非常有可能的。</p><hr><h3 id="real-time-gt-user-time-sys-time"><a href="#real-time-gt-user-time-sys-time" class="headerlink" title="real_time&gt;user_time+sys_time"></a>real_time&gt;user_time+sys_time</h3><p>根据上面的分析，这个关系式应该是成立的吧？嘿嘿，不一定哟。一般来说，在<strong>单核 CPU 系统</strong>中，<strong>这个关系式是成立的</strong>，但如果我们的系统是<strong>多核 CPU</strong> 的话，而有些程序是能够<strong>同时利用到多核 CPU 的计算能力的</strong>，在这种情况下这个关系式就不成立了。</p><p>程序利用<strong>多核 CPU 的计算能力</strong>，可以并行地处理多项事务。就像一件工作，原来是一个 CPU 核去做，现在是两个 CPU 核并行做，那么完成同样工作所花费的总时间是 <code>user_time+sys_time</code>，而两个人并行做却能够在更短的时间内完成，耗时为 <code>real_time</code>。因此，这种情况下，便出现了 <code>real_time&lt;user_time+sys_time</code> 的情况。</p><hr><h3 id="real-time-lt-user-time-sys-time"><a href="#real-time-lt-user-time-sys-time" class="headerlink" title="real_time&lt;user_time+sys_time"></a>real_time&lt;user_time+sys_time</h3><p>多核情况下，<code>real_time&lt;user_time+sys_time</code> 是成立的，那单核呢？显然<code>real_time&gt;user_time+sys_time</code>是有可能成立的。</p><p>上面的三个误区有点绕，但结论很重要，就是 <code>real_time</code> 和 <code>user_time+sys_time</code> 的<strong>大小关系不是恒久不变的</strong>，你需要了解你的 Linux 服务器，<strong>是单核</strong>，<strong>还是多核</strong>，这样才能正确地确定它们的关系。</p><hr><h2 id="前后执行同样命令时间不同"><a href="#前后执行同样命令时间不同" class="headerlink" title="前后执行同样命令时间不同"></a>前后执行同样命令时间不同</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次执行</span></span><br><span class="line">[roc@roclinux ~]$ time sudo find / -name mysql.sh</span><br><span class="line">  /etc/profile.d/mysql.sh</span><br><span class="line">  </span><br><span class="line">  real    0m6.776s</span><br><span class="line">  user    0m1.101s</span><br><span class="line">  sys 0m1.363s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次执行</span></span><br><span class="line">[roc@roclinux ~]$ time sudo find / -name mysql.sh</span><br><span class="line">/etc/profile.d/mysql.sh</span><br><span class="line"> </span><br><span class="line">  real    0m3.059s</span><br><span class="line">  user    0m1.189s</span><br><span class="line">  sys 0m1.435s</span><br></pre></td></tr></table></figure><p>咦，怎么 <code>real</code> 的时间缩减到了 3.059 秒了，生生<strong>少了 3 秒多钟</strong>，这又是怎么回事呢？<strong>为什么同样的命令在第二次执行时快这么多呢？</strong></p><p>这个现象<strong>跟 Linux 操作系统的运行原理有关</strong>，<mark><code>find</code> 命令在第一次执行后，系统会对一些文件做缓存，在第二次执行时，就正好使用到了这些缓存中的数据，因此执行速度就变快了很多</mark>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/time.html" target="_blank" rel="noopener">time命令_Linux time命令：测量命令的执行时间或者系统资源的使用情况</a></li><li><a href="https://codingstandards.iteye.com/blog/798788" target="_blank" rel="noopener">我使用过的Linux命令之time - 测定一个命令的资源使用情况</a></li><li><a href="http://man.linuxde.net/time" target="_blank" rel="noopener">time命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;计算命令执行花费的时间&lt;/strong&gt;的命令&lt;code&gt;time&lt;/code&gt;，其输出包括三个时间&lt;code&gt;real&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;sys&lt;/code&gt;，其中real是最终花费的时间；一般情况下&lt;code&gt;real=user+sys&lt;/code&gt;，但如果命令是多核执行，也有可能是&lt;code&gt;real_time&amp;lt;user_time+sys_time&lt;/code&gt;，同时由于&lt;code&gt;usr time+sys time&lt;/code&gt;&lt;strong&gt;不包括其他进程的执行时间和进程阻塞时间的&lt;/strong&gt;，所以&lt;code&gt;real_time&amp;gt;user_time+sys_time&lt;/code&gt;也是非常有可能的；最后&lt;strong&gt;前后两次执行同一个命令，输出的时间可能不同&lt;/strong&gt;，这是因为&lt;strong&gt;第一次执行命令系统会建立缓存&lt;/strong&gt;使得第二次执行的时间缩短。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>xargs-给其他命令传递参数</title>
    <link href="http://showteeth.tech/posts/30003.html"/>
    <id>http://showteeth.tech/posts/30003.html</id>
    <published>2019-04-25T06:30:08.000Z</published>
    <updated>2019-04-25T15:14:15.630Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了非常强大的能<strong>给其他命令传递参数的命令</strong><code>xargs</code>，需要特别注意的是<code>xargs</code><strong>传递的是后一个命令的参数</strong>，而<code>管道符</code><strong>传递的是前一个命令的结果，一个字符串而已</strong>；主要学习了<code>-a</code>、<code>-d</code>、<code>-n</code>、<code>-I</code>、<code>-t</code>、<code>-p</code>、<code>-L</code>等参数，同时也学习了<strong>其与<code>find</code>命令结合进行很多很强大的操作</strong>！</p></div><a id="more"></a><h2 id="xargs命令简介"><a href="#xargs命令简介" class="headerlink" title="xargs命令简介"></a>xargs命令简介</h2><ul><li><code>xargs</code> 是<strong>给命令传递参数</strong>的一个过滤器，也是<strong>组合多个命令</strong>的一个工具，其能够捕获一个命令的输出，然后传递给另外一个命令</li><li><code>xargs</code> 可以<strong>将管道或标准输入（stdin）数据转换成命令行参数</strong>，也<strong>能够从文件的输出中读取数据</strong></li><li><code>xargs</code> 也可以<strong>将单行或多行文本输入转换为其他格式</strong>，例如<strong>多行变单行</strong>，<strong>单行变多行</strong></li><li><code>xargs</code> 默认的命令是 <code>echo</code>，这意味着通过管道传递给 <code>xargs</code> 的输入将会包含换行和空白，不过通过 <code>xargs</code> 的处理，换行和空白将被空格取代</li><li><code>xargs</code> 一般是和管道一起使用</li></ul><hr><h2 id="xargs和管道符"><a href="#xargs和管道符" class="headerlink" title="xargs和管道符"></a>xargs和管道符</h2><p>通过上述功能的总结可以发现其实xargs命令和管道符的作用比较类似，两者都能够组合命令，但是两者在有些地方也存在区别或者不适用的地方，下面以cat命令为例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"><span class="comment"># 测试文件1 </span></span><br><span class="line">  I am test1 file</span><br><span class="line">cat test2.txt </span><br><span class="line"><span class="comment"># 测试文件2</span></span><br><span class="line">  I am test2 file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用管道查看test1.txt的内容</span></span><br><span class="line"><span class="built_in">echo</span> test1.txt |cat -</span><br><span class="line"><span class="comment"># 输出的就是前面echo的结果</span></span><br><span class="line">  test1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而使用xargs</span></span><br><span class="line"><span class="built_in">echo</span> test1.txt |xargs cat -</span><br><span class="line"><span class="comment"># 可以查看test.txt的具体内容</span></span><br><span class="line">  I am test1 file</span><br></pre></td></tr></table></figure><p></p><p>总结一下关于管道符和<code>xargs</code>：</p><ul><li><strong>管道符</strong>：把前一个命令<strong>原本要输出到屏幕的标准正常数据</strong>当作是<strong>后一个命令的标准输入</strong></li><li><code>xargs</code>:将前一个命令的标准输出传递给下一个命令，<strong>作为它的参数</strong></li><li>可以发现，<mark>两者最主要的区别是，管道符处理的是直接前一个命令的结果(字符串)，而xargs是将前一个命令的结果作为参数</mark>，可以通过上面的示例感受一下</li><li>一些需要<strong>处理文件名的命令</strong>，如<code>rm</code>、<code>cp</code>、<code>mv</code>等命令就需要使用<code>xargs</code>，而另一些可以<strong>直接处理具体文本内容的</strong>，就可以直接使用管道符，例如<code>grep</code></li></ul><hr><h2 id="xargs命令格式"><a href="#xargs命令格式" class="headerlink" title="xargs命令格式"></a>xargs命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  xargs [OPTION]... COMMAND INITIAL-ARGS...</span><br><span class="line">  <span class="comment"># 注意，后面的command是在xargs的参数后面</span></span><br><span class="line">  front-command | xargs -option later-command</span><br><span class="line"></span><br><span class="line">Run COMMAND with arguments INITIAL-ARGS and more arguments <span class="built_in">read</span> from input.</span><br></pre></td></tr></table></figure><hr><h2 id="xargs命令参数"><a href="#xargs命令参数" class="headerlink" title="xargs命令参数"></a>xargs命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-0</code></td><td><code>--null</code></td><td>Items are separated by a null(<code>'\0'</code>), not whitespace</td></tr><tr><td><code>-a</code></td><td><code>--arg-file=FILE</code></td><td>从文件读取参数，而不是标准输入</td></tr><tr><td><code>-d</code></td><td><code>--delimiter=CHARACTER</code></td><td>自定义参数定界符</td></tr><tr><td><code>-E END</code></td><td></td><td>END出现位置之后的参数都会被忽略</td></tr><tr><td><code>-I R</code></td><td></td><td>same as --replace=R (R must be specified)</td></tr><tr><td><code>-i</code></td><td><code>--replace=[R]</code></td><td>当xargs command 后有多个参数时，调整参数位置，R默认是<code>{}</code></td></tr><tr><td><code>-L,-l</code></td><td><code>--max-lines=MAX-LINES</code></td><td>从标准输入一次读取 num 行送给 command 命令</td></tr><tr><td><code>-n</code></td><td><code>--max-args=MAX-ARGS</code></td><td>指定一次处理的参数个数</td></tr><tr><td><code>-P</code></td><td><code>--max-procs=MAX-PROCS</code></td><td>修改最大的进程数，默认是1，为0时候为as many as it can</td></tr><tr><td><code>-p</code></td><td><code>--interactive</code></td><td>当每次执行一个argument的时候询问一次用户</td></tr><tr><td><code>-r</code></td><td>--no-run-if-empty</td><td>当xargs的输入为空的时候则停止xargs，不加这个参数会至少执行一次</td></tr><tr><td><code>-s</code></td><td><code>--max-chars=MAX-CHARS</code></td><td>xargs 后面那个命令的最大命令行字符数(包括命令的长度、参数的长度等)</td></tr><tr><td></td><td><code>--show-limits</code></td><td>Show limits on command-line length.</td></tr><tr><td><code>-t</code></td><td><code>--verbose</code></td><td>Print commands before executing them</td></tr></table><hr><h2 id="xargs使用实例"><a href="#xargs使用实例" class="headerlink" title="xargs使用实例"></a>xargs使用实例</h2><h3 id="a-从文件中读取参数"><a href="#a-从文件中读取参数" class="headerlink" title="-a-从文件中读取参数"></a>-a-从文件中读取参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">""</span> |xargs -a test1.txt </span><br><span class="line"><span class="comment"># 从文件中读取参数</span></span><br><span class="line">I am test1 file</span><br></pre></td></tr></table></figure><hr><h3 id="d-设置参数定界符"><a href="#d-设置参数定界符" class="headerlink" title="-d-设置参数定界符"></a>-d-设置参数定界符</h3><p>默认情况下<code>xargs</code>将其标准输入中的内容以<strong>空白(包括空格、Tab、回车换行等)分割</strong>成多个之后当作命令行参数传递给其后面的命令，也可以通过<code>-d</code>参数指定：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'11@22@33'</span> | xargs</span><br><span class="line"><span class="comment"># xargs默认命令是echo</span></span><br><span class="line"><span class="comment"># 等同于echo '11@22@33' | xargs echo</span></span><br><span class="line">  11@22@33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置定界符为@</span></span><br><span class="line"><span class="comment"># 注意echo命令要在xargs参数的后面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'11@22@33'</span> | xargs -d <span class="string">"@"</span> <span class="built_in">echo</span></span><br><span class="line">11 22 33</span><br><span class="line"><span class="comment"># 这个会有一个空行，不知道为什么</span></span><br><span class="line"><span class="comment"># 如果不加-d参数就不会出现空行</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-每次处理的参数个数"><a href="#n-每次处理的参数个数" class="headerlink" title="-n-每次处理的参数个数"></a>-n-每次处理的参数个数</h3><p>默认情况下，<code>xargs</code>后面的命令一次会处理所有的参数，可以通过-n参数指定每次处理的参数个数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1 2 3 4 5 6 7 8 9"</span> |xargs -n 3</span><br><span class="line"><span class="comment"># 每次输出3个</span></span><br><span class="line">  1 2 3</span><br><span class="line">  4 5 6</span><br><span class="line">  7 8 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的执行过程等价于</span></span><br><span class="line"><span class="built_in">echo</span> 1 2 3</span><br><span class="line"><span class="built_in">echo</span> 4 5 6</span><br><span class="line"><span class="built_in">echo</span> 7 8 9</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="E-指定停止解析参数字符"><a href="#E-指定停止解析参数字符" class="headerlink" title="-E-指定停止解析参数字符"></a>-E-指定停止解析参数字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定停止解析参数字符为33</span></span><br><span class="line"><span class="comment"># 包括33在内的后续字符都不会作为参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 33 44"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22</span><br></pre></td></tr></table></figure><p>注意，是完全以<code>-E</code>指定的停止解析字符<strong>完全相同</strong>才可以：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含233以及33，最终会在33的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 233 44 33 55 66"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22 233 44</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含332以及33，最终会在33的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 332 44 33 55 66"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22 332 44</span><br></pre></td></tr></table></figure><p></p><p>注意，如果<strong>同时指定了<code>-d</code>参数</strong>，<strong>则<code>-E</code>参数会失效</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定-d的同时指定-E</span></span><br><span class="line"><span class="comment"># -E失效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 33 44 "</span> | xargs -d <span class="string">" "</span> -E <span class="string">"33"</span></span><br><span class="line">11 22 33 44 </span><br><span class="line"><span class="comment"># 这里会出现一个空行</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="I-调整参数位置"><a href="#I-调整参数位置" class="headerlink" title="-I-调整参数位置"></a>-I-调整参数位置</h3><p>如果<code>xargs</code>后面的命令需要多个参数时，可以使用<code>-I</code>来<strong>指定替换字符串</strong>，并<strong>将其放在合适的位置</strong>，这个<strong>替换字符串在 <code>xargs</code> 扩展时会被替换掉</strong>，当 <code>-I</code> 与 <code>xargs</code> 结合使用，<strong>每一个参数命令都会被执行一次</strong>，例如将当前目录下所有的文件复制到另一个目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先这个任务直接使用管道符是不能完成的</span></span><br><span class="line">ls *.txt|cp - ../csplit/</span><br><span class="line">  cp: cannot <span class="built_in">stat</span> ‘-’: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果直接使用xargs会报错</span></span><br><span class="line"><span class="comment"># 默认是将前一个参数的结果放在了最后，而txt不是一个目录</span></span><br><span class="line"><span class="comment"># 所以报错</span></span><br><span class="line">ls *.txt|xargs cp  ../csplit/</span><br><span class="line">  cp: target ‘test2.txt’ is not a directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的用法</span></span><br><span class="line"><span class="comment"># 使用-I参数指定&#123;&#125;为替换字符串</span></span><br><span class="line"><span class="comment"># 在cp命令中使用&#123;&#125;指代xargs传递给cp的参数</span></span><br><span class="line">ls *.txt | xargs -I &#123;&#125;  cp &#123;&#125; ../csplit/</span><br><span class="line"><span class="comment"># 指定@为替换字符串</span></span><br><span class="line">ls *.txt | xargs -I @  cp @ ../csplit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令之前先显示命令</span></span><br><span class="line">ls *.txt | xargs -t -I @  cp @ ../csplit/</span><br><span class="line">cp test1.txt ../csplit/ </span><br><span class="line">cp test2.txt ../csplit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于使用-i，只是-i有默认值，而-I没有默认值，必须要指定</span></span><br><span class="line"><span class="comment"># -i默认就是&#123;&#125;，但是使用-I一定要加上&#123;&#125;</span></span><br><span class="line">ls *.txt | xargs -i  cp &#123;&#125; ../csplit/</span><br></pre></td></tr></table></figure><p></p><p><strong>还可以使用多次替换符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给所有的文件重命名</span></span><br><span class="line"><span class="comment"># 加上后缀</span></span><br><span class="line">ls *.txt |xargs -I &#123;&#125; mv &#123;&#125; &#123;&#125;.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上前缀</span></span><br><span class="line">ls *.bak |xargs -I &#123;&#125; mv &#123;&#125; test_&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-I(-i)</code>参数在命令需要多个参数且参数位置有限制时很适用，例如<code>cp</code>、<code>mv</code>命令</li><li><code>-I(-i)</code>指定的替换字符串用于表示<code>xargs</code>传递给命令的参数使用的位置</li><li><code>-I</code>没有默认值，必须要指定替换字符串，而<code>-i</code>有默认值为<code>{}</code>，可以不用指定</li><li>当 <code>-I</code> 与 <code>xargs</code> 结合使用，<strong>每一个参数命令都会被执行一次</strong>，正如上面的<code>ls *.txt | xargs -t -I @ cp @ ../csplit/</code>是进行了两次的cp，而不是一次全部cp</li></ul></div><hr><h3 id="t-在执行命令之前先输出命令"><a href="#t-在执行命令之前先输出命令" class="headerlink" title="-t-在执行命令之前先输出命令"></a>-t-在执行命令之前先输出命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt | xargs -t -I @  cp @ ../csplit/</span><br><span class="line"><span class="comment"># 显示会执行的命令</span></span><br><span class="line">  cp test1.txt ../csplit/ </span><br><span class="line">  cp test2.txt ../csplit/</span><br></pre></td></tr></table></figure><hr><h3 id="p-执行命令之前询问"><a href="#p-执行命令之前询问" class="headerlink" title="-p-执行命令之前询问"></a>-p-执行命令之前询问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt | xargs -p -I @  cp @ ../csplit/</span><br><span class="line"><span class="comment"># 进行询问</span></span><br><span class="line">  cp test1.txt ../csplit/ ?...y</span><br><span class="line">  cp test2.txt ../csplit/ ?...y</span><br></pre></td></tr></table></figure><hr><h3 id="L-每次读取多少行作为输入"><a href="#L-每次读取多少行作为输入" class="headerlink" title="-L-每次读取多少行作为输入"></a>-L-每次读取多少行作为输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"><span class="comment"># 测试文件 </span></span><br><span class="line">  I am test1 file</span><br><span class="line">  test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs -L 1 <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 每次读取一行作为输入</span></span><br><span class="line">  I am test1 file</span><br><span class="line">  test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs -L 2 <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 每次读取二行作为输入</span></span><br><span class="line"><span class="comment"># 两行的文本会合并</span></span><br><span class="line">  I am test1 file test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs  <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 默认是所有行作为输入</span></span><br><span class="line">  I am test1 file test2 test2</span><br></pre></td></tr></table></figure><div class="note info"><p>注意：<code>-L</code> 和 <code>-n</code> 参数是互相排斥的</p></div><hr><h3 id="结合find命令"><a href="#结合find命令" class="headerlink" title="结合find命令"></a>结合find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># find命令默认输出结果以\n进行换行</span></span><br><span class="line">  ./test1.txt</span><br><span class="line">  ./test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-print0表示在每条结果后面加上 '\0' 而不是换行</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0</span><br><span class="line">  ./test1.txt./test2.txt(base) [user@localhost xargs]$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># -print0参数刚好可以与xargs的-0参数对应</span></span><br><span class="line"><span class="comment"># -0参数表示使用\0分割参数</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0 |xargs -0 </span><br><span class="line">  ./test1.txt ./test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-d参数也能达到一样的效果</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0 |xargs -d <span class="string">"\0"</span></span><br><span class="line">  ./test1.txt ./test2.txt</span><br></pre></td></tr></table></figure><p>指定<code>-print0</code>以及设置<code>-0</code>参数的意义在于：如果查找到的文件名中包含空格，不使用<code>-print0</code>那么<code>find</code>命令会将结果使用<code>\n</code>隔开并输出，而<code>xargs</code>对空白进行分割，换行、空格、tab都属于空白，所以会将<code>find</code>文件名分成两部分，这样会出错；而使用<code>-print0</code>结合<code>-0</code>参数后，前后都是使用<code>&#39;\0&#39;</code>分割不同的文件名，这样可以保证文件名不被分割。下面是一个示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们创建了3个日志文件, 且故意让文件名称中都含有空格</span></span><br><span class="line">[roc@roclinux ~]$ <span class="keyword">for</span>((i=0;i&lt;3;i++)); <span class="keyword">do</span> touch <span class="string">"test <span class="variable">$&#123;i&#125;</span>.log"</span>;<span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们列出创建的文件</span></span><br><span class="line">[roc@roclinux ~]$ ls -1F</span><br><span class="line"><span class="built_in">test</span> 0.log</span><br><span class="line"><span class="built_in">test</span> 1.log</span><br><span class="line"><span class="built_in">test</span> 2.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们来运行xargs命令, 发现报错了</span></span><br><span class="line"><span class="comment"># 因为xargs将test 0.log文件分割为了test和0.log文件，然后根本不存在这两个文件</span></span><br><span class="line">[roc@roclinux ~]$  find . -name <span class="string">'*.log'</span> -<span class="built_in">print</span> | xargs rm</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘1.log’: No such file or directory</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘0.log’: No such file or directory</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘2.log’: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-print0和-0结合可以完美解决问题</span></span><br><span class="line">find . -name <span class="string">'*.log'</span> -print0 | xargs -0 rm -f</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>xargs</code> 的<code>-0</code>选项<strong>不仅可以将分隔符从默认的空格变成 NULL</strong>，还会<strong>将单引号、双引号、反斜线等统统默认为是普通字符</strong>。所以说，<strong><code>-0</code>选项特别适合处理命令参数中含有引号、空格、反斜线的情况</strong>。</p></div><hr><h3 id="结合rm命令"><a href="#结合rm命令" class="headerlink" title="结合rm命令"></a>结合rm命令</h3><p>如果一次删除的文件太多，使用<code>rm *.file</code>可能会遇到<code>Argument list too long</code>错误，这是因为<code>rm</code> 可接受的参数长度达到了极限，这其实并非 <code>rm</code>的错，而是系统限制了参数的长度，通过下面的命令可以查看到系统的参数长度限制值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统对参数长度的限制</span></span><br><span class="line">getconf ARG_MAX</span><br><span class="line">  2097152</span><br></pre></td></tr></table></figure><p></p><p>解决办法可以是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.file'</span> -<span class="built_in">print</span> | xargs rm -rf</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><h4 id="在所有文件中查找字符串"><a href="#在所有文件中查找字符串" class="headerlink" title="在所有文件中查找字符串"></a>在所有文件中查找字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ <span class="string">"*.log"</span> |xargs grep -ri <span class="string">"test"</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/wangqiguo/p/6464234.html" target="_blank" rel="noopener">xargs命令详解，xargs与管道的区别</a></li><li><a href="http://c.biancheng.net/linux/xargs.html" target="_blank" rel="noopener">xargs命令_Linux xargs命令：一个给其他命令传递参数的过滤器</a></li><li><a href="http://www.runoob.com/linux/linux-comm-xargs.html" target="_blank" rel="noopener">Linux xargs 命令</a></li><li><a href="https://blog.csdn.net/tommy_wxie/article/details/77715203" target="_blank" rel="noopener">linux 管道传递参数xargs 用法</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了非常强大的能&lt;strong&gt;给其他命令传递参数的命令&lt;/strong&gt;&lt;code&gt;xargs&lt;/code&gt;，需要特别注意的是&lt;code&gt;xargs&lt;/code&gt;&lt;strong&gt;传递的是后一个命令的参数&lt;/strong&gt;，而&lt;code&gt;管道符&lt;/code&gt;&lt;strong&gt;传递的是前一个命令的结果，一个字符串而已&lt;/strong&gt;；主要学习了&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-I&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-p&lt;/code&gt;、&lt;code&gt;-L&lt;/code&gt;等参数，同时也学习了&lt;strong&gt;其与&lt;code&gt;find&lt;/code&gt;命令结合进行很多很强大的操作&lt;/strong&gt;！&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>printf-格式化输出字符串</title>
    <link href="http://showteeth.tech/posts/47162.html"/>
    <id>http://showteeth.tech/posts/47162.html</id>
    <published>2019-04-24T15:32:21.000Z</published>
    <updated>2019-04-25T03:43:03.187Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中进行格式化输出字符串的命令printf，除了<strong>格式化输出之外</strong>还能对其进行修饰，<strong>这些修饰包括</strong>：<code>指定输出宽度</code>、<code>填充不足位数</code>、<code>指定精度</code>、<code>使用多个格式替换符</code>、<code>对齐输出</code>、<code>输出正负值</code>等。</p></div><a id="more"></a><h2 id="printf命令简介"><a href="#printf命令简介" class="headerlink" title="printf命令简介"></a>printf命令简介</h2><p><code>printf</code>命令可以进行<strong>格式化输出字符串</strong>，这是其与<code>echo</code>命令不同的地方，也是其特征；<code>printf</code> 由 <code>POSIX</code>标准所定义，因此<strong>使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好</strong>；具体的功能包括：</p><ul><li><strong>指定输出宽度</strong></li><li><strong>填充不足位数</strong></li><li><strong>指定精度</strong></li><li><strong>使用多个格式替换符</strong></li><li><strong>对齐输出</strong></li><li><strong>输出正负值</strong></li></ul><hr><h2 id="printf命令格式"><a href="#printf命令格式" class="headerlink" title="printf命令格式"></a>printf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> %[输出最少宽度][．精度][类型] 字符或数字1 字符或数字2 ....</span><br></pre></td></tr></table></figure><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="http://showteeth.tech/posts/39761.html">echo</a>可以用来进行<strong>字符串的输出</strong>，还可以用来<strong>输出转义字符</strong>，同时还可以用来进行<strong>带颜色的文字和背景输出</strong>，看到这里不禁要问：echo已经可以进行这么多的输出，<strong>为什么这里还要学习printf命令呢？</strong>其实原因很简单：</p><ul><li>学习<code>csplit</code>时，其中的<code>-b</code>参数指定前缀时也需要使用<code>printf</code>的格式输出</li><li>使用seq命令产生序列时可以指定<code>-f</code>参数来进行格式化的输出</li></ul><p>这么多命令需要使用<code>printf</code>命令足以见得其重要性，其实<code>printf</code>的<strong>主要作用就是用来进行格式化输出</strong>，这是其区别于<code>echo</code>的最主要的特征，也是其存在的意义。在有些应用情境下，使用printf比使用echo命令更便捷：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个字符串换行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用echo</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"abc\ndef\nghi\njkl"</span></span><br><span class="line"><span class="comment"># 需要在每个字符串后面添加\n转义字符</span></span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line">  ghi</span><br><span class="line">  jkl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用printf</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line"><span class="comment"># 可以直接使用"%s\n"为所有的字符串添加相同的格式</span></span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line">  ghi</span><br><span class="line">  jkl</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="printf格式替换符"><a href="#printf格式替换符" class="headerlink" title="printf格式替换符"></a>printf格式替换符</h2><h3 id="格式替换符的作用"><a href="#格式替换符的作用" class="headerlink" title="格式替换符的作用"></a>格式替换符的作用</h3><p>前面使用了<code>&quot;%s\n&quot;</code>来对每个输出进行格式化，那么<code>&quot;%s\n&quot;</code>是什么呢，为什么能够用来进行标准化呢？</p><p><code>&quot;%s&quot;</code>相当于一个<strong>替身演员</strong>，我们使用<code>&quot;%s&quot;</code><strong>代替传入的参数</strong>，也就是说， <code>&quot;%s&quot;</code>代替了命令3中的<code>abc</code>，代替了<code>def</code>，代替了<code>ghi</code>，<strong>代替了每一个传入的参数</strong>，在我们指定的”格式”中，它代表了每一个传入的参数，所以，如果我们指定的格式为<code>&quot;%s\n&quot;</code>，当abc被当做参数传入printf命令时，printf就会把<code>&quot;%s\n&quot;</code>中的<code>%s</code>替换成<code>abc</code>，于是，abc就变成了我们指定的格式”abc\n”，最终printf输出的就是格式化后的”abc\n”，以此类推，每一段文本都被当做一个参数传入printf命令，然后按照指定的格式输出了，具体的工作机制可以使用参考下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/格式替换符.png" alt="格式替换符.png"></p><p>了解上面<strong>替身演员</strong>的作用机制之后，我们可以进行随心所欲的输出格式自定义，例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"(%s)\n"</span> <span class="string">"abc"</span> <span class="string">"def"</span>  <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line">  (abc)</span><br><span class="line">  (def)</span><br><span class="line">  (ghi)</span><br><span class="line">  (jkl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意，默认情况下，printf输出的字符不会换行，如需换行需要指定\n</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"(%s)\t"</span> <span class="string">"abc"</span> <span class="string">"def"</span>  <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line">(abc)(def)(ghi)(jkl)(base) [user@localhost seq]</span><br></pre></td></tr></table></figure><p></p><p>而 <strong>“替身演员”只是我给<code>&quot;%s&quot;</code>起的一个外号</strong>，它的真名叫 <strong>“格式替换符”</strong>，而printf中，”格式替换符”不只有”%s”一种，<strong>“%s”代替了每一个传入的参数，并将他们转化成了”字符串类型”</strong>，<strong>针对不同的需求，我们可以设置不同的格式替换符</strong>，例如，如果需要指定<strong>浮点型</strong>，可以使用<code>%f</code>，如果需要<strong>指定整数</strong>，可以使用<code>%d</code>。</p><hr><h3 id="常用的格式替换符"><a href="#常用的格式替换符" class="headerlink" title="常用的格式替换符"></a>常用的格式替换符</h3><table><tr><th width="20%">格式替换符</th><th width="80%">说明</th></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%f</code></td><td>浮点格式（也就是我们概念中的float或者double）</td></tr><tr><td><code>%e(%E)</code></td><td>浮点格式，使用的是科学计数法，大小写e、E区别在于科学计数法的e是大写还是小写</td></tr><tr><td><code>%g(%G)</code></td><td>浮点数不显无意义的0</td></tr><tr><td><code>%d、%i</code></td><td>有符号十进制整数</td></tr><tr><td><code>%b</code></td><td>相对应的参数中包含转义字符时，可以使用此替换符进行替换，对应的转义字符会被转义</td></tr><tr><td><code>%c</code></td><td>ASCII字符，显示相对应参数的第一个字符</td></tr><tr><td><code>%o</code></td><td>不带正负号的八进制值</td></tr><tr><td><code>%u</code></td><td>不带正负号的十进制值</td></tr><tr><td><code>%x</code></td><td>不带正负号的十六进制值，使用a至f表示10至15</td></tr><tr><td><code>%X</code></td><td>不带正负号的十六进制值，使用A至F表示10至15</td></tr><tr><td><code>%%</code></td><td>表示"%"本身</td></tr></table><hr><h2 id="printf转义字符"><a href="#printf转义字符" class="headerlink" title="printf转义字符"></a>printf转义字符</h2><p>关于转义字符的内容直接参考echo命令中的转义字符，两者基本上是一样的，<a href="http://showteeth.tech/posts/39761.html">具体链接</a></p><hr><h2 id="printf格式替换符修饰信息"><a href="#printf格式替换符修饰信息" class="headerlink" title="printf格式替换符修饰信息"></a>printf格式替换符修饰信息</h2><h3 id="指定输出位数"><a href="#指定输出位数" class="headerlink" title="指定输出位数"></a>指定输出位数</h3><p><strong>使用形式</strong>：<code>&quot;m%f\n&quot;</code>，其中m表示输出的位数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认情况下，浮点会保留小数点后6位</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%1f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 如果指定位数为1，默认输出还是原始长度</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%10f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 如果指定位数为10，则会使用空格填充两个</span></span><br><span class="line">    1.000000</span><br><span class="line">    2.000000</span><br><span class="line">    3.000000</span><br><span class="line">    4.000000</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>通过上面的实例可以得出如下结论：</p><ul><li>如果指定的位数<strong>小于</strong>原始输出位数，则会<strong>保留原始长度</strong></li><li>如果指定的位数<strong>大于</strong>原始输出位数，<strong>默认会使用空格填充不足的位数</strong></li></ul></div><hr><h3 id="填充不足位数"><a href="#填充不足位数" class="headerlink" title="填充不足位数"></a>填充不足位数</h3><p><strong>使用形式</strong>：<code>&quot;0m%f\n&quot;</code>，其中m表示输出的位数，0表示不足位数使用0填充<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%10f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认在输出位数没有达到指定时，会使用空格进行填充</span></span><br><span class="line">    1.000000</span><br><span class="line">    2.000000</span><br><span class="line">    3.000000</span><br><span class="line">    4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%010f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 可以指定使用0来填充不足的位数</span></span><br><span class="line">  001.000000</span><br><span class="line">  002.000000</span><br><span class="line">  003.000000</span><br><span class="line">  004.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%010s\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 好像不会对字符串进行填充0</span></span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">          4</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>只能使用<code>0</code>或<code>空格</code>来进行填充</li><li>对字符串<code>&quot;%s&quot;</code>好像不能使用0填充</li></ul></div><hr><h3 id="指定精度"><a href="#指定精度" class="headerlink" title="指定精度"></a>指定精度</h3><p><strong>使用形式</strong>：<code>&quot;.n%f\n&quot;</code>，其中<code>.n</code>表示精度，也就是小数点后保留的位数；<code>&quot;.n%d\n&quot;</code>，如果用在整数上，会使用0填充<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%.4f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认情况是保留六位小数</span></span><br><span class="line"><span class="comment"># 这里指定保留四位小数</span></span><br><span class="line">  1.0000</span><br><span class="line">  2.0000</span><br><span class="line">  3.0000</span><br><span class="line">  4.0000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整数使用精度则会达到填充0的效果</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%.4d\n"</span> 1 2 3 4</span><br><span class="line">  0001</span><br><span class="line">  0002</span><br><span class="line">  0003</span><br><span class="line">  0004</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>可以和前面的指定输出位数联合使用</li><li>对整数使用精度则会达到填充0的效果</li></ul></div><hr><h3 id="使用多个格式替换符"><a href="#使用多个格式替换符" class="headerlink" title="使用多个格式替换符"></a>使用多个格式替换符</h3><p><strong>使用形式</strong>：<code>&quot;%s %s\n&quot;</code>，多个格式替换符连用，每个格式替换符代表一个参数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s\n"</span> a b c d e f</span><br><span class="line"><span class="comment"># 每两个进行一次换行</span></span><br><span class="line">  a b</span><br><span class="line">  c d</span><br><span class="line">  e f</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s%s\n"</span> a b c d e f</span><br><span class="line"><span class="comment"># 每个参数之间的间隔取决于格式替换符之间的间隔</span></span><br><span class="line">  ab</span><br><span class="line">  <span class="built_in">cd</span></span><br><span class="line">  ef</span><br></pre></td></tr></table></figure><p></p><p>如果指定的”格式”中包含<strong>两个”格式替换符”</strong>，那么printf每次进行”格式化”操作时，就会<strong>传入两个参数</strong>，然后<strong>前一个参数对应第一个替换符</strong>，<strong>后一个参数对应第二个替换符</strong>，当本次格式化操作完成以后，再传入下一波参数，具体的工作机制如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/多个格式替换符.png" alt="多个格式替换符.png"></p><hr><h3 id="对齐输出"><a href="#对齐输出" class="headerlink" title="对齐输出"></a>对齐输出</h3><p><strong>使用形式</strong>：<code>&quot;%-s&quot;</code>，<code>-</code>表示左对齐，不加表示右对齐<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s %s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># 输出上述信息得到的结果会存在错位现象</span></span><br><span class="line"><span class="comment"># 原因：第一行宽度与后面每行对应的宽度不一致</span></span><br><span class="line"><span class="comment"># 指定的话需要结合系统编码，utf-8中文是3个字节</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果 男 18 60 </span><br><span class="line">  香蕉 男 18 80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%6s %6s %4s %4s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># 输出也没有对齐</span></span><br><span class="line"><span class="comment"># 第二行的男字节宽度为3，会填补3个空格</span></span><br><span class="line"><span class="comment"># 默认是右对齐</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果    男   18   60 </span><br><span class="line">  香蕉    男   18   80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-4s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># "-"表示左对齐</span></span><br><span class="line"><span class="comment"># 不加的时候表示右对齐</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果 男    18   60   </span><br><span class="line">  香蕉 男    18   80</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="输出正负值"><a href="#输出正负值" class="headerlink" title="输出正负值"></a>输出正负值</h3><p><strong>使用形式</strong>：<code>&quot;%+d&quot;</code>，<code>+</code>表示在正值前面加上<code>+</code>符号<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-4d \n"</span> 苹果 男 18 60 香蕉 男 18 -80</span><br><span class="line">苹果 男    18   60   </span><br><span class="line">香蕉 男    18   -80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-+4d \n"</span> 苹果 男 18 60 香蕉 男 18 -80</span><br><span class="line"><span class="comment"># 加了+使得整数会显示+，可以个负数的输出保持对齐</span></span><br><span class="line">苹果 男    18   +60  </span><br><span class="line">香蕉 男    18   -80</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/1411" target="_blank" rel="noopener">printf命令详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/48666563" target="_blank" rel="noopener">C语言 printf详解</a></li><li><a href="http://man.linuxde.net/printf" target="_blank" rel="noopener">printf命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中进行格式化输出字符串的命令printf，除了&lt;strong&gt;格式化输出之外&lt;/strong&gt;还能对其进行修饰，&lt;strong&gt;这些修饰包括&lt;/strong&gt;：&lt;code&gt;指定输出宽度&lt;/code&gt;、&lt;code&gt;填充不足位数&lt;/code&gt;、&lt;code&gt;指定精度&lt;/code&gt;、&lt;code&gt;使用多个格式替换符&lt;/code&gt;、&lt;code&gt;对齐输出&lt;/code&gt;、&lt;code&gt;输出正负值&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>seq-产生固定步长整数</title>
    <link href="http://showteeth.tech/posts/1152.html"/>
    <id>http://showteeth.tech/posts/1152.html</id>
    <published>2019-04-24T06:53:38.000Z</published>
    <updated>2019-04-25T03:38:15.537Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中常用的用来产生等间隔序列的命令<code>seq</code>，主要参数包括<code>-w</code>、<code>-f</code>、<code>-s</code>。</p></div><a id="more"></a><h2 id="seq命令简介"><a href="#seq命令简介" class="headerlink" title="seq命令简介"></a>seq命令简介</h2><p><code>seq</code>命令可以<strong>用来产生从指定起始位点到终止位点固定步长的数字序列</strong>，这个序列<strong>可以是整数也可以是小数</strong>，在输出结果时，可以进行<strong>等宽输出</strong>、<strong>格式化输出</strong>、<strong>指定分隔符输出</strong>。</p><hr><h2 id="seq命令格式"><a href="#seq命令格式" class="headerlink" title="seq命令格式"></a>seq命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><hr><h2 id="seq命令参数"><a href="#seq命令参数" class="headerlink" title="seq命令参数"></a>seq命令参数</h2><table><thead><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--format=FORMAT</code></td><td>使用printf 样式的浮点格式来进行格式化输出，不能和<code>-w</code>一起用</td></tr><tr><td><code>-s</code></td><td><code>--separator=STRING</code></td><td>指定输出分隔符，默认是换行符<code>\n</code></td></tr><tr><td><code>-w</code></td><td><code>--equal-width</code></td><td>输出等宽的结果，默认使用0来补全，不能和<code>-f</code>一起用</td></tr></tbody></table><hr><h2 id="seq使用实例"><a href="#seq使用实例" class="headerlink" title="seq使用实例"></a>seq使用实例</h2><h3 id="seq默认行为"><a href="#seq默认行为" class="headerlink" title="seq默认行为"></a>seq默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5</span><br><span class="line"><span class="comment"># 如果给定两个数字，则一个为起始，一个为终止，步长为1</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">seq 2 1</span><br><span class="line"><span class="comment"># 没有输出结果，步长还是默认为1</span></span><br><span class="line"><span class="comment"># 即使起始大于终止</span></span><br><span class="line"></span><br><span class="line">seq 5</span><br><span class="line"><span class="comment"># 如果只指定一个数字，则这个数字是终止数字，起始和步长都为1</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">seq 1 0.5 2</span><br><span class="line"><span class="comment"># 步长可以为小数</span></span><br><span class="line"><span class="comment"># 起始和终止都可以为小数</span></span><br><span class="line">  1.0</span><br><span class="line">  1.5</span><br><span class="line">  2.0</span><br></pre></td></tr></table></figure><p>可以设置负的<code>INCREMENT</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 2 -1 1</span><br><span class="line"><span class="comment"># 生成递减的序列</span></span><br><span class="line">  2</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-设置序列输出间隔符"><a href="#s-设置序列输出间隔符" class="headerlink" title="-s-设置序列输出间隔符"></a>-s-设置序列输出间隔符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq 1 4</span><br><span class="line"><span class="comment"># 默认是通过换行符隔开</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line"></span><br><span class="line">seq -s <span class="string">','</span> 1 4</span><br><span class="line"><span class="comment"># 指定分隔符为逗号</span></span><br><span class="line">  1,2,3,4</span><br></pre></td></tr></table></figure><p>如果想<strong>要指定带有特殊意义的字符作为分隔符，就需要结合<code>echo</code>输出转义字符</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq -s <span class="string">"\t"</span> 1 4</span><br><span class="line"><span class="comment"># 如果直接指定\t，输出结果不能达到理想的效果</span></span><br><span class="line">  1\t2\t3\t4</span><br><span class="line"></span><br><span class="line">seq -s <span class="string">"<span class="variable">$(echo -e "\t")</span>"</span> 1 4</span><br><span class="line"><span class="comment"># 使用echo -e输出结果进行指定</span></span><br><span class="line">  1234</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>指定<strong>转义字符</strong>时需要<strong>借助<code>echo -e</code>进行输出</strong>，直接指定会出错</p></div><hr><h3 id="w-设置等宽输出"><a href="#w-设置等宽输出" class="headerlink" title="-w-设置等宽输出"></a>-w-设置等宽输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">seq 5 10</span><br><span class="line"><span class="comment"># 默认行为</span></span><br><span class="line">  5</span><br><span class="line">  6</span><br><span class="line">  7</span><br><span class="line">  8</span><br><span class="line">  9</span><br><span class="line">  10</span><br><span class="line"></span><br><span class="line">seq -w 5 10</span><br><span class="line"><span class="comment"># 设置输出的序列等宽</span></span><br><span class="line"><span class="comment"># 宽度由最大数字的宽度决定</span></span><br><span class="line">  05</span><br><span class="line">  06</span><br><span class="line">  07</span><br><span class="line">  08</span><br><span class="line">  09</span><br><span class="line">  10</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-w</code>参数不能和<code>-f</code>参数连用</p></div><hr><h3 id="f-进行格式化输出"><a href="#f-进行格式化输出" class="headerlink" title="-f-进行格式化输出"></a>-f-进行格式化输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5</span><br><span class="line"><span class="comment"># 默认情况</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">seq -f <span class="string">"%g"</span> 1 5</span><br><span class="line"><span class="comment"># %g表示浮点数不显无意义的零"0"</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而真正的浮点数</span></span><br><span class="line">seq -f <span class="string">"%f"</span> 1 5</span><br><span class="line"><span class="comment"># 后面有很多没有意义的0</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line">  5.000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 科学计数法</span></span><br><span class="line">seq -f <span class="string">"%e"</span> 1 5</span><br><span class="line">  1.000000e+00</span><br><span class="line">  2.000000e+00</span><br><span class="line">  3.000000e+00</span><br><span class="line">  4.000000e+00</span><br><span class="line">  5.000000e+00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出位宽</span></span><br><span class="line">seq -f <span class="string">"%3g"</span> 5 10</span><br><span class="line"><span class="comment"># 输出的位宽为3，宽度不足3的使用空格填充</span></span><br><span class="line">    5</span><br><span class="line">    6</span><br><span class="line">    7</span><br><span class="line">    8</span><br><span class="line">    9</span><br><span class="line">  10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0填充位宽不足的</span></span><br><span class="line">seq -f <span class="string">"%03g"</span> 5 10</span><br><span class="line"><span class="comment"># 这个如果将位宽设置为2，就和-w参数相同</span></span><br><span class="line"><span class="comment"># 但是-w参数可以自动识别最大宽度</span></span><br><span class="line">  005</span><br><span class="line">  006</span><br><span class="line">  007</span><br><span class="line">  008</span><br><span class="line">  009</span><br><span class="line">  010</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加前缀输出</span></span><br><span class="line">seq -f <span class="string">"dir%g"</span> 1 5</span><br><span class="line"><span class="comment"># 添加前缀为dir</span></span><br><span class="line">  dir1</span><br><span class="line">  dir2</span><br><span class="line">  dir3</span><br><span class="line">  dir4</span><br><span class="line">  dir5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合其他命令使用</span></span><br><span class="line">mkdir $(seq -f <span class="string">'dir%g'</span> 1 5)</span><br></pre></td></tr></table></figure><div class="note info"><p>更多关于<code>printf</code>格式化输出的内容请参考<a href="http://showteeth.tech/posts/47162.html">这篇文章</a></p></div><hr><h3 id="其他可以得到指定步长整数的方法"><a href="#其他可以得到指定步长整数的方法" class="headerlink" title="其他可以得到指定步长整数的方法"></a>其他可以得到指定步长整数的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 使用花括号进行拓展</span></span><br><span class="line"><span class="comment"># 默认步长为1 </span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 指定步长为2</span></span><br><span class="line">  1</span><br><span class="line">  3 </span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..f..2&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 还可以对字母进行指定步长输出</span></span><br><span class="line">  a</span><br><span class="line">  c</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/128" target="_blank" rel="noopener">seq命令详解</a></li><li><a href="http://man.linuxde.net/seq" target="_blank" rel="noopener">seq命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中常用的用来产生等间隔序列的命令&lt;code&gt;seq&lt;/code&gt;，主要参数包括&lt;code&gt;-w&lt;/code&gt;、&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shuf-随机打乱文件</title>
    <link href="http://showteeth.tech/posts/50731.html"/>
    <id>http://showteeth.tech/posts/50731.html</id>
    <published>2019-04-23T15:14:29.000Z</published>
    <updated>2019-04-23T16:17:14.408Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>对文件以及命令行输入进行随机打乱的命令<code>shuf</code></strong>，主要参数包括<code>-e</code>、<code>-i</code>、<code>-n</code>、<code>-o</code>、<code>-r</code>等。</p></div><a id="more"></a><h2 id="shuf简介"><a href="#shuf简介" class="headerlink" title="shuf简介"></a>shuf简介</h2><p><code>shuf</code>命令可以<strong>对文件或者命令行输入进行随机打乱并输出到标准输出或者指定的文件中</strong>，还<strong>可以指定<code>shuf</code>的随机模式(有放回地抽取)</strong></p><hr><h2 id="shuf命令格式"><a href="#shuf命令格式" class="headerlink" title="shuf命令格式"></a>shuf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: shuf [OPTION]... [FILE]</span><br><span class="line">  or:  shuf -e [OPTION]... [ARG]...</span><br><span class="line">  or:  shuf -i LO-HI [OPTION]...</span><br><span class="line"></span><br><span class="line">Write a random permutation of the input lines to standard output.</span><br></pre></td></tr></table></figure><hr><h2 id="shuf参数"><a href="#shuf参数" class="headerlink" title="shuf参数"></a>shuf参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-e</code></td><td><code>--echo</code></td><td>将参数作为输入信息进行随机打乱</td></tr><tr><td><code>-i</code></td><td><code>--input-range=LO-HI</code></td><td>在特定范围内生成随机数</td></tr><tr><td><code>-n</code></td><td><code>--head-count=COUNT</code></td><td>最大输出行数</td></tr><tr><td><code>-o</code></td><td><code>--output=FILE</code></td><td>指定输出文件</td></tr><tr><td></td><td><code>--random-source=FILE</code></td><td>get random bytes from FILE</td></tr><tr><td><code>-r</code></td><td><code>--repeat</code></td><td>有放回地抽取，需要结合<code>-n</code>参数一同使用</td></tr><tr><td><code>-z</code></td><td><code>--zero-terminated</code></td><td>以0 结束行而非换行符</td></tr></table><hr><h2 id="shuf使用实例"><a href="#shuf使用实例" class="headerlink" title="shuf使用实例"></a>shuf使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line6</span><br><span class="line">  line7</span><br><span class="line">  line8</span><br><span class="line">  line9</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="shuf默认行为"><a href="#shuf默认行为" class="headerlink" title="shuf默认行为"></a>shuf默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shuf test.txt</span><br><span class="line"><span class="comment"># 将test.txt随机打乱 </span></span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line7</span><br><span class="line">  line5</span><br><span class="line">  line10</span><br><span class="line">  line6</span><br><span class="line">  line8</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line1</span><br></pre></td></tr></table></figure><hr><h3 id="e-将参数作为输入信息进行随机打乱"><a href="#e-将参数作为输入信息进行随机打乱" class="headerlink" title="-e-将参数作为输入信息进行随机打乱"></a>-e-将参数作为输入信息进行随机打乱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shuf -e <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"mbc"</span></span><br><span class="line">  mbc</span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line"></span><br><span class="line">a=badad</span><br><span class="line">b=asdf</span><br><span class="line">c=sadfa</span><br><span class="line">shuf -e <span class="variable">$a</span> <span class="variable">$b</span> <span class="variable">$c</span></span><br><span class="line"><span class="comment"># 变量拓展</span></span><br><span class="line">  badad</span><br><span class="line">  sadfa</span><br><span class="line">  asdf</span><br></pre></td></tr></table></figure><hr><h3 id="i-在指定范围内生成随机数"><a href="#i-在指定范围内生成随机数" class="headerlink" title="-i-在指定范围内生成随机数"></a>-i-在指定范围内生成随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成1-10范围内的随机数</span></span><br><span class="line"><span class="comment"># 包括1和10</span></span><br><span class="line">shuf -i 1-10</span><br><span class="line">  3</span><br><span class="line">  7</span><br><span class="line">  4</span><br><span class="line">  6</span><br><span class="line">  1</span><br><span class="line">  9</span><br><span class="line">  2</span><br><span class="line">  5</span><br><span class="line">  10</span><br><span class="line">  8</span><br></pre></td></tr></table></figure><hr><h3 id="n-最大输出行数"><a href="#n-最大输出行数" class="headerlink" title="-n-最大输出行数"></a>-n-最大输出行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出随机打乱后结果的其中3行</span></span><br><span class="line">shuf -n 3 test.txt</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line9</span><br></pre></td></tr></table></figure><hr><h3 id="o-指定输出文件"><a href="#o-指定输出文件" class="headerlink" title="-o-指定输出文件"></a>-o-指定输出文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机打乱并将结果输出到shuf.txt</span></span><br><span class="line">shuf test.txt -o shuf.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">cat shuf.txt </span><br><span class="line">  line7</span><br><span class="line">  line1</span><br><span class="line">  line4</span><br><span class="line">  line6</span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line3</span><br><span class="line">  line5</span><br><span class="line">  line8</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="r-有放回地抽取"><a href="#r-有放回地抽取" class="headerlink" title="-r-有放回地抽取"></a>-r-有放回地抽取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有放回的抽取15行结果</span></span><br><span class="line">shuf -n 15 -r test.txt </span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line8</span><br><span class="line">  line1</span><br><span class="line">  line6</span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line1</span><br><span class="line">  line10</span><br><span class="line">  line7</span><br><span class="line">  line10</span><br><span class="line">  line10</span><br><span class="line">  line8</span><br></pre></td></tr></table></figure><div class="note info"><p><strong><code>-r</code>参数一定要结合<code>-n</code>参数一同使用</strong>，不然会一直运行有放回地抽取，<strong>相当于死循环</strong>，一直输出</p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.cn/article-9635-1.html" target="_blank" rel="noopener">给初学者看的 shuf 命令教程</a></li><li><a href="https://www.howtoforge.com/linux-shuf-command/" target="_blank" rel="noopener">Linux shuf Command Tutorial for Beginners (with Examples)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;对文件以及命令行输入进行随机打乱的命令&lt;code&gt;shuf&lt;/code&gt;&lt;/strong&gt;，主要参数包括&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shell中的float问题</title>
    <link href="http://showteeth.tech/posts/61435.html"/>
    <id>http://showteeth.tech/posts/61435.html</id>
    <published>2019-04-20T01:51:47.000Z</published>
    <updated>2019-04-23T15:09:17.380Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了shell中<strong>处理浮点比较</strong>相关的内容，主要学习了<strong>使用<code>awk</code>以及<code>bc</code>命令来进行浮点比较和运算</strong>，此前还有一篇<a href="http://showteeth.tech/posts/28430.html">相关的文章</a></p></div><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在编写shell脚本的时候<strong>发现shell中使用浮点的比较</strong>会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 0.1 -lt 1 ]];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  -bash: [[: 0.1: syntax error: invalid arithmetic operator (error token is <span class="string">".1"</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>shell是不支持浮点的，不管是浮点的运算还是浮点的比较</p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="使用awk"><a href="#使用awk" class="headerlink" title="使用awk"></a>使用awk</h3><p>awk是支持浮点，包括运算以及比较：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点运算</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2/3&#125;'</span></span><br><span class="line">  0.666667</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&lt;3&#125;'</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&gt;3&#125;'</span></span><br><span class="line"><span class="comment"># 假则不输出结果</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用bc"><a href="#使用bc" class="headerlink" title="使用bc"></a>使用bc</h3><p>bc是shell中支持浮点相关方法的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点计算，如果结果小于0，会省略0，这里使用方法加上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br><span class="line"><span class="comment"># 输出结果，保留两位小数</span></span><br><span class="line">  0.66</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点的比较</span></span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &gt;= 0.3"</span></span><br><span class="line"><span class="comment"># 假值返回0</span></span><br><span class="line">  0</span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &lt;= 0.3"</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>注意<code>&lt;&lt;&lt;</code>、<code>&lt;&lt;</code>、<code>&lt;</code>的区别</strong>：</p><ul><li><code>&lt;</code>：表示从文件file中读取</li><li><code>&lt;&lt;</code>：表示从命令行读取到指定的结束字符</li><li><code>&lt;&lt;&lt;</code>：读取后面紧接的字符串</li><li>具体的用法实例参考<a href="http://showteeth.tech/posts/55603.html">文章</a><br><br></li></ul><p>关于浮点运算可以参考之前的<a href="http://showteeth.tech/posts/28430.html">文章</a></p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/2424770/floating-point-comparison-in-shell-script" target="_blank" rel="noopener">Floating Point Comparison in Shell Script</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了shell中&lt;strong&gt;处理浮点比较&lt;/strong&gt;相关的内容，主要学习了&lt;strong&gt;使用&lt;code&gt;awk&lt;/code&gt;以及&lt;code&gt;bc&lt;/code&gt;命令来进行浮点比较和运算&lt;/strong&gt;，此前还有一篇&lt;a href=&quot;http://showteeth.tech/posts/28430.html&quot;&gt;相关的文章&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据竞赛Top解决方案开源整理</title>
    <link href="http://showteeth.tech/posts/49396.html"/>
    <id>http://showteeth.tech/posts/49396.html</id>
    <published>2019-04-15T03:46:19.000Z</published>
    <updated>2019-04-15T07:22:25.958Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。</p></div><a id="more"></a><h2 id="纯数据竞赛"><a href="#纯数据竞赛" class="headerlink" title="纯数据竞赛"></a>纯数据竞赛</h2><h3 id="2018科大讯飞AI营销算法大赛"><a href="#2018科大讯飞AI营销算法大赛" class="headerlink" title="2018科大讯飞AI营销算法大赛"></a>2018科大讯飞AI营销算法大赛</h3><ul><li><strong>Rank1</strong>：<a href="https://zhuanlan.zhihu.com/p/47807544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47807544</a></li></ul><hr><h3 id="2018-IJCAI-阿里妈妈搜索广告转化预测"><a href="#2018-IJCAI-阿里妈妈搜索广告转化预测" class="headerlink" title="2018 IJCAI 阿里妈妈搜索广告转化预测"></a>2018 IJCAI 阿里妈妈搜索广告转化预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/plantsgo/ijcai-2018" target="_blank" rel="noopener">https://github.com/plantsgo/ijcai-2018</a></li><li><strong>Rank2</strong>：<ul><li><a href="https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution" target="_blank" rel="noopener">https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution</a></li><li><a href="https://blog.csdn.net/Bryan__/article/details/80600189" target="_blank" rel="noopener">https://blog.csdn.net/Bryan__/article/details/80600189</a></li></ul></li><li><strong>Rank3</strong>: <a href="https://github.com/luoda888/2018-IJCAI-top3" target="_blank" rel="noopener">https://github.com/luoda888/2018-IJCAI-top3</a></li><li><strong>Rank8</strong>: <a href="https://github.com/fanfanda/ijcai_2018" target="_blank" rel="noopener">https://github.com/fanfanda/ijcai_2018</a></li><li><strong>Rank8</strong>: <a href="https://github.com/Gene20/IJCAI-18" target="_blank" rel="noopener">https://github.com/Gene20/IJCAI-18</a></li><li><strong>Rank9（第一赛季）</strong>：<a href="https://github.com/yuxiaowww/IJCAI-18-TIANCHI" target="_blank" rel="noopener">https://github.com/yuxiaowww/IJCAI-18-TIANCHI</a></li><li><strong>Rank29</strong>: <a href="https://github.com/bettenW/IJCAI18_Tianchi_Rank29" target="_blank" rel="noopener">https://github.com/bettenW/IJCAI18_Tianchi_Rank29</a></li><li><strong>Rank41</strong>: <a href="https://github.com/cmlaughing/IJCAI-18" target="_blank" rel="noopener">https://github.com/cmlaughing/IJCAI-18</a></li><li><strong>Rank48</strong>: <a href="https://github.com/YunaQiu/IJCAI-18alimama" target="_blank" rel="noopener">https://github.com/YunaQiu/IJCAI-18alimama</a></li><li><strong>Rank53</strong>: <a href="https://github.com/altmanWang/IJCAI-18-CVR" target="_blank" rel="noopener">https://github.com/altmanWang/IJCAI-18-CVR</a></li><li><strong>Rank60</strong>: <a href="https://github.com/Chenyaorui/ijcai_2018" target="_blank" rel="noopener">https://github.com/Chenyaorui/ijcai_2018</a></li><li><strong>Rank81</strong>: <a href="https://github.com/wzp123456/IJCAI_18" target="_blank" rel="noopener">https://github.com/wzp123456/IJCAI_18</a></li><li><strong>Rank94</strong>: <a href="https://github.com/Yangtze121/-IJCAI-18-" target="_blank" rel="noopener">https://github.com/Yangtze121/-IJCAI-18-</a></li></ul><hr><h3 id="2018腾讯广告算法大赛"><a href="#2018腾讯广告算法大赛" class="headerlink" title="2018腾讯广告算法大赛"></a>2018腾讯广告算法大赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/DiligentPanda/Tencent_Ads_Algo_2018" target="_blank" rel="noopener">https://github.com/DiligentPanda/Tencent_Ads_Algo_2018</a></li><li><strong>Rank6</strong>: <a href="https://github.com/nzc/tencent-contest" target="_blank" rel="noopener">https://github.com/nzc/tencent-contest</a></li><li><strong>Rank7</strong>: <a href="https://github.com/guoday/Tencent2018_Lookalike_Rank7th" target="_blank" rel="noopener">https://github.com/guoday/Tencent2018_Lookalike_Rank7th</a></li><li><strong>Rank9</strong>: <a href="https://github.com/ouwenjie03/tencent-ad-game" target="_blank" rel="noopener">https://github.com/ouwenjie03/tencent-ad-game</a></li><li><strong>Rank10</strong>: <a href="https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th" target="_blank" rel="noopener">https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th</a></li><li><strong>rank10（初赛）</strong>: <a href="https://github.com/ShawnyXiao/2018-Tencent-Lookalike" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-Tencent-Lookalike</a></li><li><strong>Rank11</strong>:<ul><li><a href="https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest" target="_blank" rel="noopener">https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest</a></li><li><a href="https://my.oschina.net/xtzggbmkk/blog/1865680" target="_blank" rel="noopener">https://my.oschina.net/xtzggbmkk/blog/1865680</a></li></ul></li><li><strong>Rank26</strong>: <a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="noopener">https://github.com/zsyandjyhouse/TencentAD_contest</a></li><li><strong>Rank33</strong>: <a href="https://github.com/John-Yao/Tencent_Social_Ads2018" target="_blank" rel="noopener">https://github.com/John-Yao/Tencent_Social_Ads2018</a></li><li><strong>Rank69</strong>: <a href="https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest" target="_blank" rel="noopener">https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest</a></li></ul><hr><h3 id="2018高校大数据挑战赛-快手活跃用户预测"><a href="#2018高校大数据挑战赛-快手活跃用户预测" class="headerlink" title="2018高校大数据挑战赛-快手活跃用户预测"></a>2018高校大数据挑战赛-快手活跃用户预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://github.com/drop-out/RNN-Active-User-Forecast" target="_blank" rel="noopener">https://github.com/drop-out/RNN-Active-User-Forecast</a></li><li><a href="https://zhuanlan.zhihu.com/p/42622063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42622063</a></li></ul></li><li><strong>Rank4</strong>: <a href="https://github.com/chantcalf/2018-Rank4-" target="_blank" rel="noopener">https://github.com/chantcalf/2018-Rank4-</a></li><li><strong>Rank13(初赛 a榜rank2 b榜rank5)</strong>: <a href="https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions" target="_blank" rel="noopener">https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions</a></li><li><strong>Rank15</strong>: <a href="https://github.com/sunwantong/Kuaishou-Active-User" target="_blank" rel="noopener">https://github.com/sunwantong/Kuaishou-Active-User</a></li><li><strong>Rank20</strong>: <a href="https://github.com/bigzhao/Kuaishou_2018_rank20th" target="_blank" rel="noopener">https://github.com/bigzhao/Kuaishou_2018_rank20th</a></li><li><strong>Rank28(初赛 a榜rank1 b榜rank2)</strong>：<ul><li><a href="https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-" target="_blank" rel="noopener">https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-</a></li><li><a href="https://github.com/FNo0/2018-KUAISHOU-Top28" target="_blank" rel="noopener">https://github.com/FNo0/2018-KUAISHOU-Top28</a></li></ul></li></ul><hr><h3 id="2018JDATA-用户购买时间预测"><a href="#2018JDATA-用户购买时间预测" class="headerlink" title="2018JDATA 用户购买时间预测"></a>2018JDATA 用户购买时间预测</h3><ul><li><strong>Rank9</strong>：<a href="https://zhuanlan.zhihu.com/p/45141799" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45141799</a></li></ul><hr><h3 id="2018-DF风机叶片开裂预警"><a href="#2018-DF风机叶片开裂预警" class="headerlink" title="2018 DF风机叶片开裂预警"></a>2018 DF风机叶片开裂预警</h3><ul><li><strong>Rank2</strong>：<a href="https://github.com/SY575/DF-Early-warning-of-the-wind-power-system" target="_blank" rel="noopener">https://github.com/SY575/DF-Early-warning-of-the-wind-power-system</a></li></ul><hr><h3 id="2018-DF光伏发电量预测"><a href="#2018-DF光伏发电量预测" class="headerlink" title="2018 DF光伏发电量预测"></a>2018 DF光伏发电量预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168</a></li><li><a href="https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g</a></li></ul></li></ul><hr><h3 id="AI全球挑战者大赛-违约用户风险预测"><a href="#AI全球挑战者大赛-违约用户风险预测" class="headerlink" title="AI全球挑战者大赛-违约用户风险预测"></a>AI全球挑战者大赛-违约用户风险预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/chenkkkk/User-loan-risk-prediction" target="_blank" rel="noopener">https://github.com/chenkkkk/User-loan-risk-prediction</a></li></ul><hr><h3 id="2016融360-用户贷款风险预测"><a href="#2016融360-用户贷款风险预测" class="headerlink" title="2016融360-用户贷款风险预测"></a>2016融360-用户贷款风险预测</h3><ul><li><strong>Rank7</strong>：<a href="https://github.com/hczheng/Rong360" target="_blank" rel="noopener">https://github.com/hczheng/Rong360</a></li></ul><hr><h3 id="2016-CCF-020优惠券使用预测"><a href="#2016-CCF-020优惠券使用预测" class="headerlink" title="2016 CCF-020优惠券使用预测"></a>2016 CCF-020优惠券使用预测</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="noopener">https://github.com/wepe/O2O-Coupon-Usage-Forecast</a></li></ul><hr><h3 id="2016-ccf-农产品价格预测"><a href="#2016-ccf-农产品价格预测" class="headerlink" title="2016 ccf-农产品价格预测"></a>2016 ccf-农产品价格预测</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/xing89qs/CCF_Product" target="_blank" rel="noopener">https://github.com/xing89qs/CCF_Product</a></li><li><strong>Rank35</strong>: <a href="https://github.com/wqlin/ccf-price-prediction" target="_blank" rel="noopener">https://github.com/wqlin/ccf-price-prediction</a></li></ul><hr><h3 id="2016-ccf-客户用电异常"><a href="#2016-ccf-客户用电异常" class="headerlink" title="2016 ccf-客户用电异常"></a>2016 ccf-客户用电异常</h3><ul><li><strong>Rank4</strong>: <a href="https://github.com/AbnerYang/2016CCF-StateGrid" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-StateGrid</a></li></ul><hr><h3 id="2016-ccf-搜狗的用户画像比赛"><a href="#2016-ccf-搜狗的用户画像比赛" class="headerlink" title="2016 ccf-搜狗的用户画像比赛"></a>2016 ccf-搜狗的用户画像比赛</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/hengchao0248/ccf2016_sougou" target="_blank" rel="noopener">https://github.com/hengchao0248/ccf2016_sougou</a></li><li><strong>Rank3</strong>: <a href="https://github.com/AbnerYang/2016CCF-SouGou" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-SouGou</a></li><li><strong>Rank5</strong>:<ul><li><a href="https://github.com/dhdsjy/2016_CCFsougou" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou</a></li><li><a href="https://github.com/dhdsjy/2016_CCFsougou2" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou2</a></li><li><a href="https://github.com/prozhuchen/2016CCF-sougou" target="_blank" rel="noopener">https://github.com/prozhuchen/2016CCF-sougou</a></li><li><a href="https://github.com/coderSkyChen/2016CCF_BDCI_Sougou" target="_blank" rel="noopener">https://github.com/coderSkyChen/2016CCF_BDCI_Sougou</a></li></ul></li></ul><hr><h3 id="2016-ccf-联通的用户轨迹"><a href="#2016-ccf-联通的用户轨迹" class="headerlink" title="2016 ccf-联通的用户轨迹"></a>2016 ccf-联通的用户轨迹</h3><ul><li><strong>RankX</strong>: <a href="https://github.com/xuguanggen/2016CCF-unicom" target="_blank" rel="noopener">https://github.com/xuguanggen/2016CCF-unicom</a></li></ul><hr><h3 id="2016-ccf-Human-or-Robots"><a href="#2016-ccf-Human-or-Robots" class="headerlink" title="2016 ccf-Human or Robots"></a>2016 ccf-Human or Robots</h3><ul><li><strong>Rank6</strong>: <a href="https://github.com/pickou/ccf_human_or_robot" target="_blank" rel="noopener">https://github.com/pickou/ccf_human_or_robot</a></li></ul><hr><h3 id="菜鸟-需求预测与分仓规划"><a href="#菜鸟-需求预测与分仓规划" class="headerlink" title="菜鸟-需求预测与分仓规划"></a>菜鸟-需求预测与分仓规划</h3><ul><li><strong>Rank6</strong>:<a href="https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning" target="_blank" rel="noopener">https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning</a></li><li><strong>Rank10</strong>: <a href="https://github.com/xing89qs/TianChi_CaiNiao_Season2" target="_blank" rel="noopener">https://github.com/xing89qs/TianChi_CaiNiao_Season2</a></li></ul><hr><p><br></p><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="2018-DC达观-文本智能处理挑战"><a href="#2018-DC达观-文本智能处理挑战" class="headerlink" title="2018 DC达观-文本智能处理挑战"></a>2018 DC达观-文本智能处理挑战</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess</a></li><li><strong>Rank4</strong>: <a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li><li><strong>Rank10</strong>: <a href="https://github.com/moneyDboat/data_grand" target="_blank" rel="noopener">https://github.com/moneyDboat/data_grand</a></li><li><strong>Rank18</strong>: <a href="https://github.com/nlpjoe/daguan-classify-2018" target="_blank" rel="noopener">https://github.com/nlpjoe/daguan-classify-2018</a></li><li><strong>RankX</strong>: <a href="https://github.com/yanqiangmiffy/daguan" target="_blank" rel="noopener">https://github.com/yanqiangmiffy/daguan</a></li></ul><hr><h3 id="智能客服问题相似度算法设计——第三届魔镜杯大赛"><a href="#智能客服问题相似度算法设计——第三届魔镜杯大赛" class="headerlink" title="智能客服问题相似度算法设计——第三届魔镜杯大赛"></a>智能客服问题相似度算法设计——第三届魔镜杯大赛</h3><ul><li><strong>rank6</strong>：<a href="https://github.com/qrfaction/paipaidai" target="_blank" rel="noopener">https://github.com/qrfaction/paipaidai</a></li><li><strong>rank12</strong>：<a href="https://www.jianshu.com/p/827dd447daf9" target="_blank" rel="noopener">https://www.jianshu.com/p/827dd447daf9</a> <a href="https://github.com/LittletreeZou/Question-Pairs-Matching" target="_blank" rel="noopener">https://github.com/LittletreeZou/Question-Pairs-Matching</a></li><li><strong>Rank16</strong>：<a href="https://github.com/guoday/PaiPaiDai2018_rank16" target="_blank" rel="noopener">https://github.com/guoday/PaiPaiDai2018_rank16</a></li><li><strong>Rank29</strong>: <a href="https://github.com/wangjiaxin24/daguan_NLP" target="_blank" rel="noopener">https://github.com/wangjiaxin24/daguan_NLP</a></li></ul><hr><h3 id="2018JD-Dialog-Challenge-任务导向型对话系统挑战赛"><a href="#2018JD-Dialog-Challenge-任务导向型对话系统挑战赛" class="headerlink" title="2018JD Dialog Challenge 任务导向型对话系统挑战赛"></a>2018JD Dialog Challenge 任务导向型对话系统挑战赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/zengbin93/jddc_solution_4th" target="_blank" rel="noopener">https://github.com/zengbin93/jddc_solution_4th</a></li></ul><hr><h3 id="2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛"><a href="#2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛" class="headerlink" title="2018CIKM AnalytiCup  – 阿里小蜜机器人跨语言短文本匹配算法竞赛"></a>2018CIKM AnalytiCup – 阿里小蜜机器人跨语言短文本匹配算法竞赛</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/zake7749/Closer" target="_blank" rel="noopener">https://github.com/zake7749/Closer</a></li><li><strong>Rank12</strong>：<a href="https://github.com/Leputa/CIKM-AnalytiCup-2018" target="_blank" rel="noopener">https://github.com/Leputa/CIKM-AnalytiCup-2018</a></li><li><strong>Rank18</strong>: <a href="https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018" target="_blank" rel="noopener">https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018</a></li></ul><hr><p><br></p><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h3 id="Kaggle-TGS"><a href="#Kaggle-TGS" class="headerlink" title="Kaggle-TGS"></a>Kaggle-TGS</h3><ul><li><strong>Rank56</strong>：<a href="https://github.com/Gary-Deeplearning/TGS-Sal" target="_blank" rel="noopener">https://github.com/Gary-Deeplearning/TGS-Sal</a></li></ul><hr><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><h3 id="经验文章"><a href="#经验文章" class="headerlink" title="经验文章"></a>经验文章</h3><ul><li><p><strong>介绍featexp 一个帮助理解特征的工具包</strong>：<a href="http://www.sohu.com/a/273552971_129720" target="_blank" rel="noopener">http://www.sohu.com/a/273552971_129720</a></p></li><li><p>Ask Me Anything session with a Kaggle Grandmaster Vladimir I. Iglovikov PDF：<a href="https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ</a></p></li></ul><hr><h3 id="大佬的Github"><a href="#大佬的Github" class="headerlink" title="大佬的Github"></a>大佬的Github</h3><ul><li><strong>植物</strong> ：<a href="https://github.com/plantsgo" target="_blank" rel="noopener">https://github.com/plantsgo</a></li><li><strong>wepon</strong> ：<a href="https://github.com/wepe" target="_blank" rel="noopener">https://github.com/wepe</a></li><li><strong>Snake</strong>：<a href="https://github.com/luoda888" target="_blank" rel="noopener">https://github.com/luoda888</a></li><li><strong>Drop-out</strong>：<a href="https://github.com/drop-out" target="_blank" rel="noopener">https://github.com/drop-out</a></li><li><strong>金老师的知乎</strong>：<a href="https://zhuanlan.zhihu.com/jlbookworm" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/jlbookworm</a></li><li><strong>渣大</strong>：<a href="https://github.com/nzc" target="_blank" rel="noopener">https://github.com/nzc</a></li><li><strong>郭大</strong>：<a href="https://github.com/guoday" target="_blank" rel="noopener">https://github.com/guoday</a></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>数据比赛资讯</strong>：<a href="https://github.com/iphysresearch/DataSciComp" target="_blank" rel="noopener">https://github.com/iphysresearch/DataSciComp</a></li><li><strong>ApacheCN 的kaggle资料链接</strong>：<a href="https://github.com/apachecn/kaggle" target="_blank" rel="noopener">https://github.com/apachecn/kaggle</a></li><li><strong>Kaggle top方案整理</strong>：<a href="https://github.com/EliotAndres/kaggle-past-solutions" target="_blank" rel="noopener">https://github.com/EliotAndres/kaggle-past-solutions</a></li></ul><hr><h3 id="团队联系方式"><a href="#团队联系方式" class="headerlink" title="团队联系方式"></a>团队联系方式</h3><ul><li><strong>Smile</strong> qq:240485545 Email:<a href="mailto:smile.xuhc@gmail.com" target="_blank" rel="noopener">smile.xuhc@gmail.com</a></li><li><strong>PUSH</strong> qq:1471386635 Email：<a href="mailto:1471386635@qq.com" target="_blank" rel="noopener">1471386635@qq.com</a></li><li><strong>dive2space</strong> qq: 1124361357 Email:<a href="mailto:dive2space@qq.com" target="_blank" rel="noopener">dive2space@qq.com</a></li></ul><hr><h2 id="来源链接"><a href="#来源链接" class="headerlink" title="来源链接"></a>来源链接</h2><p><a href="https://mp.weixin.qq.com/s/_4QG0dWhh784lF0n1wymcw" target="_blank" rel="noopener">竞赛|数据竞赛Top解决方案开源整理</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://showteeth.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="竞赛" scheme="http://showteeth.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="开源代码" scheme="http://showteeth.tech/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>anaconda管理软件和环境</title>
    <link href="http://showteeth.tech/posts/42087.html"/>
    <id>http://showteeth.tech/posts/42087.html</id>
    <published>2019-04-14T02:49:27.000Z</published>
    <updated>2019-05-06T09:27:41.472Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><ul><li>印象笔记里面的两篇文章</li><li>斌斌师兄的脚本看看(里面有2和3兼容的问题)</li></ul><p>主要想解决的问题：</p><ul><li>环境备份的问题—多台集群环境如何管理</li><li>软件冲突时如何将软件安装在另一个环境中，使用的时候是怎么使用的呢？—直接找到环境的bin目录，然后将给软件指定alias指定到这个目录？</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
