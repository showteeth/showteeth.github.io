<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2020-08-07T05:47:29.259Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python绘图系列之同时绘制并列和堆叠柱状图</title>
    <link href="http://showteeth.tech/posts/290.html"/>
    <id>http://showteeth.tech/posts/290.html</id>
    <published>2020-08-06T11:16:37.000Z</published>
    <updated>2020-08-07T05:47:29.259Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了如果同时绘制并列和堆叠柱状图的方法，给出了三种实现方式。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前绘制柱状图要么是单独的堆叠柱状图，要么是单独的并列的柱状图，但是现在遇到的一种情况就是在绘制并列柱状图的时候希望突出显示某种分类，这个时候就需要在并列柱状图中添加堆叠柱状图。</p><h2 id="实现方法一：Seaborn"><a href="#实现方法一：Seaborn" class="headerlink" title="实现方法一：Seaborn"></a>实现方法一：Seaborn</h2><h3 id="构造数据"><a href="#构造数据" class="headerlink" title="构造数据"></a>构造数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">                   index=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>],</span><br><span class="line">                   columns=[<span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>])</span><br><span class="line">df2 = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">                   index=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>],</span><br><span class="line">                   columns=[<span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>])</span><br><span class="line">df3 = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">                   index=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>], </span><br><span class="line">                   columns=[<span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>])</span><br><span class="line"></span><br><span class="line">df1</span><br><span class="line">          I       J       K       L      M</span><br><span class="line">  A <span class="number">0.584456</span> <span class="number">0.193642</span> <span class="number">0.855521</span> <span class="number">0.849345</span> <span class="number">0.142361</span></span><br><span class="line">  B <span class="number">0.231361</span> <span class="number">0.172228</span> <span class="number">0.870167</span> <span class="number">0.922349</span> <span class="number">0.903166</span></span><br><span class="line">  C <span class="number">0.959428</span> <span class="number">0.871147</span> <span class="number">0.700459</span> <span class="number">0.489180</span> <span class="number">0.232174</span></span><br><span class="line">  D <span class="number">0.750299</span> <span class="number">0.686798</span> <span class="number">0.913503</span> <span class="number">0.410401</span> <span class="number">0.800438</span></span><br><span class="line"></span><br><span class="line">df2</span><br><span class="line">          I       J       K       L       M</span><br><span class="line">  A <span class="number">0.843176</span> <span class="number">0.619224</span> <span class="number">0.472286</span> <span class="number">0.438836</span> <span class="number">0.470271</span></span><br><span class="line">  B <span class="number">0.476635</span> <span class="number">0.853611</span> <span class="number">0.355111</span> <span class="number">0.381609</span> <span class="number">0.549682</span></span><br><span class="line">  C <span class="number">0.417060</span> <span class="number">0.856389</span> <span class="number">0.377922</span> <span class="number">0.717815</span> <span class="number">0.736557</span></span><br><span class="line">  D <span class="number">0.607617</span> <span class="number">0.032434</span> <span class="number">0.541995</span> <span class="number">0.588105</span> <span class="number">0.710369</span></span><br><span class="line"></span><br><span class="line">df3</span><br><span class="line">          I       J       K       L       M</span><br><span class="line">  A <span class="number">0.603417</span> <span class="number">0.406737</span> <span class="number">0.764824</span> <span class="number">0.479933</span> <span class="number">0.234480</span></span><br><span class="line">  B <span class="number">0.671419</span> <span class="number">0.770811</span> <span class="number">0.574703</span> <span class="number">0.166566</span> <span class="number">0.290416</span></span><br><span class="line">  C <span class="number">0.782604</span> <span class="number">0.274776</span> <span class="number">0.715263</span> <span class="number">0.006884</span> <span class="number">0.908278</span></span><br><span class="line">  D <span class="number">0.187266</span> <span class="number">0.601971</span> <span class="number">0.880003</span> <span class="number">0.233897</span> <span class="number">0.117642</span></span><br></pre></td></tr></table></figure><hr><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>将上述的宽数据转换为长数据：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加一列标识</span></span><br><span class="line">df1[<span class="string">"Name"</span>] = <span class="string">"df1"</span></span><br><span class="line">df2[<span class="string">"Name"</span>] = <span class="string">"df2"</span></span><br><span class="line">df3[<span class="string">"Name"</span>] = <span class="string">"df3"</span></span><br><span class="line"><span class="comment"># 转换为长数据</span></span><br><span class="line">dfall = pd.concat([pd.melt(i.reset_index(),</span><br><span class="line">                           id_vars=[<span class="string">"Name"</span>, <span class="string">"index"</span>]) </span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> [df1, df2, df3]],</span><br><span class="line">                   ignore_index=<span class="keyword">True</span>)</span><br><span class="line">dfall</span><br><span class="line">     Name index variable value</span><br><span class="line">  <span class="number">0</span> df1 A I <span class="number">0.565242</span></span><br><span class="line">  <span class="number">1</span> df1 B I <span class="number">0.990447</span></span><br><span class="line">  <span class="number">2</span> df1 C I <span class="number">0.511492</span></span><br><span class="line">  <span class="number">3</span> df1 D I <span class="number">0.242134</span></span><br><span class="line">  <span class="number">4</span> df1 A J <span class="number">0.462155</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一列累计值，用于绘制堆叠的效果</span></span><br><span class="line">dfall[<span class="string">"vcs"</span>] = dfall.groupby([<span class="string">"Name"</span>, <span class="string">"index"</span>]).cumsum()</span><br><span class="line">dfall</span><br><span class="line">     Name index variable value vcs</span><br><span class="line">  <span class="number">0</span> df1 A I <span class="number">0.565242</span> <span class="number">0.565242</span></span><br><span class="line">  <span class="number">1</span> df1 B I <span class="number">0.990447</span> <span class="number">0.990447</span></span><br><span class="line">  <span class="number">2</span> df1 C I <span class="number">0.511492</span> <span class="number">0.511492</span></span><br><span class="line">  <span class="number">3</span> df1 D I <span class="number">0.242134</span> <span class="number">0.242134</span></span><br><span class="line">  <span class="number">4</span> df1 A J <span class="number">0.462155</span> <span class="number">1.027398</span> <span class="comment"># 这里的就是1.02就是df1 A I的值加上df1 A J</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p></p><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 设置颜色的字典</span></span><br><span class="line">c = &#123;<span class="string">"I"</span>:<span class="string">"blue"</span>, <span class="string">"J"</span>:<span class="string">"purple"</span>, <span class="string">"K"</span>:<span class="string">"red"</span>, <span class="string">"L"</span>:<span class="string">"green"</span>, <span class="string">"M"</span>:<span class="string">"pink"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, g <span class="keyword">in</span> enumerate(dfall.groupby(<span class="string">"variable"</span>)):</span><br><span class="line">    ax = sns.barplot(data=g[<span class="number">1</span>],</span><br><span class="line">                     x=<span class="string">"index"</span>,</span><br><span class="line">                     y=<span class="string">"vcs"</span>,</span><br><span class="line">                     <span class="comment"># hue参数得到并列柱状图</span></span><br><span class="line">                     hue=<span class="string">"Name"</span>,</span><br><span class="line">                     <span class="comment"># 后续的color和zorder得到堆叠柱状图的效果</span></span><br><span class="line">                     <span class="comment"># 这两个参数是关键</span></span><br><span class="line">                     color=c[g[<span class="number">0</span>]],</span><br><span class="line">                     zorder=-i, </span><br><span class="line">                     edgecolor=<span class="string">"k"</span>)</span><br><span class="line"><span class="comment"># 去除自动生成的legend，后续自己手动添加legend</span></span><br><span class="line">ax.legend_.remove()</span><br><span class="line"><span class="comment"># 根据颜色字典生成legend</span></span><br><span class="line">manul_legend_list=[mpatches.Patch(color=v, label=k) <span class="keyword">for</span> k,v <span class="keyword">in</span> c.items()]</span><br><span class="line"><span class="comment"># 设置legend的字体大小和位置等信息</span></span><br><span class="line">plt.legend(handles=manul_legend_list,fontsize=<span class="number">10</span>,bbox_to_anchor=(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">plt.title(<span class="string">'Stacked and Dodge bar plot'</span>)</span><br><span class="line"><span class="comment"># 去除grid</span></span><br><span class="line">plt.grid(<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python_stacked_dodge_barplot.png" alt="python_stacked_dodge_barplot"></p><hr><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>上述使用Seaborn实现的缺点是：<strong>hue的颜色会逐渐变淡，如果并列的柱子过多，最后颜色太淡可能不能很好地区分</strong>。</p><h2 id="实现方法二：Matplotlib"><a href="#实现方法二：Matplotlib" class="headerlink" title="实现方法二：Matplotlib"></a>实现方法二：Matplotlib</h2><h3 id="搬运的代码"><a href="#搬运的代码" class="headerlink" title="搬运的代码"></a>搬运的代码</h3><p>这里直接搬运了参考链接中的代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># H是并列的柱子的区分形式</span></span><br><span class="line"><span class="comment"># labels是区分开的并列的柱子的legend名称</span></span><br><span class="line"><span class="comment"># dfall是宽数据构成的列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_clustered_stacked</span><span class="params">(dfall, labels=None, title=<span class="string">"multiple stacked bar plot"</span>,  H=<span class="string">"/"</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Given a list of dataframes, with identical columns and index, create a clustered stacked bar plot. </span></span><br><span class="line"><span class="string">labels is a list of the names of the dataframe, used for the legend</span></span><br><span class="line"><span class="string">title is a string for the title of the plot</span></span><br><span class="line"><span class="string">H is the hatch used for identification of the different dataframe"""</span></span><br><span class="line"></span><br><span class="line">    n_df = len(dfall)</span><br><span class="line">    n_col = len(dfall[<span class="number">0</span>].columns) </span><br><span class="line">    n_ind = len(dfall[<span class="number">0</span>].index)</span><br><span class="line">    axe = plt.subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个会生成一个柱状图，互相遮挡</span></span><br><span class="line">    <span class="keyword">for</span> df <span class="keyword">in</span> dfall : <span class="comment"># for each data frame</span></span><br><span class="line">        axe = df.plot(kind=<span class="string">"bar"</span>,</span><br><span class="line">                      linewidth=<span class="number">0</span>,</span><br><span class="line">                      stacked=<span class="keyword">True</span>,</span><br><span class="line">                      ax=axe,</span><br><span class="line">                      legend=<span class="keyword">False</span>,</span><br><span class="line">                      grid=<span class="keyword">False</span>,</span><br><span class="line">                      **kwargs)  <span class="comment"># make bar plots</span></span><br><span class="line"></span><br><span class="line">    h,l = axe.get_legend_handles_labels() <span class="comment"># get the handles we want to modify</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_df * n_col, n_col): <span class="comment"># len(h) = n_col * n_df</span></span><br><span class="line">        <span class="keyword">for</span> j, pa <span class="keyword">in</span> enumerate(h[i:i+n_col]):</span><br><span class="line">            <span class="keyword">for</span> rect <span class="keyword">in</span> pa.patches: <span class="comment"># for each index</span></span><br><span class="line">                <span class="comment"># 这一句是将之前互相遮挡的柱子移开</span></span><br><span class="line">                rect.set_x(rect.get_x() + <span class="number">1</span> / float(n_df + <span class="number">1</span>) * i / float(n_col))</span><br><span class="line">                <span class="comment"># 这一句是用于区分各个并列的柱子</span></span><br><span class="line">                rect.set_hatch(H * int(i / n_col)) <span class="comment">#edited part   </span></span><br><span class="line">                <span class="comment"># 这一句是设置柱子的宽度  </span></span><br><span class="line">                rect.set_width(<span class="number">1</span> / float(n_df + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    axe.set_xticks((np.arange(<span class="number">0</span>, <span class="number">2</span> * n_ind, <span class="number">2</span>) + <span class="number">1</span> / float(n_df + <span class="number">1</span>)) / <span class="number">2.</span>)</span><br><span class="line">    axe.set_xticklabels(df.index, rotation = <span class="number">0</span>)</span><br><span class="line">    axe.set_title(title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add invisible data to add another legend</span></span><br><span class="line">    n=[]        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_df):</span><br><span class="line">        n.append(axe.bar(<span class="number">0</span>, <span class="number">0</span>, color=<span class="string">"gray"</span>, hatch=H * i))</span><br><span class="line"></span><br><span class="line">    l1 = axe.legend(h[:n_col], l[:n_col], loc=[<span class="number">1.01</span>, <span class="number">0.5</span>])</span><br><span class="line">    <span class="keyword">if</span> labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        l2 = plt.legend(n, labels, loc=[<span class="number">1.01</span>, <span class="number">0.1</span>]) </span><br><span class="line">    axe.add_artist(l1)</span><br><span class="line">    <span class="keyword">return</span> axe</span><br><span class="line"></span><br><span class="line"><span class="comment"># create fake dataframes</span></span><br><span class="line">df1 = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">                   index=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>],</span><br><span class="line">                   columns=[<span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>])</span><br><span class="line">df2 = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">                   index=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>],</span><br><span class="line">                   columns=[<span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>])</span><br><span class="line">df3 = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">                   index=[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>], </span><br><span class="line">                   columns=[<span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, just call :</span></span><br><span class="line">plot_clustered_stacked([df1, df2, df3],[<span class="string">"df1"</span>, <span class="string">"df2"</span>, <span class="string">"df3"</span>])</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python_stacked_dodge_barplot_mat.png" alt="python_stacked_dodge_barplot_mat"></p><h3 id="自己修改"><a href="#自己修改" class="headerlink" title="自己修改"></a>自己修改</h3><p>上面搬运的代码是通过在柱体上添加标记来区分不同的并列分类条件，但是我觉得这种方式不是很好，想用边框的颜色来加以区分，这里修改了一下上述代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_clustered_stacked</span><span class="params">(dfall, ecs,labels=None, title=<span class="string">"multiple stacked bar plot"</span>,  **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Given a list of dataframes, with identical columns and index, create a clustered stacked bar plot. </span></span><br><span class="line"><span class="string">labels is a list of the names of the dataframe, used for the legend</span></span><br><span class="line"><span class="string">title is a string for the title of the plot</span></span><br><span class="line"><span class="string">ecs is the color list of different dodge bar edgecolor"""</span></span><br><span class="line"></span><br><span class="line">    n_df = len(dfall)</span><br><span class="line">    n_col = len(dfall[<span class="number">0</span>].columns) </span><br><span class="line">    n_ind = len(dfall[<span class="number">0</span>].index)</span><br><span class="line">    line= [<span class="number">0</span>] + [<span class="number">1</span>]*(len(dfall)<span class="number">-1</span>)</span><br><span class="line">    axe = plt.subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> df_i <span class="keyword">in</span> range(len(dfall)) : <span class="comment"># for each data frame</span></span><br><span class="line">        axe = dfall[df_i].plot(kind=<span class="string">"bar"</span>,</span><br><span class="line">                      linewidth=line[df_i],</span><br><span class="line">                      stacked=<span class="keyword">True</span>,</span><br><span class="line">                      ax=axe,</span><br><span class="line">                      legend=<span class="keyword">False</span>,</span><br><span class="line">                      grid=<span class="keyword">False</span>,</span><br><span class="line">                      edgecolor=ecs[df_i],</span><br><span class="line">                      **kwargs)  <span class="comment"># make bar plots</span></span><br><span class="line"></span><br><span class="line">    h,l = axe.get_legend_handles_labels() <span class="comment"># get the handles we want to modify</span></span><br><span class="line">    <span class="comment"># i为并列的第几个柱子</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_df * n_col, n_col): <span class="comment"># len(h) = n_col * n_df</span></span><br><span class="line">        <span class="comment"># pa为柱子中堆叠的小柱子</span></span><br><span class="line">        <span class="keyword">for</span> j, pa <span class="keyword">in</span> enumerate(h[i:i+n_col]):</span><br><span class="line">            <span class="comment"># rect在X轴大分类中的第几个</span></span><br><span class="line">            <span class="keyword">for</span> rect <span class="keyword">in</span> pa.patches: <span class="comment"># for each index</span></span><br><span class="line">                rect.set_x(rect.get_x() + <span class="number">1</span> / float(n_df + <span class="number">1</span>) * i / float(n_col))</span><br><span class="line">    <span class="comment">#             rect.set_hatch(H * int(i / n_col)) #edited part   </span></span><br><span class="line">                rect.set_width(<span class="number">1</span> / float(n_df + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    bar_width=h[<span class="number">0</span>].patches[<span class="number">0</span>].get_width()</span><br><span class="line">    xtick_li=[h[<span class="number">0</span>].patches[i].get_x() + bar_width*n_df/<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n_ind)]</span><br><span class="line">    axe.set_xticks(xtick_li)</span><br><span class="line">    axe.set_xticklabels(dfall[<span class="number">0</span>].index, rotation = <span class="number">0</span>)</span><br><span class="line">    axe.set_title(title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add invisible data to add another legend</span></span><br><span class="line">    <span class="comment"># 这里的添加最后的legend的部分</span></span><br><span class="line">    n=[]        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_df):</span><br><span class="line">        n.append(axe.bar(<span class="number">0</span>, <span class="number">0</span>, color=<span class="string">"gray"</span>, linewidth=line[i],edgecolor=ecs[i]))</span><br><span class="line"></span><br><span class="line">    l1 = axe.legend(h[:n_col], l[:n_col], loc=[<span class="number">1.01</span>, <span class="number">0.5</span>])</span><br><span class="line">    <span class="keyword">if</span> labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        l2 = plt.legend(n, labels, loc=[<span class="number">1.01</span>, <span class="number">0.1</span>]) </span><br><span class="line">    axe.add_artist(l1)</span><br><span class="line">    <span class="keyword">return</span> axe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">plot_clustered_stacked([df1, df2, df3],ecs=[<span class="string">'white'</span>,<span class="string">'black'</span>,<span class="string">'red'</span>],labels=[<span class="string">"df1"</span>, <span class="string">"df2"</span>, <span class="string">"df3"</span>])</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python_stacked_dodge_barplot_mat_own.png" alt="python_stacked_dodge_barplot_mat_own"></p><hr><h3 id="增加子图兼容性"><a href="#增加子图兼容性" class="headerlink" title="增加子图兼容性"></a>增加子图兼容性</h3><p>上述自己修改的代码还存在的问题是不能嵌合到子图中，这里进行修改：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加了legend参数，帮助控制legend的显示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_clustered_stacked</span><span class="params">(dfall, ecs,labels=None, legend=True,title=<span class="string">"multiple stacked bar plot"</span>,  **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Given a list of dataframes, with identical columns and index, create a clustered stacked bar plot. </span></span><br><span class="line"><span class="string">labels is a list of the names of the dataframe, used for the legend</span></span><br><span class="line"><span class="string">title is a string for the title of the plot</span></span><br><span class="line"><span class="string">ecs is the color list of different dodge bar edgecolor"""</span></span><br><span class="line"></span><br><span class="line">    n_df = len(dfall)</span><br><span class="line">    n_col = len(dfall[<span class="number">0</span>].columns) </span><br><span class="line">    n_ind = len(dfall[<span class="number">0</span>].index)</span><br><span class="line">    line= [<span class="number">0</span>] + [<span class="number">1</span>]*(len(dfall)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#     axe = plt.subplot(111)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> df_i <span class="keyword">in</span> range(len(dfall)) : <span class="comment"># for each data frame</span></span><br><span class="line">        axe = dfall[df_i].plot(kind=<span class="string">"bar"</span>,</span><br><span class="line">                      linewidth=line[df_i],</span><br><span class="line">                      stacked=<span class="keyword">True</span>,</span><br><span class="line"><span class="comment">#                       ax=axe,</span></span><br><span class="line">                      legend=<span class="keyword">False</span>,</span><br><span class="line">                      grid=<span class="keyword">False</span>,</span><br><span class="line">                      edgecolor=ecs[df_i],</span><br><span class="line">                      **kwargs)  <span class="comment"># make bar plots</span></span><br><span class="line"></span><br><span class="line">    h,l = axe.get_legend_handles_labels() <span class="comment"># get the handles we want to modify</span></span><br><span class="line">    <span class="comment"># i为并列的第几个柱子</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_df * n_col, n_col): <span class="comment"># len(h) = n_col * n_df</span></span><br><span class="line">        <span class="comment"># pa为柱子中堆叠的小柱子</span></span><br><span class="line">        <span class="keyword">for</span> j, pa <span class="keyword">in</span> enumerate(h[i:i+n_col]):</span><br><span class="line">            <span class="comment"># rect在X轴大分类中的第几个</span></span><br><span class="line">            <span class="keyword">for</span> rect <span class="keyword">in</span> pa.patches: <span class="comment"># for each index</span></span><br><span class="line">                rect.set_x(rect.get_x() + <span class="number">1</span> / float(n_df + <span class="number">1</span>) * i / float(n_col))</span><br><span class="line">    <span class="comment">#             rect.set_hatch(H * int(i / n_col)) #edited part   </span></span><br><span class="line">                rect.set_width(<span class="number">1</span> / float(n_df + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    bar_width=h[<span class="number">0</span>].patches[<span class="number">0</span>].get_width()</span><br><span class="line">    xtick_li=[h[<span class="number">0</span>].patches[i].get_x() + bar_width*n_df/<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n_ind)]</span><br><span class="line">    axe.set_xticks(xtick_li)</span><br><span class="line">    axe.set_xticklabels(dfall[<span class="number">0</span>].index, rotation = <span class="number">0</span>)</span><br><span class="line">    axe.set_title(title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add invisible data to add another legend</span></span><br><span class="line">    <span class="comment"># 这里的添加最后的legend的部分</span></span><br><span class="line">    n=[]        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_df):</span><br><span class="line">        n.append(axe.bar(<span class="number">0</span>, <span class="number">0</span>, color=<span class="string">"gray"</span>, linewidth=line[i],edgecolor=ecs[i]))</span><br><span class="line">    <span class="keyword">if</span> legend:</span><br><span class="line">        l1 = axe.legend(h[:n_col], l[:n_col], loc=[<span class="number">1.01</span>, <span class="number">0.5</span>])</span><br><span class="line">        <span class="keyword">if</span> labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            l2 = plt.legend(n, labels, loc=[<span class="number">1.01</span>, <span class="number">0.1</span>]) </span><br><span class="line">        axe.add_artist(l1)</span><br><span class="line">    <span class="keyword">return</span> axe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">ax=plot_clustered_stacked([df1, df2, df3],ecs=[<span class="string">'white'</span>,<span class="string">'black'</span>,<span class="string">'red'</span>],labels=[<span class="string">"df1"</span>, <span class="string">"df2"</span>, <span class="string">"df3"</span>],ax=axes[<span class="number">0</span>],legend=<span class="keyword">False</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">ax=plot_clustered_stacked([df1, df2, df3],ecs=[<span class="string">'white'</span>,<span class="string">'black'</span>,<span class="string">'red'</span>],labels=[<span class="string">"df1"</span>, <span class="string">"df2"</span>, <span class="string">"df3"</span>],ax=axes[<span class="number">1</span>])</span><br><span class="line">ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line"><span class="comment"># 刻度值旋转</span></span><br><span class="line"><span class="comment"># ax.set_xticklabels(ax.get_xticklabels(),rotation=15)</span></span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python_stacked_dodge_barplot_mat_own_sub.png" alt="python_stacked_dodge_barplot_mat_own_sub"></p><hr><h3 id="设置堆叠部分的颜色"><a href="#设置堆叠部分的颜色" class="headerlink" title="设置堆叠部分的颜色"></a>设置堆叠部分的颜色</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加了legend参数，帮助控制legend的显示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_clustered_stacked</span><span class="params">(dfall, ecs,color_dict,labels=None, legend=True,title=<span class="string">"multiple stacked bar plot"</span>,  **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Given a list of dataframes, with identical columns and index, create a clustered stacked bar plot. </span></span><br><span class="line"><span class="string">labels is a list of the names of the dataframe, used for the legend</span></span><br><span class="line"><span class="string">title is a string for the title of the plot</span></span><br><span class="line"><span class="string">ecs is the color list of different dodge bar edgecolor"""</span></span><br><span class="line"></span><br><span class="line">    n_df = len(dfall)</span><br><span class="line">    n_col = len(dfall[<span class="number">0</span>].columns) </span><br><span class="line">    n_ind = len(dfall[<span class="number">0</span>].index)</span><br><span class="line">    line= [<span class="number">0</span>] + [<span class="number">1</span>]*(len(dfall)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#     axe = plt.subplot(111)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> df_i <span class="keyword">in</span> range(len(dfall)) : <span class="comment"># for each data frame</span></span><br><span class="line">        axe = dfall[df_i].plot(kind=<span class="string">"bar"</span>,</span><br><span class="line">                      linewidth=line[df_i],</span><br><span class="line">                      stacked=<span class="keyword">True</span>,</span><br><span class="line"><span class="comment">#                       ax=axe,</span></span><br><span class="line">                      legend=<span class="keyword">False</span>,</span><br><span class="line">                      grid=<span class="keyword">False</span>,</span><br><span class="line">                      color=[color_dict.get(x) <span class="keyword">for</span> x <span class="keyword">in</span> dfall[df_i].columns],</span><br><span class="line">                      edgecolor=ecs[df_i],</span><br><span class="line">                      **kwargs)  <span class="comment"># make bar plots</span></span><br><span class="line"></span><br><span class="line">    h,l = axe.get_legend_handles_labels() <span class="comment"># get the handles we want to modify</span></span><br><span class="line">    <span class="comment"># i为并列的第几个柱子</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_df * n_col, n_col): <span class="comment"># len(h) = n_col * n_df</span></span><br><span class="line">        <span class="comment"># pa为柱子中堆叠的小柱子</span></span><br><span class="line">        <span class="keyword">for</span> j, pa <span class="keyword">in</span> enumerate(h[i:i+n_col]):</span><br><span class="line">            <span class="comment"># rect在X轴大分类中的第几个</span></span><br><span class="line">            <span class="keyword">for</span> rect <span class="keyword">in</span> pa.patches: <span class="comment"># for each index</span></span><br><span class="line">                rect.set_x(rect.get_x() + <span class="number">1</span> / float(n_df + <span class="number">1</span>) * i / float(n_col))</span><br><span class="line">    <span class="comment">#             rect.set_hatch(H * int(i / n_col)) #edited part   </span></span><br><span class="line">                rect.set_width(<span class="number">1</span> / float(n_df + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    bar_width=h[<span class="number">0</span>].patches[<span class="number">0</span>].get_width()</span><br><span class="line">    xtick_li=[h[<span class="number">0</span>].patches[i].get_x() + bar_width*n_df/<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n_ind)]</span><br><span class="line">    axe.set_xticks(xtick_li)</span><br><span class="line">    axe.set_xticklabels(dfall[<span class="number">0</span>].index, rotation = <span class="number">0</span>)</span><br><span class="line">    axe.set_title(title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add invisible data to add another legend</span></span><br><span class="line">    <span class="comment"># 这里的添加最后的legend的部分</span></span><br><span class="line">    n=[]        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_df):</span><br><span class="line">        n.append(axe.bar(<span class="number">0</span>, <span class="number">0</span>, color=<span class="string">"gray"</span>, linewidth=line[i],edgecolor=ecs[i]))</span><br><span class="line">    <span class="keyword">if</span> legend:</span><br><span class="line">        l1 = axe.legend(h[:n_col], l[:n_col], loc=[<span class="number">1.01</span>, <span class="number">0.5</span>])</span><br><span class="line">        <span class="keyword">if</span> labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            l2 = plt.legend(n, labels, loc=[<span class="number">1.01</span>, <span class="number">0.1</span>]) </span><br><span class="line">        axe.add_artist(l1)</span><br><span class="line">    <span class="keyword">return</span> axe</span><br></pre></td></tr></table></figure><p><a href="https://seaborn.pydata.org/tutorial/color_palettes.html" target="_blank" rel="noopener">Seaborn的color palettes</a></p><hr><h2 id="实现方式三：封装的函数"><a href="#实现方式三：封装的函数" class="headerlink" title="实现方式三：封装的函数"></a>实现方式三：封装的函数</h2><p>已经有人针对这问题封装了一个很完善的函数，不过其也是基于Seaborn的，所以Seaborn的缺陷该函数也有，不过程度已经减低很多。</p><p>封装的函数<a href="https://gitlab.com/ciraig/lca_standard_graphs/-/blob/master/lca_standard_graphs.py" target="_blank" rel="noopener">下载地址</a>，使用<a href="https://gitlab.com/ciraig/lca_standard_graphs/blob/master/demo/demo_grouped_stacked_bars.ipynb" target="_blank" rel="noopener">帮助文档</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载程序</span></span><br><span class="line"><span class="comment"># https://gitlab.com/ciraig/lca_standard_graphs/-/blob/master/lca_standard_graphs.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'/home/user/scripts/common_use/'</span>)</span><br><span class="line"><span class="keyword">import</span> lca_standard_graphs <span class="keyword">as</span> lsg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用代码构建画图的dataframe</span></span><br><span class="line">comp = lsg.build_comparison_table([df1, df2,df3], [<span class="string">"df1"</span>, <span class="string">"df2"</span>, <span class="string">"df3"</span>], fillna=<span class="number">0.0</span>)</span><br><span class="line">comp.index.names=[<span class="string">'Cat'</span>,<span class="string">'Scenarios'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">ax, fig = lsg.plot_grouped_stackedbars(comp, ix_categories=<span class="string">'Cat'</span>, ix_entities_compared=<span class="string">'Scenarios'</span>, norm=<span class="keyword">None</span> )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python_stacked_dodge_barplot_sea_fun.png" alt="python_stacked_dodge_barplot_sea_fun"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/22787209/how-to-have-clusters-of-stacked-bars-with-python-pandas" target="_blank" rel="noopener">How to have clusters of stacked bars with python (Pandas)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了如果同时绘制并列和堆叠柱状图的方法，给出了三种实现方式。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/Python/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
      <category term="annotation" scheme="http://showteeth.tech/tags/annotation/"/>
    
      <category term="boxplot" scheme="http://showteeth.tech/tags/boxplot/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之字符串指定split字符的顺序</title>
    <link href="http://showteeth.tech/posts/17590.html"/>
    <id>http://showteeth.tech/posts/17590.html</id>
    <published>2020-07-22T07:07:12.000Z</published>
    <updated>2020-07-22T07:23:29.983Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了如何指定对字符串中匹配字符<code>split</code>的次数和顺序。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在对字符串进行处理的时候遇到一个问题：如果指定对匹配字符<code>split</code>的次数和顺序。例如：<code>a=&#39;a_b_c&#39;;b=&#39;c_d&#39;</code>，如果对<code>a</code>、<code>b</code>按照<code>_</code>进行<code>split</code>，最终得到的结果<code>[a,b,c],[c,d]</code>，而自己实际上想得到的结果是<code>[a_b,c],[c,d]</code>，如何实现呢？</p><h2 id="rsplit"><a href="#rsplit" class="headerlink" title="rsplit"></a>rsplit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">'a_b_c'</span></span><br><span class="line"><span class="comment"># 一般的split</span></span><br><span class="line">a.split(<span class="string">'_'</span>)</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始指定split几次</span></span><br><span class="line">a.rsplit(<span class="string">'_'</span>,<span class="number">1</span>)</span><br><span class="line">  [<span class="string">'a_b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">a.rsplit(<span class="string">'_'</span>,<span class="number">2</span>)</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p><strong>目前<code>split</code>函数只支持从右侧开始指定<code>split</code>的次数，不支持从左侧开始指定</strong>。</p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了如何指定对字符串中匹配字符&lt;code&gt;split&lt;/code&gt;的次数和顺序。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="tricks" scheme="http://showteeth.tech/categories/Python/tricks/"/>
    
    
      <category term="tricks" scheme="http://showteeth.tech/tags/tricks/"/>
    
      <category term="字符串" scheme="http://showteeth.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之解决wget下载https文件需要验证证书的问题</title>
    <link href="http://showteeth.tech/posts/48830.html"/>
    <id>http://showteeth.tech/posts/48830.html</id>
    <published>2020-07-13T02:20:01.000Z</published>
    <updated>2020-07-13T02:32:15.379Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了解决<code>wget</code>下载<code>https</code>开头链接时报错<code>To connect to www.dfam.org insecurely, use &#39;--no-check-certificate&#39;</code>的根本方法：<strong>下载新版本的<code>wget</code></strong>或者<strong>修改<code>wget</code>配置</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在执行别人的一个<code>pipeline</code>的时候总是报错：<code>To connect to www.dfam.org insecurely, use &#39;--no-check-certificate&#39;</code>，然后发现是在下载<code>https</code>开头链接时报的错，因为是别人集成的<code>pipeline</code>，所以修改起来比较麻烦，并且添加<code>--no-check-certificate</code>参数也只是治标不治本的方法，这里就记录一下解决这个问题的根本方法。</p><h2 id="安装新版本的wget"><a href="#安装新版本的wget" class="headerlink" title="安装新版本的wget"></a>安装新版本的wget</h2><p>新版本的<code>wget</code>在下载<code>https</code>链接时就并不会报错，所以这里可以安装新版本的<code>wget</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 偷懒，直接使用conda安装</span></span><br><span class="line"><span class="comment"># 这里安装的版本是1.20.1，而自带的是1.14</span></span><br><span class="line">conda install -c anaconda wget</span><br></pre></td></tr></table></figure><p></p><p>自己下载源码编译的话可以参考<a href="https://www.cnblogs.com/mengdeep/p/7275139.html" target="_blank" rel="noopener">CentOS 6 下无法wget https链接的解决方法</a></p><hr><h2 id="修改wget配置"><a href="#修改wget配置" class="headerlink" title="修改wget配置"></a>修改wget配置</h2><p>参考<a href="https://superuser.com/questions/508696/wget-without-no-check-certificate/1045163" target="_blank" rel="noopener">wget without –no-check-certificate</a>的解决办法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"check_certificate=off"</span> &gt;&gt; ~/.wgetrc</span><br></pre></td></tr></table></figure><p></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了解决&lt;code&gt;wget&lt;/code&gt;下载&lt;code&gt;https&lt;/code&gt;开头链接时报错&lt;code&gt;To connect to www.dfam.org insecurely, use &amp;#39;--no-check-certificate&amp;#39;&lt;/code&gt;的根本方法：&lt;strong&gt;下载新版本的&lt;code&gt;wget&lt;/code&gt;&lt;/strong&gt;或者&lt;strong&gt;修改&lt;code&gt;wget&lt;/code&gt;配置&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Linux/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之sorted函数使用</title>
    <link href="http://showteeth.tech/posts/217.html"/>
    <id>http://showteeth.tech/posts/217.html</id>
    <published>2020-06-13T14:37:39.000Z</published>
    <updated>2020-06-14T02:43:09.096Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章对<code>sorted</code>函数进行了详细的学习和理解，主要包括其<strong>排序的原理和过程</strong>以及 <strong><code>key</code>函数的理解</strong>，最后<strong>结合了对两个常用情形示例的解读加深了理解</strong>。</p></div><a id="more"></a><h2 id="sorted函数简介"><a href="#sorted函数简介" class="headerlink" title="sorted函数简介"></a>sorted函数简介</h2><p><code>sorted()</code> 函数可以对所有序列(可迭代的对象)进行排序操作，并且<strong>不会修改原始的序列，而是生成一个新的列表list</strong>。</p><blockquote><p>Sorted() sorts <strong>any sequence (list, tuple, dict)</strong> and always <strong>returns a list</strong> with the elements in sorted manner, <strong>without modifying the original sequence</strong>.</p></blockquote><p>和列表的<code>sort</code>函数的区别：</p><ul><li><code>sort</code> 是应用在 <code>list</code> 上的方法，<code>sorted</code> 可以对所有可迭代的对象进行排序操作。</li><li><code>list</code> 的 <code>sort</code> 方法返回的是<strong>对已经存在的列表进行操作</strong>，而内建函数 <code>sorted</code> 方法<strong>返回的是一个新的 <code>list</code></strong>，而不是在原来的基础上进行的操作。</li></ul><hr><h2 id="sorted函数语法"><a href="#sorted函数语法" class="headerlink" title="sorted函数语法"></a>sorted函数语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable, *, key=<span class="keyword">None</span>, reverse=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><ul><li><code>iterable</code>：可迭代对象</li><li><code>key</code>：键函数，这个参数很关键，它接受一个参数并返回另一个用作排序键的值；更通俗地来说，<strong>键函数的作用就是在排序开始之前对<code>iterable</code>中的每个元素进行转换(转换的结果可以是一个字符、数字或者列表)，然后使用转换之后的元素而不是原始的元素进行排序，从而得到一个排序的索引，最终将该索引再map回原始元素来得到最终的排序结果</strong></li><li><code>reverse</code>：排序规则，<code>reverse = True</code>表示按照ASCII码降序排列 ， <code>reverse = False</code> 表示按照ASCII码升序（默认）排列</li></ul><hr><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="key函数的理解"><a href="#key函数的理解" class="headerlink" title="key函数的理解"></a>key函数的理解</h3><p>对字典进行排序：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line">x.items()</span><br><span class="line">  dict_items([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照字典的value值进行排序，所以使用的是item[1]</span></span><br><span class="line">&#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(x.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])&#125;</span><br><span class="line">  &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照字典的key进行排序</span></span><br><span class="line">&#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(x.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">0</span>])&#125;</span><br><span class="line">  &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p>在按照<code>value</code>值排序是，<code>key</code>函数的作用就相当于将最开始的对<code>[(1, 2), (3, 4), (4, 3), (2, 1), (0, 0)]</code>排序转换为了对<code>[2,4,3,1,0]</code>的排序，在对<code>[2,4,3,1,0]</code>排完序后会得到一个索引，最后将该索引应用于<code>[(1, 2), (3, 4), (4, 3), (2, 1), (0, 0)]</code>即可完成排序。</p><hr><h3 id="对iterable的理解"><a href="#对iterable的理解" class="headerlink" title="对iterable的理解"></a>对iterable的理解</h3><h4 id="简单的可迭代对象"><a href="#简单的可迭代对象" class="headerlink" title="简单的可迭代对象"></a>简单的可迭代对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对列表排序</span></span><br><span class="line">sorted([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>])</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字符串排序</span></span><br><span class="line">sorted(<span class="string">'adcb'</span>)</span><br><span class="line">  sorted(<span class="string">'adcb'</span>)</span><br></pre></td></tr></table></figure><p>简单的可迭代对象的比较非常容易理解，就是单个元素之间的比较。</p><h4 id="嵌套的可迭代对象"><a href="#嵌套的可迭代对象" class="headerlink" title="嵌套的可迭代对象"></a>嵌套的可迭代对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">'aef'</span>,<span class="string">'abc'</span>]</span><br><span class="line">sorted(b)</span><br><span class="line">  [<span class="string">'abc'</span>, <span class="string">'aef'</span>]</span><br></pre></td></tr></table></figure><p>上面是<strong>列表可迭代对象嵌套字符串可迭代对象</strong>的排序，排序时<strong>对内部的两个字符串可迭代对象按照位置依次比较</strong>：<code>&#39;a&#39;-&gt;&#39;a&#39;</code>，<code>&#39;b&#39;-&gt;&#39;e&#39;</code>，<code>&#39;c&#39;-&gt;&#39;f&#39;</code>，只要出现一个可以区分出顺序如<code>&#39;b&#39; &gt; &#39;e&#39;</code>，那么比较就结束，最终顺序就是<code>[&#39;abc&#39;, &#39;aef&#39;]</code></p><p>需要注意的是，<strong>不能将数字和字符串直接进行比较</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="string">'test'</span>,<span class="number">1</span>])</span><br><span class="line">  TypeError: <span class="string">'&lt;'</span> <span class="keyword">not</span> supported between instances of <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br><span class="line"></span><br><span class="line">sorted([<span class="string">'test'</span>,<span class="string">'1'</span>])</span><br><span class="line">  [<span class="string">'1'</span>, <span class="string">'test'</span>]</span><br></pre></td></tr></table></figure><p></p><p>再多一层嵌套：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">'test'</span>,<span class="number">1</span>]</span><br><span class="line">b=[<span class="string">'abc'</span>,<span class="string">'def'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个其实是'abc'和'test'，因为已经区分出顺序了</span></span><br><span class="line"><span class="comment"># 所以不能进行后续的'def'和1的比较，不然就会报错</span></span><br><span class="line">sorted([a,b])</span><br><span class="line">  [[<span class="string">'abc'</span>, <span class="string">'def'</span>], [<span class="string">'test'</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是下面这种情况</span></span><br><span class="line">a=[<span class="string">'abc'</span>,<span class="number">1</span>]</span><br><span class="line">b=[<span class="string">'abc'</span>,<span class="string">'def'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为'abc'和'abc'不能区分出顺序，所以会进行'def'和1的比较</span></span><br><span class="line">sorted([a,b])</span><br><span class="line">  TypeError: <span class="string">'&lt;'</span> <span class="keyword">not</span> supported between instances of <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="对字母和数字混用的字符串排序"><a href="#对字母和数字混用的字符串排序" class="headerlink" title="对字母和数字混用的字符串排序"></a>对字母和数字混用的字符串排序</h3><p>这种排序也叫<code>natural sort</code>，在<code>Linux</code>写试用<code>sort</code>命令加上<code>-V</code>参数即可实现，但是在<code>Python</code>中并没有这种方法，所以需要自己想办法，下面是<a href="https://stackoverflow.com/questions/2545532/python-analog-of-phps-natsort-function-sort-a-list-using-a-natural-order-alg" target="_blank" rel="noopener">Python analog of PHP’s natsort function (sort a list using a “natural order” algorithm)</a>中一个回答的代码，这里学习一下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">natural_key</span><span class="params">(string_)</span>:</span></span><br><span class="line">    <span class="string">"""See http://www.codinghorror.com/blog/archives/001018.html"""</span></span><br><span class="line">    <span class="keyword">return</span> [int(s) <span class="keyword">if</span> s.isdigit() <span class="keyword">else</span> s <span class="keyword">for</span> s <span class="keyword">in</span> re.split(<span class="string">r'(\d+)'</span>, string_)]</span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=[<span class="string">'image1.jpg'</span>, <span class="string">'image12.jpg'</span>, <span class="string">'image15.jpg'</span>, <span class="string">'image3.jpg'</span>]</span><br><span class="line">sorted(test, key=natural_key)</span><br><span class="line">  [<span class="string">'image1.jpg'</span>, <span class="string">'image3.jpg'</span>, <span class="string">'image12.jpg'</span>, <span class="string">'image15.jpg'</span>]</span><br></pre></td></tr></table></figure><p></p><p>代码解读:<br>首先是使用了列表内涵，并且嵌套了<code>for</code>和<code>if</code>这两个流程控制，还原代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> re.split(<span class="string">r'(\d+)'</span>, string_):</span><br><span class="line">  <span class="keyword">if</span> s.isdigit():</span><br><span class="line">    int(s)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    s</span><br></pre></td></tr></table></figure><p></p><p>需要注意的就是这种<strong>带条件判断的列表内涵中<code>if</code>的位置</strong>，之前使用的列表内涵一般都是将代码结构<strong>线性铺开</strong>，而<strong>这里是将<code>if</code>条件判断前移，主要原因是<code>else</code>语句的存在</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 如果不存在else语句，最后的输出值就只有i</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i&lt;<span class="number">3</span>]</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多了else语句就相当于多了输出值</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 再次线性铺开就会报错</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i&lt;<span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">  SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line"><span class="comment"># if语句前移即可</span></span><br><span class="line">[i <span class="keyword">if</span> i&lt;<span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> a ]</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p></p><p>代码解读完了再回归到这里的<code>sorted</code>函数上来，之前也说过，<code>key</code>函数的作用其实就是在排序开始之前将原始的元素进行转换，然后使用转换之后的元素进行排序，这里的<code>natural_key</code>函数也是一样：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># natural_key函数对原始元素的转换</span></span><br><span class="line"><span class="comment"># 转换完之后再结合之前的内容将就不难理解排序的过程了</span></span><br><span class="line">[int(s) <span class="keyword">if</span> s.isdigit() <span class="keyword">else</span> s <span class="keyword">for</span> s <span class="keyword">in</span> re.split(<span class="string">r'(\d+)'</span>, <span class="string">'image1.jpg'</span>) ]</span><br><span class="line">  [<span class="string">'image'</span>, <span class="number">1</span>, <span class="string">'.jpg'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="依据另一个列表的顺序排序"><a href="#依据另一个列表的顺序排序" class="headerlink" title="依据另一个列表的顺序排序"></a>依据另一个列表的顺序排序</h3><p>需求：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'e'</span>]</span><br><span class="line">b = [<span class="string">'a001'</span>,<span class="string">'b002'</span>,<span class="string">'c003'</span>,<span class="string">'d004'</span>,<span class="string">'e005'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据a列表中元素的顺序来对b列表进行排序</span></span><br><span class="line">c = [<span class="string">'c003'</span>,<span class="string">'d004'</span>,<span class="string">'b002'</span>,<span class="string">'a001'</span>,<span class="string">'e005'</span>]</span><br></pre></td></tr></table></figure><p></p><p>解决方法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = sorted(b, key = <span class="keyword">lambda</span> x: a.index(x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">a.index(<span class="string">'c'</span>)</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>解读：这里与前面对原始的列表元素进行转换并使用转换后的元素进行排序并最终得到索引的方法不同，这里得到索引的方式<strong>也是对原始元素进行转换然而不是对转换后的元素进行排序，而是查询转换后的元素在另一个列表中的顺序来得到索引</strong>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener">Built-in Functions——sorted</a></li><li><a href="https://www.geeksforgeeks.org/sorted-function-python/" target="_blank" rel="noopener">Sorted() function in Python</a></li><li><a href="https://stackoverflow.com/questions/2545532/python-analog-of-phps-natsort-function-sort-a-list-using-a-natural-order-alg" target="_blank" rel="noopener">Python analog of PHP’s natsort function (sort a list using a “natural order” algorithm)</a></li><li><a href="https://stackoverflow.com/questions/23069055/python-sort-a-list-by-another-list" target="_blank" rel="noopener">Python, sort a list by another list</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章对&lt;code&gt;sorted&lt;/code&gt;函数进行了详细的学习和理解，主要包括其&lt;strong&gt;排序的原理和过程&lt;/strong&gt;以及 &lt;strong&gt;&lt;code&gt;key&lt;/code&gt;函数的理解&lt;/strong&gt;，最后&lt;strong&gt;结合了对两个常用情形示例的解读加深了理解&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之装饰器的使用</title>
    <link href="http://showteeth.tech/posts/16624.html"/>
    <id>http://showteeth.tech/posts/16624.html</id>
    <published>2020-05-23T05:17:12.000Z</published>
    <updated>2020-05-24T01:44:07.398Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>Python中装饰器的用法</strong>，主要学习了<strong>装饰器的作用</strong>、<strong>使用形式</strong>、<strong>多个装饰器的使用</strong>、<strong>对带参数的函数进行装饰</strong>、<strong>带参数的装饰器</strong>、<strong>基于类的装饰器</strong>以及<strong>装饰器的副作用与解决办法</strong>。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>装饰器本质上是一个 <code>Python</code> 函数或类，它可以<strong>让其他函数或类在不需要做任何代码修改的前提下增加额外功能</strong>，装饰器的<strong>返回值也是一个函数/类对象</strong>。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。<strong>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能</strong>。</p><hr><h2 id="装饰器示例"><a href="#装饰器示例" class="headerlink" title="装饰器示例"></a>装饰器示例</h2><p>为了更好地理解装饰器，我们先从一个简单的例子开始，假设有下面的函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><p></p><p>现在我们想<strong>增强 <code>hello()</code> 函数的功能</strong>，希望给返回加上 <code>HTML</code> 标签，比如 <code>&lt;i&gt;hello world&lt;/i&gt;</code>，但是有一个要求，不改变原来 <code>hello()</code> 函数的定义。这里当然有很多种方法，下面给出一种跟本文相关的方法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中，我们定义了一个函数 <code>makeitalic</code>，该函数有一个参数 <code>func</code>，它是一个函数；在 <code>makeitalic</code> 函数里面我们又定义了一个内部函数 <code>wrapped</code>，并<strong>将该函数作为返回</strong>。</p><p>现在，我们就可以不改变 <code>hello()</code> 函数的定义，给返回加上 <code>HTML</code> 标签了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello = makeitalic(hello)</span><br><span class="line">hello()</span><br><span class="line">  <span class="string">'&lt;i&gt;hello world&lt;/i&gt;'</span></span><br></pre></td></tr></table></figure><p>在上面，我们将 <code>hello</code> 函数传给 <code>makeitalic</code>，再将返回赋给 <code>hello</code>，此时调用 <code>hello()</code> 就得到了我们想要的结果。</p><p>不过要注意的是，由于我们将 <code>makeitalic</code> 的返回赋给了 <code>hello</code>，此时 <code>hello()</code> 函数仍然存在，但是它的函数名不再是 <code>hello</code> 了，而是 <code>wrapped</code>，正是 <code>makeitalic</code> 返回函数的名称，可以验证一下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前hello函数的名称</span></span><br><span class="line">hello.__name__</span><br><span class="line">  <span class="string">'wrapped'</span></span><br></pre></td></tr></table></figure><p></p><p>对于这个小瑕疵，后文将会给出解决方法。</p><p>现在，我们梳理一下上面的例子，为了增强原函数 <code>hello</code> 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，完整的代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的hello是增强之后的hello</span></span><br><span class="line">hello = makeitalic(hello)</span><br></pre></td></tr></table></figure><p></p><p>事实上，<code>makeitalic</code> 就是一个装饰器（<code>decorator</code>），它『装饰』了函数 <code>hello</code>，并返回一个函数，将其赋给 <code>hello</code>。</p><p>一般情况下，我们使用装饰器提供的 <code>@</code> 语法糖（<code>Syntactic Sugar</code>），来简化上面的写法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><p></p><p>像上面的情况，可以<strong>动态修改函数（或类）功能的函数就是装饰器</strong>。本质上，它是一个高阶函数，<strong>以被装饰的函数（比如上面的 hello）为参数</strong>，并<strong>返回一个包装后的函数（比如上面的 wrapped）给被装饰函数（hello）</strong>。</p><hr><h2 id="装饰器的使用形式"><a href="#装饰器的使用形式" class="headerlink" title="装饰器的使用形式"></a>装饰器的使用形式</h2><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p>装饰器的一般使用形式如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>等价于下面的形式：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p>装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_one</span></span><br><span class="line"><span class="meta">@decorator_two</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>等价于下面的形式：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func = decorator_one(decorator_two(func))</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器还可以带参数，用于得到不同的装饰器，比如：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator(arg1, arg2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>等价于下面的形式：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先得到装饰器decorator(arg1, arg2)</span></span><br><span class="line"><span class="comment"># 然后再去装饰函数func</span></span><br><span class="line">func = decorator(arg1, arg2)(func)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="多个装饰器-1"><a href="#多个装饰器-1" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>前面示例中已经了解了单个装饰器的使用，这里了解一下多个装饰器的用法:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + func() + <span class="string">'&lt;/b&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + func() + <span class="string">'&lt;/i&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里添加了两个装饰器</span></span><br><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><p></p><p>上面定义了两个装饰器，对 <code>hello</code> 进行装饰，<strong>上面的最后几行代码相当于</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">hello = makebold(makeitalic(hello))</span><br></pre></td></tr></table></figure><p></p><p>调用函数 <code>hello</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello()</span><br><span class="line">  <span class="string">'&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="对带参数的函数进行装饰"><a href="#对带参数的函数进行装饰" class="headerlink" title="对带参数的函数进行装饰"></a>对带参数的函数进行装饰</h2><p>前面的例子中，被装饰的函数 <code>hello()</code> 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 <code>hello()</code> 函数进行改写，使其带参数，如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + ret + <span class="string">'&lt;/i&gt;'</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">(name1, name2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello %s, %s'</span> % (name1, name2)</span><br></pre></td></tr></table></figure><p></p><p>由于函数 <code>hello</code> 带参数，因此内嵌包装函数 <code>wrapped</code> 也做了一点改变：内嵌包装函数的参数传给了 <code>func</code>，即被装饰函数，也就是说<strong>内嵌包装函数的参数跟被装饰函数的参数对应</strong>，这里使用了 <code>(*args, **kwargs)</code>，是为了适应可变参数。关于<em>args, **kwargs这两种类型的参数可以参考：[Python系列之</em>args和**kwargs的作用](<a href="http://showteeth.tech/posts/38814.html">http://showteeth.tech/posts/38814.html</a>)</p><p>看看使用：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个参数的</span></span><br><span class="line">hello(<span class="string">'python'</span>)</span><br><span class="line">  <span class="string">'&lt;i&gt;hello python&lt;/i&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个参数的</span></span><br><span class="line">hello2(<span class="string">'python'</span>, <span class="string">'java'</span>)</span><br><span class="line">  <span class="string">'&lt;i&gt;hello python, java&lt;/i&gt;'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="带参数的装饰器-1"><a href="#带参数的装饰器-1" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>上面的例子是对带参数的函数进行装饰，而这里是装饰器本身就带有参数，其实就是再外加一层函数用于根据指定的参数生成装饰器。</p><p>之前我们增强了函数 <code>hello</code> 的功能，给它的返回加上了标签 <code>&lt;i&gt;...&lt;/i&gt;</code>，现在，我们想改用标签 <code>&lt;b&gt;...&lt;/b&gt;</code> 或 <code>&lt;p&gt;...&lt;/p&gt;</code>。是不是要像前面一样，再定义一个类似 <code>makeitalic</code> 的装饰器呢？其实，我们可以<strong>定义一个函数，将标签作为参数，返回一个装饰器</strong>，比如：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap_in_tag</span><span class="params">(tag)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;'</span> + tag + <span class="string">'&gt;'</span> + ret + <span class="string">'&lt;/'</span> + tag + <span class="string">'&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p></p><p>现在，我们可以根据需要生成想要的装饰器了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">makebold = wrap_in_tag(<span class="string">'b'</span>)  <span class="comment"># 根据 'b' 返回 makebold 生成器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用增强之后的函数</span></span><br><span class="line">hello(<span class="string">'world'</span>)</span><br><span class="line">  <span class="string">'&lt;b&gt;hello world&lt;/b&gt;'</span></span><br></pre></td></tr></table></figure><p></p><p>上面的形式也可以写得更加简洁：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wrap_in_tag('b')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</span><br></pre></td></tr></table></figure><p></p><p>这就是带参数的装饰器，其实就是在装饰器外面多了一层包装，根据不同的参数返回不同的装饰器。</p><hr><h2 id="基于类的装饰器"><a href="#基于类的装饰器" class="headerlink" title="基于类的装饰器"></a>基于类的装饰器</h2><p>前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bold</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + self.func(*args, **kwargs) + <span class="string">'&lt;/b&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bold</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">hello(<span class="string">'world'</span>)</span><br><span class="line">  <span class="string">'&lt;b&gt;hello world&lt;/b&gt;'</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到，类 <code>Bold</code> 有两个方法：</p><ul><li><code>__init__()</code>：它<strong>接收一个函数作为参数，也就是被装饰的函数</strong></li><li><code>__call__()</code>：<strong>让类对象可调用</strong>，就像函数调用一样，在调用被装饰函数时被调用</li></ul><p>还可以让<strong>类装饰器带参数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag)</span>:</span></span><br><span class="line">        self.tag = tag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;&#123;tag&#125;&gt;&#123;res&#125;&lt;/&#123;tag&#125;&gt;"</span>.format(</span><br><span class="line">                res=func(*args, **kwargs), tag=self.tag</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tag('b')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是，如果类装饰器有参数，则 <code>__init__</code> 接收参数，而 <code>__call__</code> 接收 <code>func</code>。</p><hr><h2 id="装饰器的副作用"><a href="#装饰器的副作用" class="headerlink" title="装饰器的副作用"></a>装饰器的副作用</h2><p>前面提到，使用装饰器有一个瑕疵，<strong>就是被装饰的函数，它的函数名称已经不是原来的名称了</strong>，回到最开始的例子：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><p></p><p>函数 <code>hello</code> 被 <code>makeitalic</code> 装饰后，它的函数名称已经改变了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.__name__</span><br><span class="line">  <span class="string">'wrapped'</span></span><br></pre></td></tr></table></figure><p></p><p>为了消除这样的副作用，<code>Python</code> 中的 <code>functools</code> 包提供了几种装饰器相关的高级函数，如<code>wraps</code>、<code>update_wrapper</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 加上 wraps 装饰器</span></span><br><span class="line"><span class="meta">    @wraps(func)       </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上wraps 装饰器之后再次查看名称</span></span><br><span class="line">hello.__name__</span><br><span class="line">  <span class="comment"># 这里已经变成了原始的名称</span></span><br><span class="line">  <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>本质上，<strong>装饰器就是一个返回函数</strong>的高阶函数。</li><li>装饰器可以<strong>动态地修改一个类或函数的功能</strong>，通过在原有的类或者函数上包裹一层修饰类或修饰函数实现。</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wiki.jikexueyuan.com/project/explore-python/Functional/decorator.html" target="_blank" rel="noopener">装饰器</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;Python中装饰器的用法&lt;/strong&gt;，主要学习了&lt;strong&gt;装饰器的作用&lt;/strong&gt;、&lt;strong&gt;使用形式&lt;/strong&gt;、&lt;strong&gt;多个装饰器的使用&lt;/strong&gt;、&lt;strong&gt;对带参数的函数进行装饰&lt;/strong&gt;、&lt;strong&gt;带参数的装饰器&lt;/strong&gt;、&lt;strong&gt;基于类的装饰器&lt;/strong&gt;以及&lt;strong&gt;装饰器的副作用与解决办法&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之*args和**kwargs的作用</title>
    <link href="http://showteeth.tech/posts/38814.html"/>
    <id>http://showteeth.tech/posts/38814.html</id>
    <published>2020-05-23T03:23:47.000Z</published>
    <updated>2020-05-24T01:42:41.133Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了函数中<strong>可变参数</strong>的两种形式<code>*args</code>和<code>**kwargs</code>，主要学习了这<strong>两种参数的用法</strong>以及<strong>在与其他类型的参数联合使用时的顺序问题</strong>。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>*args</code>和<code>**kwargs</code>是我在查看源码时经常看到的两个参数，主要出现在各种函数中。这<strong>两个参数都是表示给函数传不定数量的参数(不确定最后使用这个函数的时候会传递多少参数，也叫可变参数)</strong>，两者的差异主要表现在：</p><ul><li><code>*args</code>：接收不定量的<strong>非关键字参数</strong>，如<code>testFun(&#39;Hello&#39;, &#39;Welcome&#39;)</code></li><li><code>**kwargs</code>：接收不定量个<strong>关键字参数</strong>，如<code>testFun(x=1, y=2)</code></li></ul><p><code>*args</code>和<code>**kwargs</code>参数关键的是最前面的<code>*</code>和<code>**</code>，后面的 <strong><code>args</code>和<code>kwargs</code>只是约定俗成的叫法而已</strong>，也可以使用<code>*vars</code>和<code>**kwvars</code>进行代替。</p><hr><h2 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h2><p><code>*args</code>可以用于接收不定量的<strong>非关键字参数</strong>，下面使用几个例子来加深对其的理解.</p><p><strong>完全的不定量的非关键字参数(可变参数)</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(arg)</span><br><span class="line"></span><br><span class="line">print_func(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'str'</span>, [])</span><br><span class="line">  &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class">  <span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'str'</span>, [])</span></span></span><br><span class="line"><span class="class">  1</span></span><br><span class="line"><span class="class">  2</span></span><br><span class="line"><span class="class">  <span class="title">str</span></span></span><br><span class="line"><span class="class">  []</span></span><br></pre></td></tr></table></figure><p></p><p>从上面的输出结果可以看出，函数接收的<code>*args</code>会被存放在一个<code>tuple</code>中。</p><p><strong>增加普通参数x,y</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(x,y,*args)</span>:</span></span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(arg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的1,2分别对应前面的x,y，可变参数只剩下了'str', []</span></span><br><span class="line">print_func(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'str'</span>, [])</span><br><span class="line">  &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class">  <span class="params">(<span class="string">'str'</span>, [])</span></span></span><br><span class="line"><span class="class">  <span class="title">str</span></span></span><br><span class="line"><span class="class">  []</span></span><br></pre></td></tr></table></figure><p></p><p><strong>调整普通参数和可变参数的顺序</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(*args,x,y)</span>:</span></span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(arg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时会报错</span></span><br><span class="line">print_func(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'str'</span>, [])</span><br><span class="line">  -</span><br><span class="line">  TypeError                                 Traceback (most recent call last)</span><br><span class="line">  &lt;ipython-input<span class="number">-224</span><span class="number">-570961470325</span>&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        <span class="number">5</span>         print(arg)</span><br><span class="line">        <span class="number">6</span> </span><br><span class="line">  ----&gt; 7 print_func(1, 2, 'str', [])</span><br><span class="line"></span><br><span class="line">  TypeError: print_func() missing <span class="number">2</span> required keyword-only arguments: <span class="string">'x'</span> <span class="keyword">and</span> <span class="string">'y'</span></span><br></pre></td></tr></table></figure><p></p><p>上面的输出内容表明，<strong>可变参数一定要在普通参数之后，如果调换顺序会报错</strong>。</p><hr><h2 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a>**kwargs</h2><p><code>**kwargs</code>可以用于接收不定量个<strong>关键字参数</strong>，下面依旧是使用几个例子来进行学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(type(kwargs))</span><br><span class="line">    print(kwargs)</span><br><span class="line">    <span class="keyword">for</span> kwarg <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(kwarg)</span><br><span class="line"></span><br><span class="line">print_func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="string">'str'</span>, d=[])</span><br><span class="line">  &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">  &#123;'a': 1, 'b': 2, 'c': 'str', 'd': []&#125;</span><br><span class="line">  (<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">  (<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line">  (<span class="string">'c'</span>, <span class="string">'str'</span>)</span><br><span class="line">  (<span class="string">'d'</span>, [])</span><br></pre></td></tr></table></figure><p>从上面的输出结果可以看出：不同于<code>*args</code>传递的参数会被存放在<code>tuple</code>中，<code>**kwargs</code>传递的参数会被存放在<code>字典</code>中。</p><p>接下来依旧是顺序问题：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变参数在普通参数之后</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(x,y,**kwargs)</span>:</span></span><br><span class="line">    print(type(kwargs))</span><br><span class="line">    print(kwargs)</span><br><span class="line">    <span class="keyword">for</span> kwarg <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(kwarg)</span><br><span class="line"></span><br><span class="line">print_func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="string">'str'</span>, d=[])</span><br><span class="line">  &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">  &#123;'c': 'str', 'd': []&#125;</span><br><span class="line">  (<span class="string">'c'</span>, <span class="string">'str'</span>)</span><br><span class="line">  (<span class="string">'d'</span>, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可变参数在普通参数之前</span></span><br><span class="line"><span class="comment">## 仍旧报错</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(**kwargs,x,y)</span>:</span></span><br><span class="line">    print(type(kwargs))</span><br><span class="line">    print(kwargs)</span><br><span class="line">    <span class="keyword">for</span> kwarg <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(kwarg)</span><br><span class="line"></span><br><span class="line">print_func(c=<span class="string">'str'</span>, d=[],<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  File <span class="string">"&lt;ipython-input-235-01d144bf7b9f&gt;"</span>, line <span class="number">1</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(**kwargs,x,y)</span>:</span></span><br><span class="line">                              ^</span><br><span class="line">  SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p></p><p>上面的输出内容表明，<strong>可变参数一定要在普通参数之后，如果调换顺序会报错</strong>。</p><hr><h2 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h2><p>目前已经出现了两种参数类型(还有一种是默认参数)，前面的示例中也可以看出，<strong>普通参数在和可变参数混用时需要注意顺序问题</strong>，具体来说：<strong><code>普通参数</code>&gt;<code>默认参数</code>&gt;<code>*args</code>&gt;`</strong>kwargs`**.<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">(x, *args, **kwargs)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同参数类型混用</span></span><br><span class="line">print_func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, y=<span class="number">1</span>, a=<span class="number">2</span>, b=<span class="number">3</span>, c=<span class="number">4</span>)</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">  &#123;<span class="string">'y'</span>: <span class="number">1</span>, <span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.geeksforgeeks.org/args-kwargs-python/" target="_blank" rel="noopener">*args and **kwargs in Python</a></li><li><a href="https://python.freelycode.com/contribution/detail/427" target="_blank" rel="noopener">*args和**kwargs在Python中的作用</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了函数中&lt;strong&gt;可变参数&lt;/strong&gt;的两种形式&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;，主要学习了这&lt;strong&gt;两种参数的用法&lt;/strong&gt;以及&lt;strong&gt;在与其他类型的参数联合使用时的顺序问题&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之functools-控制函数的工具</title>
    <link href="http://showteeth.tech/posts/1848.html"/>
    <id>http://showteeth.tech/posts/1848.html</id>
    <published>2020-05-23T01:19:54.000Z</published>
    <updated>2020-05-24T01:43:22.081Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>Python</code>中功能强大的模块<code>functools</code>，这里主要学习了可以<strong>固定函数(方法)的某些参数的函数并返回函数的<code>partial</code>和<code>partialmethod</code></strong>，可以用于<strong>消除装饰器副作用的装饰器函数<code>wraps</code>和<code>update_wrapper</code></strong>，可以<strong>进行化简运算的函数<code>reduce</code></strong>，可以<strong>将比较函数转化为键函数的<code>cmp_to_key</code></strong>。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>functools</code> 是 <code>Python</code> 中很简单但也很重要的模块，主要是一些 <code>Python</code> 高阶函数相关的函数。 关于<strong>高阶函数</strong>，这是函数式编程范式中很重要的一个概念，简单地说， 就是一个<strong>可以接受函数作为参数或者以函数作为返回值的函数</strong>，因为 <code>Python</code> 中函数是一类对象， 因此很容易支持这样的函数式特性。</p><p><code>functools</code>中比较常用的函数如下：</p><ul><li><code>partial</code>：固定函数的某些参数，返回一个新的函数</li><li><code>partialmethod</code>：针对方法的<code>partial</code>函数</li><li><code>wraps</code>：消除装饰器函数带来的副作用</li><li><code>update_wrapper</code>：功能更加强大的<code>wraps</code></li><li><code>reduce</code>：化简函数</li><li><code>cmp_to_key</code>：将比较函数转化为键函数</li></ul><p><code>functools</code>中所有的函数如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">functools.__all__</span><br><span class="line">  [<span class="string">'update_wrapper'</span>,</span><br><span class="line">   <span class="string">'wraps'</span>,</span><br><span class="line">   <span class="string">'WRAPPER_ASSIGNMENTS'</span>,</span><br><span class="line">   <span class="string">'WRAPPER_UPDATES'</span>,</span><br><span class="line">   <span class="string">'total_ordering'</span>,</span><br><span class="line">   <span class="string">'cmp_to_key'</span>,</span><br><span class="line">   <span class="string">'lru_cache'</span>,</span><br><span class="line">   <span class="string">'reduce'</span>,</span><br><span class="line">   <span class="string">'partial'</span>,</span><br><span class="line">   <span class="string">'partialmethod'</span>,</span><br><span class="line">   <span class="string">'singledispatch'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="偏函数相关"><a href="#偏函数相关" class="headerlink" title="偏函数相关"></a>偏函数相关</h2><h3 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h3><p><code>partial</code>的作用：<strong>把一个函数的某些参数给固定住（也就是设置默认值）</strong>，<strong>返回一个新的函数</strong>，调用这个新函数会更简单。接下来将使用示例进行学习。</p><p>假设有如下函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure><p></p><p>现在，我们想<strong>返回某个数的2倍</strong>，即：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3的两倍</span></span><br><span class="line">multiply(<span class="number">3</span>, y=<span class="number">2</span>)</span><br><span class="line">  <span class="number">6</span></span><br><span class="line"><span class="comment"># 4的两倍</span></span><br><span class="line">multiply(<span class="number">4</span>, y=<span class="number">2</span>)</span><br><span class="line">  <span class="number">8</span></span><br></pre></td></tr></table></figure><p></p><p>上面的调用有点繁琐，每次都要传入 <code>y=2</code>，我们想到可以定义一个新的函数，<strong>把 <code>y=2</code> 作为默认值</strong>，即：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x, y=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> multiply(x, y)</span><br></pre></td></tr></table></figure><p></p><p>现在，我们可以这样调用了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用带默认值的函数计算</span></span><br><span class="line">double(<span class="number">3</span>)</span><br><span class="line">  <span class="number">6</span></span><br><span class="line">double(<span class="number">4</span>)</span><br><span class="line">  <span class="number">8</span></span><br></pre></td></tr></table></figure><p></p><p>上面设置默认值的方法虽然可以达到目的，但是需要重新定义一个函数，同时如果<code>y</code>值发生了变化还需要每次修改，比较麻烦，这里可以使用<code>partial</code>达到类似的目的，并且不用重新定义函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="comment"># multiply函数保持不变，设置y的默认值</span></span><br><span class="line">double = partial(multiply, y=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">double(<span class="number">3</span>)</span><br><span class="line">  <span class="number">6</span></span><br></pre></td></tr></table></figure><p></p><p><code>partial</code> 接收函数 <code>multiply</code> 作为参数，固定 <code>multiply</code> 的参数 <code>y=2</code>，并返回一个新的函数给 <code>double</code>，这跟我们自己定义 <code>double</code> 函数的效果是一样的。</p><p>所以，简单而言，<strong><code>partial</code> 函数的功能就是：把一个函数的某些参数给固定住，返回一个新的函数</strong>。</p><div class="note info"><p>需要注意的是：<strong>使用<code>partial</code>函数来固定某些参数的时候最好是指定固定哪个参数的值</strong>，如<code>partial(multiply, y=2)</code>，而不是直接<code>partial(multiply, 2)</code>，因为<strong>默认会从参数的最左边来设置</strong>，那么<code>partial(multiply, 2)</code>就等同于<code>partial(multiply, x=2)</code>。</p></div><hr><h3 id="partialmethod"><a href="#partialmethod" class="headerlink" title="partialmethod"></a>partialmethod</h3><p><code>partialmethod</code>的作用基本类似于 <code>partial</code>， 不过<strong>仅作用于方法</strong>。举个例子就很容易明白：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._alive = <span class="keyword">False</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._alive</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        self._alive = bool(state)</span><br><span class="line">    set_alive = partialmethod(set_state, <span class="keyword">True</span>)</span><br><span class="line">    set_dead = partialmethod(set_state, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">c = Cell()</span><br><span class="line">c.alive         </span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line">c.set_alive()</span><br><span class="line">c.alive         </span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="装饰器相关"><a href="#装饰器相关" class="headerlink" title="装饰器相关"></a>装饰器相关</h2><p>说到<strong>接受函数为参数，以函数为返回值</strong>，在 <code>Python</code> 中最常用的当属装饰器了。 <code>functools</code> 库中装饰器相关的函数是 <code>update_wrapper</code>、<code>wraps</code>，还搭配 <code>WRAPPER_ASSIGNMENTS</code> 和 <code>WRAPPER_UPDATES</code> 两个常量使用，<strong>作用就是消除 <code>Python</code> 装饰器的一些负面作用</strong>。</p><p>学习<code>functools</code>库中装饰器相关函数的基础是 <strong><code>Python</code>中装饰器的使用</strong>以及<strong>使用装饰器可能带来的副作用</strong>，具体可以查看这篇文章：<a href="http://showteeth.tech/posts/16624.html">Python系列之装饰器的使用</a>。简单来书就是<code>Python</code>中的装饰器虽然<strong>可以在不修改原始函数的基础上动态地修改函数的功能</strong>，但使用之后<strong>函数的名称就会发生改变</strong>，而如果想去除这种副作用就需要使用<code>functools</code>中的相关函数.</p><h3 id="wraps"><a href="#wraps" class="headerlink" title="wraps"></a>wraps</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看函数的名称</span></span><br><span class="line">add.__name__</span><br><span class="line">  <span class="string">'wrapper'</span></span><br></pre></td></tr></table></figure><p>通过上述示例可以看出，函数在经过装饰器装饰之后，其名称会变为装饰器返回的函数名称而不是原本的函数名称。为了消除这个副作用，可以在装饰器中再添加一个装饰器<code>wraps</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看函数名称</span></span><br><span class="line">add.__name__</span><br><span class="line">  <span class="string">'add'</span></span><br></pre></td></tr></table></figure><p></p><p>添加了<code>wraps</code>装饰器之后，会更正的属性定义在 <code>WRAPPER_ASSIGNMENTS</code> 中：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加wraps之后，函数的以下属性会被更正</span></span><br><span class="line">functools.WRAPPER_ASSIGNMENTS</span><br><span class="line">  (<span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__annotations__'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="update-wrapper"><a href="#update-wrapper" class="headerlink" title="update_wrapper"></a>update_wrapper</h3><p><code>update_wrapper</code> 的作用与 <code>wraps</code> 类似，不过功能更加强大，换句话说，<code>wraps</code> 其实是 <code>update_wrapper</code> 的特殊化，实际上 <code>wraps(wrapped)</code> 相当于 <code>partial(update_wrapper, wrapped=wrapped, **kwargs)</code>。</p><p>因此，上面的代码可以用 <code>update_wrapper</code> 重写如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> update_wrapper(wrapper, func)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="reduce-化简函数"><a href="#reduce-化简函数" class="headerlink" title="reduce-化简函数"></a>reduce-化简函数</h2><p><code>reduce</code> 函数的使用形式如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, sequence[, initial])</span><br></pre></td></tr></table></figure><p></p><p>具体来说，<code>reduce</code>函数先将 <code>sequence</code> 的前两个 <code>item</code> 传给 <code>function</code>，即 <code>function(item1, item2)</code>，函数的返回值和 <code>sequence</code> 的下一个 <code>item</code> 再传给 <code>function</code>，即 <code>function(function(item1, item2), item3)</code>，如此迭代，直到 <code>sequence</code> 没有元素，如果有 <code>initial</code>，则作为初始值调用。</p><p>也就是说：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduece(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="comment"># 相当于 ((1 * 2) * 3) * 4</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">  <span class="number">24</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="比较相关"><a href="#比较相关" class="headerlink" title="比较相关"></a>比较相关</h2><h3 id="cmp-to-key"><a href="#cmp-to-key" class="headerlink" title="cmp_to_key"></a>cmp_to_key</h3><p><code>Python2</code>的<code>sorted</code>命令中支持一个参数为<code>cmp</code>，用来定义对象之间的<strong>比较函数</strong>，但 <code>Python3</code> 为了语言的简洁性去掉了 <code>cmp</code> 这个参数，在 <code>Python3</code> 中自定义的比较函数需要通过 <code>cmp_to_key</code> 将比较函数转化成<strong>键函数</strong>，这个函数可以传递给参数<code>key</code>，具体的实现方式这里就不学习了，下面来看一个示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">sorted(range(<span class="number">5</span>), key=cmp_to_key(<span class="keyword">lambda</span> x, y: y-x))</span><br><span class="line">  [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p></p><p>支持使用<code>cmp_to_key</code>的函数包括：<code>sorted()</code>, <code>min()</code>, <code>max()</code>, <code>heapq.nlargest()</code>, <code>heapq.nsmallest()</code>, <code>itertools.groupby()</code>。</p><p>这里补充一下<strong>比较函数和键函数的区别</strong>：</p><ul><li><p><strong>比较函数</strong>是任何可调用的对象，它会接受两个参数，比较它们并根据所提供的参数顺序返回一个数字。负数表示第一个参数小于第二个参数，零表示它们相等，正数表示第一个参数大于第二个参数。一个简单实现可能是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a&lt;b:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">elif</span> a==b:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>键函数</strong>是一个可调用对象，它接受一个参数并返回另一个用作排序键的值。</p></li></ul><p><a href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener">官方文档</a>：</p><blockquote><p>A <strong>comparison function</strong> is any callable that accept <strong>two arguments</strong>, compares them, and returns a negative number for less-than, zero for equality, or a positive number for greater-than. A <strong>key function</strong> is a callable that accepts <strong>one argument</strong> and <strong>returns another value to be used as the sort key</strong>.</p></blockquote><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://pymotw.com/3/functools/index.html#module-functools" target="_blank" rel="noopener">functools — Tools for Manipulating Functions</a></li><li><a href="https://wiki.jikexueyuan.com/project/explore-python/Functional/partial.html" target="_blank" rel="noopener">partial 函数</a></li><li><a href="https://blog.windrunner.me/python/functools.html#python-functools-%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Python functools 模块</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;code&gt;Python&lt;/code&gt;中功能强大的模块&lt;code&gt;functools&lt;/code&gt;，这里主要学习了可以&lt;strong&gt;固定函数(方法)的某些参数的函数并返回函数的&lt;code&gt;partial&lt;/code&gt;和&lt;code&gt;partialmethod&lt;/code&gt;&lt;/strong&gt;，可以用于&lt;strong&gt;消除装饰器副作用的装饰器函数&lt;code&gt;wraps&lt;/code&gt;和&lt;code&gt;update_wrapper&lt;/code&gt;&lt;/strong&gt;，可以&lt;strong&gt;进行化简运算的函数&lt;code&gt;reduce&lt;/code&gt;&lt;/strong&gt;，可以&lt;strong&gt;将比较函数转化为键函数的&lt;code&gt;cmp_to_key&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>R绘图系列-散点图</title>
    <link href="http://showteeth.tech/posts/32524.html"/>
    <id>http://showteeth.tech/posts/32524.html</id>
    <published>2020-05-18T11:14:24.000Z</published>
    <updated>2020-08-08T13:34:16.519Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>R中散点图的画法</strong>，主要包括<strong>针对点的属性如颜色、形状和大小的设置</strong>，<strong>针对分组变量使用不同的形状</strong>，<strong>给点添加border</strong>以及<strong>针对散点太密集出现重叠的两种解决方法</strong>。</p></div><a id="more"></a><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data(<span class="string">"mtcars"</span>)</span><br><span class="line">df &lt;- mtcars</span><br><span class="line">df$cyl &lt;- as.factor(df$cyl)</span><br><span class="line">head(df)</span><br><span class="line">                    mpg cyl disp  hp drat    wt  qsec vs am gear carb</span><br><span class="line">  Mazda RX4         <span class="number">21.0</span>   <span class="number">6</span>  <span class="number">160</span> <span class="number">110</span> <span class="number">3.90</span> <span class="number">2.620</span> <span class="number">16.46</span>  <span class="number">0</span>  <span class="number">1</span>    <span class="number">4</span>    <span class="number">4</span></span><br><span class="line">  Mazda RX4 Wag     <span class="number">21.0</span>   <span class="number">6</span>  <span class="number">160</span> <span class="number">110</span> <span class="number">3.90</span> <span class="number">2.875</span> <span class="number">17.02</span>  <span class="number">0</span>  <span class="number">1</span>    <span class="number">4</span>    <span class="number">4</span></span><br><span class="line">  Datsun <span class="number">710</span>        <span class="number">22.8</span>   <span class="number">4</span>  <span class="number">108</span>  <span class="number">93</span> <span class="number">3.85</span> <span class="number">2.320</span> <span class="number">18.61</span>  <span class="number">1</span>  <span class="number">1</span>    <span class="number">4</span>    <span class="number">1</span></span><br><span class="line">  Hornet <span class="number">4</span> Drive    <span class="number">21.4</span>   <span class="number">6</span>  <span class="number">258</span> <span class="number">110</span> <span class="number">3.08</span> <span class="number">3.215</span> <span class="number">19.44</span>  <span class="number">1</span>  <span class="number">0</span>    <span class="number">3</span>    <span class="number">1</span></span><br><span class="line">  Hornet Sportabout <span class="number">18.7</span>   <span class="number">8</span>  <span class="number">360</span> <span class="number">175</span> <span class="number">3.15</span> <span class="number">3.440</span> <span class="number">17.02</span>  <span class="number">0</span>  <span class="number">0</span>    <span class="number">3</span>    <span class="number">2</span></span><br><span class="line">  Valiant           <span class="number">18.1</span>   <span class="number">6</span>  <span class="number">225</span> <span class="number">105</span> <span class="number">2.76</span> <span class="number">3.460</span> <span class="number">20.22</span>  <span class="number">1</span>  <span class="number">0</span>    <span class="number">3</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="普通散点图"><a href="#普通散点图" class="headerlink" title="普通散点图"></a>普通散点图</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df, aes(x = wt, y = mpg)) + geom_point()</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_basic.png.png" alt="ggplot_point_basic.png"></p><hr><h2 id="设置点的属性"><a href="#设置点的属性" class="headerlink" title="设置点的属性"></a>设置点的属性</h2><p>点的属性可以包括：<strong>颜色</strong>、<strong>大小</strong>和<strong>形状</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df, aes(x = wt, y = mpg)) + </span><br><span class="line">  geom_point(color = <span class="string">"#00AFBB"</span>, </span><br><span class="line">             size = <span class="number">2</span>, </span><br><span class="line">             shape = <span class="number">23</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_property.png.png" alt="ggplot_point_property.png"></p><p><strong>R语言中点的形状可以包括25种</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_shape_all.png.png" alt="ggplot_point_shape_all.png"></p><p>更多的形状可以参考<a href="https://github.com/xiangpin/ggsymbol" target="_blank" rel="noopener">ggsymbol</a>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_shape_ggsymbol.png.png" alt="ggplot_point_shape_ggsymbol.png"></p><hr><h2 id="针对分组变量"><a href="#针对分组变量" class="headerlink" title="针对分组变量"></a>针对分组变量</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df, aes(x = wt, y = mpg)) + </span><br><span class="line">  <span class="comment"># 使用不同的形状以及颜色来表示不同的分组 </span></span><br><span class="line">  geom_point(aes(shape = cyl, color = cyl)) +</span><br><span class="line">  scale_color_manual(values = c(<span class="string">"#00AFBB"</span>, <span class="string">"#E7B800"</span>, <span class="string">"#FC4E07"</span>))</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_group.png.png" alt="ggplot_point_group.png"></p><hr><h2 id="添加border"><a href="#添加border" class="headerlink" title="添加border"></a>添加border</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里不同的颜色要用fill</span></span><br><span class="line"><span class="comment"># 设置pch=21</span></span><br><span class="line">ggplot(df, aes(x = wt, y = mpg, fill=cyl)) + </span><br><span class="line">  geom_point(pch=<span class="number">21</span>,color=<span class="string">"red"</span>,size=<span class="number">4</span>) +</span><br><span class="line">  scale_color_manual(values = c(<span class="string">"#00AFBB"</span>, <span class="string">"#E7B800"</span>, <span class="string">"#FC4E07"</span>))</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_border.png.png" alt="ggplot_point_border.png"></p><hr><h2 id="去除size为0的点"><a href="#去除size为0的点" class="headerlink" title="去除size为0的点"></a>去除size为0的点</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dates = c(<span class="string">"2015-05-01"</span>, <span class="string">"2015-05-02"</span>, <span class="string">"2015-05-03"</span>, <span class="string">"2015-05-04"</span>, <span class="string">"2015-05-05"</span>, <span class="string">"2015-05-06"</span>)</span><br><span class="line">Dates = as.Date(Dates)</span><br><span class="line">Series1 = c(<span class="number">0</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">Series2 = c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">df = data.frame(Dates, Series1, Series2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将range最小值设置为-1即可在图中去除size为0的显示</span></span><br><span class="line"><span class="comment"># 结合break来控制legend的信息</span></span><br><span class="line">ggplot(data = df) +</span><br><span class="line">  geom_line(aes(x = Dates, y = Series1))+</span><br><span class="line">  geom_point(aes(x = Dates, y = Series1, size = Series2))+</span><br><span class="line">  scale_size_continuous(range = c(-<span class="number">1</span>, <span class="number">5</span>), breaks = seq(<span class="number">2.5</span>, <span class="number">10</span>, <span class="number">2.5</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="针对散点存在重叠"><a href="#针对散点存在重叠" class="headerlink" title="针对散点存在重叠"></a>针对散点存在重叠</h2><p>画散点图的时候可能会遇到<strong>点非常密集(某一个横坐标对应很多很密集的纵坐标)</strong>，这样会导致本来想查看的一些数据属性丢失，针对这种情况有两种解决方法：</p><ul><li><strong>jitter图</strong>：给点在一定范围内增加抖动，让点分散一些</li><li><strong>counts图</strong>：用点的大小表示某个范围重叠的点的数目</li></ul><h3 id="jitter图"><a href="#jitter图" class="headerlink" title="jitter图"></a>jitter图</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 突然发现两个ggplot对象相加可以实现子图的效果</span></span><br><span class="line">ggplot(mpg, aes(displ, hwy)) + geom_point() + </span><br><span class="line">  ggplot(mpg, aes(displ, hwy)) +</span><br><span class="line">  geom_point(position = position_jitter(width = <span class="number">0.5</span>, height = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_jitter.png.png" alt="ggplot_point_jitter.png"></p><hr><h3 id="点的大小表示重叠的数目"><a href="#点的大小表示重叠的数目" class="headerlink" title="点的大小表示重叠的数目"></a>点的大小表示重叠的数目</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(mpg, aes(displ, hwy)) + geom_point() + </span><br><span class="line">  ggplot(mpg, aes(displ, hwy)) +</span><br><span class="line">  geom_count()</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot_point_count.png.png" alt="ggplot_point_count.png"></p><p>更多相关设置可以参考：</p><ul><li><a href="https://ggplot2.tidyverse.org/reference/geom_count.html" target="_blank" rel="noopener">Count overlapping points</a></li><li><a href="https://github.com/tidyverse/ggplot2/issues/1666" target="_blank" rel="noopener">设置最大和最小的点的范围</a></li><li><a href="https://stackoverflow.com/questions/45921746/ggplot2-geom-count-set-legend-breaks-to-integers" target="_blank" rel="noopener">修改legend break的数目</a></li></ul><hr><h2 id="嵌套if-else语句"><a href="#嵌套if-else语句" class="headerlink" title="嵌套if-else语句"></a>嵌套if-else语句</h2><p>针对不同的分组，如果想采取不同的显示方式可以在绘图语句中嵌套if-else语句。具体示例参考<a href="#自制dotplot">自制dotplot</a>中的<code>color=ifelse(df$Tissue == &quot;Monkey2&quot;, &quot;blue&quot;, &quot;black&quot;)</code>，该语句针对Monkey1和Monkey2进行了不同的颜色区分。</p><hr><h2 id="自制dotplot"><a href="#自制dotplot" class="headerlink" title="自制dotplot"></a>自制dotplot</h2><h3 id="数据-1"><a href="#数据-1" class="headerlink" title="数据"></a>数据</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">head(immune_genes)</span><br><span class="line">  <span class="comment"># A tibble: 6 x 6</span></span><br><span class="line">  <span class="comment"># Groups:   GeneName [1]</span></span><br><span class="line">    NewStrClusterWithPosition GeneName AverageExp FractionExp Tissue  ScaleExp</span><br><span class="line">    &lt;fct&gt;                     &lt;fct&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;</span><br><span class="line">  <span class="number">1</span> SMC_17|Trachea_1          IL6          <span class="number">0.133</span>       <span class="number">0.125</span>  Monkey1    <span class="number">0.930</span></span><br><span class="line">  <span class="number">2</span> SMC_17|Trachea_2          IL6          <span class="number">0.318</span>       <span class="number">0.222</span>  Monkey2    <span class="number">3.00</span> </span><br><span class="line">  <span class="number">3</span> EC_12|Trachea_1           IL6          <span class="number">0</span>           <span class="number">0</span>      Monkey1   -<span class="number">0.557</span></span><br><span class="line">  <span class="number">4</span> EC_12|Trachea_2           IL6          <span class="number">0.217</span>       <span class="number">0.143</span>  Monkey2    <span class="number">1.87</span> </span><br><span class="line">  <span class="number">5</span> Fib_10|Trachea_1          IL6          <span class="number">0</span>           <span class="number">0</span>      Monkey1   -<span class="number">0.557</span></span><br><span class="line">  <span class="number">6</span> Fib_10|Trachea_2          IL6          <span class="number">0.0869</span>      <span class="number">0.0857</span> Monkey2    <span class="number">0.416</span></span><br></pre></td></tr></table></figure><h3 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dotplot_own=<span class="keyword">function</span>(df,title=<span class="string">'Dotplot'</span>)&#123;</span><br><span class="line">  <span class="comment"># 这一部分是关键，主要是区分fill、color</span></span><br><span class="line">  p=ggplot(df,aes(x = NewStrClusterWithPosition, y = GeneName,</span><br><span class="line">                    size = FractionExp,fill=ScaleExp,</span><br><span class="line">                    <span class="comment"># 这里很关键，区分Monkey1和Monkey2，针对两种使用了不同的方法</span></span><br><span class="line">                    color=ifelse(df$Tissue == <span class="string">"Monkey2"</span>, <span class="string">"blue"</span>, <span class="string">"black"</span>)))+</span><br><span class="line">    geom_point(pch=<span class="number">21</span>) +</span><br><span class="line">    theme_bw()+</span><br><span class="line">    coord_flip()+</span><br><span class="line">    theme(axis.text.x = element_text(size=<span class="number">8</span>,angle=<span class="number">90</span>, hjust=<span class="number">0.5</span>, vjust=<span class="number">0.5</span>))+</span><br><span class="line">    scale_size_continuous(labels = <span class="keyword">function</span>(x) paste0(x*<span class="number">100</span>, <span class="string">"%"</span>),</span><br><span class="line">                          range=c(<span class="number">0</span>,<span class="number">6</span>)) + </span><br><span class="line">    scale_fill_gradient2(low = <span class="string">"black"</span>, mid = <span class="string">"#A9A9A9"</span>, high = <span class="string">"red"</span>,breaks=c(-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>)) +</span><br><span class="line">    <span class="comment"># 自定义legend的信息，需要结合前面的color</span></span><br><span class="line">    scale_colour_manual(name = <span class="string">'Tissue'</span>, </span><br><span class="line">                        values =c(<span class="string">'black'</span>=<span class="string">'black'</span>,<span class="string">'blue'</span>=<span class="string">'blue'</span>), </span><br><span class="line">                        labels = c(<span class="string">'Monkey1'</span>,<span class="string">'Monkey2'</span>)) +</span><br><span class="line">    theme(panel.grid.major = element_blank(),</span><br><span class="line">          panel.grid.minor = element_blank()) +</span><br><span class="line">    labs(y=<span class="string">"GeneName"</span>,x=<span class="string">"CellType&amp;Tissue"</span>,title = title) +</span><br><span class="line">    theme(axis.text.y = element_text(face=<span class="string">"bold"</span>),</span><br><span class="line">          axis.text.x = element_text(face=<span class="string">"bold"</span>),</span><br><span class="line">          plot.title = element_text(hjust = <span class="number">0.5</span>)) +</span><br><span class="line">    guides(size = guide_legend(title.hjust = <span class="number">0.5</span>,order=<span class="number">1</span>),</span><br><span class="line">           fill = guide_colorbar(title.hjust = <span class="number">0.5</span>,order=<span class="number">2</span>),</span><br><span class="line">           color = guide_legend(title.hjust = <span class="number">0.5</span>,order=<span class="number">3</span>,override.aes = list(size=<span class="number">4</span>))) </span><br><span class="line">  <span class="keyword">return</span>(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dotplot_own(immune_genes)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_own_dotplot.png" alt="ggplot2_own_dotplot"></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;R中散点图的画法&lt;/strong&gt;，主要包括&lt;strong&gt;针对点的属性如颜色、形状和大小的设置&lt;/strong&gt;，&lt;strong&gt;针对分组变量使用不同的形状&lt;/strong&gt;，&lt;strong&gt;给点添加border&lt;/strong&gt;以及&lt;strong&gt;针对散点太密集出现重叠的两种解决方法&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/R/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>R绘图系列-分面</title>
    <link href="http://showteeth.tech/posts/45543.html"/>
    <id>http://showteeth.tech/posts/45543.html</id>
    <published>2020-05-18T09:41:02.000Z</published>
    <updated>2020-05-21T15:15:07.896Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>使用ggplot2进行分面图的绘制</strong>，同时学习了<strong>对分面的title以及分面间距调整</strong>的方法。</p></div><a id="more"></a><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">head(total_df)</span><br><span class="line">    Chr       Pos Freq_Total Group</span><br><span class="line">  <span class="number">1</span>   <span class="number">1</span>  <span class="number">58497063</span>  <span class="number">0.0952381</span>   ABE</span><br><span class="line">  <span class="number">2</span>   <span class="number">1</span> <span class="number">119672283</span>  <span class="number">0.1000000</span>   ABE</span><br><span class="line">  <span class="number">3</span>   <span class="number">1</span> <span class="number">153456026</span>  <span class="number">0.1428571</span>   ABE</span><br><span class="line">  <span class="number">4</span>   <span class="number">1</span> <span class="number">163951717</span>  <span class="number">0.3672457</span>   ABE</span><br><span class="line">  <span class="number">5</span>  <span class="number">11</span>   <span class="number">3943200</span>  <span class="number">0.2037037</span>   ABE</span><br><span class="line">  <span class="number">6</span>  <span class="number">11</span>   <span class="number">3943208</span>  <span class="number">0.1363636</span>   ABE</span><br><span class="line"></span><br><span class="line">unique(total_df$Group)</span><br><span class="line">  [<span class="number">1</span>] ABE  ABE2 ABE8 AC   AC2  AC8 </span><br><span class="line">  Levels: AC2 ABE2 AC8 ABE8 AC ABE</span><br></pre></td></tr></table></figure><hr><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>针对<code>Group</code>变量进行分面：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data = total_df, aes(x = Chr, y = Freq_Total)) + </span><br><span class="line">  geom_count(color=<span class="string">"black"</span>,alpha=<span class="number">0.8</span>)  + </span><br><span class="line">  facet_wrap(~Group,nrow=<span class="number">1</span>) + </span><br><span class="line">  scale_size_continuous(name=<span class="string">"Number"</span>,breaks = c(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>),range=c(<span class="number">1</span>,<span class="number">5</span>)) +</span><br><span class="line">  labs(y=<span class="string">"RNA AtoG editing"</span>,x=<span class="string">"Chromosome"</span>) + theme_bw() +</span><br><span class="line">  theme(axis.text.x = element_blank(),</span><br><span class="line">        axis.ticks.x = element_blank())</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_facet_basic0.png.png" alt="ggplot2_facet_basic0.png"></p><hr><h2 id="修改分面的title"><a href="#修改分面的title" class="headerlink" title="修改分面的title"></a>修改分面的title</h2><p>上面分面之后每个子图的标题都是根据Group内容得到的，这里如果想进行修改可以使用如下方法：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个原名和修改之后名称的对应关系</span></span><br><span class="line">lab_names &lt;- c(</span><br><span class="line">  `ABE2` = <span class="string">"ABE2\nn=1483"</span>,</span><br><span class="line">  `ABE8` = <span class="string">"ABE8\nn=664"</span>,</span><br><span class="line">  `ABE` = <span class="string">"ABE\nn=237"</span>,</span><br><span class="line">  `AC2` = <span class="string">"AC2\nn=1346"</span>,</span><br><span class="line">  `AC8` = <span class="string">"AC8\nn=307"</span>,</span><br><span class="line">  `AC` = <span class="string">"AC\nn=429"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改名称</span></span><br><span class="line">ggplot(data = total_df, aes(x = Chr, y = Freq_Total)) + </span><br><span class="line">  geom_count(color=<span class="string">"black"</span>,alpha=<span class="number">0.8</span>)  + </span><br><span class="line">  <span class="comment"># 这里使用labeller进行修改</span></span><br><span class="line">  facet_wrap(~Group,labeller = labeller(Group=as_labeller(lab_names)),</span><br><span class="line">             nrow=<span class="number">1</span>) + </span><br><span class="line">  scale_size_continuous(name=<span class="string">"Number"</span>,breaks = c(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>),range=c(<span class="number">1</span>,<span class="number">5</span>)) +</span><br><span class="line">  labs(y=<span class="string">"RNA AtoG editing"</span>,x=<span class="string">"Chromosome"</span>) + theme_bw() +</span><br><span class="line">  theme(axis.text.x = element_blank(),</span><br><span class="line">        axis.ticks.x = element_blank())</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_facet_basic.png.png" alt="ggplot2_facet_basic.png"></p><p>或者使用named vector也可以进行修改，更多修改包括修改背景、字体可以参考：<a href="https://www.datanovia.com/en/blog/how-to-change-ggplot-facet-labels/" target="_blank" rel="noopener">HOW TO CHANGE GGPLOT FACET LABELS</a></p><h2 id="调整分面的间距"><a href="#调整分面的间距" class="headerlink" title="调整分面的间距"></a>调整分面的间距</h2><h3 id="统一调整间距"><a href="#统一调整间距" class="headerlink" title="统一调整间距"></a>统一调整间距</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p + theme(panel.spacing = unit(<span class="number">2</span>, <span class="string">"lines"</span>))</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_facet_space.png.png" alt="ggplot2_facet_space.png"></p><hr><h3 id="调整某部分的间距"><a href="#调整某部分的间距" class="headerlink" title="调整某部分的间距"></a>调整某部分的间距</h3><p>调整<strong>第一个分面和后续分面的间距，剩下的分面之间的间距不变</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(grid)</span><br><span class="line">gt = ggplot_gtable(ggplot_build(example))</span><br><span class="line">names(gt)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"grobs"</span>         <span class="string">"layout"</span>        <span class="string">"widths"</span>        <span class="string">"heights"</span>       <span class="string">"respect"</span>       <span class="string">"rownames"</span>     </span><br><span class="line">  [<span class="number">7</span>] <span class="string">"colnames"</span>      <span class="string">"name"</span>          <span class="string">"gp"</span>            <span class="string">"vp"</span>            <span class="string">"children"</span>      <span class="string">"childrenOrder"</span></span><br><span class="line"></span><br><span class="line">gt$widths</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5.</span>5pt                         </span><br><span class="line">  [<span class="number">2</span>] 0cm                          </span><br><span class="line">  [<span class="number">3</span>] 1grobwidth                       </span><br><span class="line">  [<span class="number">4</span>] <span class="number">0.</span>650222602739726cm              </span><br><span class="line">  [<span class="number">5</span>] 1null                                </span><br><span class="line">  [<span class="number">6</span>] 0cm                           </span><br><span class="line">  [<span class="number">7</span>] <span class="number">5.</span>5pt                            </span><br><span class="line">  [<span class="number">8</span>] 0cm                          </span><br><span class="line">  [<span class="number">9</span>] 1null                       </span><br><span class="line">  [<span class="number">10</span>] 0cm                                 </span><br><span class="line">  [<span class="number">11</span>] <span class="number">5.</span>5pt  </span><br><span class="line">  <span class="keyword">...</span>   </span><br><span class="line"><span class="comment"># 增加第一个分面和后续的距离</span></span><br><span class="line">gt$widths[<span class="number">7</span>] = <span class="number">5</span>*gt$widths[<span class="number">7</span>]</span><br><span class="line">grid.draw(gt)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_facet_space1.png.png" alt="ggplot2_facet_space1.png"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/49123019/add-space-between-specific-facets-in-ggplot2-facet-grid" target="_blank" rel="noopener">Add space between specific facets in ggplot2 (facet_grid)</a></li><li><a href="https://stackoverflow.com/questions/3681647/ggplot-how-to-increase-spacing-between-faceted-plots" target="_blank" rel="noopener">ggplot: How to increase spacing between faceted plots?</a></li><li><a href="https://www.datanovia.com/en/blog/how-to-change-ggplot-facet-labels/" target="_blank" rel="noopener">HOW TO CHANGE GGPLOT FACET LABELS</a></li><li><a href="https://stackoverflow.com/questions/3472980/how-to-change-facet-labels" target="_blank" rel="noopener">How to change facet labels?</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;使用ggplot2进行分面图的绘制&lt;/strong&gt;，同时学习了&lt;strong&gt;对分面的title以及分面间距调整&lt;/strong&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/R/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>R系列之在R中使用Python的字符串操作</title>
    <link href="http://showteeth.tech/posts/24871.html"/>
    <id>http://showteeth.tech/posts/24871.html</id>
    <published>2020-05-15T14:35:37.000Z</published>
    <updated>2020-05-25T13:27:00.205Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>在R中使用Python的格式化字符串方法</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在R中使用字符串拼接主要使用的是<code>paste</code>函数，虽然也很好用，但是相比于<code>Python</code>却非常臃肿，比如<code>Python</code>中如果想要实现字符串拼接直接使用+即可，如果想要<strong>格式化字符串</strong>可以使用<code>format</code>函数，而<code>R</code>中没有类似的函数，实现类似的功能就要使用<code>paste</code>，非常复杂。今天在看别人代码的时候发现别人使用了<code>pystr</code>这个包，其主要作用就是将<code>Python</code>中的格式化字符串的方法引入到了<code>R</code>中，当然也包括一些其他的对字符串操作的函数。</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(devtools)</span><br><span class="line">devtools::install_github(<span class="string">"nicolewhite/pystr"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="索引表示字符顺序"><a href="#索引表示字符顺序" class="headerlink" title="索引表示字符顺序"></a>索引表示字符顺序</h3><p>使用索引来表示字符串替换的顺序，替换使用的字符串形式非常灵活，可以<strong>直接作为单独的参数</strong>，也可以使用<strong>向量作为参数</strong>，也可以<strong>使用列表作为参数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接作为参数传递</span></span><br><span class="line"><span class="comment"># 注意：即使只有一个元素，前面的1,2也不能缺省</span></span><br><span class="line">pystr_format(<span class="string">"Hello &#123;1&#125;, my name is &#123;2&#125;."</span>, <span class="string">"World"</span>, <span class="string">"Nicole"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello World, my name is Nicole."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用向量</span></span><br><span class="line">params = c(<span class="string">"World"</span>, <span class="string">"Nicole"</span>)</span><br><span class="line">pystr_format(<span class="string">"Hello &#123;1&#125;, my name is &#123;2&#125;."</span>, params)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello World, my name is Nicole."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过列表传递</span></span><br><span class="line">params = list(<span class="string">"World"</span>, <span class="string">"Nicole"</span>)</span><br><span class="line">pystr_format(<span class="string">"Hello &#123;1&#125;, my name is &#123;2&#125;."</span>, params)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello World, my name is Nicole."</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="名称表示字符顺序"><a href="#名称表示字符顺序" class="headerlink" title="名称表示字符顺序"></a>名称表示字符顺序</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独的参数</span></span><br><span class="line">pystr_format(<span class="string">"Hello &#123;thing&#125;, my name is &#123;name&#125;."</span>, thing=<span class="string">"World"</span>, name=<span class="string">"Nicole"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello World, my name is Nicole."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># named vector</span></span><br><span class="line">params = c(thing=<span class="string">"World"</span>, name=<span class="string">"Nicole"</span>)</span><br><span class="line">pystr_format(<span class="string">"Hello &#123;thing&#125;, my name is &#123;name&#125;."</span>, params)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello World, my name is Nicole."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># named list</span></span><br><span class="line">params = list(thing=<span class="string">"World"</span>, name=<span class="string">"Nicole"</span>)</span><br><span class="line">pystr_format(<span class="string">"Hello &#123;thing&#125;, my name is &#123;name&#125;."</span>, params)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello World, my name is Nicole."</span></span><br></pre></td></tr></table></figure><hr><h3 id="重复的参数"><a href="#重复的参数" class="headerlink" title="重复的参数"></a>重复的参数</h3><p>参数在需要格式化的字符串中可以重复使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># last重复使用了，都会使用相同的参数值进行替换</span></span><br><span class="line">pystr_format(<span class="string">"The name is &#123;last&#125;. &#123;first&#125; &#123;last&#125;."</span>, last=<span class="string">"Bond"</span>, first=<span class="string">"James"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"The name is Bond. James Bond."</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="传入的数据类型"><a href="#传入的数据类型" class="headerlink" title="传入的数据类型"></a>传入的数据类型</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以是数字也可以是字符串</span></span><br><span class="line">pystr_format(<span class="string">"Hello &#123;name&#125;, you have &#123;n&#125; new notifications!"</span>, name=<span class="string">"Nicole"</span>, n=<span class="number">3</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello Nicole, you have 3 new notifications!"</span></span><br></pre></td></tr></table></figure><hr><h2 id="其他常用功能"><a href="#其他常用功能" class="headerlink" title="其他常用功能"></a>其他常用功能</h2><ul><li><code>pystr_capitalize</code>：首字母大写</li><li><code>pystr_count</code>：计算字符串重复出现的次数</li><li><code>pystr_endswith</code>、<code>pystr_endswith</code>：是否一某个字符串结尾或开头</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/Ironholds/pystr" target="_blank" rel="noopener">Github-pystr</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;在R中使用Python的格式化字符串方法&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="Packages" scheme="http://showteeth.tech/categories/R/Packages/"/>
    
    
      <category term="字符串" scheme="http://showteeth.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之集群存储配额</title>
    <link href="http://showteeth.tech/posts/10237.html"/>
    <id>http://showteeth.tech/posts/10237.html</id>
    <published>2020-05-13T05:58:26.000Z</published>
    <updated>2020-05-21T15:15:07.860Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<strong>查看集群存储配额</strong>的方法以及<strong>针对不同文件系统进行配额管理</strong>的办法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近集群存储用完了，<code>vim</code>打开文件都保存不了，然后找老师管理员要了一下实验室账号的配额情况，看结果的时候有些看不懂，所以打算学习一下。</p><hr><h2 id="查看账户配额"><a href="#查看账户配额" class="headerlink" title="查看账户配额"></a>查看账户配额</h2><p>关于集群的文件系统可以参考：<a href="http://showteeth.tech/posts/31689.html">Linux系列之挂载硬盘和USB设备</a></p><h3 id="Lustre分布式存储文件系统"><a href="#Lustre分布式存储文件系统" class="headerlink" title="Lustre分布式存储文件系统"></a>Lustre分布式存储文件系统</h3><p>针对<strong>Lustre分布式存储文件系统</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lfs quota -uh user /home</span><br><span class="line">  Disk quotas <span class="keyword">for</span> user user (uid 6050):</span><br><span class="line">      Filesystem    used   quota   <span class="built_in">limit</span>   grace   files   quota   <span class="built_in">limit</span>   grace</span><br><span class="line">          /home  27.94T     29T     30T       - 3094085       0       0       -</span><br></pre></td></tr></table></figure><p></p><p>结果说明：<br><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>Filesystem</td><td>用户所在的共享分布式存储</td></tr><tr><td>used</td><td>用户目前已经使用的存储（单位KB）</td></tr><tr><td>quota</td><td>存储软限制（单位KB）</td></tr><tr><td>limit</td><td>存储硬限制（单位KB）</td></tr><tr><td>grace</td><td>存储状态</td></tr><tr><td>files</td><td>用户已有的文件数量（单位：个）</td></tr><tr><td>quota</td><td>文件数量软限制（单位：个）</td></tr><tr><td>limit</td><td>文件数量硬限制（单位：个）</td></tr><tr><td>grace</td><td>文件数量状态</td></tr></tbody></table></p><hr><h2 id="关于soft-hard-quota以及grace"><a href="#关于soft-hard-quota以及grace" class="headerlink" title="关于soft, hard quota以及grace"></a>关于soft, hard quota以及grace</h2><p><strong>Soft quota(quota)</strong>:</p><blockquote><p>this is <strong>in effect the desired ‘upper limit’ of disk usage on a normal basis</strong>. It is usually set higher than most people need, so that those users that need more space are accommodated. The disk will fill before everyone can use the amount of space allowed by their soft quota. If you <strong>reach your soft quota</strong>, the system should <strong>begin to warn you that you are over quota</strong>. By reaching/exceeding your soft quota, you <strong>trip a ‘grace period’ timer</strong>, which gives you seven (7) days to continue working and even allows you to use more disk space. But if you <strong>have not reduced your disk consumption on that disk partition to a level below the soft quota before the grace period expires</strong>, you will be <strong>unable to save any more material until you reduce your consumption so that it is below your soft quota</strong>.</p></blockquote><p><strong>Hard quota(limit)</strong>:</p><blockquote><p>this is the <strong>enforced upper limit of your storage on this particular disk partition</strong>. f you try to exceed this value, you should see a warning, and will not be able to save any more material to that disk. <strong>If you try to save a 1024 byte file and only 900 bytes are left on your quota, you will only be able to save 900 bytes</strong>. To be able to save any materials, you must reduce your usage on that disk partition so that it is below your soft quota. NOTE: if you have reached your hard quota, or your grace period has expired, and you have something that simply must be saved, you may be able to save it (temporarily) in /var/tmp rather than in your home directory. You will need to remove it from /var/tmp as soon as possible, and if it uses too much space in this shared “scratch space” area we may need to remove it (a full /var/tmp can prevent others from being able to work).</p></blockquote><p><strong>Grace period(grace)</strong>:</p><blockquote><p>once you <strong>exceed your soft quota, a timer is started</strong>. This timer is for your grace period, <strong>a period of time - 7 days by default</strong> - during which you may continue to work and save files in this disk area (as long as you do not exceed the hard quota). To <strong>clear the timer, you need to reduce your disk usage in that disk partition to an amount less than your soft quota</strong>. When you exceed your quota, you should see system messages appear. Some applications can hide this, or it may appear in a console window rather than in the window in which you are working. We are working on a small script that we will run minimally once a week, and more likely, once a day, that will look for ‘over-quota’ conditions, and send an email alert to each person over quota.</p></blockquote><p>总结来说就是：</p><ul><li><strong>存储是有配额限制的</strong>，这种配额限制包括两种形式，<strong>一种是软限制(quota)，另一种是硬限制(limit)</strong></li><li>当用户的<strong>存储超出软限制</strong>，<strong>开启倒计时</strong>，这个倒计时就是grace，默认为7天，<strong>倒计时到期如果用户存储还是高于软显示，那么就不能继续写入数据</strong>；超出硬限制，直接就用不了了。</li></ul><hr><h2 id="给用户设置配额"><a href="#给用户设置配额" class="headerlink" title="给用户设置配额"></a>给用户设置配额</h2><h3 id="查看文件系统"><a href="#查看文件系统" class="headerlink" title="查看文件系统"></a>查看文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df -T -h</span><br><span class="line">  Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">  /dev/mapper/centos-root xfs        50G   35G   16G  69% /</span><br><span class="line">  devtmpfs                devtmpfs   24G     0   24G   0% /dev</span><br><span class="line">  tmpfs                   tmpfs      24G  8.0K   24G   1% /dev/shm</span><br><span class="line">  tmpfs                   tmpfs      24G   42M   24G   1% /run</span><br><span class="line">  tmpfs                   tmpfs      24G     0   24G   0% /sys/fs/cgroup</span><br><span class="line">  /dev/sdd1               ext4      1.8T  1.6T  156G  92% /datastore_2</span><br><span class="line">  /dev/sdc1               ext4      3.6T  3.2T  291G  92% /workstation</span><br><span class="line">  /dev/sda1               xfs       494M  214M  281M  44% /boot</span><br><span class="line">  /dev/mapper/centos-home xfs       1.8T  1.5T  353G  81% /home</span><br><span class="line">  tmpfs                   tmpfs     4.7G     0  4.7G   0% /run/user/0</span><br><span class="line">  /data                   nfs4      107T   59T   49T  55% /data</span><br><span class="line">  tmpfs                   tmpfs     4.7G     0  4.7G   0% /run/user/1021</span><br><span class="line">  tmpfs                   tmpfs     4.7G     0  4.7G   0% /run/user/1035</span><br><span class="line">  tmpfs                   tmpfs     4.7G     0  4.7G   0% /run/user/1028</span><br></pre></td></tr></table></figure><p>上面输出结果中的Type即为磁盘的文件系统，这里主要包括<code>xfs</code>, <code>ext4</code>,</p><hr><h3 id="针对ext4文件系统的配额管理"><a href="#针对ext4文件系统的配额管理" class="headerlink" title="针对ext4文件系统的配额管理"></a>针对ext4文件系统的配额管理</h3><ul><li><a href="https://www.jianshu.com/p/db7512b7400f" target="_blank" rel="noopener">/home/目录下的账户Quota（磁盘配额）</a></li><li><a href="http://www.opsers.org/base/learning-linux-the-rhel6-day-that-the-disk-quota-system.html?spm=a2c4e.10696291.0.0.6c1819a4Zq8hB0" target="_blank" rel="noopener">一天一点学习Linux之RHEL6系统上的磁盘配额</a></li><li><a href="https://www.thegeekstuff.com/2010/07/disk-quota/" target="_blank" rel="noopener">5 Steps to Setup User and Group Disk Quota on UNIX / Linux</a></li><li><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialQuotas.html" target="_blank" rel="noopener">Linux File System Quotas</a></li></ul><hr><h3 id="针对xfs文件系统的配额管理"><a href="#针对xfs文件系统的配额管理" class="headerlink" title="针对xfs文件系统的配额管理"></a>针对xfs文件系统的配额管理</h3><ul><li><a href="https://www.qingsword.com/qing/rhel-12.html" target="_blank" rel="noopener">[RHEL]-12-xfs文件系统磁盘配额</a></li><li><a href="https://kim1024.github.io/2018/11/27/quota-with-xfs.html" target="_blank" rel="noopener">XFS文件系统中quota的使用</a></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://cng.seas.rochester.edu/CNG/docs/Quotas.html" target="_blank" rel="noopener">Disk Quotas</a></li><li><a href="https://blog.mrzhenggang.com/storage-quota-introduction/" target="_blank" rel="noopener">关于存储配额的说明</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了&lt;strong&gt;查看集群存储配额&lt;/strong&gt;的方法以及&lt;strong&gt;针对不同文件系统进行配额管理&lt;/strong&gt;的办法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="集群运维" scheme="http://showteeth.tech/categories/Linux/%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="集群运维" scheme="http://showteeth.tech/tags/%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>R系列之通过传参得到列表中的值</title>
    <link href="http://showteeth.tech/posts/11123.html"/>
    <id>http://showteeth.tech/posts/11123.html</id>
    <published>2020-05-10T07:53:47.000Z</published>
    <updated>2020-05-21T15:15:07.888Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>通过传参得到列表中元素值</strong>的方法，主要使用的是<code>get</code>函数。和之前<a href="http://showteeth.tech/posts/14356.html">R系列之将字符串转化为变量</a>中学习的<code>get</code>可以<strong>得到字符串对应的变量的值</strong>不同的是这里的<code>get</code>指定的搜索对象是列表而不是默认的当前环境。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想在R中实现一个<strong>类似字典</strong>的功能，因为存储的元素不是单个的元素，所以<code>named vector</code>并不是很好用，这里想到的就是使用<code>list</code>来实现，但是<code>list</code>访问的时候不能直接使用<code>list$args</code>这种形式。</p><h2 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h2><p>之前在<a href="http://showteeth.tech/posts/14356.html">R系列之将字符串转化为变量</a>中学习的<code>get</code>可以<strong>得到字符串对应的变量的值</strong>，这里学习的其可以根据<code>list</code>的<code>attribute</code>字符得到对应的元素信息，其实都是同一种功能：<strong>在指定的object中根据name查找元素</strong>。上述两种用法的区别是<strong>指定的object不同</strong>，get函数指定object的方法包括三种：</p><ul><li><strong>整数值</strong>表示的在<code>search</code>列表中的位置</li><li><strong>字符</strong>表示的<code>search</code>列表中元素的名称</li><li><code>an environment</code></li></ul><p>默认的位置<code>-1</code>表示的是当前的<code>environment</code>(使用<code>get</code>得到字符串对应的变量的值)。</p><hr><h2 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h2><p>正常的获取list中元素的方法：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">test=list(name=c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">test</span><br><span class="line">  $name</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用整数表示的位置</span></span><br><span class="line">test[[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 直接使用test$name</span></span><br><span class="line">test$name</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用get函数</span></span><br><span class="line">get(<span class="string">"name"</span>,test)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p></p><p>如果想传参的话：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"name"</span></span><br><span class="line"><span class="comment"># 这个时候就得不到想要的结果</span></span><br><span class="line">test$a</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用get函数成功传参</span></span><br><span class="line">get(a,test)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/9449542/access-list-element-in-r-using-get" target="_blank" rel="noopener">Access list element in r using get()</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;通过传参得到列表中元素值&lt;/strong&gt;的方法，主要使用的是&lt;code&gt;get&lt;/code&gt;函数。和之前&lt;a href=&quot;http://showteeth.tech/posts/14356.html&quot;&gt;R系列之将字符串转化为变量&lt;/a&gt;中学习的&lt;code&gt;get&lt;/code&gt;可以&lt;strong&gt;得到字符串对应的变量的值&lt;/strong&gt;不同的是这里的&lt;code&gt;get&lt;/code&gt;指定的搜索对象是列表而不是默认的当前环境。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之在逻辑判断中传递变量</title>
    <link href="http://showteeth.tech/posts/5754.html"/>
    <id>http://showteeth.tech/posts/5754.html</id>
    <published>2020-05-08T14:29:32.000Z</published>
    <updated>2020-05-21T15:15:07.883Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了<strong>在R中的逻辑判断式中添加参数的方法</strong>，主要有两种，一种是<strong>substitute结合eval</strong>，另一种是<strong>parse结合eval</strong>，两种方法都是先得到<code>unevaluated expressions</code>，而后使用<code>eval</code>对得到的表达式进行求值。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近想在函数中添加一个<code>subset</code>命令来获取不同的数据，但是发现函数中传递的参数不能直接用到逻辑判断式中。</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">raw_data&lt;- data.frame(Blok=c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>))</span><br><span class="line">raw_data</span><br><span class="line">    Blok</span><br><span class="line">  <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">  <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br><span class="line">  <span class="number">4</span>    <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到其中Blok大于1的行</span></span><br><span class="line">    Blok</span><br><span class="line">  <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="substitute结合eval"><a href="#substitute结合eval" class="headerlink" title="substitute结合eval"></a>substitute结合eval</h3><p><code>substitute</code>函数作用：</p><blockquote><p>substitute returns the parse tree for <strong>the (unevaluated) expression expr</strong>, substituting any variables bound in env.</p></blockquote><p>其实<code>substitute</code>就是用来构建一个单纯的表达式，这个表达式并没有进行求值，具体求值是<code>eval</code>函数的作用。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list中给出的是前面exp中需要替换的部分</span></span><br><span class="line"><span class="comment"># 可以发现输出的只是这个单纯的表达式，并没有对其进行求值</span></span><br><span class="line">substitute(x &lt;- x + <span class="number">1</span>, list(x = <span class="number">1</span>))</span><br><span class="line">  <span class="number">1</span> &lt;- <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对这个表达式进行求值</span></span><br><span class="line"><span class="number">1</span> &lt;- <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">  Error <span class="keyword">in</span> <span class="number">1</span> &lt;- <span class="number">1</span> + <span class="number">1</span> : invalid (do_set) left-hand side to assignment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用eval函数</span></span><br><span class="line"><span class="comment"># 发现eval其实就是相当于指定了得到的表达式</span></span><br><span class="line">eval(substitute(x &lt;- x + <span class="number">1</span>, list(x = <span class="number">1</span>)))</span><br><span class="line">  Error <span class="keyword">in</span> <span class="number">1</span> &lt;- <span class="number">1</span> + <span class="number">1</span> : invalid (do_set) left-hand side to assignment</span><br></pre></td></tr></table></figure><p></p><p>回归到前面的问题上：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">subset(raw_data,eval(substitute(x &gt; <span class="number">1</span>, list(x = as.name(<span class="string">"Blok"</span>)))))</span><br><span class="line">    Blok</span><br><span class="line">  <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里as.name的用法</span></span><br><span class="line"><span class="comment"># 得到的是Blok而不是字符串"Blok"</span></span><br><span class="line"><span class="comment"># subset中可以直接传入前面data的列名即可</span></span><br><span class="line">as.name(<span class="string">"Blok"</span>)</span><br><span class="line">  Blok</span><br><span class="line"><span class="string">"Blok"</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Blok"</span></span><br><span class="line"></span><br><span class="line">subset(raw_data,Blok&gt;<span class="number">1</span>)</span><br><span class="line">    Blok</span><br><span class="line">  <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br><span class="line">subset(raw_data,<span class="string">"Blok"</span>&gt;<span class="number">1</span>)</span><br><span class="line">    Blok</span><br><span class="line">  <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">  <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br><span class="line">  <span class="number">4</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>关于<code>as.name</code>:</p><blockquote><p>A ‘name’ (also known as a ‘symbol’) is <strong>a way to refer to R objects by name</strong> (rather than the value of the object, if any, bound to that name).</p></blockquote><hr><h3 id="parse结合eval"><a href="#parse结合eval" class="headerlink" title="parse结合eval"></a>parse结合eval</h3><p>parse函数功能：</p><blockquote><p>parse returns the parsed but <strong>unevaluated expressions in a list</strong>.</p></blockquote><p>其功能和前面的<code>substitute</code>类似，都是返回<code>unevaluated expressions</code>。</p><p>针对前面的问题：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keep_rows &lt;- <span class="string">"Blok&gt;1"</span></span><br><span class="line">parse(text=keep_rows)</span><br><span class="line">  expression(Blok&gt;<span class="number">1</span>)</span><br><span class="line">subset(raw_data,eval(parse(text=keep_rows)))</span><br><span class="line">    Blok</span><br><span class="line">  <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/6474922/how-to-paste-text-and-variables-into-a-logical-expression-in-r" target="_blank" rel="noopener">How to paste text and variables into a logical expression in R?</a></li><li><a href="https://stackoverflow.com/questions/30831785/convert-a-character-variable-into-a-logical-expression-in-order-to-use-it-later" target="_blank" rel="noopener">Convert a character variable into a logical expression in order to use it later inside the subset argument of the subset() function</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了&lt;strong&gt;在R中的逻辑判断式中添加参数的方法&lt;/strong&gt;，主要有两种，一种是&lt;strong&gt;substitute结合eval&lt;/strong&gt;，另一种是&lt;strong&gt;parse结合eval&lt;/strong&gt;，两种方法都是先得到&lt;code&gt;unevaluated expressions&lt;/code&gt;，而后使用&lt;code&gt;eval&lt;/code&gt;对得到的表达式进行求值。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-添加垂直和水平线</title>
    <link href="http://showteeth.tech/posts/269.html"/>
    <id>http://showteeth.tech/posts/269.html</id>
    <published>2020-04-24T14:18:48.000Z</published>
    <updated>2020-05-21T15:15:07.866Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了<strong>绘制垂直和水平线的两种方法以及这两种方法之间的区别</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在完成一些图形的绘制(如散点图)之后，如果想明确展示过滤阈值的位置可以在原有图形上添加水平和垂直线进行表示。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>垂直和水平线的绘制分别有两种函数可以实现:</p><ul><li><code>plt.vlines(x, ymin, ymax, colors=&#39;k&#39;, linestyles=&#39;solid&#39;, label=&#39;&#39;, *, data=None, **kwargs)</code>和<code>plt.hlines(x, ymin, ymax, colors=&#39;k&#39;, linestyles=&#39;solid&#39;, label=&#39;&#39;, *, data=None, **kwargs)</code></li><li><code>plt.axvline(x=0, ymin=0, ymax=1, **kwargs)</code>和<code>plt.axhline(x=0, ymin=0, ymax=1, **kwargs)</code></li></ul><p><mark>两者的区别：</mark></p><ul><li>默认参数的区别：<code>plt.vlines</code>最少需要三个参数<code>x</code>, <code>ymin</code>, <code>ymax</code>才能使用；而<code>plt.axvline</code>只需要<code>x</code>即可使用，<code>plt.axvline</code>不设置<code>ymin</code>, <code>ymax</code>，<strong>画出来的图会自动占满整个图片</strong></li><li>参数的差异：另外的区别就是在<code>plt.vlines</code>可以使用<code>colors</code>、<code>linestyles</code>；但咋<code>plt.axvline</code>需要使用<code>color</code>、<code>linestyle(可用选项也不同)</code></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了&lt;strong&gt;绘制垂直和水平线的两种方法以及这两种方法之间的区别&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-绘制密度散点图</title>
    <link href="http://showteeth.tech/posts/24328.html"/>
    <id>http://showteeth.tech/posts/24328.html</id>
    <published>2020-04-24T08:03:13.000Z</published>
    <updated>2020-05-21T15:15:07.863Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了<strong>使用<code>Python</code>的<code>matplotlib</code>给散点图添加点的分布密度</strong>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>散点图是展示两个变量之间关系的非常有效的方式，理想情况是两个变量之间的均匀的，沿着其具有相关性的方向均匀分布，但是也存在一些例外，比如大部分的点都聚集在相关性方向的某一部分，这样的话对展示效果就会大打折扣，为了解决这个问题，可以给散点图添加一个颜色，而这个颜色就是局部点的分布密度，这种图就是密度散点图。</p><hr><h2 id="普通散点图"><a href="#普通散点图" class="headerlink" title="普通散点图"></a>普通散点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate fake data</span></span><br><span class="line">x = np.random.normal(size=<span class="number">1000</span>)</span><br><span class="line">y = x * <span class="number">3</span> + np.random.normal(size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># s表示点的大小</span></span><br><span class="line">ax.scatter(x, y, s=<span class="number">100</span>, edgecolor=<span class="string">''</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/density_scatter_raw.png.png" alt="density_scatter_raw.png"></p><hr><h2 id="密度散点图"><a href="#密度散点图" class="headerlink" title="密度散点图"></a>密度散点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 导入计算概率密度的函数</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> gaussian_kde</span><br><span class="line"></span><br><span class="line">x = np.random.normal(size=<span class="number">1000</span>)</span><br><span class="line">y = x * <span class="number">3</span> + np.random.normal(size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算概率密度</span></span><br><span class="line">xy = np.vstack([x,y])</span><br><span class="line">z = gaussian_kde(xy)(xy)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># 使用概率密度来对点进行染色</span></span><br><span class="line">ax.scatter(x, y, c=z, s=<span class="number">100</span>, edgecolor=<span class="string">''</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这里的一定要是参数<code>c</code>，而不是使用参数<code>color</code></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/density_scatter_final.png.png" alt="density_scatter_final.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/49662964/density-scatter-plot-for-huge-dataset-in-matplotlib" target="_blank" rel="noopener">Density scatter plot for huge dataset in matplotlib</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了&lt;strong&gt;使用&lt;code&gt;Python&lt;/code&gt;的&lt;code&gt;matplotlib&lt;/code&gt;给散点图添加点的分布密度&lt;/strong&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>R绘图系列-使用patchwork进行图形排布</title>
    <link href="http://showteeth.tech/posts/60938.html"/>
    <id>http://showteeth.tech/posts/60938.html</id>
    <published>2020-04-20T08:27:15.000Z</published>
    <updated>2020-05-21T15:15:07.892Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>patchwork</code>来进行图形排布的各种基础使用。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>patchwork</code>的功能和<code>cowplot</code>的功能比较类似，都是可以量多个<code>ggplot</code>对象进行排布的<code>R</code>包，相比于<code>cowplot</code>，<code>patchwork</code>使用更加简单，直接使用<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>|</code>、<code>&amp;</code>等即可实现多种多样的图形排布，而<code>cowplot</code>中还有使用<code>plot_grid</code>函数。</p><hr><h2 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line">p1 &lt;- ggplot(mtcars) + </span><br><span class="line">  geom_point(aes(mpg, disp)) + </span><br><span class="line">  ggtitle(<span class="string">'Plot 1'</span>)</span><br><span class="line"></span><br><span class="line">p2 &lt;- ggplot(mtcars) + </span><br><span class="line">  geom_boxplot(aes(gear, disp, group = gear)) + </span><br><span class="line">  ggtitle(<span class="string">'Plot 2'</span>)</span><br><span class="line"></span><br><span class="line">p3 &lt;- ggplot(mtcars) + </span><br><span class="line">  geom_point(aes(hp, wt, colour = mpg)) + </span><br><span class="line">  ggtitle(<span class="string">'Plot 3'</span>)</span><br><span class="line"></span><br><span class="line">p4 &lt;- ggplot(mtcars) + </span><br><span class="line">  geom_bar(aes(gear)) + </span><br><span class="line">  facet_wrap(~cyl) + </span><br><span class="line">  ggtitle(<span class="string">'Plot 4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(patchwork)</span><br><span class="line">p1+p2+p3+p4</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_example_plots.png.png" alt="patchwork_example_plots.png"></p><hr><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将p1和p2合并在一起</span></span><br><span class="line">p1 + p2</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_add_plots.png.png" alt="patchwork_add_plots.png"></p><hr><h2 id="控制layout"><a href="#控制layout" class="headerlink" title="控制layout"></a>控制layout</h2><p>控制输出结果为3行，并且<strong>先按列进行填充</strong>，也就是先把第一列的3行填满，然后再去第二列：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 + p2 + p3 + p4 + plot_layout(nrow = <span class="number">3</span>, byrow = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_layout_plots1.png.png" alt="patchwork_layout_plots1.png"></p><hr><h2 id="纵向合并"><a href="#纵向合并" class="headerlink" title="纵向合并"></a>纵向合并</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 纵向合并图</span></span><br><span class="line">p1 / p2</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_stacking_plots.png.png" alt="patchwork_stacking_plots.png"></p><p><strong>嵌套合并</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 | (p2 / p3)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_stacking_nested_plots.png.png" alt="patchwork_stacking_nested_plots.png"></p><hr><h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p><strong>添加title</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(p1 | (p2 / p3)) + </span><br><span class="line">  plot_annotation(title = <span class="string">'The surprising story about mtcars'</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_annotating_title_plots.png.png" alt="patchwork_annotating_title_plots.png"></p><p><strong>添加label</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag_levels = 'A'是A、B、C的形式</span></span><br><span class="line">p1 + p2 + p3 + </span><br><span class="line">  plot_annotation(tag_levels = <span class="string">'I'</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/patchwork_annotating_label_plots.png.png" alt="patchwork_annotating_label_plots.png"></p><hr><h2 id="合并主题"><a href="#合并主题" class="headerlink" title="合并主题"></a>合并主题</h2><p>使用<code>&amp;</code>来<strong>将同一个主题设置应用到多个子图中</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(patchwork)</span><br><span class="line">FeaturePlot(mouse_fibro_combined, features = c(<span class="string">"Trem2"</span>,<span class="string">"Cd9"</span>), pt.size=<span class="number">0.5</span>, label = <span class="literal">TRUE</span>) &amp; </span><br><span class="line">  scale_colour_gradientn(colours = c(<span class="string">"blue"</span>,<span class="string">"white"</span>,<span class="string">"#d3583d"</span>))</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://patchwork.data-imaginist.com/articles/patchwork.html" target="_blank" rel="noopener">Getting Started</a></li><li><a href="https://patchwork.data-imaginist.com/articles/guides/assembly.html" target="_blank" rel="noopener">Plot Assembly</a></li><li><a href="https://patchwork.data-imaginist.com/articles/guides/layout.html" target="_blank" rel="noopener">Controlling Layouts</a></li><li><a href="https://patchwork.data-imaginist.com/articles/guides/annotation.html" target="_blank" rel="noopener">Adding Annotation and Style</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了使用&lt;code&gt;patchwork&lt;/code&gt;来进行图形排布的各种基础使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/R/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>R绘图系列-放大局部</title>
    <link href="http://showteeth.tech/posts/42932.html"/>
    <id>http://showteeth.tech/posts/42932.html</id>
    <published>2020-04-13T03:25:02.000Z</published>
    <updated>2020-05-21T15:15:07.900Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了如何<strong>放大图片中的某部分</strong>，可以对<strong>某个分类的数据</strong>进行放大，也可以对<strong>指定范围的数据</strong>进行放大。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>画完图之后可能想放大展示某一部分，遇到这种情况可以使用ggplot2的拓展<code>ggforce</code>来实现。</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"ggforce"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="常规图"><a href="#常规图" class="headerlink" title="常规图"></a>常规图</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +</span><br><span class="line">  geom_point()</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_zoom_raw.png.png" alt="ggplot2_zoom_raw.png"></p><hr><h3 id="对某个分类的数据放大"><a href="#对某个分类的数据放大" class="headerlink" title="对某个分类的数据放大"></a>对某个分类的数据放大</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +</span><br><span class="line">  geom_point() +</span><br><span class="line">  facet_zoom(x = Species == <span class="string">'versicolor'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_zoom_cat.png.png" alt="ggplot2_zoom_cat.png"></p><p><strong>调整一下背景</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +</span><br><span class="line">    geom_point() +</span><br><span class="line">    facet_zoom(x = Species == <span class="string">'versicolor'</span>) + cowplot::theme_cowplot()</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_zoom_cat_theme.png.png" alt="ggplot2_zoom_cat_theme.png"></p><hr><h3 id="放大指定坐标范围"><a href="#放大指定坐标范围" class="headerlink" title="放大指定坐标范围"></a>放大指定坐标范围</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +</span><br><span class="line">    geom_point() +</span><br><span class="line">    facet_zoom(xlim = c(<span class="number">2</span>, <span class="number">4</span>)) + cowplot::theme_cowplot()</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ggplot2_zoom_range.png.png" alt="ggplot2_zoom_range.png"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s/BxPDHi57EUWmYZ6_5UZ4NA" target="_blank" rel="noopener">ggplot2 图区域放大</a></li><li><a href="https://ggforce.data-imaginist.com/index.html" target="_blank" rel="noopener">ggforce</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了如何&lt;strong&gt;放大图片中的某部分&lt;/strong&gt;，可以对&lt;strong&gt;某个分类的数据&lt;/strong&gt;进行放大，也可以对&lt;strong&gt;指定范围的数据&lt;/strong&gt;进行放大。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/R/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之指定模块加载路径</title>
    <link href="http://showteeth.tech/posts/59896.html"/>
    <id>http://showteeth.tech/posts/59896.html</id>
    <published>2020-04-13T02:04:47.000Z</published>
    <updated>2020-05-21T15:15:07.909Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Python中<strong>包和模块的加载方式</strong>以及<strong>添加模块和包的搜索路径</strong>。在包和模块的加载方式中，学习了包括<strong>加载顺序</strong>、<strong><code>__file__</code>变量</strong>、<strong><code>sys.argv[0]</code>变量</strong>、<strong>加载的包和模块的存在位置</strong>；在添加模块和包的搜索路径中，学习了<strong>暂时添加和永久添加的方法</strong>。</p></div><a id="more"></a><h2 id="包和模块的加载"><a href="#包和模块的加载" class="headerlink" title="包和模块的加载"></a>包和模块的加载</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><code>module</code>：模块， 一个 <code>py</code> 文件或以其他文件形式存在的可被导入的就是一个模块</li><li><code>package</code>：包，包含有 <code>__init__</code> 文件的文件夹</li><li><code>relative path</code>：相对路径，相对于某个目录的路径</li><li><code>absolute path</code>：绝对路径，全路径</li></ul><hr><h3 id="执行Python模块"><a href="#执行Python模块" class="headerlink" title="执行Python模块"></a>执行Python模块</h3><p><code>Python</code> 执行一个 <code>py</code> 文件，无论执行的方式是用绝对路径还是相对路径，<code>interpreter</code> 都会把文件所在的 <code>directory</code> 加入 <code>sys.path</code> 这个 <code>list</code> 中，而<code>sys.path</code>又是<code>Python</code>查找包和模块的列表。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (sys.path[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p></p><p>用<strong>绝对路径</strong>或者<strong>相对路径</strong>执行上述脚本：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用相对路径</span></span><br><span class="line">./test.py</span><br><span class="line">  /home/user/learn/python_learn/module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用绝对路径执行</span></span><br><span class="line">/home/user/learn/python_learn/module/test.py</span><br><span class="line">  /home/user/learn/python_learn/module</span><br></pre></td></tr></table></figure><p></p><p>相对路径和绝对路径都输出相同的结果，结果表明无论哪种执行方式，<code>test.py</code> 所在的<strong>文件夹</strong>都会被加入 <code>sys.path</code> 的首位，也就是索引为<code>0</code>的位置.</p><hr><h3 id="包和模块的加载顺序"><a href="#包和模块的加载顺序" class="headerlink" title="包和模块的加载顺序"></a>包和模块的加载顺序</h3><p><code>test.py</code> 所在的<strong>文件夹</strong>被加入到<code>sys.path[0]</code>是不是就意味着优先加载该目录下的<code>module</code>呢？这个涉及到<code>module</code>或者包的加载顺序问题。</p><p><code>Python</code>解释器查找包，首先搜索 <code>built-in module</code>，其次搜索 <code>sys.path(包括当前文件夹以及其他加载包的路径)</code> ，这样的查找顺序将<strong>会导致同名包或模块被遮蔽</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前的文件结构</span></span><br><span class="line"><span class="comment"># 其中redis.py和sys.py均为空</span></span><br><span class="line">tree .</span><br><span class="line">  .</span><br><span class="line">  ├── sys.py</span><br><span class="line">  ├── redis.py</span><br><span class="line">  ├── test2.py</span><br><span class="line">  └── test.py</span><br><span class="line"></span><br><span class="line">  0 directories, 4 files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试文件</span></span><br><span class="line">cat test2.py</span><br><span class="line">  <span class="comment">#!/usr/bin/env python</span></span><br><span class="line">  <span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#test2.py</span></span><br><span class="line">  import sys</span><br><span class="line">  <span class="built_in">print</span> (sys.path)</span><br><span class="line"></span><br><span class="line">  from redis import Redi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行测试文件</span></span><br><span class="line">./test2.py</span><br><span class="line">  [<span class="string">'/home/user/learn/python_learn/module'</span>, <span class="string">'/home/user/anaconda3/lib/python37.zip'</span>, <span class="string">'/home/user/anaconda3/lib/python3.7'</span>, <span class="string">'/home/user/anaconda3/lib/python3.7/lib-dynload'</span>, <span class="string">'/home/user/.local/lib/python3.7/site-packages'</span>, <span class="string">'/home/user/.local/lib/python3.7/site-packages/statannot-0.1.0-py3.7.egg'</span>, <span class="string">'/home/user/.local/lib/python3.7/site-packages/cycler-0.10.0-py3.7.egg'</span>, <span class="string">'/home/softwares/anaconda3/lib/python3.7/site-packages'</span>, <span class="string">'/home/user/anaconda3/lib/python3.7/site-packages'</span>]</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"./test2.py"</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      from redis import Redis</span><br><span class="line">  ImportError: cannot import name <span class="string">'Redis'</span> from <span class="string">'redis'</span> (/home/user/learn/python_learn/module/redis.py)</span><br></pre></td></tr></table></figure><p>由于 <code>sys</code> 是 <code>built-in module</code>，即使在同目录下有同名模块(<code>sys.py</code>文件)，解释器依然可以找到正确的 <code>sys</code> 模块(从输出的结果可以看出)，可以证实 <code>built-in module</code> 不会被遮蔽，拥有最高的模块加载权限；而 <code>redis</code> 属于第三方模块，默认安装位置是 <code>Python</code> 环境变量中的 <code>site-packages</code>，解释器启动之后会将此目录中的内容加入 <code>sys.path</code>，由于当前目录会在 <code>sys.path</code> 的首位，当前目录的 <code>redis</code> 优先被找到，<code>site-packages</code> 中的 <code>redis</code> 模块被遮蔽了(当前的<code>redis.py</code>中并没有<code>Redi</code>方法，所以报错)。</p><p><mark>总的来说就是：built-in module &gt; 当前目录 &gt; 各种site-packages目录</mark></p><hr><h3 id="模块中的file变量"><a href="#模块中的file变量" class="headerlink" title="模块中的file变量"></a>模块中的<strong>file</strong>变量</h3><blockquote><p><code>__file__</code> is the pathname of the file from which the module was loaded, if it was loaded from a file.</p></blockquote><p>如果一个模块是<strong>从文件加载</strong>的，<code>__file__</code> 就是<strong>该模块的路径名</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模块的内容</span></span><br><span class="line">cat test.py</span><br><span class="line">  <span class="comment">#!/usr/bin/env python</span></span><br><span class="line">  <span class="comment"># encoding: utf-8</span></span><br><span class="line">  import sys</span><br><span class="line">  <span class="built_in">print</span> (__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模块的文件</span></span><br><span class="line">cat test2.py </span><br><span class="line">  <span class="comment">#!/usr/bin/env python</span></span><br><span class="line">  <span class="comment"># encoding: utf-8</span></span><br><span class="line">  import <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行test2.py </span></span><br><span class="line">./test2.py </span><br><span class="line">  /home/user/learn/python_learn/module/test.py</span><br></pre></td></tr></table></figure><p></p><p>可以看到执行的是<code>test2.py</code>，返回的却是<code>test.py</code>的路径，因为<code>__file__</code>就是<strong>该模块的路径名</strong>。</p><h3 id="sys-argv-0-变量"><a href="#sys-argv-0-变量" class="headerlink" title="sys.argv[0] 变量"></a>sys.argv[0] 变量</h3><p>上面提到了<code>__file__</code>变量，与该变量功能类似的还有<code>sys.argv[0]</code> 变量，两者都是返回文件的路径，但是却存在一些差异。<strong><code>sys.argv[0]</code>返回的是被执行文件的路径，并且被执行文件如果是相对路径执行则返回相对路径，绝对路径执行就返回绝对路径，而<code>__file__</code>返回的是被加载的模块的绝对路径</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模块的内容</span></span><br><span class="line">cat test.py</span><br><span class="line">  <span class="comment">#!/usr/bin/env python</span></span><br><span class="line">  <span class="comment"># encoding: utf-8</span></span><br><span class="line">  import sys</span><br><span class="line">  <span class="built_in">print</span> (__file__)</span><br><span class="line">  <span class="built_in">print</span> (sys.argv[0])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模块的文件</span></span><br><span class="line">cat test2.py </span><br><span class="line">  <span class="comment">#!/usr/bin/env python</span></span><br><span class="line">  <span class="comment"># encoding: utf-8</span></span><br><span class="line">  import <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行test2.py——相对路径</span></span><br><span class="line">./test2.py </span><br><span class="line">  /home/user/learn/python_learn/module/test.py</span><br><span class="line">  ./test2.py</span><br><span class="line"><span class="comment"># 执行test2.py——绝对路径</span></span><br><span class="line">/home/user/learn/python_learn/module/test2.py</span><br><span class="line">  /home/user/learn/python_learn/module/test.py</span><br><span class="line">  /home/user/learn/python_learn/module/test2.py</span><br></pre></td></tr></table></figure><p>上述实例中，虽然<code>sys.argv[0]</code>在<code>test.py</code>文件中，但是真正被执行还是在<code>test2.py</code>文件中，所以返回的是<code>test2.py</code>的路径。</p><hr><h3 id="被加载的包和module存放位置"><a href="#被加载的包和module存放位置" class="headerlink" title="被加载的包和module存放位置"></a>被加载的包和module存放位置</h3><p>既然 <code>Python</code> 是在 <code>built-in module</code>和<code>sys.path</code> 中搜索模块的，那载入的模块存放在何处？答案就是 <code>sys.modules</code>。模块一经载入，<code>Python</code> 会把这个模块加入 <code>sys.modules</code> 中供下次载入使用，<strong>这样可以加速模块的引入，起到缓存的作用</strong>。</p><p><code>sys.modules</code>其实是一个加载了的模块和包的字典，<code>key</code>为包和模块的名称。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(sys.modules)</span><br><span class="line">&lt;class <span class="string">'dict'</span>&gt;</span><br><span class="line"><span class="comment"># built-in module会被预先加载</span></span><br><span class="line">&gt;&gt;&gt; sys.modules[<span class="string">'os'</span>]</span><br><span class="line">&lt;module <span class="string">'os'</span> from <span class="string">'/home/user/anaconda3/lib/python3.7/os.py'</span>&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sys.modules[<span class="string">'pandas'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'pandas'</span></span><br><span class="line">&gt;&gt;&gt; import pandas as pd</span><br><span class="line">&gt;&gt;&gt; sys.modules[<span class="string">'pandas'</span>]</span><br><span class="line">&lt;module <span class="string">'pandas'</span> from <span class="string">'/home/softwares/anaconda3/lib/python3.7/site-packages/pandas/__init__.py'</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p>借助 <code>sys.modules</code> 和 <code>__file__</code>，可以<strong>动态获取所有已加载模块目录和路径</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># built-in module的路径</span></span><br><span class="line">&gt;&gt;&gt; sys.modules[<span class="string">'os'</span>].__file__</span><br><span class="line"><span class="string">'/home/user/anaconda3/lib/python3.7/os.py'</span></span><br><span class="line"><span class="comment"># 第三方包的路径</span></span><br><span class="line">&gt;&gt;&gt; sys.modules[<span class="string">'pandas'</span>].__file__</span><br><span class="line"><span class="string">'/home/softwares/anaconda3/lib/python3.7/site-packages/pandas/__init__.py'</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="添加模块和包的搜索路径"><a href="#添加模块和包的搜索路径" class="headerlink" title="添加模块和包的搜索路径"></a>添加模块和包的搜索路径</h2><p>在使用Python的时候经常遇到有些包安装需要一个大环境的支持，而这个大环境中的依赖包可能和当前环境中的其他包存在冲突，所以比较好的解决办法就是将这种包安装在一个虚拟环境中，然后将这个虚拟环境中Python包的地址添加到正常使用的Python包的搜索路径中。</p><p>前面已经学习了Python中包和模块加载的基础知识，这里学习如何添加模块和包的搜索路径。</p><h3 id="暂时添加"><a href="#暂时添加" class="headerlink" title="暂时添加"></a>暂时添加</h3><p><strong>暂时添加的搜索路径会在Python关闭之后被清除，下次重新启动Python就不会再有之前添加的搜索路径信息</strong>。</p><p>按照前面学习了内容，可以直接修改<code>sys.path</code>列表：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/user/Library"</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="永久添加"><a href="#永久添加" class="headerlink" title="永久添加"></a>永久添加</h3><p><strong>永久添加就是在重新启动Python之后之前添加的搜索路径信息仍然有效</strong>，主要包括两种方法：</p><ul><li>修改|添加环境变量<code>PYTHONPATH</code>，Linux直接在<code>~/.bashrc</code>中修改即可</li><li>在<code>site-packages</code>目录中增加<code>.pth</code>文件</li></ul><h4 id="PYTHONPATH"><a href="#PYTHONPATH" class="headerlink" title="PYTHONPATH"></a>PYTHONPATH</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYTHONPATH=/home/user/Library:<span class="variable">$PYTHONPATH</span></span><br></pre></td></tr></table></figure><hr><h4 id="增加-pth文件"><a href="#增加-pth文件" class="headerlink" title="增加.pth文件"></a>增加.pth文件</h4><p>查看<code>site-packages</code>目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import site</span><br><span class="line">&gt;&gt;&gt; site.getsitepackages()</span><br><span class="line">[<span class="string">'/home/user/anaconda3/lib/python3.7/site-packages'</span>]</span><br></pre></td></tr></table></figure><p></p><p>在<code>site-packages</code>目录中添加一个路径文件，如<code>cafffe.pth</code>，<strong>必须以<code>.pth</code>为后缀</strong>，写上你要加入的模块文件所在的目录名称:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/Library/caffe</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://sanyuesha.com/2016/05/28/python-module-path-find/" target="_blank" rel="noopener">如何理解 Python 的模块查找原理与方式</a></li><li><a href="https://www.jianshu.com/p/244675429cd3" target="_blank" rel="noopener">理解 python 模块加载和路径查找</a></li><li><a href="https://www.jianshu.com/p/cb6447e1cf88" target="_blank" rel="noopener">为Python添加默认模块搜索路径</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Python中&lt;strong&gt;包和模块的加载方式&lt;/strong&gt;以及&lt;strong&gt;添加模块和包的搜索路径&lt;/strong&gt;。在包和模块的加载方式中，学习了包括&lt;strong&gt;加载顺序&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;__file__&lt;/code&gt;变量&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;sys.argv[0]&lt;/code&gt;变量&lt;/strong&gt;、&lt;strong&gt;加载的包和模块的存在位置&lt;/strong&gt;；在添加模块和包的搜索路径中，学习了&lt;strong&gt;暂时添加和永久添加的方法&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-自定义colormap</title>
    <link href="http://showteeth.tech/posts/10006.html"/>
    <id>http://showteeth.tech/posts/10006.html</id>
    <published>2020-04-07T09:03:42.000Z</published>
    <updated>2020-05-21T15:15:07.870Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Matplotlib</code>中<strong>自定义colormap</strong>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近想利用给定的颜色设置一个连续变化的<code>colormap</code>，发现<code>Matplotlib</code>并没有像<code>R</code>中<code>ggplot2</code>的<code>scale_colour_gradient2(low = &quot;white&quot;, mid = &quot;#000000&quot;, high = &quot;red&quot;)</code>设置<code>colormap</code>这么简便的方法，这里记录一下简单设置(能用)的方法。</p><hr><h2 id="设置colormap"><a href="#设置colormap" class="headerlink" title="设置colormap"></a>设置colormap</h2><p>如下代码实现了<code>low=&quot;grey&quot;, middle=&quot;black&quot;, high=&quot;red&quot;</code>的效果：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LinearSegmentedColormap</span><br><span class="line">cmap = LinearSegmentedColormap.from_list(<span class="string">'custom greys'</span>, [(<span class="number">.8</span>,<span class="number">.8</span>,<span class="number">.8</span>),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)], N=<span class="number">256</span>)</span><br></pre></td></tr></table></figure><p></p><p>关键点：</p><ul><li><code>LinearSegmentedColormap.from_list</code>是<strong>从颜色列表</strong>创建colormap的函数，默认的<code>LinearSegmentedColormap</code>函数是<strong>从颜色字典</strong>进行colormap创建的</li><li><code>&#39;custom greys&#39;</code>：colormap的名称</li><li><code>(.8,.8,.8)</code>颜色并不是使用的<code>(255, 255, 255)</code>这种<code>0~255</code>范围的数字表示的，而是使用的<code>0-1</code>之间的数字表示的，如果使用<code>0~255</code>的数字表示会报错<code>ValueError: RGBA values should be within 0-1 range</code>；还可以使用<strong>十六进制的字符表示的颜色</strong>创建</li><li><code>N=256</code>表示颜色设置的颜色之间过渡的bin数目，数值越大颜色过渡越平滑</li></ul><hr><h2 id="颜色表示和转换"><a href="#颜色表示和转换" class="headerlink" title="颜色表示和转换"></a>颜色表示和转换</h2><h3 id="内置的颜色及简写"><a href="#内置的颜色及简写" class="headerlink" title="内置的颜色及简写"></a>内置的颜色及简写</h3><p><code>Matplotlib</code>内置了一些常见的颜色，这些颜色可以使用指定的简写形式来代表，如果想指定的颜色不在这个列表内是不能自己想当然或者使用常见的简写来表示的。内置的常见颜色以及简写如下：</p><ul><li>b: blue</li><li>g: green</li><li>r: red</li><li>c: cyan</li><li>m: magenta</li><li>y: yellow</li><li>k: black</li><li>w: white</li></ul><hr><h3 id="将颜色转换为rgb、rgba"><a href="#将颜色转换为rgb、rgba" class="headerlink" title="将颜色转换为rgb、rgba"></a>将颜色转换为rgb、rgba</h3><p>内置的颜色都是非常常见的颜色，数目非常少，而实际使用过程中可能会遇到一些不在这个内置颜色列表中的颜色，这个时候可以有两种方式：</p><ul><li>使用<strong>十六进制的字符表示的颜色</strong></li><li>使用<code>Matplotlib</code>内置的函数将<strong>不在内置颜色中的常用颜色</strong>或者<strong>十六进制的字符表示的颜色</strong>转换为<code>0~1</code>范围的数字</li></ul><p>如下代码展示了将<strong>不在内置颜色中的常用颜色</strong>或者<strong>十六进制的字符表示的颜色</strong>转换为<code>0~1</code>范围的数字的方法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将常用英文颜色转化为0-1之间的颜色表示</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ColorConverter</span><br><span class="line">ColorConverter.to_rgb(<span class="string">"black"</span>)</span><br><span class="line">  (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将16进制的字符转换为0-1之间的颜色表示</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ColorConverter</span><br><span class="line">ColorConverter.to_rgb(<span class="string">"#000000"</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="三种颜色指定方式示例"><a href="#三种颜色指定方式示例" class="headerlink" title="三种颜色指定方式示例"></a>三种颜色指定方式示例</h3><p>下面使用四种颜色指定方式进行示例：</p><ul><li><strong>颜色指定方式一：0-1范围内的数字</strong><code>colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)] # R -&gt; G -&gt; B</code></li><li><strong>颜色指定方式二+三：内置的颜色以及16进制的字符表示</strong><code>colors=[&#39;r&#39;,&#39;#008000&#39;,&#39;b&#39;]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用(255,0,0)表示red会出错</span></span><br><span class="line">ValueError: RGBA values should be within <span class="number">0</span><span class="number">-1</span> range</span><br><span class="line"><span class="comment"># 可以使用自带的工具进行转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.arange(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = np.cos(X) * np.sin(Y) * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # R -&gt; G -&gt; B</span></span><br><span class="line">colors=[<span class="string">'r'</span>,<span class="string">'#008000'</span>,<span class="string">'b'</span>]</span><br><span class="line">n_bins = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">100</span>]  <span class="comment"># Discretizes the interpolation into bins</span></span><br><span class="line">cmap_name = <span class="string">'my_list'</span></span><br><span class="line">fig, axs = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">9</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.02</span>, bottom=<span class="number">0.06</span>, right=<span class="number">0.95</span>, top=<span class="number">0.94</span>, wspace=<span class="number">0.05</span>)</span><br><span class="line"><span class="keyword">for</span> n_bin, ax <span class="keyword">in</span> zip(n_bins, axs.ravel()):</span><br><span class="line">    <span class="comment"># Create the colormap</span></span><br><span class="line">    cm = LinearSegmentedColormap.from_list(</span><br><span class="line">        cmap_name, colors, N=n_bin)</span><br><span class="line">    <span class="comment"># Fewer bins will result in "coarser" colomap interpolation</span></span><br><span class="line">    im = ax.imshow(Z, interpolation=<span class="string">'nearest'</span>, origin=<span class="string">'lower'</span>, cmap=cm)</span><br><span class="line">    ax.set_title(<span class="string">"N bins: %s"</span> % n_bin)</span><br><span class="line">    fig.colorbar(im, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib_colormap.png.png" alt="matplotlib_colormap.png"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/49850429/manually-create-a-colormap" target="_blank" rel="noopener">Manually create a colormap</a></li><li><a href="https://matplotlib.org/gallery/color/custom_cmap.html#sphx-glr-gallery-color-custom-cmap-py" target="_blank" rel="noopener">Creating a colormap from a list of colors</a></li><li><a href="https://www.osgeo.cn/matplotlib/gallery/color/custom_cmap.html" target="_blank" rel="noopener">从颜色列表创建颜色映射</a></li><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html#matplotlib.colors.LinearSegmentedColormap.from_list" target="_blank" rel="noopener">matplotlib.colors.LinearSegmentedColormap</a></li><li><a href="https://matplotlib.org/1.4.1/api/colors_api.html#matplotlib.colors.ColorConverter" target="_blank" rel="noopener">colors</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Matplotlib&lt;/code&gt;中&lt;strong&gt;自定义colormap&lt;/strong&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之SciPy-稀疏矩阵</title>
    <link href="http://showteeth.tech/posts/5727.html"/>
    <id>http://showteeth.tech/posts/5727.html</id>
    <published>2020-04-07T09:01:27.000Z</published>
    <updated>2020-05-25T02:10:04.416Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章对<code>SciPy</code>中的<strong>稀疏矩阵</strong>进行了学习，主要学习了四种常见的稀疏矩阵形式：<code>coo_matrix</code>,<code>lil_matrix</code>, <code>csr_matrix</code>和<code>csc_matrix</code>。针对每张稀疏矩阵学习<strong>了创建方法</strong>、<strong>查看属性的方法</strong>、<strong>如何转换为稠密矩阵</strong>以及<strong>切片操作</strong>等。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在处理数据时遇到的结果文件是使用稀疏矩阵的形式保存的，为了查看里面的数据就需要对稀疏矩阵有所了解，这里整理了一下学习的内容。</p><hr><h2 id="稀疏矩阵简介"><a href="#稀疏矩阵简介" class="headerlink" title="稀疏矩阵简介"></a>稀疏矩阵简介</h2><p><strong>什么是稀疏矩阵</strong>？按数据结构领域知名学者严老师的定义稀疏矩阵是<strong>一个矩阵里有小于5%非0数据的矩阵可以视为稀疏矩阵</strong>，如果矩阵的总数据量较大，完成存储这个矩阵会有大量的0存储，<strong>浪费空间</strong>，所以<strong>对稀疏矩阵的存储有必要研究用少量的内存存储稀疏矩阵</strong>，在数据结构里有时用三元组来解决。</p><p>SciPy中提供了<strong>7种不同类型的稀疏矩阵</strong>:</p><ul><li><code>bsr_matrix</code>: Block Sparse Row matrix</li><li><code>coo_matrix</code>: COOrdinate format matrix</li><li><code>csc_matrix</code>: Compressed Sparse Column matrix</li><li><code>csr_matrix</code>: Compressed Sparse Row matrix</li><li><code>dia_matrix</code>: Sparse matrix with DIAgonal storage</li><li><code>dok_matrix</code>: Dictionary Of Keys based sparse matrix</li><li><code>lil_matrix</code>: Row-based LInked List sparse matrix</li></ul><p><strong>各种稀疏矩阵适用的操作不同</strong>。如果想<strong>创建一个新的稀疏矩阵</strong>，<code>lil_matrix</code>，<code>dok_matrix</code>和<code>coo_matrix</code>会比高效，但是它们<strong>不适合做矩阵运算</strong>。如果想做<strong>矩阵运算</strong>，例如矩阵乘法、求逆等，应该用 <code>csc_matrix</code> 或者 <code>csr_matrix</code> 类型的稀疏矩阵。由于<strong>在内存中存储顺序的差异</strong>，<code>csc_matrix</code> 矩阵更适合<strong>取列切片</strong>，而 <code>csr_matrix</code> 矩阵更适合用来<strong>取行切片</strong>。</p><p>接下来主要学习其中几种比较常见的：<code>coo_matrix</code>,<code>lil_matrix</code>, <code>csr_matrix</code>和<code>csc_matrix</code>。</p><hr><h2 id="coo-matrix"><a href="#coo-matrix" class="headerlink" title="coo_matrix"></a>coo_matrix</h2><p><code>coo_matrix</code>是最简单的存储方式。采用三个数组<code>row</code>、<code>col</code>和<code>data</code>保存<strong>非零元素的信息</strong>。这三个<strong>数组的长度相同</strong>，<code>row</code>保存元素的行，<code>col</code>保存元素的列，<code>data</code>保存元素的值。一般来说，<code>coo_matrix</code>主要用来创建矩阵。</p><p><code>coo_matrix</code>存储数据的示意图：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/SciPy_coo_sparse_matrix.png.png" alt="SciPy_coo_sparse_matrix.png"></p><p>从上图中可以很直观看出哪些位置对应的哪些非零元素，比如第一个非零元素的坐标为<code>(0,0)</code>，值为<code>1</code>.</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>通过指定<strong>非零元素的行列坐标</strong>以及<strong>data值</strong>进行创建：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> coo_matrix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行下标</span></span><br><span class="line">row_ind = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 列下标</span></span><br><span class="line">col_ind = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 数值</span></span><br><span class="line">data = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], dtype=float)</span><br><span class="line">mat_coo = coo_matrix((data, (row_ind, col_ind)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">print(mat_coo)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">4</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">3</span>, <span class="number">3</span>)<span class="number">4.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">4</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><p></p><p><strong>通过稠密数组或者矩阵创建</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mat_dense=np.array(</span><br><span class="line">    [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接由数组创建</span></span><br><span class="line">mat_coo2 = coo_matrix(mat_dense)</span><br><span class="line">print(mat_coo2)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">4</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">3</span>, <span class="number">3</span>)<span class="number">4.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">4</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看非零元素的行索引</span></span><br><span class="line">mat_coo.row</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=int32)</span><br><span class="line"><span class="comment"># 查看非零元素的列索引</span></span><br><span class="line">mat_coo.col</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=int32)</span><br><span class="line"><span class="comment"># 查看非零元素的data值</span></span><br><span class="line">mat_coo.data</span><br><span class="line">  array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看大小</span></span><br><span class="line">mat_coo.shape</span><br><span class="line">  (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">type(mat_coo)</span><br><span class="line">  scipy.sparse.coo.coo_matrix</span><br><span class="line"><span class="comment"># 稀疏矩阵中非0元素的个数</span></span><br><span class="line">mat_coo.nnz</span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="转换为稠密矩阵"><a href="#转换为稠密矩阵" class="headerlink" title="转换为稠密矩阵"></a>转换为稠密矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将稀疏矩阵转换为数组的形式</span></span><br><span class="line">mat_dense = mat_coo.toarray()</span><br><span class="line">mat_dense</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将稀疏矩阵转换为稠密矩阵的形式</span></span><br><span class="line">mat_coo.todense()</span><br><span class="line">  matrix([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br></pre></td></tr></table></figure><hr><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select_ind=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 直接报错</span></span><br><span class="line">mat_coo2[:,select_ind]</span><br><span class="line">  ---------------------------------------------------------------------------</span><br><span class="line">  TypeError                                 Traceback (most recent call last)</span><br><span class="line">  &lt;ipython-input<span class="number">-258</span>-a25d626229ea&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  ----&gt; 1 mat_coo2[:,select_ind]</span><br><span class="line"></span><br><span class="line">  TypeError: <span class="string">'coo_matrix'</span> object <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure><hr><h2 id="lil-matrix"><a href="#lil-matrix" class="headerlink" title="lil_matrix"></a>lil_matrix</h2><p><code>lil_matrix</code>是使用<strong>两个数组存储非0元素</strong>。<code>data</code>保存每行中的非零元素,<code>rows</code>保存非零元素所在的列。这种格式也<strong>很适合逐个添加元素</strong>，并且能快速获取行相关的数据。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><strong>通过稠密数组或者矩阵创建</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> lil_matrix</span><br><span class="line"></span><br><span class="line">mat_dense=np.array(</span><br><span class="line">    [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">     [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接由数组创建</span></span><br><span class="line">mat_lil = lil_matrix(mat_dense)</span><br><span class="line">print(mat_lil)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">4</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">3</span>, <span class="number">3</span>)<span class="number">4.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">4</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><p></p><p><strong>不同稀疏矩阵之间转化</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将coo_matrix转换为lil_matrix</span></span><br><span class="line">lmat_lil2=il_matrix(mat_coo)</span><br><span class="line">print(mat_lil2)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">4</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">3</span>, <span class="number">3</span>)<span class="number">4.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">4</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看属性-1"><a href="#查看属性-1" class="headerlink" title="查看属性"></a>查看属性</h3><p>不同于<code>coo_matrix</code>是由<code>row</code>、<code>col</code>和<code>data</code>保存<strong>非零元素的信息</strong>，所以存在<code>row</code>、<code>col</code>和<code>data</code>三种属性；<code>lil_matrix</code>是由<code>rows</code>和<code>data</code>来保存非零元素的信息，所以也就只有<code>rows</code>和<code>data</code>两种属性。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看每行中非零元素的列信息</span></span><br><span class="line">mat_lil.rows</span><br><span class="line">  array([list([<span class="number">0</span>]), list([<span class="number">2</span>, <span class="number">4</span>]), list([]), list([<span class="number">3</span>]), list([<span class="number">4</span>])],</span><br><span class="line">        dtype=object)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看非零元素的value</span></span><br><span class="line">mat_lil.data</span><br><span class="line">  array([list([<span class="number">1.0</span>]), list([<span class="number">2.0</span>, <span class="number">3.0</span>]), list([]), list([<span class="number">4.0</span>]), list([<span class="number">5.0</span>])],</span><br><span class="line">        dtype=object)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看大小</span></span><br><span class="line">mat_lil.shape</span><br><span class="line">  (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">type(mat_lil)</span><br><span class="line">  scipy.sparse.lil.lil_matrix</span><br><span class="line"><span class="comment"># 稀疏矩阵中非0元素的个数</span></span><br><span class="line">mat_lil.nnz</span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="转换为稠密矩阵-1"><a href="#转换为稠密矩阵-1" class="headerlink" title="转换为稠密矩阵"></a>转换为稠密矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将稀疏矩阵转换为数组的形式</span></span><br><span class="line">mat_dense = mat_lil.toarray()</span><br><span class="line">mat_dense</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将稀疏矩阵转换为稠密矩阵的形式</span></span><br><span class="line">mat_lil.todense()</span><br><span class="line">  matrix([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br></pre></td></tr></table></figure><hr><h3 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select_ind=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">mat_lil[:,select_ind]</span><br><span class="line">  &lt;<span class="number">5</span>x3 sparse matrix of type <span class="string">'&lt;class '</span>numpy.float64<span class="string">'&gt;'</span></span><br><span class="line">    <span class="keyword">with</span> <span class="number">4</span> stored elements <span class="keyword">in</span> List of Lists format&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出新的切片之后的稀疏矩阵的数据索引信息</span></span><br><span class="line">print(mat_lil[:,select_ind])</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">1</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">2</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><hr><h2 id="csr-matrix"><a href="#csr-matrix" class="headerlink" title="csr_matrix"></a>csr_matrix</h2><p><code>csr_matrix</code>，是<strong>按行对矩阵进行压缩的</strong>。采用三个数组<code>data</code>, <code>indices</code>, <code>indptr</code>来存储非零元素的信息：</p><ul><li><code>data</code>：保存的非0元素，按行优先保存，即先将第1行的非零元素依次放完，然后载第二行直到最后；长度为非零元素的长度</li><li><code>indices</code>：给出每个非0值所在的列标；和<code>data</code>数组长度相同</li><li><code>indptr</code>：行偏移量，如下图中的0表示第一行的第一个非零数值在<code>data</code>中的索引，2表示第2行的第一个非零元素在<code>data</code>中的索引；长度为稀疏矩阵行数+1，最后一个数值表示的是<strong>非零数值数量 = <code>indices</code>和<code>data</code>的长度</strong></li></ul><p><code>csr_matrix</code>存储数据的示意图：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/SciPy_csr_sparse_matrix.png.png" alt="SciPy_csr_sparse_matrix.png"></p><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><p>通过指定<strong>非零元素的行列坐标</strong>以及<strong>data值</strong>进行创建：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行索引</span></span><br><span class="line">row = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 列索引</span></span><br><span class="line">col = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 数据</span></span><br><span class="line">data = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">mat_csr=csr_matrix((data, (row, col)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">print(mat_csr)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1</span></span><br><span class="line">  (<span class="number">0</span>, <span class="number">2</span>)<span class="number">2</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">3</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">0</span>)<span class="number">4</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">1</span>)<span class="number">5</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">2</span>)<span class="number">6</span></span><br></pre></td></tr></table></figure><p></p><p><strong>通过<code>data</code>, <code>indices</code>, <code>indptr</code>三个数组来创建</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行偏移量数组</span></span><br><span class="line">indptr = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 列索引数组</span></span><br><span class="line">indices = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 数据数组</span></span><br><span class="line">data = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">mat_csr=csr_matrix((data, indices, indptr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">print(mat_csr)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1</span></span><br><span class="line">  (<span class="number">0</span>, <span class="number">2</span>)<span class="number">2</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">3</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">0</span>)<span class="number">4</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">1</span>)<span class="number">5</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">2</span>)<span class="number">6</span></span><br></pre></td></tr></table></figure><p></p><p><strong>不同稀疏矩阵之间转化</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将coo_matrix转换为csr_matrix</span></span><br><span class="line">mat_csr=csr_matrix(mat_coo)</span><br><span class="line">print(mat_csr)</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">4</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">3</span>, <span class="number">3</span>)<span class="number">4.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">4</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看属性-2"><a href="#查看属性-2" class="headerlink" title="查看属性"></a>查看属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看行偏移量</span></span><br><span class="line"><span class="comment">## 因为第三行没有非零元素，所以直接和第四行的相同了</span></span><br><span class="line">mat_csr.indptr</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看列索引</span></span><br><span class="line">mat_csr.indices</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">mat_csr.data</span><br><span class="line">  array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看大小</span></span><br><span class="line">mat_csr.shape</span><br><span class="line">  (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">type(mat_csr)</span><br><span class="line">  scipy.sparse.csr.csr_matrix</span><br><span class="line"><span class="comment"># 稀疏矩阵中非0元素的个数</span></span><br><span class="line">mat_csr.nnz</span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="转换为稠密矩阵-2"><a href="#转换为稠密矩阵-2" class="headerlink" title="转换为稠密矩阵"></a>转换为稠密矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将稀疏矩阵转换为数组的形式</span></span><br><span class="line">mat_dense = mat_csr.toarray()</span><br><span class="line">mat_dense</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将稀疏矩阵转换为稠密矩阵的形式</span></span><br><span class="line">mat_csr.todense()</span><br><span class="line">  matrix([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>]])</span><br></pre></td></tr></table></figure><hr><h3 id="切片-2"><a href="#切片-2" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select_ind=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">mat_csr[:,select_ind]</span><br><span class="line">  &lt;<span class="number">5</span>x3 sparse matrix of type <span class="string">'&lt;class '</span>numpy.float64<span class="string">'&gt;'</span></span><br><span class="line">    <span class="keyword">with</span> <span class="number">4</span> stored elements <span class="keyword">in</span> Compressed Sparse Row format&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出新的切片之后的稀疏矩阵的数据索引信息</span></span><br><span class="line">print(mat_csr[:,select_ind])</span><br><span class="line">  (<span class="number">0</span>, <span class="number">0</span>)<span class="number">1.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">1</span>)<span class="number">2.0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>)<span class="number">3.0</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">2</span>)<span class="number">5.0</span></span><br></pre></td></tr></table></figure><hr><h2 id="csc-matrix"><a href="#csc-matrix" class="headerlink" title="csc_matrix"></a>csc_matrix</h2><p><code>csc_matrix</code>和<code>csr_matrix</code>一个是<strong>按稀疏列</strong>进行压缩的，一个是<strong>按照稀疏行</strong>进行压缩的，内容基本相同，这里就不做介绍了。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/scipy-lecture-notes/content/10.html" target="_blank" rel="noopener">SciPy中稀疏矩阵</a></li><li><a href="http://liao.cpython.org/scipy03/" target="_blank" rel="noopener">SciPy创建稀疏矩阵</a></li><li><a href="https://www.biaodianfu.com/scipy-sparse.html" target="_blank" rel="noopener">SciPy中的稀疏矩阵scipy.sparse</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章对&lt;code&gt;SciPy&lt;/code&gt;中的&lt;strong&gt;稀疏矩阵&lt;/strong&gt;进行了学习，主要学习了四种常见的稀疏矩阵形式：&lt;code&gt;coo_matrix&lt;/code&gt;,&lt;code&gt;lil_matrix&lt;/code&gt;, &lt;code&gt;csr_matrix&lt;/code&gt;和&lt;code&gt;csc_matrix&lt;/code&gt;。针对每张稀疏矩阵学习&lt;strong&gt;了创建方法&lt;/strong&gt;、&lt;strong&gt;查看属性的方法&lt;/strong&gt;、&lt;strong&gt;如何转换为稠密矩阵&lt;/strong&gt;以及&lt;strong&gt;切片操作&lt;/strong&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
</feed>
