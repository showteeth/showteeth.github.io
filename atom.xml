<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-03-23T13:06:37.634Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python系列之logging-日志</title>
    <link href="http://showteeth.tech/posts/56982.html"/>
    <id>http://showteeth.tech/posts/56982.html</id>
    <published>2019-03-22T12:31:42.000Z</published>
    <updated>2019-03-23T13:06:37.634Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章依照<a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">这篇博客</a>对Python的常用模块logging进行了学习，主要学习了<code>日志的作用</code>、<code>不同开发环境设置不同的日志输出</code>、<code>使用logging模块的日志级别函数直接记录日志</code>；也学习了logging模块的<strong>高级用法</strong>，包括<strong>使用logging模块的四大组件进行日志记录(主要用于满足多种需求，如将结果同时输出到文件和屏幕)</strong>、配置logging的几种方式、向日志输出上下文信息等；最后也总结了一些<strong>实战技巧</strong>。</p></div><a id="more"></a><h2 id="日志相关概念"><a href="#日志相关概念" class="headerlink" title="日志相关概念"></a>日志相关概念</h2><p>日志是一种可以<strong>追踪某些软件运行时所发生事件的方法</strong>。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有<strong>重要性</strong>的概念，这个重要性也可以被称为严重性级别（level）。</p><h3 id="日志的作用"><a href="#日志的作用" class="headerlink" title="日志的作用"></a>日志的作用</h3><p>通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。<br><strong>简单来讲就是</strong>，我们通过记录和分析日志可以了解一个系统或软件程序<strong>运行情况是否正常</strong>，也可以<strong>在应用程序出现故障时快速定位问题</strong>。比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。日志的作用可以<strong>简单总结</strong>为以下3点：</p><ul><li><strong>程序调试</strong></li><li><strong>了解软件程序运行情况，是否正常</strong></li><li><strong>软件程序运行故障分析与问题定位</strong></li></ul><p>如果应用的日志信息足够详细和丰富，还可以<strong>用来做用户行为分析</strong>，如：分析用户的操作行为、类型喜好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。</p><hr><h3 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h3><p>我们先来思考下下面的两个问题：</p><ul><li>作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？</li><li>作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？</li></ul><p>在<strong>软件开发阶段或部署开发环境</strong>时，为了<strong>尽可能详细</strong>的查看应用程序的运行状态来<strong>保证上线后的稳定性</strong>，我们可能<strong>需要把该应用程序所有的运行日志全部记录下来进行分析</strong>，<u>这是非常耗费机器性能的</u>。当<strong>应用程序正式发布或在生产环境部署应用程序</strong>时，我们通常<strong>只需要记录应用程序的异常信息、错误信息</strong>等，这样既可以减小服务器的<code>I/O</code>压力，也可以避免我们在排查故障时被淹没在日志的海洋里。那么，<mark><strong>怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？</strong>这就是<strong>日志等级</strong>的作用了，我们<strong>通过配置文件指定我们需要的日志等级就可以了</strong></mark>。</p><p>不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级(具体的级别高低在后面会有讲解)：</p><ul><li>DEBUG</li><li>INFO</li><li>NOTICE</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>ALERT</li><li>EMERGENCY</li></ul><hr><h3 id="日志字段信息与日志格式"><a href="#日志字段信息与日志格式" class="headerlink" title="日志字段信息与日志格式"></a>日志字段信息与日志格式</h3><p>本节开始问题提到过，<strong>一条日志信息对应的是一个事件的发生</strong>，而<strong>一个事件通常需要包括以下几个内容</strong>：</p><ul><li>事件发生<strong>时间</strong></li><li>事件发生<strong>位置</strong></li><li>事件的<strong>严重程度–日志级别</strong></li><li>事件<strong>内容</strong></li></ul><p>上面这些都是一条日志记录中可能包含的字段信息，当然<strong>还可以包括</strong>一些其他信息，如<code>进程ID</code>、<code>进程名称</code>、<code>线程ID</code>、<code>线程名称</code>等。<strong>日志格式</strong>就是用来定义一条日志记录中包含哪些字段的，且日志格式通常都是可以自定义的。</p><div class="note info"><p>输出一条日志时，<strong>日志内容</strong>和<strong>日志级别</strong>是<strong>需要开发人员明确指定的(必须的)</strong>。对于而其它字段信息，只需要是否显示在日志中就可以了。</p></div><h3 id="日志功能的实现"><a href="#日志功能的实现" class="headerlink" title="日志功能的实现"></a>日志功能的实现</h3><p>几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：<code>log4j</code>，<code>log4php</code>等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块–<code>logging</code>。</p><hr><p><br></p><h2 id="logging模块简介"><a href="#logging模块简介" class="headerlink" title="logging模块简介"></a>logging模块简介</h2><p><code>logging</code>模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。<code>logging</code>模块是Python的一个<strong>标准库模块</strong>，<strong>由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能</strong>。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><h3 id="logging模块的日志级别"><a href="#logging模块的日志级别" class="headerlink" title="logging模块的日志级别"></a>logging模块的日志级别</h3><p>logging模块默认定义了以下几个日志等级，它<strong>允许开发人员自定义其他日志级别</strong>，但是这是<strong>不被推荐的</strong>，尤其是在开发供别人使用的库时，因为这<strong>会导致日志级别的混乱</strong>。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>日志等级</th><th>数值</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>10</td><td><strong>最详细</strong>的日志信息，典型应用场景是<strong>问题诊断</strong></td></tr><tr><td>INFO</td><td>20</td><td>信息详细程度仅次于DEBUG，通常<strong>只记录关键节点信息</strong>，用于<strong>确认一切都是按照我们预期的那样进行工作</strong></td></tr><tr><td>WARNING</td><td>30</td><td>当<strong>某些不期望的事情发生</strong>时记录的信息（如，磁盘可用空间较低），但是<strong>此时应用程序还是正常运行</strong>的</td></tr><tr><td>ERROR</td><td>40</td><td>由于一个更严重的问题<strong>导致某些功能不能正常运行</strong>时记录的信息</td></tr><tr><td>CRITICAL</td><td>50</td><td>当发生严重错误，<strong>导致应用程序不能继续运行</strong>时记录的信息</td></tr></tbody></table><div class="note info"><ul><li>上面列表中的<strong>日志等级是从上到下依次升高(按照数值的大小排序)</strong>的，即：<code>DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</code>，而<strong>日志的信息量是依次减少的</strong>；</li><li><p><code>logging</code>模块<strong>可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃</strong>；</p></li><li><p><strong>开发应用程序或部署开发环境</strong>时，可以使用<code>DEBUG</code>或<code>INFO</code>级别的日志获取<strong>尽可能详细</strong>的日志信息来进行开发或部署调试；</p></li><li><strong>应用上线或部署生产环境</strong>时，应该使用<code>WARNING</code>或<code>ERROR</code>或<code>CRITICAL</code>级别的日志来降低机器的<code>I/O</code>压力和提高获取错误日志信息的效率；</li><li><strong>日志级别的指定通常都是在应用程序的配置文件中进行的</strong>。</li></ul></div><hr><h3 id="logging模块的使用方式介绍"><a href="#logging模块的使用方式介绍" class="headerlink" title="logging模块的使用方式介绍"></a>logging模块的使用方式介绍</h3><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是<strong>使用logging提供的日志级别的函数</strong></li><li>第二种方式是<strong>使用Logging日志系统的四大组件</strong></li></ul><p>其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已</p><h4 id="logging模块定义的日志级别的常用函数"><a href="#logging模块定义的日志级别的常用函数" class="headerlink" title="logging模块定义的日志级别的常用函数:"></a>logging模块定义的日志级别的常用函数:</h4><table><tr><th width="40%">函数</th><th width="60%">说明</th></tr><tr><td><code>logging.debug(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>DEBUG</code>的日志记录</td></tr><tr><td><code>logging.info(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>INFO</code>的日志记录</td></tr><tr><td><code>logging.warning(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>WARNING</code>的日志记录</td></tr><tr><td><code>logging.error(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>ERROR</code>的日志记录</td></tr><tr><td><code>logging.critical(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>CRITICAL</code>的日志记录</td></tr><tr><td><code>logging.log(level, *args, **kwargs)</code></td><td>创建一条级别为<code>level</code>的日志记录</td></tr><tr><td><code>logging.basicConfig(**kwargs)</code></td><td>对<code>root logger</code>进行一次性配置</td></tr></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定<code>要记录的日志级别</code>、<code>日志格式</code>、<code>日志输出位置</code>、<code>日志文件的打开模式</code>等信息，<strong>其他几个都是用于记录各个级别日志的函数</strong>。</p><hr><h4 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h4><table><tr><th width="20%">组件</th><th width="80%">说明</th></tr><tr><td><code>loggers</code></td><td>提供应用程序代码直接使用的接口</td></tr><tr><td><code>handlers</code></td><td>用于将日志记录发送到指定的目的位置</td></tr><tr><td><code>filters</code></td><td>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）</td></tr><tr><td><code>formatters</code></td><td>用于控制日志信息的最终输出格式</td></tr></table><div class="note info"><p>logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。</p></div><hr><p><br></p><h2 id="使用日志级别函数记录日志"><a href="#使用日志级别函数记录日志" class="headerlink" title="使用日志级别函数记录日志"></a>使用日志级别函数记录日志</h2><p>回顾下前面提到的<strong>几个重要信息</strong>：</p><ul><li>可以通过logging模块定义的日志级别方法去完成简单的日志记录</li><li><strong>只有级别大于或等于日志记录器指定级别的日志记录才会被输出，小于该级别的日志记录将会被丢弃</strong></li></ul><h3 id="最简单的日志输出"><a href="#最简单的日志输出" class="headerlink" title="最简单的日志输出"></a>最简单的日志输出</h3><p><strong>使用各种具体级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>也可以使用统一设置级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.log(logging.DEBUG, <span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.log(logging.INFO, <span class="string">"This is a info log."</span>)</span><br><span class="line">logging.log(logging.WARNING, <span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.log(logging.ERROR, <span class="string">"This is a error log."</span>)</span><br><span class="line">logging.log(logging.CRITICAL, <span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br><span class="line">================================</span><br><span class="line">WARNING:root:This <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:This <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:This <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><p>第二种写法显然没有第一种写法简单，以后还是使用第一种写法吧</p><h3 id="简单日志输出的结果分析"><a href="#简单日志输出的结果分析" class="headerlink" title="简单日志输出的结果分析"></a>简单日志输出的结果分析</h3><h4 id="为什么前面两条日志没有被打印出来？"><a href="#为什么前面两条日志没有被打印出来？" class="headerlink" title="为什么前面两条日志没有被打印出来？"></a>为什么前面两条日志没有被打印出来？</h4><p>这是因为logging模块提供的日志记录函数所使用的日志器设置的日志级别是<code>WARNING</code>(<strong>logging的默认日志级别是warning</strong>)，因此只有<code>WARNING</code>级别的日志记录以及<strong>大于等于</strong>它的<code>ERROR</code>和<code>CRITICAL</code>级别的日志记录<strong>被输出</strong>了，而<strong>小于</strong>它的<code>DEBUG</code>和<code>INFO</code>级别的日志记录<strong>被丢弃</strong>了。</p><hr><h4 id="日志信息中各字段含义？为什么会这样输出？"><a href="#日志信息中各字段含义？为什么会这样输出？" class="headerlink" title="日志信息中各字段含义？为什么会这样输出？"></a>日志信息中各字段含义？为什么会这样输出？</h4><p>上面输出结果中每行日志记录的各个字段含义分别是：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志级别:日志器名称:日志内容</span><br></pre></td></tr></table></figure><p></p><p>之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器<strong>设置的日志格式默认是<code>BASIC_FORMAT</code></strong>，其值为：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="如果将日志记录输出到文件中，而不是打印到控制台？"><a href="#如果将日志记录输出到文件中，而不是打印到控制台？" class="headerlink" title="如果将日志记录输出到文件中，而不是打印到控制台？"></a>如果将日志记录输出到文件中，而不是打印到控制台？</h4><p>因为在logging模块提供的日志记录函数所使用的日志器设置的处理器所<strong>指定的日志输出位置默认为:<code>sys.stderr</code>.</strong></p><hr><h4 id="我是怎么知道这些的？"><a href="#我是怎么知道这些的？" class="headerlink" title="我是怎么知道这些的？"></a>我是怎么知道这些的？</h4><p><strong>查看这些日志记录函数的实现代码</strong>，可以发现：当我们<strong>没有提供任何配置信息的时候</strong>，这些函数都会去调用<code>logging.basicConfig(**kwargs)</code>方法，且不会向该方法传递任何参数。继续<strong>查看<code>basicConfig()</code>方法的代码</strong>就可以找到上面这些问题的答案了。</p><p><strong>查看源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先导入模块</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">help(logging.basicConfig)</span><br><span class="line"></span><br><span class="line">The default behaviour <span class="keyword">is</span> to create a StreamHandler which writes to sys.stderr, set a formatter using the BASIC_FORMAT format string, <span class="keyword">and</span> add the handler to the root logger.</span><br><span class="line"></span><br><span class="line">BASIC_FORMAT = <span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="怎么修改这些默认设置呢？"><a href="#怎么修改这些默认设置呢？" class="headerlink" title="怎么修改这些默认设置呢？"></a>怎么修改这些默认设置呢？</h4><p>其实很简单，在我们<strong>调用上面这些日志记录函数之前</strong>，<strong>手动调用一下<code>basicConfig()</code>方法</strong>，把我们<strong>想设置的内容以参数的形式传递进去就可以了</strong>。</p><hr><h3 id="logging-basicConfig-函数说明"><a href="#logging-basicConfig-函数说明" class="headerlink" title="logging.basicConfig()函数说明"></a>logging.basicConfig()函数说明</h3><p>经过上述对简单日志输出的结果分析，发现如果我们想修改输出的信息(默认设置)就需要在调用日志记录函数之前，手动调用一下<code>basicConfig()</code>方法，所以这里来对<code>logging.basicConfig()</code>函数进行一定的学习。该方法用于为logging日志系统做一些基本配置，方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure><p></p><p><strong>该函数可接收的关键字参数</strong>如下：</p><table><tr><th width="20%">参数名称</th><th width="80%">描述</th></tr><tr><td><code>filename</code></td><td><strong>指定日志输出目标文件的文件名</strong>，指定该设置项后日志信息就不会被输出到控制台了</td></tr><tr><td><code>filemode</code></td><td>指定日志文件的打开模式，默认为<code>a</code>。需要注意的是，<strong>该选项要在filename指定时才有效</strong></td></tr><tr><td><code>format</code></td><td>指定日志格式字符串，即<strong>指定日志输出时所包含的字段信息以及它们的顺序</strong>。logging模块定义的格式字段下面会列出。</td></tr><tr><td><code>datefmt</code></td><td>指定日期/时间格式。需要注意的是，该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></td></tr><tr><td><code>level</code></td><td><strong>指定日志器的日志级别</strong></td></tr><tr><td><code>stream</code></td><td>指定日志输出目标stream，如<code>sys.stdout</code>、<code>sys.stderr</code>以及网络stream。需要说明的是，<strong>stream和filename不能同时提供，否则会引发 ValueError异常</strong></td></tr><tr><td><code>style</code></td><td>Python 3.2中新添加的配置项。<strong>指定format格式字符串的风格<strong>，可取值为<code>%</code>、<code>{</code>和<code>$</code>，默认为<code>%</code></strong></strong></td></tr><tr><td><code>handlers</code></td><td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：<strong>filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常</strong>。</td></tr></table><hr><h3 id="格式字符串字段-format"><a href="#格式字符串字段-format" class="headerlink" title="格式字符串字段(format)"></a>格式字符串字段(format)</h3><p>这里列出了<code>logging.basicConfig()</code>函数中的日志格式字符串(format)包含的字段：</p><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的<strong>时间</strong>–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–<strong>时间戳</strong>，就是当时调用<code>time.time()</code>函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的<strong>相对毫秒数</strong>（目前还不知道干嘛用的）</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的<strong>毫秒部分</strong></td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的<strong>文字形式的日志级别(‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’)</strong></td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的<strong>数字形式的日志级别(10, 20, 30, 40, 50)</strong></td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的<strong>日志器名称</strong>，<strong>默认是’root’，因为默认使用的是 rootLogger</strong></td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 <code>msg % args</code>计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td><strong>调用日志记录函数的源码文件的全路径</strong></td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的<strong>文件名部分，包含文件后缀</strong></td></tr><tr><td>module</td><td>%(module)s</td><td>filename的<strong>名称部分，不包含后缀</strong></td></tr><tr><td>lineno</td><td>%(lineno)d</td><td><strong>调用日志记录函数的源代码所在的行号</strong></td></tr><tr><td>funcName</td><td>%(funcName)s</td><td><strong>调用日志记录函数的函数名</strong></td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><div class="note info"><p>定义format的形式：<code>BASIC_FORMAT = &quot;%(levelname)s:%(name)s:%(message)s&quot;</code>这是官方的默认形式，不同字段间使用<code>:</code>分割，分割符可以自定义</p></div><hr><h3 id="自定义输出日志信息"><a href="#自定义输出日志信息" class="headerlink" title="自定义输出日志信息"></a>自定义输出日志信息</h3><h4 id="level-自定义日志级别"><a href="#level-自定义日志级别" class="headerlink" title="level-自定义日志级别"></a>level-自定义日志级别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"=====change level====="</span>)</span><br><span class="line"><span class="comment">## 自定义日志器的日志级别</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p>输出信息：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====change level=====</span><br><span class="line">DEBUG:root:this <span class="keyword">is</span> a debug log.</span><br><span class="line">INFO:root:this <span class="keyword">is</span> a info log.</span><br><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="filename-amp-format-设置日志输出目标文件和日志格式"><a href="#filename-amp-format-设置日志输出目标文件和日志格式" class="headerlink" title="filename &amp; format-设置日志输出目标文件和日志格式"></a>filename &amp; format-设置日志输出目标文件和日志格式</h4><ul><li><code>filename</code>：指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了</li><li><code>format</code>：指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。<ul><li><code>%(asctime)s</code>：日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</li><li><code>%(levelname)s</code>：该日志记录的文字形式的日志级别<code>(&#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;)</code></li><li><code>%(message)s</code>：日志记录的文本内容，通过 <code>msg % args</code>计算得到的</li></ul></li></ul><p><strong>示例代码如下</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"=====change out file and format====="</span>)</span><br><span class="line"><span class="comment"># 设置输出的format，中间的字段分隔符可以自定义</span></span><br><span class="line">LOG_FORMAT=<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line"><span class="comment"># 设置日志输出文件名以及format</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>,level=logging.DEBUG,format=LOG_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="datefmt-设置日期-时间格式"><a href="#datefmt-设置日期-时间格式" class="headerlink" title="datefmt-设置日期/时间格式"></a>datefmt-设置日期/时间格式</h4><ul><li>时间格式同<code>time.strftime()</code>，具体信息可以本文最后的补充信息</li><li>该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>从上面输出结果可以发现，前面几行是上一步生成的日志文件，下面几行是这步生成的文件，这是因为<strong>默认的<code>filemode</code>是<code>a</code>也就是追加的意思，所以没有清空原始文件的信息</strong>。</p><hr><h4 id="filemode-指定日志文件的打开模式"><a href="#filemode-指定日志文件的打开模式" class="headerlink" title="filemode-指定日志文件的打开模式"></a>filemode-指定日志文件的打开模式</h4><ul><li>该选项默认为<code>a</code></li><li>需要注意的是，<strong>该选项要在filename指定时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件打开模式更改为w，如果存在就清空然后写入，如果不存在就创建</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT,filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  03/23/2019 00:23:36 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>可以发现前一步的输出结果已经被覆盖掉了，只生成了这一步的输出结果。</p><hr><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><h4 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h4><ul><li><code>logging.basicConfig()</code>函数是一个<strong>一次性的简单配置工具</strong>，也就是说<strong>只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作</strong></li><li><strong>日志器（Logger）是有层级关系的</strong>，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为<code>root</code>，它是<strong>处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的</strong></li><li>如果要记录的<strong>日志中包含变量数据</strong>，<strong>可使用一个格式字符串</strong>作为这个事件的描述消息(<code>logging.debug</code>、<code>logging.info</code>等函数的第一个参数)，然后将变量数据作为第二个参数<code>*args</code>的值进行传递，如:<code>logging.warning(&#39;%s is %d years old.&#39;, &#39;Tom&#39;, 10)</code>，输出内容为<code>WARNING:root:Tom is 10 years old.</code>.</li></ul><hr><h4 id="日志级别方法参数的补充说明"><a href="#日志级别方法参数的补充说明" class="headerlink" title="日志级别方法参数的补充说明"></a>日志级别方法参数的补充说明</h4><ul><li><code>logging.debug()</code>, <code>logging.info()</code>等方法的定义中，除了<code>msg</code>和<code>args</code>参数外，还有一个<code>**kwargs</code>参数。它们<strong>支持3个关键字参数</strong>: <code>exc_info</code>、<code>stack_info</code>、<code>extra</code>，下面对这几个关键字参数作个说明:</li><li><code>exc_info</code>：其值为<strong>布尔值</strong>，如果该参数的值设置为<strong>True</strong>，则会<strong>将异常信息添加到日志消息中</strong>；如果<strong>没有异常信息则添加None到日志信息</strong>中</li><li><code>stack_info</code>：其值也为<strong>布尔值</strong>，<strong>默认值为False</strong>。如果该参数的值设置为<strong>True</strong>，<strong>栈信息将会被添加到日志信息中，相当于是哪一行输入了这个log信息</strong></li><li><code>extra</code>：这是一个<strong>字典（dict）参数</strong>，它可以用来<strong>自定义消息格式中所包含的字段</strong>，但是<strong>它的<code>key</code>不能与logging模块定义的字段冲突</strong></li></ul><p><strong>示例</strong>：<br>在日志消息中添加<code>exc_info</code>和<code>stack_info</code>信息，并添加<strong>两个自定义的字端</strong><code>ip</code>和<code>user</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(user)s[%(ip)s] - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置exc_info、stack_info、extra参数</span></span><br><span class="line">logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=<span class="keyword">True</span>, stack_info=<span class="keyword">True</span>, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03/23/2019 09:28:06 AM - WARNING - Tom[47.98.53.222] - Some one delete the <span class="built_in">log</span> file.</span><br><span class="line">NoneType: None</span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">"logging_learn.py"</span>, line 75, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=True, stack_info=True, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="日志模块四大组件以及日志流处理流程"><a href="#日志模块四大组件以及日志流处理流程" class="headerlink" title="日志模块四大组件以及日志流处理流程"></a>日志模块四大组件以及日志流处理流程</h2><p>在介绍logging模块的<strong>高级用法</strong>之前，很有必要对logging模块所包含的<strong>重要组件以及其工作流程做个全面、简要的介绍</strong>，这有助于我们更好的理解我们所写的代码（将会触发什么样的操作）。</p><h3 id="日志模块四大组件"><a href="#日志模块四大组件" class="headerlink" title="日志模块四大组件"></a>日志模块四大组件</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块日志级别的函数也是通过这些组件对应的类来实现的。</p><hr><h3 id="四大组件之间的关系"><a href="#四大组件之间的关系" class="headerlink" title="四大组件之间的关系"></a>四大组件之间的关系</h3><ul><li><strong>日志器(logger)需要通过处理器(handler)将日志信息输出到目标位置</strong>，如：文件、<code>sys.stdout</code>、网络等；</li><li>不同的<strong>处理器(handler)可以将日志输出到不同的位置</strong>；</li><li>日志器(logger)可以设置<strong>多个</strong>处理器(handler)将<strong>同一条</strong>日志记录输出到<strong>不同的位置</strong>；</li><li>每个<strong>处理器(handler)</strong>都可以<strong>设置自己的过滤器(filter)实现日志过滤</strong>，从而只保留感兴趣的日志；</li><li>每个<strong>处理器(handler)</strong>都可以设<strong>置自己的格式器(formatter)</strong>实现同一条日志<strong>以不同的格式输出到不同的地方</strong>。</li></ul><p>简单点说就是：<mark>日志器(logger)是入口，真正干活儿的是处理器(handler)，处理器(handler)还可以通过过滤器(filter)和格式器(formatter)对要输出的日志内容做过滤和格式化等处理操作。</mark></p><hr><h3 id="组件相关类与常用方法介绍"><a href="#组件相关类与常用方法介绍" class="headerlink" title="组件相关类与常用方法介绍"></a>组件相关类与常用方法介绍</h3><h4 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h4><p><strong>Logger对象有3个任务要做</strong>：</p><ul><li>向<strong>应用程序代码暴露几个方法</strong>，使应用程序<strong>可以在运行时记录日志消息</strong>；</li><li>基于日志严重等级(默认的过滤设施)或filter对象来<strong>决定要对哪些日志进行后续处理</strong>；</li><li>将日志消息<strong>传送给</strong>所有感兴趣的日志<strong>handlers</strong>。</li></ul><p><strong>Logger对象最常用的方法分为两类</strong>：</p><ul><li><code>配置方法</code></li><li><code>消息发送方法(创建日志)</code></li></ul><h5 id="最常用的配置方法"><a href="#最常用的配置方法" class="headerlink" title="最常用的配置方法"></a>最常用的配置方法</h5><table><tr><th>方法</th><th>描述</th></tr><tr><td><code>Logger.setLevel()</code></td><td><strong>设置<strong>日志器将会处理的日志消息的<strong>最低严重级别</strong></strong></strong></td></tr><tr><td><code>Logger.addHandler()</code>和<code>Logger.removeHandler()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>handler对象</strong></td></tr><tr><td><code>Logger.addFilter()</code>和<code>Logger.removeFilter()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>filter对象</strong></td></tr></table><div class="note info"><p>关于<code>Logger.setLevel()</code>方法的说明：内建等级中，级别最低的是<code>DEBUG</code>，级别最高的是<code>CRITICAL</code>。例如<code>setLevel(logging.INFO)</code>，此时函数参数为INFO，那么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。</p></div><hr><h5 id="创建日志记录方法"><a href="#创建日志记录方法" class="headerlink" title="创建日志记录方法"></a>创建日志记录方法</h5><p>logger对象配置完成后，可以<strong>使用下面的方法来创建日志记录</strong>：</p><table><tr><th width="50%">方法</th><th width="50%">描述</th></tr><tr><td><code>Logger.debug()</code>, <code>Logger.info()</code>, <code>Logger.warning()</code>, <code>Logger.error()</code>, <code>Logger.critical()</code></td><td>创建一个与它们的方法名对应等级的日志记录</td></tr><tr><td><code>Logger.exception()</code></td><td>创建一个类似于<code>Logger.error()</code>的日志消息</td></tr><tr><td><code>Logger.log()</code></td><td>需要获取一个明确的日志level参数来创建一个日志记录</td></tr></table><div class="note info"><ul><li><code>Logger.exception()</code>与<code>Logger.error()</code>的区别在于：<code>Logger.exception()</code>将会输出堆栈追踪信息，另外<strong>通常只是在一个exception handler中调用该方法</strong></li><li><code>Logger.log()</code>与<code>Logger.debug()</code>、<code>Logger.info()</code>等方法相比，虽然<strong>需要多传一个level参数，显得不是那么方便，但是当需要记录自定义level的日志时还是需要该方法来完成</strong></li></ul></div><h5 id="得到一个Logger对象"><a href="#得到一个Logger对象" class="headerlink" title="得到一个Logger对象"></a>得到一个Logger对象</h5><p>得到Logger对象方法有两种：</p><ul><li>第一种方式是通过<strong>Logger类的实例化方法</strong>创建一个Logger类的实例</li><li>第二种方式是<code>logging.getLogger()</code>方法，这是通常使用的方法</li></ul><p><code>logging.getLogger()</code>方法有一个<strong>可选参数</strong><code>name</code>，该参数表示将<strong>要返回的日志器的名称标识，如果不提供该参数，则其值为’root’</strong>。若以相同的<code>name</code>参数值多次调用<code>getLogger()</code>方法，将会返回指向同一个logger对象的引用。</p><div class="note info"><p>关于logger的<strong>层级结构</strong>与<strong>有效等级</strong>的说明：</p><ul><li><p>logger的名称是一个以<code>.</code>分割的层级结构，每个<code>.</code>后面的logger都是<code>.</code>前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代</p></li><li><p>logger有一个<strong>有效等级(effective level)</strong>的概念。</p><ul><li>如果一个logger上<strong>没有被明确设置一个level</strong>，那么该logger就是<strong>使用它parent的level</strong>；</li><li>如果它的<strong>parent也没有明确设置level</strong>则继续向上<strong>查找parent的parent的有效level，依次类推</strong>，直到找到个一个明确设置了level的祖先为止。</li><li>需要说明的是，<strong>root logger总是会有一个明确的level设置(默认为 WARNING)</strong>。</li><li>当<strong>决定是否去处理一个已发生的事件时</strong>，<strong>logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理</strong>。</li></ul></li><li><p><code>child loggers</code>在完成对日志消息的处理后，<strong>默认会将日志消息传递给与它们的祖先loggers相关的handlers</strong>。因此，我们<strong>不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了</strong>。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</p></li></ul></div><hr><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的<strong>作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）</strong>。Logger对象可以通过<code>addHandler()</code>方法<strong>为自己添加0个或者更多个handler对象</strong>。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>把所有日志都发送到一个日志文件中；</li><li>把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>把所有严重级别为critical的日志发送到一个email邮件地址。</li></ul><p>这种场景就需要<strong>3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置</strong>。</p><p>一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似乎唯一相关的handler方法就是下面这几个<strong>配置方法</strong>：</p><table><tr><th width="40%">方法</th><th width="60%">描述</th></tr><tr><td><code>Handler.setLevel()</code></td><td>设置handler将会处理的日志消息的最低严重级别</td></tr><tr><td><code>Handler.setFormatter()</code></td><td>为handler设置一个格式器对象</td></tr><tr><td><code>Handler.addFilter()</code>和<code>Handler.removeFilter()</code></td><td>为handler添加和删除一个过滤器对象</td></tr></table><p>需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了所有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些<strong>常用的Handler</strong>：</p><table><tr><th width="40%">Handler</th><th width="60%">描述</th></tr><tr><td><code>logging.StreamHandler</code></td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td><code>logging.FileHandler</code></td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td><code>logging.handlers.RotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td><code>logging.hanlders.TimedRotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td><code>logging.handlers.HTTPHandler</code></td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td><code>logging.handlers.SMTPHandler</code></td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td><code>logging.NullHandler</code></td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免'No handlers could be found for logger XXX'信息的出现。</td></tr></table><hr><h4 id="Formater类"><a href="#Formater类" class="headerlink" title="Formater类"></a>Formater类</h4><p>Formater对象用于<strong>配置日志信息的最终顺序、结构和内容</strong>。与logging.Handler基类不同的是，<strong>应用代码可以直接实例化Formatter类</strong>。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=<span class="keyword">None</span>, datefmt=<span class="keyword">None</span>, style=<span class="string">'%'</span>)</span><br></pre></td></tr></table></figure><p></p><p>可见，该构造方法接收3个可选参数：</p><ul><li><code>fmt</code>：指定消息格式化字符串，如果不指定该参数则<strong>默认使用message的原始值</strong></li><li><code>datefmt</code>：指定日期格式字符串，如果不指定该参数则默认使用<code>%Y-%m-%d %H:%M:%S</code></li><li><code>style</code>：Python 3.2新增的参数，可取值为<code>%</code>、<code>{</code>和<code>$</code>，如果不指定该参数则默认使用<code>%</code></li></ul><hr><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>.<span class="title">Filter</span><span class="params">(name=<span class="string">''</span>)</span></span></span><br><span class="line"><span class="class">    <span class="title">filter</span><span class="params">(record)</span></span></span><br></pre></td></tr></table></figure><p></p><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><div class="note info"><ul><li>如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性</li><li>我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等</li></ul></div><hr><h3 id="logging日志流处理流程"><a href="#logging日志流处理流程" class="headerlink" title="logging日志流处理流程"></a>logging日志流处理流程</h3><p>下面这个图描述了日志流的处理流程：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/logging处理流程.png" alt="logging处理流程.png"></p><p>我们来描述下上面这个图的日志流处理流程：</p><ul><li>（在用户代码中进行）<strong>日志记录函数调用</strong>，如：logger.info(…)，logger.debug(…)等；</li><li>判断要记录的日志级别<strong>是否满足日志器设置的级别要求</strong>（要记录的日志级别要大于或等于日志器设置的级别才算满足要求），如果不满足则该日志记录会被丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>根据日志记录函数调用时掺入的参数，<strong>创建</strong>一个<strong>日志记录（LogRecord类）对象</strong>；</li><li>判断日志记录器上设置的<strong>过滤器是否拒绝这条日志记录</strong>，如果日志记录器上的某个过滤器拒绝，则该日志记录会被丢弃并终止后续的操作，如果日志记录器上设置的过滤器不拒绝这条日志记录或者日志记录器上没有设置过滤器则继续下一步操作–<strong>将日志记录</strong>分别交给该日志器上添加的各个<strong>处理器</strong>；</li><li>判断要记录的日志级别<strong>是否满足处理器设置的级别要求</strong>（要记录的日志级别要大于或等于该处理器设置的日志级别才算满足要求），如果不满足记录将会被该处理器丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>判断该<strong>处理器上设置的过滤器</strong>是否拒绝这条日志记录，如果该处理器上的某个过滤器拒绝，则该日志记录会被当前处理器丢弃并终止后续的操作，如果当前处理器上设置的过滤器不拒绝这条日志记录或当前处理器上没有设置过滤器测继续下一步操作；</li><li>如果能到这一步，说明这条日志记录经过了层层关卡允许被输出了，此时当前<strong>处理器会根据自身被设置的格式器</strong>（如果没有设置则使用默认格式）将这条日志记录进行格式化，最后将格式化后的结果输出到指定位置（文件、网络、类文件的Stream等）；</li><li>如果日志器被设置了<strong>多个处理器</strong>的话，上面的第5-8步会执行多次；</li><li>这里才是完整流程的最后一步：<strong>判断该日志器输出的日志消息是否需要传递给上一级logger（之前提到过，日志器是有层级关系的）的处理器</strong>，如果propagate属性值为1则表示日志消息将会被输出到处理器指定的位置，同时还会被传递给parent日志器的handlers进行处理直到当前日志器的propagate属性为0停止，如果propagate值为0则表示不向parent日志器的handlers传递该消息，到此结束。</li></ul><p>可见，<strong>一条日志信息要想被最终输出需要依次经过以下几次过滤</strong>：</p><ul><li><strong>日志器等级过滤</strong></li><li>日志器的过滤器过滤</li><li><strong>日志器的处理器等级过滤</strong></li><li>日志器的处理器的过滤器过滤</li></ul><div class="note info"><p><strong>需要说明的是</strong>： 关于上面第9个步骤，如果propagate值为1，那么日志消息会直接传递交给上一级logger的handlers进行处理，此时上一级logger的日志等级并不会对该日志消息进行等级过滤。</p></div><hr><p><br></p><h2 id="使用四大组件记录日志"><a href="#使用四大组件记录日志" class="headerlink" title="使用四大组件记录日志"></a>使用四大组件记录日志</h2><p>现在，我们对logging模块的重要组件及整个日志流处理流程都应该有了一个比较全面的了解，下面我们来看一个例子。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>现在有以下几个日志记录的需求：</p><ul><li>要求将<strong>所有级别的所有日志都写入磁盘文件</strong>中</li><li><strong>all.log文件中记录所有的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 日志信息</li><li><strong>error.log文件中单独记录error及以上级别的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 文件名[:行号] - 日志信息</li><li>要求all.log在<strong>每天凌晨</strong>进行<strong>日志切割</strong></li></ul><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>要记录所有级别的日志，因此日志器的有效level需要设置为最低级别–DEBUG;</li><li><strong>日志需要被发送到两个不同的目的地</strong>，因此需要<strong>为日志器设置两个handler</strong>；另外，两个<strong>目的地都是磁盘文件</strong>，因此<strong>这两个handler都是与FileHandler相关的</strong>；</li><li>all.log要求<strong>按照时间进行日志切割</strong>，因此他需要用<code>logging.handlers.TimedRotatingFileHandler</code>; 而error.log没有要求日志切割，因此可以使用<code>FileHandler</code>;</li><li><strong>两个日志文件的格式不同</strong>，因此需要<strong>对这两个handler分别设置格式器</strong>.</li></ul><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'mylogger'</span>)</span><br><span class="line"><span class="comment"># 设置日志器的日志级别</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第一个handler，实现日志切割</span></span><br><span class="line">rf_handler = logging.handlers.TimedRotatingFileHandler(<span class="string">'all.log'</span>, when=<span class="string">'midnight'</span>, interval=<span class="number">1</span>, backupCount=<span class="number">7</span>, atTime=datetime.time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置第一个handler的格式器，使用了formatter类</span></span><br><span class="line">rf_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第二个handler</span></span><br><span class="line">f_handler = logging.FileHandler(<span class="string">'error.log'</span>)</span><br><span class="line"><span class="comment"># 设置这个handler的日志级别，实现日志过滤，在上面日志器的过滤结果中进行进一步的过滤</span></span><br><span class="line">f_handler.setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># 设置第二个handler的日志格式，使用了formatter类</span></span><br><span class="line">f_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给日志器添加第一个handler</span></span><br><span class="line">logger.addHandler(rf_handler)</span><br><span class="line"><span class="comment"># 给日志器添加第二个handler</span></span><br><span class="line">logger.addHandler(f_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同级别的日志信息 </span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat all.log</span><br><span class="line">  2019-03-23 16:53:48,763 - DEBUG - debug message</span><br><span class="line">  2019-03-23 16:53:48,766 - INFO - info message</span><br><span class="line">  2019-03-23 16:53:48,766 - WARNING - warning message</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - critical message</span><br><span class="line"></span><br><span class="line">cat error.log</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - logging_learn.py[:100] - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - logging_learn.py[:101] - critical message</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>%(filename)s[:%(lineno)d]</code>可以用来显示哪个文件的哪一行进行了这个日志输出</p></div><hr><h3 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a>其他实例</h3><h4 id="日志同时输出到文件和屏幕"><a href="#日志同时输出到文件和屏幕" class="headerlink" title="日志同时输出到文件和屏幕"></a>日志同时输出到文件和屏幕</h4><p>上面的那个实例是创建了两个handler来进行相关操作，其实也可以使用四大组件和日志级别函数结合来进行设置，<strong>以下是将日志同时输出到文件和屏幕的示例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用logging.basicConfig()来自定义日志输出信息，将日志信息输入到文件中</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                filename=<span class="string">'myapp.log'</span>,</span><br><span class="line">                filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"><span class="comment"># 使用四大组件来控制日志，因为一个handler只能输出到一个地方</span></span><br><span class="line"><span class="comment"># 这种需要输出到多个地方的肯定是需要两个handler的，上面的logging.basicConfig()相当于一个，所以还需要自己创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象#</span></span><br><span class="line">console = logging.StreamHandler()</span><br><span class="line"><span class="comment"># 设置handler的日志级别</span></span><br><span class="line">console.setLevel(logging.INFO)</span><br><span class="line"><span class="comment"># 使用foramtter类设置formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(name)-12s: %(levelname)-8s %(message)s'</span>)</span><br><span class="line"><span class="comment"># 设置handler的formatter</span></span><br><span class="line">console.setFormatter(formatter)</span><br><span class="line"><span class="comment"># 得到Logger类的对象并添加handler</span></span><br><span class="line">logging.getLogger(<span class="string">''</span>).addHandler(console)</span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'This is debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'This is info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'This is warning message'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="配置logging的几种方式"><a href="#配置logging的几种方式" class="headerlink" title="配置logging的几种方式"></a>配置logging的几种方式</h2><p>作为开发者，我们可以<strong>通过以下3中方式来配置logging</strong>:</p><ul><li>使用Python代码显式的创建loggers, handlers和formatters并分别调用它们的配置函数；</li><li>创建一个日志配置文件，然后使用fileConfig()函数来读取该文件的内容；</li><li>创建一个包含配置信息的dict，然后把它传递个dictConfig()函数；</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6885182.html" target="_blank" rel="noopener">《python之配置日志的几种方式》</a></p><hr><p><br></p><h2 id="向日志输出中添加上下文信息"><a href="#向日志输出中添加上下文信息" class="headerlink" title="向日志输出中添加上下文信息"></a>向日志输出中添加上下文信息</h2><p>除了传递给日志记录函数的参数外，有时候我们还想在<strong>日志输出中包含一些额外的上下文信息</strong>。比如，在一个网络应用中，可能希望在日志中记录客户端的特定信息，如：远程客户端的IP地址和用户名。这里我们来介绍以下几种实现方式：</p><ul><li>通过向日志记录函数传递一个<code>extra</code>参数引入上下文信息</li><li>使用<code>LoggerAdapters</code>引入上下文信息</li><li>使用<code>Filters</code>引入上下文信息</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6897964.html" target="_blank" rel="noopener">《Python之向日志输出中添加上下文信息》</a></p><hr><p><br></p><h2 id="实战技巧"><a href="#实战技巧" class="headerlink" title="实战技巧"></a>实战技巧</h2><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p><code>FileHandler</code> 创建对象时可以设置文件编码，如果将<strong>文件编码设置为 <code>utf-8</code>（utf-8 和 utf8 等价）</strong>，就可以解决中文乱码问题啦。</p><ul><li>一种方法是<strong>自定义 Logger 对象</strong>，需要写很多配置</li><li>另一种方法是<strong>使用默认配置方法 <code>basicConfig()</code>，传入 handlers 处理器列表对象</strong>，在其中的 handler 设置文件的编码</li></ul><p>关键参考代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义 Logger 配置</span></span><br><span class="line">handler = logging.FileHandler(filename=<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用默认的 Logger 配置，传入handlers时设置编码方式</span></span><br><span class="line">logging.basicConfig(handlers=[logging.FileHandler(<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)], level=logging.DEBUG)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="临时禁用日志输出"><a href="#临时禁用日志输出" class="headerlink" title="临时禁用日志输出"></a>临时禁用日志输出</h3><p>有时候我们又不想让日志输出，但在这后又想输出日志。</p><ul><li>一种方法是在<strong>使用默认配置时</strong>，给 <code>logging.disabled()</code> 方法<strong>传入禁用的日志级别</strong>，就可以禁止设置级别以下的日志输出了</li><li>另一种方法时在<strong>自定义 Logger 时</strong>，<strong>Logger 对象的 disable 属性设为 True，默认值是 False，也即不禁用</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认配置</span></span><br><span class="line">logging.disable(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的Logger</span></span><br><span class="line">logger.disabled = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割日志文件"><a href="#分割日志文件" class="headerlink" title="分割日志文件"></a>分割日志文件</h3><p><code>logging.handlers</code>文件中提供了<code>TimedRotatingFileHandler</code>和<code>RotatingFileHandler</code>类分别可以实现<strong>按时间</strong>和<strong>大小</strong>划分:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1000 Byte 划分一个日志文件，备份文件为 3 个</span></span><br><span class="line">file_handler = logging.handlers.RotatingFileHandler(<span class="string">"test.log"</span>, mode=<span class="string">"w"</span>, maxBytes=<span class="number">1000</span>, backupCount=<span class="number">3</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1小时 划分一个日志文件，interval 是时间间隔，备份文件为 10 个</span></span><br><span class="line">handler2 = logging.handlers.TimedRotatingFileHandler(<span class="string">"test.log"</span>, when=<span class="string">"H"</span>, interval=<span class="number">1</span>, backupCount=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>这个在前面的使用四大组件记录日志的示例中也有提及。</p><hr><p><br></p><h2 id="补充信息"><a href="#补充信息" class="headerlink" title="补充信息"></a>补充信息</h2><h3 id="datefmt支持的时间格式"><a href="#datefmt支持的时间格式" class="headerlink" title="datefmt支持的时间格式"></a>datefmt支持的时间格式</h3><table><tr><th width="20%">格式</th><th width="80%">含义</th></tr><tr><td><code>%a</code></td><td>本地（locale）简化星期名称</td></tr><tr><td><code>%A</code></td><td>本地完整星期名称</td></tr><tr><td><code>%b</code></td><td>本地简化月份名称</td></tr><tr><td><code>%B</code></td><td>本地完整月份名称</td></tr><tr><td><code>%c</code></td><td>本地相应的日期和时间表示</td></tr><tr><td><code>%d</code></td><td>一个月中的第几天（01 - 31）</td></tr><tr><td><code>%H</code></td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td><code>%I</code></td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td><code>%j</code></td><td>一年中的第几天（001 - 366）</td></tr><tr><td><code>%m</code></td><td>月份（01 - 12）</td></tr><tr><td><code>%M</code></td><td>分钟数（00 - 59）</td></tr><tr><td><code>%p</code></td><td>本地am或者pm的相应符</td></tr><tr><td><code>%S</code></td><td>秒（01 - 61）</td></tr><tr><td><code>%U</code></td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td></tr><tr><td><code>%w</code></td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td><code>%W</code></td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td><code>%x</code></td><td>本地相应日期</td></tr><tr><td><code>%X</code></td><td>本地相应时间</td></tr><tr><td><code>%y</code></td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td><code>%Y</code></td><td>完整的年份</td></tr><tr><td><code>%Z</code></td><td>时区的名字（如果不存在为空字符）</td></tr><tr><td><code>%%</code></td><td>‘%’字符</td></tr></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3.5/howto/logging.html" target="_blank" rel="noopener">Logging HOWTO-官方细致教程</a></li><li><a href="https://docs.python.org/3.5/howto/logging-cookbook.html" target="_blank" rel="noopener">Logging Cookbook-官方实例</a></li><li><a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">官方链接</a></li><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li><li><a href="http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html" target="_blank" rel="noopener">python 的日志logging模块学习</a></li><li><a href="https://blog.csdn.net/fxjtoday/article/details/6307285" target="_blank" rel="noopener">项目中比较需要用到的</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章依照&lt;a href=&quot;https://www.cnblogs.com/yyds/p/6901864.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇博客&lt;/a&gt;对Python的常用模块logging进行了学习，主要学习了&lt;code&gt;日志的作用&lt;/code&gt;、&lt;code&gt;不同开发环境设置不同的日志输出&lt;/code&gt;、&lt;code&gt;使用logging模块的日志级别函数直接记录日志&lt;/code&gt;；也学习了logging模块的&lt;strong&gt;高级用法&lt;/strong&gt;，包括&lt;strong&gt;使用logging模块的四大组件进行日志记录(主要用于满足多种需求，如将结果同时输出到文件和屏幕)&lt;/strong&gt;、配置logging的几种方式、向日志输出上下文信息等；最后也总结了一些&lt;strong&gt;实战技巧&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>cat-显示、读取或拼接文件内容</title>
    <link href="http://showteeth.tech/posts/24399.html"/>
    <id>http://showteeth.tech/posts/24399.html</id>
    <published>2019-03-22T12:00:42.000Z</published>
    <updated>2019-03-22T12:20:12.365Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用Linux的<code>cat</code>命令来执行文件的查看、合并和创建功能。在查看文件方面包括的参数有：<code>-n</code>、<code>-b</code>、<code>-s</code>、<code>-E</code>、<code>-T</code>；在合并文件方面学习了<strong>结合输出重定向以及前面的查看功能的参数进行合并</strong>；在创建文件方面主要有三个命令：<code>cat &gt;filename</code>、<code>cat &lt;&lt; EOF</code>和<code>cat &gt; filename &lt;&lt; EOF</code>。</p></div><a id="more"></a><h2 id="cat简介"><a href="#cat简介" class="headerlink" title="cat简介"></a>cat简介</h2><p><code>cat</code> 是一个文本文件(查看)和(连接)工具，通常是用于查看某个文件的内容，其主要有三大功能：</p><ul><li><strong>显示整个文件</strong>内容</li><li>将几个文件<strong>合并</strong>为一个文件</li><li><strong>从键盘创建一个文件</strong></li></ul><hr><p><br></p><h2 id="cat命令用法"><a href="#cat命令用法" class="headerlink" title="cat命令用法"></a>cat命令用法</h2><h3 id="cat命令格式"><a href="#cat命令格式" class="headerlink" title="cat命令格式"></a>cat命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cat [OPTION]... [FILE]...</span><br><span class="line">Description:</span><br><span class="line">  Concatenate FILE(s), or standard input, to standard output.</span><br></pre></td></tr></table></figure><hr><h3 id="cat-options说明"><a href="#cat-options说明" class="headerlink" title="cat options说明"></a>cat options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-n</strong></td><td>–number</td><td><strong>由1开始对所有输出的行数编号</strong></td></tr><tr><td><strong>-b</strong></td><td>–number-nonblank</td><td><strong>和-n相似，只不过对于空白行不编号</strong></td></tr><tr><td><strong>-s</strong></td><td>–squeeze-blank</td><td><strong>当遇到有连续两行以上的空白行，只输出一行的空白行</strong></td></tr><tr><td>-E</td><td>–show-ends</td><td>在每行结束处显示<code>$</code></td></tr><tr><td>-v</td><td>–show-nonprinting</td><td>使用<code>^</code>和<code>M-</code>符号，除了<code>LFD</code>和<code>TAB</code>之外</td></tr><tr><td>-T</td><td>–show-tabs</td><td>将<code>TAB</code>字符显示为<code>^I</code></td></tr><tr><td>-A</td><td>–show-all</td><td>等价于 <code>-vET</code></td></tr><tr><td>-e</td><td></td><td>等价于<code>-vE</code>选项</td></tr><tr><td>-t</td><td></td><td>等价于<code>-vT</code>选项</td></tr></tbody></table><hr><p><br></p><h2 id="cat用法实例"><a href="#cat用法实例" class="headerlink" title="cat用法实例"></a>cat用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>a<br>b 1</p><p>\====</p></blockquote><blockquote><p><code>cat test2.txt</code><br>c<br>d<br>\==</p></blockquote><hr><h3 id="查看文件功能"><a href="#查看文件功能" class="headerlink" title="查看文件功能"></a>查看文件功能</h3><h4 id="n-对所有行编号"><a href="#n-对所有行编号" class="headerlink" title="-n-对所有行编号"></a>-n-对所有行编号</h4><p><strong>所有行包含空白行</strong>：</p><blockquote><p><code>cat -n test1.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====</p></blockquote><hr><h4 id="b-对除空白行之外的行进行编号"><a href="#b-对除空白行之外的行进行编号" class="headerlink" title="-b-对除空白行之外的行进行编号"></a>-b-对除空白行之外的行进行编号</h4><blockquote><p><code>cat -b test1.txt</code><br>1 a<br>2 b 1</p><pre><code>3     ====  </code></pre></blockquote><p><strong>需要和上面的<code>-n</code>参数进行区分</strong></p><hr><h4 id="s-只输出连续多行空白行的其中一行"><a href="#s-只输出连续多行空白行的其中一行" class="headerlink" title="-s-只输出连续多行空白行的其中一行"></a>-s-只输出连续多行空白行的其中一行</h4><p><strong>结合前面的<code>-n</code>参数</strong>：</p><blockquote><p><code>cat -sn test1.txt</code><br>1 a<br>2 b 1<br>3<br>4 ====</p></blockquote><p>可以发现只输出了连续两行空白行中的一个，并进行编号，说明是先输出一个，然后编号的，不是先编号再输出其中一行</p><hr><h4 id="E-在每行结束处显示"><a href="#E-在每行结束处显示" class="headerlink" title="-E-在每行结束处显示$"></a>-E-在每行结束处显示$</h4><blockquote><p><code>cat -E test1.txt</code><br>a <strong>\$</strong><br>b 1<strong>\$</strong><br><strong>\$</strong><br><strong>\$</strong><br>====<strong>\$</strong></p></blockquote><hr><h4 id="T-将TAB字符显示为-I"><a href="#T-将TAB字符显示为-I" class="headerlink" title="-T-将TAB字符显示为^I"></a>-T-将TAB字符显示为^I</h4><blockquote><p>cat -nT test1.txt<br>1 a<br>2 b <strong>^I</strong>1<br>3<br>4<br>5 ====</p></blockquote><hr><p><br></p><h3 id="合并文件功能"><a href="#合并文件功能" class="headerlink" title="合并文件功能"></a>合并文件功能</h3><p>将<code>test1.txt</code>和<code>test2.txt</code>合并后重定向到<code>test3.txt</code>中：</p><blockquote><p><code>cat test1.txt test2.txt &gt;test3.txt</code><br><code>cat test3.txt</code><br>a<br>b 1</p><p>\====<br>c<br>d<br>\==</p></blockquote><p><strong>可以结合前面查看文件的参数</strong>：</p><blockquote><p><code>cat -n test1.txt test2.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====<br>6 c<br>7 d<br>8 ==</p></blockquote><div class="note info"><ul><li><strong>后面不接文件的话会输出到标准输出</strong></li><li>文件内容是<strong>按照文件顺序连接起来的</strong></li><li><strong>编号是连续的</strong>，不是每个文件单独的编号</li></ul></div><hr><p><br></p><h3 id="创建文件相关功能"><a href="#创建文件相关功能" class="headerlink" title="创建文件相关功能"></a>创建文件相关功能</h3><p>这一部分主要有三个比较重要和常见的命令：</p><ul><li><code>cat &lt;&lt; EOF</code></li><li><code>cat &gt; filename</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code></li></ul><h4 id="cat-lt-lt-EOF"><a href="#cat-lt-lt-EOF" class="headerlink" title="`cat &lt;&lt; EOF"></a>`cat &lt;&lt; EOF</h4><p><strong>以<code>EOF</code>输入字符为标准输入结束</strong>，这里的<strong>EOF并不是固定</strong>的(<code>EOF是end of file</code>，表示文本结束符，使用有含义的字符可能更容易记住用法)，可以设置为<code>mmm</code>等其他自定义的字符，示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF </span><br><span class="line">&gt; ad    <span class="comment"># 开始从标准输入读取</span></span><br><span class="line">&gt; adad</span><br><span class="line">&gt; EOF <span class="comment"># 遇到了标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad    <span class="comment"># 直接输出</span></span><br><span class="line">adad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换标准输入结束字符</span></span><br><span class="line">cat &lt;&lt; mmm</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; mmm   <span class="comment"># 遇到了上面定义的标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad</span><br><span class="line">ad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>这一部分输入输入和输出重定向部分，还可以参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h4 id="cat-gt-filename"><a href="#cat-gt-filename" class="headerlink" title="cat &gt; filename"></a><code>cat &gt; filename</code></h4><p><strong>创建文件</strong>，并<strong>把标准输入输出到filename文件</strong>中，<strong>以<code>ctrl+d</code>作为输入结束</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并写入</span></span><br><span class="line">cat &gt; filename</span><br><span class="line">ad</span><br><span class="line">adad   <span class="comment"># 这一行输入完成之后按下快捷键ctrl+d结束输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat filename </span><br><span class="line">ad</span><br><span class="line">adad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>cat &gt; filename</code>命令和上面的<code>cat &lt;&lt; EOF</code>不同之处在于：</p><ul><li><code>cat &lt;&lt; EOF</code>不会创建文件，而<code>cat &gt; filename</code>会创建文件</li><li><code>cat &lt;&lt; EOF</code>可以自定义结束的字符，而<code>cat &gt; filename</code>则是使用快捷键<code>ctrl+d</code>作为输入结束</li><li><code>cat &lt;&lt; EOF</code>输入的时候有<code>&gt;</code>提示输入，而<code>cat &gt; filename</code>没有任何提示输入的此内容</li></ul></div><hr><h4 id="cat-gt-filename-lt-lt-EOF"><a href="#cat-gt-filename-lt-lt-EOF" class="headerlink" title="cat &gt; filename &lt;&lt; EOF"></a><code>cat &gt; filename &lt;&lt; EOF</code></h4><p>这个是上面两个的合并版，<strong>既可以创建文件</strong>，<strong>又可以自定义停止输入字符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并设置停止输入字符</span></span><br><span class="line">cat &gt; test4.txt &lt;&lt; EOF</span><br><span class="line">&gt; a</span><br><span class="line">&gt; b</span><br><span class="line">&gt; c</span><br><span class="line">&gt; d</span><br><span class="line">&gt; EOF   <span class="comment"># 遇到了标准输入结束字符，结束标准输入，但是不会直接输入，因为内容已经重定向到test4.txt中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test4.txt文件内容，是刚刚输入的内容</span></span><br><span class="line">cat test4.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p></p><ul><li>上面的创建文件也<strong>可以改为追加文件</strong>：<code>cat &gt;&gt; test4.txt &lt;&lt; EOF</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code>书写的前后顺序可以调换，比如可写成：<code>cat &lt;&lt; EOF &gt; filename</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cat" target="_blank" rel="noopener">cat命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-cat.html" target="_blank" rel="noopener">Linux cat命令</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/7717602.html" target="_blank" rel="noopener">Linux cat命令详解</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5856106.html" target="_blank" rel="noopener">Linux中cat、more、less、tail、head命令的区别</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了使用Linux的&lt;code&gt;cat&lt;/code&gt;命令来执行文件的查看、合并和创建功能。在查看文件方面包括的参数有：&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-E&lt;/code&gt;、&lt;code&gt;-T&lt;/code&gt;；在合并文件方面学习了&lt;strong&gt;结合输出重定向以及前面的查看功能的参数进行合并&lt;/strong&gt;；在创建文件方面主要有三个命令：&lt;code&gt;cat &amp;gt;filename&lt;/code&gt;、&lt;code&gt;cat &amp;lt;&amp;lt; EOF&lt;/code&gt;和&lt;code&gt;cat &amp;gt; filename &amp;lt;&amp;lt; EOF&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Git系列-Git实战总结</title>
    <link href="http://showteeth.tech/posts/5778.html"/>
    <id>http://showteeth.tech/posts/5778.html</id>
    <published>2019-03-22T07:25:26.000Z</published>
    <updated>2019-03-22T08:48:43.663Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在使用Git中遇到的比较使用的技巧和问题解决方案，便于后续查询和使用。</p></div><a id="more"></a><h2 id="gitignore文件不起作用以及文件规则"><a href="#gitignore文件不起作用以及文件规则" class="headerlink" title=".gitignore文件不起作用以及文件规则"></a>.gitignore文件不起作用以及文件规则</h2><h3 id="文件书写规则"><a href="#文件书写规则" class="headerlink" title="文件书写规则"></a>文件书写规则</h3><p>在使用Git管理代码的过程中，可以修改<code>.gitignore</code>文件中的标示的方法来<strong>忽略开发者想忽略掉的文件或目录(实际项目中，很多文件都是不需要版本管理的)</strong>，如果没有<code>.gitignore</code>文件，可以自己手工创建。在<code>.gitignore</code>文件中的每一行保存一个匹配的规则例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"> </span><br><span class="line">*.a       <span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">!lib.a    <span class="comment"># 但 lib.a 除外</span></span><br><span class="line">/TODO     <span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line">build/    <span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">doc/*.txt <span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure><p></p><p>需要强调的一点是，如果你不慎在创建<code>.gitignore</code>文件之前就push了项目，那么即使你在<code>.gitignore</code>文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说，出现这种问题的原因就是<strong>Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们</strong>。所以大家一定要<strong>养成在项目开始就创建<code>.gitignore</code>文件的习惯，否则一旦push，处理起来会非常麻烦。</strong></p><hr><h3 id="清除本地缓存"><a href="#清除本地缓存" class="headerlink" title="清除本地缓存"></a>清除本地缓存</h3><p>如果一不小心在创建<code>.gitignore</code>文件之前就使用了<code>git push</code>，这样可能会使得<code>.gitignore</code>的忽略规则失效，这是因为新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在<code>.gitignore</code>中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行<code>git push</code>，这样就不会出现忽略的文件了。git清除本地缓存命令如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line">git rm -r --cached .</span><br><span class="line"><span class="comment"># 将所有文件改变上传到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 将暂存区的所有内容提交到当前分支上</span></span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="git-push-u-VS-git-push"><a href="#git-push-u-VS-git-push" class="headerlink" title="git push -u VS git push"></a>git push -u VS git push</h2><p><code>git push</code>的用法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与多个主机存在追踪关系(连接)，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用：</span></span><br><span class="line"><span class="comment"># 先使用带-u参数的git push</span></span><br><span class="line">git push -u origin master </span><br><span class="line"><span class="comment"># 后续的git push可以省略参数</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将已有的文件夹上传到github"><a href="#将已有的文件夹上传到github" class="headerlink" title="将已有的文件夹上传到github"></a>将已有的文件夹上传到github</h2><p>背景：可能有些时候并没有在文件夹创建之初没有考虑到上传到Github的情况，所以就需要将已有的文件夹上传到Github，但是又不希望先建立空的repo，然后clone下来将文件复制进去，然后就有了下面的方法：</p><ul><li>在bash下<strong>进入需要上传的文件夹</strong>：<code>cd dir</code></li><li><strong>初始化产生版本库</strong>：<code>git init</code></li><li>将所有文件<strong>添加到暂存区</strong>：<code>git add .</code></li><li>提交文件：<code>git commit -m &quot;message&quot;</code></li><li>添加远程仓库：<code>git remote add origin git@github.com:showteeth/orth_blast_docker.git</code></li><li>上传本地代码：<code>git push -u origin master</code></li><li>后续上传：<ul><li><code>git add .</code></li><li><code>git commit -m &quot;message&quot;</code></li><li><code>git push origin master</code>或者<code>git push</code></li></ul></li></ul><p>在使用<code>git push -u origin master</code>上传本地代码时，如果报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.com:showteeth/orth_blast_docker.git'</span></span><br></pre></td></tr></table></figure><p></p><ul><li>按照这个<a href="https://github.com/rtyley/bfg-repo-cleaner/issues/29" target="_blank" rel="noopener">issue</a>的说法，可以试试<code>git push -u origin master --force</code></li><li>或者按照<a href="https://blog.csdn.net/pql925/article/details/72772660" target="_blank" rel="noopener">这篇文章</a>的做法：<ul><li>合并代码：<code>git pull origin master</code>或者<code>git pull --rebase origin master</code>(<mark>文章中使用的这个，但我感觉是不是应该使用前面的，下次可以先试试前面的可不可以</mark>)</li><li>上传代码：<code>git push -u origin master</code></li></ul></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录了在使用Git中遇到的比较使用的技巧和问题解决方案，便于后续查询和使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列-Dockerfile</title>
    <link href="http://showteeth.tech/posts/31987.html"/>
    <id>http://showteeth.tech/posts/31987.html</id>
    <published>2019-03-21T13:18:13.000Z</published>
    <updated>2019-03-22T04:02:58.362Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/leveldc/article/details/85492558#_1" target="_blank" rel="noopener">Dockerfile详解</a></li><li><a href="https://www.cnblogs.com/lighten/p/6900556.html" target="_blank" rel="noopener">docker学习(3)–Dockfile详解</a></li><li><a href="https://www.centos.bz/2016/12/dockerfile-cmd-instruction/" target="_blank" rel="noopener">Dockerfile参考(8) – CMD设置运行容器时执行的命令</a></li><li><a href="https://www.jianshu.com/p/78f4591b7ff0" target="_blank" rel="noopener">Docker CMD</a></li><li><a href="https://www.cnblogs.com/51kata/p/5264894.html" target="_blank" rel="noopener">docker学习笔记16：Dockerfile 指令 ADD 和 COPY介绍</a></li><li><a href="https://www.cnblogs.com/lienhua34/p/5170335.html" target="_blank" rel="noopener">Dockerfile创建自定义Docker镜像以及CMD与ENTRYPOINT指令的比较</a></li><li><a href="http://www.dockone.io/article/1414" target="_blank" rel="noopener">九个编写Dockerfiles的常见错误</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Docker" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Docker/"/>
    
    
      <category term="Docker" scheme="http://showteeth.tech/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-构建第一个docker镜像</title>
    <link href="http://showteeth.tech/posts/371.html"/>
    <id>http://showteeth.tech/posts/371.html</id>
    <published>2019-03-21T08:54:20.000Z</published>
    <updated>2019-03-22T04:02:58.399Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是我的第一个Docker镜像，主要是依托项目是寻找两个基因之间的同源基因对。这篇文章主要记录了创建第一个镜像的过程，包括前期测试、编写Dockfile、查看镜像、运行镜像、修改镜像、退出、关闭、重启镜像、删除镜像以及后面的发布镜像、拉取镜像等操作，同时也记录了运行中的一些错误和解决办法。</p></div><a id="more"></a><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>docker 镜像是一个只读的 docker 容器模板，含有启动 docker 容器所需的文件系统结构及其内容(包括对资源需求、环境的要求、依赖的类库和运行的代码等等)，因此是启动一个 docker 容器的基础。</p><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile用于构建<strong>一致的Docker镜像</strong>，其定义了容器中的运行环境，包括像网络接口和虚拟化的磁盘驱动等硬件资源，这些资源是与宿主系统隔离开的，不会对系统有任何影响。使用Docker镜像运行Docker容器，可以让定义在该镜像中的应用程序<strong>无论在哪里运行，都有一致的功能</strong>。</p><h3 id="示例Dockerfile学习"><a href="#示例Dockerfile学习" class="headerlink" title="示例Dockerfile学习"></a>示例Dockerfile学习</h3><p>以下是官方的<code>Dockerfile</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方python镜像作为根镜像</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER <span class="string">"user_id&lt;email address&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /app 目录下</span></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外公开容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个环境变量world</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行 python app.py命令</span></span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="示例Dockerfile解读"><a href="#示例Dockerfile解读" class="headerlink" title="示例Dockerfile解读"></a>示例Dockerfile解读</h3><ul><li>FROM：FROM命令是<strong>必须的</strong>，<strong>可以是基于某个镜像</strong><ul><li><strong>从0开始构建</strong>：需要使用<code>scratch</code>，<code>scratch</code>代表着一个空白的镜像**，此时基本命令就是<code>FROM scratch</code>；</li><li>基于某个镜像：如上使用官方python镜像作为根镜像，所有的官方镜像可以在这个网站看到</li></ul></li><li>MAINTAINER：就是将维护人信息添加到脚本文件中，<strong>不一定需要，可有可无</strong></li><li>WORKDIR：定义工作目录</li><li><p>ADD：将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件拷贝到镜像中</p></li><li><p>RUN：用来执行基本命令的，基本格式有两种</p><ul><li>第一种是Shell格式：如上面安装包的命令以及<code>RUN npm install</code></li><li>第二种是exec格式：如<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ul></li></ul><p>由于<code>Dockerfile</code>每一个命令都会建立一层，RUN也不例外，在不必要的情况下使用多行RUN命令会使得镜像非常冗余和庞大，以下是一个示例:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p></p><p>类似上述例子，<strong>一共构建了7层镜像</strong>，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等，<strong>结果就是产生非常臃肿、非常 多层的镜像，不仅仅增加了构建部署的时间，也很容易出错</strong>。</p><p>正确写法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \ &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p></p><p>首先，之前所有的命令只有一个目的：编译、安装redis可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个RUN指令，并使用 <code>&amp;&amp;</code>将各个所需命令串联起来。将之前的7层，简化为了1层。其中每行命令后的 <code>\</code> 代表着换行，使dockerfile的RUN命令更具有可读性。</p><p>此外，命令的最后一行还有一个 <code>--auto-remove</code>命令，这个为<strong>清理工作</strong>的命令，<strong>删除了编译所需要的软件，清理下载以及展开的文件，并且还清理了apt缓存文件</strong>。由于镜像是一层一层构建的，每一层的多余东西并不会在下一层中被删除掉，到后面镜像会越来越大，因此<strong>清理这些没有用处的东西很有必要</strong>.</p><blockquote><p>RUN示例<a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">参考博客</a></p></blockquote><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile，其中安装Python所需要的依赖包时使用了文件进行安装，没有使用多行命令以及上述提及的使用<code>&amp;&amp;</code>的方法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p></p><p>示例的requirements.txt文件内容：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p></p><ul><li>EXPOSE：将指定的端口暴露出来，可以供外界访问，或者映射到宿主机的端口上去</li><li>CMD：容器启动命令，CMD命令和RUN命令相似，也是两种格式，分别为 <strong><code>shell</code>命令格式</strong>和 <strong><code>exec</code>命令格式</strong>。</li></ul><p>CMD 指令就是用于指定<strong>默认的容器主进程的启动命令的</strong>。在<code>exec</code>命令格式上，一般会被解析成json数组格式，<strong>需要用双引号，不能使用单引号!!!</strong></p><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile的CMD命令：<code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>，属于 <strong><code>exec</code>命令格式</strong>，<strong>注意使用的是双引号</strong>，意思是<strong>容器使用Python运行app.py文件</strong>，至于具体的app.py文件信息就不列举了。</p><div class="note info"><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">各个参数的官方解释</a></p></div><hr><h3 id="动手测试Dockerfile"><a href="#动手测试Dockerfile" class="headerlink" title="动手测试Dockerfile"></a>动手测试Dockerfile</h3><p>基于上面对示例Dockerfile的学习，接下来自己建立自己的Dockerfile</p><h4 id="建立centos的测试"><a href="#建立centos的测试" class="headerlink" title="建立centos的测试"></a>建立centos的测试</h4><p>Dockerfile内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos7</span></span><br><span class="line">FROM centos:7</span><br><span class="line"><span class="comment"># 维护人信息</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"><span class="comment"># 看看是否安装了python以及版本</span></span><br><span class="line">CMD python -v</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="创建docker镜像"><a href="#创建docker镜像" class="headerlink" title="创建docker镜像"></a>创建docker镜像</h4><p>基于上述Dockerfile使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>建立镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker build -f .\Dockerfile  -t centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line"><span class="comment"># 第一步对应于第一行</span></span><br><span class="line">Step 1/4 : FROM centos:7</span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">8ba884070f61: Pull complete</span><br><span class="line">Digest: sha256:ca58fe458b8d94bc6e3072f1cfbd334855858e05e1fd633aa07cf7f82b048e66</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:7</span><br><span class="line"> ---&gt; 9f38484d220f</span><br><span class="line"><span class="comment"># 第二步对应于第二行</span></span><br><span class="line">Step 2/4 : MAINTAINER showteeth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 75f880e1b2d9</span><br><span class="line">Removing intermediate container 75f880e1b2d9</span><br><span class="line"> ---&gt; 9ea90a7b7832</span><br><span class="line"><span class="comment"># 第三步对应于第三行</span></span><br><span class="line">Step 3/4 : WORKDIR /orth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 2c117f20ad92</span><br><span class="line">Removing intermediate container 2c117f20ad92</span><br><span class="line"> ---&gt; 07e0e346b57d</span><br><span class="line"><span class="comment"># 第四步对应于第四行 </span></span><br><span class="line">Step 4/4 : CMD python -v</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 297b155a52be</span><br><span class="line">Removing intermediate container 297b155a52be</span><br><span class="line"> ---&gt; 1f29d9e70fac</span><br><span class="line">Successfully built 1f29d9e70fac</span><br><span class="line">Successfully tagged centos:1.0</span><br><span class="line">SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have <span class="string">'-rwxr-xr-x'</span> permissions. It is recommended to double check and reset permissions <span class="keyword">for</span> sensitive files and directories.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>创建完成之后使用命令<code>docker images</code>查看镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里信息和build命令以及输出信息的对应</span></span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                     1.0                 1f29d9e70fac        8 minutes ago       202MB</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>使用<code>docker run -it centos:1.0</code>运行镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/aliases.pyc matches /usr/lib64/python2.7/encodings/aliases.py</span></span><br><span class="line">import encodings.aliases <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/aliases.pyc</span></span><br><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/ascii.pyc matches /usr/lib64/python2.7/encodings/ascii.py</span></span><br><span class="line">import encodings.ascii <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/ascii.pyc</span></span><br><span class="line">Python 2.7.5 (default, Oct 30 2018, 23:45:53)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">dlopen(<span class="string">"/usr/lib64/python2.7/lib-dynload/readline.so"</span>, 2);</span><br><span class="line">import readline <span class="comment"># dynamically loaded from /usr/lib64/python2.7/lib-dynload/readline.so</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p></p><p><strong>如上，运行之后自动运行了<code>python -v</code>，因为前面的Dockerfile的<code>CMD</code>写的就是这个命令</strong>，如果没有Python，可以参考这个链接来<a href="https://www.centos.bz/2018/01/%E5%9C%A8centos%E4%B8%8A%E5%AE%89%E8%A3%85python3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">安装Python</a></p><hr><h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h4><p>由于开始的时候设置了<code>CMD python -v</code>，导致镜像运行之后自动进入Python程序，退出Python之后也退出了整个docker环境，所以想知道可不可以修改CMD命令，查询<a href="https://serverfault.com/questions/594281/how-can-i-override-cmd-when-running-a-docker-image" target="_blank" rel="noopener">相关文档</a>之后，可以使用如下进行修改：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --entrypoint=/bin/bash <span class="variable">$IMAGE</span> -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如我可以使用如下命令进入bash shell的交互环境</span></span><br><span class="line">docker run -it --entrypoint=/bin/bash centos:1.0 -i</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="退出、关闭、重启镜像"><a href="#退出、关闭、重启镜像" class="headerlink" title="退出、关闭、重启镜像"></a>退出、关闭、重启镜像</h4><ul><li>使用命令<code>exit</code>来<strong>退出</strong>正在使用的镜像，注意退出之后并没有关闭，后台还在运行，使用<code>docker ps -a</code>可看到</li><li>使用<code>docker stop image_id|name</code>来关闭镜像</li></ul><hr><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>测试版本镜像和真正想要使用的镜像有很大差距，所以打算直接删掉重新创建一个镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有的container，这样才能够删除其中的images：</span></span><br><span class="line">docker stop $(docker ps -a -q)   <span class="comment"># Linux下可以这么使用，windows还是单个单个操作吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要删除 所有container 的话再加一个指令：</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前有些什么images</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除images，通过image的 id 来指定删除谁，注意和上面的删除容器相区分</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print <span class="variable">$3</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除 全部 image的话</span></span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：运行docker时docker desktop必须也在运行，而且不要关闭，一旦关闭，正在运行的container会直接退出</p></div><hr><h3 id="编写Dockfile"><a href="#编写Dockfile" class="headerlink" title="编写Dockfile"></a>编写Dockfile</h3><h4 id="准备文件信息"><a href="#准备文件信息" class="headerlink" title="准备文件信息"></a>准备文件信息</h4><ul><li>blast软件包</li><li>python相关运行文件</li><li>初始文件(fasta文件)</li><li>相关的脚本</li></ul><hr><h4 id="正式的Dockerfile"><a href="#正式的Dockerfile" class="headerlink" title="正式的Dockerfile"></a>正式的Dockerfile</h4><p>经过上述所有的学习和尝试，这里给出了最终可以运行的Dockerfile：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos镜像</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /orth</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /orth 目录下</span></span><br><span class="line">ADD . /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN yum -y install epel-release \</span><br><span class="line">&amp;&amp; yum -y install python-pip \ </span><br><span class="line">&amp;&amp; yum -y install vim \</span><br><span class="line">&amp;&amp; pip install -r requirements.txt \</span><br><span class="line">&amp;&amp; chmod 744 /orth/scripts/docker_blast.sh \</span><br><span class="line">&amp;&amp; tar -zxvf /orth/ncbi-blast-2.8.1+-x64-linux.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将blast加入环境变量</span></span><br><span class="line">ENV PATH /orth/ncbi-blast-2.8.1+/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行命令</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p></p><p>上面使用ADD没有执行自动解压操作，后续添加了自动解压操作，这个是官方的一个<a href="https://github.com/docker/docker-ce/releases/tag/v17.06.0-ce" target="_blank" rel="noopener">issue</a>，后续版本会改进。</p><hr><h4 id="创建和运行镜像"><a href="#创建和运行镜像" class="headerlink" title="创建和运行镜像"></a>创建和运行镜像</h4><ul><li>创建镜像：<code>docker build -f .\Dockerfile -t orth_project:2.0 .</code></li><li>运行镜像：<code>docker run -it orth_project:2.0</code></li><li>在镜像中使用<code>bash /orth/scripts/docker_blast.sh</code>运行查找同源基因的程序</li></ul><hr><p><br></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>主要步骤如下：</p><ul><li>第一步：开通<a href="https://cr.console.aliyun.com/new/new" target="_blank" rel="noopener">阿里云镜像服务</a></li><li>第二步：创建镜像仓库</li><li>第三步：推送镜像</li><li>第四步：查找验证镜像</li></ul><p>首先是开通阿里云镜像服务：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/开通阿里云镜像服务" alt="开通阿里云镜像服务"></p><hr><p>接下来创建镜像仓库：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库.png" alt="创建镜像仓库"><br><strong>仓库类型选择公开</strong><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库_2.png" alt="创建镜像仓库_2.png"><br><strong>代码源选择本地仓库</strong></p><hr><p>创建完成镜像仓库后，点击刚刚创建的镜像的管理，发现如下信息：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/推送镜像.png" alt="推送镜像.png"><br>然后，就可以按照上述图片中的提示完成镜像的推送，下面也列出了镜像推送的命令：</p><ul><li><code>docker login --username=username registry.cn-beijing.aliyuncs.com</code>输入这一步需要验证密码，验证成功会显示<code>Login Succeeded</code></li><li><code>docker tag [ImageId] registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这一步前面的<code>[ImageId]</code>使用<code>docker images</code>查看，<code>[镜像版本号]</code>是你上传上去想要显示的版本号，运行完成没有输出信息</li><li><code>docker push registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这里的<code>[镜像版本号]</code>是你上传上去想要显示的版本号，和上一步的保持一致，这一步完成会显示如下信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The push refers to repository [registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project]</span><br><span class="line">788a64a2f222: Pushed</span><br><span class="line">f652370971d2: Pushed</span><br><span class="line">d245b64a20a7: Pushed</span><br><span class="line">d69483a6face: Pushed</span><br><span class="line">1.0: digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7 size: 1161</span><br></pre></td></tr></table></figure></li></ul><div class="note info"><p>上传完成镜像后，本地也会出现一个名为<code>registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project</code>的镜像(<strong>该镜像具有和原始镜像相同的iamge id</strong>)，可以删除，通过命令<code>docker rmi -f registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</code>删除</p></div><hr><p>最后是查找验证镜像，经过上面几步已经成功将镜像上传到阿里云，接下来到阿里云中搜索自己刚刚上传的镜像：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索.png" alt="镜像搜索.png"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索结果.png" alt="镜像搜索结果.png"></p><hr><p><br></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>在上述查询到镜像结果之后，点击<strong>查看镜像的详细信息</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像的详细信息.png" alt="镜像的详细信息.png"></p><p><strong>复制公网地址</strong>并<strong>使用如下命令拉取镜像</strong>：<code>docker pull registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code></p><div class="note info"><p><strong>注意这个<code>[镜像版本号]</code>一定要指定，因为可能会存在很多版本号，这里指定后会拉取指定版本</strong></p></div><p>运行完成之后输出如下信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0: Pulling from showteeth/orth_blast_project</span><br><span class="line">Digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="build-with-gRPC-error"><a href="#build-with-gRPC-error" class="headerlink" title="build with gRPC error"></a>build with gRPC error</h3><p>使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[0000] failed to dial gRPC: cannot connect to the Docker daemon. Is <span class="string">'docker daemon'</span> running on this host?: open //./pipe/docker_engine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure><p></p><p><strong>解决办法</strong>：<br>在Github上看到了类似的<a href="https://github.com/docker-library/docker/issues/71" target="_blank" rel="noopener">issue</a>，主要的解决方法是在docker的设置中开启experimental features，如下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/experimental_features" alt="experimental_features"></p><p><strong>开启完成之后就解决了问题</strong></p><hr><h3 id="docker-image-is-being-used"><a href="#docker-image-is-being-used" class="headerlink" title="docker image is being used"></a>docker image is being used</h3><p>在使用<code>docker rmi 20ffdd2f28c0</code>删除镜像是发现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: conflict: unable to delete 20ffdd2f28c0 (must be forced) - image is being used by stopped container 7356c1e7efc0</span><br></pre></td></tr></table></figure><p></p><p><strong>解决方法：</strong></p><ul><li><p>先删除上面提示的那个占用当前镜像的<code>7356c1e7efc0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm  7356c1e7efc0</span><br></pre></td></tr></table></figure></li><li><p>然后再使用命令<code>docker rmi 20ffdd2f28c0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 20ffdd2f28c0</span><br></pre></td></tr></table></figure></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">Docker工作基本流程</a></li><li><a href="https://yq.aliyun.com/articles/596352" target="_blank" rel="noopener">Docker初体验，向Docker Hub推送第一个Docker镜像</a></li><li><a href="https://blog.csdn.net/qq_34680763/article/details/79711567" target="_blank" rel="noopener">第一次构建、运行、发布、获取docker镜像</a></li><li><a href="https://www.jianshu.com/p/4971967f7d3c" target="_blank" rel="noopener">Docker入门（二）创建您的第一个Docker镜像</a></li><li><a href="http://dockone.io/article/783" target="_blank" rel="noopener">10张图带你深入理解Docker容器和镜像</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是我的第一个Docker镜像，主要是依托项目是寻找两个基因之间的同源基因对。这篇文章主要记录了创建第一个镜像的过程，包括前期测试、编写Dockfile、查看镜像、运行镜像、修改镜像、退出、关闭、重启镜像、删除镜像以及后面的发布镜像、拉取镜像等操作，同时也记录了运行中的一些错误和解决办法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Docker" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Docker/"/>
    
    
      <category term="Docker" scheme="http://showteeth.tech/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python-博客转载项目</title>
    <link href="http://showteeth.tech/posts/26003.html"/>
    <id>http://showteeth.tech/posts/26003.html</id>
    <published>2019-03-21T08:14:20.000Z</published>
    <updated>2019-03-22T04:02:58.374Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h2><ul><li style="list-style:none"><input type="checkbox" checked> 启动这个项目 2019-3-21</li><li style="list-style:none"><input type="checkbox"> 印象笔记转载-API</li><li style="list-style:none"><input type="checkbox"> 博客园</li><li style="list-style:none"><input type="checkbox"> CSDN</li><li style="list-style:none"><input type="checkbox"> 其他自建博客</li><li style="list-style:none"><input type="checkbox"> 自定义内容</li></ul><h2 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h2><ul><li><a href="https://dev.yinxiang.com/doc/" target="_blank" rel="noopener">印象笔记开发者文档</a></li><li><a href="https://dev.yinxiang.com/doc/start/python.php" target="_blank" rel="noopener">印象笔记 Python SDK 快速入门指南</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="项目实战" scheme="http://showteeth.tech/categories/Python/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="实战" scheme="http://showteeth.tech/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>sublime text3使用以及配置</title>
    <link href="http://showteeth.tech/posts/53131.html"/>
    <id>http://showteeth.tech/posts/53131.html</id>
    <published>2019-03-21T07:19:50.000Z</published>
    <updated>2019-03-22T04:02:58.385Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在学习和使用sublime text编辑器过程中对其进行的配置和优化，包括一些插件的用法，便于后续使用和查询</p></div><a id="more"></a><h2 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h2><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="显示目录插件"><a href="#显示目录插件" class="headerlink" title="显示目录插件"></a>显示目录插件</h3><p>使用的是<strong>插件</strong>：<a href="https://github.com/warmdev/SublimeOutline" target="_blank" rel="noopener">SublimeOutline</a></p><p><strong>显示效果</strong>：</p><p><br><a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/warmdev/SublimeOutline/master/screenshot.png"><img src="https://raw.githubusercontent.com/warmdev/SublimeOutline/master/screenshot.png" alt="Screenshot" title="Screenshot" style="max-width:100%"></a><br></p><p><strong>具体使用</strong>：</p><ul><li><strong>打开</strong>侧边栏：<code>ctrl + shift + p</code>打开命令框，然后再输入<code>Browse Mode: Outline (Right)</code></li><li><strong>关闭</strong>侧边栏：<code>ctrl + shift + p</code>打开命令框，然后再输入<code>Browse mode: Close sidebar(s)</code></li></ul><hr><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录了在学习和使用sublime text编辑器过程中对其进行的配置和优化，包括一些插件的用法，便于后续使用和查询&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sublime text3" scheme="http://showteeth.tech/tags/sublime-text3/"/>
    
  </entry>
  
  <entry>
    <title>博客图床-阿里云+PicGo上传照片</title>
    <link href="http://showteeth.tech/posts/41221.html"/>
    <id>http://showteeth.tech/posts/41221.html</id>
    <published>2019-03-20T01:16:33.000Z</published>
    <updated>2019-03-20T13:44:55.516Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是关于使用阿里云搭建图床以及使用PicGo进行上传照片的操作，便与后续查询使用</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来图床使用的是七牛的服务，但是前几天七牛给我发了一封”测试域名回收通知”的邮件，看了邮件，然后查看相关说明发现如果想要使用就有添加自己的域名，然后为了添加自己的域名还要去公安部备案，尝试了一下，太麻烦了，然后看了一下关于阿里和腾讯的，本着天下没有免费的午餐的理念，我选择了阿里(腾讯的存储不要钱)，然后就有了接下来的故事。</p><h2 id="开通阿里云oss"><a href="#开通阿里云oss" class="headerlink" title="开通阿里云oss"></a>开通阿里云oss</h2><p>主要流程：实名认证—&gt;开通对象存储服务 OSS—&gt;购买资源包—&gt;新建Bucket</p><p>购买资源包的时候可以选取资源包类型和规格等信息，按照自己的需求选取即可，我这里选择的是存储包以及40G大小，作为博客图片应该是足够用了(如果有再小一点的我肯定就选了)。</p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/阿里oss.png"><br></div><p>关于阿里oss收费，比较复杂，主要包括：存储容量，流量，请求次数。刚刚购买的只是存储容量，具体的收费详情请查看<a href="https://www.aliyun.com/price/product?spm=5176.7933691.744462.c1.79ba6a56EQXVX5#/oss/detail" target="_blank" rel="noopener">这个链接</a></p><p>接下来就是新建Bucket了，我按照如下选项进行的创建：</p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/阿里oss_2.png"><br></div><hr><h2 id="使用PicGo上传图片"><a href="#使用PicGo上传图片" class="headerlink" title="使用PicGo上传图片"></a>使用PicGo上传图片</h2><p>PicGo是一款图片上传的工具，目前支持微博图床、七牛图床、腾讯云、又拍云、GitHub、阿里等主流图床，并且支持macOS、windows 64位（&gt;= v1.3.1），linux（&gt;= v1.6.0），可是说是全平台很强大了，这是<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Github链接</a>、这是<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">官方网站</a></p><p>下载并安装之后进入图床设置，选择对应的图床，我这里选取了阿里oss：</p><div align="center"><br><img src="https://i.loli.net/2019/03/20/5c92335ee931f.png"><br></div><ul><li>accesskey和accesskeySecret可以从阿里云控制台获取(就在新建Bucket旁边)</li><li>存储空间名是bucket的名字</li><li>存储区域按照提示填写(在bucket的访问域名中可以看到)</li><li>存储路径按照提示填写</li><li>自定义域名可以不填写</li></ul><h3 id="PicGo插件使用"><a href="#PicGo插件使用" class="headerlink" title="PicGo插件使用"></a>PicGo插件使用</h3><p>这里给出的<a href="https://github.com/PicGo/Awesome-PicGo/blob/master/README.md" target="_blank" rel="noopener">PicGo</a>中包含的插件，我觉得比较好的是<a href="https://github.com/Spades-S/vs-picgo/blob/master/README_ZH.md" target="_blank" rel="noopener">vs-picgo</a>，其可以在vscode中使用，刚好自己使用的就是vscode，所以非常方便，这里记录这个插件的主要用法。</p><ul><li>安装插件，直接在vscode应用商店中搜索PicGo即可</li><li><p><strong>配置插件</strong>：<br><strong>修改vscode的<code>setting.json</code>文件</strong>，加入如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 其中的XXX使用自己的信息填写进去</span><br><span class="line">"picgo": &#123;</span><br><span class="line">  "path": ""</span><br><span class="line">&#125;,</span><br><span class="line">"picBed": &#123;</span><br><span class="line">  "current": "aliyun",</span><br><span class="line">  "aliyun": &#123;</span><br><span class="line">    "accessKeyId": "XXX",</span><br><span class="line">    "accessKeySecret": "XXX",</span><br><span class="line">    "bucket": "XXX",</span><br><span class="line">    "area": "XXX",</span><br><span class="line">    "path": "XXX",</span><br><span class="line">    "customUrl": ""</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>插件上传的图片<strong>不会显示在PicGo软件的相册</strong>中，直接上传在了阿里云</p></li><li>如果想要<strong>对上传的图片更改名称</strong>，可以<strong>先选中名称</strong>，然后<strong>再插入图片</strong></li><li>上传<strong>只支持markdown的链接</strong>，<strong>不支持其他类型(如html)链接</strong>，这个<strong>没有PicGo桌面版好用</strong></li><li>支持从剪贴板、文件选取以及输入框上床，对应的快捷键如下：<blockquote><ul><li><code>ctrl+alt+u</code>：<strong>剪贴板</strong>图片上传</li><li><code>ctrl+alt+e</code>：打开<strong>文件管理器</strong>上传</li><li><code>ctrl+alt+o</code>：打开<strong>输入框输入路径</strong>上传</li></ul></blockquote></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要是关于使用阿里云搭建图床以及使用PicGo进行上传照片的操作，便与后续查询使用&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="博客" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://showteeth.tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之argparse-命令行选项与参数解析</title>
    <link href="http://showteeth.tech/posts/19941.html"/>
    <id>http://showteeth.tech/posts/19941.html</id>
    <published>2019-03-19T02:33:27.000Z</published>
    <updated>2019-03-23T12:18:47.398Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python用于解析命令行参数的<code>argparse</code>模块，按照其使用过程依次学习了<strong>生成参数分析器</strong>、<strong>添加参数</strong>、<strong>参数解析</strong>和<strong>输出传入参数值</strong>，最后还学习了<strong>参数群组</strong>、比较强大的<strong>创建子命令</strong>以及<strong>互斥参数组</strong>的使用。</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>argparse</code>是 <code>Python</code> 标准库中用来解析命令行参数和选项的模块，很早之前就想学习和使用这个模块了，但由于种种原因没能实现；之前一直使用的是<code>sys</code>模块的<code>argv</code>来传递参数，但是这种传递参数的方法比较简单，不能输出一些提示信息，导致有些脚本很久之后再看可能不知道当时设置的参数的含义或者需要打开具体的脚本才能知道参数的含义，比较麻烦，所以这里来对<code>argparse</code>进行学习，在以后的脚本中替换<code>sys</code>模块。</p><hr><h2 id="初识argparse"><a href="#初识argparse" class="headerlink" title="初识argparse"></a>初识argparse</h2><p>创建python文件(<strong>注意不要将文件命名为argparse.py，不然会报错，因为文件名和模块名相同，导入会出问题</strong>)，并在其中写入如下代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成参数分析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出传入参数值 </span></span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><p></p><p>运行上述python文件：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–sum] N [N …]</p><p>Process some integers.</p><p>positional arguments:<br>N an integer for the accumulator</p><p>optional arguments:<br>-h, –help show this help message and exit<br>–sum sum the integers (default: find the max)</p></blockquote><p>从上述输出结果可以发现：<code>argparse</code>会自动生成帮助文档，也就是说即使在程序中不添加任何参数，<strong><code>argparse</code>也会自动默认生成一个参数<code>-h</code></strong>，用于输出帮助文档</p><p>在上述<code>argparse</code>使用过程中依次经过了<strong>生成参数分析器</strong>、<strong>添加参数</strong>、<strong>参数解析</strong>和<strong>输出传入参数值</strong>这几步，接下来我就按照这个顺序进行学习。</p><hr><h2 id="创建解析器-ArgumentParser类"><a href="#创建解析器-ArgumentParser类" class="headerlink" title="创建解析器-ArgumentParser类"></a>创建解析器-ArgumentParser类</h2><p>上述argparse测试代码中使用<code>argparse.ArgumentParser()</code>创建参数分析器也就是解析器，这里就先对这个解析器进行一定的了解，其原型如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">argparse</span>.<span class="title">ArgumentParser</span><span class="params">(prog=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                usage=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                description=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                epilog=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                parents=[], </span></span></span><br><span class="line"><span class="class"><span class="params">                formatter_class=argparse.HelpFormatter,</span></span></span><br><span class="line"><span class="class"><span class="params">                prefix_chars=<span class="string">'-'</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">                fromfile_prefix_chars=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                argument_default=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                conflict_handler=<span class="string">'error'</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">                add_help=True,</span></span></span><br><span class="line"><span class="class"><span class="params">                allow_abbrev=True)</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>其中参数的含义</strong>：</p><style>table th:first-of-type{width:30%}table th:nth-of-type(2){width:50%}table th:nth-of-type(3){width:20%}</style><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>prog</td><td>程序的名字，help中显示的</td><td><code>sys.argv[0]</code></td></tr><tr><td>usage</td><td>描述程序用途的字符串</td><td>从解析器的参数生成</td></tr><tr><td>description</td><td>参数帮助信息之前的文本</td><td>none</td></tr><tr><td>epilog</td><td>参数帮助信息之后的文本</td><td>none</td></tr><tr><td>parents</td><td><code>ArgumentParser</code> 对象的一个列表，这些对象的参数应该包括进去(参数继承)</td><td></td></tr><tr><td>formatter_class</td><td>定制化输出的帮助信息</td><td></td></tr><tr><td>prefix_chars</td><td>可选参数的前缀字符</td><td>‘-‘</td></tr><tr><td>fromfile_prefix_chars</td><td>从文件中读取参数时文件的前缀字符</td><td>None</td></tr><tr><td>argument_default</td><td>参数的全局默认值</td><td>None</td></tr><tr><td>conflict_handler</td><td>解决冲突的可选参数的策略（通常没有必要）</td><td></td></tr><tr><td>add_help</td><td>解析器添加-h/–help 选项</td><td>True</td></tr><tr><td>allow_abbrev</td><td>如果前缀是明确的，则允许缩写长参数</td><td>True</td></tr></tbody></table><h3 id="proc-help中描述程序的名称"><a href="#proc-help中描述程序的名称" class="headerlink" title="proc-help中描述程序的名称"></a>proc-help中描述程序的名称</h3><p><code>proc</code>参数代表程序的名字，默认为<code>sys.argv[0]</code>，<strong>用来在help信息中描述程序的名称</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改上述代码解析器的部分如下</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br></pre></td></tr></table></figure><p></p><p>并使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: <strong><em>myprogram</em></strong> [-h]</p></blockquote><p>发现<code>usage</code>后面接着的文字由默认的<code>argparse_test.py(sys.argv[0])</code>变成了现在的<code>prog=&#39;myprogram&#39;</code>定义的内容</p><hr><h3 id="usage-描述程序用途"><a href="#usage-描述程序用途" class="headerlink" title="usage-描述程序用途"></a>usage-描述程序用途</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以结合proc一起使用</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>, usage=<span class="string">'%(prog)s is a test of argparse'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: <strong>myprogram is a test of argparse</strong></p></blockquote><p>发现<code>usage</code>后面接着的文字由默认的<code>argparse_test.py [-h]</code>变成了现在的<code>myprogram is a test of argparse</code></p><hr><h3 id="description和epilog-程序描述信息，help-信息前后的文字"><a href="#description和epilog-程序描述信息，help-信息前后的文字" class="headerlink" title="description和epilog-程序描述信息，help 信息前后的文字"></a>description和epilog-程序描述信息，help 信息前后的文字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'before help'</span>,epilog=<span class="string">"after help"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [-h]</p><p><strong>before help</strong></p><p>optional arguments:<br>-h, –help show this help message and exit</p><p><strong>after help</strong></p></blockquote><hr><h3 id="prefix-chars-参数前缀"><a href="#prefix-chars-参数前缀" class="headerlink" title="prefix_chars-参数前缀"></a>prefix_chars-参数前缀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prefix_chars=<span class="string">'+'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py +h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [<strong>+</strong>h]</p><p>optional arguments:<br><strong>+</strong>h, <strong>++</strong>help show this help message and exit</p></blockquote><hr><h3 id="parents-参数继承"><a href="#parents-参数继承" class="headerlink" title="parents-参数继承"></a>parents-参数继承</h3><p>我们常常需要实现一套命令行程序，这些程序都带一组参数，只是<strong>在某些方面有特殊化</strong>。例如，如果所有程序都需要在用户进行任何实际的操作之前对用户进行认证，那么它们就<strong>都需要支持<code>--user</code>和<code>--password</code>选项</strong>。你可以共享的选项来定义一个“父母”解析器，然后<strong>令单个程序的解析器从该“父母”解析器继承共享选项，这样就不必显式为每个ArgumentParser添加共享选项</strong>。</p><p><strong>第一步</strong>是以共享的参数定义<strong>建立“父母”解析器</strong>。注意：<strong>由于“父母”解析器的后代使用者会添加相同的帮助选项，从而会引发一个异常(见下面冲突解决)，所以在基础解析器中我们关闭自动帮助选项生成</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 注意这里的add_help=False</span></span><br><span class="line">parser = argparse.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure><p></p><p>文件保存在名为<code>argparse_parent_base.py</code>的文件中</p><p><strong>第二步以父母解析器集创建另一个解析器</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 导入parent的文件</span></span><br><span class="line"><span class="keyword">import</span> argparse_parent_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承父母解析器的参数</span></span><br><span class="line">parser = argparse.ArgumentParser(parents=[argparse_parent_base.parser])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置自己的参数</span></span><br><span class="line">parser.add_argument(<span class="string">'--local-arg'</span>, action=<span class="string">"store_true"</span>, default=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出所有的参数</span></span><br><span class="line"><span class="keyword">print</span> parser.parse_args()</span><br></pre></td></tr></table></figure><p></p><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_uses_parent.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_uses_parent.py [-h] [--user USER] [--password PASSWORD]</span><br><span class="line">                           [--local-arg]</span><br><span class="line"><span class="comment"># 可以发现继承了父母解析器的参数</span></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">    --user USER</span><br><span class="line">    --password PASSWORD</span><br><span class="line">    --local-arg</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="conflict-handler-冲突解决"><a href="#conflict-handler-冲突解决" class="headerlink" title="conflict_handler-冲突解决"></a>conflict_handler-冲突解决</h3><p>前一个例子指出<strong>以相同的参数名字为一个解析器添加两个参数处理器会引发一个异常</strong>(就是<code>parent</code>中提到的的帮助选项)。可以通过传递一个<code>conflict_handler</code>来改变冲突消除行为。<code>argparse</code>有两个内置的冲突处理器<code>error（默认）</code>和<code>resolve</code>，<code>resolve</code>会基于冲突选项的添加顺序来选择一个参数处理器:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 设置冲突解决的策略为resolve</span></span><br><span class="line">parser = argparse.ArgumentParser(conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">"store"</span>)</span><br><span class="line"><span class="comment"># 两个相同参数名的参数</span></span><br><span class="line">parser.add_argument(<span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">"Short alone"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--long-b'</span>, <span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">"Long and short together"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> parser.parse_args([<span class="string">'-h'</span>])</span><br></pre></td></tr></table></figure><p></p><p>由于最后一个处理器所给定的参数名已被使用，那么本例中<strong>独立选项<code>-b</code>将被<code>--long-b</code>所覆盖</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_conflict_handler_resolve.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_conflict_handler_resolve.py [-h] [-a A] [--long-b LONG_B]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -a A</span><br><span class="line">    <span class="comment"># 只出现了后定义的参数，前面定义的参数被覆盖了</span></span><br><span class="line">    --long-b LONG_B, -b LONG_B</span><br><span class="line">            Long <span class="keyword">and</span> short together</span><br></pre></td></tr></table></figure><p></p><p><strong>切换<code>add_argument()</code>的调用顺序</strong>就可以使两个选项都可以使用：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">"store"</span>)</span><br><span class="line"><span class="comment"># 同样是定义两个相同参数名的参数，只是顺序发生改变</span></span><br><span class="line">parser.add_argument(<span class="string">'--long-b'</span>, <span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">'Long and short together'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">'Short alone'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> parser.parse_args([-h])</span><br></pre></td></tr></table></figure><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_conflict_handler_resolve2.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_conflict_handler_resolve2.py [-h] [-a A] [--long-b LONG_B] [-b B]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -a A</span><br><span class="line">    <span class="comment"># 两个参数都可以使用了，没有进行覆盖</span></span><br><span class="line">    --long-b LONG_B Long <span class="keyword">and</span> short together</span><br><span class="line">    -b B    Short alone</span><br></pre></td></tr></table></figure><hr><h3 id="fromfile-prefix-chars-从文件中读取参数时文件的前缀字符集"><a href="#fromfile-prefix-chars-从文件中读取参数时文件的前缀字符集" class="headerlink" title="fromfile_prefix_chars-从文件中读取参数时文件的前缀字符集"></a>fromfile_prefix_chars-从文件中读取参数时文件的前缀字符集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'args.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>   fp.write(<span class="string">'-f\nbar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(fromfile_prefix_chars=<span class="string">'@'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-f'</span>, <span class="string">'foo'</span>, <span class="string">'@args.txt'</span>])</span><br><span class="line">Namespace(f=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p>当<strong>参数过多</strong>时，可以<strong>将参数放到文件中读取</strong>，例子中<code>parser.parse_args([&#39;-f&#39;, &#39;foo&#39;, &#39;@args.txt&#39;])</code><strong>解析时会从文件args.txt读取，相当于<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;-f&#39;, &#39;bar&#39;]</code></strong></p><hr><h3 id="add-help-解析器添加-h-–help-选项"><a href="#add-help-解析器添加-h-–help-选项" class="headerlink" title="add_help-解析器添加-h/–help 选项"></a>add_help-解析器添加-h/–help 选项</h3><p>设为 <code>False</code> 时，<code>help</code> 信息里面不再显示 <code>-h --help</code> 信息</p><div class="note info"><p>以上是我觉得比较重要的参数，但不是全部参数，具体参数的解释请参考<a href="https://docs.python.org/3/library/argparse.html#argumentparser-objects" target="_blank" rel="noopener">官方文档</a></p></div><hr><h3 id="allow-abbrev-长参数缩写"><a href="#allow-abbrev-长参数缩写" class="headerlink" title="allow_abbrev-长参数缩写"></a>allow_abbrev-长参数缩写</h3><p>参考后面解析参数<code>-parse_args()</code>的参数缩写</p><hr><p><br></p><h2 id="添加参数-add-argument"><a href="#添加参数-add-argument" class="headerlink" title="添加参数-add_argument()"></a>添加参数-add_argument()</h2><p>创建解析器之后如果需要为程序序添加参数选项需要用 ArgumentParser 对象的 <code>add_argument</code> 方法，该方法原型如下:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name <span class="keyword">or</span> flags...[, action][, nargs]</span><br><span class="line">                                            [, const][, default]</span><br><span class="line">                                            [, type][, choices]</span><br><span class="line">                                            [, required][, help]</span><br><span class="line">                                            [, metavar][, dest])</span><br></pre></td></tr></table></figure><p></p><table><tr><th width="20%">参数</th><th width="80%">含义</th></tr><tr><td>name or flags</td><td>选项字符串的名字或者列表，例如foo 或者-f, --foo</td></tr><tr><td>action</td><td>在命令行遇到该参数时采取的基本动作类型</td></tr><tr><td>nargs</td><td>应该读取的命令行参数个数</td></tr><tr><td>const</td><td>某些action和nargs选项要求的常数值</td></tr><tr><td>default</td><td>如果命令行中没有出现该参数时的默认值</td></tr><tr><td>type</td><td>命令行参数应该被转换成的类型</td></tr><tr><td>choices</td><td>包含参数可允许的值的一个容器</td></tr><tr><td>required</td><td>该命令行选项是否可以省略(只针对可选参数)</td></tr><tr><td>help</td><td>参数的简短描述</td></tr><tr><td>metavar</td><td>参数在帮助信息中的名字</td></tr><tr><td>dest</td><td>给parse_args()返回的对象要添加的属性名称</td></tr></table><h3 id="位置参数和可选参数"><a href="#位置参数和可选参数" class="headerlink" title="位置参数和可选参数"></a>位置参数和可选参数</h3><p>在学习具体的各个参数的含义之前，先了解一下argparse中的两种参数类型：<strong>位置参数</strong>和<strong>可选参数</strong>，<strong>位置参数在定义时没有前缀，而可选参数需要加前缀（默认为’-‘）</strong>。</p><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在前面的代码中按如下进行修改</span></span><br><span class="line"><span class="comment"># 添加echo这个位置参数，且定义参数的帮助信息</span></span><br><span class="line">parser.add_argument(<span class="string">"echo"</span>, help = <span class="string">"echo the string you use here"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="keyword">print</span> args.echo</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [-h] echo</p><p><strong>positional arguments:</strong><br>echo echo the string you use here</p><p><strong>optional arguments:</strong><br>-h, –help show this help message and exit</p></blockquote><p>如果直接使用<code>python argparse_test.py</code>运行程序，不加参数：</p><blockquote><p>python argparse_test.py<br>usage: argparse_test.py [-h] echo<br>argparse_test.py: <strong>error: the following arguments are required: echo</strong></p></blockquote><p>位置参数<strong>相当于默认情况下使用了参数，如果不进行传参会报错</strong>，当然这可以通过<code>action=&#39;store_true&#39;</code>解决</p><p>使用<code>python argparse_test.py test</code>运行程序：</p><blockquote><p>python argparse_test.py test<br>test</p></blockquote><p>在添加参数后程序正常执行，输出参数值(<strong>通过解析后，参数的值保存在<code>echo</code>变量中</strong>)</p><hr><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>可选参数有两种：</p><ul><li>通过一个<code>-</code>来指定的<strong>短参数</strong>，如<code>-h</code></li><li>通过<code>--</code>来指定的<strong>长参数</strong>，如<code>--help</code></li><li>长参数是完整版，使用比较麻烦，而短参数则是简写版，便于使用，两个可以同时存在，也可以只写其中一个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br></pre></td></tr></table></figure><p>显示出帮助信息：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-v VERBOSITY]</p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>-v <code>VERBOSITY</code>, –verbosity <code>VERBOSITY</code></strong><br><strong>increase output verbosity</strong></p></blockquote><p>可选参数<code>-v</code>或<code>--verbosity</code>，通过解析后，其<strong>值保存在<code>args.verbosity</code>变量</strong>中:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一句</span></span><br><span class="line"><span class="keyword">print</span> (args.verbosity)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -v 2</code><br>2</p></blockquote><div class="note info"><ul><li>位置参数和可选参数是通过<code>-</code>来区分，如果不加<code>-</code>，<code>argparse</code>会将其当做位置参数解析</li><li>位置参数在解析时，值存储在位置参数同名的变量中；可选参数在解析时，如果没有添加长参数，则和位置参数一样，储存在同名变量中，而如果添加了长参数，则存储在长参数的变量中</li></ul></div><hr><h3 id="name-or-flags-参数名"><a href="#name-or-flags-参数名" class="headerlink" title="name or flags-参数名"></a>name or flags-参数名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加位置参数，echo即为参数名</span></span><br><span class="line">parser.add_argument(<span class="string">"echo"</span>, help = <span class="string">"echo the string you use here"</span>)</span><br><span class="line"><span class="comment"># 添加可选参数，-v和--verbosity都为参数名</span></span><br><span class="line">parser.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="action-对参数采取的动作"><a href="#action-对参数采取的动作" class="headerlink" title="action-对参数采取的动作"></a>action-对参数采取的动作</h3><p>action包括六种不同的取值，分别为<code>store(默认选项)</code>、<code>store_const</code>、<code>store_true</code>、<code>store_false</code>、<code>append</code>、<code>append_const</code>、<code>count</code>、<code>help</code>、<code>version</code>。</p><h4 id="只存储值–action-’store"><a href="#只存储值–action-’store" class="headerlink" title="只存储值–action=’store"></a>只存储值–action=’store</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store'</span>)</span><br></pre></td></tr></table></figure><p>这是默认情况，可以不用加，<strong>这种情况如果使用了参数但是不传入值，就会报错</strong></p><hr><h4 id="常量参数–action-’store-const’"><a href="#常量参数–action-’store-const’" class="headerlink" title="常量参数–action=’store_const’"></a>常量参数–action=’store_const’</h4><p><code>store_const</code>，表示参数为固定值，该固定值存放在 <code>const</code> 中:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_const'</span>, const=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py --foo</code><br>42</p></blockquote><p><strong>不能修改值(默认值，不能修改)</strong>，如果修改值就会报错：</p><blockquote><p><code>python argparse_test.py --foo 20</code><br>usage: argparse_test.py [-h] [–foo]<br>argparse_test.py: error: unrecognized arguments: 20</p></blockquote><hr><h4 id="True-or-False–store-true和store-false"><a href="#True-or-False–store-true和store-false" class="headerlink" title="True or False–store_true和store_false"></a>True or False–store_true和store_false</h4><p>store_true和store_false，值存为 True 或 False。这个很实用，比如前面<strong>在位置参数中如果直接执行(可选参数也是一样，不过需要调用)，不对参数传值的话就会报错，但是设置这个之后参数即使不传参，调用后也会返回值，不过是True或者False：</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用<code>python argparse_test.py --foo</code>执行程序：</p><blockquote><p>usage: argparse_test.py [-h] [–foo FOO]<br>argparse_test.py: error: argument –foo: expected one argument</p></blockquote><blockquote><p>True</p></blockquote><hr><h4 id="存储列表参数-action-’append’"><a href="#存储列表参数-action-’append’" class="headerlink" title="存储列表参数-action=’append’"></a>存储列表参数-action=’append’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'append'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo 2 --foo 3</code><br>[‘2’, ‘3’]</p></blockquote><hr><h4 id="参数出现次数–action-’count’"><a href="#参数出现次数–action-’count’" class="headerlink" title="参数出现次数–action=’count’"></a>参数出现次数–action=’count’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'count'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo --foo</code><br>2</p></blockquote><hr><h4 id="保存常量到列表–action-’append-const’"><a href="#保存常量到列表–action-’append-const’" class="headerlink" title="保存常量到列表–action=’append_const’"></a>保存常量到列表–action=’append_const’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-A'</span>, action=<span class="string">'append_const'</span>, dest=<span class="string">'const_collection'</span>,</span><br><span class="line">        const=<span class="string">'value-1-to-append'</span>,</span><br><span class="line">        default=[],</span><br><span class="line">        help=<span class="string">'Add different values to list'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-B'</span>, action=<span class="string">'append_const'</span>, dest=<span class="string">'const_collection'</span>,</span><br><span class="line">        const=<span class="string">'value-2-to-append'</span>,</span><br><span class="line">        help=<span class="string">'Add different values to list'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py -A -B</code><br>[‘value-1-to-append’, ‘value-2-to-append’]</p></blockquote><p>可以参考上面的<code>action=&#39;store_const&#39;</code></p><hr><h4 id="版本信息–action-’version’"><a href="#版本信息–action-’version’" class="headerlink" title="版本信息–action=’version’"></a>版本信息–action=’version’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 2.0'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --version</code><br>argparse_test.py 2.0</p></blockquote><hr><h3 id="nargs-参数数量"><a href="#nargs-参数数量" class="headerlink" title="nargs-参数数量"></a>nargs-参数数量</h3><p>参数可以传入的值的数目，可以为：</p><ul><li><strong>整数<code>N</code></strong>：<strong>N个</strong>传入值，返回传入值的<strong>列表</strong>，即使为1， 也返回列表</li><li><strong><code>&#39;*&#39;</code></strong>：<strong>任意多个传入值(包括0个)</strong>，返回<strong>列表</strong></li><li><strong><code>&#39;+&#39;</code></strong>：<strong>一个或更多</strong>，不加传入值的时候会报错，返回<strong>列表</strong></li><li><strong><code>&#39;?&#39;</code></strong>：首先从命令行获得参数，若没有则从const获得，然后从default获得；还可以使用该参数<mark>指定输入和输出文件</mark></li><li><strong><code>argparse.REMAINDER</code></strong>：将<strong>剩余的参数</strong>作为<strong>列表</strong>搜集起来</li></ul><h4 id="整数N"><a href="#整数N" class="headerlink" title="整数N"></a>整数N</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo 1 2</code><br>[‘1’, ‘2’]</p></blockquote><p><strong>注意使用整数N(N个)时返回的是一个列表，即使N=1，返回的也是一个元素的列表，这和默认行为(传入一个参数)返回传入值本身不同</strong></p><hr><h4 id="使用-39-39-进行文件操作"><a href="#使用-39-39-进行文件操作" class="headerlink" title="使用&#39;?&#39;进行文件操作"></a>使用<code>&#39;?&#39;</code>进行文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件，默认值为从标准输入读取</span></span><br><span class="line">parser.add_argument(<span class="string">'infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>),</span><br><span class="line">                     default=sys.stdin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件，默认值为标准输出</span></span><br><span class="line">parser.add_argument(<span class="string">'outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>),</span><br><span class="line">                     default=sys.stdout)</span><br></pre></td></tr></table></figure><div class="note info"><p>如果没有提供<code>nargs</code>参数，传入值的数量将由<code>action</code>决定，通常情况下只有一个参数</p></div><hr><h3 id="const-保存常量"><a href="#const-保存常量" class="headerlink" title="const-保存常量"></a>const-保存常量</h3><p>在以下两种情况使用：</p><ul><li><code>action</code>中的<code>action=&#39;store_const&#39;</code>和<code>action=&#39;append_const&#39;</code>给参数设置固定值</li><li><code>nargs</code>中的<code>&#39;?&#39;</code>，首先从命令行获得参数，若没有则从const获得，然后从default获得</li></ul><hr><h3 id="default-设置默认值"><a href="#default-设置默认值" class="headerlink" title="default-设置默认值"></a>default-设置默认值</h3><p>和前面的<code>const</code>的区别在于：const设置之后不能修改这个值，但是default设置之后只有命令行中没有传入参数值才会使用default，传入值的话就使用传入的值。</p><hr><h3 id="type-参数类型"><a href="#type-参数类型" class="headerlink" title="type-参数类型"></a>type-参数类型</h3><p><strong>默认情况下将传入的参数值统一作为字符读入</strong>，可以通过设置type来确定传入的参数值的类型：</p><ul><li><strong>type=float：浮点</strong></li><li><strong>type=float：整型</strong></li><li><p><strong>type=argparse.FileType()</strong>：创建可写入文件，其中的参数包括<code>mode=</code>、<code>bufsize=</code>、<code>encoding=</code>和<code>errors=</code>，前面的<code>nargs</code>中的<code>&#39;?&#39;</code>也是用于文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>, type=argparse.FileType(mode=<span class="string">'w'</span>,encoding=<span class="string">'UTF-8'</span>))</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python argparse_test.py out.txt</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   &lt;_io.TextIOWrapper name='out.txt' mode='w' encoding='UTF-8'&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>type还可以接受一个可以调用的函数(输入单个字符，返回转化后的类型)</p></li></ul><hr><h3 id="choices-参数的范围"><a href="#choices-参数的范围" class="headerlink" title="choices-参数的范围"></a>choices-参数的范围</h3><ul><li>choices设置参数的范围，例如通过<code>choices=range(1, 4)</code>设定数字的，也可以通过<code>choices=[&#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]</code>设置字符的</li><li><strong>需要注意：传入值先进行<code>type</code>的类型转换，然后才看检查<code>choices</code>范围，所以<code>choices</code>范围的类型要和<code>type</code>一致</strong></li><li><strong>支持<code>in操作(for i in sth)</code>的都可以作为<code>choices</code>的范围，例如常规的<code>dict</code>、<code>set</code>、<code>list</code>等</strong></li></ul><hr><h3 id="required-参数是否必须"><a href="#required-参数是否必须" class="headerlink" title="required-参数是否必须"></a>required-参数是否必须</h3><ul><li><strong><code>required</code>只针对可选参数</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, required=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用的时候如果不加--foo</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     argparse.py: error: option --foo is required</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="help-参数的帮助信息"><a href="#help-参数的帮助信息" class="headerlink" title="help-参数的帮助信息"></a>help-参数的帮助信息</h3><ul><li>对参数的简短描述，可以帮助选择参数</li><li><p>为了避免与<code>argparse</code>的参数重叠，帮助信息中的有些关键字(<code>prog</code>、<code>default</code>)可以使用<code>%</code>包围(文字中需要出现<code>%</code>的话用<code>%%</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>, type=int, default=<span class="number">42</span>,</span><br><span class="line">                     help=<span class="string">'the bar to %(prog)s (default: %(default)s)'</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 显示帮助信息时：</span></span><br><span class="line"><span class="comment">#   usage: frobble [-h] [bar]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   positional arguments:</span></span><br><span class="line"><span class="comment">#    bar     the bar to frobble (default: 42)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不输出某个参数的帮助信息，使用<code>help=argparse.SUPPRESS</code></strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=argparse.SUPPRESS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示帮助信息时显示：</span></span><br><span class="line"><span class="comment">#  usage: frobble [-h]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  optional arguments:</span></span><br><span class="line"><span class="comment">#   -h, --help  show this help message and exit</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="metavar-参数在帮助信息中的名称"><a href="#metavar-参数在帮助信息中的名称" class="headerlink" title="metavar-参数在帮助信息中的名称"></a>metavar-参数在帮助信息中的名称</h3><p>默认情况下，参数使用<code>dest</code>值作为名称，例如位置参数的参数名称就是位置参数的名称，而可选参数如果使用了长参数则是长参数的名称，如果<strong>只使用了短参数</strong>则是短参数的名称(前面位置参数也有讲解)</p><p>默认情况：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–foo <strong>FOO</strong>] <strong>bar</strong></p><p>positional arguments:<br>bar</p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>–foo FOO</strong></p></blockquote><p><strong>通过metavar设置</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, metavar=<span class="string">'YYY'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>, metavar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–foo <strong>YYY</strong>] <strong>XXX</strong></p><p>positional arguments:<br><strong>XXX</strong></p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>–foo YYY</strong></p></blockquote><p>可以发现上述加粗的地方的名称出现了改变</p><p><strong>需要注意的是<code>metavar</code>只是改变了名称的显示内容，真正的变量解析的名称还是有<code>dest</code>决定</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上述输出变量值，使用metavar设置的名称</span></span><br><span class="line"><span class="keyword">print</span> (args.YYY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述输出变量值，使用dest的名称</span></span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><p><code>print (args.YYY)</code>的输出：</p><blockquote><p><code>python argparse_test.py --foo test test2</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.YYY)<br>AttributeError: <strong>‘Namespace’ object has no attribute ‘YYY’</strong></p></blockquote><p><code>print (args.foo)</code>的输出：</p><blockquote><p><code>python argparse_test.py --foo test test2</code><br>test</p></blockquote><p><strong>可以发现只有使用<code>print (args.foo)</code>才能正常输出，说明参数解析存放的变量还是没变，<code>metavar</code>设置的名称只是改变了显示形式</strong></p><div class="note info"><ul><li>参数解析存放的变量还是没变(还是由<code>dest</code>决定)，<code>metavar</code>设置的名称只是改变了显示形式</li><li>如果参数设置了<code>nargs</code>(例如：nargs=2)，会导致<code>metavar</code>设置的名称(如果只指定了一个名称)重复出现</li></ul></div><hr><h3 id="dest-传入值的属性名称"><a href="#dest-传入值的属性名称" class="headerlink" title="dest-传入值的属性名称"></a>dest-传入值的属性名称</h3><ul><li>如果<strong>存在长参数(–开头的)</strong>，则<code>dest</code>取<strong>第一个长参数的值作为属性名称</strong>；</li><li>如果<strong>没有长参数</strong>，则<code>dest</code>取<strong>第一个短参数的值作为属性名称</strong></li><li>所有字符中间的<code>-</code>都会被转化为<code>_</code>，保证属性名称是有效的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-x'</span>, <span class="string">'-y'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用第一个长参数以及将-转化为_</span></span><br><span class="line"><span class="keyword">print</span> (args.foo_bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用第二个长参数</span></span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.y)</span><br></pre></td></tr></table></figure><p><strong>查看帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-f <strong>FOO_BAR</strong>] [-x <strong>X</strong>]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-f <strong>FOO_BAR</strong>, –foo-bar <strong>FOO_BAR</strong>, –foo <strong>FOO_BAR</strong><br>-x <strong>X</strong>, -y <strong>X</strong></p></blockquote><p><strong>使用第一个长参数以及将<code>-</code>转化为<code>_</code></strong>：</p><blockquote><p><code>python argparse_test.py --foo test</code><br>test</p></blockquote><p><strong>如果使用短参数</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.f)<br>AttributeError: <strong>‘Namespace’ object has no attribute ‘f’</strong></p></blockquote><p><strong>如果使用第二个长参数</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in<module><br>print (args.foo)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘foo’</strong></module></p></blockquote><p><strong>第一个短参数</strong>:</p><blockquote><p><code>python argparse_test.py -x test</code><br>test</p></blockquote><p><strong>第二个短参数</strong>:</p><blockquote><p><code>python argparse_test.py -x test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.y)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘y’</strong></p></blockquote><p><mark>使用dest自定义属性名称</mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>,dest=<span class="string">"my_set"</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果还使用最开始的foo_bar</span></span><br><span class="line"><span class="keyword">print</span> (args.foo_bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的my_set</span></span><br><span class="line"><span class="keyword">print</span> (args.my_set)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-f <strong>MY_SET</strong>]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-f <strong>MY_SET</strong>, –foo-bar <strong>MY_SET</strong>, –foo <strong>MY_SET</strong></p></blockquote><p><strong>如果还使用最开始的foo_bar</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 5, in \&lt;module><br>print (args.foo_bar)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘foo_bar’</strong></p></blockquote><p><strong>使用自定义的my_set</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>test</p></blockquote><div class="note info"><p><strong><code>dest</code>就是命令行参数(传入值)在经过解析后存储的变量名</strong>，默认情况下：</p><ul><li>如果存在长参数，就是第一个长参数的值(<code>--</code>后面接着的字符串)</li><li>如果不存在长参数，就是第一个短参数的值(<code>-</code>后面接着的字符串)</li><li>参数中间的<code>-</code>都会被转化为<code>_</code>，保证属性名称是有效的</li></ul><p><strong>当然可以通过<code>dest</code>参数进行自定义解析后存储的变量名</strong></p></div><hr><p><br></p><h2 id="解析参数-parse-args"><a href="#解析参数-parse-args" class="headerlink" title="解析参数-parse_args()"></a>解析参数-parse_args()</h2><p>上述添加完所有参数之后，就可以给 <code>parse_args()</code> 传递一组参数字符串来解析命令行。<strong>默认情况下</strong>，参数是从 <code>sys.argv[1:]</code> 中获取，但你也可以传递自己的参数列表。因为一般使用argparse都是用来解析命令行参数，所以使用其默认情况即可，这里对自己传递参数的方法没有进行学习，需要的时候可以去看官方文档。<br><code>parse_args()</code> 的返回值是一个命名空间，包含传递给命令的参数。<strong>该对象将参数保存其属性</strong>，因此如果你的参数 <code>dest</code> 是 <code>&quot;myoption&quot;</code>，那么你就可以<code>args.myoption</code> 来访问该值(可以参考前面<code>dest</code>的用法).<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.parse_args(args=<span class="keyword">None</span>, namespace=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>args</code> - List of strings to parse. <strong>The default is taken from sys.argv</strong>.</li><li><code>namespace</code> - An object to take the attributes. <strong>The default is a new empty Namespace object</strong>.</li></ul><hr><p><br></p><h3 id="参数缩写"><a href="#参数缩写" class="headerlink" title="参数缩写"></a>参数缩写</h3><p>parse_args()默认允许长参数缩写为前缀(前缀是不相同的)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-bacon'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-badger'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-bac MMM'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="string">'MMM'</span>, badger=None)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-bad WOOD'</span>.split())</span><br><span class="line">Namespace(bacon=None, badger=<span class="string">'WOOD'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-ba BA'</span>.split())</span><br><span class="line">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span><br><span class="line">PROG: error: ambiguous option: -ba could match -badger, -bacon</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="解析部分参数-parse-known-args"><a href="#解析部分参数-parse-known-args" class="headerlink" title="解析部分参数-parse_known_args()"></a>解析部分参数-parse_known_args()</h3><p>有时间一个脚本只需要解析所有命令行参数中的一小部分，剩下的命令行参数给另一个脚本或者程序。在这种情况下，<code>parse_known_args()</code>就很有用。它很像<code>parse_args()</code>，但是它在接受到多余的命令行参数时不报错。相反的，返回一个tuple类型的命名空间和一个保存着余下的命令行字符的list。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse </span><br><span class="line">parser = argparse.ArgumentParser() </span><br><span class="line">parser.add_argument( </span><br><span class="line">    <span class="string">'--flag_int'</span>, </span><br><span class="line">    type=float, </span><br><span class="line">    default=<span class="number">0.01</span>, </span><br><span class="line">    help=<span class="string">'flag_int.'</span> </span><br><span class="line">) </span><br><span class="line">FLAGS, unparsed = parser.parse_known_args() </span><br><span class="line">print(FLAGS.flag_int) </span><br><span class="line">print(unparsed)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py --flag_int 0.02 --double 0.03 a 1</code><br>0.02<br>[‘–double’, ‘0.03’, ‘a’, ‘1’]</p></blockquote><p>binbin师兄的项目中有所使用，可以看看</p><hr><p><br></p><h2 id="参数群组"><a href="#参数群组" class="headerlink" title="参数群组"></a>参数群组</h2><p><code>argparse</code>能将参数定义组合成“群组”。<strong>默认情况下是使用两个群组，一个是可选参数的群组，另一个是必须的位置参数的群组</strong>，这可以在程序的帮助信息中看到，使用<code>optional arguments</code>和<code>positional arguments</code>将群组分开，可以参考前面的位置参数和可选参数部分</p><p>在实际使用中，<strong>可以调整群组来提高帮助信息中群组的逻辑性，这样相关选项或值能记录在一起</strong>。可以使用自定义群组来重写之前的共享选项的示例，如在帮助信息中身份认证的选项就可以显示在一起：<br><strong>第一步</strong>：在基础解析器中使用<code>add_argument_group()</code>来<strong>创建一个“身份认证”群组</strong>，然后逐个添加身份认证相关的选项到该群组<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparser.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 创建名为authentication的群组</span></span><br><span class="line">group = parser.add_argument_group(<span class="string">'authentication'</span>)</span><br><span class="line"><span class="comment"># 给这个群组添加参数</span></span><br><span class="line">group.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">group.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure><p></p><p>以上内容保存在名为<code>argparse_parent_with_group.py</code>的文件中</p><p><strong>第二步</strong>：和之前parent中讲到的一样进行参数继承<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> argparse_parent_with_group</span><br><span class="line"><span class="comment"># 继承参数，注意parent中是ArgumentParser类，所以这里依然导入的是parser，而不是group</span></span><br><span class="line">parser = argparse.ArgumentParser(parents=[argparse_parent_with_group.parser])</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--local-arg'</span>, action=<span class="string">"store_true"</span>, default=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (parser.parse_args())</span><br></pre></td></tr></table></figure><p></p><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">python argparse_test.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">usage: argparse_test.py [-h] [--user USER] [--password PASSWORD] [--local-arg]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">  --local-arg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的群组</span></span><br><span class="line">authentication:</span><br><span class="line">  --user USER</span><br><span class="line">  --password PASSWORD</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="创建子命令"><a href="#创建子命令" class="headerlink" title="创建子命令"></a>创建子命令</h2><p>有时候，我们可以根据功能将命令行分组成一系列相关的子命令，为了实现这种分组行为argparse提供了ArgumentParser.add_subparsers()方法，其使用如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_subparsers([title][, description][, prog]</span><br><span class="line">                              [, parser_class][, action][, option_string]</span><br><span class="line">                              [, dest][, required][, help][, metavar])</span><br></pre></td></tr></table></figure><p></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成参数分析器</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'cmd'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sub-commands</span></span><br><span class="line">sub_parser = parser.add_subparsers(title=<span class="string">'subcommands'</span>,</span><br><span class="line">                                description=<span class="string">'valid subcommands'</span>,</span><br><span class="line">                                help=<span class="string">'config subscommand help'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第一个分组，相当于单个分组中的argparse.ArgumentParser</span></span><br><span class="line">add_parser = sub_parser.add_parser(<span class="string">'add'</span>,help=<span class="string">'add user config'</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">add_parser.add_argument(<span class="string">'--name'</span>, required=<span class="keyword">True</span>, help=<span class="string">'user name'</span>)</span><br><span class="line">add_parser.add_argument(<span class="string">'--addr'</span>, required=<span class="keyword">False</span>, help=<span class="string">'user address'</span>)</span><br><span class="line">add_parser.add_argument(<span class="string">'--phone'</span>, required=<span class="keyword">False</span>, help=<span class="string">'phone number'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第二个分组</span></span><br><span class="line">delete_parser = sub_parser.add_parser(<span class="string">'delete'</span>, help=<span class="string">'delete user config'</span>)</span><br><span class="line">delete_parser.add_argument(<span class="string">'--name'</span>, required=<span class="keyword">True</span>, help=<span class="string">'user name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第三个分组</span></span><br><span class="line">show_parser = sub_parser.add_parser(<span class="string">'show'</span>, help=<span class="string">'show user config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py -h</code><br>usage: cmd [-h] {add,delete,show} …</p><p>optional arguments:<br>-h, –help show this help message and exit</p><p>subcommands:<br>valid subcommands</p><p>{add,delete,show} config subscommand help<br>add add user config<br>delete delete user config<br>show show user config</p></blockquote><p><strong>上述过程讲解：</strong><br><code>ArgumentParser</code>对象使用<code>add_subparsers()</code>方法创建子命令组；该方法通常在调用的时候不传递参数，并返回一个特殊的action实例，这个实例只有一个方法：<code>add_parser()</code>；对这个实例分别调用<code>add_parser()</code>方法来创建子命令对应的<code>ArgumentParser</code>(包含了其所有可以使用的参数，还包含了一个子命令组名称的参数)，再调用这个<code>ArgumentParser</code>实例的<code>add_argument()</code>方法来添加子命令的参数。</p><p>从上述帮助输出可以看出，<strong>对整体使用-h不会返回每个子命令组详细的帮助信息，如果想查看每个子命令组详细的帮助信息需要使用<code>python argparse_test.py add -h</code></strong>:</p><blockquote><p><code>python argparse_test.py add -h</code><br>usage: cmd add [-h] –name NAME [–addr ADDR] [–phone PHONE]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>–name NAME user name<br>–addr ADDR user address<br>–phone PHONE phone number</p></blockquote><p><mark>通过<code>ArgumentParser</code>的<code>set_defaults()</code>方法来设置不同的子命令执行的函数</mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置子命令add的执行函数为add_fn</span></span><br><span class="line">add_parser.set_defaults(func=add_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子命令delete的执行函数为delete_fn</span></span><br><span class="line">delete_parser.set_defaults(func=delete_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子命令show的执行函数为show_fn</span></span><br><span class="line">show_parser.set_defaults(func=show_fn)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建互斥参数"><a href="#创建互斥参数" class="headerlink" title="创建互斥参数"></a>创建互斥参数</h2><p>使用<code>ArgumentParser</code>的<code>add_mutually_exclusive_group()</code>来创建互斥参数组：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"calculate X to the power of Y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建互斥参数</span></span><br><span class="line">group = parser.add_mutually_exclusive_group()</span><br><span class="line">group.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbose"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">group.add_argument(<span class="string">"-q"</span>, <span class="string">"--quiet"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"x"</span>, type=int, help=<span class="string">"the base"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"y"</span>, type=int, help=<span class="string">"the exponent"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">answer = args.x**args.y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.quiet:</span><br><span class="line">    <span class="keyword">print</span> (answer)</span><br><span class="line"><span class="keyword">elif</span> args.verbose:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125;^&#123;&#125; == &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br></pre></td></tr></table></figure><p></p><p><strong>查看帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] <strong>[-v | -q]</strong> x y</p><p>calculate X to the power of Y</p><p>positional arguments:<br>x the base<br>y the exponent</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-v, –verbose<br>-q, –quiet</p></blockquote><p><strong>如果同时使用会报错</strong>：</p><blockquote><p><code>python argparse_test.py -v -q</code><br>usage: argparse_test.py [-h] [-v | -q] x y<br><strong>argparse_test.py: error: argument -q/–quiet: not allowed with argument -v/–verbose</strong></p></blockquote><p><strong><code>add_mutually_exclusive_group(required=True)</code>支持<code>required=True</code>参数(但是不支持title和description参数)，表明两个互斥的参数中必须使用一个</strong></p><hr><p><br></p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ul><li>可以将<strong>共有的参数放在一个父参数文件中，然后其他的文件直接导入(<code>parent</code>的使用)</strong>，这样比较简单</li><li>参数群组(<code>add_argument_group()</code>)，<strong>可以自己组织参数出现的分组，看着比较清晰</strong>，如果没有必要用到子命令(<code>add_subparsers()</code>)的时候可以尝试一下</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.jianshu.com/p/fef2d215b91d" target="_blank" rel="noopener">python argparse用法总结</a></li><li><a href="https://www.jianshu.com/p/0361cd8b8fec" target="_blank" rel="noopener">python命令行参数解析</a></li><li><a href="http://blog.konghy.cn/2016/06/30/python-argparse/" target="_blank" rel="noopener">Python 模块简介 – argparse</a></li><li><a href="https://www.cnblogs.com/xlqtlhx/p/8243592.html" target="_blank" rel="noopener">argarse.ArgumentParser.parse_known_args()解析</a></li><li><a href="http://blog.xiayf.cn/2013/03/30/argparse/" target="_blank" rel="noopener">非常好的讲解，但是适合回顾的时候看，需要基础</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python用于解析命令行参数的&lt;code&gt;argparse&lt;/code&gt;模块，按照其使用过程依次学习了&lt;strong&gt;生成参数分析器&lt;/strong&gt;、&lt;strong&gt;添加参数&lt;/strong&gt;、&lt;strong&gt;参数解析&lt;/strong&gt;和&lt;strong&gt;输出传入参数值&lt;/strong&gt;，最后还学习了&lt;strong&gt;参数群组&lt;/strong&gt;、比较强大的&lt;strong&gt;创建子命令&lt;/strong&gt;以及&lt;strong&gt;互斥参数组&lt;/strong&gt;的使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python-main函数的理解</title>
    <link href="http://showteeth.tech/posts/32155.html"/>
    <id>http://showteeth.tech/posts/32155.html</id>
    <published>2019-03-18T10:06:52.000Z</published>
    <updated>2019-03-20T13:21:51.137Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇之前学习过的关于Python main函数的理解，主要学习了main函数的作用、在作为包引入以及直接运行时的区别，同时对Python的代码运行机制也有了一定的了解.</p></div><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><strong>程序入口：</strong><br>&emsp;&emsp;对于<strong>很多编程语言</strong>来说，<strong>程序都必须要有一个入口</strong>，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，<strong>C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始</strong>。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。<br>&emsp;&emsp;而 <strong>Python 则有不同</strong>，它<strong>属于脚本语言</strong>，不像编译型语言那样先将程序编译成二进制再运行，而是<strong>动态的逐行解释运行</strong>。也就是<strong>从脚本第一行开始运行，没有统一的入口</strong>，结合Python<strong>使用缩进对齐组织代码</strong>的执行，所有<strong>没有缩进的代码（非函数定义和类定义），都会被当成Python的main函数，在载入时自动执行</strong>。<br>&emsp;&emsp; 一个 Python 源码文件除了<strong>可以被直接运行</strong>外，还<strong>可以作为模块（也就是库）被导入</strong>。<strong>不管是导入还是直接运行，最顶层的代码都会被运行（没有设置缩进的代码）</strong>，<strong>而实际上在导入的时候，有一部分代码我们是不希望被运行的，这一部分代码可以放在main函数中，当作为模块进行导入时就不会被执行</strong></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'AAA'</span>)                <span class="comment">#没有所进的代码，会被直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'BBB'</span>)             <span class="comment">#函数中的内容，被调用后会被执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (__name__)              <span class="comment">#是内置变量，用于表示当前模块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment">#当name是main的时候执行</span></span><br><span class="line">   test()</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'CCC'</span>)</span><br></pre></td></tr></table></figure><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p><strong>直接运行文件的输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line"></span><br><span class="line">__main__</span><br><span class="line"></span><br><span class="line">BBB</span><br><span class="line">CCC</span><br></pre></td></tr></table></figure><p></p><p>可以看出<strong>直接执行文件</strong>的时候<strong>先是两个print会被执行</strong>，并且从输出信息可以<strong>看出<code>__name__</code>是<code>__main__</code>，满足<code>if</code>的判断条件，所以<code>test()</code>函数会被执行，并且输出<code>CCC</code></strong>。</p><hr><h3 id="当成模块引入"><a href="#当成模块引入" class="headerlink" title="当成模块引入"></a>当成模块引入</h3><ul><li>将上述代码保存为<code>test_main.py</code>文件</li><li>在同一个目录下创建另一个文件，里面只写入<code>from test_main import test</code>，运行该文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只导入包的时候出现</span></span><br><span class="line"><span class="keyword">from</span> test_main <span class="keyword">import</span> test</span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件中继续写入 test()，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只写 test，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">&lt;function test at <span class="number">0x03433970</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>导入包的时候，和上面一样，两个print也会被直接执行</strong>，<strong>需要注意的是这里的<code>__name__</code>已经变成了<code>module</code>的名称（test_main）</strong>，由于<strong>此时的<code>__name__</code>不等于<code>__main___</code>，不满足if的条件，所以不会直接执行test函数和输出CCC</strong>；<strong>导入之后，调用其中的test函数（被导入的函数），原始的test函数就会被执行。</strong></p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>&emsp;&emsp;<strong><code>__name__ == &#39;__main__&#39;</code>含义是“Make a script both importable and executable”</strong>，也就是<strong>让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行</strong>。每个python模块(python文件)都包含内置的变量<code>__name__</code>，当运行模块被直接执行的时候，<code>__name__</code>等于<code>&#39;__main__&#39;</code>；如果import到其他模块中，则<code>__name__</code>等于模块名称(不包含后缀.py)。而在程序中的判断条件是<code>if __name__ == &#39;__main__&#39;</code>，所以当模块被直接执行时，<code>__name__ == &#39;__main__&#39;</code>结果为真；而当模块被import到其他模块中时，<code>__name__ == &#39;__main__&#39;</code>结果为假，就是不调用对应的方法。简单来说： <strong>如果模块是被直接运行的，则if语句中的代码块被运行，如果模块是被导入的，则if语句中的代码块不被运行</strong>。</p><div class="note info"><p>这个功能有一个用处：调试代码的时候，在<code>if __name__ == &#39;__main__&#39;</code>中加入一些我们的调试代码，我们可以<strong>让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</strong></p></div><hr><h2 id="典型的python文件结构"><a href="#典型的python文件结构" class="headerlink" title="典型的python文件结构"></a>典型的python文件结构</h2><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python文件结构.gif"><br></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/51892.htm" target="_blank" rel="noopener">浅析python 中<strong>name</strong> = ‘<strong>main</strong>‘ 的作用</a></li><li><a href="https://zhuanlan.zhihu.com/p/34366092" target="_blank" rel="noopener">python编程中的if <strong>name</strong> == ‘main’ 的作用和原理</a></li><li><a href="https://www.restran.net/2015/10/22/how-python-code-run/" target="_blank" rel="noopener">Python 源码剖析读书笔记</a></li><li><a href="http://blog.konghy.cn/2017/04/24/python-entry-program/" target="_blank" rel="noopener">Python 中的 if <strong>name</strong> == ‘<strong>main</strong>‘ 该如何理解</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇之前学习过的关于Python main函数的理解，主要学习了main函数的作用、在作为包引入以及直接运行时的区别，同时对Python的代码运行机制也有了一定的了解.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python常用程序块</title>
    <link href="http://showteeth.tech/posts/58475.html"/>
    <id>http://showteeth.tech/posts/58475.html</id>
    <published>2019-03-18T09:49:43.000Z</published>
    <updated>2019-03-18T16:19:04.253Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇博客总结一些常用的Python程序块，避免重复造轮子</p></div><a id="more"></a><h2 id="添加中文注释"><a href="#添加中文注释" class="headerlink" title="添加中文注释"></a>添加中文注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><hr><h2 id="正则匹配-分组、非贪婪"><a href="#正则匹配-分组、非贪婪" class="headerlink" title="正则匹配(分组、非贪婪)"></a>正则匹配(分组、非贪婪)</h2><p>正则匹配是经常使用的，也是经常容易出错的，这个给出比较常用的带<strong>分组</strong>和<strong>非贪婪</strong>模式的匹配：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">'&gt;AT1G01060.4 | Symbols: LHY, LHY1 | Homeodomain-like superfamily protein | chr1:33992-37061 REVERSE LENGTH=644'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配前面的AT1G01060</span></span><br><span class="line">pattern=re.compile(<span class="string">'^&gt;(.*?)\.'</span>)</span><br><span class="line"></span><br><span class="line">re.search(pattern,s).group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>‘AT1G01060’</p></blockquote><div class="note info"><ul><li>需要注意的：<code>&#39;^&gt;(.*?)\.&#39;</code>这里<code>?</code>加在<code>*</code>的后面，因为<code>*</code>才是贪婪匹配的来源；不应该加载<code>()</code>后面，那样起不到非贪婪匹配的作用</li><li><code>group(0)</code>或者<code>group()</code>表示的是整个匹配上的字符串，比如这里指的就是<code>&#39;&gt;AT1G01060.&#39;</code>；<code>group(1)</code>才是匹配的括号内的内容</li><li><code>re.match</code><strong>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None</strong>；而<code>re.search</code>匹配<strong>整个字符串，直到找到一个匹配</strong></li><li><strong><code>re.match</code> 和 <code>re.search</code> 是匹配一次 <code>re.findall</code> 匹配所有，返回列表</strong></li></ul></div><hr><h2 id="自动调用函数执行"><a href="#自动调用函数执行" class="headerlink" title="自动调用函数执行"></a>自动调用函数执行</h2><p>关于main函数的理解，请参考<a href="http://showteeth.tech/">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义主函数</span></span><br><span class="line">def main():</span><br><span class="line">    my_func()</span><br><span class="line">    my_func_1()</span><br><span class="line">    my_func_2()</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="输出固定长度的字串"><a href="#输出固定长度的字串" class="headerlink" title="输出固定长度的字串"></a>输出固定长度的字串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改every即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wrapped</span><span class="params">(string, every=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\n'</span>.join(string[i:i+every] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), every))</span><br></pre></td></tr></table></figure><hr><h2 id="字典相关操作："><a href="#字典相关操作：" class="headerlink" title="字典相关操作："></a>字典相关操作：</h2><h3 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的字典</span></span><br><span class="line">dic=&#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="string">'3'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用collections中的defaultdict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dic_test=defaultdict(list)</span><br><span class="line">dic_test[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 具体的形式：defaultdict(&lt;type 'list'&gt;, &#123;'a': [1]&#125;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="两个列表组成字典"><a href="#两个列表组成字典" class="headerlink" title="两个列表组成字典"></a>两个列表组成字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"></span><br><span class="line">dictionary = dict(zip(keys, values)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (dictionary) </span><br><span class="line"><span class="comment"># 输出: </span></span><br><span class="line"><span class="comment">#      &#123;'a': 1, 'c': 3, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方法创建方法都可以使用以下方法遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">  <span class="keyword">print</span> (k)</span><br><span class="line">  <span class="keyword">print</span> (v)</span><br></pre></td></tr></table></figure><hr><h3 id="将字典写入文件"><a href="#将字典写入文件" class="headerlink" title="将字典写入文件"></a>将字典写入文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dic_file</span><span class="params">(dic,out_file)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(out_file,<span class="string">'w'</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">out.write(k+<span class="string">'\n'</span>)</span><br><span class="line">out_s=write_wrapped(v, every=<span class="number">60</span>)</span><br><span class="line">out.write(out_s)</span><br><span class="line">out.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="获取字典最值"><a href="#获取字典最值" class="headerlink" title="获取字典最值"></a>获取字典最值</h3><p><strong>利用<code>min(dict, key=dict.get)</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="number">3</span>:<span class="number">2</span>&#125;</span><br><span class="line">min(d, key=d.get)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     2</span></span><br></pre></td></tr></table></figure><p></p><p><strong>利用<code>lambda</code>函数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到索引和值</span></span><br><span class="line">min(d.items(), key=lambda x: x[1])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     (2, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只得到值</span></span><br><span class="line">min(d, key=lambda x: d[x])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#      2</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="判断最后一行文本"><a href="#判断最后一行文本" class="headerlink" title="判断最后一行文本"></a>判断最后一行文本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bug:if second last is same as last, this will be wrong </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">last_line=total_lines[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> line == last_line:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># fix bug above</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line_num)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">total_line_num=len(total_lines)</span><br><span class="line"><span class="keyword">if</span> line_num==total_line_num:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇博客总结一些常用的Python程序块，避免重复造轮子&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python常见错误</title>
    <link href="http://showteeth.tech/posts/61409.html"/>
    <id>http://showteeth.tech/posts/61409.html</id>
    <published>2019-03-18T07:52:34.000Z</published>
    <updated>2019-03-18T16:19:04.246Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要整理了在Python学习过程中遇到的具有典型性的问题，搜集起来，以免以后遇到同样的错误重新找解决方法。</p></div><a id="more"></a><h2 id="常规报错"><a href="#常规报错" class="headerlink" title="常规报错"></a>常规报错</h2><h2 id="pandas报错"><a href="#pandas报错" class="headerlink" title="pandas报错"></a>pandas报错</h2><h2 id="jupyter报错"><a href="#jupyter报错" class="headerlink" title="jupyter报错"></a>jupyter报错</h2><h3 id="jupyter启动报错"><a href="#jupyter启动报错" class="headerlink" title="jupyter启动报错"></a>jupyter启动报错</h3><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\Scripts\jupyter-notebook-script.py"</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from notebook.notebookapp import main</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\notebookapp.py"</span>, line 81, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .services.kernels.kernelmanager import MappingKernelManager</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\services\kernels\kernelmanager.py"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.session import Session</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\session.py"</span>, line 61, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.jsonutil import extract_dates, squash_dates, date_default</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\jsonutil.py"</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from dateutil.parser import parse as _dateutil_parse</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\dateutil\parser.py"</span>, line 158</span><br><span class="line">    l.append(<span class="string">"%s=%s"</span> % (attr, `value`))</span><br><span class="line">                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall python-dateutil</span><br><span class="line">pip install python-dateutil</span><br></pre></td></tr></table></figure><hr><h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p>之前安装的将印象笔记转化为markdown格式的时候安装的包将某个包的版本降低了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ever2simple 2.0 has requirement python-dateutil&lt;2.0, but you<span class="string">'ll have python-dateutil 2.8.0 which is incompatible.</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要整理了在Python学习过程中遇到的具有典型性的问题，搜集起来，以免以后遇到同样的错误重新找解决方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>shell-数组</title>
    <link href="http://showteeth.tech/posts/46714.html"/>
    <id>http://showteeth.tech/posts/46714.html</id>
    <published>2019-03-17T10:36:25.000Z</published>
    <updated>2019-03-17T12:31:40.606Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要对Shell的数组进行了学习，主要内容包括<code>创建数组</code>、<code>数组赋值</code>、<code>读取数组</code>、<code>获取数组长度</code>、<code>获取数组使用的下标</code>、<code>在数组末尾添加元素</code>、<code>数组排序</code>、<code>删除数组</code>和<code>关联数组</code>。</p></div><a id="more"></a><h2 id="shell数组简介"><a href="#shell数组简介" class="headerlink" title="shell数组简介"></a>shell数组简介</h2><p>数组是可以存放多个值的一种数据结构，Bash shell也支持数组，但是其对数组的支持比较有限，下面列出了Bash shell数组的特征：</p><ul><li>Bash Shell <strong>只支持一维数组(不支持多维数组)</strong></li><li>初始化时<strong>不需要定义数组大小</strong></li><li>数组元素的<strong>下标由0开始</strong>(与大部分编程语言类似)</li><li>数组用<strong>括号来表示</strong>，<strong>元素用”空格”符号分割</strong>开</li></ul><hr><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="提前创建"><a href="#提前创建" class="headerlink" title="提前创建"></a>提前创建</h3><p><strong>特殊符号<code>( )</code></strong>被用于数组的声明中，因此可以使用如下命令提前创建数组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array=(element1 element2 element3 ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组时直接指定元素的索引值</span></span><br><span class="line">array=([1]=element1 [2]=element2 [3]=element3)</span><br></pre></td></tr></table></figure><p></p><p>更多关于特殊符号<code>( )</code>的用法参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><p><strong>也可以使用declare命令创建数组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array=<span class="string">'(element1 element2 element3 ...)'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p>数组变量就像其它 bash 变量一样命名，当<strong>被访问的时候，它们会被自动地创建</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[1]=foo</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  foo</span><br></pre></td></tr></table></figure><p></p><p>上面是一个赋值并访问数组元素的例子，通过<code>a[1]=foo</code>，数组索引为1(开始于0)的元素被赋值为foo(索引为0的位置可以访问，但是输出为空)；通过<code>echo ${a[1]}</code>访问数组索引为1的元素，<code>${}</code>可以进行数组操作，具体的请看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><div class="note info"><p>可以不使用连续的下标创建数组，而且下标的范围没有限制</p></div><hr><h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>在上述创建数组的过程中其实已经实现了数组的赋值：</p><ul><li><strong>单个元素</strong>赋值：<code>array[index]=value</code></li><li><strong>多个元素</strong>赋值：<code>array=(element1 element2 element3 ...)</code></li><li><strong>多个元素结合索引</strong>进行赋值：<code>array=([1]=element1 [2]=element2 [3]=element3)</code></li></ul><p><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次赋值</span></span><br><span class="line">a=(a b c)</span><br><span class="line"><span class="comment"># $&#123;a[@]&#125;是获取数组所有元素，后面会讲到</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次赋值</span></span><br><span class="line">a=(d e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a b c<br>d e f g</p></blockquote><div class="note info"><ul><li>数组的<code>index</code>是<strong>一个大于或等于零的整数（或算术表达式）</strong></li><li>数组<strong>第一个元素的下标是0</strong>， 而不是1</li><li>数组<strong>元素的值可以是一个字符串或整数</strong></li><li><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong></li></ul></div><hr><h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><h3 id="读取数组单个元素"><a href="#读取数组单个元素" class="headerlink" title="读取数组单个元素"></a>读取数组单个元素</h3><p>读取数组使用特殊符号<code>${}</code>，一般形式为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><p>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=A</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>A<br>2<br>3<br>4</p></blockquote><hr><h3 id="读取数组所有元素"><a href="#读取数组所有元素" class="headerlink" title="读取数组所有元素"></a>读取数组所有元素</h3><p><strong>如果想要获取数组的所有元素，使用<code>@</code> 或 <code>*</code></strong> :<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1 2 3 4<br>1 2 3 4</p></blockquote><p><code>@</code>和<code>*</code>的区别和使用<a href="http://showteeth.tech/posts/55603.html"><code>$*</code>或<code>$@</code>得到所有脚本变量</a>的区别相同：</p><ul><li><strong>不使用双引号括起来时完全相同</strong>：都以”element1” “element2” … “elementn” 的形式输出所有参数</li><li><strong>使用双引号括起来时不同</strong>：<code>&quot;${!array[*]}&quot;</code> 会将所有的元素作为一个整体，以”element1 element2 … elementn”的形式输出所有元素；<code>&quot;${!array[@]}&quot;</code> 会将各个元素分开，以”element1” “element2” … “elementn” 的形式输出所有元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>不使用双引号括起来时输出结果完全相同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>使用双引号括起来时输出结果不同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><blockquote><p>1 2 3 4</p></blockquote><div class="note info"><ul><li>读取数组所有元素需要注意<code>${array[*]}</code>和<code>${array[@]}</code>加引号和不加引号输出结果的区别</li><li>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong></li></ul></div><hr><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>获取数组长度(元素个数)的方法与获取字符串长度的方法相同，仍然是使用特殊符号<code>${}</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>4</p></blockquote><p><strong>如果上面不是使用了<code>@</code>和<code>*</code>，而是使用了具体的索引位置，则会得到指定索引位置的元素长度：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[1]=test_length</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[1]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>11 &emsp;&emsp;&emsp;# 输出的是test_length的长度</p></blockquote><p>还有需要注意的地方是：<strong>如果赋值时数组的索引不是连续的，数组的长度不是最大索引对应的长度，而是有具体值的索引的个数，也就是说没有赋值的那些索引不计入数组长度(但是仍然可以通过索引访问，返回结果为空)</strong>。示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[100]=100</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>5 &emsp;&emsp;&emsp;# 这里输出结果是5，而不是101，即使最后一个有值的索引为100，但是5-99的索引位置并没有赋值，也就没有计入数组长度</p></blockquote><div class="note info"><ul><li><strong>使用<code>@</code>和<code>*</code></strong>获取的是<strong>数组的长度</strong></li><li><strong>使用具体的索引位置</strong>获取的是<strong>指定索引位置的元素长度</strong></li><li><strong>未赋值的索引不计入输入长度的计算</strong></li></ul></div><hr><h2 id="获取数组使用的下标"><a href="#获取数组使用的下标" class="headerlink" title="获取数组使用的下标"></a>获取数组使用的下标</h2><p>因为shell数组允许赋值的数组下标包含 “间隔”，所以确定哪些下标在数组中是具有值的有时候很关键：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>0 1 2 3 100</p></blockquote><p><strong>和前面提到的使用双引号和不使用双引号括起来输出结果不同相同，这里两种方法在使用双引号括起来的时候也会存在差异</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;!array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;!array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><code>&quot;${!array[@]}&quot;</code>输出结果：</p><blockquote><p>0<br>1<br>2<br>3<br>100</p></blockquote><p><code>&quot;${!array[*]}&quot;</code>输出结果：</p><blockquote><p>0 1 2 3 100</p></blockquote><div class="note info"><ul><li>获取数组下标时需要注意<code>${!array[*]}</code>和<code>${!array[@]}</code>加引号和不加引号输出结果的区别</li><li><code>${array[*]}</code>和<code>${array[@]}</code>是获取数组所有元素的方法，而<code>!</code>具有取反的作用，<strong>数组元素的反理解为索引</strong>的话就很好记忆了</li></ul></div><hr><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><p>如果我们需要<strong>在数组末尾附加数据</strong>，那么知道数组中元素的个数是没用的，因为通过 <code>*</code> 和 <code>@</code>表示法返回的数值<strong>不能告诉我们使用的最大数组索引</strong>，并且<strong>直接不加索引继续赋值的话第二次的赋值会覆盖前一次的赋值结果</strong>。幸运地是，shell 为我们提供了一种解决方案：<strong>通过使用 <code>+=</code> 赋值运算符，我们能够自动地把值附加到数组末尾(索引接着最后一个索引)</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=(a b c)</span><br><span class="line"><span class="built_in">test</span>[100]=d</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>+=(e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100 101 102 103</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>Shell 没有直接对数组元素排序的方法，但是可以通过获取值然后排序再利用排序后的值重新赋值给另一个数组即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=(a d c f e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将排序后的结果赋值给新数组，这里使用了循环接入管道的操作</span></span><br><span class="line"><span class="comment"># 可以不使用新数组，直接赋值给原始数组即可覆盖原始数组的值</span></span><br><span class="line">a_sorted=($(<span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;a[@]&#125;</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span> |sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在同一行输出新数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;a_sorted[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a c d e f</p></blockquote><hr><h2 id="删除数组相关操作"><a href="#删除数组相关操作" class="headerlink" title="删除数组相关操作"></a>删除数组相关操作</h2><p>删除数组相关操作都会使用 <code>unset</code> 命令</p><h3 id="删除整个数组"><a href="#删除整个数组" class="headerlink" title="删除整个数组"></a>删除整个数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> foo</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出为空</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> <span class="string">'foo[2]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b d e f</span></span><br></pre></td></tr></table></figure><hr><h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>现在最新的 bash 版本支持关联数组了，<strong>关联数组使用字符串而不是整数作为数组索引(AWK只支持关联数组，但可以把数字下标转化为字符)</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用-A也可以使用-a</span></span><br><span class="line"><span class="comment"># 也可以直接在使用的时候创建</span></span><br><span class="line"><span class="built_in">declare</span> -A colors</span><br><span class="line">colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#ff0000 #0000ff #00ff00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种创建输出会出问题：</span></span><br><span class="line">array=([<span class="string">"red"</span>]=<span class="string">"#ff0000"</span> [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span> [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#0000ff</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/chapter4/46.html" target="_blank" rel="noopener">shell-guide</a></li><li><a href="https://baijiahao.baidu.com/s?id=1608244941950314734&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/hanframe/p/3564313.html" target="_blank" rel="noopener">shell编程中使用数组进行操作</a></li><li><a href="http://www.runoob.com/linux/linux-shell-array.html" target="_blank" rel="noopener">Shell 数组</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要对Shell的数组进行了学习，主要内容包括&lt;code&gt;创建数组&lt;/code&gt;、&lt;code&gt;数组赋值&lt;/code&gt;、&lt;code&gt;读取数组&lt;/code&gt;、&lt;code&gt;获取数组长度&lt;/code&gt;、&lt;code&gt;获取数组使用的下标&lt;/code&gt;、&lt;code&gt;在数组末尾添加元素&lt;/code&gt;、&lt;code&gt;数组排序&lt;/code&gt;、&lt;code&gt;删除数组&lt;/code&gt;和&lt;code&gt;关联数组&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="shell编程" scheme="http://showteeth.tech/categories/Linux/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git系列(一):Git简介</title>
    <link href="http://showteeth.tech/posts/60073.html"/>
    <id>http://showteeth.tech/posts/60073.html</id>
    <published>2019-03-17T02:52:57.000Z</published>
    <updated>2019-03-17T03:18:16.170Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>在有了前面两篇转载的偏实战文章的学习之后，打算针对Git进行一系列的学习，这次是偏系统，因为在实战学习中发现有些命令和操作不是很懂，同时在这篇文章的参考链接中也给出了一些Git相关的系列教程</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></li><li><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5" target="_blank" rel="noopener">Git官方教程</a></li><li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/article-8478-1.html" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/daima/git_code/" target="_blank" rel="noopener">Git实例</a></li><li></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;在有了前面两篇转载的偏实战文章的学习之后，打算针对Git进行一系列的学习，这次是偏系统，因为在实战学习中发现有些命令和操作不是很懂，同时在这篇文章的参考链接中也给出了一些Git相关的系列教程&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>转载-Git常用命令及日常问题集锦</title>
    <link href="http://showteeth.tech/posts/13404.html"/>
    <id>http://showteeth.tech/posts/13404.html</id>
    <published>2019-03-16T06:04:30.000Z</published>
    <updated>2019-03-17T04:20:56.603Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的博客，主要记录了<code>Git</code>的常用命令，包括<code>新建代码库</code>、<code>Git相关配置</code>、<code>添加文件到暂存区</code>、<code>删除工作区文件</code>、<code>代码提交</code>、<code>分支操作</code>、<code>标签</code>、<code>查看信息</code>、<code>远程同步</code>，还整理了一些使用过程中<code>常见的问题</code>。</p></div><a id="more"></a><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><ul><li>在<strong>当前目录</strong>新建一个Git代码库(初始化)：<code>git init</code></li><li><strong>新建一个目录</strong>，<strong>将其初始化</strong>为Git代码库：<code>git init [project-name]</code></li><li><strong>下载一个项目和它的整个代码历史</strong>：<code>git clone [url]</code></li></ul><hr><h2 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h2><ul><li><strong>显示当前</strong>的Git配置：<code>git config --list</code></li><li><strong>编辑</strong>Git配置文件：<code>git config -e [--global]</code></li><li><strong>设置提交代码时的用户信息</strong>：<code>git config [--global] user.name &quot;[name]&quot;</code>和<code>git config [--global] user.email &quot;[email address]&quot;</code></li></ul><hr><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><ul><li><strong>添加</strong>指定<strong>文件</strong>到<strong>暂存区</strong>：<code>git add [file1] [file2] ...</code></li><li>添加指定<strong>目录到暂存区</strong>，<strong>包括子目录</strong>：<code>git add [dir]</code></li><li>添加<strong>当前目录的所有文件到暂存区</strong>：<code>git add .</code></li><li>添加<strong>每个变化</strong>前，都会<strong>要求确认</strong>(对于<strong>同一个文件的多处变化</strong>，可以实现<strong>分次提交</strong>)：<code>git add -p</code></li></ul><hr><h2 id="删除工作区文件"><a href="#删除工作区文件" class="headerlink" title="删除工作区文件"></a>删除工作区文件</h2><ul><li><strong>删除工作区</strong>文件，并且将这次删除<strong>放入暂存区</strong>：<code>git rm [file1] [file2] ...</code></li><li><strong>停止追踪</strong>指定文件，但该文件会<strong>保留在工作区</strong>：<code>git rm --cached [file]</code></li><li><strong>改名</strong>文件，并且将这个<strong>改名放入暂存区</strong>：<code>git mv [file-original] [file-renamed]</code></li></ul><hr><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><ul><li>提交<strong>暂存区到仓库区</strong>：<code>git commit -m [message]</code></li><li>提交<strong>暂存区的指定文件到仓库区</strong>：<code>git commit [file1] [file2] ... -m [message]</code></li><li>提交<strong>工作区自上次commit之后的变化，<u>直接到仓库区</u></strong>：<code>git commit -a</code><br><br></li><li>提交时<strong>显示所有diff信息</strong>：<code>git commit -v</code><br><br></li><li><strong>使用一次新的commit，替代上一次提交(如果代码没有任何新变化，则用来改写上一次commit的提交信息)</strong>：<code>git commit --amend -m [message]</code></li><li><strong>重做上一次commit，并包括指定文件的新变化</strong>：<code>git commit --amend [file1] [file2] ...</code></li></ul><hr><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ul><li><strong>列出</strong>所有<strong>本地分支</strong>：<code>git branch</code></li><li><strong>列出</strong>所有<strong>远程分支</strong>：<code>git branch -r</code></li><li><strong>列出</strong>所有<strong>本地分支和远程分支</strong>：<code>git branch -a</code><br><br></li><li><strong>新建</strong>一个分支，但<strong>依然停留在当前分支</strong>：<code>git branch [branch-name]</code></li><li><strong>新建</strong>一个分支，并<strong>切换到该分支</strong>：<code>git checkout -b [branch]</code></li><li><strong>新建</strong>一个分支，<strong>指向指定commit</strong>：<code>git branch [branch] [commit]</code></li><li><strong>新建</strong>一个分支，<strong>与指定的远程分支建立追踪关系(连接)</strong>：<code>git branch --track [branch] [remote-branch]</code><br><br></li><li><strong>切换</strong>到<strong>指定</strong>分支，并<strong>更新工作区</strong>：<code>git checkout [branch-name]</code></li><li><strong>切换</strong>到<strong>上一个</strong>分支：<code>git checkout -</code></li><li><strong>建立追踪关系(连接)</strong>，在<strong>现有分支</strong>与<strong>指定的远程分支</strong>之间：<code>git branch --set-upstream [branch] [remote-branch]</code><br><br></li><li><strong>合并指定分支</strong>到<strong>当前分支</strong>：<code>git merge [branch]</code></li><li><strong>选择一个commit</strong>，<strong>合并进当前分支</strong>：<code>git cherry-pick [commit]</code><br><br></li><li><strong>删除</strong>分支：<code>git branch -d [branch-name]</code></li><li><strong>删除远程</strong>分支：<code>git push origin --delete [branch-name]</code>或者<code>git branch -dr [remote/branch]</code></li></ul><hr><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><strong>列出</strong>所有tag：<code>git tag</code></li><li><strong>查看</strong>tag信息：<code>git show [tag]</code><br><br></li><li><strong>新建</strong>一个tag<strong>在当前commit</strong>：<code>git tag [tag]</code></li><li><strong>新建</strong>一个tag在<strong>指定commit</strong>：<code>git tag [tag] [commit]</code><br><br></li><li><strong>删除本地</strong>tag：<code>git tag -d [tag]</code></li><li><strong>删除远程</strong>tag：<code>git push origin :refs/tags/[tagName]</code><br><br></li><li><strong>提交指定</strong>tag：<code>git push [remote] [tag]</code></li><li><strong>提交所有</strong>tag：<code>git push [remote] --tags</code><br><br></li><li><strong>新建一个分支</strong>，<strong>指向某个tag</strong>：<code>git checkout -b [branch] [tag]</code></li></ul><hr><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul><li><strong>显示有变更的文件</strong>：<code>git status</code><br><br></li><li>显示<strong>暂存区</strong>和<strong>工作区的差异</strong>：<code>git diff</code></li><li>显示<strong>暂存区</strong>和<strong>上一个commit的差异</strong>：<code>git diff --cached [file]</code></li><li>显示<strong>工作区</strong>与<strong>当前分支最新commit之间的差异</strong>：<code>git diff HEAD</code></li><li>显示<strong>两次提交之间的差异</strong>：<code>git diff [commit_1] [commit_2]</code></li><li><strong>显示今天你写了多少行代码</strong>：<code>git diff --shortstat &quot;@{0 day ago}&quot;</code><br><br></li><li>显示<strong>某次提交</strong>的<strong>元数据和内容变化</strong>：<code>git show [commit]</code></li><li>显示<strong>某次提交发生变化的文件</strong>：<code>git show --name-only [commit]</code></li><li>显示<strong>某次提交时，某个文件的内容</strong>：<code>git show [commit]:[filename]</code><br><br></li><li><strong>显示当前分支的版本历史</strong>：<code>git log</code></li><li><strong>显示commit历史</strong>，以及<strong>每次commit发生变更的文件</strong>：<code>git log --stat</code></li><li><strong>根据关键词搜索提交历史</strong>：<code>git log -S [keyword]</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>每个commit占据一行</strong>：<code>git log [tag] HEAD --pretty=format:%s</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>其”提交说明”必须符合搜索条件</strong>：<code>git log [tag] HEAD --grep feature</code></li><li>显示<strong>某个文件的版本历史</strong>，<strong>包括文件改名</strong>：<code>git log --follow [file]</code>或者<code>git whatchanged [file]</code></li><li>显示<strong>指定文件</strong>相关的<strong>每一次diff</strong>：<code>git log -p [file]</code></li><li><strong>显示过去5次提交</strong>，且<strong>每个commit占据一行</strong>：<code>git log -5 --pretty --oneline</code><br><br></li><li><strong>记录几乎当前分支的所有改变，带版本号</strong>：<code>git reflog</code><br><br></li><li>显示<strong>所有提交过的用户</strong>，<strong>按提交次数排序</strong>：<code>git shortlog -sn</code></li><li>显示<strong>指定文件</strong>是<strong>什么人在什么时间修改过</strong>：<code>git blame [file]</code></li></ul><hr><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><ul><li><strong>下载远程仓库的所有变动</strong>：<code>git fetch [remote]</code></li><li><strong>取回远程仓库的变化</strong>，并<strong>与本地分支合并</strong>：<code>git pull [remote] [branch]</code><br><br></li><li>上传<strong>本地指定分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] [branch]</code></li><li><strong>强行</strong>推送<strong>当前分支</strong>到<strong>远程仓库</strong>，<strong>即使有冲突</strong>：<code>git push [remote] --force</code></li><li>推送<strong>所有分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] --all</code><br><br></li><li><strong>显示所有远程仓库</strong>：<code>git remote -v</code></li><li>显示<strong>某个远程仓库</strong>的信息：<code>git remote show [remote]</code></li><li><strong>增加一个新的远程仓库</strong>，<strong>并命名</strong>：<code>git remote add [shortname] [url]</code></li></ul><hr><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li>恢复<strong>暂存区的指定文件</strong>到<strong>工作区</strong>：<code>git checkout [file]</code></li><li>恢复<strong>暂存区的所有文件</strong>到<strong>工作区</strong>：<code>git checkout .</code></li><li>恢复<strong>某个commit的指定文件</strong>到<strong>暂存区和工作区</strong>：<code>git checkout [commit] [file]</code><br><br></li><li>重置<strong>暂存区的指定文件</strong>，与<strong>上一次commit保持一致</strong>，但<strong>工作区不变</strong>：<code>git reset [file]</code></li><li>重置<strong>暂存区与工作区</strong>，与<strong>上一次commit保持一致</strong>：<code>git reset --hard</code></li><li>重置<strong>当前分支的指针为指定commit</strong>，同时<strong>重置暂存区</strong>，但<strong>工作区不变</strong>：<code>git reset [commit]</code></li><li>重置<strong>当前分支的HEAD为指定commit</strong>，同时<strong>重置暂存区和工作区</strong>，<strong>与指定commit一致</strong>：<code>git reset --hard [commit]</code></li><li>重置<strong>当前HEAD为指定commit</strong>，但<strong>保持暂存区</strong>和<strong>工作区不变</strong>：<code>git reset --keep [commit]</code><br><br></li><li><strong>新建一个commit</strong>，<strong>用来撤销指定commit(后者的所有变化都将被前者抵消，并且应用到当前分支)</strong>：<code>git revert [commit]</code><br><br></li><li><strong>暂时将未提交的变化移除，稍后再移入</strong>：<code>git stash</code>和<code>git stash pop</code></li></ul><div><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr><div class="RichText ztext Post-RichText"><h2 id="常见问题">常见问题</h2><h3 id="failed to push some refs to git">failed to push some refs to git</h3><p style="font-weight:700">Question1</p><div class="highlight"><pre><code class="language-text"><span></span>如何解决: failed to push some refs to git    </code></pre></div><p style="font-weight:700">Answer1</p><div class="highlight"><pre><code class="language-text"><span></span>git pull --rebase origin master  # 进行代码合并    git push -u origin master  # 即可完成代码上传    </code></pre></div><hr><h3 id="git pull未指定本地与远程连接报错">git pull未指定本地与远程连接报错</h3><p style="font-weight:700">Question2</p><p><code>If you wish to set tracking information for this branch you can do so with:</code></p><p><code>git branch --set-upstream-to=origin/ master</code></p><p style="font-weight:700">Answer2</p><p>指定当前工作分支跟远程仓库分支之间的联系</p><p><code>git branch --set-upstream master origin/master</code></p><hr><h3 id="获取最新代码报错">获取最新代码报错</h3><p style="font-weight:700">Question3</p><p><code>git pull</code> 获取最新代码报以下错误</p><p><code>fatal: refusing to merge unrelated histories</code></p><p style="font-weight:700">Answer3</p><p>git pull之后加上可选参数 --allow-unrelated-histories 强制合并</p><p><code>git pull origin master --allow-unrelated-histories</code></p><hr><h3 id="使用钩子报错">使用钩子报错</h3><p style="font-weight:700">Question4</p><p>使用钩子<code>pre-commit</code>，提交代码提示如下错误：</p><div class="highlight"><pre><code class="language-text"><span></span>$ git commit -m '.'    sh: eslint: command not found    pre-commit:    pre-commit: We've failed to pass the specified git pre-commit hooks as the `fix`    pre-commit: hook returned an exit code (1). If you're feeling adventurous you can    pre-commit: skip the git pre-commit hooks by adding the following flags to your commit:    pre-commit:    pre-commit:   git commit -n (or --no-verify)    pre-commit:    pre-commit: This is ill-advised since the commit is broken.    pre-commit:    </code></pre></div><p style="font-weight:700">Answer4</p><ul><li>打开项目中的<code>.git/hooks</code>文件夹，找到<code>pre-commit.sample</code>文件，将以下代码替换到文件中，或者，<code>npm install pre-commit --save</code>也可以，这个命令会自动执行以下操作。</li></ul><div class="highlight"><pre><code class="language-text"><span></span>#!/bin/bash    TSLINT="$(git rev-parse --show-toplevel)/node_modules/.bin/tslint"    for file in $(git diff --cached --name-only | grep -E '\.ts$')    do            git show ":$file" | "$TSLINT" "$file"            if [ $? -ne 0 ]; then                    exit 1            fi    done    </code></pre></div><ul><li>将<code>pre-commit.sample</code>文件名修改为<code>pre-commit</code>。</li></ul><hr><h3 id=".gitignore规则不生效">.gitignore规则不生效</h3><p style="font-weight:700">Question5</p><p><code>.gitignore规则不生效的解决办法</code></p><p style="font-weight:700">Answer5</p><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</p><div class="highlight"><pre><code class="language-text"><span></span>git rm -r --cached . 或者 git rm -r README.md    git add .    git commit -m 'update .gitignore'    </code></pre></div><p><br>作者：五月君<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/269298" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/26929</span><span class="invisible">8</span><span class="ellipsis"></span></a><br>来源：慕课网<br>本文首次发布于慕课网 ，转载请注明出处，谢谢合作</p></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的博客，主要记录了&lt;code&gt;Git&lt;/code&gt;的常用命令，包括&lt;code&gt;新建代码库&lt;/code&gt;、&lt;code&gt;Git相关配置&lt;/code&gt;、&lt;code&gt;添加文件到暂存区&lt;/code&gt;、&lt;code&gt;删除工作区文件&lt;/code&gt;、&lt;code&gt;代码提交&lt;/code&gt;、&lt;code&gt;分支操作&lt;/code&gt;、&lt;code&gt;标签&lt;/code&gt;、&lt;code&gt;查看信息&lt;/code&gt;、&lt;code&gt;远程同步&lt;/code&gt;，还整理了一些使用过程中&lt;code&gt;常见的问题&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>转载-Git讲解与使用实战</title>
    <link href="http://showteeth.tech/posts/13035.html"/>
    <id>http://showteeth.tech/posts/13035.html</id>
    <published>2019-03-16T05:44:08.000Z</published>
    <updated>2019-03-17T04:43:16.906Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要偏向实战，通过实战讲解Git的用法，比较全面，包括<code>创建版本库</code>、<code>版本回退</code>、<code>撤销修改和删除文件操作</code>、<code>远程仓库相关操作</code>以及<code>分支操作</code>，总的来说是一篇不错的文章。</p></div><a id="more"></a><div class="RichText ztext Post-RichText"><h2 id="简介与安装">Git简介与安装</h2><h3 id="Git是什么？">Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。工作原理 / 流程：</p><img 图片1 src="http://img.mukewang.com/59c31e4400013bc911720340.png" alt="图片描述" data-original="http://img.mukewang.com/59c31e4400013bc911720340.png" style="cursor:pointer;display:block"><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><hr><h3 id="SVN与Git的最主要的区别">SVN与Git的最主要的区别</h3><p><code>SVN</code>是<strong>集中式版本控制系统</strong>，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。<strong>集中式版本控制系统是必须联网才能工作</strong>，如果在<u>局域网</u>还可以，带宽够大，速度够快，如果在<u>互联网下</u>，如果网速慢的话，就纳闷了。</p><p><code>Git</code>是<strong>分布式版本控制系统</strong>，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就<strong>不需要联网</strong>了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><hr><h3 id="在windows上安装Git">在windows上安装Git</h3><p><code>msysgit</code>是 windows版的Git,如下：</p><img 图片2 src="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" style="cursor:pointer;display:block"><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 "Git --&gt; Git Bash",如下：<br></p><img 图片3 src="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" style="cursor:pointer;display:block"><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：<br></p><img 图片4 src="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" style="cursor:pointer;display:block"><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><img 图片5 src="http://img.mukewang.com/59c1d041000110d906460213.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1d041000110d906460213.jpg" style="cursor:pointer;display:block"><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p>注意：<code>git config --global</code> 参数，有了这个参数，表示<strong>你这台机器上所有的Git仓库都会使用这个配置</strong>，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><hr><br><h2 id="Git使用">Git使用</h2><h3 id="创建版本库">创建版本库</h3><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><img 图片6 src="http://img.mukewang.com/59c1d1060001909005780268.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d1060001909005780268.png" style="cursor:pointer;display:block"><p>pwd 命令是用于显示当前的目录。</p><h4 id="把这个目录变成git可以管理的仓库">把这个目录变成git可以管理的仓库</h4><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><img 图片7 src="http://img.mukewang.com/59c1d12b0001b08305270077.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d12b0001b08305270077.png" style="cursor:pointer;display:block"><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><img 图片8 src="http://img.mukewang.com/59c1d143000112df06120173.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d143000112df06120173.png" style="cursor:pointer;display:block"><hr><h4 id="把文件添加到版本库中">把文件添加到版本库中</h4><p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><b>示例demo：</b></p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p><strong>第一步：使用命令 <code>git add readme.txt</code>添加到暂存区</strong>里面去，如下：<br></p><img 图片9 src="http://img.mukewang.com/59c1d2080001e4bb04490080.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2080001e4bb04490080.png" style="cursor:pointer;display:block"><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p><strong>第二步：用命令 <code>git commit</code>告诉Git，把文件提交到仓库</strong>:<br></p><img 图片10 src="http://img.mukewang.com/59c1d2200001f05b04930121.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2200001f05b04930121.png" style="cursor:pointer;display:block"><p>这样我们就已经提交了一个readme.txt文件了</p><p><strong>第三步：使用命令<code>git status</code>来查看是否还有文件未提交</strong>，如下：<br></p><img 图片11 src="http://img.mukewang.com/59c1d2340001a87904690107.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2340001a87904690107.png" style="cursor:pointer;display:block"><p>说明没有任何文件未提交</p><p><strong>第四步：继续来修改readme.txt内容，比如我在下面添加一行2222222222内容，继续使用<code>git status</code>来查看下结果</strong>，如下：<br></p><img 图片12 src="http://img.mukewang.com/59c1d2500001634606170171.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2500001634606170171.png" style="cursor:pointer;display:block"><p>上面的命令告诉我们 readme.txt文件已被修改，但是<strong>未被提交的修改</strong>。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？</p><p><strong>第五步：使用<code>git diff readme.txt</code>查看文件到底改了什么内容</strong>，如下：<br></p><img 图片13 src="http://img.mukewang.com/59c1d2cb00010a0304960202.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2cb00010a0304960202.png" style="cursor:pointer;display:block"><p>如上可以看到，readme.txt文件内容从一行11111111改成二行添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是<code>git add</code>；第二步是：<code>git commit</code>)，如下：<br></p><img 图片14 src="http://img.mukewang.com/59c1d2ff00015a9606180342.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2ff00015a9606180342.png" style="cursor:pointer;display:block"><hr><br><h3 id="版本回退">版本回退</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为<strong>33333333333333</strong>继续执行命令如下：</p><img 图片15 src="http://img.mukewang.com/59c1d32b00012ba604570139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d32b00012ba604570139.png" style="cursor:pointer;display:block"><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？</p><h4 id="使用命令 git log 查看历史记录">使用命令 git log 查看历史记录</h4><img 图片16 src="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" style="cursor:pointer;display:block"><p><code>git log</code>命令显示<strong>从最近到最远</strong>的修改日志，我们可以看到最近有三次提交，最近的一次是：增加内容为333333；上一次是添加内容222222；第一次默认是 111111.<br></p><p>如果<strong>嫌上面显示的信息太多的话，我们可以使用命令 <code>git log –pretty=oneline</code></strong>演示如下：<br></p><img 图片17 src="http://img.mukewang.com/59c1d3fc00013ad206040097.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d3fc00013ad206040097.png" style="cursor:pointer;display:block"><hr><h4 id="使用命令 git reset 进行版本回退">使用命令 git reset 进行版本回退</h4><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令：<br></p><ul><li>第一种是：<code>git reset --hard HEAD^</code>，那么如果要回退到<strong>上上个版本只需把HEAD^ 改成 HEAD^^，以此类推</strong></li><li>第二种是：<code>git reset --hard HEAD~1</code>，第一种方法如果要回退到前100个版本的话，肯定不方便，这时可以使用简便命令操作：<code>git reset --hard HEAD~100</code></li></ul><p><strong>未回退之前</strong>的readme.txt内容如下：<br></p><img 图片18 src="http://img.mukewang.com/59c1d4140001a0c404490165.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4140001a0c404490165.png" style="cursor:pointer;display:block"><p>如果想<strong>回退到上一个版本</strong>的命令如下操作：</p><img 图片19 src="http://img.mukewang.com/59c1d429000199fc04610105.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d429000199fc04610105.png" style="cursor:pointer;display:block"><p><strong>使用命令cat readme.txt查看下 readme.txt内容</strong>，如下：<br></p><img 图片20 src="http://img.mukewang.com/59c1d4470001fcdc04360085.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4470001fcdc04360085.png" style="cursor:pointer;display:block"><p>可以看到，<strong>内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息</strong>，如下：<br></p><img 图片21 src="http://img.mukewang.com/59c1d45300012d9604800219.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d45300012d9604800219.png" style="cursor:pointer;display:block"><p>发现增加333333内容已经没有了</p><hr><h4 id="使用命令 git reset 结合 git reflog 进行版本号回退">使用命令 git reset 结合 git reflog 进行版本号回退</h4><p>如果现在想<strong>回退到最新的版本</strong>，如：有333333的内容要如何恢复呢？我们可以<strong>通过版本号回退</strong>，使用命令：<code>git reset --hard 版本号</code> ，但是现在的问题<strong>假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？</strong><br></p><p>可以<strong>通过<code>git reflog</code>命令获取到版本号</strong>，演示如下：<br></p><img 图片22 src="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" style="cursor:pointer;display:block"><p>通过上面的显示我们可以知道，增加内容3333的版本号是 <code>6fcfc89</code>。我们现在可以使用命令：<code>git reset --hard 6fcfc89</code>来恢复了，演示如下：<br></p><img 图片23 src="http://img.mukewang.com/59c1d53a0001b8b305050153.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d53a0001b8b305050153.png" style="cursor:pointer;display:block"><p>可以看到目前已经是最新的版本了。</p><hr><br><h3 id="理解工作区与暂存区的区别">理解工作区与暂存区的区别</h3><ul><li>工作区：就是你在<strong>电脑上看到的目录</strong>，比如目录下testgit里的文件(<code>.git</code>隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li><li>版本库(Repository)：<strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库</strong>。其中版本库里面存了很多东西，其中最重要的就是<strong>stage(暂存区)</strong>，还有Git为我们<strong>自动创建了第一个分支master</strong>,以及<strong>指向master的一个指针HEAD</strong>。</li></ul><p>我们前面说过使用<strong>Git提交文件到版本库有两步</strong>：</p><ul><li>第一步：是使用<code>git add</code>把文件添加进去，实际上就是把文件<strong>添加到暂存区</strong></li><li>第二步：使用<code>git commit</code>提交更改，实际上就是<strong>把暂存区的所有内容提交到当前分支上</strong></li></ul><p>继续使用demo来演示下：</p><p>我们在readme.txt再<u>添加一行内容为4444444</u>，接着在目录下<u>新建一个文件为test.txt 内容为test</u>，我们先用命令<code>git status</code>来查看下状态，如下：</p><img 图片24 src="http://img.mukewang.com/59c1d55a0001a3c306430241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d55a0001a3c306430241.png" style="cursor:pointer;display:block"><p>现在我们先<strong>使用<code>git add</code>命令把2个文件都添加到暂存区</strong>中，再使用<code>git status</code>来查看下状态，如下：</p><img 图片25 src="http://img.mukewang.com/59c1d56a0001a28704700241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d56a0001a28704700241.png" style="cursor:pointer;display:block"><p>接着我们可以<strong>使用<code>git commit</code>一次性提交到分支上</strong>，如下：</p><img 图片26 src="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" style="cursor:pointer;display:block"><hr><br><h3 id="撤销修改和删除文件操作">撤销修改和删除文件操作</h3><h4 id="撤销修改">撤销修改</h4><p>现在在readme.txt文件里面增加一行内容为555555555555，我们先通过命令查看如下：<br></p><img 图片27 src="http://img.mukewang.com/59c1d5e40001806803930139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5e40001806803930139.png" style="cursor:pointer;display:block"><p>在我<strong>未提交之前</strong>，我发现添加5555555555555内容有误，所以我得马上<strong>恢复以前的版本</strong>，现在我可以有如下几种方法可以做修改：</p><ul><li>第一：如果我知道要删掉那些内容的话，直接<strong>手动更改</strong>去掉那些需要的文件，然后add添加到暂存区，最后commit掉</li><li>第二：使用<code>git reset --hard HEAD^</code>直接恢复到上一个版本</li><li>第三：使用撤销命令<code>git checkout --</code>，下面讲解如何使用撤销命令</li></ul><p>首先在做撤销之前，我们可以先用<code>git status</code>查看下当前的状态。如下所示：</p><img 图片28 src="http://img.mukewang.com/59c1d5fa0001b07806400168.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5fa0001b07806400168.png" style="cursor:pointer;display:block"><p>可以发现，Git会告诉你，<strong><code>git checkout -- file</code>可以丢弃工作区的修改</strong>，例如使用<code>git checkout -- readme.txt</code>：</p><img 图片29 src="http://img.mukewang.com/59c1d6390001419705210140.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6390001419705210140.png" style="cursor:pointer;display:block"><p><strong>命令<code>git checkout --readme.txt</code>意思就是：把readme.txt文件在工作区做的修改全部撤销</strong>，这里有2种情况：</p><ul><li>readme.txt自动修改后，还<strong>没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态</strong></li><li>readme.txt<strong>已经放入暂存区了，接着又作了修改，撤销修改就回到<u>添加暂存区后</u>的状态</strong></li></ul><p><strong>也就是说<code>git checkout --readme.txt</code>只能撤销没有提交到暂存区的修改</strong></p><p>对于上面列举的<strong>第二种情况</strong>，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我<code>git add</code>添加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><img 图片30 src="http://img.mukewang.com/59c1d6ca0001782f06160482.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6ca0001782f06160482.png" style="cursor:pointer;display:block"><p><mark>注意：命令<code>git checkout -- readme.txt</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了。</mark></p><hr><h4 id="删除文件">删除文件</h4><p>假如我现在版本库testgit目录<u>添加一个文件b.txt,然后提交</u>，如下：<br></p><img 图片31 src="http://img.mukewang.com/59c1d6de0001a31606390392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6de0001a31606390392.png" style="cursor:pointer;display:block"><p>如上：一般情况下，可以<strong>直接在文件目录中把文件删了</strong>，或者<strong>使用如上<code>rm</code>命令：<code>rm b.txt</code></strong>，如果我想<strong>彻底从版本库中删掉了此文件的话，可以再执行commit命令提交掉</strong>，现在目录是这样的：<br></p><img 图片32 src="http://img.mukewang.com/59c1d78200017e8f07030192.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d78200017e8f07030192.png" style="cursor:pointer;display:block"><hr><h4 id="撤销删除操作">撤销删除操作</h4><p>只要<strong><u>没有commit之前</u>，如果我想在版本库中恢复此文件如何操作呢？</strong>，可以使用如下命令<strong><code>git checkout -- b.txt</code></strong>，如下所示：</p><img 图片33 src="http://img.mukewang.com/59c1d7980001368e05570244.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7980001368e05570244.png" style="cursor:pointer;display:block"><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><img 图片34 src="http://img.mukewang.com/59c1d7b70001308907550258.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7b70001308907550258.png" style="cursor:pointer;display:block"><hr><br><h3 id="远程仓库">远程仓库</h3><h4 id="建立传输连接">建立传输连接</h4><p>以Github为例进行远程仓库的操作，首先需要建立本地Git仓库和Github仓库之间的传输(通过SSH加密的)连接</p><p><strong>第一步：创建SSHKey</strong>。在用户主目录下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入命令：<code>ssh-keygen -t rsa –C “youremail@example.com”</code>, 结果如下所示：</p><img 图片35 src="http://img.mukewang.com/59c1d7d7000120d107530169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7d7000120d107530169.png" style="cursor:pointer;display:block"><p>注意：<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第二步：在Github中添加公钥</strong>。登录Github,打开“settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴<code>id_rsa.pub</code>文件的内容。<br></p><img 图片36 src="http://img.mukewang.com/59c1d7ef0001c75411330860.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7ef0001c75411330860.png" style="cursor:pointer;display:block"><p>点击Add Key，你就应该可以看到已经添加的key。<br></p><img 图片37 src="http://img.mukewang.com/59c1d8540001eb3707620373.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8540001eb3707620373.png" style="cursor:pointer;display:block"><hr><h4 id="添加远程库">添加远程库</h4><p><strong>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在Github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样Github的仓库可以作为备份，又可以其他人通过该仓库来协作。</strong></p><p>首先，登录Github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><img 图片38 src="http://img.mukewang.com/59c1d86a0001044b10840605.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d86a0001044b10840605.png" style="cursor:pointer;display:block"><p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br></p><img 图片39 src="http://img.mukewang.com/59c1d8850001b5ea10260661.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8850001b5ea10260661.png" style="cursor:pointer;display:block"><p>目前，在GitHub上的这个testgit仓库还是空的，GitHub提示我们，<strong>可以从这个仓库克隆出新的仓库</strong>，<strong>也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库</strong>。<br>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p><img 图片40 src="http://img.mukewang.com/59c1d8a70001c86206320252.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8a70001c86206320252.png" style="cursor:pointer;display:block"><p><strong>把本地库的内容推送到远程，使用<code>git push</code>命令，实际上是把当前分支master推送到远程。</strong></p><div class="note info"><p>由于远程库是空的，我们第一次推送master分支时，加上了<code>–u</code>参数，<strong>Git不但会把本地的master分支内容推送的远程新的master分支</strong>，还会<strong>把本地的master分支和远程的master分支关联起来</strong>，在以后的推送或者拉取时就可以简化命令。</p></div><p>推送成功后，可以立刻在Github页面中看到远程库的内容已经和本地一模一样了:<br></p><img 图片41 src="http://img.mukewang.com/59c1d8bb00019ff310480655.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8bb00019ff310480655.png" style="cursor:pointer;display:block"><p><strong>从现在起，只要本地作了提交，就可以通过命令：<code>git push origin master</code>把本地master分支的最新修改推送到Github上了，现在你就拥有了真正的分布式版本库了。</strong></p><hr><h4 id="克隆远程库到本地">克隆远程库到本地</h4><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。现在我们想，假如<strong>远程库有新的内容了，我想克隆到本地来，如何克隆呢？</strong></p><p>首先，登录Github，创建一个新的仓库，名字叫testgit2，如下：</p><img 图片42 src="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" style="cursor:pointer;display:block"> <img 图片43 src="http://img.mukewang.com/59c1d97400014d4e10360484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d97400014d4e10360484.png" style="cursor:pointer;display:block"><p>接下来，使用命令<code>git clone</code>克隆一个本地库了。如下所示：</p><img 图片44 src="http://img.mukewang.com/59c1d9860001e0d806370127.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9860001e0d806370127.png" style="cursor:pointer;display:block"><p>操作完成后可以发现在我本地目录下生成testgit2目录了，如下所示：</p><img 图片45 src="http://img.mukewang.com/59c1d99500016a2e07130197.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d99500016a2e07130197.png" style="cursor:pointer;display:block"><hr><br><h3 id="分支操作">分支操作</h3><p>在版本回填退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<strong>主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p><strong>Git的分支操作主要包括：创建分支、合并分支、删除分支</strong></p><h4 id="创建分支">创建分支</h4><p>首先，我们来<strong>创建dev分支</strong>，然后<strong>切换到dev分支上</strong>，如下操作：</p><img 图片46 src="http://img.mukewang.com/59c1d9aa0001c15604080167.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9aa0001c15604080167.png" style="cursor:pointer;display:block"><div class="note info"><ul><li><strong><code>git checkout</code>命令加上<code>–b</code>参数表示创建并切换，相当于2条命令</strong>：<ul><li><strong><code>git branch dev</code>(新建分支)</strong></li><li><strong><code>git checkout dev</code>(切换分支)</strong></li></ul></li><li><strong><code>git branch</code>查看分支，会列出所有的分支，当前分支前面会添加一个星号</strong></li></ul></div><p>接下来我们<strong>在dev分支上</strong>继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><img 图片47 src="http://img.mukewang.com/59c1da3f0001b5b703890392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da3f0001b5b703890392.png" style="cursor:pointer;display:block"><p>现在dev分支工作已完成，现在我们<strong>切换到主分支master</strong>上，继续查看readme.txt内容如下：</p><img 图片48 src="http://img.mukewang.com/59c1da520001d44c06340206.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da520001d44c06340206.png" style="cursor:pointer;display:block"><div class="note info"><p>不同分支上的内容修改是不共享的，如果想要共享需要使用合并操作，具体请看下文</p></div><hr><h4 id="合并分支">合并分支</h4><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令<code>git merge dev</code>如下所示：<br></p><img 图片49 src="http://img.mukewang.com/59c1da69000145ca05320255.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da69000145ca05320255.png" style="cursor:pointer;display:block"><ul><li><strong><code>git merge</code>命令用于合并指定分支到当前分支上</strong>，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的</li><li><strong>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快</strong></li></ul><hr><h4 id="删除分支">删除分支</h4><p>合并完成后，我们可以使用命令<code>git branch –d dev</code>删除dev分支了，操作如下：</p><img 图片50 src="http://img.mukewang.com/59c1da91000120cd06430139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da91000120cd06430139.png" style="cursor:pointer;display:block"><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><hr><h4 id="分支合并冲突">分支合并冲突</h4><p><mark>当我们同时在两个分支中修改同一个文件，并将其合并的时候会出现分支合并冲突</mark>，示例如下：<br><strong>首先</strong>，先新建一个新分支，比如名字叫fenzhi1，<strong>在readme.txt添加一行内容8888888，然后提交</strong>，如下所示：<br></p><img 图片51 src="http://img.mukewang.com/59c1db410001036105690462.png" alt="图片描述" data-original="http://img.mukewang.com/59c1db410001036105690462.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，我们现在<strong>切换到master分支上来，也在readme.txt最后一行添加内容，内容为99999999，然后提交</strong>，如下所示：</p><img 图片52 src="http://img.mukewang.com/59c1daaf0001133205840500.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daaf0001133205840500.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们在master分支上来合并fenzhi1，<strong>直接使用<code>git merge</code>会提示conflict，然后使用<code>git status</code>查看发现在两个分支中readme.txt都被修改了，此时打开readme.txt文件发现出现了冲突的内容显示</strong>，具体内容和操作截图如下：</p><img 图片53 src="http://img.mukewang.com/59c1daff000106eb06340589.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daff000106eb06340589.png" style="cursor:pointer;display:block"><p><strong>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以手动对readme.txt文件进行如下修改后保存</strong>：<br></p><img 图片54 src="http://img.mukewang.com/59c1dbaf00015f2205770266.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbaf00015f2205770266.png" style="cursor:pointer;display:block"><p><strong>最后</strong>，使用命令<code>git log</code>命令查看分支合并的情况：<br></p><img 图片55 src="http://img.mukewang.com/59c1dbc50001076c04970869.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbc50001076c04970869.png" style="cursor:pointer;display:block"><hr><h4 id="分支合并模式">分支合并模式</h4><p><strong>通常合并分支时，Git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</strong><br>首先我们来做demo演示下：</p><div class="highlight"><pre><code class="language-text">            创建一个dev分支;            修改readme.txt内容;            添加到暂存区;            切换回主分支(master);            合并dev分支，使用命令 git merge –no-ff -m “注释” dev;            查看历史记录;        </code></pre></div><img 图片56 src="http://img.mukewang.com/59c1dbdc0001836d06030780.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbdc0001836d06030780.png" style="cursor:pointer;display:block"><hr><h4 id="分支管理策略">分支管理策略</h4><div class="note info"><p><strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</strong></p></div><hr><h4 id="创建bug分支">创建bug分支</h4><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，<strong>每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</strong></p><p>例如，我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，<strong>当前的dev分支上的工作还没有提交</strong>，具体如下：</p><img 图片57 src="http://img.mukewang.com/59c1dc4e000141b306260166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc4e000141b306260166.png" style="cursor:pointer;display:block"><p><strong>这里并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成</strong>。怎么办呢？还好，<strong>Git还提供了一个<code>stash</code>功能，可以把当前工作现场”隐藏起来”，等以后恢复现场后继续工作</strong>。如下：</p><img 图片58 src="http://img.mukewang.com/59c1dc63000121ff06510188.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc63000121ff06510188.png" style="cursor:pointer;display:block"><p>现在我可以通过创建issue-404分支来修复bug了，具体的实施步骤如下：</p><p><strong>首先</strong>，我们要<strong>确定在哪个分支上修复bug</strong>，比如我现在是在主分支master上来修复的，现在我要在master分支上<strong>创建</strong>一个临时分支，演示如下：</p><img 图片59 src="http://img.mukewang.com/59c1dc7000010f8506010533.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc7000010f8506010533.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，在<strong>修复完成</strong>后<strong>切换</strong>到master分支上，并完成<strong>合并</strong>，最后<strong>删除</strong>issue-404分支。演示如下：</p><img 图片60 src="http://img.mukewang.com/59c1dce00001c1ed06120441.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dce00001c1ed06120441.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们<strong>回到dev分支</strong>上干活:<br></p><img 图片61 src="http://img.mukewang.com/59c1dcfa00019c8104220136.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dcfa00019c8104220136.png" style="cursor:pointer;display:block"><p><strong>但是</strong>，我们发现<strong>工作区是干净的</strong>，那么我们工作现场去哪里呢？我们可以<strong>使用命令<code>git stash list</code>来查看工作现场</strong>。如下：</p><img 图片62 src="http://img.mukewang.com/59c1dd07000152b404340093.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd07000152b404340093.png" style="cursor:pointer;display:block"><p>通过<code>git stash list</code>发现工作现场还在，Git把<code>stash</code>内容存在某个地方了，但是需要<strong>恢复</strong>一下，可以使用如下2个方法：</p><ul><li><code>git stash apply</code>恢复，<strong>恢复后，<code>stash</code>内容并不删除，你需要使用命令<code>git stash drop</code>来删除</strong></li><li>另一种方式是使用<code>git stash pop</code>，<strong>恢复的同时把<code>stash</code>内容也删除了</strong></li></ul><p>示例如下：</p><img 图片63 src="http://img.mukewang.com/59c1dd1f000174d406380466.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd1f000174d406380466.png" style="cursor:pointer;display:block"><hr><h4 id="多人协作">多人协作</h4><h5 id="查看远程库的信息">查看远程库的信息</h5><p>当你从<strong>远程库克隆</strong>时候，<strong>实际上Git自动把本地的master分支和远程的master分支对应起来了，并且<u>远程库的默认名称是origin</u>。</strong></p><p>要<strong>查看远程库的信息</strong>，使用<code>git remote</code><br>要<strong>查看远程库的详细信息</strong>，使用<code>git remote –v</code>，具体操作如下：</p><img 图片64 src="http://img.mukewang.com/59c1dd7d000136fd06190169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd7d000136fd06190169.png" style="cursor:pointer;display:block"><hr><h5 id="推送分支">推送分支</h5><p>推送分支就是<strong>把该分支上所有本地提交到远程库</strong>中，推送时<strong>要指定本地分支</strong>，这样Git就会<strong>把该分支推送到远程库对应的远程分支上</strong></p><p><strong>把本地分支推送到远程分支</strong>，使用<code>git push origin master</code></p><p>例如，我的<strong>Github(远程库)</strong>上的readme.txt代码如下：<br></p><img 图片65 src="http://img.mukewang.com/59c1dd90000164a508280459.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd90000164a508280459.png" style="cursor:pointer;display:block"><p><strong>本地</strong>的readme.txt代码如下：<br></p><img 图片66 src="http://img.mukewang.com/59c1dda60001771804210205.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dda60001771804210205.png" style="cursor:pointer;display:block"><p>现在我想把<strong>本地更新</strong>的readme.txt代码<strong>推送到远程库</strong>中，使用命令如下：<br></p><img 图片67 src="http://img.mukewang.com/59c1ddbf0001271e05410203.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddbf0001271e05410203.png" style="cursor:pointer;display:block"><p>我们可以看到如上Git信息提示，推送成功，然后我们可以看看Github上的readme.txt内容 如下：</p><img 图片68 src="http://img.mukewang.com/59c1ddcf0001771f08100484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddcf0001771f08100484.png" style="cursor:pointer;display:block"><p>可以看到推送成功了，如果我们现在要<strong>推送到其他分支</strong>，比如dev分支上，我们还是那个命令<code>git push origin dev</code></p><div class="note info"><p>那么一般情况下，那些分支要推送呢？</p><p><strong>master分支是主分支</strong>，因此要<strong>时刻与远程同步</strong>；一些<strong>修复bug分支不需要推送到远程去</strong>，可以<strong>先合并</strong>到主分支(或者dev分支)上，然后把主分支master(或者dev分支)推送到远程去</p></div><hr><h5 id="抓取分支">抓取分支</h5><p><strong>多人协作时，大家都会往master分支上推送各自的修改</strong>。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到Github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2，具体的协作步骤如下：</p><p><strong>首先</strong>，我要把dev分支也要<strong>推送</strong>到远程去，如下：</p><img 图片69 src="http://img.mukewang.com/59c1ded800014adf05030151.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1ded800014adf05030151.jpg" style="cursor:pointer;display:block"><p><strong>然后</strong>，进入testgit2目录，进行<strong>克隆</strong>远程的库到本地来(模拟的协作)，如下：<br></p><img 图片70 src="http://img.mukewang.com/59c1deb70001ec7605080170.png" alt="图片描述" data-original="http://img.mukewang.com/59c1deb70001ec7605080170.png" style="cursor:pointer;display:block"><p>现在目录下生成有如下所示：<br></p><img 图片71 src="http://img.mukewang.com/59c1defe0001942707180256.png" alt="图片描述" data-original="http://img.mukewang.com/59c1defe0001942707180256.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们的小伙伴要在dev分支上做开发，就必须<strong>把远程的origin的dev分支到本地来</strong>，于是可以<strong>使用命令创建本地dev分支：<code>git checkout –b dev origin/dev</code></strong>。创建完成后，小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时，如下：<br></p><img 图片72 src="http://img.mukewang.com/59c1df160001ef1e06020730.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df160001ef1e06020730.png" style="cursor:pointer;display:block"><p><strong>下一步</strong>，小伙伴们<strong>已经向origin/dev分支上推送了提交</strong>，而我在<strong>我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库</strong>时，如下：<br></p><img 图片73 src="http://img.mukewang.com/59c1df340001209306470759.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df340001209306470759.png" style="cursor:pointer;display:block"><p>由上面可知：推送失败，<strong>因为我的小伙伴最新提交的和我试图推送的有冲突</strong>，<strong>解决的办法</strong>也很简单，上面已经提示我们，<strong>先用<code>git pull</code>把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</strong></p><img 图片74 src="http://img.mukewang.com/59c1dfa60001473e05940282.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfa60001473e05940282.png" style="cursor:pointer;display:block"><p><code>git pull</code>也失败了，原因是<strong>没有指定本地dev分支与远程origin/dev分支的链接</strong>，根据提示，<strong>设置dev和origin/dev的链接，使用<code>git branch --set-upstream dev origin/dev</code></strong>，如下：</p><img 图片75 src="http://img.mukewang.com/59c1dfc8000159c106460199.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfc8000159c106460199.png" style="cursor:pointer;display:block"><p>这回git pull成功，但是<strong>合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</strong>。解决后，提交，再push。我们可以先来看看readme.txt内容：</p><img 图片76 src="http://img.mukewang.com/59c1dff70001a87605190277.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dff70001a87605190277.png" style="cursor:pointer;display:block"><p>手动解决完后，接着再提交，再push到远程库里面去。如下所示：<br></p><img 图片77 src="http://img.mukewang.com/59c1e0130001843906050480.png" alt="图片描述" data-original="http://img.mukewang.com/59c1e0130001843906050480.png" style="cursor:pointer;display:block"><div class="note info"><p>总结一下，多人协作工作模式一般是这样的：</p><ul><li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li><li>如果<strong>推送失败</strong>，则因为远程分支比你的本地更新早，需要先用<code>git pull</code>试图合并；</li><li>如果<strong>合并有冲突</strong>，则需要解决冲突，并在本地提交，然后再用<code>git push origin branch-name</code>推送。</li></ul></div><p>感谢龙恩的贡献：<a href="http://link.zhihu.com/?target=http%3A//www.cnblogs.com/tugenhua0707/p/4050072.html" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">cnblogs.com/tugenhua070</span><span class="invisible">7/p/4050072.html</span><span class="ellipsis"></span></a></p><hr><br><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，主要偏向实战，通过实战讲解Git的用法，比较全面，包括&lt;code&gt;创建版本库&lt;/code&gt;、&lt;code&gt;版本回退&lt;/code&gt;、&lt;code&gt;撤销修改和删除文件操作&lt;/code&gt;、&lt;code&gt;远程仓库相关操作&lt;/code&gt;以及&lt;code&gt;分支操作&lt;/code&gt;，总的来说是一篇不错的文章。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>shell解析命令行过程以及eval命令</title>
    <link href="http://showteeth.tech/posts/29719.html"/>
    <id>http://showteeth.tech/posts/29719.html</id>
    <published>2019-03-15T13:46:10.000Z</published>
    <updated>2019-03-17T02:21:59.222Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的过程以及eval命令</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>HTML常用字符实体</title>
    <link href="http://showteeth.tech/posts/45689.html"/>
    <id>http://showteeth.tech/posts/45689.html</id>
    <published>2019-03-15T10:33:39.000Z</published>
    <updated>2019-03-15T13:17:01.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括<code>特色字符实体</code>、<code>常用字符实体</code>、<code>货币类字符实体</code>、<code>数字类字符实体</code>、<code>方向类字符实体</code>以及<code>其他字符实体</code>，以供需要时查阅</p></div><a id="more"></a><h2 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h2><p>一些字符在 HTML 中拥有特殊的含义，比如小于号<code>&lt;</code>用于定义 HTML 标签的开始，在这种情况下如果我们<strong>希望浏览器正确地显示这些字符</strong>，我们必须在 HTML 源码中<strong>插入字符实体</strong>来使HTML不将其当做具有特殊含义的字符，例如，要在 HTML 文档中显示小于号，我们需要这样写：<code>&amp;lt;</code> 或者 <code>&amp;#60;</code>。</p><p><strong>字符实体有三部分：</strong></p><ul><li>一个和号<code>&amp;</code></li><li>一个实体名称，或者 <code>#</code> 和一个实体编号</li><li>以及一个分号 <code>;</code></li></ul><p>使用<strong>实体名称</strong>而<strong>不是实体编号</strong>的<strong>好处</strong>在于，名称相对来说更容易记忆；而这么做的<strong>坏处</strong>是，并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。</p><p><strong>注意：实体对大小写敏感。</strong></p><hr><h2 id="特色HTML字符实体"><a href="#特色HTML字符实体" class="headerlink" title="特色HTML字符实体"></a>特色HTML字符实体</h2><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:40%}</style><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线，常用作菜单或导航中的分隔符</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>圆点，有时被用来作为菜单分隔符</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头，常用作网页“返回页面顶部”标识</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元标识</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2，数学中的平方，在数字处理中常用到，例如：<strong>1000²</strong></td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>心型，用来表达你的心</td></tr></tbody></table><hr><h2 id="常用HTML字符实体"><a href="#常用HTML字符实体" class="headerlink" title="常用HTML字符实体"></a>常用HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&nbsp;</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td>空格</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td>&amp;#38;</td><td>and符号，与</td></tr><tr><td>"</td><td>&amp;quot;</td><td>&amp;#34;</td><td>引号</td></tr><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>®</td><td>&amp;reg;</td><td>&amp;#187;</td><td>注册标志</td></tr><tr><td>™</td><td>&amp;trade;</td><td>&amp;#153;</td><td>商标标志</td></tr><tr><td>“</td><td>&amp;ldquo;</td><td>&amp;#147;</td><td>左双引号</td></tr><tr><td>”</td><td>&amp;rdquo;</td><td>&amp;#148;</td><td>右双引号</td></tr><tr><td>‘</td><td>&amp;lsquo;</td><td>&amp;#145;</td><td>做单引号</td></tr><tr><td>’</td><td>&amp;rsquo;</td><td>&amp;#146;</td><td>右单引号</td></tr><tr><td>«</td><td>&amp;laquo;</td><td>&amp;#171;</td><td>左三角双引号</td></tr><tr><td>»</td><td>&amp;raquo;</td><td>&amp;#187;</td><td>右三角双引号</td></tr><tr><td>‹</td><td>&amp;lsaquo;</td><td>&amp;#8249;</td><td>左三角单引号</td></tr><tr><td>›</td><td>&amp;rsaquo;</td><td>&amp;#8250;</td><td>右三角单引号</td></tr><tr><td>§</td><td>&amp;sect;</td><td>&amp;#167;</td><td>章节标志</td></tr><tr><td>¶</td><td>&amp;para;</td><td>&amp;#182;</td><td>段落标志</td></tr><tr><td>•</td><td>&amp;bull;</td><td>&amp;#149;</td><td>列表圆点（大）</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>列表圆点（中）</td></tr><tr><td>…</td><td>&amp;hellip;</td><td>&amp;#8230;</td><td>省略号</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线</td></tr><tr><td>¦</td><td>&amp;brvbar;</td><td>&amp;#166;</td><td>断的竖线</td></tr><tr><td>–</td><td>&amp;ndash;</td><td>&amp;#150;</td><td>短破折号</td></tr><tr><td>—</td><td>&amp;mdash;</td><td>&amp;#151;</td><td>长破折号</td></tr></tbody></table><hr><h2 id="货币类HTML字符实体"><a href="#货币类HTML字符实体" class="headerlink" title="货币类HTML字符实体"></a>货币类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>¤</td><td>&amp;curren;</td><td>&amp;#164;</td><td>一般货币符号</td></tr><tr><td>$</td><td>&nbsp;</td><td>&amp;#36;</td><td>美元符号</td></tr><tr><td>¢</td><td>&amp;cent;</td><td>&amp;#162;</td><td>分</td></tr><tr><td>£</td><td>&amp;pound;</td><td>&amp;#163;</td><td>英镑</td></tr><tr><td>¥</td><td>&amp;yen;</td><td>&amp;#165;</td><td>日元</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元</td></tr></tbody></table><hr><h2 id="数字类HTML字符实体"><a href="#数字类HTML字符实体" class="headerlink" title="数字类HTML字符实体"></a>数字类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&amp;#60;</td><td>小于号</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&amp;#62;</td><td>大于号</td></tr><tr><td>≤</td><td>&amp;le;</td><td>&amp;#8804;</td><td>小于等于号</td></tr><tr><td>≥</td><td>&amp;ge;</td><td>&amp;#8805;</td><td>大于等于号</td></tr><tr><td>×</td><td>&amp;times;</td><td>&amp;#215;</td><td>乘号</td></tr><tr><td>÷</td><td>&amp;divide;</td><td>&amp;#247;</td><td>除号</td></tr><tr><td>−</td><td>&amp;minus;</td><td>&amp;#8722;</td><td>减号</td></tr><tr><td>±</td><td>&amp;plusmn;</td><td>&amp;#177;</td><td>加/减 号</td></tr><tr><td>≠</td><td>&amp;ne;</td><td>&amp;#8800;</td><td>不等于号</td></tr><tr><td>¹</td><td>&amp;sup1;</td><td>&amp;#185;</td><td>上标1</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2</td></tr><tr><td>³</td><td>&amp;sup3;</td><td>&amp;#179;</td><td>上标3</td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>¼</td><td>&amp;frac14;</td><td>&amp;#188;</td><td>四分之一</td></tr><tr><td>¾</td><td>&amp;frac34;</td><td>&amp;#190;</td><td>四分之三</td></tr><tr><td>‰</td><td>&amp;permil;</td><td>&amp;#8240;</td><td>千分率</td></tr><tr><td>°</td><td>&amp;deg;</td><td>&amp;#176;</td><td>度</td></tr><tr><td>√</td><td>&amp;radic;</td><td>&amp;#8730;</td><td>平方根</td></tr><tr><td>∞</td><td>&amp;infin;</td><td>&amp;#8734;</td><td>无限大</td></tr></tbody></table><hr><h2 id="方向类HTML字符实体"><a href="#方向类HTML字符实体" class="headerlink" title="方向类HTML字符实体"></a>方向类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>←</td><td>&amp;larr;</td><td>&amp;#8592;</td><td>左箭头</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头</td></tr><tr><td>→</td><td>&amp;rarr;</td><td>&amp;#8594;</td><td>右箭头</td></tr><tr><td>↓</td><td>&amp;darr;</td><td>&amp;#8595;</td><td>下箭头</td></tr><tr><td>↔</td><td>&amp;harr;</td><td>&amp;#8596;</td><td>左右箭头</td></tr><tr><td>↵</td><td>&amp;crarr;</td><td>&amp;#8629;</td><td>回车箭头</td></tr><tr><td>⌈</td><td>&amp;lceil;</td><td>&amp;#8968;</td><td>左上限</td></tr><tr><td><strong>⌉</strong></td><td>&amp;rceil;</td><td>&amp;#8969;</td><td>右上限</td></tr><tr><td><strong>⌊</strong></td><td>&amp;lfloor;</td><td>&amp;#8970;</td><td>左下限</td></tr><tr><td><strong>⌋</strong></td><td>&amp;rfloor;</td><td>&amp;#8971;</td><td>右下限</td></tr></tbody></table><hr><h2 id="其他HTML字符实体"><a href="#其他HTML字符实体" class="headerlink" title="其他HTML字符实体"></a>其他HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>♠</td><td>&amp;spades;</td><td>&amp;#9824;</td><td>黑桃</td></tr><tr><td>♣</td><td>&amp;clubs;</td><td>&amp;#9827;</td><td>梅花</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>红桃，心</td></tr><tr><td>♦</td><td>&amp;diams;</td><td>&amp;#9830;</td><td>方块牌</td></tr><tr><td>◊</td><td>&amp;loz;</td><td>&amp;#9674;</td><td>菱形</td></tr><tr><td>†</td><td>&amp;dagger;</td><td>&amp;#8224;</td><td>匕首</td></tr><tr><td>‡</td><td>&amp;Dagger;</td><td>&amp;#8225;</td><td>双剑号</td></tr><tr><td>¡</td><td>&amp;iexcl;</td><td>&amp;#161;</td><td>反向感叹号</td></tr><tr><td>¿</td><td>&amp;iquest;</td><td>&amp;#191;</td><td>反向问号</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/cutdragonhit/p/9785350.html" target="_blank" rel="noopener">HTML实体符号</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/4159374.html" target="_blank" rel="noopener">网页中常用HTML字符实体</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括&lt;code&gt;特色字符实体&lt;/code&gt;、&lt;code&gt;常用字符实体&lt;/code&gt;、&lt;code&gt;货币类字符实体&lt;/code&gt;、&lt;code&gt;数字类字符实体&lt;/code&gt;、&lt;code&gt;方向类字符实体&lt;/code&gt;以及&lt;code&gt;其他字符实体&lt;/code&gt;，以供需要时查阅&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="http://showteeth.tech/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://showteeth.tech/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux通配符和正则表达式及其区别</title>
    <link href="http://showteeth.tech/posts/37480.html"/>
    <id>http://showteeth.tech/posts/37480.html</id>
    <published>2019-03-15T07:42:47.000Z</published>
    <updated>2019-03-17T02:19:28.214Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像<code>awk</code>、<code>sed</code>、<code>grep</code>使用正则表达式、像<code>find</code>、<code>ls</code>、<code>cp</code>使用通配符。</p></div><a id="more"></a><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls <span class="built_in">test</span>*.txt</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls d*.txt</span><br><span class="line">  ls: cannot access d*.txt: No such file or directory</span><br></pre></td></tr></table></figure><hr><h3 id="通配符的作用方式"><a href="#通配符的作用方式" class="headerlink" title="通配符的作用方式"></a>通配符的作用方式</h3><p><strong>通配符是由<code>shell</code>处理的</strong>(不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍), 它只会出现在命令的<strong>参数</strong>里(它不用在命令名称里， 也不用在操作符上)。<strong>当shell在参数中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个<u>普通字符传递给命令</u>，然后再由命令进行处理</strong>。总之，<strong>通配符实际上就是一种shell实现的路径扩展功能</strong>。在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。</p><p>我们回过头分析上面命令：</p><ul><li>在第2个命令中，<strong>test*.txt 实际shell搜索文件,找到了符合条件的文件，命令会变成</strong>：<code>ls test2.txt test3.txt test.txt</code> ,实际在执行<code>ls</code>时候传给它的<strong>参数</strong>是test2.txt test3.txt test.txt。</li><li>而命令3，<code>d*.txt</code> 由于当前目录下面没有这样的文件或目录，直接将<code>d*.txt</code>作为普通字符传给<code>ls</code>作为参数。这个时候<code>*</code>只是一个普通的 <code>ls</code>参数而已，已经<strong>失去了它通配意义</strong>。由于找不到文件，所以会出现：无法访问提示！</li></ul><p>了解了shell通配符，我们现在看下，shell常见通配符有哪些了。</p><hr><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>*</td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td>?</td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td>[list]</td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td>[!list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[^list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[^0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[c1-c2]</td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)<strong>其一字符串</strong></td><td>a{abc,xyz,123}b：a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><div class="note info"><p>需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种</p></div><hr><h3 id="通配符示例"><a href="#通配符示例" class="headerlink" title="通配符示例"></a>通配符示例</h3><p><code>[!list]</code> 和<code>[^list]</code>：</p><blockquote><p><code>ls test[^1-2].txt</code><br>test3.txt</p></blockquote><blockquote><p><code>ls test[!1-2].txt</code><br>test3.txt</p></blockquote><p>注意不会出现test.txt，因为test和.txt之间必须要有一个字符，而test.txt不具备这个条件</p><hr><p><br></p><h2 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>^word</td><td>待搜寻的字串(word)在<strong>行首</strong></td><td>grep -n ‘^#’ regular_express.txt：搜寻行首为 # 开始的那一行，并列出行号</td></tr><tr><td>word$</td><td>待搜寻的字串(word)在<strong>行尾</strong></td><td>grep -n ‘!$’ regular_express.txt：将行尾为 ! 的那一行打印出来，并列出行号</td></tr><tr><td>.</td><td>代表<strong>一定有一个任意字符</strong>的字符</td><td>grep -n ‘e.e’ regular_express.txt：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定<strong>仅有一个字符，而空白字符也是字符！</strong></td></tr><tr><td>\</td><td>转义字符，将特殊符号的特殊意义去除</td><td>grep -n \’ regular_express.txt：搜寻含有单引号 ‘ 的那一行</td></tr><tr><td>*</td><td>重复<strong>零个到无穷多个的前一个字符</strong></td><td>grep -n ‘ess*’ regular_express.txt：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字串。另外，之前也可以紧接着一个 RE 字符，例如任意字符则为 “.”</td></tr><tr><td>[list]</td><td>字符集合，匹配list 中的任意单个字符</td><td>grep -n ‘g[ld]’ regular_express.txt：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思</td></tr><tr><td>[n1-n2]</td><td>字符范围，匹配n1-n2中的任意单个字符</td><td>grep -n ‘[A-Z]’ regular_express.txt：搜寻含有大写字母的那一行。需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关。</td></tr><tr><td>[^list]</td><td>字符集合，匹配 除list 中的任意单一字符(一定要有一个)</td><td>不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字</td></tr><tr><td>{n,m}</td><td>连续 n 到 m 个的前一个字符；若为 {n} 则是连续 n 个的前一个字符；若是 {n,} 则是连续 n 个以上的前一个字符</td><td>grep -n ‘go{2,3}g’ regular_express.txt：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)</td></tr></tbody></table><hr><h3 id="延伸正则表达式字符"><a href="#延伸正则表达式字符" class="headerlink" title="延伸正则表达式字符"></a>延伸正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>重复<strong>一个或一个以上的前一个字符</strong></td><td>egrep -n ‘go+d’ regular_express.txt：搜寻 (god) (good) (goood)… 等等的字串，那个 o+ 代表一个以上的 o</td></tr><tr><td>?</td><td><strong>零个或一个的前一个字符</strong></td><td>egrep -n ‘go?d’ regular_express.txt：搜寻 (gd) (god) 这两个字串，那个 o? 代表空的或 1 个 o</td></tr><tr><td>&#124;</td><td>用<strong>或( or )的方式找出数个字串</strong></td><td>egrep -n ‘gd&#124;good’ regular_express.txt：搜寻 gd 或 good 这两个字串</td></tr><tr><td>()</td><td>找出<strong>群组字串</strong></td><td>egrep -n ‘g(la&#124;oo)d’ regular_express.txt：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来</td></tr><tr><td>()+</td><td><strong>多个重复群组的判别</strong></td><td>echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’</td></tr></tbody></table><div class="note info"><p><code>grep</code> <strong>默认仅支持基础正则表达式</strong>，如果要<strong>使用延伸型正则表达式</strong>，你可以使用 <code>grep -E</code> ， 不过更建议直接使用 <code>egrep</code>！直接区分指令比较好记忆！其实 <code>egrep</code> 与 <code>grep -E</code> 是类似命令别名的关系啦！</p></div><h2 id="通配符和正则表达式关系"><a href="#通配符和正则表达式关系" class="headerlink" title="通配符和正则表达式关系"></a>通配符和正则表达式关系</h2><ul><li>在<strong>文本过滤工具里，都是用正则表达式</strong>，比如像<code>awk</code>、<code>sed</code>、<code>grep</code>等，是针对文件的内容的；而<strong>通配符多用在文件名</strong>上，比如<code>find</code>、<code>ls</code>、<code>cp</code>等等</li><li>正则表达式中有部分与通配符是相近的含义，如<code>[list]</code>、<code>[n1-n2]</code>、<code>[^list]</code>，但也有一些差异非常大，如<code>*</code> <strong>在通配符中表示匹配0或多个</strong>字符(可以独立使用)，但<strong>在正则表达式中表示重复零个到无穷多个的<u>前一个字符</u></strong>(不能独立使用)</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://blog.csdn.net/swjtuwyp/article/details/51817472" target="_blank" rel="noopener">linux通配符和正则表达式</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;使用正则表达式、像&lt;code&gt;find&lt;/code&gt;、&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;cp&lt;/code&gt;使用通配符。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell-循环结构</title>
    <link href="http://showteeth.tech/posts/16486.html"/>
    <id>http://showteeth.tech/posts/16486.html</id>
    <published>2019-03-15T03:04:40.000Z</published>
    <updated>2019-03-17T07:43:23.499Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇博客主要学习了<code>shell</code>的循环结构，包括<code>for</code>、<code>while</code>、<code>until</code>循环，重点学习了前两个，整理了这两种循环的不同使用情形，同时也学习了循环控制结构的<code>break</code>和<code>continue</code>语句</p></div><a id="more"></a><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环适用于<strong>已经知道需要进行多少次的循环</strong>，所以for循环也叫<strong>固定循环</strong>。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      程序段</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p>为了防止可能的字符分割(变量存在空格)问题，con1 con2 con3都需要被引用(使用双引号括起来)，关于字符分割的示例可以查看<a href="http://showteeth.tech/posts/58105.html">shell-if条件测试</a></p></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用变量进行循环"><a href="#使用变量进行循环" class="headerlink" title="使用变量进行循环"></a>使用变量进行循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line">field1=$(cut -d <span class="string">' '</span> -f 1 test.txt)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;field1&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>this<br>that<br>there<br>those</p></blockquote><blockquote><p><code>name=&quot;my name is test&quot;</code><br><code>for i in ${name};do echo $i;done</code></p></blockquote><p><strong>输出</strong>：</p><blockquote><p>my<br>name<br>is<br>test</p></blockquote><hr><h4 id="使用seq命令进行循环"><a href="#使用seq命令进行循环" class="headerlink" title="使用seq命令进行循环"></a>使用seq命令进行循环</h4><p><strong>seq命令的用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line"></span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -f, --format=FORMAT      use <span class="built_in">printf</span> style floating-point FORMAT</span><br><span class="line">  -s, --separator=STRING   use STRING to separate numbers (default: \n)</span><br><span class="line">  -w, --equal-width        equalize width by padding with leading zeroes</span><br></pre></td></tr></table></figure><p></p><p><strong>默认用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>设置步长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 2 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>1<br>3<br>5</p></blockquote><p><strong>-w设置输出等长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w 1 2 12`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>01<br>03<br>05<br>07<br>09<br>11</p></blockquote><hr><h4 id="使用特殊符号-进行循环"><a href="#使用特殊符号-进行循环" class="headerlink" title="使用特殊符号{}进行循环"></a>使用特殊符号{}进行循环</h4><p><strong>特殊符号<code>{}</code>用法</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  &#123;FIRST..LAST..INCREMENT &#125;</span><br><span class="line">  </span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><p></p><p>对<strong>数字</strong>循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字循环设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>1<br>3<br>5</p></blockquote><p>对<strong>字母</strong>循环：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字母循环也可以设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a&#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..2&#125;&#123;a..d&#125;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>a<br>b<br>c<br>d</p></blockquote><blockquote><p>a<br>c</p></blockquote><blockquote><p>aa<br>ab<br>ac<br>ad</p></blockquote><blockquote><p>1a<br>1b<br>1c<br>1d<br>2a<br>2b<br>2c<br>2d</p></blockquote><p>特殊符号<code>{}</code>中的<strong>两个小数点来代表连续出现的意思</strong>，更多关于特殊符号<code>{}</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用特殊符号-进行循环-1"><a href="#使用特殊符号-进行循环-1" class="headerlink" title="使用特殊符号(())进行循环"></a>使用特殊符号(())进行循环</h4><p><strong>使用形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> （（ 初始值; 限制值; 执行步阶 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i=i+2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i+=2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>特殊符号<code>(())</code>表示<strong>执行计算</strong>，和linux <code>let</code>命令相似，更多关于特殊符号<code>(())</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用通配符进行循环"><a href="#使用通配符进行循环" class="headerlink" title="使用通配符进行循环"></a>使用通配符进行循环</h4><p>通配符主要有星号(<code>*</code>)和问号(<code>?</code>)，用来<strong>模糊搜索文件</strong>。关于shell中常见的通配符以及通配符和正则表达式的区别请参考<a href="http://showteeth.tech/posts/37480.html">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">test</span>*.txt</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  test2.txt  </span><br><span class="line">  test3.txt  </span><br><span class="line">  test.txt  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="comment">#           ^  Bash 在检测到通配表达式时，</span></span><br><span class="line"><span class="comment">#+             会进行文件名扩展。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ls -l <span class="string">"<span class="variable">$file</span>"</span>  <span class="comment"># 列出 $PWD（当前工作目录）下的所有文件。</span></span><br><span class="line">  <span class="comment">#  回忆一下，通配符 "*" 会匹配所有的文件名，</span></span><br><span class="line">  <span class="comment">#+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  如果没有匹配到文件，那么它将会扩展为它自身。</span></span><br><span class="line">  <span class="comment">#  为了防止出现这种情况，需要设置 nullglob 选项。</span></span><br><span class="line">  <span class="comment">#+    (shopt -s nullglob)。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> [jx]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="variable">$file</span>    <span class="comment"># 删除当前目录下所有以 "j" 或 "x" 开头的文件。</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Removed file \"<span class="variable">$file</span>\""</span>.</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="每个元素多个参数"><a href="#每个元素多个参数" class="headerlink" title="每个元素多个参数"></a>每个元素多个参数</h4><p>用于循环的每个参数可以继续分解为多个参数，这里使用 <code>set</code> 命令<strong>强制解析循环内容中的每一个元素</strong>，并将元素的每一个部分分配给位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个行星与其到太阳的距离放在一起。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> planet <span class="keyword">in</span> <span class="string">"Mercury 36"</span> <span class="string">"Venus 67"</span> <span class="string">"Earth 93"</span> <span class="string">"Mars 142"</span> <span class="string">"Jupiter 483"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">set</span> -- <span class="variable">$planet</span>  <span class="comment">#  解析变量 "planet"</span></span><br><span class="line">                  <span class="comment">#+ 并将其每个部分赋值给位置参数。</span></span><br><span class="line">  <span class="comment"># "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。</span></span><br><span class="line">  <span class="comment"># 你可以使用数组来保存</span></span><br><span class="line">  <span class="comment">#         original_params=("$@")</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>        <span class="variable">$2</span>,000,000 miles from the sum"</span></span><br><span class="line">  <span class="comment">#-------两个制表符---将后面的一系列 0 连到参数 $2 上。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>Mercury 36,000,000 miles from the sum<br>Venus 67,000,000 miles from the sum<br>Earth 93,000,000 miles from the sum<br>Mars 142,000,000 miles from the sum<br>Jupiter 483,000,000 miles from the sum</p></blockquote><p>示例来源于<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part3/11_1_loops.html" target="_blank" rel="noopener">这本书</a></p><hr><h4 id="集成管道符"><a href="#集成管道符" class="headerlink" title="集成管道符"></a>集成管道符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$( find $directory -type 1 )</span>"</span>   <span class="comment"># -type 1 = 符号链接</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span> | sort</span><br></pre></td></tr></table></figure><blockquote><p><code>for i in test*.txt;do echo $i;done |wc -l</code></p></blockquote><blockquote><p>3</p></blockquote><hr><p><br></p><h2 id="while-until循环"><a href="#while-until循环" class="headerlink" title="while/until循环"></a>while/until循环</h2><p><code>while/until</code>循环适用于条件判断，<strong>条件成立则进行循环，具体多少次的循环不知道</strong>，只要条件成立即可，所以<code>while/until</code>循环也叫<strong>不定循环</strong>。<code>while</code>和<code>until</code>循环在进行条件判断时执行的是完全相反的操作，<code>while</code>是条件成立则进行循环，而<code>until</code>这是条件成立终止循环，是完全相反的，所以后续的学习主要集中于使用较多的<code>while</code>循环，<code>until</code>循环一样的道理，只是将条件判断改变即可。</p><h3 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止</span></span><br><span class="line"><span class="keyword">while</span> [ condition ]  <span class="comment"># 括号内的状态就是判断式</span></span><br><span class="line"><span class="keyword">do</span>                   <span class="comment"># do 是循环的开始！</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span>                 <span class="comment"># done 是循环的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 condition 条件成立时，就终止循环， 否则就持续进行循环的程序段(和while循环相反)</span></span><br><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>while</code>和<code>until</code>循环中当<strong>使用条件测试进行循环时和前面在if条件测试分支结构中使用的条件测试是相同的</strong>，具体的各种测试形式这里就不在列出，后续可以查看<a href="http://showteeth.tech/posts/58105.html">这篇文章</a></p></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用条件测试进行循环"><a href="#使用条件测试进行循环" class="headerlink" title="使用条件测试进行循环"></a>使用条件测试进行循环</h4><p>和 <code>if</code> 一样， 使用条件测试进行循环时 <code>while</code> 会计算一系列命令的退出状态。只要<strong>退出状态为零(条件测试执行成功)，它就执行循环内的命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=0  <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0  <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]   <span class="comment"># 变量使用双引号在进行变量替换的同时防止字符分割</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+1))   <span class="comment"># 每次 i 都会增加 1 </span></span><br><span class="line">    s=$((<span class="variable">$s</span>+<span class="variable">$i</span>))  <span class="comment"># 每次都会加总一次！</span></span><br><span class="line">                  <span class="comment"># 使用了特殊符号$(())来执行计算</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is  <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p><mark>如果一个 while 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止，这个也和if命令相同:</mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环，输出this is true</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">false</span>;<span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="循环读取文件"><a href="#循环读取文件" class="headerlink" title="循环读取文件"></a>循环读取文件</h4><p>使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this is a test<br>that is a test<br>there is a test<br>those are tests</p></blockquote><p>也可以<strong>按字段读取文件的每行内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 field3 field4 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field3</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field4</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this<br>is a test<br>that<br>is a test<br>there<br>is a test<br>those<br>are tests</p></blockquote><blockquote><p>this<br>is<br>a<br>test<br>that<br>is<br>a<br>test<br>there<br>is<br>a<br>test<br>those<br>are<br>tests<br><em>这是空行</em></p></blockquote><div class="note info"><ul><li>为了重定向文件到循环中，可以将重定向操作符放置到 <code>done</code> 语句之后。循环使用 <code>read</code> 从重定向文件中读取字段；<strong>这个 <code>read</code> 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾，这时候它的退出状态为非零数值，因此终止循环</strong>。</li><li><strong>指定字段数小于每行字段数</strong>：第一个字段为第一个空格之前的内容，剩下的所有字段为第二个字段(这里只指定了两个字段来读取每一行)</li><li><strong>指定字段数大于每行字段数</strong>：不足的字段使用空格填补</li></ul></div><hr><h4 id="集成管道符-1"><a href="#集成管道符-1" class="headerlink" title="集成管道符"></a>集成管道符</h4><p>上面使用使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件的操作也可以使用管道符实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt|<span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>因为管道将会在<strong>子 shell</strong> 中执行循环，<strong>当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失</strong>，记住这一点很重要(这个还没测试过，先mark一下)</p></div><hr><p><br></p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break-终止循环"><a href="#break-终止循环" class="headerlink" title="break-终止循环"></a>break-终止循环</h3><p><code>break</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳出当前所在的循环体(终止循环)，执行循环体之后的语句</strong>。</p><h4 id="终止单层循环"><a href="#终止单层循环" class="headerlink" title="终止单层循环"></a>终止单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"></span><br><span class="line">  <span class="built_in">break</span>---------+</span><br><span class="line">                |</span><br><span class="line">  commands      |</span><br><span class="line">  commands      | 跳出(终止)循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">                |</span><br><span class="line"><span class="keyword">done</span>            |</span><br><span class="line">                |</span><br><span class="line">commands&lt;-------+</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; <span class="built_in">break</span>  <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>在循环中一旦发现目录，则立即停止循环并退出</p><hr><h4 id="终止多层循环"><a href="#终止多层循环" class="headerlink" title="终止多层循环"></a>终止多层循环</h4><p><mark><code>break</code> 命令可以接受一个参数，普通的 <code>break</code> 命令<strong>仅仅跳出其所在的那层循环</strong>，而 <code>break N</code> 命令则可以<strong>跳出其上 N 层的循环</strong></mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outerloop</span>:   "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> innerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$innerloop</span> "</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$innerloop</span>"</span> -eq 3 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">break</span> 2 <span class="comment"># 尝试一下 break 2 看看会发生什么。</span></span><br><span class="line">             <span class="comment"># （它同时中止了内层和外层循环。）</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>直接使用<code>break</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3<br>Group 2: 1 2 3<br>Group 3: 1 2 3<br>Group 4: 1 2 3<br>Group 5: 1 2 3</p></blockquote><p>使用了<code>break 2</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3</p></blockquote><p>可以发现使用<code>break 2</code>不仅跳出了本层循环，还跳出了本层循环的外层循环，也就是跳出了2层循环</p><hr><h3 id="continue-进行下一次循环"><a href="#continue-进行下一次循环" class="headerlink" title="continue-进行下一次循环"></a>continue-进行下一次循环</h3><p><code>continue</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</strong>。</p><h4 id="影响单层循环"><a href="#影响单层循环" class="headerlink" title="影响单层循环"></a>影响单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]&lt;-------+</span><br><span class="line"><span class="keyword">do</span>                         |</span><br><span class="line">                           |</span><br><span class="line">  commands                 | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">  commands                 |</span><br><span class="line">                           |</span><br><span class="line">  <span class="built_in">continue</span> ----------------+</span><br><span class="line"></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">commands</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -d <span class="string">"<span class="variable">$f</span>"</span> ] || <span class="built_in">continue</span>    <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line">    chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>如果是目录，添加权限；如果不是，跳过当前循环，continue 后面代码不再执行，而是直接执行下次循环。</p><hr><h4 id="影响多层循环"><a href="#影响多层循环" class="headerlink" title="影响多层循环"></a>影响多层循环</h4><p><mark>与 <code>break</code> 类似，<code>continue</code> 也可以接受一个参数，普通的 <code>continue</code> 命令<strong>仅仅影响其所在的那层循环</strong>，而 <code>continue N</code> 命令则可以<strong>影响其上 N 层的循环</strong></mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outer <span class="keyword">in</span> I II III IV V           <span class="comment"># 外层循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span>; <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outer</span>: "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> inner <span class="keyword">in</span> 1 2 3 4 5 6 7 8 9 10  <span class="comment"># 内层循环</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$inner</span>"</span> -eq 7 &amp;&amp; <span class="string">"<span class="variable">$outer</span>"</span> = <span class="string">"III"</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">continue</span> 2  <span class="comment"># 影响两层循环，包括“外层循环”。</span></span><br><span class="line">                  <span class="comment"># 将其替换为普通的 "continue"，那么只会影响内层循环。</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$inner</span> "</span>  <span class="comment"># 7 8 9 10 将不会出现在 "Group III."中。</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>直接使用<code>continue</code>的输出结果(只有第三组少了数字7)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6 8 9 10<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><p>使用了<code>continue 2</code>的输出结果(第三组7以后的数字全消失了)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><div class="note warning"><p><code>continue N</code> 结构<strong>不易理解并且可能在一些情况下有歧义，因此不建议使用</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇博客主要学习了&lt;code&gt;shell&lt;/code&gt;的循环结构，包括&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;until&lt;/code&gt;循环，重点学习了前两个，整理了这两种循环的不同使用情形，同时也学习了循环控制结构的&lt;code&gt;break&lt;/code&gt;和&lt;code&gt;continue&lt;/code&gt;语句&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="shell编程" scheme="http://showteeth.tech/categories/Linux/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
