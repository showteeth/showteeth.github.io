<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-11-10T01:56:22.813Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系列之按文件类型统计空间占用</title>
    <link href="http://showteeth.tech/posts/21373.html"/>
    <id>http://showteeth.tech/posts/21373.html</id>
    <published>2019-11-09T13:45:04.000Z</published>
    <updated>2019-11-10T01:56:22.813Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对实际问题-<strong>按照文件类型统计空间占用</strong>进行了实例学习，主要复习巩固了<strong>通配符和正则表达式的区别</strong>、<strong>awk数组和流程控制</strong>的使用，<strong>结合find的帮助文档学习了<code>-printf</code>参数以及<code>-exec</code>参数</strong>的使用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近想检查备份集群数据的备份情况，是不是都是只备份了某一种格式的文件，以及每种格式的文件占的空间大小，这种情况下单纯地使用du命令就不能解决问题，所以这里结合<a href="https://unix.stackexchange.com/questions/308846/how-to-find-total-filesize-grouped-by-extension" target="_blank" rel="noopener">How to find total filesize grouped by extension</a>中的高赞答案来学习一下。</p><hr><h2 id="命令和最终效果"><a href="#命令和最终效果" class="headerlink" title="命令和最终效果"></a>命令和最终效果</h2><p>命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span> |</span><br><span class="line">  awk -F . -v RS=<span class="string">'\0'</span> <span class="string">'</span></span><br><span class="line"><span class="string">    &#123;s[$NF] += $1; n[$NF]++&#125;</span></span><br><span class="line"><span class="string">    END &#123;for (e in s) printf "%15d %4d %s\n", s[e]*512, n[e], e&#125;'</span> |</span><br><span class="line">  sort -n</span><br></pre></td></tr></table></figure><p></p><p>最终结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      4096    1 cron</span><br><span class="line">      4096    1 cron2</span><br><span class="line">      4096    1 h</span><br><span class="line">      4096    1 json</span><br><span class="line">      4096    1 md5</span><br><span class="line">      4096    1 r</span><br><span class="line">      4096    1 tsv</span><br><span class="line">      8192    2 bai</span><br><span class="line">      8192    2 yml</span><br><span class="line">     12288    3 yaml</span><br><span class="line">     16384    3 cpp</span><br><span class="line">     28672    1 jpeg</span><br><span class="line">     32768    1 R</span><br><span class="line">    122880   12 py</span><br><span class="line">    122880   13 snakemake</span><br><span class="line">    155648   18 md</span><br><span class="line">    155648   31 sh</span><br><span class="line">   1544192    2 ipynb</span><br><span class="line">   7966720   41 txt</span><br><span class="line">  11456512   65 png</span><br><span class="line">  11685888    1 zip</span><br><span class="line">  36081664    1 out</span><br><span class="line"> 136515584    2 <span class="built_in">log</span></span><br><span class="line"> 542244864    2 <span class="built_in">test</span></span><br><span class="line">1084489728    4 filepart</span><br><span class="line">1941045248    5 bam</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><h3 id="通配符和正则表达式"><a href="#通配符和正则表达式" class="headerlink" title="通配符和正则表达式"></a>通配符和正则表达式</h3><p>首先需要注意的就是<strong>通配符和正则表达式的区别和使用</strong>，具体可以参考<a href="http://showteeth.tech/posts/37480.html">Linux通配符和正则表达式及其区别</a>。在这里<strong>使用的是<code>find</code>命令，对应的使用的就是通配符，而不是正则表达式</strong>，所以<code>-name &#39;?*.*&#39;</code>是正确的，<code>?</code>表示任意一个字符、<code>*</code>表示任意多个字符，而不是正则表达式中针对的是前一个字符的数目。</p><hr><h3 id="find的参数-printf"><a href="#find的参数-printf" class="headerlink" title="find的参数-printf"></a>find的参数-printf</h3><p>注意这里写的是<strong>find的参数-printf，而不是printf在find中的应用，两者有着本质的区别</strong>，前者说明这里的-printf是具有单独的用法的，而后者则说明是linux中格式化输出的语法使用。这也就涉及到其中<code>%s</code>、<code>%f</code>的用法不同了，在<a href="http://showteeth.tech/posts/47162.html">printf用法中</a>，<code>%f</code>表示浮点格式输出、<code>%b</code>表示开启转义模式(转义字符会被转义).</p><p>而在参数<code>-printf</code>用法中：</p><ul><li><code>%b</code>表示The amount of disk space used for this file in <strong>512-byte blocks</strong>. Since disk space is allocated in multiples of the filesystem block size, this is <strong>usually greater than %s/512, but it can also be smaller if the file is a sparse file.</strong></li><li><code>%f</code>表示仅输出文件名称。<strong>File’s name with any leading directories removed (only the last element).</strong></li></ul><p><mark>果然还是命令的帮助文档是最全面的！！！</mark></p><hr><h3 id="find命令的输出"><a href="#find命令的输出" class="headerlink" title="find命令的输出"></a>find命令的输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span></span><br><span class="line">  8.test1.txt8.test2.txt8.test3.txt8.test4.txt8.test5.txt16.test.txt16.merged.txt8.server.log8.test1.txt8.test2.txt8.test.txt8.shuf.txt8.test1.txt8.test2.txt8.test.sh8.test_t.sh8.test_s.sh8.n.sh8.u_1.sh8.u_2.sh8.u_3.sh8.test.txt8.u_4.sh8.i.sh8.test_2.sh8.a.sh8.d.sh8.e.sh8.test.txt8.test.txt529536.B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart8.test2.txt8.test.sh70472.nohup.out266624.test.log529536.B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br></pre></td></tr></table></figure><hr><h3 id="输出文件大小、文件数目、文件后缀"><a href="#输出文件大小、文件数目、文件后缀" class="headerlink" title="输出文件大小、文件数目、文件后缀"></a>输出文件大小、文件数目、文件后缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用awk的数组</span></span><br><span class="line"><span class="comment"># 将512-byte block转化为了4096-byte block的大小</span></span><br><span class="line"><span class="comment"># 控制了输出的位数15、4</span></span><br><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span> |</span><br><span class="line">  awk -F . -v RS=<span class="string">'\0'</span> <span class="string">'</span></span><br><span class="line"><span class="string">    &#123;s[$NF] += $1; n[$NF]++&#125;</span></span><br><span class="line"><span class="string">    END &#123;for (e in s) printf "%15d %4d %s\n", s[e]*512, n[e], e&#125;'</span> |</span><br><span class="line">  sort -n</span><br></pre></td></tr></table></figure><hr><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>需要改进的地方是不能转化为K、M、G、T这种形式，这里尝试改进一下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span> |</span><br><span class="line">  awk -F . -v RS=<span class="string">'\0'</span> <span class="string">'</span></span><br><span class="line"><span class="string">    &#123;s[$NF] += $1; n[$NF]++&#125;</span></span><br><span class="line"><span class="string">    END &#123;</span></span><br><span class="line"><span class="string">      for (e in s)</span></span><br><span class="line"><span class="string">        if(int(s[e]*512/1024/1024/1024/1024) &gt; 0)&#123;printf "%8.2fT %6d %s\n", s[e]*512/1024/1024/1024/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else if(int(s[e]*512/1024/1024/1024) &gt; 0)&#123;printf "%8.2fG %6d %s\n", s[e]*512/1024/1024/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else if(int(s[e]*512/1024/1024) &gt; 0)&#123;printf "%8.2fM %6d %s\n", s[e]*512/1024/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else if(int(s[e]*512/1024) &gt; 0)&#123;printf "%8.2fK %6d %s\n", s[e]*512/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else &#123;printf "%8fB %6d %s\n", s[e]*512, n[e], e&#125;</span></span><br><span class="line"><span class="string">        &#125;'</span> |</span><br><span class="line">  sort -hr</span><br></pre></td></tr></table></figure><p></p><p>效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  1.81G      5 bam</span><br><span class="line">  1.01G      4 filepart</span><br><span class="line">517.12M      2 <span class="built_in">test</span></span><br><span class="line">130.19M      2 <span class="built_in">log</span></span><br><span class="line"> 34.41M      1 out</span><br><span class="line"> 11.14M      1 zip</span><br><span class="line"> 10.93M     65 png</span><br><span class="line">  7.60M     41 txt</span><br><span class="line">  1.47M      2 ipynb</span><br><span class="line">152.00K     31 sh</span><br><span class="line">152.00K     18 md</span><br><span class="line">120.00K     13 snakemake</span><br><span class="line">120.00K     12 py</span><br><span class="line"> 32.00K      1 R</span><br><span class="line"> 28.00K      1 jpeg</span><br><span class="line"> 16.00K      3 cpp</span><br><span class="line"> 12.00K      3 yaml</span><br><span class="line">  8.00K      2 yml</span><br><span class="line">  8.00K      2 bai</span><br><span class="line">  4.00K      1 tsv</span><br><span class="line">  4.00K      1 r</span><br><span class="line">  4.00K      1 md5</span><br><span class="line">  4.00K      1 json</span><br><span class="line">  4.00K      1 h</span><br><span class="line">  4.00K      1 cron2</span><br><span class="line">  4.00K      1 cron</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="只统计某个后缀文件大小"><a href="#只统计某个后缀文件大小" class="headerlink" title="只统计某个后缀文件大小"></a>只统计某个后缀文件大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -name使用了通配符指定</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.bam'</span> -<span class="built_in">exec</span> du -ch &#123;&#125; +</span><br><span class="line">  717M./linux_learn/scp/LJ_mt_677_1_paired.bam</span><br><span class="line">  717M./linux_learn/pv/LJ_mt_677_1_paired.bam</span><br><span class="line">  210M./python_learn/pysam/chrM_no_gap.bam</span><br><span class="line">  209M./python_learn/pysam/chrM_no_gap_mapped.bam</span><br><span class="line">  8.0K./python_learn/pysam/with_gap.bam</span><br><span class="line">  1.9Gtotal</span><br></pre></td></tr></table></figure><p>需要注意的是这里的<code>-exec</code>参数的<code>+</code>，之前只知道<code>\;</code>，看了帮助文档才知道原来配合<code>-exec</code>参数使用的有<strong>两种模式</strong>：</p><ul><li><code>-exec command ;</code>：Execute command; true if 0 status is returned. <strong>All following arguments to find are taken to be arguments to the command until an argument consisting of ‘;’is encountered</strong>. The string ‘{}’ is replaced by the current file name being processed everywhere it occurs in the arguments to the command, not just in arguments where it is alone, as in some versions of find. <strong>Both of these constructions might need to be escaped (with a ‘\’) or quoted to protect them from expansion by the shell</strong>. The specified command is run once for each matched file. The command is executed in the starting directory. There are unavoidable security problems surrounding use of the -exec action; you should use the -execdir option instead.</li><li><code>-exec command {} +</code>：This variant of the -exec action runs the specified command on the selected files, <strong>but the command line is built by appending each selected file name at the end</strong>; <strong>the total number of invocations of the command will be much less than the number of matched files</strong>. The command line is built in much the same way that <code>xargs</code> builds its command lines. <strong>Only one instance of ‘{}’ is allowed within the command</strong>. The command is executed in the starting directory.</li><li><code>-execdir command ;</code>、<code>-execdir command {} +</code>：Like -exec, but <strong>the specified command is run from the subdirectory containing the matched file, which is not normally the directory in which you started find</strong>. This a much more secure method for invoking commands, as it avoids race conditions during resolution of the paths to the matched files. As with the -exec action, the ‘+’ form of -execdir will build a command line to process more than one matched file, but any given invocation of command will only list files that exist in the same subdirectory. If you use this option, you must ensure that your $PATH environment variable does not reference ‘.’; otherwise, an attacker can run any commands they like by leaving an appropriately-named file in a directory in which you will run -execdir. The same applies to having entries in $PATH which are empty or which are not absolute directory names.</li></ul><p><strong>使用上面的统计指定后缀文件大小的实例来巩固一下上面的内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加模式，也就是先把所有的文件找到，然后调用du命令一次</span></span><br><span class="line"><span class="comment"># 所以只会出现一个total</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.bam'</span> -<span class="built_in">exec</span> du -ch &#123;&#125; +</span><br><span class="line">  717M./linux_learn/scp/LJ_mt_677_1_paired.bam</span><br><span class="line">  717M./linux_learn/pv/LJ_mt_677_1_paired.bam</span><br><span class="line">  210M./python_learn/pysam/chrM_no_gap.bam</span><br><span class="line">  209M./python_learn/pysam/chrM_no_gap_mapped.bam</span><br><span class="line">  8.0K./python_learn/pysam/with_gap.bam</span><br><span class="line">  1.9Gtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规模式</span></span><br><span class="line"><span class="comment"># 每次找到一个后缀为bam的文件就统计其大小</span></span><br><span class="line"><span class="comment"># 所以每个文件对应于一个大小，同时并没有显示总大小</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.bam'</span> -<span class="built_in">exec</span> du -ch &#123;&#125; \;</span><br><span class="line">  717M./linux_learn/scp/LJ_mt_677_1_paired.bam</span><br><span class="line">  717Mtotal</span><br><span class="line">  717M./linux_learn/pv/LJ_mt_677_1_paired.bam</span><br><span class="line">  717Mtotal</span><br><span class="line">  210M./python_learn/pysam/chrM_no_gap.bam</span><br><span class="line">  210Mtotal</span><br><span class="line">  209M./python_learn/pysam/chrM_no_gap_mapped.bam</span><br><span class="line">  209Mtotal</span><br><span class="line">  8.0K./python_learn/pysam/with_gap.bam</span><br><span class="line">  8.0Ktotal</span><br></pre></td></tr></table></figure><p></p><p>为什么需要使用<code>\;</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止被解释为shell脚本的标点符号</span></span><br><span class="line"><span class="comment"># 不仅;需要加上\或者单引号来进行保护，&#123;&#125;也可以加上单引号</span></span><br><span class="line"><span class="comment"># Runs 'file' on every file in or below the current directory.  </span></span><br><span class="line"><span class="comment"># Notice that the braces are enclosed in single quote </span></span><br><span class="line"><span class="comment"># marks to protect them from interpretation as shell script punctuation.  </span></span><br><span class="line"><span class="comment"># The semicolon is similarly protected by the use of a backslash, </span></span><br><span class="line"><span class="comment"># though single quotes could have been used in that case also.</span></span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> file <span class="string">'&#123;&#125;'</span> \;</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/308846/how-to-find-total-filesize-grouped-by-extension" target="_blank" rel="noopener">How to find total filesize grouped by extension</a></li><li><a href="https://stackoverflow.com/questions/34971106/print-total-of-du-for-one-filetype-directory-is-not-flat" target="_blank" rel="noopener">print total of ‘du’ for one filetype, directory is not flat</a></li><li><a href="https://unix.stackexchange.com/questions/41550/find-the-total-size-of-certain-files-within-a-directory-branch" target="_blank" rel="noopener">Find the total size of certain files within a directory branch</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章针对实际问题-&lt;strong&gt;按照文件类型统计空间占用&lt;/strong&gt;进行了实例学习，主要复习巩固了&lt;strong&gt;通配符和正则表达式的区别&lt;/strong&gt;、&lt;strong&gt;awk数组和流程控制&lt;/strong&gt;的使用，&lt;strong&gt;结合find的帮助文档学习了&lt;code&gt;-printf&lt;/code&gt;参数以及&lt;code&gt;-exec&lt;/code&gt;参数&lt;/strong&gt;的使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之没有root权限安装gcc</title>
    <link href="http://showteeth.tech/posts/53937.html"/>
    <id>http://showteeth.tech/posts/53937.html</id>
    <published>2019-11-06T03:00:52.000Z</published>
    <updated>2019-11-06T12:09:20.628Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<strong>没有<code>root</code>权限</strong>条件下<strong>安装(升级)<code>gcc</code></strong>的步骤。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在安装一个软件的过程中出现了如下错误：</p><blockquote><p>cc1plus: error: unrecognized command line option “-std=c++11”</p></blockquote><p>仔细一查原来是集群的<code>gcc</code>版本太低，安装这个软件需要<code>4.7.X</code>版本：</p><blockquote><p>gcc (GCC) 4.4.6 20120305 (Red Hat 4.4.6-4)<br>Copyright (C) 2010 Free Software Foundation, Inc.<br>This is free software; see the source for copying conditions. There is NO<br>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p></blockquote><p>但自己没有<code>root</code>权限，所以不能直接使用<code>yum</code>这种命令来升级<code>gcc</code>，这里记录一下没有<code>root</code>权限如何解决这个问题。</p><hr><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><h3 id="下载gcc"><a href="#下载gcc" class="headerlink" title="下载gcc"></a>下载gcc</h3><p>可以从<a href="https://gcc.gnu.org/releases.html" target="_blank" rel="noopener">这个链接</a>查看<code>gcc</code>版本混合更新时间(才发现原来已经更新到<code>9.2</code>版本了)，具体的<a href="https://ftp.gnu.org/gnu/gcc/" target="_blank" rel="noopener">下载链接</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载对应的gcc版本</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf gcc-9.2.0.tar.gz</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>安装<code>gcc</code>需要先安装一些依赖的库：<code>GMP</code>、<code>MPFR</code> 和 <code>MPC</code>。安装这些依赖库可以按照常规地<a href="https://blog.csdn.net/qq_36573282/article/details/79762028" target="_blank" rel="noopener">下载源码安装</a>，但是三个包之间存在相互依赖，所以安装也有相应的顺序，而且不同的gcc版本还有不同的依赖库的版本，比较麻烦；<code>gcc</code>给出了下载这些依赖库的<a href="https://gcc.gnu.org/wiki/InstallingGCC" target="_blank" rel="noopener">简便命令</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="comment"># 必须要在gcc解压目录下运行，不能进入下一级目录</span></span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line">  <span class="comment"># 下载在当前目录下</span></span><br><span class="line">  2019-11-06 13:43:20 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2 [2383840] -&gt; <span class="string">"./gmp-6.1.0.tar.bz2"</span> [1]</span><br><span class="line">  2019-11-06 13:44:01 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2 [1279284] -&gt; <span class="string">"./mpfr-3.1.4.tar.bz2"</span> [1]</span><br><span class="line">  2019-11-06 13:44:28 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz [669925] -&gt; <span class="string">"./mpc-1.0.3.tar.gz"</span> [1]</span><br><span class="line">  2019-11-06 13:46:29 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2 [1658291] -&gt; <span class="string">"./isl-0.18.tar.bz2"</span> [2]</span><br><span class="line">  gmp-6.1.0.tar.bz2: OK</span><br><span class="line">  mpfr-3.1.4.tar.bz2: OK</span><br><span class="line">  mpc-1.0.3.tar.gz: OK</span><br><span class="line">  isl-0.18.tar.bz2: OK</span><br><span class="line">  All prerequisites downloaded successfully.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="安装gcc-1"><a href="#安装gcc-1" class="headerlink" title="安装gcc"></a>安装gcc</h3><h4 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gcc-9.2.0/configure --prefix=`<span class="built_in">pwd</span>` --<span class="built_in">enable</span>-languages=c,c++,fortran,go</span><br></pre></td></tr></table></figure><p>出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误一：</span></span><br><span class="line">checking build system <span class="built_in">type</span>... config.guess: cannot create a temporary directory <span class="keyword">in</span> /800T/wangjb/tmp</span><br><span class="line">configure: error: cannot guess build <span class="built_in">type</span>; you must specify one</span><br><span class="line"><span class="comment">## 解决办法：在/800T/wangjb下创建tmp文件夹，当然也可以添加build选项(没有尝试过)</span></span><br><span class="line"><span class="comment">## 可能的原因是：在.bashrc文件中添加了export TEMP=/800T/wangjb/tmp、export TMPDIR=/800T/wangjb/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误二：</span></span><br><span class="line">configure: error: I suspect your system does not have 32-bit development libraries (libc and headers). If you have them, rerun configure with --<span class="built_in">enable</span>-multilib. If you <span class="keyword">do</span> not have them, and want to build a 64-bit-only compiler, rerun configure with --<span class="built_in">disable</span>-multilib.</span><br><span class="line"><span class="comment">## 解决办法：添加参数--disable-multilib</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译，开启4个线程</span></span><br><span class="line">make -j4</span><br><span class="line">  <span class="comment"># 可能出现如下warning</span></span><br><span class="line">  <span class="comment">## make[2]: warning:  Clock skew detected.  Your build may be incomplete.</span></span><br><span class="line">  <span class="comment">## make[2]: Leaving directory `/BioII/wangjb/usr/gcc/gotools'</span></span><br><span class="line">  <span class="comment">## make[1]: warning:  Clock skew detected.  Your build may be incomplete.</span></span><br><span class="line">  <span class="comment">## make[1]: Leaving directory `/BioII/wangjb/usr/gcc'</span></span><br><span class="line">  <span class="comment">## make: warning:  Clock skew detected.  Your build may be incomplete.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><hr><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>一定要确保安装路径在<code>$LD_LIBRARY_PATH</code>和<code>$PATH</code>之前，这样安装的程序才能<strong>取代之前系统默认的程序</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcc 9.2.0</span></span><br><span class="line"><span class="built_in">export</span> PATH=/BioII/wangjb/usr/gcc/bin:/BioII/wangjb/usr/gcc/lib64:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/BioII/wangjb/usr/gcc/lib/:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="重现安装软件"><a href="#重现安装软件" class="headerlink" title="重现安装软件"></a>重现安装软件</h2><p>在安装完成<code>gcc</code>以及将其写入环境变量之后，再次安装软件即可成功安装。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://gcc.gnu.org/wiki/InstallingGCC" target="_blank" rel="noopener">Installing GCC</a></li><li><a href="https://gcc.gnu.org/install/configure.html" target="_blank" rel="noopener">Installing GCC: Configuration</a></li><li><a href="http://www.xieqiang.site/2017/07/31/install-gcc-5.4-without-root/" target="_blank" rel="noopener">Linux下非root用户安装GCC 5.4</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;strong&gt;没有&lt;code&gt;root&lt;/code&gt;权限&lt;/strong&gt;条件下&lt;strong&gt;安装(升级)&lt;code&gt;gcc&lt;/code&gt;&lt;/strong&gt;的步骤。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Linux/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之head命令</title>
    <link href="http://showteeth.tech/posts/35269.html"/>
    <id>http://showteeth.tech/posts/35269.html</id>
    <published>2019-10-30T15:00:42.000Z</published>
    <updated>2019-10-31T08:38:13.471Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>Linux</code>中常用的命令<code>head</code>，主要学习了其<strong>输出文件的前多少字节</strong>的用法；同时也了解了文件大小单位中<code>K</code>和<code>KB</code>的区别，加<code>B</code>的如<code>KB</code>是以<code>1000</code>换算的，而不加<code>B</code>的如<code>K</code>是以<code>1024</code>换算的。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>head</code>命令是日常学习和工作中很常用的一个命令，但有时候越常使用的命令越容易忽视其一些非常重要的功能，比如今天想要学习的<strong>使用<code>head</code>来获取文件的前9M信息</strong>。</p><hr><h2 id="用法和参数"><a href="#用法和参数" class="headerlink" title="用法和参数"></a>用法和参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>-c, --bytes=[-][K|M|G]</code>: <strong>输出文件的前多少字节</strong>，如果前面增加了<code>-</code>表示从文档的最后获取信息。print the first K bytes of each file; with the leading ‘-‘, print all but the last K bytes of each file</li><li><code>-n, --lines=[-]K</code>: <strong>输出文件的前多少行</strong>，如果前面增加了<code>-</code>表示从文档的最后获取信息。print the first K lines instead of the first 10; with the leading ‘-‘, print all but the last K lines of each file</li><li><code>-v, --verbose</code>: <strong>输出文件名</strong>。always print headers giving file names</li><li><code>-q, --quiet, --silent</code>: <strong>不打印文件名</strong>。never print headers giving file names</li></ul><p><strong>关于单位</strong>：</p><blockquote><p>K may have a multiplier suffix: <code>b 512</code>, <code>kB 1000</code>, <code>K 1024</code>, <code>MB 1000*1000</code>, <code>M 1024*1024</code>, <code>GB 1000*1000*1000</code>, <code>G 1024*1024*1024</code>, and so on for <code>T</code>, <code>P</code>, <code>E</code>, <code>Z</code>, <code>Y</code>.</p></blockquote><hr><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规用法</span></span><br><span class="line">head -n 5 shuf.txt </span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件名称</span></span><br><span class="line">head -v -n 5 shuf.txt </span><br><span class="line">  ==&gt; shuf.txt &lt;==</span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定大小的文件</span></span><br><span class="line">head -c 10M user.storage &gt; user_10M.storage</span><br><span class="line">  -rw-rw-r-- 1 root root  10M Oct 31 16:33 user_10M.storage</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/head" target="_blank" rel="noopener">head(1) - Linux man page</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;code&gt;Linux&lt;/code&gt;中常用的命令&lt;code&gt;head&lt;/code&gt;，主要学习了其&lt;strong&gt;输出文件的前多少字节&lt;/strong&gt;的用法；同时也了解了文件大小单位中&lt;code&gt;K&lt;/code&gt;和&lt;code&gt;KB&lt;/code&gt;的区别，加&lt;code&gt;B&lt;/code&gt;的如&lt;code&gt;KB&lt;/code&gt;是以&lt;code&gt;1000&lt;/code&gt;换算的，而不加&lt;code&gt;B&lt;/code&gt;的如&lt;code&gt;K&lt;/code&gt;是以&lt;code&gt;1024&lt;/code&gt;换算的。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shell-字典</title>
    <link href="http://showteeth.tech/posts/17760.html"/>
    <id>http://showteeth.tech/posts/17760.html</id>
    <published>2019-10-30T13:05:11.000Z</published>
    <updated>2019-10-30T15:08:25.002Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章对<code>Shell</code>中的<strong>字典(关联数组)</strong>进行了学习，主要包括<strong>字典的创建</strong>和<strong>字典的常用操作</strong>，其实<strong>字典的常用操作和数组基本相同</strong>，但<strong>字典可以使用字符串(key)作为索引来直接获取value</strong>，提高了效率。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天在写脚本的时候忽然发现<code>shell</code>可以支持<strong>字典(hash)</strong>操作了，不过好像只有<code>bash 4.X</code>的版本可以使用，还好自己平常使用的集群的<code>bash</code>都是<code>4.X</code>的，这里记录一下使用过程。</p><p>实际上这里所谓的字典其实是数组的一种，叫做<strong>关联数组(associative array)</strong>，我之所以将其称为字典(后续我都会称其为字典)是因为<strong>其和字典的用法基本一致</strong>，都是键值对的形式。</p><blockquote><p>Bash provides <code>one-dimensional</code> indexed and <code>associative array</code> variables.<br>Associative arrays are created using <code>declare -A</code> name.</p></blockquote><p>关于数组的使用可以回顾<a href="http://showteeth.tech/posts/46714.html">这个文章</a>。</p><hr><h2 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明一个名为color的字典</span></span><br><span class="line"><span class="comment"># 必须用-A才能创建关联数组(字典)，-a创建的是一般的数组</span></span><br><span class="line"><span class="built_in">declare</span> -A color</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值操作</span></span><br><span class="line"><span class="comment">## 赋值方式一：</span></span><br><span class="line">color[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">color[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">color[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line"><span class="comment">## 赋值方式二：</span></span><br><span class="line"><span class="comment">### 注意这里不需要在每个键值对后面添加,分割</span></span><br><span class="line">color=(</span><br><span class="line">  [<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">  [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">  [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">## 赋值方式三(声明的同时赋值)：</span></span><br><span class="line"><span class="built_in">declare</span> -A color=([<span class="string">"red"</span>]=<span class="string">"#ff0000"</span> [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span> [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="字典常见操作"><a href="#字典常见操作" class="headerlink" title="字典常见操作"></a>字典常见操作</h2><p>使用字典的初衷就是其访问值更加方便，可以直接<strong>通过键值去取对应的value</strong>，而<strong>不需要像传统数组一样去使用索引</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;color["blue"]&#125;</span></span><br><span class="line">  <span class="comment">#0000ff</span></span><br></pre></td></tr></table></figure><p></p><p><mark>如果键值key在字典中不存在，那么获取的返回值就是空值。</mark></p><p>只需要<strong>将这些的key值理解为传统数组中的索引</strong>，那么数组的使用就会方便许多：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数组所有元素，这个和传统数组基本相同</span></span><br><span class="line"><span class="comment"># 也可以使用 echo $&#123;color[@]&#125;</span></span><br><span class="line"><span class="comment"># 关于@和*之间的区别也是一样的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;color[*]&#125;</span></span><br><span class="line">  <span class="comment">#ff0000 #0000ff #00ff00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到数组所有的key值---对应于常规数组中的下标值</span></span><br><span class="line"><span class="comment"># 也可以使用 echo $&#123;!color[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[*]&#125;</span>  </span><br><span class="line">  red blue green</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典长度</span></span><br><span class="line"><span class="comment"># 也可以使用 echo $&#123;#color[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#color[@]&#125;</span></span><br><span class="line">  3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取value值的长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#color["red"]&#125;</span></span><br><span class="line">  7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">color[<span class="string">"white"</span>]=<span class="string">"#ffffff"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[*]&#125;</span></span><br><span class="line">  red blue white green</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时添加多个元素</span></span><br><span class="line"><span class="comment"># dic+=( ["key2"]=val2 ["key3"]=val3 )</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[@]&#125;</span></span><br><span class="line">  red blue white green</span><br><span class="line">color+=([<span class="string">"black"</span>]=<span class="string">"#000000"</span></span><br><span class="line">        [<span class="string">"purple"</span>]=<span class="string">"#7F00FF"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[@]&#125;</span></span><br><span class="line">  red blue white black green purple</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/bash" target="_blank" rel="noopener">bash(1) - Linux man page</a></li><li><a href="https://stackoverflow.com/questions/14370133/is-there-a-way-to-create-key-value-pairs-in-bash-script/23697848" target="_blank" rel="noopener">Is there a way to create key-value pairs in Bash script?</a></li><li><a href="https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash" target="_blank" rel="noopener">How to define hash tables in Bash?</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章对&lt;code&gt;Shell&lt;/code&gt;中的&lt;strong&gt;字典(关联数组)&lt;/strong&gt;进行了学习，主要包括&lt;strong&gt;字典的创建&lt;/strong&gt;和&lt;strong&gt;字典的常用操作&lt;/strong&gt;，其实&lt;strong&gt;字典的常用操作和数组基本相同&lt;/strong&gt;，但&lt;strong&gt;字典可以使用字符串(key)作为索引来直接获取value&lt;/strong&gt;，提高了效率。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="shell编程" scheme="http://showteeth.tech/categories/Linux/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之定时执行任务发送邮件</title>
    <link href="http://showteeth.tech/posts/6366.html"/>
    <id>http://showteeth.tech/posts/6366.html</id>
    <published>2019-10-29T09:16:58.000Z</published>
    <updated>2019-10-31T09:27:06.862Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇实战的文章，主要目的是<strong>定期统计集群存储使用情况并通过邮箱告知用户</strong>。其中涉及到的技术点主要有：<strong>定时任务的设置</strong>、<strong>集群邮件的发送</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室使用了学校的一个公共集群，上面的存储空间有限，一旦存储到达90%左右就不能继续运行任务，所以需要定期检查集群存储的使用情况，但是人工每次check很容易忘记，所以就想能不能使用定期检测的方式。总结来说，我的需求有两个：</p><ul><li>定期检测集群存储—<strong>定期执行任务</strong></li><li>给所有用户发邮件提醒各自账户的使用情况—<strong>发送邮件</strong></li></ul><hr><p><br></p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><h3 id="crontab简介"><a href="#crontab简介" class="headerlink" title="crontab简介"></a>crontab简介</h3><p><code>cron</code>是<code>Unix</code>、<code>Solaris</code>、<code>Linux</code>等系统下的可以<strong>自动在后台执行定时任务的工具</strong>，比如在某一天9点提醒你开会，某一天6点去给女票买礼物等等，这是由<strong>cron守护进程定期执行</strong>的。如果启用了 <code>cron</code>(一般默认启用), <code>cron</code> 守护进程会在系统启动后自动启动，并按时执行任务。 <code>cron</code>也能手动启用、关闭、重启等。</p><p><code>crontab(cron table)</code>是<code>cron</code>的<strong>任务库</strong>文件，它存储了<code>cron</code>要执行的计划任务项目。不同系统下该文件的位置可能不同，<code>centos</code>下是在<code>/var/spool/cron/</code>目录下，但是需要<code>root</code>权限才能访问。</p><p><code>crontab</code>也是一个<strong>命令</strong>，其用来<strong>创建、删除、查看当前用户（或者指定用户）的crontab文件</strong>。</p><hr><h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> crontab [options] file</span><br><span class="line"> crontab [options]</span><br><span class="line"> crontab -n [hostname]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -u &lt;user&gt;  define user</span><br><span class="line"> -e         edit user<span class="string">'s crontab</span></span><br><span class="line"><span class="string"> -l         list user'</span>s crontab</span><br><span class="line"> -r         delete user<span class="string">'s crontab</span></span><br><span class="line"><span class="string"> -i         prompt before deleting</span></span><br><span class="line"><span class="string"> -n &lt;host&gt;  set host in cluster to run users'</span> crontabs</span><br><span class="line"> -c         get host <span class="keyword">in</span> cluster to run users<span class="string">' crontabs</span></span><br><span class="line"><span class="string"> -s         selinux context</span></span><br><span class="line"><span class="string"> -x &lt;mask&gt;  enable debugging</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Default operation is replace, per 1003.2</span></span><br></pre></td></tr></table></figure><p>常用参数说明：</p><ul><li><code>file</code>：<code>file</code>是命令文件的名字,表示<strong>将<code>file</code>做为<code>crontab</code>的任务列表文件并载入<code>crontab</code></strong>。如果在命令行中没有指定这个文件，<code>crontab</code>命令将接受标准输入（键盘）上键入的命令，并将它们载入<code>crontab</code>。</li><li><code>-u</code>: 指定 <code>crontab</code> 的用户名, 此选项<strong>只能 <code>root</code>使用</strong></li><li><code>-e</code>: 编辑 <code>crontab</code> 文件，如果没有，会新建一个</li><li><code>-l</code>: 打印出 <code>crontab</code> 文件内容，列出计划任务</li><li><code>-r</code>: 移除 <code>crontab</code> 文件</li><li><code>-c</code>: 获取用户在集群上的 <code>crontabs</code></li></ul><hr><h3 id="crontab文件格式和定时规则"><a href="#crontab文件格式和定时规则" class="headerlink" title="crontab文件格式和定时规则"></a>crontab文件格式和定时规则</h3><p><code>crontab</code> 文件的格式可以查看<code>/etc/crontab</code>文件(也可以直接在其中添加命令作为系统的routine)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的shell</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line"><span class="comment"># 命令的查找路径，也就是环境变量</span></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"><span class="comment"># 如果出现错误，或者有数据输出，数据作为邮件发给这个帐号</span></span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="comment"># 使用者运行的路径,这里默认是根目录</span></span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现其主要有<strong>六个字段</strong>，具体来说就是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个字段之间使用空格分隔</span></span><br><span class="line">&#123;minute&#125; &#123;hour&#125; &#123;day-of-month&#125; &#123;month&#125; &#123;day-of-week&#125; &#123;full-path-to-shell-script&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中每个字段的具体说明：</p><ul><li><code>minute</code>：区间为<code>0–59</code>；</li><li><code>hour</code>：区间为<code>0–23</code>；</li><li><code>day-of-month</code>：区间为<code>0–31</code>；</li><li><code>month</code>：区间为<code>1–12</code>；1是1月，12是12月；</li><li><code>day-of-week</code>：区间为<code>0–6</code>，<strong>周日是0</strong>，这个不会影响到前面的<code>day-of-month</code>、<code>month</code></li></ul><p>除了数字还有以下<strong>几个特殊的符号</strong>需要特殊说明：</p><ul><li><code>*</code>：代表<strong>所有的取值范围内的数字，也就是任意数字</strong>；</li><li><code>/</code>：代表<strong>每</strong>的意思，<strong>”*/5″表示每5个单位</strong>；</li><li><code>-</code>：代表<strong>从某个数字到某个数字</strong>，<code>0 10-20 * * * command</code> 表示在每天 <code>10:00</code> 到 <code>20:00</code> 执行任务</li><li><code>,</code>：分开<strong>几个离散的数字</strong>，<code>0 3,6 * * * command</code> 表示在每天 <code>3:00</code>、<code>6:00</code> 执行任务</li></ul><hr><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><ul><li>第一步：进入<code>crontab</code>编辑模式：输入命令<code>crontab -e</code>，默认就是<code>vim</code>的编辑环境</li><li>第二步：编写定期规则，可以是<code>58 * * * * echo &quot;Good morning.&quot; &gt;/home/log.log</code>表示<strong>每小时的58分</strong>输出一次<code>Good morning.</code>到文件<code>/home/log.log</code>中</li><li>第三步：退出<code>vim</code>编辑环境，会显示<code>crontab: installing new crontab</code>，这时会在<code>/var/spool/cron</code>中生成对应用户名的文件，用于保存这个定时规则。需要注意的是<strong>每次重新执行<code>crontab -e</code>打开的都是同一个文件，不同的定时任务可以叠加处理</strong>。</li></ul><hr><h4 id="自定义文件"><a href="#自定义文件" class="headerlink" title="自定义文件"></a>自定义文件</h4><p>除了上述直接在编辑模式中编辑之外，还可以自定义文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim test.cron</span><br><span class="line">  58 * * * * <span class="built_in">echo</span> <span class="string">"Good morning."</span> &gt;/home/log2.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加定时任务</span></span><br><span class="line"><span class="comment">## crontab 刚刚新建的任务名</span></span><br><span class="line">crontab test.cron </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本</span></span><br><span class="line">crontab -l</span><br><span class="line">  58 * * * * <span class="built_in">echo</span> <span class="string">"Good morning."</span> &gt;/home/log2.log</span><br></pre></td></tr></table></figure><p></p><p><mark>需要注意的是：这里如果先后编辑两个文件，然后执行<code>crontab 文件名</code>，那么就会进行覆盖，也就是说最后执行的是最后一次编辑的内容。</mark></p><hr><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>有时我们创建了一个<code>crontab</code>，但是这个任务却<strong>无法自动执行</strong>，而<strong>手动执行这个任务却没有问题</strong>，这种情况<strong>一般是由于在<code>crontab</code>文件中没有配置环境变量引起的</strong>。</p><p>在<code>crontab</code>文件中定义多个调度任务时，需要特别注环境变量的设置，<strong>因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量</strong>，而<strong>系统自动执行任务调度时，是不会加载任何环境变量的</strong>，因此，就需要在<code>crontab</code>文件中<strong>指定任务运行所需的所有环境变量</strong>，这样，系统执行任务调度时就没有问题了。</p><p>不要假定<code>cron</code>知道所需要的特殊环境，它其实并不知道。所以你要保证在<code>shell</code>脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。</p><hr><h4 id="关闭邮件通知"><a href="#关闭邮件通知" class="headerlink" title="关闭邮件通知"></a>关闭邮件通知</h4><p><code>cron</code>默认会在执行一个<code>cronjob</code>后发送一封邮件的，如果执行任务勤了，会产生大量的邮件，为了避免这种情况，可以将输出重定向到一个日志文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;/home/log2.log</span></span><br><span class="line">58 * * * * <span class="built_in">echo</span> <span class="string">"Good morning."</span> &gt;/home/log2.log</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每1分钟执行一次myCommand</span></span><br><span class="line">* * * * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天早上6点执行一次myCommand</span></span><br><span class="line">0 6 * * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每两个小时执行一次myCommand</span></span><br><span class="line">0 */2 * * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔两天的上午8点到11点的第3和第15分钟执行一次myCommand</span></span><br><span class="line">3,15 8-11 */2 * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每周一上午8点到11点的第3和第15分钟执行一次myCommand</span></span><br><span class="line">3,15 8-11 * * 1 myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定使用的shell</span></span><br><span class="line">0 1 30 * * /bin/sh command.sh</span><br></pre></td></tr></table></figure><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jellythink.com/archives/155" target="_blank" rel="noopener">Linux定时执行任务Crontab</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">crontab 定时任务</a></li><li><a href="https://amito.me/2018/Using-Crontab-in-Linux/" target="_blank" rel="noopener">在 Linux 中使用 Cron 执行定时任务</a></li></ul><hr><p><br></p><h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><h3 id="安装mailx"><a href="#安装mailx" class="headerlink" title="安装mailx"></a>安装mailx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">yum install mailx</span><br></pre></td></tr></table></figure><p>安装完成测试命令却<strong>出现如下错误</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mail</span><br><span class="line">  /var/spool/mail/username: Permission denied</span><br></pre></td></tr></table></figure><p></p><p>这种情况可能就是因为当前用户<code>username</code>并没有在mail这个group中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户所属组的信息</span></span><br><span class="line">groups</span><br><span class="line">  username vboxusers</span><br></pre></td></tr></table></figure><p></p><p>可以发现当前用户<code>username</code>并没有在mail这个group中，那么就直接添加即可，具体的命令可以查看<a href="http://showteeth.tech/posts/61241.html">这个链接</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">usermod -a -G mail username</span><br></pre></td></tr></table></figure><p></p><p><strong>再次测试</strong>即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mail -h</span><br><span class="line">  mail: option requires an argument -- h</span><br><span class="line">  Usage: mail -eiIUdEFntBDNHRVv~ -T FILE -u USER -h hops -r address -s SUBJECT -a FILE -q FILE -f FILE -A ACCOUNT -b USERS -c USERS -S OPTION users</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="发件"><a href="#发件" class="headerlink" title="发件"></a>发件</h3><p>安装完成之后就可以进行发件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v：显示执行过程</span></span><br><span class="line"><span class="comment"># -s：指定邮件的主题</span></span><br><span class="line">mail -v -s <span class="string">"test"</span> <span class="built_in">test</span>@163.com</span><br><span class="line">  <span class="comment"># 随意输入一段信息作为信件内容</span></span><br><span class="line">  <span class="comment"># 然后 ctrl + D 才会让新建发送出去</span></span><br><span class="line">  <span class="comment"># 新建发送的日志</span></span><br><span class="line">  Mail Delivery Status Report will be mailed to &lt;wangjb&gt;.</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：</p><ul><li>上述命令<strong>敲入命令行之后并没有执行发件操作</strong>，而是<strong>等待输入信件内容</strong>，随意输入一段信息作为信件内容，然后 <code>ctrl + D</code> 才会让新建发送出去。</li><li>默认的发件信息是<a href="mailto:`username@loginview03.localdomain" target="_blank" rel="noopener">`username@loginview03.localdomain</a>`，其组成为：<strong>用户名@发送邮件的节点名称.localdomain</strong></li><li>发件完成之后输入<code>mail</code>命令会出现<code>You have mail in /var/spool/mail/username</code>，这个是发件的日志文件</li></ul></div><hr><h3 id="配置发件信息"><a href="#配置发件信息" class="headerlink" title="配置发件信息"></a>配置发件信息</h3><p>如果<strong>不想使用默认的邮箱作为发件信箱(可能会会很多邮箱当成是垃圾邮件)</strong>，可以对发件信息进行设置，配置文件为<code>/etc/mail.rc</code>。</p><h4 id="单个发件邮箱"><a href="#单个发件邮箱" class="headerlink" title="单个发件邮箱"></a>单个发件邮箱</h4><p><strong>配置单个邮箱时</strong>具体修改信息如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mail.rc</span><br><span class="line">  <span class="comment"># 在文件的最后添加如下命令</span></span><br><span class="line">  <span class="built_in">set</span> from=123456@qq.com</span><br><span class="line">  <span class="built_in">set</span> smtp=smtp.qq.com  </span><br><span class="line">  <span class="built_in">set</span> smtp-auth-user=123456</span><br><span class="line">  <span class="built_in">set</span> smtp-auth-password=授权码</span><br><span class="line">  <span class="built_in">set</span> smtp-auth=login</span><br></pre></td></tr></table></figure><p></p><p>发件时和前面<a href="#%e5%8f%91%e4%bb%b6">发件步骤</a>命令相同。</p><p>如果是使用<code>qq</code>邮箱，那么密码就是授权码(登录第三方客户端时，密码框请输入“授权码”进行验证)，获取方式如下：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/linux_mail_qq.png" alt="linux_mail_qq.png"></p><hr><h4 id="配置多个发件邮箱"><a href="#配置多个发件邮箱" class="headerlink" title="配置多个发件邮箱"></a>配置多个发件邮箱</h4><p>如果想要配置<strong>多个发件邮箱</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">account qq &#123;</span><br><span class="line"><span class="built_in">set</span> from=123456@qq.com <span class="comment"># 对方收到邮件时显示的发件人</span></span><br><span class="line"><span class="built_in">set</span> smtp=smtp.qq.com <span class="comment"># 指定第三方发邮件的smtp服务器地址</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=123456 <span class="comment"># 第三方发邮件的用户名</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=授权码 <span class="comment"># 用户名对应的密码,有些邮箱填的是授权码</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth=login  <span class="comment"># SMTP的认证方式，默认是login，也可以改成CRAM-MD5或PLAIN方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">account gmail &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个时候发件操作就和前面的<a href="#%e5%8f%91%e4%bb%b6">发件步骤</a>命令有所差异：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -A：发件邮箱名称，前面定义的那个</span></span><br><span class="line">mail -v -s “主题” -A qq 收件人</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="邮件内容"><a href="#邮件内容" class="headerlink" title="邮件内容"></a>邮件内容</h3><p>邮件内容添加方式有三种：</p><ul><li><strong>命令行方式输入</strong>，这个在前面<a href="#%e5%8f%91%e4%bb%b6">发件步骤</a>已经用过了</li><li><strong>管道方式发送</strong>：<code>echo &quot;hey,how are you &quot; | mail -v -s &quot;test&quot; test@163.com</code></li><li><strong>借助重定向符进行输入</strong>：<code>mail -v -s &quot;test&quot; test@163.com &lt; test.txt</code></li></ul><hr><h3 id="添加附件"><a href="#添加附件" class="headerlink" title="添加附件"></a>添加附件</h3><p>添加附件使用<code>-a</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加附件</span></span><br><span class="line">mail -v -s “主题” -a 附件 收件人 </span><br><span class="line"><span class="comment"># 也可同时将文件内容作为正文</span></span><br><span class="line">mail -v -s “主题” -a 附件 收件人  &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>注意收件人的address在命令行的最后</strong>，不然可能会报错：<code>smtp-server: 501 Bad address syntax</code></p></div><hr><h3 id="正文和附件大小限制"><a href="#正文和附件大小限制" class="headerlink" title="正文和附件大小限制"></a>正文和附件大小限制</h3><p>Linux对发送的邮件以及附件大小存在限制，可以使用如下命令查看系统的限制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看正文大小限制</span></span><br><span class="line">postconf -d | grep message_size</span><br><span class="line">  <span class="comment"># 默认情况下都是10M的大小</span></span><br><span class="line">  message_size_limit = 10240000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看附件大小限制</span></span><br><span class="line">postconf -d | grep mailbox_size</span><br><span class="line">  <span class="comment"># 默认的大小是50M</span></span><br><span class="line">  mailbox_size_limit = 51200000</span><br></pre></td></tr></table></figure><p></p><p>因为大部分情况下使用的都是公有集群，所以这里就不写出修改默认设置的方法了。</p><hr><h3 id="发件端口"><a href="#发件端口" class="headerlink" title="发件端口"></a>发件端口</h3><p><code>mail</code>命令发送邮件默认使用<code>25</code>端口，也可以使用<code>587</code>、<code>465(ssl)</code>、<code>587</code>端口，<code>465</code>端口就是<strong>加密端口</strong>。平常一些服务器运营商会禁止使用<code>25</code>端口，使得用上面的配置则发送不去出，因此可以使用<code>587</code>端口。</p><p>设置使用<code>465</code>端口来发送邮件的<code>/etc/mail.rc</code>配置：<code>set smtp=smtps://smtp.qq.com:465</code></p><p>设置使用<code>587</code>端口来发送邮件的<code>/etc/mail.rc</code>配置：<code>set smtp=smtp.qq.com:587</code></p><hr><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>如果出现如果错误：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> certificate: Peer’s certificate issuer is not recognized.</span><br></pre></td></tr></table></figure><p></p><p>解决办法：<a href="https://www.wenjinyu.me/zh/mail-send-mail-through-the-command-line-in-linux/" target="_blank" rel="noopener">mail: 在linux上通过命令行发送邮件</a></p><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linux.die.net/man/1/mail" target="_blank" rel="noopener">mail(1) - Linux man page</a></li><li><a href="https://www.wenjinyu.me/zh/mail-send-mail-through-the-command-line-in-linux/" target="_blank" rel="noopener">mail: 在linux上通过命令行发送邮件</a></li><li><a href="https://cgspace.date/2017/08/30/linux/2017-08-30-linux-sendEmail/" target="_blank" rel="noopener">使用shell发送qq邮件</a></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/email-attachment-size-limit-734249/" target="_blank" rel="noopener">Email Attachment size limit</a></li></ul><hr><p><br></p><h2 id="设置定时任务-邮箱提醒"><a href="#设置定时任务-邮箱提醒" class="headerlink" title="设置定时任务+邮箱提醒"></a>设置定时任务+邮箱提醒</h2><p>OK，回到最原始的目的：</p><ul><li>定期检测集群存储—<strong>定期执行任务</strong></li><li>给所有用户发邮件提醒各自账户的使用情况—<strong>发送邮件</strong></li></ul><p>现在已经具备了所需的知识，那么就开始写脚本吧。</p><p>具体的脚本可以查看<a href="https://github.com/showteeth/useful_scripts" target="_blank" rel="noopener">Github</a></p><p>注意点：</p><ul><li><strong>正文大小和附件大小限制</strong>—解决办法：正文显示最大的前20个文件，附件添加不超过9M的文件(大于9M会其他前9M的信息)</li><li><strong>用户名和邮箱的对应</strong>—解决办法：使用了<a href="http://showteeth.tech/posts/17760.html">Shell中的字典</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇实战的文章，主要目的是&lt;strong&gt;定期统计集群存储使用情况并通过邮箱告知用户&lt;/strong&gt;。其中涉及到的技术点主要有：&lt;strong&gt;定时任务的设置&lt;/strong&gt;、&lt;strong&gt;集群邮件的发送&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-基础(二)</title>
    <link href="http://showteeth.tech/posts/31747.html"/>
    <id>http://showteeth.tech/posts/31747.html</id>
    <published>2019-10-27T12:19:23.000Z</published>
    <updated>2019-10-30T15:08:24.993Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>的一个补充，从另一个<strong>更加贴合日常使用的角度</strong>理解<code>Matplotlib</code>中图片的元素，将元素分为<strong>基础(primitives)类</strong>和<strong>容器(containers)类</strong>，最后<strong>结合实例</strong>的方式来加深理解。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的文章<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>中已经对<code>Matplotlib</code>有了一个大概的认知：<strong>Python绘图系统中非常重要的模块，具有很强大的对图片进行自定义的功能</strong>，同时对其组件也有了一定的认识。这里会换个角度来认识一个图片中的所有元素。</p><p>前面我们将一个图片拆分为了<code>Figure</code>、<code>Axes</code>、<code>Axis</code>、<code>Artist</code>四大部分，虽然简洁，但是和平常绘图使用还是有一定的距离，尤其是最后的那个<code>Artist</code>，太过笼统和抽象。下面我们从另一种角度对图片中的元素进行分类，使其更加贴近我们的日常使用。总的来说，可以将一个图片拆分为<strong>两类元素</strong>：</p><ul><li><strong>基础 (primitives) 类</strong>：线 (<code>line</code>)、点 (<code>marker</code>)、文字 (<code>text</code>)、图例 (<code>legend</code>)、网格 (<code>grid</code>)、标题 (<code>title</code>)、图片 (<code>image</code>) 等。</li><li><strong>容器 (containers) 类</strong>：图 (<code>figure</code>)、坐标系 (<code>axes</code>)、坐标轴 (<code>axis</code>)和刻度 (<code>tick</code>)</li></ul><p>基础类元素是我们想画出的标准对象，而容器类元素顾名思义就是包含基础类元素的对象，基础类元素画在容器类元素之上。看了上述两类元素包含的对象和作用，有没有感觉非常熟悉，自己平常绘图的过程不就是在容器类元素中添加基础类元素嘛。</p><p><strong>这里主要学习容器类元素</strong>，原因有二：一是基础类元素纷繁复杂，种类较多，且相互之间没有联系，学着比较费劲；二是基础类元素是绘制在容器类元素之上的，在学习容器类元素的过程中就会涉及到基础类元素。</p><p>首先结合之前学习的内容，我们可以知道这里的容器类元素是有层级关系的：<strong>图 &gt; 坐标系 &gt; 坐标轴 &gt; 刻度</strong></p><hr><p><br></p><h2 id="图-Figure"><a href="#图-Figure" class="headerlink" title="图(Figure)"></a>图(Figure)</h2><p>之前已经对其有过介绍，所以这里主要集中在图(Figure)的容器类元素方面的内容.</p><h3 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Figure'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_with_text.png" alt="figure_with_text.png"></p><p>关于<code>plt.text()</code>：</p><ul><li><strong>第一、二个参数</strong>是指添加的<code>text</code>的横轴和纵轴坐标</li><li><strong>第三个参数</strong>是指要<code>text</code>显示的内容</li><li><code>ha, va</code>：是对齐方式，<code>horizontalalignment</code>、<code>verticalalignment</code></li><li><code>size</code>：设置字体大小</li><li><code>alpha</code>：设置字体透明度 (<code>0.5</code> 是半透明)</li></ul><hr><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">plt.figure()</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">im = np.array(Image.open(<span class="string">'Houston Rockets.png'</span>))</span><br><span class="line">plt.imshow(im)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_with_figure.png" alt="figure_with_figure.png"></p><hr><h3 id="添加线条"><a href="#添加线条" class="headerlink" title="添加线条"></a>添加线条</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.plot( [<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>] )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_with_line.png" alt="figure_with_line.png"></p><div class="note info"><p>前面这些操作看似是直接加在<code>figure</code>上，其实并不是，实际上上述各种操作都是在<code>Axes</code>上，而<code>Axes</code>又是被包含在<code>figure</code>中。默认情况下，一个<code>figure</code>中只有一个<code>Axes</code>，所以不需要在向<code>Axes</code>添加元素时进行显式声明，所以感觉就是直接在<code>figure</code>上操作，接下来我们来看看多个<code>Axes</code>的情况，这样就会对<code>figure</code>和<code>Axes</code>以及操作的具体界面有更进一步的了解。</p></div><hr><p><br></p><h2 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a>Axes</h2><p>首先说明一下关于<code>Axes</code>和<code>Subplot</code>的关系，两者都可以表示存在多个坐标系，但是存在细微的差别：</p><ul><li><strong>子图(Subplot)</strong>在<code>figure</code>中的网格结构<strong>一定是规则的</strong></li><li><strong>坐标系(Axes)</strong>在<code>figure</code>中的网格结构<strong>可以是不规则的</strong></li></ul><p>由此可见，<strong>子图是坐标系的一个特例，来我们先研究特例。</strong></p><h3 id="子图-Subplot"><a href="#子图-Subplot" class="headerlink" title="子图(Subplot)"></a>子图(Subplot)</h3><p><strong>子图有两种生成方式</strong>：</p><ul><li><code>plt.subplots(nrows=NUM,ncols=NUM)</code>：返回一个<code>NUM x NUM</code>的<strong>数组</strong>，在哪个子图上画图就将其调出来即可，相当于是<strong>先声明再调用</strong>。</li><li><code>plt.subplot(rows=NUM, columns=NUM, i-th plots)</code>：返回<strong>单个的子图</strong>，<strong>每次画子图之前先声明是哪个子图</strong>。</li></ul><h4 id="plt-subplots"><a href="#plt-subplots" class="headerlink" title="plt.subplots"></a>plt.subplots</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建4个坐标系，2行2列</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>)</span><br><span class="line">axes</span><br><span class="line">  <span class="comment"># 二维数组，每个元素表示一个坐标系</span></span><br><span class="line">  array([[&lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f2ac6630</span>&gt;,</span><br><span class="line">          &lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f2a2b9b0</span>&gt;],</span><br><span class="line">        [&lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f2766da0</span>&gt;,</span><br><span class="line">          &lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f288f390</span>&gt;]],</span><br><span class="line">        dtype=object)</span><br><span class="line"><span class="comment"># 以每个坐标系为单位添加文字</span></span><br><span class="line"><span class="keyword">for</span> i,ax <span class="keyword">in</span> enumerate(axes.flat):</span><br><span class="line">    ax.set(xticks=[],yticks=[])</span><br><span class="line">    s=<span class="string">'subplot(2,2,'</span> + str(i) + <span class="string">')'</span></span><br><span class="line">    ax.text(<span class="number">0.5</span>,<span class="number">0.5</span>,s,ha=<span class="string">"center"</span>,va=<span class="string">"center"</span>,size=<span class="number">20</span>,alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axes_add_subplots.png" alt="axes_add_subplots.png"></p><p>上面是例子是不是很明天可以看出层级关系了：<code>figure(fig)</code>包含四个<code>Axes(ax)</code>，具体的添加<code>text</code>是在<code>ax</code>上操作的。</p><hr><h4 id="plt-subplot"><a href="#plt-subplot" class="headerlink" title="plt.subplot"></a>plt.subplot</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2行1列figure的第一个子图</span></span><br><span class="line"><span class="comment"># 声明完子图后，下面所有代码就只在这幅子图上生效，直到声明下一幅子图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'subplot(2,1,1)'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 2行1列figure的第二个子图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'subplot(2,1,2)'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axes_add_subplot.png" alt="axes_add_subplot.png"></p><div class="note info"><p><code>plt.subplot</code>和<code>plt.subplots</code>还有一个区别是：<code>plt.subplots</code>会先把子图画出来(先形成<code>2x2</code>的子图)，即使只在其中一个子图上添加了基础类元素，最后显示的时候也会将所有的子图画出来；而<code>plt.subplot</code>因为是用时在声明，所以即使使用的是<code>plt.subplot(2,2,1)</code>，最后也只会显示出这个小子图，只是其大小是符合子图的对应比例的(长和宽都是<code>figure</code>的一半)。</p></div><hr><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p><strong>坐标系比子图更通用，布局更加随意</strong>，所以在某些需要对坐标系进行特殊排布的情况就非常实用，下面就是一个使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"><span class="comment"># 创建3x3的网格</span></span><br><span class="line">G=gridspec.GridSpec(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 第1行的所有网格作为第一个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">0</span>,:])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 1'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行除最后一列之外的所有部分作为第二个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">1</span>,:<span class="number">-1</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 2'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行和第3行的最后一列的网格作为第三个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">1</span>:,<span class="number">-1</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 3'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行第1列的网格作为第三个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">-1</span>,<span class="number">0</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 4'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行第2列的网格作为第三个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">-1</span>,<span class="number">-2</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 5'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axes_add_gridspec.png" alt="axes_add_gridspec.png"></p><hr><p><br></p><h2 id="坐标轴和刻度"><a href="#坐标轴和刻度" class="headerlink" title="坐标轴和刻度"></a>坐标轴和刻度</h2><p>一个二维坐标系 (<code>Axes</code>)，有两条坐标轴 (<code>Axis</code>)：</p><ul><li>横轴：<code>X-Axis</code></li><li>纵轴：<code>Y-Axis</code></li></ul><p>而每个坐标轴都有两个元素:</p><ul><li><strong>容器类元素「刻度」</strong>：该对象里还包含<strong>刻度本身</strong>和<strong>刻度标签</strong></li><li><strong>基础类元素「标签」</strong>：该对象包含的是<strong>坐标轴标签</strong></li></ul><p><strong>「刻度」</strong> 和 <strong>「标签」</strong> 都是对象，下面代码通过改变它们一些属性值来进行可视化：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="comment"># 显示坐标轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">"Label on X-Axis"</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">"Label on Y-Axis"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改X轴的刻度标签</span></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.xaxis.get_ticklabels():</span><br><span class="line">    <span class="comment"># 设置刻度标签的字体颜色</span></span><br><span class="line">    label.set_color(<span class="string">"blue"</span>)</span><br><span class="line">    <span class="comment"># 设置刻度标签选择的角度</span></span><br><span class="line">    label.set_rotation(<span class="number">45</span>)</span><br><span class="line">    <span class="comment"># 设置刻度标签选择的字体大小</span></span><br><span class="line">    label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 设置刻度Y轴的刻度本身---刻度线</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ax.yaxis.get_ticklines():</span><br><span class="line">    <span class="comment"># 设置刻度线的颜色</span></span><br><span class="line">    line.set_color(<span class="string">"red"</span>)</span><br><span class="line">    <span class="comment"># 设置刻度线长度(凸出部分的长度)</span></span><br><span class="line">    line.set_markersize(<span class="number">30</span>)</span><br><span class="line">    <span class="comment"># 设置刻度线的宽度</span></span><br><span class="line">    line.set_markeredgewidth(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axis_tick_add.png" alt="axis_tick_add.png"></p><hr><p><br></p><h2 id="关于图形选择"><a href="#关于图形选择" class="headerlink" title="关于图形选择"></a>关于图形选择</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/choosing_a_good_chart_en.png" alt="choosing_a_good_chart_en.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/choosing_a_good_chart_zh.png" alt="choosing_a_good_chart_zh.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&amp;mid=2247487597&amp;idx=2&amp;sn=e2a61c9637900d7bcb3fb658a28758a3&amp;chksm=fb39b566cc4e3c70fc6d06c5be5b962dee3e68ce66e51b03533db5cd9fd60cd0c51a64fb3d3f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1571474906951&amp;sharer_shareid=1b54e58f922202bb93a6ffe28bb2f3a7&amp;key=7fbd4d18e8fd1c6fff6d9c4f75a5f7a7aa84450f1bafdbddcb15955ec1c1602ad5b32e505be4f4262cb7c3a654ae46ad1f778ab74bfca91c73afbcc665063b69ce1f6fe3338b9a0ae66edf55bbfdbebc&amp;ascene=1&amp;uin=MjU2NzcxOTIxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060841&amp;lang=zh_CN&amp;pass_ticket=GwsbQV788IMD6AiagF%2BPxa50XmG0oazH9xqtxGhmt5vIPH0QkD3SChoH46%2Fsdj%2FX" target="_blank" rel="noopener">干货一文掌握Matplotlib的使用方法</a></li><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplots.html" target="_blank" rel="noopener">matplotlib.pyplot.subplots</a></li><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplot.html" target="_blank" rel="noopener">matplotlib.pyplot.subplot</a></li><li><a href="https://matplotlib.org/3.1.1/gallery/subplots_axes_and_figures/gridspec_multicolumn.html#sphx-glr-gallery-subplots-axes-and-figures-gridspec-multicolumn-py" target="_blank" rel="noopener">Using Gridspec to make multi-column/row subplot layouts</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是&lt;a href=&quot;http://showteeth.tech/posts/4719.html&quot;&gt;Python系列之Matplotlib-基础&lt;/a&gt;的一个补充，从另一个&lt;strong&gt;更加贴合日常使用的角度&lt;/strong&gt;理解&lt;code&gt;Matplotlib&lt;/code&gt;中图片的元素，将元素分为&lt;strong&gt;基础(primitives)类&lt;/strong&gt;和&lt;strong&gt;容器(containers)类&lt;/strong&gt;，最后&lt;strong&gt;结合实例&lt;/strong&gt;的方式来加深理解。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python绘图系列-matplotlib中50个最常用的图</title>
    <link href="http://showteeth.tech/posts/56749.html"/>
    <id>http://showteeth.tech/posts/56749.html</id>
    <published>2019-10-23T08:01:54.000Z</published>
    <updated>2019-10-27T08:02:07.720Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章对应于<a href="http://showteeth.tech/posts/59768.html">R绘图系列-ggplot2中50个最常用的图</a>，参考<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/" target="_blank" rel="noopener">Top 50 matplotlib Visualizations – The Master Plots (with full python code)</a>给出了matplotlib中最常用的50个图，这里mark一下，便于学习使用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这篇文章起源于<a href="http://showteeth.tech/posts/59768.html">R绘图系列-ggplot2中50个最常用的图</a>，这里对应于<code>ggplot2</code>中常用的50个图给出了<code>matplotlib</code>中常用的50个图，具体的参考文章是<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/" target="_blank" rel="noopener">Top 50 matplotlib Visualizations – The Master Plots (with full python code)</a>。</p><hr><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>因为这里所有的图都和ggplot2中的相对应的，所以就没有继续学习，后续如果使用的话可以结合<a href="http://showteeth.tech/posts/59768.html">R绘图系列-ggplot2中50个最常用的图</a>以及<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/" target="_blank" rel="noopener">Top 50 matplotlib Visualizations – The Master Plots (with full python code)</a>、中文译文：<a href="http://liyangbit.com/pythonvisualization/matplotlib-top-50-visualizations/" target="_blank" rel="noopener">深度好文 | Matplotlib可视化最有价值的 50 个图表（附完整 Python 源代码）</a>。</p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章对应于&lt;a href=&quot;http://showteeth.tech/posts/59768.html&quot;&gt;R绘图系列-ggplot2中50个最常用的图&lt;/a&gt;，参考&lt;a href=&quot;https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top 50 matplotlib Visualizations – The Master Plots (with full python code)&lt;/a&gt;给出了matplotlib中最常用的50个图，这里mark一下，便于学习使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/Python/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="常用图" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9B%BE/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>R绘图系列-ggplot2中50个最常用的图</title>
    <link href="http://showteeth.tech/posts/59768.html"/>
    <id>http://showteeth.tech/posts/59768.html</id>
    <published>2019-10-23T04:23:44.000Z</published>
    <updated>2019-10-23T09:06:55.596Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是从<a href="http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html" target="_blank" rel="noopener">Top 50 ggplot2 Visualizations - The Master List (With Full R Code)</a>选出了我自己<strong>之前比较少用，但是又挺有实际意义的图</strong>，这里记录学习一下。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天看到了这篇文章：<a href="http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html" target="_blank" rel="noopener">Top 50 ggplot2 Visualizations - The Master List (With Full R Code)</a>，感觉里面有些解释和有些图也挺实用的，这里mark一下并挑选几个进行学习。</p><hr><h2 id="整数散点图重叠"><a href="#整数散点图重叠" class="headerlink" title="整数散点图重叠"></a>整数散点图重叠</h2><p>散点图是绘图中很常用的一种图，其可以<strong>在很直观地显示变量之间相关关系的同时保留原始的数据特征</strong>。但是在对整数类型的数据进行散点图绘制中<strong>存在的问题</strong>是：<strong>数据点之间存在重叠，这样的话很多散点信息其实就被隐藏了(重叠的数据点在散点图上只表现为单个散点)</strong>。解决这种数据重叠的方法有两种：</p><ul><li><code>Jitter Plot</code>：给点<strong>增加扰动，使点与点之间分开</strong></li><li><code>Counts Chart</code>：点的<strong>大小表示数据点的密度</strong></li></ul><h3 id="Jitter-Plot"><a href="#Jitter-Plot" class="headerlink" title="Jitter Plot"></a>Jitter Plot</h3><p><strong>对每个点的位置添加了随机的变异</strong>.</p><blockquote><p>It adds a small amount of random variation to the location of each point, and is a useful way of handling overplotting caused by discreteness in smaller datasets.</p></blockquote><p>使用<code>geom_jitter</code>替换原始的<code>geom_point</code>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"><span class="comment"># 数据</span></span><br><span class="line">data(mpg, package=<span class="string">"ggplot2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主题背景</span></span><br><span class="line">theme_set(theme_bw())  <span class="comment"># pre-set the bw theme.</span></span><br><span class="line"><span class="comment"># 普通的散点图</span></span><br><span class="line">p1 &lt;- ggplot(mpg, aes(cty, hwy)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Scatterplot with overlapping points"</span>, </span><br><span class="line">       caption=<span class="string">"Source: midwest"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了jitter</span></span><br><span class="line">p2 &lt;- ggplot(mpg, aes(cty, hwy)) + </span><br><span class="line">  geom_jitter(width = <span class="number">0.5</span>) +</span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Jittered Points"</span>)   </span><br><span class="line">grid.arrange(p1,p2,nrow=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/top_50_jitter_R.png" alt="top_50_jitter_R.png"></p><p><code>jitter</code>图明显比原始的散点图点更多(扰动之后点分开了)。<strong><code>jitter</code>中<code>width</code>参数是控制点的离散程度的</strong>，<code>width</code>值越大，那么图中的点与原始点之间的距离就越大。</p><hr><h3 id="Counts-Chart"><a href="#Counts-Chart" class="headerlink" title="Counts Chart"></a>Counts Chart</h3><p>前面使用<code>jitter</code>解决整数数据散点图重叠有一个很大的问题就是<strong>改变了原始数据的值</strong>，虽然只是在原始点附近随机扰动，并不影响最终的结果，但这对于强迫症来说可能有点难受。这里给出另一种解决方案就是<strong>修改点的大小</strong>，如果多个点重叠在同一个位置，那么画的点就大一些，这样也能很好的区分。</p><p>使用<code>geom_count</code>替换<code>geom_point</code>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line">data(mpg, package=<span class="string">"ggplot2"</span>) </span><br><span class="line"><span class="comment"># 设置主题背景</span></span><br><span class="line">theme_set(theme_bw())  <span class="comment"># pre-set the bw theme.</span></span><br><span class="line"><span class="comment"># 原始的散点图</span></span><br><span class="line">p1 &lt;- ggplot(mpg, aes(cty, hwy)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Scatterplot with overlapping points"</span>, </span><br><span class="line">       caption=<span class="string">"Source: midwest"</span>)</span><br><span class="line"><span class="comment"># count chart</span></span><br><span class="line">p3 &lt;- ggplot(mpg, aes(cty, hwy)) +  </span><br><span class="line">  geom_count(col=<span class="string">"tomato3"</span>, show.legend=<span class="literal">F</span>) +</span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Counts Plot"</span>)</span><br><span class="line">grid.arrange(p1,p3,nrow=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/top_50_count_R.png" alt="top_50_count_R.png"></p><hr><h2 id="选中部分画圈"><a href="#选中部分画圈" class="headerlink" title="选中部分画圈"></a>选中部分画圈</h2><p>选中部分的数据点，在图中将其圈起来(使用多边形圈起来，不是圆或者椭圆)。这个可以<strong>适用于PCA选中不同群的点</strong>以及<strong>其他任意想要圈起来的</strong>。</p><p>这部分需要使用的是一个<code>ggplot2</code>插件：<a href="https://github.com/hrbrmstr/ggalt" target="_blank" rel="noopener">ggalt</a>。所谓插件的意思就是可以在原有ggplot2图形的基础上添加语法即可完成想要的图。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装proj</span></span><br><span class="line"><span class="comment"># 可以直接使用conda安装</span></span><br><span class="line">conda install -c conda-forge proj</span><br><span class="line"><span class="comment"># proj安装完成之后再安装ggalt</span></span><br><span class="line">install.packages(<span class="string">"ggalt"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="任意部分画圈"><a href="#任意部分画圈" class="headerlink" title="任意部分画圈"></a>任意部分画圈</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(ggalt)</span><br><span class="line"><span class="comment"># 得到选中的区域</span></span><br><span class="line">midwest_select &lt;- midwest[midwest$poptotal &gt; <span class="number">350000</span> &amp; </span><br><span class="line">                            midwest$poptotal &lt;= <span class="number">500000</span> &amp; </span><br><span class="line">                            midwest$area &gt; <span class="number">0.01</span> &amp; </span><br><span class="line">                            midwest$area &lt; <span class="number">0.1</span>, ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画多边形将上面选中的圈起来</span></span><br><span class="line">ggplot(midwest, aes(x=area, y=poptotal)) + </span><br><span class="line">  geom_point(aes(col=state, size=popdensity)) +   <span class="comment"># draw points</span></span><br><span class="line">  geom_smooth(method=<span class="string">"loess"</span>, se=<span class="literal">F</span>) + </span><br><span class="line">  xlim(c(<span class="number">0</span>, <span class="number">0.1</span>)) + </span><br><span class="line">  ylim(c(<span class="number">0</span>, <span class="number">500000</span>)) +   <span class="comment"># draw smoothing line</span></span><br><span class="line">  <span class="comment"># 这个是画多边形的</span></span><br><span class="line">  geom_encircle(aes(x=area, y=poptotal), </span><br><span class="line">                data=midwest_select, </span><br><span class="line">                color=<span class="string">"red"</span>, </span><br><span class="line">                size=<span class="number">2</span>, </span><br><span class="line">                expand=<span class="number">0.08</span>) +   <span class="comment"># encircle</span></span><br><span class="line">  labs(subtitle=<span class="string">"Area Vs Population"</span>, </span><br><span class="line">       y=<span class="string">"Population"</span>, </span><br><span class="line">       x=<span class="string">"Area"</span>, </span><br><span class="line">       title=<span class="string">"Scatterplot + Encircle"</span>, </span><br><span class="line">       caption=<span class="string">"Source: midwest"</span>)</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>expand</code>：画的多边形<strong>向外扩的大小</strong></li><li><code>color</code>：多边形<strong>圈的颜色</strong></li><li><code>size</code>：<strong>线的宽度</strong></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/scatter_circle.png" alt="scatter_circle.png"></p><hr><h3 id="PCA部分"><a href="#PCA部分" class="headerlink" title="PCA部分"></a>PCA部分</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(ggalt)</span><br><span class="line"><span class="keyword">library</span>(ggfortify)</span><br><span class="line">theme_set(theme_classic())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute data with principal components ------------------</span></span><br><span class="line">df &lt;- iris[c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line">pca_mod &lt;- prcomp(df)  <span class="comment"># compute principal components</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data frame of principal components ----------------------</span></span><br><span class="line">df_pc &lt;- data.frame(pca_mod$x, Species=iris$Species)  <span class="comment"># dataframe of principal components</span></span><br><span class="line">df_pc_vir &lt;- df_pc[df_pc$Species == <span class="string">"virginica"</span>, ]  <span class="comment"># df for 'virginica'</span></span><br><span class="line">df_pc_set &lt;- df_pc[df_pc$Species == <span class="string">"setosa"</span>, ]  <span class="comment"># df for 'setosa'</span></span><br><span class="line">df_pc_ver &lt;- df_pc[df_pc$Species == <span class="string">"versicolor"</span>, ]  <span class="comment"># df for 'versicolor'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot ----------------------------------------------------</span></span><br><span class="line">ggplot(df_pc, aes(PC1, PC2, col=Species)) + </span><br><span class="line">  geom_point(aes(shape=Species), size=<span class="number">2</span>) +   <span class="comment"># draw points</span></span><br><span class="line">  labs(title=<span class="string">"Iris Clustering"</span>, </span><br><span class="line">       subtitle=<span class="string">"With principal components PC1 and PC2 as X and Y axis"</span>,</span><br><span class="line">       caption=<span class="string">"Source: Iris"</span>) + </span><br><span class="line">  coord_cartesian(xlim = <span class="number">1.2</span> * c(min(df_pc$PC1), max(df_pc$PC1)), </span><br><span class="line">                  ylim = <span class="number">1.2</span> * c(min(df_pc$PC2), max(df_pc$PC2))) +   <span class="comment"># change axis limits</span></span><br><span class="line">  geom_encircle(data = df_pc_vir, aes(x=PC1, y=PC2)) +   <span class="comment"># draw circles</span></span><br><span class="line">  geom_encircle(data = df_pc_set, aes(x=PC1, y=PC2)) + </span><br><span class="line">  geom_encircle(data = df_pc_ver, aes(x=PC1, y=PC2))</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/pca_circle_ggplot.png" alt="pca_circle_ggplot.png"></p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他有意思的图如<strong>分组之间连线(Slope Chart)</strong>、<strong>哑铃图(Dumbbell Plot)</strong>，具体可以直接看原文：<a href="http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html" target="_blank" rel="noopener">Top 50 ggplot2 Visualizations - The Master List (With Full R Code)</a>，或者译文：<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODQ1MzQ0Mg==&amp;mid=2648661801&amp;idx=1&amp;sn=05cc8ff30e1e9831dc7163e0bc8beb38&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">50个ggplot2可视化案例</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是从&lt;a href=&quot;http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top 50 ggplot2 Visualizations - The Master List (With Full R Code)&lt;/a&gt;选出了我自己&lt;strong&gt;之前比较少用，但是又挺有实际意义的图&lt;/strong&gt;，这里记录学习一下。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/R/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="常用图" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9B%BE/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python绘图系列-给boxplot添加统计性的注释</title>
    <link href="http://showteeth.tech/posts/26853.html"/>
    <id>http://showteeth.tech/posts/26853.html</id>
    <published>2019-10-21T06:58:44.000Z</published>
    <updated>2019-10-23T04:24:35.405Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Python</code>中如何<strong>给<code>boxplot</code>添加两两之间比较的统计注释信息</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这篇文章起源于<a href="http://showteeth.tech/posts/40911.html">R绘图系列-带有significant信息的boxplot</a>，因为<code>R</code>中有可以对<code>boxplot</code>两两样本之间<strong>添加显著性注释</strong>的包，这里对应地记录一下<code>Python</code>中<strong>实现相同目的需要的包</strong>和<strong>基本命令</strong>。</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为该包没有发表在<code>Pypi</code>上，所以不可以直接使用<code>pip</code>安装，这里直接使用<code>setup.py</code>安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone到本地目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/webermarcolivier/statannot.git</span><br><span class="line"><span class="comment"># 如果没有权限将它安装到系统Python库中去，可以使用如下命令</span></span><br><span class="line"><span class="comment"># 会安装在~/.local/</span></span><br><span class="line">python setup.py install --user</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>特点</strong>：</p><ul><li>给由<code>seaborn boxplot</code>画出的<code>boxplot</code>添加<strong>统计注释</strong></li><li>内置的检验：<ul><li><code>Mann-Whitney</code>—<strong>非参检验(不要求正态分布)</strong></li><li><code>t-test (independent and paired)</code>—<strong>配对和不配对的t检验</strong></li><li><code>Welch&#39;s t-test</code>—<strong>方差不同情况下的t检验</strong></li></ul></li><li>可以控制统计注释在<strong>图内还是图外</strong>以及<strong>多个注释之间的间隔</strong></li><li>统计注释有三种格式：<ul><li><strong>star annotation</strong>：对应的参数<code>star</code>，这个是<strong>默认格式</strong>，<ul><li><code>ns</code>: 5.00e-02 &lt; p &lt;= 1.00e+00</li><li><code>*</code>: 1.00e-02 &lt; p &lt;= 5.00e-02</li><li><code>**</code>: 1.00e-03 &lt; p &lt;= 1.00e-02</li><li><code>***</code>: 1.00e-04 &lt; p &lt;= 1.00e-03</li><li><code>****</code>: p &lt;= 1.00e-04</li></ul></li><li><strong>simplified pvalue</strong>：对应的参数是<code>simple</code>，这个会<strong>直接显示pvalue数值</strong></li><li><strong>explicit pvalue</strong>：对应的参数是<code>full</code>，这个会显示使用的<strong>检验名称</strong>、<strong>pvalue的数值</strong></li></ul></li></ul><p>具体使用可以参考<a href="https://nbviewer.jupyter.org/github/webermarcolivier/statannot/blob/master/example/example.ipynb" target="_blank" rel="noopener">statannot使用example</a></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/webermarcolivier/statannot" target="_blank" rel="noopener">statannot的Github</a></li><li><a href="https://nbviewer.jupyter.org/github/webermarcolivier/statannot/blob/master/example/example.ipynb" target="_blank" rel="noopener">statannot使用example</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Python&lt;/code&gt;中如何&lt;strong&gt;给&lt;code&gt;boxplot&lt;/code&gt;添加两两之间比较的统计注释信息&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/Python/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
      <category term="annotation" scheme="http://showteeth.tech/tags/annotation/"/>
    
      <category term="boxplot" scheme="http://showteeth.tech/tags/boxplot/"/>
    
  </entry>
  
  <entry>
    <title>R绘图系列-带有significant信息的boxplot</title>
    <link href="http://showteeth.tech/posts/40911.html"/>
    <id>http://showteeth.tech/posts/40911.html</id>
    <published>2019-10-21T06:18:00.000Z</published>
    <updated>2019-10-23T04:24:19.325Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用R中的<code>ggsignif</code>包对<code>boxplot</code>两两样本之间<strong>添加显著性注释</strong>的过程；其实这个包可以两两对比的使用<code>ggplot2</code>画图的都可以添加，对<strong>任何可以两两对比的、使用<code>ggplot2</code>画图的都可以添加</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>boxplot</code>既可以很好地显示某个属性内部样本点的变化，也可以与其他属性进行对比，所以使用非常广泛。但是有时候我们需要对属性之间的样本点变化有个准确的度量，也就是比较两个样本是不是存在显著性地差异，这个时候就需要在原始的<code>boxplot</code>上加上样本之间假设检验的显著性信息。</p><hr><h2 id="ggsignif"><a href="#ggsignif" class="headerlink" title="ggsignif"></a>ggsignif</h2><p><code>R</code>中的<code>ggsignif</code>就是专门解决前面遇到问题的包，<a href="https://www.jianshu.com/p/678213d605a5" target="_blank" rel="noopener">其他包如ggpubr</a>也可以达到类似的目的，这里主要学习<code>ggsignif</code>，因为其是基于<code>ggplot2</code>的语法，相当于是<a href="https://www.ggplot2-exts.org/gallery/" target="_blank" rel="noopener">ggplot2的一个拓展</a>，这也就意味着<strong>其不仅可以对<code>boxplot</code>添加显著性，对于任何可以两两对比的使用<code>ggplot2</code>画图的都可以添加</strong>，很是方便；同时对熟悉<code>ggplot2</code>的人来说也比较容易上手。下面来简单介绍其使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">install.packages(<span class="string">"ggsignif"</span>)</span><br><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(ggsignif)</span><br></pre></td></tr></table></figure><hr><h3 id="简单绘制"><a href="#简单绘制" class="headerlink" title="简单绘制"></a>简单绘制</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(x=Species, y=Sepal.Length)) + </span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  geom_signif(comparisons = list(c(<span class="string">"versicolor"</span>, <span class="string">"virginica"</span>)), </span><br><span class="line">              map_signif_level=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/boxplot_with_sign.png" alt="boxplot_with_sign.png"></p><div class="note info"><p>注意<strong>默认的检验的两个样本的非参检验(不需要样本符合正太分布)</strong>：<code>‘Mann-Whitney’ test.(wilcox.test)</code></p></div><hr><h2 id="自定义绘制"><a href="#自定义绘制" class="headerlink" title="自定义绘制"></a>自定义绘制</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两两比较的列表</span></span><br><span class="line">compaired &lt;- list(c(<span class="string">"versicolor"</span>, <span class="string">"virginica"</span>), </span><br><span class="line">                  c(<span class="string">"versicolor"</span>,<span class="string">"setosa"</span>), </span><br><span class="line">                  c(<span class="string">"virginica"</span>,<span class="string">"setosa"</span>))</span><br><span class="line"><span class="comment"># 使用t.test代替默认的wilcox.test</span></span><br><span class="line">ggplot(iris, aes(Species, Sepal.Width, fill = Species)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  ylim(<span class="number">1.5</span>, <span class="number">6.5</span>) +</span><br><span class="line">  geom_signif(comparisons = compaired,</span><br><span class="line">              step_increase = <span class="number">0.3</span>,</span><br><span class="line">              map_signif_level = <span class="literal">F</span>,</span><br><span class="line">              test = t.test)</span><br></pre></td></tr></table></figure><ul><li><code>step_increase</code>：调整每个显著性标记之间的间隔。</li><li><code>test</code>：指定要使用的检验类型，默认是<code>wilcox.test</code></li><li><code>map_signif_level</code>：是显示具体<code>pvalue</code>还是显示符号<code>c(&quot;***&quot;=0.001,&quot;**&quot;=0.01, &quot;*&quot;=0.05)</code>，可以自行指定符号。</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/boxplot_with_sign_2.png" alt="boxplot_with_sign_2.png"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(Species, Sepal.Width, fill = Species)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  ylim(<span class="number">1.5</span>, <span class="number">6.5</span>) +</span><br><span class="line">  geom_signif(comparisons = compaired,</span><br><span class="line">              map_signif_level = <span class="literal">F</span>,</span><br><span class="line">              y_position=c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),</span><br><span class="line">              tip_length = c(<span class="number">0</span>),</span><br><span class="line">              test = t.test)</span><br></pre></td></tr></table></figure><ul><li><code>y_position</code>：指定显著性标记的高度，如<code>y_position=c(4,5,6)</code></li><li><code>tip_length</code>：设置横线两端向下生出的长度，如 <code>tip_length = c(0)</code></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/boxplot_with_sign_3.png" alt="boxplot_with_sign_3.png"></p><p>其他常用参数：</p><ul><li><code>annotations</code>：character vector with alternative annotations, <strong>if not null test is ignored</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/const-ae/ggsignif" target="_blank" rel="noopener">ggsignif的Github</a></li><li><a href="https://cran.r-project.org/web/packages/ggsignif/ggsignif.pdf" target="_blank" rel="noopener">ggsignif的文档</a></li><li><a href="https://cran.r-project.org/web/packages/ggsignif/vignettes/intro.html" target="_blank" rel="noopener">ggsignif官方介绍</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzQzMjU4Mw==&amp;mid=2247487837&amp;idx=3&amp;sn=6559108238df05ddbb261416bbc0851c&amp;chksm=ec736d35db04e423545b852bb6eedbc2275b0a884f85513fdf06770e35f1f105fa9f6d360141&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1570442620363&amp;sharer_shareid=1b54e58f922202bb93a6ffe28bb2f3a7&amp;key=0a90e6804693187e27a3239b02db27a4572be4a61502c8d3c582ed2cf63ac02fb7c1f7ba2c4ddcf96ee86e173f89f985e926f84a233154d2660ff56f51e0fda374a6b37deda76be77484d35e635e4165&amp;ascene=1&amp;uin=MjU2NzcxOTIxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060841&amp;lang=zh_CN&amp;pass_ticket=62x9VlAM9BQRQsx6qYImjeGo2KjVm0E3ZgT1cQ7V8AytSS45gCiqY%2FtyNXhl%2B6mt" target="_blank" rel="noopener">Boxplot | 用R画一个漂亮的boxplot</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3Mzc1MzczMA==&amp;mid=2247484318&amp;idx=1&amp;sn=aeeb47d5f0cc6ce0971032f4709393ef&amp;chksm=eb1f3073dc68b9651aa3fe1fed06db66ade6231c5f9790868ffcf680e76f67e329e04f823da3&amp;scene=21" target="_blank" rel="noopener">神奇小工具丨ggplot绘图显著性添加工具—ggsignif</a></li><li><a href="http://www.bioinfo-scrounger.com/archives/403" target="_blank" rel="noopener">R作图 显著性绘制工具-ggsignif</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了使用R中的&lt;code&gt;ggsignif&lt;/code&gt;包对&lt;code&gt;boxplot&lt;/code&gt;两两样本之间&lt;strong&gt;添加显著性注释&lt;/strong&gt;的过程；其实这个包可以两两对比的使用&lt;code&gt;ggplot2&lt;/code&gt;画图的都可以添加，对&lt;strong&gt;任何可以两两对比的、使用&lt;code&gt;ggplot2&lt;/code&gt;画图的都可以添加&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/R/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
      <category term="boxplot" scheme="http://showteeth.tech/tags/boxplot/"/>
    
  </entry>
  
  <entry>
    <title>Python绘图系列-处理annotation重叠</title>
    <link href="http://showteeth.tech/posts/46875.html"/>
    <id>http://showteeth.tech/posts/46875.html</id>
    <published>2019-10-21T05:41:36.000Z</published>
    <updated>2019-10-23T04:24:30.575Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>R</code>和<code>Python</code>中<strong>对<code>annotation</code>重叠进行自动调整的包</strong>，便于日后查询使用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前不管在使用<code>R</code>语言绘图还是<code>Python</code>绘图都会涉及到<strong>对图中的某些点进行注释</strong>的问题，点比较少并且分得开也还好，但是一旦点比较多或者想要标注的点比较密集就很容易遇到annotation重叠的问题，这种情况下自己慢慢调整就非常费劲。今天刚好看到有文章在分享关于解决<code>R</code>中<code>annotation</code>注释重叠的问题(专门的基于<code>ggplot2</code>的包来解决这个问题)，顺藤摸瓜居然发现<code>Python</code>也已经有了类似的包可以解决<code>annotation</code>重叠(白高兴一场，本来以为自己可以开发一个自动调整<code>annotation</code>的包来着)，这里就记录一下这个包，日后需要的时候方便。</p><hr><h2 id="Python-adjustText"><a href="#Python-adjustText" class="headerlink" title="Python-adjustText"></a>Python-adjustText</h2><p>在具体使用方面总的来说是<strong>先使用<code>Matplotlib</code>的命令将图画出来</strong>，然后<strong>再使用该包的一些命令对<code>annotation</code>进行调整</strong>(没有脱离于<code>Matplotlib</code>，大大增强了其易用性)：</p><ul><li><a href="https://github.com/Phlya/adjustText" target="_blank" rel="noopener">Github链接</a></li><li><a href="https://adjusttext.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a></li><li><a href="https://github.com/Phlya/adjustText/wiki" target="_blank" rel="noopener">wiki</a></li><li><a href="https://nbviewer.jupyter.org/github/Phlya/adjustText/blob/master/docs/source/Examples.ipynb" target="_blank" rel="noopener">使用example</a></li></ul><hr><h2 id="R-ggrepel"><a href="#R-ggrepel" class="headerlink" title="R-ggrepel"></a>R-ggrepel</h2><p>上面的<code>adjustText</code>就是基于R包<code>ggrepel</code>思想来开发的，该包在我看来最大的好处就是<strong>没有脱离于<code>ggplot2</code>(属于<a href="https://www.ggplot2-exts.org/gallery/" target="_blank" rel="noopener">ggplot2的拓展</a>)</strong>，也就是说使用者可以在常规地<code>ggplot2</code>绘图脚本之后添加一行命令就可以达到调整<code>annotation</code>重叠的目的(吹爆这个特点)：</p><ul><li><a href="https://github.com/slowkow/ggrepel" target="_blank" rel="noopener">Github链接</a></li><li><a href="https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html" target="_blank" rel="noopener">ggrepel examples</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;R&lt;/code&gt;和&lt;code&gt;Python&lt;/code&gt;中&lt;strong&gt;对&lt;code&gt;annotation&lt;/code&gt;重叠进行自动调整的包&lt;/strong&gt;，便于日后查询使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="绘图" scheme="http://showteeth.tech/categories/Python/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="绘图" scheme="http://showteeth.tech/tags/%E7%BB%98%E5%9B%BE/"/>
    
      <category term="annotation" scheme="http://showteeth.tech/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>设置Github项目徽章</title>
    <link href="http://showteeth.tech/posts/19563.html"/>
    <id>http://showteeth.tech/posts/19563.html</id>
    <published>2019-10-19T14:55:21.000Z</published>
    <updated>2019-10-19T15:52:04.460Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了为自己的<a href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener">项目</a><strong>增加徽章</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>Github</code>上我们经常能看到一些项目的小徽章(<code>Badge</code>)，这些小徽章可以很简洁明了地介绍项目信息，比如下面<code>pandas</code>的项目徽章：</p><table><tr><td>Latest Release</td><td><a href="https://pypi.org/project/pandas/" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/v/pandas.svg" alt="latest release"></a></td></tr><td></td><td><a href="https://anaconda.org/anaconda/pandas/" target="_blank" rel="noopener"><img src="https://anaconda.org/conda-forge/pandas/badges/version.svg" alt="latest release"></a></td><tr><td>Package Status</td><td><a href="https://pypi.org/project/pandas/" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/status/pandas.svg" alt="status"></a></td></tr><tr><td>License</td><td><a href="https://github.com/pandas-dev/pandas/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/l/pandas.svg" alt="license"></a></td></tr><tr><td>Build Status</td><td><a href="https://travis-ci.org/pandas-dev/pandas" target="_blank" rel="noopener"><img src="https://travis-ci.org/pandas-dev/pandas.svg?branch=master" alt="travis build status"></a></td></tr><tr><td></td><td><a href="https://dev.azure.com/pandas-dev/pandas/_build/latest?definitionId=1&branch=master" target="_blank" rel="noopener"><img src="https://dev.azure.com/pandas-dev/pandas/_apis/build/status/pandas-dev.pandas?branch=master" alt="Azure Pipelines build status"></a></td></tr><tr><td>Coverage</td><td><a href="https://codecov.io/gh/pandas-dev/pandas" target="_blank" rel="noopener"><img src="https://codecov.io/github/pandas-dev/pandas/coverage.svg?branch=master" alt="coverage"></a></td></tr><tr><td>Downloads</td><td><a href="https://pandas.pydata.org" target="_blank" rel="noopener"><img src="https://anaconda.org/conda-forge/pandas/badges/downloads.svg" alt="conda-forge downloads"></a></td></tr><tr><td>Gitter</td><td><a href="https://gitter.im/pydata/pandas" target="_blank" rel="noopener"><img src="https://badges.gitter.im/Join%20Chat.svg"></a></td></tr></table><p>这篇文章将会学习如何给自己的项目加上一些项目徽章。</p><h2 id="徽章生成网站"><a href="#徽章生成网站" class="headerlink" title="徽章生成网站"></a>徽章生成网站</h2><p>GitHub 项目的徽章可以使用<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>来生成。使用该网站生成徽章主要有两种方法：</p><ul><li><a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>自动推荐。这种方法只需要你提供<code>Github</code>项目的<code>url</code>链接，<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>会依据你的项目项目信息进行推荐，一般会包括<code>Github issues</code>、<code>Github forks</code>、<code>Github stars</code>、<code>Github license</code>、<code>Twitter</code>。</li><li><strong>生成自定义的徽章标签</strong>。如果想要自己修改徽章的文字和颜色，<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>也支持自定义的方式来进行设置。</li></ul><h2 id="自动推荐徽章"><a href="#自动推荐徽章" class="headerlink" title="自动推荐徽章"></a>自动推荐徽章</h2><h3 id="得到徽章"><a href="#得到徽章" class="headerlink" title="得到徽章"></a>得到徽章</h3><p>打开<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>，输入<code>Github</code>项目链接，点击<code>Suggest badges</code>即可，具体效果如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章.png" alt="Github项目徽章.png"></p><h3 id="设置徽章"><a href="#设置徽章" class="headerlink" title="设置徽章"></a>设置徽章</h3><p>点击图标或者链接，即可进入设置页，设置图标的颜色、样式等属性，最后选择你想要的 <code>markdown</code> 或者 <code>URL</code> 代码到 <code>README.md</code> 或者项目的文档页面即可:<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_2.png" alt="Github项目徽章_2.png"></p><p>效果图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_3.png" alt="Github项目徽章_3.png"></p><h2 id="自定义徽章"><a href="#自定义徽章" class="headerlink" title="自定义徽章"></a>自定义徽章</h2><p>打开<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>，找到<code>Your Badge</code>，输入<code>label</code>、<code>message</code>和<code>color</code>，<code>Make Badge</code>即可：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_4.png" alt="Github项目徽章_4.png"></p><p>最后将得到的信息加入到项目的<code>README.md</code>中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置了超链接</span></span><br><span class="line">[![blog__reprint](https://img.shields.io/badge/showteeth-blog__reprint-yellow)](https://github.com/showteeth/blog_reprint)</span><br><span class="line">[![GitHub forks](https://img.shields.io/github/forks/showteeth/blog_reprint)](https://github.com/showteeth/blog_reprint/network)</span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果图</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_5.png" alt="Github项目徽章_5.png"></p><div class="note info"><p>总结：</p><ul><li>实际上徽章就是<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>帮助我们<strong>生成的一些小图片</strong>，得到这些图片后我们可以将其以<code>markdown</code>的语法加载<code>.md</code>文件中；</li><li><strong>徽章是静态的</strong>，不会根据项目内容的改变而做出自动的调整，所以<strong>如果项目更改了和徽章相关的信息就需要手动对其进行修改</strong>。</li></ul></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了为自己的&lt;a href=&quot;https://github.com/showteeth/blog_reprint&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目&lt;/a&gt;&lt;strong&gt;增加徽章&lt;/strong&gt;的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-两种绘图接口的统一</title>
    <link href="http://showteeth.tech/posts/22997.html"/>
    <id>http://showteeth.tech/posts/22997.html</id>
    <published>2019-10-19T14:15:42.000Z</published>
    <updated>2019-10-19T15:52:04.442Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>plt.gca()</code>将<code>Matplotlib</code>的<code>state-based interface</code>转化为<code>object-oriented interface</code>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>文章中提到过<code>Matplotlib</code>有两种让初学者非常难受的地方，其中之一就是其有<strong>两种绘图接口(两种绘图的语法)</strong>，这意味着使用<code>Matplotlib</code>绘图需要记住两种截然不同的绘图语法规则，这是非常痛苦的，尤其是在需要对图片进行自定义地调整的时候。基于这种情况，如果能够找到一种方法将两种绘图接口统一起来，那就极大减少<code>Matplotlib</code>的使用难度。这里发现了一种可以将两种绘图接口结合起来的方法：使用<code>plt.gca()</code>将<code>state-based interface</code>转化为<code>object-oriented interface</code>，下面将会仔细了解一下。</p><hr><h2 id="plt-gca"><a href="#plt-gca" class="headerlink" title="plt.gca()"></a>plt.gca()</h2><p><code>plt.gca()</code>的作用是得到<strong>当前图片的<code>Axes</code>实例</strong>，如果<code>Axes</code>不存在，那就创建一个。</p><blockquote><p>Get the <strong>current Axes instance</strong> on the current figure matching the given keyword args, or create one. If the current axes doesn’t exist, or isn’t a polar one, the appropriate axes will be created and then returned.</p></blockquote><hr><h2 id="两种接口转化"><a href="#两种接口转化" class="headerlink" title="两种接口转化"></a>两种接口转化</h2><p>以隐藏<code>tick label</code>为例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用state-based interface的方法</span></span><br><span class="line">plt.plot(range(<span class="number">10</span>))</span><br><span class="line">plt.tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用object-oriented interface的方法</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(range(<span class="number">10</span>))</span><br><span class="line">ax.tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用plt.gca()将state-based interface转换为object-oriented interface语法</span></span><br><span class="line">plt.gca().tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.gca.html" target="_blank" rel="noopener">matplotlib.pyplot.gca</a></li><li><a href="https://stackoverflow.com/questions/45381589/how-does-plt-gca-work-internally" target="_blank" rel="noopener">How does plt.gca work internally</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了使用&lt;code&gt;plt.gca()&lt;/code&gt;将&lt;code&gt;Matplotlib&lt;/code&gt;的&lt;code&gt;state-based interface&lt;/code&gt;转化为&lt;code&gt;object-oriented interface&lt;/code&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-速查表</title>
    <link href="http://showteeth.tech/posts/12679.html"/>
    <id>http://showteeth.tech/posts/12679.html</id>
    <published>2019-10-18T15:31:30.000Z</published>
    <updated>2019-10-19T15:58:44.367Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是一个<code>Matplotlib</code>绘图的速查表，便于日后使用<code>Matplotlib</code>绘图查询使用，内容源于<a href="https://github.com/rougier/matplotlib-cheatsheet/blob/master/README.md" target="_blank" rel="noopener">matplotlib-cheatsheet</a>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在系统学习<code>Matplotlib</code>绘图，恰巧看到知乎上一篇文章讲的是<code>Matplotlib</code>速查表，我大致看了一看，感觉整理地确实很详细，所以在这里学习和记录一下，以便以后查阅。</p><hr><h2 id="线条类型和常用颜色"><a href="#线条类型和常用颜色" class="headerlink" title="线条类型和常用颜色"></a>线条类型和常用颜色</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_1.png" alt="matplotlib速查_1.png"></p><p>相关名词：</p><ul><li><strong><a href="https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/joinstyle.html" target="_blank" rel="noopener">Cap styles</a></strong>: Cap styles define how the the end of a line is drawn</li><li><strong><a href="https://stackoverflow.com/questions/8750203/what-is-antialiased-in-matplotlib-collections-and-how-do-you-set-the-paramet" target="_blank" rel="noopener">Antialias</a></strong>:<ul><li>The antialiased keyword argument controls <strong>whether or not a particular matplotlib artist (e.g. line, polygon, etc) is drawn with antialising or not</strong>. <mark>Non-antialiased plotting will be faster, so if you’re plotting a large amount of data, it can be worthwhile to turn it off.</mark></li><li>简单理解就是matplotlib在画图时会对呈现的图像进行处理来使图像更加光滑，不至于出现那种锯齿状的像素块形状(混叠效应)。</li></ul></li></ul><hr><h2 id="marker的种类和颜色"><a href="#marker的种类和颜色" class="headerlink" title="marker的种类和颜色"></a>marker的种类和颜色</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_2.png" alt="matplotlib速查_2.png"></p><ul><li><strong><a href="https://matplotlib.org/examples/pylab_examples/markevery_demo.html" target="_blank" rel="noopener">Marker spacing</a></strong>：控制绘制marker的频率，如<ul><li><code>markevery=5</code>表示隔五个数据点画一个marker</li><li><code>markevery=[0, -1]</code>表示只在第一个数据点和最后一个数据点画marker</li></ul></li></ul><hr><h2 id="多边形集合"><a href="#多边形集合" class="headerlink" title="多边形集合"></a>多边形集合</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_3.png" alt="matplotlib速查_3.png"></p><hr><h2 id="常用图形"><a href="#常用图形" class="headerlink" title="常用图形"></a>常用图形</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_4.png" alt="matplotlib速查_4.png"></p><hr><h2 id="刻度控制"><a href="#刻度控制" class="headerlink" title="刻度控制"></a>刻度控制</h2><p><a href="https://matplotlib.org/3.1.1/gallery/ticks_and_spines/tick-locators.html" target="_blank" rel="noopener">官网链接</a><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_5.png" alt="matplotlib速查_5.png"></p><hr><h2 id="图片布局调整"><a href="#图片布局调整" class="headerlink" title="图片布局调整"></a>图片布局调整</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_6.png" alt="matplotlib速查_6.png"></p><hr><h2 id="legend控制"><a href="#legend控制" class="headerlink" title="legend控制"></a>legend控制</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_7.png" alt="matplotlib速查_7.png"></p><hr><h2 id="坐标轴类型-线性和对数"><a href="#坐标轴类型-线性和对数" class="headerlink" title="坐标轴类型-线性和对数"></a>坐标轴类型-线性和对数</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_8.png" alt="matplotlib速查_8.png"></p><hr><h2 id="常用colormap名称"><a href="#常用colormap名称" class="headerlink" title="常用colormap名称"></a>常用colormap名称</h2><p><a href="https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html" target="_blank" rel="noopener">官方教程</a><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_9.png" alt="matplotlib速查_9.png"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/rougier/matplotlib-cheatsheet/blob/master/matplotlib-cheatsheet.pdf" target="_blank" rel="noopener">pdf的Github地址</a></li><li><a href="https://zhuanlan.zhihu.com/p/77782561?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=680025552107343872" target="_blank" rel="noopener">Matplotlib速查表——画图时候一定要放手边的表</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是一个&lt;code&gt;Matplotlib&lt;/code&gt;绘图的速查表，便于日后使用&lt;code&gt;Matplotlib&lt;/code&gt;绘图查询使用，内容源于&lt;a href=&quot;https://github.com/rougier/matplotlib-cheatsheet/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matplotlib-cheatsheet&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>R系列之包的相关操作汇总</title>
    <link href="http://showteeth.tech/posts/28413.html"/>
    <id>http://showteeth.tech/posts/28413.html</id>
    <published>2019-10-17T01:24:59.000Z</published>
    <updated>2019-10-19T15:52:04.455Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了对<code>R</code>包的一些常用操作，包括<strong>安装<code>R</code>包的各种方法</strong>、<strong>查看已加载的包</strong>、<strong>卸除加载包</strong>、<strong>卸载R包</strong>、<strong>查看包提供的函数</strong>以及<strong>查看包的版本</strong>。</p></div><a id="more"></a><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><h3 id="install-packages安装"><a href="#install-packages安装" class="headerlink" title="install.packages安装"></a>install.packages安装</h3><p>这个是安装<code>R</code>包最常用也是最简单的方法，关键在于镜像的选择(有时候安装不成功，换个镜像说不定就成功了)：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定使用清华的镜像</span></span><br><span class="line">install.packages(<span class="string">"getopt"</span>, repos=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/CRAN"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用官方镜像</span></span><br><span class="line">install.packages(<span class="string">'ggplot2'</span>, dependencies=<span class="literal">TRUE</span>, repos=<span class="string">'http://cran.rstudio.com/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用如下方法一次指定</span></span><br><span class="line"><span class="comment"># Allow the user to set and examine a variety of global options </span></span><br><span class="line"><span class="comment"># which affect the way in which R computes and displays its results.</span></span><br><span class="line">options(repos=structure(c(CRAN=<span class="string">"http://cran.rstudio.com/"</span>)))</span><br><span class="line">install.packages(<span class="string">"ggplot2"</span>, dependencies = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="从github直接安装"><a href="#从github直接安装" class="headerlink" title="从github直接安装"></a>从github直接安装</h3><p>有些包如果没有发布在<code>CRAN(Comprehensive R Archive Network)</code>或者使用前面的安装方法不成功上可以直接从<code>github</code>上安装：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Github安装</span></span><br><span class="line"><span class="comment"># 先安装devtools，然后在利用devtools中的install_github进行安装</span></span><br><span class="line">install.packages(<span class="string">"devtools"</span>, repo=<span class="string">"http://cran.rstudio.com/"</span>)</span><br><span class="line"><span class="keyword">library</span>(devtools)</span><br><span class="line">install_github(<span class="string">"kassambara/ggpubr"</span>)</span><br></pre></td></tr></table></figure><p></p><p><code>github</code>安装<code>R</code>包还可以使用<code>githubinstall</code>包，其<strong>功能更加完善一些</strong>，可以<strong>搜索某个用户</strong>的所有包、<strong>关键词搜索R包**</strong>、显示指定<code>R</code>函数的源代码**等，不过我觉得有一个就可以了，后续如果需要再看吧。</p><hr><h3 id="Bioconductor安装"><a href="#Bioconductor安装" class="headerlink" title="Bioconductor安装"></a>Bioconductor安装</h3><p><code>Bioconductor</code>中主要包含的是进行生信分析所需要的包，如果不是生信行业从业者，这个方法可能不是很适用，不过也有可能自己需要的包包含在了<code>Bioconductor</code>中：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source一下源码</span></span><br><span class="line"><span class="comment"># 如果源码被黑存在病毒，那就gg</span></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">biocLite(<span class="string">"org.Dr.eg.db"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在R3.5.1之后，推出了BiocManager包Bioconductor包的安装</span></span><br><span class="line"><span class="comment"># 先安装BiocManager</span></span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">"BiocManager"</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">"BiocManager"</span>)</span><br><span class="line"><span class="comment"># BiocManager::install()</span></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">BiocManager::install(c(<span class="string">"GenomicFeatures"</span>, <span class="string">"AnnotationDbi"</span>))</span><br></pre></td></tr></table></figure><p></p><p>安装包的自动化脚本：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要安装的包的名称</span></span><br><span class="line">package_list &lt;- c(<span class="string">"clusterProfiler"</span>,<span class="string">"getopt"</span>,<span class="string">"org.Hs.eg.db"</span>,<span class="string">"org.Mm.eg.db"</span>,<span class="string">"topGO"</span>,<span class="string">"pathview"</span>,<span class="string">"Rgraphviz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> package_list)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!suppressWarnings(suppressMessages(<span class="keyword">require</span>(p, character.only = <span class="literal">TRUE</span>, quietly = <span class="literal">TRUE</span>, warn.conflicts = <span class="literal">FALSE</span>))))&#123;</span><br><span class="line">    <span class="comment"># Bioconductor安装</span></span><br><span class="line">    <span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">    biocLite(p)</span><br><span class="line">    suppressWarnings(suppressMessages(<span class="keyword">library</span>(p, character.only = <span class="literal">TRUE</span>, quietly = <span class="literal">TRUE</span>, warn.conflicts = <span class="literal">FALSE</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><mark>require和library加载包的区别</mark>：</p><ul><li><strong>包不存在时</strong>：使用<code>library</code>加载包会<strong>直接报错停止</strong>；而使用<code>require</code>加载则只会出现<code>Warning message</code>，<strong>不会停止执行</strong>，并且<code>require</code>命令会返回<code>FALSE</code>，所以可以<strong>利用这个特性进行检测环境是不是安装了某个包，并进行自动化安装</strong>；</li><li><strong>包存在时</strong>：都是加载包</li></ul></div><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/tandelin/article/details/87601729" target="_blank" rel="noopener">从Github上获取R包/安装</a></li><li><a href="https://www.bioconductor.org/install/" target="_blank" rel="noopener">Using Bioconductor</a></li><li><a href="https://stackoverflow.com/questions/5595512/what-is-the-difference-between-require-and-library" target="_blank" rel="noopener">What is the difference between require() and library()?</a></li></ul><hr><h2 id="查看已加载的包"><a href="#查看已加载的包" class="headerlink" title="查看已加载的包"></a>查看已加载的包</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意外面的括号和前面的点不能省</span></span><br><span class="line">(.packages())</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"htmlwidgets"</span> <span class="string">"recharts"</span>    <span class="string">"stats"</span>       <span class="string">"graphics"</span>    <span class="string">"grDevices"</span>   <span class="string">"utils"</span>       <span class="string">"datasets"</span>   </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"methods"</span></span><br></pre></td></tr></table></figure><hr><h2 id="卸除加载包"><a href="#卸除加载包" class="headerlink" title="卸除加载包"></a>卸除加载包</h2><p>注意<strong>是卸除，不是卸载</strong>，也就是说不是把包从R运行环境中彻底删除，只是<strong>不希望该包被加载使用</strong>；在<strong>包使用函数冲突</strong>，<strong>检验函数依赖</strong>时比较有用。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">detach</span>(<span class="string">"package:htmlwidgets"</span>)</span><br><span class="line">(.packages())</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"recharts"</span>  <span class="string">"stats"</span>     <span class="string">"graphics"</span>  <span class="string">"grDevices"</span> <span class="string">"utils"</span>     <span class="string">"datasets"</span>  <span class="string">"methods"</span>   <span class="string">"base"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="卸载R包"><a href="#卸载R包" class="headerlink" title="卸载R包"></a>卸载R包</h2><p><strong>彻底删除</strong>已安装的包：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># "pkg1","pkg2"表示包名，即一次可以卸载多个包；</span></span><br><span class="line">remove. packages(c(<span class="string">"pkg1"</span>,<span class="string">"pkg2"</span>) , lib = file .path(<span class="string">"path"</span>, <span class="string">"to"</span>, <span class="string">"library"</span>))</span><br><span class="line"><span class="comment"># "path", "to", "library"表示R的库路径，字符向量，通常情况下只输一个路径即可。</span></span><br><span class="line"><span class="comment"># 使用命令.libPaths()可以查看库路径。示例：</span></span><br><span class="line">&gt; .libPaths()</span><br><span class="line">[<span class="number">1</span>] <span class="string">"D:/R-3.5.1/library"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="查看某个包提供的函数"><a href="#查看某个包提供的函数" class="headerlink" title="查看某个包提供的函数"></a>查看某个包提供的函数</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(package=<span class="string">'ggplot2'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="查看包的版本"><a href="#查看包的版本" class="headerlink" title="查看包的版本"></a>查看包的版本</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packageVersion(<span class="string">"ggplot2"</span>)</span><br><span class="line">  [<span class="number">1</span>] ‘<span class="number">3.2</span><span class="number">.0</span>’</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了对&lt;code&gt;R&lt;/code&gt;包的一些常用操作，包括&lt;strong&gt;安装&lt;code&gt;R&lt;/code&gt;包的各种方法&lt;/strong&gt;、&lt;strong&gt;查看已加载的包&lt;/strong&gt;、&lt;strong&gt;卸除加载包&lt;/strong&gt;、&lt;strong&gt;卸载R包&lt;/strong&gt;、&lt;strong&gt;查看包提供的函数&lt;/strong&gt;以及&lt;strong&gt;查看包的版本&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之SGE出现Command Not Found, Undefined Variable</title>
    <link href="http://showteeth.tech/posts/35609.html"/>
    <id>http://showteeth.tech/posts/35609.html</id>
    <published>2019-10-14T14:19:53.000Z</published>
    <updated>2019-10-15T04:56:49.561Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>SGE</code>集群任务管理系统提交任务时出现的<code>Command Not Found, Undefined Variable</code>错误的<strong>原因</strong>以及<strong>解决方法</strong>，同时也列出了<strong>常用的参数</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>SGE(Sun Grid Engine)</code>集群任务管理系统提交任务时莫名出现了错误<code>Command Not Found, Undefined Variable</code>，具体就是使用<code>a=path; cd ${a}</code>，结果发现<code>a=path: Command not found; a: Undefined variable.</code>，这个错误让我很纳闷，平常在另一个机器上使用<code>SGE</code>使用同样的脚本并不会出错啊，但是为啥现在就不行了呢？这篇文章就记录了出现这个问题的原因以及可行的解决办法。</p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现上述问题的原因总的来说就是<mark>当前机器上<code>SGE</code>默认的<code>shell</code>不是<code>bash</code>，而是<code>csh</code>，而<code>csh</code>在对(局部)变量进行赋值操作时需要使用<code>set a=path</code>，而不是<code>bash</code>中常用的<code>a=path</code></mark>。</p><p>查看<code>SGE</code>集群节点的默认<code>shell</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看queue列表</span></span><br><span class="line">qconf -sql</span><br><span class="line">  all.q</span><br><span class="line">  bnode.q</span><br><span class="line">  guo.q</span><br><span class="line">  little.q</span><br><span class="line">  login04.q</span><br><span class="line">  lu.q</span><br><span class="line">  qlogin.q</span><br><span class="line">  yang.q</span><br><span class="line">  zhong.q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看自己所属队列的情况</span></span><br><span class="line">qconf -sq all.q</span><br><span class="line">  qname                 all.q</span><br><span class="line">  <span class="comment"># 主机列表，也就是这个队列可以使用的节点名称</span></span><br><span class="line">  hostlist              hpbnode-0-1.local hpbnode-0-2.local node-0-1.local \</span><br><span class="line">                        node-0-13.local node-0-14.local node-0-15.local \</span><br><span class="line">                        node-0-16.local.hpc.org node-0-18.local node-0-19.local \</span><br><span class="line">                        node-0-2.local node-0-20.local node-0-3.local \</span><br><span class="line">                        node-0-4.local node-0-5.local node-0-6.local \</span><br><span class="line">                        node-0-7.local</span><br><span class="line">  seq_no                0</span><br><span class="line">  load_thresholds       np_load_avg=1.5</span><br><span class="line">  suspend_thresholds    NONE</span><br><span class="line">  nsuspend              1</span><br><span class="line">  suspend_interval      00:05:00</span><br><span class="line">  priority              0</span><br><span class="line">  min_cpu_interval      00:05:00</span><br><span class="line">  processors            UNDEFINED</span><br><span class="line">  qtype                 BATCH INTERACTIVE</span><br><span class="line">  ckpt_list             NONE</span><br><span class="line">  pe_list               make mpi mpich openmp orte smp</span><br><span class="line">  rerun                 FALSE</span><br><span class="line">  slots                 16,[bnode02.local=32],[C-login01.local=32], \</span><br><span class="line">                        [C-login02.local=32],[C-login03.local=32], \</span><br><span class="line">                        [C-login04.local=56],[hpbnode-0-2.local=24]</span><br><span class="line">  tmpdir                /tmp</span><br><span class="line">  <span class="comment"># 默认的shell就是csh，而不是bash</span></span><br><span class="line">  <span class="comment"># 这个就是问题的关键</span></span><br><span class="line">  shell                 /bin/csh</span><br><span class="line">  prolog                NONE</span><br><span class="line">  epilog                NONE</span><br><span class="line">  shell_start_mode      posix_compliant</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>既然<code>SGE</code>默认的<code>shell</code>不是<code>bash</code>，而我们大部分对<code>bash</code>比较熟悉，所以<strong>最简单直接</strong>的办法就是将<code>SGE</code>默认的<code>shell</code>修改为<code>bash</code>，这个是一劳永逸的方法，具体的可以参考<a href="https://stackoverflow.com/questions/2020957/how-to-change-the-default-shell-for-the-sun-grid-engine" target="_blank" rel="noopener">这个</a>，因为使用的是学校的集群，所以自己不敢轻举妄动，或许也没有轻举妄动的权利，有兴趣的可以自行尝试。</p><p><strong>另一种方法，也是最推荐的方法</strong>就是在任务提交脚本中指明<code>SGE</code>使用的<code>shell</code>，使用语句：<code>#$ -S /bin/bash</code>，这样就可以直接使用熟悉的<code>bash</code>语法进行脚本的编写了。</p><p><strong>最后一种方法也是个人最不推荐的方法</strong>就是使用<code>csh</code>的语法进行脚本的编写，如上述需求可以使用：<code>set a=path</code>来解决，这种方法对于我来说不方便，有些复杂，还需要去了解<code>csh</code>的语法。</p><hr><h2 id="sge任务提交脚本示例"><a href="#sge任务提交脚本示例" class="headerlink" title="sge任务提交脚本示例"></a>sge任务提交脚本示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh This script is interpreted by the Bourne shell, sh.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The name of my job:</span></span><br><span class="line"><span class="comment">#$ -N glxspheres</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The interpreter SGE must use:</span></span><br><span class="line"><span class="comment">#$ -S /bin/shSun Grid Engine always uses sh to interpret this script.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Join stdout and stderr:</span></span><br><span class="line"><span class="comment">#$ -j y</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This job needs a graphics device:</span></span><br><span class="line"><span class="comment">#$ -l gfx=1 # Allocate a graphics resource to this job.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify that these environment variables are to be sent to SGE with the job:</span></span><br><span class="line"><span class="comment">#$ -v DISPLAY</span></span><br><span class="line"><span class="comment">#$ -v VGL_CLIENT</span></span><br><span class="line"><span class="comment">#$ -v VGL_GAMMA</span></span><br><span class="line"><span class="comment">#$ -v VGL_GLLIB</span></span><br><span class="line"><span class="comment">#$ -v VGL_SPOIL</span></span><br><span class="line"><span class="comment">#$ -v VGL_X11LIB</span></span><br><span class="line"><span class="comment">#$ -v SSH_CLIENT</span></span><br><span class="line"><span class="comment"># If these variables are not set before qsub/qrsh is invoked,</span></span><br><span class="line"><span class="comment"># then the job will find these variables set, but with a null string value ("").</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Script can run on what systems?</span></span><br><span class="line"><span class="comment"># Solaris (SPARC or x86, 32-bit or 64-bit) and Linux systems (32- or 64-bit),</span></span><br><span class="line"><span class="comment"># provided glxspheres is installed on the target system in one of the paths below.</span></span><br><span class="line"><span class="comment">#$ -l arch=sol-sparc|sol-sparc64|sol-x86|sol-amd64|lx24-x86|lx24-amd64</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># If VGL_DISPLAY is set by SGE, then run program with vglrun. Otherwise don't.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;VGL_DISPLAY+set&#125;</span>"</span> ]; <span class="keyword">then</span> If VGL_DISPLAY is <span class="built_in">set</span> (even <span class="keyword">if</span> null)...</span><br><span class="line"></span><br><span class="line">VGLRUN=/opt/VirtualGL/bin/vglrun Then the script will use vglrun to launch application.</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -x <span class="variable">$VGLRUN</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> 1&gt;&amp;2 <span class="string">"vglrun not found on host <span class="variable">$&#123;HOSTNAME:=‘hostname‘&#125;</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    VGLRUN=<span class="string">""</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>  [ -x /opt/VirtualGL/bin/glxspheres ]; <span class="keyword">then</span></span><br><span class="line">    path=/opt/VirtualGL/bin/glxspheres</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 1&gt;&amp;2 <span class="string">"glxspheres not found on host <span class="variable">$&#123;HOSTNAME&#125;</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Sun Grid Engine job starts vglrun which starts glxspheres</span></span><br><span class="line"><span class="comment"># with any arguments passed to this script.  If VGL_DISPLAY is not set,</span></span><br><span class="line"><span class="comment"># $VGLRUN will be the empty string, and vglrun won't be invoked.</span></span><br><span class="line"><span class="variable">$VGLRUN</span> <span class="string">"<span class="variable">$path</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="其他实用参数"><a href="#其他实用参数" class="headerlink" title="其他实用参数"></a>其他实用参数</h2><ul><li><code>-V</code>： 将<strong>当前的环境变量传递到执行命令的节点中</strong>，<code>Specifies that all environment variables active within the qsub utility be exported to the context of the job</code>.</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://talby.rcs.manchester.ac.uk/~ri/_linux_and_hpc_lib/sge_intro.html#jobshellsect" target="_blank" rel="noopener">An Intro to SGE</a></li><li><a href="https://stackoverflow.com/questions/17271931/sge-command-not-found-undefined-variable" target="_blank" rel="noopener">SGE Command Not Found, Undefined Variable</a></li><li><a href="https://docs.oracle.com/cd/E19279-01/820-3257-12/n1ge.html#50577430_84220" target="_blank" rel="noopener">Sun Grid Engine Reference</a></li><li><a href="http://gridscheduler.sourceforge.net/htmlman/htmlman1/qsub.html" target="_blank" rel="noopener">qsub的帮助文档，查看参数</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了使用&lt;code&gt;SGE&lt;/code&gt;集群任务管理系统提交任务时出现的&lt;code&gt;Command Not Found, Undefined Variable&lt;/code&gt;错误的&lt;strong&gt;原因&lt;/strong&gt;以及&lt;strong&gt;解决方法&lt;/strong&gt;，同时也列出了&lt;strong&gt;常用的参数&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-基础</title>
    <link href="http://showteeth.tech/posts/4719.html"/>
    <id>http://showteeth.tech/posts/4719.html</id>
    <published>2019-10-13T09:34:57.000Z</published>
    <updated>2019-10-27T13:26:42.779Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是<strong>系统</strong>学习<code>Matplotlib</code>包的开始，主要包括<strong>对<code>Matplotlib</code>的介绍</strong>、<strong>其他常用的绘图包</strong>、<strong><code>Matplotlib</code>中的两种绘图接口</strong>、<strong><code>Matplotlib</code>所接受的输入数据类型</strong>以及<strong><code>Matplotlib</code>中一些常用术语和模块关系</strong>，为以后的深入学习打下基础。</p></div><a id="more"></a><h2 id="Matplotlib简介"><a href="#Matplotlib简介" class="headerlink" title="Matplotlib简介"></a>Matplotlib简介</h2><p>在<code>Python</code>中只要是使用常规的绘图功能(交互式绘图除外)，<code>Matplotlib</code>是你必然会使用的一个<code>package</code>。有时候你的使用是<strong>显式的</strong>，有时候你的使用是<strong>隐式的</strong>，说隐式的原因是<code>Python</code>中常用的绘图包都是基于<code>Matplotlib</code>进行二次开发的，比如<code>Seaborn</code>、<code>pandas</code>(内置的一些绘图方法)、<code>plotnine</code>(类似<code>R</code>中的<code>ggplot2</code>)、<code>ggplot</code>(类似R中的<code>ggplot2</code>)。所以学习使用<code>Matplotlib</code>是使用<code>Python</code>进行绘图不可避免的一个环节。</p><p>但是<code>Matplotlib</code>也有一些很让<strong>初学者难受</strong>的地方：</p><ul><li><strong>两种绘图接口</strong>。一种是基于<code>MATLAB</code>的<code>state-based interface</code>，一种是<code>object-oriented interface</code>(这两种接口在后续会进行进一步地介绍)，因为存在两种绘图接口，也就是说<strong>可以使用两套代码来完成同一个图</strong>，在实际使用过程中可能会<strong>带来混乱</strong>——当你使用一种<code>interface</code>绘图遇到错误去搜索的时候，发现大部分的答案是基于另一种<code>interface</code>的，直接把这种代码拷贝过来发现并不能得到别人所说的效果；</li><li><strong>基于Matplotlib的工具太多，这些工具既相似又存在很大差异</strong>。在<code>Python</code>中绘图，有时候发现<code>pandas</code>可以直接实现，有时候发现<code>Seaborn</code>也可以绘图，并且用的人也很多，但是使用的时候发现自己的需求单纯使用<code>pandas</code>、<code>Seaborn</code>可能不能解决，同时这两者绘图中的大部分语句又和<code>Matplotlib</code>类似，导致的结果就是想去学习绘图，但是又不知道从哪个<code>package</code>开始学习，最终的结果就是啥也没学会。</li></ul><p>虽然<code>Matplotlib</code>存在一些让初学者很难受的地方(我这么晚才开始系统学习<code>Matplotlib</code>的原因)，但是这些问题在初学者对<code>Matplotlib</code>有基本的学习和了解之后就可以很轻松的解决(<strong>个人的真实感受</strong>)。</p><p><br></p><h2 id="其他绘图包"><a href="#其他绘图包" class="headerlink" title="其他绘图包"></a>其他绘图包</h2><p>在具体了解<code>Matplotlib</code>之前，先详细了解一下其他目前<code>Python</code>中<strong>常用的绘图包以及其适用场景</strong>：</p><ul><li><code>Seaborn</code>：<code>Seaborn</code> 是一个基于 <code>Matplotlib</code> 的高级可视化效果库， <strong>偏向于统计作图</strong>。因此，<strong>针对的点主要是数据挖掘和机器学习中的变量特征选取</strong>。相比 <code>Matplotlib</code> ，它<strong>语法相对简化些</strong>，绘制出来的图不需要花很多功夫去修饰。但是它<strong>绘图方式比较局限，不过灵活</strong>。</li><li><code>Bokeh</code>：<code>Bokeh</code> 是基于 <code>javascript</code> 来实现<strong>交互可视化库</strong>，它可以在<code>WEB</code>浏览器中实现美观的视觉效果。但是它也有明显的<strong>缺点</strong>:其一是<strong>版本时常更新</strong>，最重要的是有时<strong>语法还不向下兼容</strong>；其二是<strong>语法晦涩</strong>。</li><li><code>Plotly</code>：<code>Plotly</code> 也是一个<strong>交互可视化库</strong>。它不仅支持 <code>Python</code> 还支持 <code>R</code> 语言。<code>Plotly</code> 的<strong>优点</strong>是能提供 <code>WEB</code> 在线交互，配色也真心好看。如果你是一名数据分析师，<code>Plotly</code> 强大的交互功能能助你一臂之力完成展示。</li><li><code>ggplot</code>：<code>ggplot</code> 是 <code>yhat</code> 大神基于 <code>R</code> 语言的 <code>ggplot2</code>制作的 <code>python</code> 版本库。 如果你使用 <code>R</code> 语言的话，<code>ggplot2</code> 可以算是必不可少的工具。所以，很多人都推荐使用该库，不过可惜的是，<code>yhat</code> 大神已<strong>经停止维护该库</strong>了(<a href="https://github.com/yhat/ggpy" target="_blank" rel="noopener">github</a>上最近一次更新还是3年之前了)。</li><li><code>plotnine</code>：<code>plotnine</code>也是一个为了在<code>Python</code>中实现<code>ggplot2</code>语法进行绘图的<code>package</code>，相比对长时间没有维护的<code>ggplot</code>，这个<code>package</code>目前仍然活跃，<a href="https://github.com/has2k1/plotnine" target="_blank" rel="noopener">github</a>上最近一次更新是2个月前，而且其<a href="https://plotnine.readthedocs.io/en/stable/" target="_blank" rel="noopener">文档</a>也比<code>ggplot</code>做得好很多，便于学习和使用。</li></ul><p><a href="https://pbpython.com/python-vis-flowchart.html" target="_blank" rel="noopener">最后附上绘图package的选择</a>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib_packages.png" alt="matplotlib_packages.png"></p><p><br></p><h2 id="关于Matplotlib中的两种绘图接口"><a href="#关于Matplotlib中的两种绘图接口" class="headerlink" title="关于Matplotlib中的两种绘图接口"></a>关于Matplotlib中的两种绘图接口</h2><h3 id="state-based-interface"><a href="#state-based-interface" class="headerlink" title="state-based interface"></a>state-based interface</h3><p>这种<code>interface</code>是基于<code>MATLAB</code>，其在创建<strong>简单图形</strong>的时候比较好用(可以使用<code>plt.XXX</code>来绘制图形的各个部分)，但是允许的<strong>对图形的控制不是很多</strong>。使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># 使用plt完成所有的绘图操作</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.title(<span class="string">'Test figure'</span>)        </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="object-oriented-interface"><a href="#object-oriented-interface" class="headerlink" title="object-oriented interface"></a>object-oriented interface</h3><p>这种方法<strong>较为复杂</strong>，但是可以<strong>对图形进行完整的控制</strong>。使用这种<code>interface</code>进行绘图的<strong>主要思想</strong>是：</p><ul><li>创建一个<code>&quot;figure&quot;</code>对象(可以将其视为可视化的边界框)</li><li>然后创建一个或多个<code>&quot;axes&quot;</code>对象(作为可视化的子图)，主要这里的<code>&quot;axes&quot;</code>需要和<code>&quot;axis&quot;</code>进行区分，<code>&quot;axes&quot;</code>是指子图，而<code>&quot;axis&quot;</code>指的是一个图形的<code>x/y</code>轴</li><li>最后可以使用<code>&quot;axes&quot;</code>对象的方法来控制子图。</li></ul><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 创建"figure"对象以及一个"axes"对象</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 使用"axes"对象的方法来控制子图</span></span><br><span class="line">ax.bar(x=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>], height=[<span class="number">3.1</span>,<span class="number">7</span>,<span class="number">4.2</span>], color=<span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(xlabel=<span class="string">'X title'</span>, size=<span class="number">20</span>)</span><br><span class="line">ax.set_ylabel(ylabel=<span class="string">'Y title'</span> , color=<span class="string">'b'</span>, size=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意事项：</p><ul><li>通常情况下，尽量使用<code>object-oriented interface</code>，而不是<code>state-based(Pyplot) interface</code>.</li><li>在<code>object-oriented interface</code>中也会用到<code>state-based(Pyplot) interface</code>，不过用到的功能很少，包括<strong>用来创建和显示图片</strong>。</li></ul></div><p><br></p><h2 id="学习和使用步骤"><a href="#学习和使用步骤" class="headerlink" title="学习和使用步骤"></a>学习和使用步骤</h2><p>在这篇文章中提到了学习和使用<code>Matplotlib</code>的步骤，我觉得不错，这里直接对其进行翻译：</p><ul><li>学习<code>Matplotlib</code>中常用的术语，尤其是什么是<code>Figure</code>以及<code>Axes</code>；</li><li>使用<code>object-oriented interface</code>，在开始分析之前就养成这种习惯；</li><li>从基本的<code>pandas</code>绘图开始进行可视化操作；</li><li>使用<code>Seaborn</code>进行<strong>更加复杂的统计可视化</strong>；</li><li>使用<code>Matplotlib</code>来对<code>pandas</code>和<code>Seaborn</code>做的图进行<strong>自定义</strong>；</li><li>有了<code>Matplotlib</code>基础再根据需求学习其他的绘图<code>package</code>，比如<code>plotly</code>等.</li></ul><p><br></p><h2 id="图形的组件"><a href="#图形的组件" class="headerlink" title="图形的组件"></a>图形的组件</h2><p><code>Matplotlib Usage</code>中对图形的<strong>每个部分</strong>有个很好的图示说明：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_element.png" alt="figure_element.png"></p><p><strong>了解图形组件的意义</strong>：</p><blockquote><p>Once you understand what these are and how to access them through the object oriented API, the rest of the process starts to fall into place.</p></blockquote><blockquote><p>The other benefit of this knowledge is that you <strong>have a starting point when you see things on the web</strong>. If you take the time to understand this point, <strong>the rest of the matplotlib API will start to make sense</strong>. Also, many of the advanced python packages like seaborn and ggplot rely on matplotlib so understanding the basics will <strong>make those more powerful frameworks much easier to learn</strong>.</p></blockquote><h3 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h3><p><code>Figure</code>涵盖了<strong>整个图片的内容</strong>，包括所有的<code>Axes</code>、a smattering of ‘special’ artists (<code>titles</code>, <code>figure legends</code>, etc)以及<code>canvas</code>(很重要的一个组成成分，是实际绘图和获取图像的部分，但是<strong>对于user来说是不可见的</strong>，具体可以看后面<a href="#artist">Artist部分</a>)。</p><p><code>Figure</code>可以包含任意数目的<code>Axes</code>，但要有用，最少要包含一个，也就是说常规的(<code>object-oriented interface</code>)，<strong>一个<code>Figure</code>可以包括一个或多个<code>Axes</code></strong>。</p><p>创建<code>Figure</code>最简单的方法是使用<code>pyplot</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># an empty figure with no axes</span></span><br><span class="line"><span class="comment"># 适用于state-based(Pyplot) interface</span></span><br><span class="line">fig = plt.figure()  </span><br><span class="line"><span class="comment"># a figure with a 2x2 grid of Axes</span></span><br><span class="line">fig, ax_lst = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a>Axes</h3><p><code>Axes</code>就是<strong>所谓的(子)图的概念</strong>，它是具有数据空间的图像区域。<strong>一个给定的<code>Figure</code>可以包含多个<code>Axes</code>，但是一个给定的<code>Axes</code>只能是某一个<code>Figure</code>的一部分</strong>。</p><p>一个<code>Axes</code>包括两个或三个<code>Axis</code>对象(注意区分<code>Axes</code>和<code>Axis</code>，前者是图，后者是图片的<code>X/Y</code>轴)；每个<code>Axes</code>包括一个<code>title</code>、<code>x-label</code>、<code>y-label</code>。</p><p><strong>打个比方：<code>Figure</code>类似于一整A4纸(画布)，然后我们将这个A4纸对折得到两个隔区，这每个隔区可以用来写字(画图)，这里的每个隔区就类似于<code>Axes</code></strong>。</p><hr><h3 id="Axis"><a href="#Axis" class="headerlink" title="Axis"></a>Axis</h3><p><code>Axis</code>是<code>number-line-like objects</code>，主要是用来设置图形的<code>(x、y)limits</code>以及产生<code>ticks</code>(凸起的小刻度线)和<code>ticklabels</code>(小刻度线对应的数值)。<code>ticks</code>的位置是由<a href="https://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Locator" target="_blank" rel="noopener">Locator</a>对象决定的，<code>ticklabel</code>是由<a href="https://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Formatter" target="_blank" rel="noopener">Formatter</a>对象决定的，正确使用这两个对象可以很好地控制<code>ticks</code>以及<code>ticklabels</code>。</p><p><strong><code>Figure</code>、<code>Axes</code>以及<code>Axis</code>关系的图示</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Figure_Axes_Axis.png" alt="Figure_Axes_Axis.png"></p><hr><h3 id="Artist"><a href="#Artist" class="headerlink" title="Artist"></a>Artist</h3><p>在<strong>图中所有可以看见的部分基本上都是artist(甚至包括前面提到的<code>Figure</code>、<code>Axes</code>和<code>Axis</code>)</strong>，其包括：<code>Text</code>对象、<code>Line2D</code>对象、<code>collection</code>对象以及<code>Patch</code>对象等。在绘制图形时，所有的<code>artists</code>都会画在<code>canvas</code>(用户不可见)上。大部分的<code>artists</code>都绑定在<code>Axes</code>上，<strong>因此<code>artists</code>不能被共享或者进行移动</strong>。</p><p><strong>补充说明关于<code>Artist</code>、<code>Renderer</code>、<code>FigureCanvas</code>之间关系</strong>：</p><p><code>Matplotlib</code>绘图过程与人自身绘图过程的类比：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Artist_Renderer_FigureCanvas.png" alt="Artist_Renderer_FigureCanvas.png"></p><p>想想平时我们怎么画图，是不是分三步:</p><ul><li><strong>找画板</strong>——解决图画在哪的问题</li><li><strong>用调色板</strong>——解决用什么画的问题</li><li><strong>画画</strong>——解决谁来画、怎么画的问题</li></ul><p><code>Matplotlib</code> 模拟了类似过程，也分三步：</p><ul><li><code>FigureCanvas</code></li><li><code>Renderer</code></li><li><code>Artist</code></li></ul><p>上面是 <code>Matplotlib</code> 里的三层 <code>API</code>：</p><ul><li><code>FigureCanvas</code>——帮你确定画图的地方</li><li><code>Renderer</code>——帮你把想画的东西展示在屏幕上</li><li><code>Artist</code>——帮你用 <code>Renderer</code> 在 <code>Canvas</code> 上画图</li></ul><hr><h2 id="画图所需的数据类型"><a href="#画图所需的数据类型" class="headerlink" title="画图所需的数据类型"></a>画图所需的数据类型</h2><p><strong>所有的绘图函数都以<code>np.array</code>或者<code>np.ma.masked_array</code>作为输入</strong>，其他的<code>array-like</code>对象<strong>如<code>pandas</code>的数据对象以及<code>np.matrix</code>可能不会很好的<code>work</code></strong>，最好能将这些数据对象在绘图之前转为<code>np.array</code>对象。</p><p>当然<code>pandas</code>中的数据对象可以直接使用<code>pandas</code>内置的画图方法，也是基于<code>Matplotlib</code>的。</p><p><br></p><h2 id="Matplotlib、pyplot、pylab之间的关系"><a href="#Matplotlib、pyplot、pylab之间的关系" class="headerlink" title="Matplotlib、pyplot、pylab之间的关系"></a>Matplotlib、pyplot、pylab之间的关系</h2><p><code>Matplotlib</code>是整个<code>package</code>的名称，而<code>matplotlib.pyplot</code>是<code>Matplotlib</code>中的一个<code>module</code>，而<code>pylab</code>是在伴随着<code>matplotlib</code>一块安装的<code>module</code>。</p><p><code>Pyplot</code>为基础的<code>object-oriented interface</code>提供了<code>state-based interface</code>(前面提到了<code>object-oriented interface</code>中也会用到<code>state-based interface</code>中创建和保存图片的功能)。<code>state-based interface</code>会<strong>显式或者隐式地创建<code>Figure</code>和<code>Axes</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 隐式创建</span></span><br><span class="line"><span class="comment"># 第一次调用plt.plot会自动创建figure和axes</span></span><br><span class="line">plt.plot(x, x, label=<span class="string">'linear'</span>)</span><br><span class="line"><span class="comment"># 后续的plt.plot会使用当前的axes，直接添加一条线</span></span><br><span class="line">plt.plot(x, x**<span class="number">2</span>, label=<span class="string">'quadratic'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">3</span>, label=<span class="string">'cubic'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置title、legend以及axis labels也会使用当前的axes</span></span><br><span class="line">plt.xlabel(<span class="string">'x label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y label'</span>)</span><br><span class="line">plt.title(<span class="string">"Simple Plot"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><p><code>pylab</code> is a convenience module that <strong><code>bulk imports</code> <code>matplotlib.pyplot</code> (for plotting) and <code>numpy</code> (for mathematics and working with arrays) in a single name space.</strong> Although many examples use pylab, <strong>it is no longer recommended</strong>.</p><p><mark>对于非交互式绘图，推荐使用pyplot来创建图片，然后使用object-oriented interface进行绘图</mark></p><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://matplotlib.org/faq/usage_faq.html" target="_blank" rel="noopener">Matplotlib Usage</a></li><li><a href="https://matplotlib.org/tutorials/introductory/lifecycle.html" target="_blank" rel="noopener">The Lifecycle of a Plot</a></li><li><a href="https://pbpython.com/effective-matplotlib.html" target="_blank" rel="noopener">Effectively Using Matplotlib</a></li><li><a href="https://www.jianshu.com/p/ebe721199d72" target="_blank" rel="noopener">Python 绘图，我只用 Matplotlib（一）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&amp;mid=2247487597&amp;idx=2&amp;sn=e2a61c9637900d7bcb3fb658a28758a3&amp;chksm=fb39b566cc4e3c70fc6d06c5be5b962dee3e68ce66e51b03533db5cd9fd60cd0c51a64fb3d3f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1571474906951&amp;sharer_shareid=1b54e58f922202bb93a6ffe28bb2f3a7&amp;key=7fbd4d18e8fd1c6fff6d9c4f75a5f7a7aa84450f1bafdbddcb15955ec1c1602ad5b32e505be4f4262cb7c3a654ae46ad1f778ab74bfca91c73afbcc665063b69ce1f6fe3338b9a0ae66edf55bbfdbebc&amp;ascene=1&amp;uin=MjU2NzcxOTIxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060841&amp;lang=zh_CN&amp;pass_ticket=GwsbQV788IMD6AiagF%2BPxa50XmG0oazH9xqtxGhmt5vIPH0QkD3SChoH46%2Fsdj%2FX" target="_blank" rel="noopener">干货：一文掌握Matplotlib的使用方法</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是&lt;strong&gt;系统&lt;/strong&gt;学习&lt;code&gt;Matplotlib&lt;/code&gt;包的开始，主要包括&lt;strong&gt;对&lt;code&gt;Matplotlib&lt;/code&gt;的介绍&lt;/strong&gt;、&lt;strong&gt;其他常用的绘图包&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;Matplotlib&lt;/code&gt;中的两种绘图接口&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;Matplotlib&lt;/code&gt;所接受的输入数据类型&lt;/strong&gt;以及&lt;strong&gt;&lt;code&gt;Matplotlib&lt;/code&gt;中一些常用术语和模块关系&lt;/strong&gt;，为以后的深入学习打下基础。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib中文显示</title>
    <link href="http://showteeth.tech/posts/60218.html"/>
    <id>http://showteeth.tech/posts/60218.html</id>
    <published>2019-10-12T13:13:51.000Z</published>
    <updated>2019-10-12T14:47:31.982Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux</code>下如何让<code>matplotlib</code>可以<strong>正确地显示中文</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习使用<code>matplotlib</code>画图过程中<strong>遇到了中文显示的问题</strong>，在<code>google</code>上搜索了很多结果，按照这些结果都不能正确显示(<strong>大部分的博客都是互相抄的，没有经过自己的实验验证，这也坚定了我自己写blog的决心</strong>)，所以这里自己记录一下。</p><hr><h2 id="查找matplotlib字体文件夹"><a href="#查找matplotlib字体文件夹" class="headerlink" title="查找matplotlib字体文件夹"></a>查找matplotlib字体文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找matplotlib配置文件的位置</span></span><br><span class="line">import matplotlib</span><br><span class="line">matplotlib.matplotlib_fname()</span><br><span class="line">  /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体文件夹和这个文件在同一目录</span></span><br><span class="line">ll /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data</span><br><span class="line">  drwxr-xr-x. 2 root root 4.0K Aug  8 22:27 stylelib</span><br><span class="line">  drwxr-xr-x. 2 root root 4.0K Aug  8 22:27 images</span><br><span class="line">  -rw-rw-r--. 2 root root  33K Jul 24 13:42 matplotlibrc</span><br><span class="line">  drwxr-xr-x. 5 root root   61 Apr 11  2019 fonts</span><br></pre></td></tr></table></figure><hr><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><p>这个具体的操作参考<a href="http://showteeth.tech/posts/358.html">Linux系列之添加中文字体</a></p><hr><h2 id="查找和更新matplotlib中文缓存"><a href="#查找和更新matplotlib中文缓存" class="headerlink" title="查找和更新matplotlib中文缓存"></a>查找和更新matplotlib中文缓存</h2><h3 id="查找字体缓存地址"><a href="#查找字体缓存地址" class="headerlink" title="查找字体缓存地址"></a>查找字体缓存地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字体缓存地址</span></span><br><span class="line"><span class="comment"># 最好是直接输出这个目录的绝对路径</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.get_cachedir()</span><br><span class="line">  <span class="comment"># /home/user/.cache/matplotlib</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除字体缓存"><a href="#删除字体缓存" class="headerlink" title="删除字体缓存"></a>删除字体缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到字体缓存地址后，可以将其中的缓存信息全部删除</span></span><br><span class="line">rm -rf /home/user/.cache/matplotlib/*</span><br></pre></td></tr></table></figure><hr><h3 id="直接更新字体缓存"><a href="#直接更新字体缓存" class="headerlink" title="直接更新字体缓存"></a>直接更新字体缓存</h3><p>除了上面的<strong>手动删除字体缓存</strong>之外，可以<strong>直接使用python语句更新字体缓存</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> _rebuild</span><br><span class="line">_rebuild()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用中文字体"><a href="#使用中文字体" class="headerlink" title="使用中文字体"></a>使用中文字体</h2><p><strong>上述更新完缓存之后，如果是<code>jupyter</code>，一定要重启一次，切记，不然不会生效</strong>。</p><h3 id="暂时使用中文字体"><a href="#暂时使用中文字体" class="headerlink" title="暂时使用中文字体"></a>暂时使用中文字体</h3><p><strong>在<code>Python</code>中指明使用的中文字体</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>]= <span class="string">'SimHei'</span> <span class="comment"># 指定字体，实际上相当于修改 matplotlibrc 文件　只不过这样做是暂时的　下次失效</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment"># 正确显示负号，防止变成方框</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用如下命令也行</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>] <span class="comment">#用来正常显示中文标签 </span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment">#用来正常显示负号</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y,label=<span class="string">"$sin(x)$"</span>,color=<span class="string">"red"</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">"t轴"</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y轴'</span>)</span><br><span class="line">plt.title(<span class="string">'中文'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="永久使用中文字体"><a href="#永久使用中文字体" class="headerlink" title="永久使用中文字体"></a>永久使用中文字体</h3><p>如果想要一次修改永久使用，可以直接修改<code>matplotlibrc</code>文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件地址在第一步就已经得到了</span></span><br><span class="line">vim /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改如下内容：</span></span><br><span class="line"><span class="comment">## SimHei必须写在font.sans-serif的第一位，不然不会生效</span></span><br><span class="line">font.family         : sans-serif        </span><br><span class="line">font.sans-serif     : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif <span class="comment"># 在其中添加中文字体名</span></span><br><span class="line">axes.unicode_minus  :False，<span class="comment">#作用就是解决负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zsxh.github.io/blog/2018/05/28/matplotlib%20%E5%9C%A8%20Linux%20Deepin%20%E4%B8%8B%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/" target="_blank" rel="noopener">matplotlib 在 Linux Deepin 下中文显示</a></li><li><a href="https://zodiac911.github.io/blog/matplotlib-chinese.html" target="_blank" rel="noopener">让Matplotlib正确显示中文</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Linux&lt;/code&gt;下如何让&lt;code&gt;matplotlib&lt;/code&gt;可以&lt;strong&gt;正确地显示中文&lt;/strong&gt;的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之添加中文字体</title>
    <link href="http://showteeth.tech/posts/358.html"/>
    <id>http://showteeth.tech/posts/358.html</id>
    <published>2019-10-12T12:45:02.000Z</published>
    <updated>2019-10-12T14:47:11.732Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux(centos)</code>下<strong>安装(中文)字体</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>Python</code>画图的时候发现中文乱码，想要进行中文的显示就需要系统有中文字体，但是<code>centos</code>默认是没有中文字体的，所以就需要下载，这里记录一下下载安装过程。</p><hr><h2 id="查看已安装字体"><a href="#查看已安装字体" class="headerlink" title="查看已安装字体"></a>查看已安装字体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装字体配置相关库</span></span><br><span class="line">yum install -y fontconfig mkfontscale</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装的字体</span></span><br><span class="line"><span class="built_in">fc</span>-list</span><br><span class="line">  /usr/share/fonts/default/Type1/c059016l.pfb: Century Schoolbook L:style=Bold</span><br><span class="line">  /usr/share/fonts/default/Type1/c059033l.pfb: Century Schoolbook L:style=Italic</span><br><span class="line">  /usr/share/fonts/default/Type1/p052024l.pfb: URW Palladio L:style=Bold Italic</span><br><span class="line">  /usr/share/fonts/default/Type1/d050000l.pfb: Dingbats:style=Regular</span><br><span class="line">  /usr/share/fonts/default/Type1/s050000l.pfb: Standard Symbols L:style=Regular</span><br><span class="line">  /usr/share/fonts/liberation/LiberationMono-Bold.ttf: Liberation Mono:style=Bold</span><br><span class="line">  /usr/share/fonts/default/Type1/n021003l.pfb: Nimbus Roman No9 L:style=Regular</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装了的中文字体</span></span><br><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line">  <span class="comment"># 没有结果输出，说明没有安装到中文字体</span></span><br></pre></td></tr></table></figure><hr><h2 id="部分中文字体的英文名"><a href="#部分中文字体的英文名" class="headerlink" title="部分中文字体的英文名"></a>部分中文字体的英文名</h2><table><tr><th width="25%">中文字体</th><th width="25%">英文名</th><th width="25%">中文字体</th><th width="25%">英文名</th></tr><tr><td>宋体</td><td>SimSun</td><td>华文细黑</td><td>STXihei</td></tr><tr><td>黑体</td><td>SimHei</td><td>华文楷体</td><td>STKaiti</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>华文宋体</td><td>STSong</td></tr><tr><td>微软正黑体</td><td>Microsoft JhengHei</td><td>华文中宋</td><td>STZhongsong</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>华文仿宋</td><td>STFangsong</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>方正舒体</td><td>FZShuTi</td></tr><tr><td>细明体</td><td>MingLiU</td><td>方正姚体</td><td>FZYaoti</td></tr><tr><td>标楷体</td><td>DFKai-SB</td><td>华文彩云</td><td>STCaiyun</td></tr><tr><td>仿宋</td><td>FangSong</td><td>华文琥珀</td><td>STHupo</td></tr><tr><td>楷体</td><td>KaiTi</td><td>华文隶书</td><td>STLiti</td></tr><tr><td>隶书</td><td>LiSu</td><td>华文行楷</td><td>STXingkai</td></tr><tr><td>幼圆</td><td>YouYuan</td><td>华文新魏</td><td>STXinwei</td></tr></table><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><ul><li><strong>创建字体目录</strong>：在<code>linux</code>下的<code>/usr/share/fonts</code>目录中创建目录：<code>mkdir chinese</code></li><li><strong>复制字体</strong>：在<code>windows</code>下的<code>C:\Windows\Fonts</code>目录中选择自己想要的字体移动到刚刚在<code>linux</code>上创建的<code>chinese</code>目录</li><li><strong>下载字体</strong>：从<a href="https://github.com/tracyone/program_font" target="_blank" rel="noopener">github</a>上下载字体</li><li><strong>安装字体</strong>：建立字体索引信息，更新字体缓存。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里一共有三个字体：宋体、微软雅黑、中易黑体</span></span><br><span class="line">-rw-r--r--. 1 root root 9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">-rw-r--r--. 1 root root 18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">-rw-r--r--. 1 root root 19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改目录权限，可选操作</span></span><br><span class="line">chmod -R 755 /usr/share/fonts/chinese</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立字体索引信息，更新字体缓存</span></span><br><span class="line">mkfontscale</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line">mkfontdir</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.dir</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line"><span class="built_in">fc</span>-cache</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.dir</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br></pre></td></tr></table></figure><hr><h2 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line">  <span class="comment"># 相比于第一次运行没有结果输出，这里出现了字体添加的中文字体</span></span><br><span class="line">  /usr/share/fonts/chinese/MSYH.TTC: Microsoft YaHei:style=Normal</span><br><span class="line">  /usr/share/fonts/chinese/SIMSUN.TTC: SimSun,宋体:style=Regular,常规</span><br><span class="line">  /usr/share/fonts/chinese/MSYH.TTC: Microsoft YaHei UI:style=Normal</span><br><span class="line">  /usr/share/fonts/chinese/SIMSUN.TTC: NSimSun,新宋体:style=Regular,常规</span><br><span class="line">  /usr/share/fonts/chinese/simhei.ttf: SimHei:style=Regular,Normal</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ilanni.com/?p=11746" target="_blank" rel="noopener">linux安装中文字体</a></li><li><a href="https://www.cnblogs.com/cuishuai/p/8441132.html" target="_blank" rel="noopener">Centos7 安装字体库&amp;中文字体</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Linux(centos)&lt;/code&gt;下&lt;strong&gt;安装(中文)字体&lt;/strong&gt;的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Linux安装scipy</title>
    <link href="http://showteeth.tech/posts/34795.html"/>
    <id>http://showteeth.tech/posts/34795.html</id>
    <published>2019-10-08T13:10:53.000Z</published>
    <updated>2019-10-10T15:57:55.978Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Python2.7</code>环境下安装<code>scipy</code>过程中遇到的一些问题以及爬坑过程(解决方案).</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近实验室的师姐在分析数据的时候需要用到一个软件，该软件依赖于<code>Python2.7</code>以及<code>scipy</code>、<code>numpy</code>包的，但师姐在安装scipy中遇到了一些问题，我在解决的时候也发现了<strong>很多陷阱</strong>，这里记录一下。</p><hr><h2 id="安装之路"><a href="#安装之路" class="headerlink" title="安装之路"></a>安装之路</h2><h3 id="直接pip安装默认scipy"><a href="#直接pip安装默认scipy" class="headerlink" title="直接pip安装默认scipy"></a>直接pip安装默认scipy</h3><p>安装<code>python</code>包最简单粗暴的方法就是直接上<code>pip</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pip之前先更新一波</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接pip安装scipy</span></span><br><span class="line">pip install scipy</span><br></pre></td></tr></table></figure><p></p><p><strong>直接报错，报错信息如下</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Python version &gt;= 3.5 required.</span><br></pre></td></tr></table></figure><p></p><p>上述报错提示需要<code>Python</code>版本<code>&gt;=3.5</code>才可以安装，但是我用的是<code>python2</code>的<code>pip</code>啊，为什么不能直接安装<code>python2</code>对应的<code>scipy</code>版本呢？</p><p><strong>原因猜测</strong>：在<a href="https://github.com/scipy/scipy/releases" target="_blank" rel="noopener">scipy的github</a>上可以发现现在的<strong>scipy会有两个不同的更新</strong>，一个是<code>1.3.x</code>的还有一个就是<code>1.2.x</code>的更新，仔细看两种版本的更新可以发现：<code>1.3.x</code>支持的是<code>Python 3.5+</code>的版本，没有提供<code>Python 2.x</code>版本的安装信息；而与之对应的<code>1.2.x</code>版本的就有提供<code>Python 2.x</code>版本的安装文件。基于上述判断，<strong>直接使用<code>pip</code>安装可能会默认安装<code>scipy 1.3.x</code>，也就是<code>Python 3.5+</code>的版本，所以可以尝试使用<code>pip</code>安装指定的版本。</strong></p><hr><h3 id="使用whl文件安装指定版本scipy"><a href="#使用whl文件安装指定版本scipy" class="headerlink" title="使用whl文件安装指定版本scipy"></a>使用whl文件安装指定版本scipy</h3><p>从<a href="https://github.com/scipy/scipy/releases" target="_blank" rel="noopener">github上scipy的release处</a>下载<code>1.2.2</code>版本的<code>scipy</code>的<code>whl</code>文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中的cp27就是python2.7的意思</span></span><br><span class="line">wget https://github.com/scipy/scipy/releases/download/v1.2.2/scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完成之后使用pip安装</span></span><br><span class="line">pip install scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl</span><br></pre></td></tr></table></figure><p></p><p><strong>再次出现报错</strong>，报错信息如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 报错信息</span></span><br><span class="line">scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br><span class="line">Storing debug <span class="built_in">log</span> <span class="keyword">for</span> failure <span class="keyword">in</span> /root/.pip/pip.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># log文件内容：</span></span><br><span class="line">cat /root/.pip/pip.log</span><br><span class="line">  ------------------------------------------------------------</span><br><span class="line">  /usr/bin/pip run on Tue Oct  8 09:03:00 2019</span><br><span class="line">  scipy-1.2.2-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br><span class="line">  Exception information:</span><br><span class="line">  Traceback (most recent call last):<span class="comment">#   File "/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/basecommand.py", line 122, in main</span></span><br><span class="line">      status = self.run(options, args)</span><br><span class="line">    File <span class="string">"/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/commands/install.py"</span>, line 257, <span class="keyword">in</span> run</span><br><span class="line">      InstallRequirement.from_line(name, None))</span><br><span class="line">    File <span class="string">"/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/req.py"</span>, line 167, <span class="keyword">in</span> from_line</span><br><span class="line">      raise UnsupportedWheel(<span class="string">"%s is not a supported wheel on this platform."</span> % wheel.filename)</span><br><span class="line">  UnsupportedWheel: scipy-1.2.2-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br></pre></td></tr></table></figure><p></p><p>报错信息提示说该whl文件不是一个目前系统支持的文件，然后我查看了该系统支持的文件信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统可以支持的版本</span></span><br><span class="line">&gt;&gt;&gt; import pip; <span class="built_in">print</span>(pip.pep425tags.get_supported())</span><br><span class="line">[(<span class="string">'cp27'</span>, <span class="string">'none'</span>, <span class="string">'linux_x86_64'</span>), (<span class="string">'cp27'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp2'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp26'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp25'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp24'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp23'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp22'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp21'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp20'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py27'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py2'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py26'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py25'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py24'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py23'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py22'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py21'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py20'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>)]</span><br></pre></td></tr></table></figure><p></p><p>通过前面命令发现下载的文件确实<strong>不是系统支持的</strong>，但是在<code>scipy</code>官网上也<strong>没找到完全符合上面信息的文件</strong>，但是<a href="https://stackoverflow.com/questions/28568070/filename-whl-is-not-supported-wheel-on-this-platform" target="_blank" rel="noopener">从这里</a>发现可以<strong>直接修改文件名称</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改名</span></span><br><span class="line">mv scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl scipy-1.2.2-cp27-none-linux_x86_64.whl</span><br><span class="line">pip install scipy-1.2.2-cp27-none-linux_x86_64.whl</span><br><span class="line"><span class="comment"># 还是报错：RuntimeError: Python version &gt;= 3.5 required.</span></span><br></pre></td></tr></table></figure><p></p><p>因为<strong>改名字在我看来确实不是一个很科学的做法</strong>，加上<strong>后续又报错了</strong>，所以就<strong>放弃了这个做法</strong>，转而使用下一个方法安装指定版本的scipy。</p><div class="note info"><p>关于<code>whl</code>文件：</p><ul><li>A Distribution format <strong>containing files and metadata that only need to be moved to the correct location on the target system, to be installed</strong>. Wheel is such a format, whereas distutil’s Source Distribution is not, in that it requires a build step before it can be installed. <strong>This format does not imply that Python files have to be precompiled (Wheel intentionally does not include compiled Python files)</strong>. <a href="https://packaging.python.org/glossary/#term-built-distribution" target="_blank" rel="noopener">参考链接</a></li><li><a href="https://fileinfo.com/extension/whl" target="_blank" rel="noopener">There are three types of WHL files</a>:<ul><li><code>Universal Wheel</code> - It <strong>only contains Python files</strong>, <strong>no compiled extensions</strong>, and <strong>natively supports Python 2 and 3</strong>.</li><li><code>Pure Python Wheel</code> - It <strong>only contains Python files and no compiled extensions</strong>, but does <strong>not natively support Python 2 and 3</strong>.</li><li><code>Platform Wheel</code> - It <strong>contains Python files and compiled extensions</strong> but does <strong>not natively support Python 2 and 3</strong>. This type of wheel is <strong>specific to a platform</strong>, such as Windows or macOS, because it contains compiled extensions.</li></ul></li></ul></div><hr><h3 id="使用pip安装指定版本的scipy"><a href="#使用pip安装指定版本的scipy" class="headerlink" title="使用pip安装指定版本的scipy"></a>使用pip安装指定版本的scipy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接安装指定版本的scipy</span></span><br><span class="line">pip install scipy==1.2.2</span><br><span class="line"><span class="comment"># 出现如下报错信息</span></span><br><span class="line">  Collecting numpy&gt;=1.8.2 (from scipy==1.2.2)</span><br><span class="line">  ERROR: multicoretsne 0.1 requires cffi, <span class="built_in">which</span> is not installed.</span><br><span class="line">  Installing collected packages: numpy, scipy</span><br><span class="line">    Found existing installation: numpy 1.7.1</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p>上述报错有两个方面，一是缺少<code>cffi</code>包，二是发现已经安装了<code>numpy</code>，并且版本是<code>1.7.1</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装cffi</span></span><br><span class="line">pip install cffi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行</span></span><br><span class="line">pip install scipy==1.2.2</span><br><span class="line"><span class="comment"># cffi的报错解决，numpy的问题依旧存在</span></span><br><span class="line">  Collecting numpy&gt;=1.8.2 (from scipy==1.2.2)</span><br><span class="line">  Installing collected packages: numpy, scipy</span><br><span class="line">    Found existing installation: numpy 1.7.1</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p></p><p>查看<code>numpy</code>版本以及更新或者卸载<code>numpy</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看numpy版本</span></span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt; numpy.__version__</span><br><span class="line"><span class="string">'1.7.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载numpy</span></span><br><span class="line">pip uninstall numpy</span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级numpy</span></span><br><span class="line">pip install --upgrade numpy</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p></p><p>上面尝试升级或者删除<code>numpy</code>包均报错，提示numpy是<code>distutils installed project</code>，所以不能进行卸载。</p><p>随后在<a href="https://stackoverflow.com/questions/50421287/pip-cannot-uninstall-ipython-it-is-a-distutils-installed-project-and-thus-w" target="_blank" rel="noopener">这篇文章</a>中发现，可以添加参数来忽略已经安装的numpy，从而进行下一版本的安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略已安装的版本</span></span><br><span class="line">pip install --ignore-installed -U numpy</span><br><span class="line"><span class="comment"># 可以安装numpy和scipy，但是在python中导入numpy模块的时候报错</span></span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/numpy/__init__.py"</span>, line 142, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from . import core</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/numpy/core/__init__.py"</span>, line 91, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raise ImportError(msg.format(path))</span><br><span class="line">ImportError: Something is wrong with the numpy installation. While importing we detected an older version of numpy <span class="keyword">in</span> [<span class="string">'/usr/lib64/python2.7/site-packages/numpy'</span>]. One method of fixing this is to repeatedly uninstall numpy until none is found, <span class="keyword">then</span> reinstall this version.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line"><span class="comment">## 进入安装目录：/usr/lib64/python2.7/site-packages</span></span><br><span class="line"><span class="comment">## 再次尝试导入numpy即可</span></span><br><span class="line">rm numpy-1.7.1-py2.7.egg-info</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>问题虽然解决了，但是仍然<strong>有一些疑惑需要解答</strong>：什么是<code>distutils installed project</code>，为什么不能通过<strong>pip升级和卸载</strong>？</p><blockquote><p>This error means that <strong>this package’s metadata doesn’t include a list of files that belong to it</strong>. Most probably, you have installed this package <code>via your OS&#39; package manager(比如apt、yum)</code>, so you need to use that <code>rather than pip to update or remove it, too</code>. <a href="https://stackoverflow.com/questions/53807511/pip-cannot-uninstall-package-it-is-a-distutils-installed-project" target="_blank" rel="noopener">参考链接</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Python2.7&lt;/code&gt;环境下安装&lt;code&gt;scipy&lt;/code&gt;过程中遇到的一些问题以及爬坑过程(解决方案).&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="tricks" scheme="http://showteeth.tech/categories/Python/tricks/"/>
    
    
      <category term="tricks" scheme="http://showteeth.tech/tags/tricks/"/>
    
  </entry>
  
</feed>
