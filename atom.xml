<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-03-05T09:15:29.018Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Travis CI自动部署github项目</title>
    <link href="http://showteeth.tech/posts/62916.html"/>
    <id>http://showteeth.tech/posts/62916.html</id>
    <published>2019-03-05T01:26:30.000Z</published>
    <updated>2019-03-05T09:15:29.018Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://segmentfault.com/a/1190000011218410?utm_source=tag-newest" target="_blank" rel="noopener">Travis CI 自动化部署博客</a></li><li><a href="https://www.cnblogs.com/zqzjs/p/6119750.html" target="_blank" rel="noopener">Travis CI用来持续集成你的项目</a></li><li><a href="https://www.cnblogs.com/morang/p/7228488.html" target="_blank" rel="noopener">使用travis-ci自动部署github上的项目</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="博客" scheme="http://showteeth.tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>管理多个SSH公钥</title>
    <link href="http://showteeth.tech/posts/51573.html"/>
    <id>http://showteeth.tech/posts/51573.html</id>
    <published>2019-03-05T01:21:56.000Z</published>
    <updated>2019-03-05T09:14:08.094Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法</p></div><a id="more"></a><h2 id="SSH-key介绍"><a href="#SSH-key介绍" class="headerlink" title="SSH key介绍"></a>SSH key介绍</h2><p>SSH key提供了一种与GitHub或其他平台通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub或其他平台作为自己的remote端服务器，进行版本控制。</p><p>需要注意的是<strong>不同平台的SSH key各不相同</strong>，所以为了能在各个平台上方便地使用git进行版本控制，就需要设置多个SSH key。</p><p><strong>使用SSH key的步骤</strong>：</p><ul><li>在客户端生成SSH key（密钥对：公钥-&gt;锁头和私钥-&gt;钥匙，利用了公钥和私钥实现数据加密和解密）</li><li>在服务端的配置文件中加入你的公钥。（比如我们需要再GitHub中粘贴你的公钥）</li></ul><p><strong>具体原理</strong>：用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回远程主机，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。</p><hr><p><br></p><h2 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h2><p>默认情况下，使用<code>ssh-keygen</code>生成会在<code>C:\Users\user\.ssh</code>目录下生成SSH key(<code>id_rsa</code>和<code>id_rsa.pub(公钥)</code>)，为了使生成了SSH key互不干扰，所以需要使用<code>-f</code>参数进行设置生成了SSH key名称，不然可能会覆盖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/keyname(eg:github)</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/coding_pages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-t：指定要创建的密钥类型，默认是 rsa ，可以省略</span><br><span class="line">-C：添加注释，比如邮箱；</span><br><span class="line">-f：指定用来保存密钥的文件名；</span><br><span class="line">-b：指定密钥长度；</span><br><span class="line">-e：读取openssh的私钥或者公钥文件；</span><br><span class="line">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；</span><br><span class="line">-l：显示公钥文件的指纹数据；</span><br><span class="line">-N：提供一个新密语；</span><br><span class="line">-P：提供（旧）密语；</span><br><span class="line">-q：静默模式；</span><br></pre></td></tr></table></figure><p>上述命令输入后，会出现如下提示：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line"><span class="comment"># Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p></p><ul><li>可以不输入文件名，使用默认文件名（推荐），那么就会生成 github 和 github.pub 两个秘钥文件；</li><li>接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）；</li><li>也可以不输入密码，直接按回车，那么push的时候就不需要输入密码，直接提交到github上了；</li><li>将 github.pub 文件的内容添加到github上面的ssh key</li></ul><p>以上是生成一个的过程，生成另一个的过程也是相同的操作。</p><hr><p><br></p><h2 id="添加生成的SSH"><a href="#添加生成的SSH" class="headerlink" title="添加生成的SSH"></a>添加生成的SSH</h2><p>将上述得到的公钥(以pub结尾的文件内容复制到平台相应的ssh key添加部位)：</p><div><br><img title="github_key" alt="github_key" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/github_key.png?imageView2/2/w/600"><br></div><div><br><img title="coding_pages_key" alt="coding_pages_key.png" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/coding_pages_key.png?imageView2/2/w/600"><br></div><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在 <code>C:\Users\user\.ssh</code> 目录下新建一个config文件，并添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host 公司github的地址 如：github.com</span><br><span class="line">HostName 公司github的地址 如：github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host git.dev.tencent.com</span><br><span class="line">    HostName git.dev.tencent.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/coding_pages</span><br></pre></td></tr></table></figure><p>上述host地址的得到可以通过点击平台任意一个项目的<code>clone and download</code>看到，冒号<code>:</code>前面的就是host地址了</p><hr><p><br></p><h2 id="验证SSH-key是否添加成功"><a href="#验证SSH-key是否添加成功" class="headerlink" title="验证SSH key是否添加成功"></a>验证SSH key是否添加成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding pages</span></span><br><span class="line">ssh -T git@git.dev.tencent.com</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Hi showteeth! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><blockquote><p>Coding 提示: Hello showteeth, You’ve connected to Coding.net via SSH. This is a personal key.<br>showteeth，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</p></blockquote><p>到这里留完成了管理多个SSH公钥的步骤，接下来就可以不用输入密码地将代码托管到相应的平台上了!</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/3e57bb0f8185" target="_blank" rel="noopener">如何同时使用多个SSH公钥提交代码至不同平台</a></li><li><a href="https://blog.csdn.net/DBB_zifeng/article/details/71698865" target="_blank" rel="noopener">管理多个SSH公钥密钥</a></li><li><a href="https://www.jianshu.com/p/a869072a0092" target="_blank" rel="noopener">同一台电脑关于多个SSH KEY管理</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>PDF转HTML-pdf2htmlex</title>
    <link href="http://showteeth.tech/posts/40996.html"/>
    <id>http://showteeth.tech/posts/40996.html</id>
    <published>2019-03-04T03:41:11.000Z</published>
    <updated>2019-03-04T06:43:30.913Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。</p></div><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><p>由于电脑是windows系统，所以只能按照<a href="https://gist.github.com/cnstar9988/3571c66b49050d98df92142dc19fbb00" target="_blank" rel="noopener">这里</a>给定的教程进行安装，无奈尝试了很多次，最终都以失败告终，都有点想放弃使用这个工具了，但是后来尝试了其他工具如<a href="https://github.com/mgufrone/pdf-to-html" target="_blank" rel="noopener">pdf-to-html</a>，但是效果很差，出来的效果和原本的pdf差很多，所以还是放弃了。</p><p>最近忽然发现应该可以使用docker进行安装，所以尝试使用<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>，接下来就是安装和使用docker：</p><ul><li>注册docker账号然后下载</li><li>安装docker，这里注意如果电脑上安装了360会提示<strong>发现黑客新建用户帐号，建议阻止</strong>，鉴于360的一贯行为以及阻止后不能顺利安装，我选择了允许操作</li><li>安装完成之后会<strong>注销和重启电脑</strong>，这个按照提示操作即可</li><li>最后需要注意的是<strong>运行docker是在命令行形式下运行</strong>，而不是直接打开桌面的快捷方式</li></ul><hr><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>使用docker安装pdf2htmlex，可以参考<a href="https://github.com/BWITS/pdf2htmlEX_docker" target="_blank" rel="noopener">官方给出的教程</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><p>输入上述命令后<strong>发现错误</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> connection (Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span><br></pre></td></tr></table></figure><p></p><p>上网搜了一下，发现这个错误是因为网络原因导致无法拉取镜像，解决方法：<strong>使用国内的Docker仓库daocloud</strong>：</p><ul><li>进入<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daocloud关于docker加速器的网站</a>，找到<strong>配置 Docker 加速器</strong>下对应的操作系统，因为我使用的windows系统，所以选择windows系统下的<code>http://f1361db2.m.daocloud.io</code></li></ul><img title="docker配置镜像" alt="docker配置镜像" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/docker配置镜像2.png?imageView2/2/w/500"><ul><li>将上述所得到的的地址写入<code>docker-&gt;setting-&gt;daemon-&gt;registry mirrors</code>中，然后<strong>apply</strong>，docker会提示<strong>restart</strong>：</li></ul><img title="配置docker加速器" alt="配置docker加速器" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/docker配置镜像.png?imageView2/2/w/500"><ul><li>上述操作完成之后重新执行命令，发现下载速度飞快~~~</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="通过docker命令"><a href="#通过docker命令" class="headerlink" title="通过docker命令"></a>通过docker命令</h3><p>详细的使用参考<a href="https://github.com/coolwanglu/pdf2htmlEX/wiki/Quick-Start" target="_blank" rel="noopener">工具的github</a>，这里我只尝试较为简单的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX --zoom 1.8  resume.pdf</span><br></pre></td></tr></table></figure><p></p><p>用到的docker参数说明：</p><ul><li><code>-v</code>：挂载宿主机目录，~/pdf对应于C:\Users\user\pdf，/pdf的容器的目录，在容器启动后，容器内会自动创建/pdf目录，也就是冒号<code>:</code>前面的目录是宿主机目录，后面的目录是容器内目录。<strong>注意使用时docker会提示需要使用文件权限</strong>，如果宿主机目录放在C盘，还要输入电脑密码</li><li><code>--rm</code>：默认情况下，每个container在退出时，它的文件系统也会保存下来，该参数可以让docker在container结束时自动清理其所产生的数据</li><li><code>-ti</code>：以交互模式启动一个容器</li></ul><hr><h3 id="创建命令调用别名"><a href="#创建命令调用别名" class="headerlink" title="创建命令调用别名"></a>创建命令调用别名</h3><p>因为使用的docker安装，每次调用可能全长命令比较麻烦，所以这里使用alias创建命令别名-pdf2htmlEX：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己修改挂载目录</span></span><br><span class="line"><span class="built_in">alias</span> pdf2htmlEX=<span class="string">"docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX"</span></span><br></pre></td></tr></table></figure><p>这里一直没有成功不知道是为什么，总是显示<code>文件名、目录名或卷标语法不正确。</code>，但我直接使用命令不使用alias的方式却能正常使用，所以就没有继续使用这个</p><blockquote><p>系统自带的cmd是不支持alias的，我这里使用的是<a href="https://cmder.net/" target="_blank" rel="noopener">cmder</a>，很强大的命令行工具，关于如何在windows下配置这个工具，可以参考博客中关于配置cmder的文章</p></blockquote><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="pdf2htmlex" scheme="http://showteeth.tech/tags/pdf2htmlex/"/>
    
  </entry>
  
  <entry>
    <title>coding_pages和mkdocs使用</title>
    <link href="http://showteeth.tech/posts/54578.html"/>
    <id>http://showteeth.tech/posts/54578.html</id>
    <published>2019-03-03T08:31:43.000Z</published>
    <updated>2019-03-04T16:05:36.915Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>coding pages和mkdocs使用简介</p></div><a id="more"></a><h2 id="注册coding-pages"><a href="#注册coding-pages" class="headerlink" title="注册coding pages"></a>注册coding pages</h2><ul><li>前往其<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>，常规的注册方法即可</li><li>关于会员：<ul><li><a href="https://feedback.coding.net/topics/7257" target="_blank" rel="noopener">免费升级</a>好像</li><li>升级之前不可以创建项目，如果有项目需要转让或者删除，具体操作步骤<a href="https://dev.tencent.com/help/doc/account/up-to-tencent#CODING-3" target="_blank" rel="noopener">参考文章</a></li></ul></li></ul><hr><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>填写项目标识，项目标识在最后创建完pages之后就会显示为username.coding.me/项目标识/</li><li>项目名称填写：username.coding.me，相当于 github 上面的 name.github.io</li><li>创建完成即进入项目，选择代码下的代码浏览，创建<code>index.html</code>页面(注意名字一定要叫 <code>index.html</code>)，随意写一段话：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Coding Pages<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Coding!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>然后点击左侧<strong>代码</strong>下的 <strong>Pages 服务</strong>，选择<strong>静态 Pages 服务</strong>，一键创建pages</li><li>静态 Coding Pages 允许的部署分支来源为master 分支和coding-pages 分支，默认部署来源是master 分支，用户可在设置(右上角)里更改部署来源（实测发现只有master分支）。部署成功后后可通过<code>&lt;user_name&gt;.coding.me／&lt;project_name&gt;</code>形式的 URL 访问静态 Pages</li><li>如果需要自定义域名，这个也在pages服务中的设置(右上角)中进行设置</li></ul><hr><p><br></p><h2 id="结合mkdocs"><a href="#结合mkdocs" class="headerlink" title="结合mkdocs"></a>结合mkdocs</h2><h3 id="安装相关packages"><a href="#安装相关packages" class="headerlink" title="安装相关packages"></a>安装相关packages</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装mkdocs</span></span><br><span class="line">pip install mkdocs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure><hr><h3 id="常规用法："><a href="#常规用法：" class="headerlink" title="常规用法："></a>常规用法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">mkdocs new my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动内建服务器</span></span><br><span class="line">mkdocs serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点生成，创建了一个 site 新目录</span></span><br><span class="line">mkdocs build</span><br></pre></td></tr></table></figure><hr><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主题和头像</span></span><br><span class="line">theme:</span><br><span class="line">  name: material</span><br><span class="line">  favicon: <span class="string">'/dark_logo_16x16.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加页面</span></span><br><span class="line">nav:</span><br><span class="line">- 主页 : index.md</span><br><span class="line">- 软件 : about.md</span><br><span class="line">- 项目 : about.md</span><br><span class="line">- 关于 : about.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持中文搜索，虽然search功能(lunr.js)暂不直接支持中文，但测试发现设置为日语后，中文和英文搜索都可以使用</span></span><br><span class="line">extra:</span><br><span class="line">  search:</span><br><span class="line">    language: <span class="string">'jp'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加扩展</span></span><br><span class="line">markdown_extensions:</span><br><span class="line">  - admonition</span><br><span class="line">  - codehilite:</span><br><span class="line">      guess_lang: <span class="literal">false</span></span><br><span class="line">      linenums: <span class="literal">false</span></span><br><span class="line">  ......</span><br><span class="line"><span class="comment"># 自定义的CSS和JS</span></span><br><span class="line">extra_javascript:</span><br><span class="line">  - <span class="string">'js/extra.js'</span></span><br><span class="line">  - <span class="string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'</span></span><br><span class="line"></span><br><span class="line">extra_css:</span><br><span class="line">  - <span class="string">'css/extra.css'</span></span><br></pre></td></tr></table></figure><hr><h3 id="上传到coding-pages"><a href="#上传到coding-pages" class="headerlink" title="上传到coding pages"></a>上传到coding pages</h3><ul><li>将coding pages项目clone到本地：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里本想使用ssh的链接，但是失败，提示repo不存在，但是使用https的却可以成功，需要再看看问题</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.dev.tencent.com/showteeth/project.git bio_projects</span><br></pre></td></tr></table></figure><ul><li>将原本mkdoc目录下的文件拷进这个目录</li><li><p>部署到coding pages，详细参考<a href="https://www.mkdocs.org/user-guide/deploying-your-docs/" target="_blank" rel="noopener">官方教程</a></p><ul><li>自动将相应内容推送到项目的 master 分支上，默认会部署在 gh-pages 分支上，而我的账户好像只能部署在master分支上，所以只能修改分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdocs gh-deploy -b master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>输入链接即可访问</p></li></ul><p>readme.md文件的处理</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.mkdocs.org/" target="_blank" rel="noopener">mkdocs的官方网站</a></li><li><a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs的github</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">mkdocs主题material的相关材料（拓展、代码高亮）</a></li><li><a href="https://docs.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">readthedocs的官方网站（介绍的比较简答，具体实施还是需要看mkdocs的网站说明）</a></li><li><a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs托管文档</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/syntax/note_style/" target="_blank" rel="noopener">支持的markdown语法</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">基于mkdocs-material搭建个人静态博客(含支持的markdown语法)</a></li><li><a href="https://docs.flc.io/more/github-travis-mkdocs-document/" target="_blank" rel="noopener">使用mkdocs搭建的文档库</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;coding pages和mkdocs使用简介&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="coding pages" scheme="http://showteeth.tech/tags/coding-pages/"/>
    
  </entry>
  
  <entry>
    <title>jupyter主题、插件、技巧、server搭建</title>
    <link href="http://showteeth.tech/posts/13473.html"/>
    <id>http://showteeth.tech/posts/13473.html</id>
    <published>2019-03-02T14:16:26.000Z</published>
    <updated>2019-03-05T07:55:51.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>针对默认的jupyter notebook的页面进行修改、增加一些插件使jupyter的使用更加方便，整理一些jupyter使用技巧，最后是关于搭建jupyter server的内容</p></div><a id="more"></a><h2 id="jupyter默认页面的修改"><a href="#jupyter默认页面的修改" class="headerlink" title="jupyter默认页面的修改"></a>jupyter默认页面的修改</h2><p>jupyter默认页面的修改主要是使用<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyter-themes</a>包。</p><h3 id="jupyter-themes安装"><a href="#jupyter-themes安装" class="headerlink" title="jupyter-themes安装"></a>jupyter-themes安装</h3><p>常规的<code>pip</code>安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install jupyterthemes</span></span><br><span class="line">pip install jupyterthemes</span><br><span class="line"></span><br><span class="line"><span class="comment"># upgrade to latest version</span></span><br><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure><ul><li>为了达到最好的效果，建议notebook的版本是<code>&gt;=5.6.0</code>，如果低于此版本可以使用<code>pip install --upgrade notebook</code>进行升级</li><li>refreshing / removing / resetting：如果想要恢复默认值或者使新采用的主题生效，可能需要清除浏览器缓存（不一定非要进行，看自己的浏览器和系统，真遇到情况可以参考<a href="https://github.com/dunovank/jupyter-themes/issues/86" target="_blank" rel="noopener">issue</a>）；进行上述操作后刷新浏览器肯定是要刷新浏览器的！</li><li>安装或其他问题直接上<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">github</a>找答案！</li></ul><hr><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jt  [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">    [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">    [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim]</span><br><span class="line">    [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout]</span><br><span class="line">    [-P] [-T] [-N] [-r] [-dfonts]</span><br></pre></td></tr></table></figure><p>具体的参数说明：</p><table><thead><tr><th>cl options</th><th>arg</th><th>default</th></tr></thead><tbody><tr><td>Usage help</td><td>-h</td><td>–</td></tr><tr><td>List Themes</td><td>-l</td><td>–</td></tr><tr><td>Theme Name to Install</td><td>-t</td><td>–</td></tr><tr><td>Code Font</td><td>-f</td><td>–</td></tr><tr><td>Code Font-Size</td><td>-fs</td><td>11</td></tr><tr><td>Notebook Font</td><td>-nf</td><td>–</td></tr><tr><td>Notebook Font Size</td><td>-nfs</td><td>13</td></tr><tr><td>Text/MD Cell Font</td><td>-tf</td><td>–</td></tr><tr><td>Text/MD Cell Fontsize</td><td>-tfs</td><td>13</td></tr><tr><td>Pandas DF Fontsize</td><td>-dfs</td><td>9</td></tr><tr><td>Output Area Fontsize</td><td>-ofs</td><td>8.5</td></tr><tr><td>Mathjax Fontsize (%)</td><td>-mathfs</td><td>100</td></tr><tr><td>Intro Page Margins</td><td>-m</td><td>auto</td></tr><tr><td>Cell Width</td><td>-cellw</td><td>980</td></tr><tr><td>Line Height</td><td>-lineh</td><td>170</td></tr><tr><td>Cursor Width</td><td>-cursw</td><td>2</td></tr><tr><td>Cursor Color</td><td>-cursc</td><td>–</td></tr><tr><td>Alt Prompt Layout</td><td>-altp</td><td>–</td></tr><tr><td>Alt Markdown BG Color</td><td>-altmd</td><td>–</td></tr><tr><td>Alt Output BG Color</td><td>-altout</td><td>–</td></tr><tr><td>Style Vim NBExt*</td><td>-vim</td><td>–</td></tr><tr><td>Toolbar Visible</td><td>-T</td><td>–</td></tr><tr><td>Name &amp; Logo Visible</td><td>-N</td><td>–</td></tr><tr><td>Kernel Logo Visible</td><td>-kl</td><td>–</td></tr><tr><td>Reset Default Theme</td><td>-r</td><td>–</td></tr><tr><td>Force Default Fonts</td><td>-dfonts</td><td>–</td></tr></tbody></table><p>github上有具体的示例用法，建议大家去看看，我这里挑选我最喜欢的配置如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t monokai -f firacode -fs 12 -cellw 70% -ofs 10 -dfs 11 -T -N -altp -lineh 140</span><br></pre></td></tr></table></figure><p></p><ul><li>上述命令是在cmd中输入进行配置，而不是在jupyter notebook中</li><li>-fs：字体大小</li><li>-ofs：输出字体大小</li><li>-dfs：pandas dataframe字体大小</li><li>-cellw：主体宽度</li><li>-T：显示导航栏</li><li>-N：显示文件名称</li><li>-altp：不显示格子左上角的number</li><li>-lineh：行高</li></ul><p>设置完成之后发现<strong>jupyter的logo没有完全显示出来</strong>，同时<strong>文件名称也只显示了一部分</strong>，这些需要修改，找到<code>C:\Users\username\.jupyter\custom</code>目录下的<code>custom.css</code>进行修改:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将none改为block来显示jupyter的logo --&gt;</span></span><br><span class="line">div#ipython_notebook &#123;</span><br><span class="line"> display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将height: initial修改为20px，这个可以自己设置 --&gt;</span></span><br><span class="line">span.save_widget span.filename &#123;</span><br><span class="line"> margin-left: 8px;</span><br><span class="line"> height: 22px;</span><br><span class="line"> font-size: 100%;</span><br><span class="line"> color: #a6e22e;</span><br><span class="line"> background-color: #282828;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述修改每次重新修改主题相关配置后都需要重新修改</p><p>修改绘图配置：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jupyterthemes <span class="keyword">import</span> jtplot</span><br><span class="line">jtplot.style(theme=<span class="string">'grade3'</span>,ticks=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>主要使用的包是<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">jupyter_contrib_nbextensions</a>，这是一个非常强大的包，里面包含了很多在jupyter notebook只很常用的插件，包括代码段、显示目录等等等，同时这个包还提供了一个链接：<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">A collection of various notebook extensions for Jupyter</a>，里面总结了可以用在jupyter notebook中的插件。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install the python package</span></span><br><span class="line"><span class="comment">## 这个安装经常失败，下载速度太慢了</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment">## 换用这个了</span></span><br><span class="line">pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install javascript and css files</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>上述两步安装完成之后就可以在jupyter的homo page看到如下的插件：</p><img title="jupyter插件" alt="jupyter插件" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/jupyter插件.png?imageView2/2/w/600"><p>选取插件安装：</p><ul><li><strong>Code prettify</strong></li></ul><p>插件的快捷键：ctrl + l进行单个cell的prettify（也可以在选中cell时直接点击导航栏的小锤子按钮）、Ctrl-Shift-L进行所有的的prettify<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个插件安装后提示yapf没有安装</span></span><br><span class="line">pip install yapf</span><br></pre></td></tr></table></figure><p></p><p>After checking “Snippets Menu” in Configurable nbextensions, Snippets did’t appear in</p><ul><li><strong>Collapsible headings</strong>-折叠标题</li><li><strong>Snippets</strong>-自定义代码片段</li></ul><p>修改<code>C:\Users\user\AppData\Roaming\jupyter\nbextensions\snippets\snippets.json</code>来添加新的代码段，注意是上面的地址，<strong>而不是anaconda目录下的文件，如果修改了anaconda下的文件不起作用</strong>。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "name" : "common_use",</span><br><span class="line">    "code" : [</span><br><span class="line">        "import os",</span><br><span class="line">        "import sys",</span><br><span class="line">        "import numpy as np",</span><br><span class="line">        "import pandas as pd"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编辑完成之后想要生效需要重启jupyter notebook</p><ul><li><strong>Table of Contents (2)</strong>-显示目录结构</li></ul><p>这个和上面的jupyter-themes好像要有些冲突，导航栏遮挡部分的目录结构，现在还不知道有没有什么解决办法， 可以取舍一下</p><ul><li><strong>Highlight selected word</strong>-高亮代码中与选中部分相同的</li><li><strong>highlighter</strong>-高亮选中的文本</li><li><strong>ExecuteTime</strong>-显示每个cell的运行时间</li><li><strong>table_beautifier</strong>-让输出的table更好看</li><li><strong>Snippets Menu</strong>-和snippet类似，但是<mark>没有正常工作，需要看看为什么？？？</mark></li><li><strong>Hinterland</strong>-自动补全代码</li></ul><hr><p><br></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li><a href="https://www.jianshu.com/p/a85bc2a8fa56" target="_blank" rel="noopener">多行输出</a></li><li><a href="https://zhuanlan.zhihu.com/p/32600329" target="_blank" rel="noopener">关于Jupyter Notebook的28个技巧(快捷键、Magic命令等)</a></li></ul><h2 id="jupyter-server搭建"><a href="#jupyter-server搭建" class="headerlink" title="jupyter server搭建"></a>jupyter server搭建</h2><ul><li><a href="https://bitmingw.com/2017/07/09/run-jupyter-notebook-server/" target="_blank" rel="noopener">搭建 ipython/jupyter notebook 服务器</a></li><li><a href="https://jupyter-notebook.readthedocs.io/en/stable/public_server.html" target="_blank" rel="noopener">Running a notebook server</a></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;针对默认的jupyter notebook的页面进行修改、增加一些插件使jupyter的使用更加方便，整理一些jupyter使用技巧，最后是关于搭建jupyter server的内容&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>markdown空格缩进</title>
    <link href="http://showteeth.tech/posts/58681.html"/>
    <id>http://showteeth.tech/posts/58681.html</id>
    <published>2019-03-01T08:07:24.000Z</published>
    <updated>2019-03-01T08:10:22.837Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/31eade263e7a" target="_blank" rel="noopener">markdown空格缩进以及HTML空格实体</a></li><li><a href="https://blog.csdn.net/testcs_dn/article/details/78957685" target="_blank" rel="noopener">markdown编辑器中可以使用的6种空格标记</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="markdown" scheme="http://showteeth.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>总结|位、字节、字符和编码</title>
    <link href="http://showteeth.tech/posts/56690.html"/>
    <id>http://showteeth.tech/posts/56690.html</id>
    <published>2019-02-28T16:58:24.000Z</published>
    <updated>2019-03-04T06:41:58.453Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文主要讲解了编码、字符、字节、位的概念，以及不同编码情况下字节与字符的对应关系，主要包括<code>ASCII码</code>、<code>UTF-8编码</code>、<code>Unicode编码</code>、<code>UTF-16编码</code>和<code>UTF-32编码</code>。</p></div><a id="more"></a><h2 id="编码问题的由来，相关概念的理解"><a href="#编码问题的由来，相关概念的理解" class="headerlink" title="编码问题的由来，相关概念的理解"></a>编码问题的由来，相关概念的理解</h2><h3 id="字符与编码的发展"><a href="#字符与编码的发展" class="headerlink" title="字符与编码的发展"></a>字符与编码的发展</h3><p>从计算机对多国语言的支持角度看，大致可以分为三个阶段：<br><table><tr><th width="10%">　</th><th width="10%">系统内码</th><th width="60%">说明</th><th width="20%">系统</th></tr><tr><td>阶段一</td><td>ASCII</td><td>计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。</td><td>英文 DOS</td></tr><tr><td>阶段二</td><td>ANSI编码（本地化）</td><td>为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 <strong>2 个字节来表示 1 个字符</strong>。比如：汉字 '中' 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些 <strong>使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码</strong>。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。<strong>不同 ANSI 编码之间 互不兼容 </strong>，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 <strong>ANSI 编码</strong>的文本中。</td><td>中文 DOS，中文 Windows 95/98，日文 Windows 95/98</td></tr><tr><td>阶段三</td><td>UNICODE（国际化）</td><td>为了使国际间信息交流更加方便，国际组织制定了 <strong>UNICODE 字符集</strong>，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。</td><td>Windows NT/2000/XP，Linux，Java</td></tr></table></p><p>字符串在内存中的存放方法：</p><p>在 <strong>ASCII</strong> 阶段，<strong>单字节字符串</strong>使用<strong>一个字节存放一个字符（SBCS）</strong>。比如，”Bob123” 在内存中为：<br><u>42</u> <u>6F</u> <u>62</u> <u>31</u> <u>32</u> <u>33</u> <u>00</u><br>&nbsp;B&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0</p><p>在使用 <strong>ANSI 编码</strong>支持多种语言阶段，每个字符使用一个字节或多个字节来表示（MBCS），因此，这种方式存放的字符也被称作<strong>多字节字符</strong>。比如，”中文123” 在中文 Windows 95 内存中为7个字节，<strong>每个汉字占2个字节，每个英文和数字字符占1个字节</strong>：</p><p><u>D6 D0</u> <u>CE C4</u> <u>31</u> <u>32</u> <u>33</u> <u>00</u><br>&emsp;中&emsp;&emsp;文&emsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0</p><p>在 <strong>UNICODE</strong> 被采用之后，计算机存放字符串时，改为存放每个字符在 UNICODE 字符集中的序号。目前计算机<strong>一般使用 2 个字节（16 位）来存放一个序号（DBCS）</strong>，因此，这种方式存放的字符也被称作<strong>宽字节字符</strong>。比如，字符串 “中文123” 在 Windows 2000 下，内存中实际存放的是 5 个序号：</p><p><u>2D 4E</u> <u>87 65</u> <u>31 00</u> <u>32 00</u> <u>33 00</u> <u>00 00</u> &lt;-在 x86 CPU 中，低字节在前<br>&emsp;中&emsp;&emsp;文&emsp;&emsp;1&emsp;&emsp;2&emsp;&emsp;3&emsp;&emsp;\0<br>一共占 10 个字节</p><hr><h3 id="字符、字节、字符串"><a href="#字符、字节、字符串" class="headerlink" title="字符、字节、字符串"></a>字符、字节、字符串</h3><p>理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分：</p><table><tr><th width="10%">　</th><th width="70%">概念描述</th><th width="20%">举例</th></tr><tr><td>字符</td><td>人们使用的记号，抽象意义上的一个符号。</td><td>'1', '中', 'a', '$', '￥', ……</td></tr><tr><td>字节</td><td>计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。</td><td>0x01, 0x45, 0xFA, ……</td></tr><tr><td>ANSI字符串</td><td>在内存中，如果“字符”是以 <strong>ANSI 编码</strong>形式存在的，<strong>一个字符可能使用一个字节或多个字节</strong>来表示，那么我们称这种字符串为 <strong>ANSI 字符串</strong>或者<strong>多字节字符串</strong>。</td><td>"中文123"（占7字节）</td></tr><tr><td>UNICODE字符串</td><td>在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 <strong>UNICODE 字符串或者宽字节字符串</strong>。</td><td>L"中文123"（占10字节）</td></tr></table><p>由于不同 ANSI 编码所规定的标准是不相同的，因此，对于一个给定的<strong>多字节字符串</strong>，我们必须知道它采用的是哪一种编码规则，才能够知道它包含了哪些“字符”。而对于 <strong>UNICODE 字符串</strong>来说，不管在什么环境下，它所代表的“字符”内容总是不变的。</p><hr><h3 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h3><p>各个国家和地区所制定的不同 ANSI 编码标准中，都只规定了各自语言所需的“字符”。比如：汉字标准（GB2312）中没有规定韩国语字符怎样存储。这些 ANSI 编码标准所规定的内容包含两层含义：</p><ol><li>使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“<strong>字符集</strong>”。</li><li>规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“<strong>编码</strong>”。</li></ol><p>各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p><p>“<strong>UNICODE 字符集</strong>”包含了各种语言中使用到的所有“字符”。用来给 UNICODE 字符集编码的标准有很多种，比如：UTF-8, UTF-7, UTF-16, UnicodeLittle, UnicodeBig 等。</p><hr><h3 id="常用的编码简介"><a href="#常用的编码简介" class="headerlink" title="常用的编码简介"></a>常用的编码简介</h3><p>简单介绍一下常用的编码规则，为后边的章节做一个准备。在这里，我们根据编码规则的特点，把所有的编码分成三类：<br><table><tr><th width="15%">分类</th><th width="15%">编码标准</th><th width="70%">说明</th></tr><tr><td>单字节字符</td><td>ISO-8859-1</td><td>最简单的编码规则，每一个字节直接作为一个 UNICODE 字符。比如，[0xD6, 0xD0] 这两个字节，通过 iso-8859-1 转化为字符串时，将直接得到 [0x00D6, 0x00D0] 两个 UNICODE 字符，即 "ÖÐ"。反之，将 UNICODE 字符串通过 iso-8859-1 转化为字节串时，只能正常转化 0~255 范围的字符。</td></tr><tr><td>ANSI</td><td>GB2312,BIG5,Shift_JIS,ISO-8859-2 ……</td><td>把 UNICODE 字符串通过 ANSI 编码转化为“字节串”时，根据各自编码的规定，一个 UNICODE 字符可能转化成一个字节或多个字节。反之，将字节串转化成字符串时，也可能多个字节转化成一个字符。比如，[0xD6, 0xD0] 这两个字节，通过 GB2312 转化为字符串时，将得到 [0x4E2D] 一个字符，即 '中' 字。“ANSI 编码”的<strong>特点</strong>：1. 这些“ANSI 编码标准”都只能处理各自语言范围之内的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间的关系是人为规定的。</td></tr><tr><td>UNICODE</td><td>UTF-8,UTF-16, UnicodeBig ……</td><td>与“ANSI 编码”类似的，把字符串通过 UNICODE 编码转化成“字节串”时，一个 UNICODE 字符可能转化成一个字节或多个字节。<strong>与“ANSI 编码”不同的是</strong>：1. 这些“UNICODE 编码”能够处理所有的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间是可以通过计算得到的。</td></tr></table></p><p>我们实际上没有必要去深究每一种编码具体把某一个字符编码成了哪几个字节，我们<strong>只需要知道“编码”的概念就是把“字符”转化成“字节”就可以了</strong>。对于“UNICODE 编码”，由于它们是可以通过计算得到的，因此，在特殊的场合，我们可以去了解某一种“UNICODE 编码”是怎样的规则。</p><hr><p><br></p><h2 id="简介介绍区别"><a href="#简介介绍区别" class="headerlink" title="简介介绍区别"></a>简介介绍区别</h2><p><strong>位（bit）</strong>：计算机存储信息的最小单位，11001100是一个八位二进制数。</p><p><strong>字节（byte）</strong>：是一种计量单位，表示数据量多少，是计算机存储容量基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）</p><p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号，比如<code>1、2、3、A、B、C、~！·#￥%……—*（）——+、</code>等等。</p><p><strong>编码</strong>：把“字符”转化成“字节”</p><p>不同编码里，字符和字节的对应关系如下：</p><p>ASCII码：</p><ul><li>1个英文字母（不分大小写）= 1个字节的空间</li><li>1个中文汉字 = 2个字节的空间</li></ul><p>Unicode编码：</p><ul><li>1个英文字符 = 2个字节</li><li>英文标点 = 2个字节</li><li>1个中文（含繁体） = 2个字节</li><li>中文标点 = 2个字节</li></ul><p>UTF-8编码：</p><ul><li>1个英文字符 = 1个字节</li><li>英文标点 = 1个字节</li><li>1个中文（含繁体） = 3个字节</li><li>中文标点 = 3个字节</li></ul><p>UTF-16编码：</p><ul><li>一个英文字母字符或一个汉字字符存储都需要2个字节</li><li>Unicode扩展区的一些汉字存储需要4个字节</li></ul><p>UTF-32编码：</p><ul><li>世界上任何字符的存储都需要4个字节</li></ul><div class="note info"><p>unicode编码、UTF-8编码、UTF-16编码、UTF-32编码都是对Unicode字符集进行编码的实现方式</p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/u012156116/article/details/79923484" target="_blank" rel="noopener">字符与字节的区别</a></li><li><a href="http://www.regexlab.com/zh/encoding.htm" target="_blank" rel="noopener">字符，字节和编码</a></li><li><a href="https://www.cnblogs.com/yangxiaoqin/p/8460395.html" target="_blank" rel="noopener">位、字节、字符的区别</a></li><li><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">UTF-8和Unicode关系</a></li><li><a href="https://www.cnblogs.com/wpcockroach/p/3907324.html" target="_blank" rel="noopener">简单几句话总结Unicode，UTF-8和UTF-16</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文主要讲解了编码、字符、字节、位的概念，以及不同编码情况下字节与字符的对应关系，主要包括&lt;code&gt;ASCII码&lt;/code&gt;、&lt;code&gt;UTF-8编码&lt;/code&gt;、&lt;code&gt;Unicode编码&lt;/code&gt;、&lt;code&gt;UTF-16编码&lt;/code&gt;和&lt;code&gt;UTF-32编码&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="基础" scheme="http://showteeth.tech/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://showteeth.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单行命令嵌套</title>
    <link href="http://showteeth.tech/posts/50164.html"/>
    <id>http://showteeth.tech/posts/50164.html</id>
    <published>2019-02-28T08:07:00.000Z</published>
    <updated>2019-03-01T08:56:52.382Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>单行命令嵌套，也就是一行命令使用另一行命令的结果，或者将命令的结果当做参数传给另一个命令，使用方法<code>command1 &lt;(command2)</code>.</p></div><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>将command2的结果作为command1的输入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  command1 &lt;(command2)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>uniq命令去重常常需要先进行排序操作：</p><blockquote><p><code>uniq -c &lt;(sort uniq.txt)</code><br>1 i am test<br>2 i love test<br>1 i want go abroad<br>4 this is a test<br>1 those are good men<br>1 we are good men<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try</p></blockquote><p>当前上述也可以直接使用<strong>管道符<code>|</code></strong>来操作</p><p>但是如果是像<code>join</code>这种<strong>需要操作两个文件的</strong>，单纯地使用管道符就很难达到目的，<code>join</code>对指定列进行连接时也需要进行排序操作：</p><blockquote><p><code>cat test1.txt</code><br>aa 1 2<br>bb 2 3<br>cc 4 6<br>dd 3 3</p></blockquote><blockquote><p><code>cat test2.txt</code><br>aa 2 1<br>bb 8 2<br>ff 2 4<br>cc 4 4<br>dd 5 5</p></blockquote><p>管道符和命令嵌套合用：</p><blockquote><p><strong><code>sort -k 1,1 test2.txt |join -j 1 &lt;(sort -k 1,1 test1.txt) -</code></strong><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>当然也可以直接使用命令嵌套：</p><blockquote><p><strong><code>join -j 1 &lt;(sort -k 1,1 test1.txt) &lt;(sort -k 1,1 test2.txt)</code></strong><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;单行命令嵌套，也就是一行命令使用另一行命令的结果，或者将命令的结果当做参数传给另一个命令，使用方法&lt;code&gt;command1 &amp;lt;(command2)&lt;/code&gt;.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>cut-按列切分文件字段工具</title>
    <link href="http://showteeth.tech/posts/64687.html"/>
    <id>http://showteeth.tech/posts/64687.html</id>
    <published>2019-02-28T07:35:38.000Z</published>
    <updated>2019-03-01T08:03:31.599Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了Linux下对每一行文本按照给定的分隔符进行切割并按照指定的范围提取字段、字符或字节的命令<code>cut</code>，其主要选项包括：<code>-d</code>、<code>-f</code>、<code>--complement</code>、<code>-s</code>、<code>-c</code>、<code>-b</code>、<code>-n</code>和<code>--output-delimiter</code>。</p></div><a id="more"></a><h2 id="cut用法"><a href="#cut用法" class="headerlink" title="cut用法"></a>cut用法</h2><ul><li><code>cut</code>命令从文件的每一行剪切字节、字符或字段并将这些字节、字符或字段写至标准输出</li><li>如果不指定文件，<code>cut</code>命令将读取标准输入</li></ul><h3 id="cut命令格式"><a href="#cut命令格式" class="headerlink" title="cut命令格式"></a>cut命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cut OPTION [FILE]</span><br></pre></td></tr></table></figure><hr><h3 id="cut-options说明"><a href="#cut-options说明" class="headerlink" title="cut options说明"></a>cut options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–bytes=LIST</td><td>以字节为单位进行分割，这些字节位置将忽略多字节字符边界，除非也指定了-n标志</td></tr><tr><td>-c</td><td>–characters=LIST</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>–delimiter=DELIM</td><td>自定义分隔符，默认为制表符tab</td></tr><tr><td>-f</td><td>–fields=LIST</td><td>与-d一同使用，显示指定字段的内容；也会打印不包含分隔符的行，除非指定了-s参数</td></tr><tr><td>-n</td><td></td><td>with -b: 取消分割多字节字符，仅和 -b 标志一起使用；如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出，否则该字符将被排除</td></tr><tr><td></td><td>–complement</td><td>补足被选择的字节、字符或字段</td></tr><tr><td>-s</td><td>–only-delimited</td><td>不打印没有包含分隔符的行，有利于去掉注释和标题</td></tr><tr><td></td><td>–output-delimiter=STRING</td><td>指定输出内容是的分隔符</td></tr></tbody></table><hr><h3 id="cut指定字段、字符或字节范围的方法"><a href="#cut指定字段、字符或字节范围的方法" class="headerlink" title="cut指定字段、字符或字节范围的方法"></a>cut指定字段、字符或字节范围的方法</h3><p>指定字段、字符或字节范围有以下三种方法：</p><ul><li><strong>N-</strong>：获取<em>连续</em>范围，<strong>从第N个</strong>字节、字符、字段<strong>到结尾</strong>；</li><li><strong>N-M</strong>：获取<em>连续</em>范围，<strong>从第N个</strong>字节、字符、字段<strong>到第M个（包括M在内）</strong>字节、字符、字段；</li><li><strong>-M</strong>：获取<em>连续</em>范围，<strong>从第1个</strong>字节、字符、字段<strong>到第M个（包括M在内）</strong>字节、字符、字段</li><li><strong>N,M</strong>：获取<em>不连续</em>范围，得到<strong>第N个</strong>字节、字符、字段和<strong>第M个</strong>字节、字符、字段</li><li><strong>N,M,Z-P</strong>：获取<em>连续范围和不连续</em>范围，<strong>第N个</strong>字节、字符、字段、<strong>第M个</strong>字节、字符、字段以及<strong>从第Z个</strong>字节、字符、字段<strong>到第P个（包括P在内）</strong>字节、字符、字段</li></ul><div class="note info"><p>逗号(,)可以使用多个</p></div><hr><p><br></p><h2 id="cut用法实例"><a href="#cut用法实例" class="headerlink" title="cut用法实例"></a>cut用法实例</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><blockquote><p><code>cat cut.txt</code><br>No Name Mark Percent<br>01 tom 69 91<br>02 jack 71 87<br>03 alex 68 98</p></blockquote><h3 id="d-自定义分隔符"><a href="#d-自定义分隔符" class="headerlink" title="-d 自定义分隔符"></a>-d 自定义分隔符</h3><p><mark>默认-d是制表符tab，这个很关键，不是空白字符，同时自定义的分隔符必须是单个的字符，比如单个的空格，不能是两个或以上空格</mark></p><blockquote><p><code>cut -d &#39; &#39; -f 1 cut.txt</code><br>No<br>01<br>02<br>03</p></blockquote><blockquote><p><code>awk &#39;{print $1&quot;;&quot;$2&quot;;&quot;$3&quot;;&quot;$4}&#39; cut.txt |cut -d &#39;;&#39; -f 1</code><br>No<br>01<br>02<br>03</p></blockquote><hr><h3 id="f-提取指定字段内容"><a href="#f-提取指定字段内容" class="headerlink" title="-f 提取指定字段内容"></a>-f 提取指定字段内容</h3><p>选取<strong>单个filed</strong>如上面-d用法示例</p><p><strong>选取多个字段，直接将多个字段在-f选项后使用,分割即可：</strong></p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3 cut.txt</code></strong><br>No Mark<br>01 69<br>02 71<br>03 68</p></blockquote><p><strong>也可以使用<code>-</code>和<code>,</code>混用的方法：</strong></p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3-4 cut.txt</code></strong><br>No Mark Percent<br>01 69 91<br>02 71 87<br>03 68 98</p></blockquote><hr><h3 id="–complement-提取指定字段之外的内容"><a href="#–complement-提取指定字段之外的内容" class="headerlink" title="–complement 提取指定字段之外的内容"></a>–complement 提取指定字段之外的内容</h3><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3 --complement cut.txt</code></strong><br>Name Percent<br>tom 91<br>jack 87<br>alex 98</p></blockquote><p><strong>这里得到的结果和上面单纯使用<code>-f</code>得到的结果可以说是互补的，因为<code>--complement</code>是提取指定字段之外的内容</strong></p><hr><h3 id="s-不打印没有包含分隔符的行"><a href="#s-不打印没有包含分隔符的行" class="headerlink" title="-s 不打印没有包含分隔符的行"></a>-s 不打印没有包含分隔符的行</h3><p>在cut.txt上增加一行文本，其分隔符和其他几行不同：</p><blockquote><p><code>cat cut.txt</code><br>#this-is-test<br>No Name Mark Percent<br>01 tom 69 91<br>02 jack 71 87<br>03 alex 68 98</p></blockquote><p><strong>默认情况，如果一行不包含分隔符，就会输出这一行</strong>：</p><blockquote><p>cut -d ‘ ‘ -f 1 cut.txt<br>#this-is-test<br>No<br>01<br>02<br>03</p></blockquote><p>为了防止上述情形出现，可以使用<code>-s</code>选项：</p><blockquote><p><code>cut -d &#39; &#39; -s -f 1 cut.txt</code><br>No<br>01<br>02<br>03</p></blockquote><p>可以发现，不包含空格作为分隔符的第一行就没有进行输出</p><hr><h3 id="c-提取指定字符范围的内容"><a href="#c-提取指定字符范围的内容" class="headerlink" title="-c 提取指定字符范围的内容"></a>-c 提取指定字符范围的内容</h3><blockquote><p><code>cat cut2.txt</code><br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz</p></blockquote><p><strong>指定连续范围：</strong></p><blockquote><p><code>cut -c -2 cut2.txt</code><br>ab<br>ab<br>ab<br>ab<br>ab</p></blockquote><blockquote><p><code>cut -c 5- cut2.txt</code><br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz</p></blockquote><p><strong>指定不连续范围和连续范围（<code>,</code>和<code>-</code>混用）：</strong></p><blockquote><p><code>cut -c 1,3-5 cut2.txt</code><br>acde<br>acde<br>acde<br>acde<br>acde</p></blockquote><hr><h3 id="b-提取指定字符范围的内容"><a href="#b-提取指定字符范围的内容" class="headerlink" title="-b 提取指定字符范围的内容"></a>-b 提取指定字符范围的内容</h3><blockquote><p><code>cut -b 1-5 cut2.txt</code><br>abcde<br>abcde<br>abcde<br>abcde<br>abcde</p></blockquote><p><strong>这结果咋一看和前面的<code>-c</code>没有什么区别，这是因为操作对象都是英文字母，而在<code>ASCII码</code>和<code>UTF-8编码</code>中英文字母的字节和字符是相等的</strong>，具体的字节和字符的区别见<a href="http://showteeth.tech/posts/56690.html">这篇博客</a></p><p>由于我使用的<strong>vscode的默认编码方式为<code>utf-8</code></strong>，所以<strong>英文字母的字节和字符是相等的</strong>，而<strong>中文1个中文（含繁体） = 3个字节</strong>，为了凸显-b和-c的区别，下面采用中文进行测试：</p><blockquote><p><code>cat cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><blockquote><p><code>cut -b 1-3 cut3.txt</code> # cut -b <strong>1-2</strong> cut3.txt<strong>结果为空</strong>，因为需要三个字节才可以<br>星<br>星<br>星<br>星<br>星</p></blockquote><blockquote><p><code>cut -c 1-3 cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><div class="note info"><p>针对英文字符进行提取指定字符范围内容时，<code>-b</code>和<code>-c</code>选项没什么差别，因为在大部分编码方式中，英文字母的字节和字符是相等的，而针对中文就需要注意不同的编码方式对中文字符对应字节数的设置，当然<code>cut</code>命令还提供了了一个选项<code>-n</code>来解决上述<code>-b</code>可能遇到的问题</p></div><hr><h3 id="n-取消分割多字节字符"><a href="#n-取消分割多字节字符" class="headerlink" title="-n 取消分割多字节字符"></a>-n 取消分割多字节字符</h3><p><strong>该选项仅和 -b 选项一起使用</strong>，用来取消分割多字节字符</p><blockquote><p><code>cut -b 3 cut3.txt</code></p></blockquote><blockquote><p>cut -nb 3 cut3.txt<br>星<br>星<br>星<br>星<br>星</p></blockquote><blockquote><p><code>cut -nb 3,6,9 cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><p>当<code>-nb</code>后面的数字为<code>3的整数倍（utf-8编码）</code>时就不会分割多字节字符，得到对应的字符，不过感觉这没啥大用处，一般都直接使用了<code>-c</code>参数来获取字符</p><hr><h3 id="–output-delimiter-STRING-指定输出内容是的分隔符"><a href="#–output-delimiter-STRING-指定输出内容是的分隔符" class="headerlink" title="–output-delimiter=STRING 指定输出内容是的分隔符"></a>–output-delimiter=STRING 指定输出内容是的分隔符</h3><blockquote><p><code>cut -d &#39; &#39; -f 1-3 --output-delimiter=$&#39;\t&#39; cut.txt</code><br>#this-is-test<br>No Name Mark<br>01 tom 69<br>02 jack 71<br>03 alex 68</p></blockquote><div class="note info"><p>注意这里指定输出分割符为tab的时候使用了<code>$&#39;\t&#39;</code>的方式，其中<code>$</code>和<code>单引号</code>都是必须的不能更改的，这个和<code>join</code>命令中指定分隔符的用法相同，具体原因查看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cut" target="_blank" rel="noopener">cut命令</a></li><li><a href="https://www.cnblogs.com/fulucky/p/8124858.html" target="_blank" rel="noopener">linux的cut命令</a></li><li><a href="https://www.cnblogs.com/longjshz/p/5792502.html" target="_blank" rel="noopener">Linux下的cut选取命令详解</a></li><li><a href="https://www.cnblogs.com/Hobbies/articles/4527447.html" target="_blank" rel="noopener">linux每日一命令–cut</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文主要学习了Linux下对每一行文本按照给定的分隔符进行切割并按照指定的范围提取字段、字符或字节的命令&lt;code&gt;cut&lt;/code&gt;，其主要选项包括：&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;--complement&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;和&lt;code&gt;--output-delimiter&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>uniq-去重</title>
    <link href="http://showteeth.tech/posts/20744.html"/>
    <id>http://showteeth.tech/posts/20744.html</id>
    <published>2019-02-28T07:35:14.000Z</published>
    <updated>2019-03-01T02:39:54.244Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文学习了linux中准备对文本进行去重操作的<code>uniq</code>命令，其重要的参数包括<code>-c</code>、<code>-d</code>、<code>-D</code>、<code>-f</code>、<code>-s</code>、<code>-w</code>、<code>-i</code>、<code>-u</code>。这个命令通常与<a href="http://showteeth.tech/posts/61024.html">sort</a>一起使用。</p></div><a id="more"></a><h2 id="uniq用法"><a href="#uniq用法" class="headerlink" title="uniq用法"></a>uniq用法</h2><p>uniq命令是专门用来去除重复行的命令，使用时需要注意：</p><ul><li>对文本操作时，它一般会和<a href="http://showteeth.tech/posts/61024.html">sort命令</a>进行组合使用，因为<strong>uniq 不会检查重复的行，除非它们是相邻的</strong>，如果您想<strong>先对输入排序</strong>，使用<strong>sort -u</strong></li><li>对文本操作时，若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中<strong>字符前的空字符将被跳过</strong></li></ul><h3 id="uniq命令格式"><a href="#uniq命令格式" class="headerlink" title="uniq命令格式"></a>uniq命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  uniq [OPTION] [INPUT [OUTPUT]]</span><br><span class="line">  <span class="comment"># 从输入文件或者标准输入中过滤相邻的匹配行并将结果写入到输出文件或标准输出</span></span><br><span class="line">  <span class="comment"># 在不加options的情况下，匹配行将在首次出现处被合并</span></span><br></pre></td></tr></table></figure><hr><h3 id="uniq-options说明"><a href="#uniq-options说明" class="headerlink" title="uniq options说明"></a>uniq options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>–count</td><td>在每行前加上表示行出现次数</td></tr><tr><td>-d</td><td>–repeated</td><td>只输出重复的行，即出现次数&gt;=2的行，且只打印一次</td></tr><tr><td>-D</td><td>–all-repeated[=delimit-method]</td><td>仅显示重复的行，即出现次数&gt;=2的行，且打印重复行的所有行。其中delimit-method表示对重复行集合的分隔方式，有三种取值，分别为none（默认）、prepend和separate。</td></tr><tr><td>-u</td><td>–unique</td><td>只显示唯一的行，即出现次数等于1的行</td></tr><tr><td>-f</td><td>–skip-fields=N</td><td>忽略前N个<strong>字段</strong></td></tr><tr><td>-s</td><td>–skip-chars=N</td><td>和-f类似，不过-s是忽略前N个<strong>字符</strong></td></tr><tr><td>-w</td><td>–check-chars=N</td><td>指定每行要比较的前N个字符数</td></tr><tr><td>-i</td><td>–ignore-case</td><td>不区分大小写</td></tr><tr><td>-z</td><td>–zero-terminated</td><td>end lines with 0 byte, not newline</td></tr></tbody></table><hr><p><br></p><h2 id="uniq用法实例"><a href="#uniq用法实例" class="headerlink" title="uniq用法实例"></a>uniq用法实例</h2><h3 id="测试文本"><a href="#测试文本" class="headerlink" title="测试文本"></a>测试文本</h3><blockquote><p><code>cat uniq.txt</code><br>this is a test<br>this is a test<br><strong>this is a test</strong><br>i am test<br>i love test<br>i love test<br><strong>this is a test</strong><br>whom have a try<br>WhoM have a try<br>you have a try<br>i want go abroad<br>those are good men<br>we are good men</p></blockquote><h3 id="使用默认方式进行去重"><a href="#使用默认方式进行去重" class="headerlink" title="使用默认方式进行去重"></a>使用默认方式进行去重</h3><blockquote><p><code>uniq uniq.txt</code><br><em>this is a test</em><br>i am test<br>i love test<br><em>this is a test</em><br>whom have a try<br>WhoM have a try<br>you have a try<br>i want go abroad<br>those are good men<br>we are good men</p></blockquote><p>可以发现，<strong>uniq在计算重复的时候只会看相邻行</strong>，有一个<em>this is a test</em>没有和其他相邻，结果就被保留下来，当做非重复行</p><h3 id="c-显示行重复出现的次数"><a href="#c-显示行重复出现的次数" class="headerlink" title="-c 显示行重复出现的次数"></a>-c 显示行重复出现的次数</h3><blockquote><p><code>uniq -c uniq.txt</code><br>3 this is a test<br>1 i am test<br>2 i love test<br>1 this is a test<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try<br>1 i want go abroad<br>1 those are good men<br>1 we are good men</p></blockquote><p>依旧存在前面提到的问题，<strong>uniq在计算重复的时候只会看相邻行</strong>，和sort连用：</p><blockquote><p><code>sort uniq.txt |uniq -c</code><br>1 i am test<br>2 i love test<br>1 i want go abroad<br><strong>4 this is a test</strong><br>1 those are good men<br>1 we are good men<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try</p></blockquote><p>单纯使用sort命令去重的结果和上面是一样的，只是不能得到具体的重复数目，uniq功能更加强大：</p><blockquote><p><code>sort -u uniq.txt</code><br>i am test<br>i love test<br>i want go abroad<br>this is a test<br>those are good men<br>we are good men<br>whom have a try<br>WhoM have a try<br>you have a try</p></blockquote><hr><h3 id="d-只输出重复的行"><a href="#d-只输出重复的行" class="headerlink" title="-d 只输出重复的行"></a>-d 只输出重复的行</h3><blockquote><p><code>sort uniq.txt |uniq -dc</code><br>2 i love test<br>4 this is a test</p></blockquote><hr><h3 id="D-仅显示重复的行"><a href="#D-仅显示重复的行" class="headerlink" title="-D 仅显示重复的行"></a>-D 仅显示重复的行</h3><blockquote><p><code>sort uniq.txt |uniq -D</code><br>i love test<br>i love test<br>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><p>这个就<strong>不能和<code>-c</code>连用</strong>，因为重复行都显示出来了</p><h4 id="delimit-method-none"><a href="#delimit-method-none" class="headerlink" title="delimit-method=none"></a>delimit-method=none</h4><p>none表示不进行分隔，为<strong>默认选项</strong>，<code>uniq -D</code>等同于<code>uniq --all-repeated=none</code></p><p>注意使用<code>delimit-method</code>的时候就<strong>不能使用option的简写形式</strong>，<strong>必须使用完整参数</strong></p><hr><h4 id="delimit-method-prepend"><a href="#delimit-method-prepend" class="headerlink" title="delimit-method=prepend"></a>delimit-method=prepend</h4><p>prepend表示在每一个<strong>重复行集合前面</strong>插入一个空行</p><blockquote><p><strong><code>sort uniq.txt |uniq --all-repeated=prepend</code></strong></p><p>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><hr><h4 id="delimit-method-separate"><a href="#delimit-method-separate" class="headerlink" title="delimit-method=separate"></a>delimit-method=separate</h4><p>separate表示在每个<strong>重复行集合间</strong>插入一个空行</p><blockquote><p><strong><code>sort uniq.txt |uniq --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><hr><h3 id="f-忽略前N个字段"><a href="#f-忽略前N个字段" class="headerlink" title="-f 忽略前N个字段"></a>-f 忽略前N个字段</h3><blockquote><p><strong><code>sort uniq.txt |uniq -f 1 --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p><em>those</em> are good men<br><em>we</em> are good men</p><p><em>whom</em> have a try<br><em>WhoM</em> have a try</p></blockquote><blockquote><p><code>uniq -f 2 --all-repeated=separate uniq2.txt</code><br>this is a test<br>this are a test</p><p>my name is showteeth<br>your mmmm is showteeth</p></blockquote><div class="note info"><p><strong>-f是指定前N个field</strong>，而<strong>不是仅仅规定单独的field来进行判断是不是重复</strong>，如果<strong>仅仅想看某一列</strong>，可以<strong>将那一列放在第一个field</strong>，然后使用<code>-f</code>参数即可</p></div><hr><h3 id="s-忽略前N个字符"><a href="#s-忽略前N个字符" class="headerlink" title="-s 忽略前N个字符"></a>-s 忽略前N个字符</h3><blockquote><p><strong><code>sort uniq.txt |uniq -s 4 --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p><em>whom</em> have a try<br><em>WhoM</em> have a try<br><em>you</em> have a try</p></blockquote><hr><h3 id="w-指定每行要比较的前N个字符数"><a href="#w-指定每行要比较的前N个字符数" class="headerlink" title="-w 指定每行要比较的前N个字符数"></a>-w 指定每行要比较的前N个字符数</h3><blockquote><p><strong><code>sort uniq.txt |uniq -w 2 --all-repeated=separate</code></strong><br><em>i</em> am test<br><em>i</em> love test<br><em>i</em> love test<br><em>i</em> want go abroad</p><p><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>ose are good men</p></blockquote><div class="note info"><p>注意这个参数和前面的<code>-f</code>、<code>-s</code>相同，都是<mark>前N个字段或者字符</mark>，而<strong>不是单纯地指定某一个字段或者字符</strong></p></div><hr><h3 id="i-不区分大小写"><a href="#i-不区分大小写" class="headerlink" title="-i 不区分大小写"></a>-i 不区分大小写</h3><blockquote><p><code>sort uniq.txt |uniq -i --all-repeated=separate</code><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p>whom have a try<br>WhoM have a try</p></blockquote><hr><h3 id="u-只显示唯一的行"><a href="#u-只显示唯一的行" class="headerlink" title="-u 只显示唯一的行"></a>-u 只显示唯一的行</h3><blockquote><p><code>sort uniq.txt |uniq -u</code><br>i am test<br>i want go abroad<br>those are good men<br>we are good men<br><em>whom</em> have a try<br><em>WhoM</em> have a try<br>you have a try</p></blockquote><p>显示<strong>在忽略大小写情况下的唯一的行</strong>：</p><blockquote><p><code>sort uniq.txt |uniq -u -i</code><br>i am test<br>i want go abroad<br>those are good men<br>we are good men<br>you have a try</p></blockquote><p>上面的whom存在大小写区别的行就没排除在外</p><div class="note info"><p>不会显示去除了重复之后的保留的唯一重复行</p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/ftl1012/p/uniq.html" target="_blank" rel="noopener">Linux uniq命令详解</a></li><li><a href="https://blog.csdn.net/k346k346/article/details/70175532" target="_blank" rel="noopener">Linux命令——uniq命令</a></li><li><a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">实例详细说明linux下去除重复行命令uniq</a></li><li><a href="http://man.linuxde.net/uniq" target="_blank" rel="noopener">uniq命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文学习了linux中准备对文本进行去重操作的&lt;code&gt;uniq&lt;/code&gt;命令，其重要的参数包括&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;、&lt;code&gt;-D&lt;/code&gt;、&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-w&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;。这个命令通常与&lt;a href=&quot;http://showteeth.tech/posts/61024.html&quot;&gt;sort&lt;/a&gt;一起使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>join-连接文本</title>
    <link href="http://showteeth.tech/posts/5579.html"/>
    <id>http://showteeth.tech/posts/5579.html</id>
    <published>2019-02-28T07:34:36.000Z</published>
    <updated>2019-02-28T17:06:28.228Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文学习了可以按照指定<code>field</code>内容来将两个文件连接起来的<code>join</code>命令，其重要的参数包括<code>-1</code>、<code>-2</code>、<code>-j</code>、<code>-o</code>、<code>-t</code>、<code>-a</code>、<code>-e</code>、<code>-v</code>、<code>–nocheck-order</code>。</p></div><a id="more"></a><h2 id="join用法"><a href="#join用法" class="headerlink" title="join用法"></a>join用法</h2><ul><li><code>join</code>命令用来将<strong>两个文件</strong>中<strong>指定栏位内容相同的行连接起来</strong>，再输出到标准输出设备</li><li><strong>默认</strong>连接的栏位是有<strong>空白字符分隔</strong>的第一个栏位</li></ul><h3 id="join命令格式"><a href="#join命令格式" class="headerlink" title="join命令格式"></a>join命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  join [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="join-options说明"><a href="#join-options说明" class="headerlink" title="join options说明"></a>join options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>FILENUM</td><td>FILENUM 取1或者2，表示除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行，<strong>相当于指定左外链接还是右外连接</strong></td></tr><tr><td>-v</td><td>FILENUM</td><td>与-a相似 但只显示文件里没匹配上的行</td></tr><tr><td>-e</td><td>EMPTY</td><td>取值为字符串，将须要显示可是文件里不存在的域用此选项指定的字符取代</td></tr><tr><td>-i</td><td>–ignore-case</td><td>比较栏位内容时，忽略大小写的差异</td></tr><tr><td>-j</td><td>FIELD</td><td>-j指定一个域作为匹配字段，等同于 -1 FIELD -2 FIELD</td></tr><tr><td>-1</td><td>FIELD</td><td>以file1中FIELD字段进行匹配</td></tr><tr><td>-2</td><td>FIELD</td><td>以file2中FIELD字段进行匹配</td></tr><tr><td>-o</td><td>FORMAT</td><td>以指定格式输出</td></tr><tr><td>-t</td><td>CHAR</td><td>指定输入输出的分隔符，join 默认以空白字符做分隔符</td></tr><tr><td>–check-order</td><td></td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td></td><td>不判断所有输入文件是不是已经排好序</td></tr></tbody></table><hr><p><br></p><h2 id="join用法实例"><a href="#join用法实例" class="headerlink" title="join用法实例"></a>join用法实例</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><blockquote><p><code>cat test1.txt</code><br>aa 1 2<br>bb 2 3<br>cc 4 6<br>dd 3 3</p></blockquote><blockquote><p><code>cat test2.txt</code><br>aa 2 1<br>bb 8 2<br>ff 2 4<br>cc 4 4<br>dd 5 5</p></blockquote><h3 id="使用默认方式连接文件"><a href="#使用默认方式连接文件" class="headerlink" title="使用默认方式连接文件"></a>使用默认方式连接文件</h3><blockquote><p><code>join test1.txt test2.txt</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br><strong>join: file 2 is not in sorted order</strong></p></blockquote><p>上面的结果<strong>没有输出完整</strong>，同时输出了提示信息，<strong>file 2(test2.txt)没有进行没有进行排序</strong>，结合前面学习的<a href="http://showteeth.tech/posts/61024.html">sort</a>命令对其第一列进行排序并进行连接：</p><blockquote><p><code>sort -k 1,1 test2.txt |join test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>这次得到了完整的结果，同时注意在<strong>管道符</strong>后使用<code>-</code>表示<code>read standard input</code>也就是前面的sort的输出内容</p><div class="note info"><p>对某一列进行连接，就需要<strong>保证文件的这一列是排好序的</strong>，而不是只要对整个文件进行排序即可</p></div><hr><h3 id="–nocheck-order-检查是否排序"><a href="#–nocheck-order-检查是否排序" class="headerlink" title="–nocheck-order 检查是否排序"></a>–nocheck-order 检查是否排序</h3><p>针对上面出现的文件没有排序的问题，也可以在不报错的情况下直接输出部分结果，默认情况应该是<code>--check-order</code>的：</p><blockquote><p><code>join --nocheck-order test1.txt test2.txt</code><br>aa 1 2 2 1<br>bb 2 3 8 2</p></blockquote><p>这个感觉没啥意义，得不到正确结果</p><hr><h3 id="1、-2-指定连接列"><a href="#1、-2-指定连接列" class="headerlink" title="-1、-2 指定连接列"></a>-1、-2 指定连接列</h3><ul><li><code>-1</code>：指定<strong>文件1（写在前面的文件）</strong>中用于连接的列</li><li><code>-2</code>：指定<strong>文件2（写在后面的文件）</strong>中用于连接的列</li></ul><blockquote><p><code>sort -k 1,1 test2.txt |join -1 1 -2 1 test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>这个结果和上面默认的结果相同</p><p>让文件1的第2列与文件2的第3列进行连接（两列都是已经排好序的，不用再排序）：</p><blockquote><p><code>join -1 2 -2 3 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong></p></blockquote><p>可以发现<strong>文件1中的<code>cc 4 6</code>出现了两次</strong>，这是因为<em>文件2中在第3列上出现了2个4</em>，这2个4对应的行都和文件1中的对应的行进行连接，从而出现了2次</p><p>如果在文件1中增加一列重复的<code>cc 4 6</code>，得到如下结果：</p><blockquote><p><code>join -1 2 -2 3 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong><br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong></p></blockquote><p>即使<strong>存在重复，连接也会进行组合操作</strong>，得到2x2个结果</p><div class="note info"><ul><li><strong>默认情况下</strong>，对哪一列进行连接，输出的结果中，<strong>用于连接的那一列就会放在最前面</strong>，如果需要<strong>自定义输出内容和顺序</strong>，可以使用后面提到的<code>-o</code>参数进行修改</li><li>文件在指定的列上存在相同的，则会进行组合，比如各有2个相同的，则会得到2x2也就是4个结果（这里不管文件是否存在重复）</li></ul></div><hr><h3 id="j-指定用于连接的列"><a href="#j-指定用于连接的列" class="headerlink" title="-j 指定用于连接的列"></a>-j 指定用于连接的列</h3><p>如果两个文件中用于连接的列(field)相同，可以直接使用-j参数统一制定，不用使用上面那种-1、-2这种分别指定，较为简便：</p><blockquote><p><code>sort -k 1,1 test2.txt |join -j 1 test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><hr><h3 id="o-自定义输出内容和顺序"><a href="#o-自定义输出内容和顺序" class="headerlink" title="-o 自定义输出内容和顺序"></a>-o 自定义输出内容和顺序</h3><p>输出文件1的第1列和第2列以及文件2的第1列和第3列：</p><blockquote><p><code>join -1 2 -2 3 -o 1.{1,2} 2.{1,3} test1.txt test2.txt</code><br>aa 1 aa 1<br>bb 2 bb 2<br>cc 4 ff 4<br>cc 4 cc 4</p></blockquote><div class="note info"><p>注意这里大括号<code>{}</code>的用法，详细请参考<a href="http://showteeth.tech/posts/55603.html">文章</a></p></div><hr><h3 id="t-指定分隔符"><a href="#t-指定分隔符" class="headerlink" title="-t 指定分隔符"></a>-t 指定分隔符</h3><blockquote><p><code>sort -k 1,1 test2.txt|awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39;|join -t $&#39;\t&#39; &lt;(awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39; test1.txt) -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>指定<code>-t $&#39;\t&#39;</code>后，<strong>输出的内容也是以tab作为分隔的</strong>；使用<strong>默认的分隔符</strong>也能对上述案例进行连接，但是<strong>输出的是空格分隔</strong>，不管原始文件内是使用空格份额各还是tab分隔</p><div class="note info"><p>注意这里指定tab作为分隔符的方式，<strong><code>$&#39;\t&#39;</code>设定的原因（单引号+<code>$</code>）</strong>参考之前的<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h3 id="a-指定外连接"><a href="#a-指定外连接" class="headerlink" title="-a 指定外连接"></a>-a 指定外连接</h3><p><strong>join默认进行的是内连接</strong>，也就是找到两个文件中在指定列上能够连接起来的行显示出现，但是要想显示共有的以及一个文件有一个文件没有的行就需要涉及到外连接，分为<strong>左外链接和右外连接和全外连接</strong>。<strong>左外链接指</strong>除了显示在指定列上能够连接起来的行外，还要把左边文件有，右边文件没有的行显示出来，右外连接类似，<strong>全外连接</strong>是将左边和右边的都显示出来，不管有没有连接上</p><p>设置<strong>左外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 **-a 1** test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br><strong>3 dd 3</strong></p></blockquote><p>设置<strong>右外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a 2 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br><strong>5 dd 5</strong></p></blockquote><p>设置<strong>全外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a1 -a2 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br>3 dd 3<br>5 dd 5</p></blockquote><p>这个顺序好像有点错乱，不管是文件1还是文件2的内容都靠左显示，使用-o指定输出内容：</p><blockquote><p><code>join -1 2 -2 3 -a1 -a2 -o 1.{1..3} 2.{1..3} test1.txt test2.txt</code><br>aa 1 2 aa 2 1<br>bb 2 3 bb 8 2<br>cc 4 6 ff 2 4<br>cc 4 6 cc 4 4<br>dd 3 3<br>dd 5 5</p></blockquote><p>发现文件1的内容靠左，文件2的内容前面会留有3个空格（文件1每一行的长度），刚好错开</p><hr><h3 id="e-指定替代字符"><a href="#e-指定替代字符" class="headerlink" title="-e 指定替代字符"></a>-e 指定替代字符</h3><p>在上面设置<strong>左外链接和右外连接</strong>的情况下，使用<code>-e</code>设置字符来填充某个文件没有的行的信息:</p><blockquote><p><code>join -1 2 -2 3 -a 2 -o 1.{1..3} 2.{1..3} -e &quot;empty&quot; test1.txt test2.txt</code><br>aa 1 2 aa 2 1<br>bb 2 3 bb 8 2<br>cc 4 6 ff 2 4<br>cc 4 6 cc 4 4<br>empty empty empty dd 5 5</p></blockquote><div class="note info"><p><strong>使用<code>-e</code>选项时必须也要设定<code>-o</code>选项</strong>，不然不能使用字符进行填充（可能是因为如-a参数使用中的不设置-o参数会使得结果显示出现问题，指定连接的列会在最左边显示，不能连接的行的内容不管是文件1还是文件2都会靠左显示，不能正确显示出内容和文件的对应关系）</p></div><hr><h3 id="v-显示未匹配行"><a href="#v-显示未匹配行" class="headerlink" title="-v 显示未匹配行"></a>-v 显示未匹配行</h3><blockquote><p><code>join -1 2 -2 3 -v 1 test1.txt test2.txt</code><br>3 dd 3</p></blockquote><blockquote><p><code>join -1 2 -2 3 -v 2 test1.txt test2.txt</code><br>5 dd 5</p></blockquote><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="指定多个列来进行链接"><a href="#指定多个列来进行链接" class="headerlink" title="指定多个列来进行链接"></a>指定多个列来进行链接</h3><p>因为join命令只支持单个field的连接，而指定多个field作为连接列又非常常用，所以这里给出了几种解决方法：</p><p><strong>思路一：既然join命令只支持单个field的连接，那就把多个field转化为单个field进行连接即可</strong><br>将上述test1.txt的第1列和第2列与test2.txt的第1列和第3列进行连接：</p><blockquote><p><strong><code>join -j 1 &lt;(awk &#39;{print $1&quot;-&quot;$2&quot;\t&quot;$0}&#39; test1.txt |sort -k 1,1) &lt;(awk &#39;{print $1&quot;-&quot;$3&quot;\t&quot;$0}&#39; test2.txt |sort -k 1,1)</code></strong><br><em>aa-1</em> aa 1 2 aa 2 1<br><em>bb-2</em> bb 2 3 bb 8 2<br><em>cc-4</em> cc 4 6 cc 4 4</p></blockquote><p>控制输出的时候可以使用<code>-o</code>参数对输出进行控制，来决定输出的内容</p><p><strong>思路二：通过处理其中一个文件得到匹配的fileds，然后利用<code>grep</code>命令在另一个文件中查找这个fields，得到最终的结果</strong><br>提取test1.txt的第1列和第2列作为pattern_file，在test2.txt文件中对齐进行查找：</p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,2 test1.txt |grep -f - &lt;(awk &#39;{print $1,$3,$2}&#39; test2.txt )</code></strong><br>aa 1 2<br>bb 2 8<br>cc 4 4</p></blockquote><p>注意这个<strong>只能得到test2.txt中的内容</strong>，而且还<strong>必须得调整列的位置</strong>，使<strong>test2.txt中需要和pattern_file进行连接的列进行对应（pattern_file是第1、2列，那就需要把test2.txt的第3列换到第2列的位置，和pattern_file进行对应）</strong>，不然不能查找结果。</p><p>还可以使用<code>awk</code>命令进行操作，具体参考<a href="https://stackoverflow.com/questions/2619562/joining-multiple-fields-in-text-files-on-unix" target="_blank" rel="noopener">这个链接</a></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.runoob.com/linux/linux-comm-join.html" target="_blank" rel="noopener">Linux join命令</a></li><li><a href="https://www.cnblogs.com/agilework/archive/2012/04/18/2454877.html" target="_blank" rel="noopener">linux下join命令的用法</a></li><li><a href="https://blog.csdn.net/K346K346/article/details/80237368" target="_blank" rel="noopener">Linux命令——join命令</a></li><li><a href="https://www.jianshu.com/p/97006b505cd6" target="_blank" rel="noopener">linux: join</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文学习了可以按照指定&lt;code&gt;field&lt;/code&gt;内容来将两个文件连接起来的&lt;code&gt;join&lt;/code&gt;命令，其重要的参数包括&lt;code&gt;-1&lt;/code&gt;、&lt;code&gt;-2&lt;/code&gt;、&lt;code&gt;-j&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-v&lt;/code&gt;、&lt;code&gt;–nocheck-order&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>sort-排序</title>
    <link href="http://showteeth.tech/posts/61024.html"/>
    <id>http://showteeth.tech/posts/61024.html</id>
    <published>2019-02-27T03:10:06.000Z</published>
    <updated>2019-02-28T14:06:23.525Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文学习sort-对文件进行排序，主要包括了sort用法(命令格式、参数说明)、用法实例(各种参数：<code>-u</code>、<code>-n</code>、<code>-r</code>、<code>-k</code>、<code>-t</code>、<code>-o</code>、<code>-c</code>、<code>h</code>和<code>g</code>等的实例讲解)并在最后给出了几个非常常用的实战示例。</p></div><a id="more"></a><h2 id="sort用法"><a href="#sort用法" class="headerlink" title="sort用法"></a>sort用法</h2><ul><li><code>sort</code>命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</li><li><code>sort</code>命令既可以从<strong>特定的文件</strong>，也可以<strong>从stdin中获取输入</strong></li></ul><h3 id="sort命令格式"><a href="#sort命令格式" class="headerlink" title="sort命令格式"></a>sort命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  sort [OPTION] [FILE]</span><br></pre></td></tr></table></figure><hr><h3 id="sort-options说明"><a href="#sort-options说明" class="headerlink" title="sort options说明"></a>sort options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–ignore-leading-blanks</td><td>忽略每行前面开始出的空格字符</td></tr><tr><td>-d</td><td>–dictionary-order</td><td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符</td></tr><tr><td>-f</td><td>–ignore-case</td><td>排序时，将小写字母视为大写字母，亦即忽略大小写</td></tr><tr><td>-g</td><td>–general-numeric-sort</td><td>按通用数值排序，支持科学计数法</td></tr><tr><td>-i</td><td>–ignore-nonprinting</td><td>排序时，除了040至176之间的ASCII字符外，忽略其他的字符</td></tr><tr><td>-M</td><td>–month-sort</td><td>将前面3个字母依照月份的缩写进行排序 (unknown) &lt; ‘JAN’ &lt; … &lt; ‘DEC’</td></tr><tr><td>-m</td><td>–merge</td><td>将几个排序号的文件进行合并</td></tr><tr><td>-h</td><td>–human-numeric-sort</td><td>使用易读性数字(例如： 2K 1G)</td></tr><tr><td>-n</td><td>–numeric-sort</td><td>依照数值的大小排序</td></tr><tr><td>-o</td><td>–output=FILE</td><td>将排序后的结果存入指定的文件</td></tr><tr><td>-r</td><td>–reverse</td><td>降序排序，默认为升序</td></tr><tr><td>-t</td><td>–field-separator=SEP</td><td>指定排序时所用的栏位分隔字符</td></tr><tr><td>-k</td><td>–key=POS1[,POS2]</td><td>排序从POS1开始，若指定POS2，则POS2结束，否则以pos1排序</td></tr><tr><td>-u</td><td>–unique</td><td>去除重复的行</td></tr><tr><td>-c</td><td>–check</td><td>检查文件是否已经按照顺序排序</td></tr></tbody></table><hr><p><br></p><h2 id="sort用法实例"><a href="#sort用法实例" class="headerlink" title="sort用法实例"></a>sort用法实例</h2><h3 id="使用默认方式对文件进行排序"><a href="#使用默认方式对文件进行排序" class="headerlink" title="使用默认方式对文件进行排序"></a>使用默认方式对文件进行排序</h3><p><code>sort</code> 命令将以<strong>默认的方式</strong>将文本文件的<strong>第一列以ASCII码的次序排列</strong>，并将结果<strong>输出到标准输出</strong><br>测试文件default.txt:</p><blockquote><p><code>cat default.txt</code><br>test 30<br>Hello 95<br>Linux 25</p></blockquote><blockquote><p><code>sort default.txt</code><br>Hello 95<br>Linux 25<br>test 30</p></blockquote><hr><h3 id="u-去除重复行"><a href="#u-去除重复行" class="headerlink" title="-u 去除重复行"></a>-u 去除重复行</h3><blockquote><p><code>cat uniq.txt</code><br>test 30<br>Hello 95<br>Linux 25<br>Linux 25<br>Linux 20</p></blockquote><p>文件中存在两行完全相同的信息，这将其去除:</p><blockquote><p><code>sort -u uniq.txt</code><br>Hello 95<br>Linux 20<br>Linux 25<br>test 30</p></blockquote><p><strong>会考察所有的列是否相同来进行去除，只有第一列相同是不会进行去除的</strong></p><h3 id="n-对数字进行排序"><a href="#n-对数字进行排序" class="headerlink" title="-n 对数字进行排序"></a>-n 对数字进行排序</h3><blockquote><p><code>cat num.txt</code><br>10<br>20<br>30<br>110<br>120<br>210</p></blockquote><p>sort默认会<strong>把所有列当成字符来进行排序</strong>，因为1小于3，所以110小于20：</p><blockquote><p><code>sort num.txt</code><br>10<br>110<br>120<br>20<br>210<br>30</p></blockquote><p>为了避免上述情况，需要使用<code>-n</code>选项，声明是数字进行排序，而不是字符：</p><blockquote><p><code>sort -n num.txt</code><br>10<br>20<br>30<br>110<br>120<br>210</p></blockquote><hr><h3 id="r-降序排列"><a href="#r-降序排列" class="headerlink" title="-r 降序排列"></a>-r 降序排列</h3><p>从上面的输出结果可以看出：sort默认进行的是升序排列，为了能够得到降序排列的结果，需要使用参数<code>-r</code>：</p><blockquote><p><code>sort -n -r num.txt</code> 等价于 <code>sort -nr num.txt</code><br>210<br>120<br>110<br>30<br>20<br>10</p></blockquote><hr><h3 id="k-指定排序开始-和结束-的位置"><a href="#k-指定排序开始-和结束-的位置" class="headerlink" title="-k 指定排序开始(和结束)的位置"></a>-k 指定排序开始(和结束)的位置</h3><h4 id="k选项的语法格式"><a href="#k选项的语法格式" class="headerlink" title="-k选项的语法格式"></a>-k选项的语法格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FStart.CStart Modifie,FEnd.CEnd Modifier   <span class="comment"># 详细划分</span></span><br><span class="line">-------Start--------,-------End--------    <span class="comment"># 整体划分</span></span><br><span class="line">FStart.CStart 选项  ,  FEnd.CEnd 选项       <span class="comment"># 详细划分解读</span></span><br></pre></td></tr></table></figure><ul><li>这个语法格式可以被其中的逗号<code>,</code>分为两大部分，<strong>Start部分</strong>和<strong>End部分</strong></li><li><code>Start</code>部分也<strong>由两部分组成</strong>:<ul><li><strong>Modifier</strong>部分是<strong>选项部分</strong>，可以用到b、d、f、i、n 或 r。</li><li><code>FStart.CStart</code>，其中<code>FStart</code>就是表示使用的<strong>域</strong>而<code>CStart</code>则表示<strong>在FStart域中</strong>从<strong>第几个字符开始算“排序首字符”</strong>。<code>C.Start</code>也是可以省略的，<u>省略的话就表示从本域的开头部分开始</u></li></ul></li><li>同理，在<code>End</code>部分中，你可以设定<code>FEnd.CEnd</code>，如果你<strong>省略.CEnd，则表示结尾到“域尾”，即<u>本域</u>的最后一个字符</strong>。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”</li><li><mark>如果直接省略了<code>End</code>部分，则会直接从指定的开始位置到一行的结束进行排序</mark></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>从<strong>公司英文名称（第一个域）</strong>的<strong>第二个字母</strong>开始进行排序：</p><blockquote><p><code>sort -k 1.2 salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p><strong>结果解读：</strong>使用了<code>-k 1.2</code>，表示对<strong>第一个域</strong>的<strong>第二个字符开始到本域的最后一个字符为止</strong>的字符串进行排序，结果是baidu因为第二个字母是a而名列榜首，sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三，guge只能排在第四了。</p><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序：</p><blockquote><p><code>sort -k 1.2 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>可以发现这个与预期的结果并不一致，和没有按照员工工资进行降序排序的结果相同，所以命令肯定存在问题。首先，<code>-k 3nr</code>没有起作用，相当于只是用前面的<code>-k 1.2</code>就可以达到效果，事实上也正是如此，因为<code>-k 1.2</code>表示对<strong>第一个域</strong>的<strong>第二个字符开始到本域的最后一个字符为止</strong>的字符串进行排序，按照上一个示例的分析，可以将这些结果分开，所以就不存在上面所说的<code>如果相同的按照员工工资进行降序排序</code>，因此后面的排序也就没有了意义。随后基于此我做了一个测试，在最后一行增加”google 110 4500”，这样就存在了<code>-k 1.2</code>不能讲所有的分开是现象，依旧使用上面的命令进行排序：</p><blockquote><p><code>sort -k 1.2 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>发现上述并没有按照我预定的<code>-k 1.2</code>不能讲所有的分开，然后就按照第二个指定的<code>-k 3nr</code>进行排序，然后我去google上搜索相关问题发现<a href="https://unix.stackexchange.com/questions/78925/how-to-sort-by-multiple-columns?rq=1" target="_blank" rel="noopener">有个回答</a>说<mark>对多行进行排序时需要指定sort keys的开始和结束，如果没指定结束就会在一直到一行的末尾结束（可能是因为第一个key是主key），不会考虑后面继续设置的key</mark>，基于此，做了测试：</p><blockquote><p><code>sort -k 1.2,1 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>google 110 4500<br>guge 50 3000</p></blockquote><p>最终得到了正确的结果，使用<code>-k 1.2,1</code>是<strong>省略.CEnd，则表示结尾到“域尾”</strong>，同时吸取上面的教训，为了严谨期间，虽然第3列是最后一列，也直接加上sort key的结束位置：<code>sort -k 1.2,1 -k 3,3nr salary.txt</code>，结果和上面相同</p><div class="note info"><ul><li><code>-k 3nr</code>：表示在第3列上进行按数字的降序进行排列</li><li><strong>对不同的列进行不同的排序方式时尤其需要指定sort key的结束为止，如果不指定，会以第一个key设置的为主，忽略后续key的设置，这个在对不同的列分别依据ascii和数字进行排序中非常常见</strong></li></ul></div><hr><h3 id="t-指定field分隔符"><a href="#t-指定field分隔符" class="headerlink" title="-t 指定field分隔符"></a>-t 指定field分隔符</h3><p>sort使用<code>-t</code>参数来<strong>指定分隔符</strong>，<strong>默认的分隔符为空格(包括空格和tab)</strong>:</p><blockquote><p><code>cat sep.txt</code><br>aaa:eee<br>ccc:eee<br>ddd:ddd<br>bbb:ccc<br>eee:bbb<br>eee:aaa</p></blockquote><p>以<code>:</code>为分隔符，对<strong>第二列</strong>进行排序：</p><blockquote><p><code>sort -t : -k 2 sep.txt</code><br>eee:aaa<br>eee:bbb<br>bbb:ccc<br>ddd:ddd<br>aaa:eee<br>ccc:eee</p></blockquote><p>当然也可以<strong>指定列来判断重复与否</strong>，并进行删除：</p><blockquote><p><code>sort -t : -uk 2 sep.txt</code><br>eee:aaa<br>eee:bbb<br>bbb:ccc<br>ddd:ddd<br>aaa:eee</p></blockquote><hr><h3 id="o-输出到文件"><a href="#o-输出到文件" class="headerlink" title="-o 输出到文件"></a>-o 输出到文件</h3><p>输出到文件也可以使用重定向<code>&gt;</code>进行操作，但是<strong>如果使用重定向想要写入原文件，这个时候不但写不进去，还把原文件清空了</strong></p><p>这个问题可以很好的使用<code>-o</code>参数解决，<code>-o</code>后面接原文件，即<strong>可将重排序的结果写入原文件</strong></p><h3 id="c-检查文件是否已经排序"><a href="#c-检查文件是否已经排序" class="headerlink" title="-c 检查文件是否已经排序"></a>-c 检查文件是否已经排序</h3><p><strong>如果乱序，则输出第一个乱序的行的相关信息</strong></p><blockquote><p><code>sort -c uniq.txt</code><br>sort: uniq.txt:2: disorder: Hello 95</p></blockquote><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="对多行进行排序并进行去重"><a href="#对多行进行排序并进行去重" class="headerlink" title="对多行进行排序并进行去重"></a>对多行进行排序并进行去重</h3><p>示例文件：含有google共有三行，其中有两行1、2列是完全相同的，有一行是第一列是相同的：</p><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br><strong>google 110 5000</strong><br>guge 50 3000<br><strong>google 110 4500</strong><br><strong>google 120 4500</strong></p></blockquote><p><strong>对1、2列进行排序并删除在这两列上的重复行：</strong></p><blockquote><p><code>sort -uk 1,2 salary.txt</code><br>baidu 100 5000<br><strong>google 110 5000</strong><br><strong>google 120 4500</strong><br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>可以发现达到了目的</p><p>只针对第一列来看：</p><blockquote><p><code>sort -uk 1 salary.txt</code><br>baidu 100 5000<br>google 110 4500<br>google 110 5000<br>google 120 4500<br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>这个并没有达到目的，和前面提到的<code>-k</code>选项中提到的一样，<strong>必须要指定终止位置</strong>，<strong>不然会比较整个行</strong>，这样最终结果是没有重复的，如果在上面文件中<strong>故意加一行重复的</strong>，还果真如此，比较的是整个行：</p><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000<br>google 110 4500<br><strong>google 120 4500</strong><br><strong>google 120 4500</strong></p></blockquote><blockquote><p><code>sort -uk 1 salary.txt</code><br>baidu 100 5000<br>google 110 4500<br>google 110 5000<br><strong>google 120 4500</strong><br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>增加终止位置，得到预期结果：</p><blockquote><p><code>sort -uk 1,1 salary.txt</code><br>baidu 100 5000<br>google 110 5000<br>guge 50 3000<br>sohu 100 4500</p></blockquote><p><strong>第一列相同的行中进行去重复保留的是原始文件中第一个出现的</strong></p><hr><h3 id="对文件大小进行排序"><a href="#对文件大小进行排序" class="headerlink" title="对文件大小进行排序"></a>对文件大小进行排序</h3><p><code>-h</code>：排序时使用易读性数字(例如： 2K 1G)</p><p><strong>统计目录下子目录的大小，并按大小进行降序排列：</strong></p><blockquote><p><code>du -h |sort -hr</code> # <code>du -h</code>统计目录下子目录的大小<br>2.6G ./test2<br>2.6G . # 整个目录大小<br>6.8M ./test<br>4.0K ./test3</p></blockquote><hr><h3 id="系统进程内存占用排序"><a href="#系统进程内存占用排序" class="headerlink" title="系统进程内存占用排序"></a>系统进程内存占用排序</h3><p><code>-g</code>：按通用数值排序，支持科学计数法</p><blockquote><p><code>ps aux |less -S</code><br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p></blockquote><blockquote><p><code>ps aux|sort -gr -k 4|head -n 5|awk &#39;{print $2,$3,$4}&#39;</code><br>10742 0.0 0.8<br>3916 99.5 0.7<br>110870 99.5 0.4<br>131268 99.5 0.3<br>66967 0.0 0.0</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html" target="_blank" rel="noopener">linux sort 命令详解</a></li><li><a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-sort.html" target="_blank" rel="noopener">Linux sort命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文学习sort-对文件进行排序，主要包括了sort用法(命令格式、参数说明)、用法实例(各种参数：&lt;code&gt;-u&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-k&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;h&lt;/code&gt;和&lt;code&gt;g&lt;/code&gt;等的实例讲解)并在最后给出了几个非常常用的实战示例。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>字符串截取方法</title>
    <link href="http://showteeth.tech/posts/43811.html"/>
    <id>http://showteeth.tech/posts/43811.html</id>
    <published>2019-02-27T03:09:16.000Z</published>
    <updated>2019-02-27T12:22:40.545Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>字符串截取在平常的工作中非常常用，这里总结常用的截取方法，便于查阅和温习，主要包括：<code>${}</code>的<strong>字符串截取</strong>和<strong>正则匹配</strong>、<code>cut</code>命令的<code>-c</code>参数、<code>awk</code>的<code>substr</code>函数和<code>FS</code>内置参数以及<code>expr</code>的<code>substr</code>表达式</p></div><a id="more"></a><h2 id="使用-进行截取"><a href="#使用-进行截取" class="headerlink" title="使用${}进行截取"></a>使用<code>${}</code>进行截取</h2><p><code>${}</code>是一种非常常用的linux特殊符号，一般来说共有五种不同的功能，具体的是哪五种功能，之前已经写过<a href="http://showteeth.tech/posts/55603.html">一篇博文</a>，这里就不赘述了，这里主要用示例的形式讲解其中与字符串截取相关的两种功能：<strong>字符串截取</strong>和<strong>正则匹配替换</strong>。</p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><ul><li><code>${str:offest}</code>：从<strong>字符串尾端（左侧）下标offset(含)开始截取到末尾</strong>的子串</li><li><code>${str:offest:length}</code>：从<strong>字符串尾端（左侧）下标offset(含)开始向后截取长度为length</strong>的子串，长度超出不报错</li><li><code>${str:0-offset:length}</code>：从<strong>字符串尾端（右侧）下标offset(含)开始以及<u>向后</u>截取长度为length</strong>的子串</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"http://showteeth.tech/posts/55603.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取从下标5到字符串结尾的子串，注意下标是从0开始的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从下标5开始截取长度为10的子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5:10&#125;</span></span><br><span class="line"><span class="comment"># 字符长度超出不会报错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5:40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右数下标15开始截取长度为10的子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0-15:10&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="http://showteeth.tech/posts/55603.html">http://showteeth.tech/posts/55603.html</a><br>ttp://showteeth.tech/posts/55603.html<br>//showteeth.tech/posts/55603.html</p></blockquote><blockquote><p>//showteet<br>//showteeth.tech/posts/55603.html</p></blockquote><blockquote><p>osts/55603</p></blockquote><div class="note info"><ul><li><code>下标（offset）</code>从0开始 <strong>（注意与使用<code>awk</code>的<code>substr</code>函数进行字符截取不同）</strong></li><li><code>${str:0-offset:length}</code>是从字串右侧开始数坐标，然后和正常的一样，向后截取长度</li></ul></div><hr><h3 id="正则匹配替换"><a href="#正则匹配替换" class="headerlink" title="正则匹配替换"></a>正则匹配替换</h3><ul><li><code>${\#parameter}</code>：获取变量长度</li><li><code>${parameter#word}</code>、<code>${parameter##word}</code>：<strong>从头开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>#</code>为<strong>最短</strong>匹配，<code>##</code>为<strong>最长</strong>匹配</li><li><code>${parameter%word}</code>、<code>${parameter%%word}</code>：<strong>从尾开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>%</code>为<strong>最短</strong>匹配，<code>%%</code>为<strong>最长</strong>匹配</li><li><code>${parameter/pattern/string}</code>、<code>${parameter//pattern/string}</code>：使用string替换pattern，<code>/</code>表示<strong>只替换一次</strong>；<code>//</code>表示<strong>全部替换</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取变量长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边开始删除第一次出现子字符串即其左边字符，保留右边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str#*/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边开始删除最后一次出现子字符串即其左边字符，保留符号最右边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str##*/&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始删除第一次出现子字符串即其右边字符，保留左边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%/*&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始删除最后一次出现子字符串即其右边字符，保留最左边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%%/*&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换，只替换第一次出现的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str/\//%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换，所有匹配的都进行替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str//\//%&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>38</p></blockquote><blockquote><p>/showteeth.tech/posts/55603.html<br>55603.html</p></blockquote><blockquote><p><a href="http://showteeth.tech/posts">http://showteeth.tech/posts</a><br>http:</p></blockquote><blockquote><p>http:%/showteeth.tech/posts/55603.html<br>http:%%showteeth.tech%posts%55603.html</p></blockquote><div class="note info"><ul><li><code>#</code>在<code>%</code>的左边，所以<code>#</code>是从左向右删除字符，保留右边子串，而<code>%</code>是从右向左删除字符，保留左边字符</li><li>一个<code>#</code>或<code>%</code>是匹配并删除第一次出现的pattern，而<code>##</code>或<code>%%</code>是匹配并删除最后一次出现的pattern（相当于贪婪匹配）</li><li>上述的<code>parameter</code>都是可以不用引用的，因为<code>${var}</code>本来就和<code>$var</code>是一个意思</li></ul></div><hr><p><br></p><h2 id="使用awk进行截取"><a href="#使用awk进行截取" class="headerlink" title="使用awk进行截取"></a>使用awk进行截取</h2><p>使用<code>awk</code>中的<code>substr</code>函数，<code>substr()</code>用于从字符串中<strong>指定位置</strong>和<strong>长度</strong>截取出子串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usage：</span><br><span class="line">  substr(s, i [, n])</span><br><span class="line">    s 待截取的字符串</span><br><span class="line">    i 索引位置，从1开始，按照字符计算、非字节</span><br><span class="line">    n 要截取的长度，默认或者填写长度超出字符尾，则截取到字符尾</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |awk <span class="string">'&#123;print substr($str,5,10)&#125;'</span></span><br></pre></td></tr></table></figure><blockquote><p>://showtee</p></blockquote><p>也可以使用<code>awk</code>指定<strong>输入分割符</strong>的方式截取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |awk -v FS=<span class="string">"/"</span> <span class="string">'&#123; print $3 &#125;'</span></span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>注意这里与使用<code>${}</code>进行字符串截取不同，这里字符的<strong>索引开始为1</strong>，而上面<code>${}</code>索引<strong>开始位置为0</strong></li><li><code>FS</code>是awk内置的系统变量，表示<strong>域分隔符</strong>，默认为空白字符（空格），使用时需要结合<code>-v</code>来传递参数</li></ul></div><hr><p><br></p><h2 id="使用cut进行截取"><a href="#使用cut进行截取" class="headerlink" title="使用cut进行截取"></a>使用cut进行截取</h2><p><strong>直接通过范围得到子串：</strong><br><code>cut</code>命令的<code>-c</code>参数：<strong>仅显示行中指定范围的字符</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |cut -c 2-6</span><br></pre></td></tr></table></figure><p></p><blockquote><p>ttp:/</p></blockquote><div class="note warning"><ul><li>注意这里与使用<code>${}</code>进行字符串截取<strong>不同</strong>，与使用<code>awk</code>的<code>substr</code>函数进行字符截取<strong>相同</strong>，这里字符的<strong>索引开始为1</strong>，而上面<code>${}</code>索引<strong>开始位置为0</strong></li><li><code>cut</code> <code>-c</code> 后面接的是<code>index的起始和终止范围</code>，而不是像前面的<code>awk</code>和<code>${}</code>一样是<strong>index</strong>和<strong>length</strong>的组合</li></ul></div><p><strong>利用cut按分割符分割来得到子串：</strong></p><ul><li><code>cut</code>命令的<code>-d</code>参数：<strong>指定字段的分隔符，默认的字段分隔符为”TAB”</strong></li><li><code>cut</code>命令的<code>-f</code>参数：<strong>指定需要显示的字段</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |cut -d / -f 3</span><br></pre></td></tr></table></figure><blockquote><p>showteeth.tech</p></blockquote><div class="note info"><p><code>cut</code>命令的<code>-d</code>和<code>-f</code>参数合用主要用于得到被<strong>已知分隔符</strong>分割的<strong>一块子串</strong></p></div><hr><p><br></p><h2 id="使用expr进行截取"><a href="#使用expr进行截取" class="headerlink" title="使用expr进行截取"></a>使用expr进行截取</h2><p><code>expr</code>用于计算表达式变量的值，其中有表达式：<code>substr String StartPosition Length</code>，表示<strong>从String的StartPosition开始截取Length的子串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr substr <span class="variable">$str</span> 2 6</span><br></pre></td></tr></table></figure><blockquote><p>ttp://</p></blockquote><div class="note info"><ul><li>注意每个单词之间都有空格，不带空格会出错</li><li>索引位置也是从1开始，和<code>awk</code>的<code>substr</code>函数、<code>cut</code>命令的<code>-c</code>参数相同，和<code>${}</code>不同</li></ul></div><hr><p><br></p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><div class="note info"><ul><li>一般最为常用的是<code>${}</code>的<strong>正则匹配替换</strong>方法(保留字符串最左或者最右的子串)，同时awk和cut使用的也非常多</li><li>使用需要提供索引位置的方法时需要注意索引的开始位置：<ul><li><code>awk</code>的<code>substr</code>函数、<code>cut</code>命令的<code>-c</code>参数还有expr的substr表达式索引都是从1开始</li><li><code>${str:offest:length}</code>方法的索引则开始于0</li></ul></li><li><code>${}</code>、<code>cut</code>命令的<code>-c</code>参数以及<code>awk</code>的<code>FS</code>内置参数都是用于通过<strong>已知分割符</strong>得到相应的<strong>一块子串</strong>，而不是具体地通过索引位置</li></ul></div><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;字符串截取在平常的工作中非常常用，这里总结常用的截取方法，便于查阅和温习，主要包括：&lt;code&gt;${}&lt;/code&gt;的&lt;strong&gt;字符串截取&lt;/strong&gt;和&lt;strong&gt;正则匹配&lt;/strong&gt;、&lt;code&gt;cut&lt;/code&gt;命令的&lt;code&gt;-c&lt;/code&gt;参数、&lt;code&gt;awk&lt;/code&gt;的&lt;code&gt;substr&lt;/code&gt;函数和&lt;code&gt;FS&lt;/code&gt;内置参数以及&lt;code&gt;expr&lt;/code&gt;的&lt;code&gt;substr&lt;/code&gt;表达式&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>整数计算、浮点计算并保留小数</title>
    <link href="http://showteeth.tech/posts/28430.html"/>
    <id>http://showteeth.tech/posts/28430.html</id>
    <published>2019-02-27T03:08:40.000Z</published>
    <updated>2019-02-27T12:29:14.330Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>在linux中进行整数计算、浮点计算并保留小数，主要包括：使用<code>expr</code>进行<strong>整数运算</strong>以及<strong>简单的字符串操作</strong>、使用<code>bc</code>进行<strong>浮点运算</strong>和<strong>进制转换</strong>以及使用<code>awk</code>进行<strong>浮点运算</strong>。</p></div><a id="more"></a><h2 id="expr-整数或字符串表达式计算"><a href="#expr-整数或字符串表达式计算" class="headerlink" title="expr 整数或字符串表达式计算"></a>expr 整数或字符串表达式计算</h2><p><code>expr</code>语法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 表达式</span><br></pre></td></tr></table></figure><p></p><p>表达式说明:</p><ul><li><strong><code>expr</code>只能用于整数计算</strong></li><li>用<strong>空格隔开</strong>每个项</li><li><strong>用<code>/</code>(反斜杠)放在shell特定的字符</strong>前面</li><li><strong>对包含空格和其他特殊字符的字符串要用引号括起来</strong></li></ul><h3 id="整数计算"><a href="#整数计算" class="headerlink" title="整数计算"></a>整数计算</h3><table><tr><th width="10%">类别</th><th width="20%">语法</th><th width="70%">说明</th></tr><tr><td rowspan="2">四则运算</td><td>expr1 \| expr2</td><td>如果 expr1 不是零或 null 则传回 expr1，否则传回 expr2</td></tr><tr><td>expr1 \&amp; expr2</td><td>如果 expr1 及 expr2 都不为零或 null，则传回 expr1，否则传回 0</td></tr><tr><td rowspan="5">四则运算</td><td>expr1 + expr2</td><td>传回 expr1 加 expr2 后的值</td></tr><tr><td>expr1 - expr2</td><td>传回 expr1 减 expr2 后的值</td></tr><tr><td>expr1\* expr2</td><td>传回 expr1 乘 expr2 后的值</td></tr><tr><td>expr1 / expr2</td><td>传回 expr1 除 expr2 后的整数位值（小数位直接丢弃，不四舍五入）</td></tr><tr><td>expr1 % expr2</td><td>传回 expr1 除 expr2 的余数</td></tr><tr><td rowspan="6">大小判断</td><td>expr1 \&gt; expr2</td><td>如果 expr1 大于 expr2 则传回 1，否则传回 0。如果 expr1 及 expr2 都是数字，则是以数字大小判断，否则是以文字判断。以下皆同</td></tr><tr><td>expr1 \&lt; expr2</td><td>如果 expr1 小于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 = expr2</td><td>如果 expr1 等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 != expr2</td><td>如果 expr1 不等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 \&gt;= expr2</td><td>如果 expr1 大于或等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 \&lt;= expr2</td><td>如果 expr1 小于或等于 expr2 则传回 1，否则传回 0</td></tr></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">expr 2+3</span><br><span class="line">expr 2 + 3</span><br><span class="line"></span><br><span class="line">expr 2 * 3</span><br><span class="line">expr 2 \* 3</span><br><span class="line"></span><br><span class="line">expr 5 / 3</span><br><span class="line"></span><br><span class="line">expr 2 % 3</span><br></pre></td></tr></table></figure><blockquote><p>2+3 # 2和3之间没有空格，直接被输出，没有进行计算<br>5 # 输出正确结果</p></blockquote><blockquote><p>expr: syntax error # 因为没有对<code>*</code>进行转义，所以报错<br>6 # 转义后输出正确结果</p></blockquote><blockquote><p>1 # 直接去掉余数，不进行四舍五入</p></blockquote><blockquote><p>2 # 输出余数</p></blockquote><hr><h3 id="字符串表达式计算"><a href="#字符串表达式计算" class="headerlink" title="字符串表达式计算"></a>字符串表达式计算</h3><p>因为<code>expr</code>用于字符串计算并不常见，所以这里不仔细了解，只了解几个个人感觉比较常用的，需要了解的可以参考<a href="https://blog.csdn.net/guhong5153/article/details/6542995" target="_blank" rel="noopener">这篇博客</a></p><p><strong>计算字串长度(length)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr length <span class="string">"this is a test"</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>14</p></blockquote><p><strong>截取子串(substr)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># substr String StartPosition Length</span></span><br><span class="line">expr substr <span class="string">"this is a test"</span> 3 5</span><br></pre></td></tr></table></figure><p></p><blockquote><p>is is</p></blockquote><p><strong>匹配第一个字符(串)出现的位置(index)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr index <span class="string">"this is a test"</span> is</span><br></pre></td></tr></table></figure><p></p><blockquote><p>3</p></blockquote><div class="note info"><p>注意四则运算中的<code>*</code>需要进行转义处理，同时还有条件判断中的<code>|</code> <code>&amp;</code>和大小判断中的<code>&gt;</code> <code>&lt;</code>都需要进行转义处理</p></div><hr><p><br></p><h2 id="浮点计算并保留小数"><a href="#浮点计算并保留小数" class="headerlink" title="浮点计算并保留小数"></a>浮点计算并保留小数</h2><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p><code>bc</code>命令是任意精度计算器语言，通常在linux下当计算器用, 它类似基本的计算器, 使用这个计算器可以做基本的数学运算。</p><p>常用的运算：</p><ul><li>+ 加法</li><li>- 减法</li><li>* 乘法</li><li>/ 除法</li><li>^ 指数</li><li>% 余数</li><li>sqrt 开方</li></ul><p>语法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc (选项) (参数)</span><br></pre></td></tr></table></figure><p></p><p>在shell中直接输入<code>bc</code>即可进入交互式界面，类似于没有图形界面的计算器，输入表达式得到结果<br>具体用法不详细讲解，可以参考<a href="https://www.cnblogs.com/lovevivi/p/4359296.html" target="_blank" rel="noopener">这篇博客</a></p><p><strong>实际进行浮点运算常用的方法是通过管道符：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage:</span><br><span class="line">  <span class="built_in">echo</span>  <span class="string">'scale=num; expression'</span>|bc</span><br><span class="line">    num：表示保留的小数点后位数</span><br><span class="line">    expression：表示计算表达式</span><br></pre></td></tr></table></figure><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;2/3'</span> |bc</span><br></pre></td></tr></table></figure><blockquote><p>.66</p></blockquote><p><strong>可以发现上述输出结果中并没有0(因为结果小于0)，如果想要显示可以使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>0.66</p></blockquote><p><strong>bc还能用来进行进制的转换：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usage：</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"obase=base;ibase=base;num"</span> | bc</span><br><span class="line">    obase:输出数字的进制，默认值为10</span><br><span class="line">    ibase:输入数字的进制，默认值为10</span><br><span class="line">    num:进行进制转换的数字</span><br><span class="line">    obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的</span><br></pre></td></tr></table></figure><p></p><p>obase如果放在ibase后可能会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"obase=10;ibase=2;110"</span> | bc</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ibase=2;obase=10;110"</span> | bc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>6<br>110</p></blockquote><hr><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk中的计算，默认支持浮点运算：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> |awk <span class="string">'&#123;print 2/3&#125;'</span></span><br></pre></td></tr></table></figure><p></p><p><strong>格式化输出：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line"><span class="built_in">echo</span> |awk <span class="string">'&#123;printf("%.2f\n" , 3/50)&#125;'</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;在linux中进行整数计算、浮点计算并保留小数，主要包括：使用&lt;code&gt;expr&lt;/code&gt;进行&lt;strong&gt;整数运算&lt;/strong&gt;以及&lt;strong&gt;简单的字符串操作&lt;/strong&gt;、使用&lt;code&gt;bc&lt;/code&gt;进行&lt;strong&gt;浮点运算&lt;/strong&gt;和&lt;strong&gt;进制转换&lt;/strong&gt;以及使用&lt;code&gt;awk&lt;/code&gt;进行&lt;strong&gt;浮点运算&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux中特殊符号用法</title>
    <link href="http://showteeth.tech/posts/55603.html"/>
    <id>http://showteeth.tech/posts/55603.html</id>
    <published>2019-02-26T02:57:41.000Z</published>
    <updated>2019-02-28T12:46:20.519Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>Linux常见特殊符号作用，包括<code>#</code>、<code>~</code>、<code>~+</code>、<code>~-</code>、<code>;</code>、<code>;;</code>、<code>.</code>、<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>`</code>、<code>,</code>、<code>/</code>、<code>\</code>、<code>|</code>、<code>!</code>、<code>:</code>、<code>*</code>、<code>**</code>、<code>$</code>、<code>$$</code>、<code>?</code>、<code>${}</code>、<code>$*</code>、<code>$@</code>、<code>$#</code>、<code>$(())</code>、<code>(())</code>、<code>()</code>、<code>{}</code>、<code>[]</code>、<code>[[]]</code>、<code>||</code> 、<code>&amp;&amp;</code>、<code>\&lt;...\&gt;</code>和文件操作符以及重定向。</p></div><a id="more"></a><h2 id="号-注释"><a href="#号-注释" class="headerlink" title="#号-注释"></a>#号-注释</h2><p>在脚本中 <code>#</code>也常出现在一行的<strong>开头</strong>,或者位于<strong>完整指令之后</strong>,这类情况表示符号后边是<strong>注解文字,不会被执行</strong>，如果被<u>用在指令</u>中，或者<u>引号、双引号括住</u>的话，或者<u>在反斜线的后面</u>，那他就变成<strong>一般符号</strong>，不具上述的特殊功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#this line is comments</span></span><br></pre></td></tr></table></figure><hr><h2 id="home目录"><a href="#home目录" class="headerlink" title="~ home目录"></a>~ home目录</h2><p>代表使用者的<strong>home目录</strong>：<code>cd ~</code>表示进入home目录；也可以<strong>直接在符号后加上某帐户</strong>的名称：<code>cd ~user</code>表示进入这个user的home目录；或者<strong>当成是路径的一部份</strong>：<code>~/bin</code></p><p><code>~+</code>表示当前的工作目录</p><p><code>~-</code>表示上一个工作目录，这个在目录切换很好用啊，<code>cd ~-</code>直接<strong>进入上一次cd之前的目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">echo</span> ~+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入上一次cd之前的目录</span></span><br><span class="line"><span class="built_in">cd</span> ~-</span><br><span class="line"><span class="comment"># 进入上一次cd之前目录下的test目录</span></span><br><span class="line"><span class="built_in">cd</span> ~-/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure><hr><h2 id="分号"><a href="#分号" class="headerlink" title="; 分号"></a>; 分号</h2><p><strong>连续命令之间起到连接作用</strong>，命令之间没有依赖，<mark>不管上一条命令是否执行成功，分号后的命令都会执行</mark>。</p><hr><h2 id="连续分号"><a href="#连续分号" class="headerlink" title=";;连续分号"></a>;;连续分号</h2><p>专用在<code>case（多分支条件判断）</code>的选项，担任 <code>Terminator</code> 的角色</p><hr><h2 id="点号-dot"><a href="#点号-dot" class="headerlink" title=". 点号(dot)"></a>. 点号(dot)</h2><ul><li>在<strong>目录</strong>中：一个<code>.</code>表示当前目录，两个<code>..</code>表示上层目录</li><li>在<strong>文件命名</strong>中：以<code>.</code>开头的文件表明该文件是<strong>隐藏文件</strong>，需要使用<code>ls -a</code>才能看到</li><li>在<strong>正则表达式</strong>中：一个逗号表示一个任意字符（换行符 \n 之外），如果想要匹配<code>.</code>，需要使用转义<code>\.</code>。</li></ul><h2 id="‘’-单引号"><a href="#‘’-单引号" class="headerlink" title="‘’ 单引号"></a>‘’ 单引号</h2><p>被单引号用括住的内容，将被视为<code>单一字串</code>。在<mark>引号内的代表变量的<code>$</code>符号，没有作用</mark>，也就是说，他被视为一般符号处理，<strong>防止任何变量替换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$test'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">'s/hello/$test/'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p><code>$</code>test</p></blockquote><blockquote><p><code>$</code>test WORLD</p></blockquote><hr><h2 id="“”-双引号"><a href="#“”-双引号" class="headerlink" title="“” 双引号"></a>“” 双引号</h2><p>被双引号用括住的内容，将被视为<code>单一字串</code>。它<mark>防止通配符扩展，但允许变量替换</mark>，这点与单引号的处理方式不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$test</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">"s/hello/<span class="variable">$test</span>/"</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>hello</p></blockquote><blockquote><p>HELLO WORLD</p></blockquote><hr><h2 id="反引号"><a href="#反引号" class="headerlink" title="`` 反引号"></a>`` 反引号</h2><p>在前面的<strong>单双引号，括住的是字串</strong>，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用反引号来做，被<strong>反引号括住的内容是可以执行的</strong>。</p><p>与反引号相同可以用来进行命令执行的还有<code>$()</code>，两者的区别在于<mark>如果是使用反引号执行命令在进行命令嵌套时会比较麻烦，而使用<code>$()</code>进行命令的嵌套会比较简单</mark>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$test</span>`</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$test</span>)</span><br></pre></td></tr></table></figure><p>命令嵌套：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$test</span>))</span><br></pre></td></tr></table></figure><p>不等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$test</span>``</span><br></pre></td></tr></table></figure><p><strong>反引号遇到第一个匹配的反引号就结束，之间的内容会当做命令运行，可以使用转义字符<code>\</code>解决嵌套问题</strong></p><p>等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> \`<span class="built_in">echo</span> <span class="variable">$test</span>\``</span><br></pre></td></tr></table></figure><div class="note info"><p>所以还是使用<code>$()</code>来得到命令执行结果更为简便，但是不需要嵌套时两者差不多</p></div><hr><h2 id="逗号"><a href="#逗号" class="headerlink" title=", 逗号"></a>, 逗号</h2><p>这个符号常运用在运算当中当做<strong>区隔用途</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1,$2,$3,$4&#125;'</span> filename</span><br></pre></td></tr></table></figure><hr><h2 id="斜线"><a href="#斜线" class="headerlink" title="/ 斜线"></a>/ 斜线</h2><ul><li>在路径表示时，<strong>分割不同级别的目录</strong></li><li>单一的斜线<code>/</code>表示根目录，和上面的<code>~</code>表示的家目录不同</li><li>在四则运算中，代表<strong>除法的符号</strong></li></ul><h2 id="反斜线"><a href="#反斜线" class="headerlink" title="\ 反斜线"></a>\ 反斜线</h2><p>在交互模式下的escape字元，有几个作用</p><ul><li>放在<strong>指令前</strong>，有<strong>取消 aliases</strong>的作用；</li><li>放在<strong>特殊符号</strong>前，则该<strong>特殊符号的作用消失（转义）</strong>；</li><li>放在<strong>指令的最末端</strong>，表示指令<strong>连接下一行</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l</span></span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消ll代表ls -l，在ll之前防止反斜线表示暂时取消别名的功能，将 ll 指令还原</span></span><br><span class="line">\ll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转义，取消变量应用</span></span><br><span class="line">\<span class="variable">$test</span></span><br></pre></td></tr></table></figure><p>最终ll结果输出：</p><blockquote><p>bash: ll: command not found</p></blockquote><hr><h2 id="管道符"><a href="#管道符" class="headerlink" title="| 管道符"></a>| 管道符</h2><p><strong>连结上个指令的标准输出，做为下个指令的标准输入</strong>。</p><hr><h2 id="惊叹号"><a href="#惊叹号" class="headerlink" title="! 惊叹号"></a>! 惊叹号</h2><ul><li>通常它代表反逻辑的作用，如<code>!=</code>表示不等于</li><li>匹配模式取反：<code>sed -n &#39;1,2!p&#39; test.txt</code>表示打印第1、2行之外的行；<code>ls a[!0-9]</code>表示显示除了a0, a1 …. a9 这几个文件的其他文件</li><li>在历史命令（history）中：<ul><li><code>!number</code> ：表示执行history中<strong>第number条命令</strong></li><li><code>!!</code>：表示执行<strong>上一条命令</strong></li><li><code>!command</code>：执行<strong>最近一条command为开头的命令</strong></li><li><code>!$</code>：表示<strong>最近一条命令的第二个字符信息</strong></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line">!!</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>mkdir test<br>mkdir: cannot create directory `test’: File exists</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line">!$</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>test</p></blockquote><hr><h2 id="冒号"><a href="#冒号" class="headerlink" title=": 冒号"></a>: 冒号</h2><ul><li>在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0</li><li><code>: &gt; f</code>：相当于<code>cat/dev/null&gt;f</code>，这样不仅写法简短了，而且执行效率也好上许多</li><li><code>: ${HOSTNAME?} ${USER?} ${MAIL?}</code>这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 <code>test</code> 或<code>if</code>这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。<strong>(这个具体还没试验过)</strong></li><li>添加环境变量时需要使用<code>:</code>分割，比如<code>PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla</code></li></ul><h2 id="星号"><a href="#星号" class="headerlink" title="* 星号"></a>* 星号</h2><ul><li>在<code>文件名扩展(Filename expansion)</code>上，用来代表<strong>0到无穷多个任意字符</strong></li><li>在<code>正则表达式（Regular Expressions）</code>中，代表<strong>重复零个到无穷多个的<u>前一个字符</u></strong>，而代销<strong>0到无穷多个任意字符</strong>是使用<code>.*</code>。</li><li>在运算时，它则代表 “乘法”</li></ul><div class="note info"><p><code>*</code>在不同地方不同的用法需要注意，尤其是代表<strong>0到无穷多个任意字符</strong>、<strong>重复零个到无穷多个的<u>前一个字符</u></strong>这方面。</p></div><hr><h2 id="次方运算"><a href="#次方运算" class="headerlink" title="** 次方运算"></a>** 次方运算</h2><p>两个星号在运算时代表 “次方” 的意思。</p><hr><h2 id="和"><a href="#和" class="headerlink" title="$和$$"></a>$和$$</h2><ul><li>引用变量的前导符号，如<code>var=&quot;test&quot; echo $var</code></li><li>在正则表达式里被定义为<code>行的最末端 (end-of-line)</code>，这个常用在<code>grep</code>、<code>sed</code>、<code>awk</code> 以及 <code>vim(vi)</code> 当中</li><li>在bash中<code>$</code>本身也是个变量。代表的是<strong>目前这个shell的进程代码</strong>，即所谓的<code>PID（Process ID）</code><ul><li><code>$$</code> Shell本身的PID（ProcessID）</li><li><code>$!</code> Shell最后运行的后台Process的PID</li><li><code>$?</code> 最后运行的命令的结束代码（返回值），一般指令程序倘若执行成功，其回传值为 0，失败为 1。</li><li>其他参考<a href="https://www.cnblogs.com/chjbbs/p/6393935.html" target="_blank" rel="noopener">该博客</a></li></ul></li><li><mark><code>$</code>后接引号（单双引号），单引号可以使引号内的内容被特殊对待：会将某些反斜线序列(如<code>\n</code>，<code>\t</code>，<code>\&quot;</code>，<code>\&#39;</code>等)继续转义(<code>\t-&gt;tab</code>;<code>\n-&gt;换行</code>)，而不认为它是字面符号(如果没有<code>$</code>符号，单引号会强制将string翻译为字面符号，包括反斜线)；而双引号则没有上述效果，<code>$&quot;string&quot;</code>和<code>&quot;string&quot;</code>是完全等价的，使用<code>$&quot;&quot;</code>只是为了保证本地化</mark></li></ul><blockquote><p><code>echo &#39;a\nb&#39;</code><br>a\nb</p></blockquote><p>上述结果<strong>并没有和预期的一样在a、b之间进行换行</strong>，这是因为<strong>单引号中的<code>\n</code>被看成了字面意思，就是反斜线加上n</strong>，而不是特殊的换行的意思</p><p>如果在前面加上<code>$</code>：</p><blockquote><p><code>echo $&#39;a\nb&#39;</code><br>a<br>b</p></blockquote><p>这个结果和预期的一样，<strong>因为<code>$</code>将<code>\n</code>翻译成了换行</strong>，而不是单纯的反斜线加上n，这个在join命令指定分隔符时会用到，具体参考介绍<a href="http://showteeth.tech/posts/5579.html">join用法的文章</a></p><p>如果将上述单引号转换为双引号：</p><blockquote><p><code>echo $&quot;a\nb&quot;</code><br>a\nb</p></blockquote><p>发现在使用<strong>双引号</strong>的情况下，得到的结果<strong>和没使用<code>$</code>是一样的</strong>，这和前面说的<code>$&quot;string&quot;</code>和<code>&quot;string&quot;</code>是完全等价的是相符的。</p><p><strong>常见的需要注意使用<code>$</code>和单引号的转义字符包括</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\a    alert (bell)</span><br><span class="line">\b    backspace</span><br><span class="line">\e</span><br><span class="line">\E    an escape character</span><br><span class="line">\f    form feed</span><br><span class="line">\n    new line</span><br><span class="line">\r    carriage <span class="built_in">return</span></span><br><span class="line">\t    horizontal tab</span><br><span class="line">\v    vertical tab</span><br><span class="line">\\    backslash</span><br><span class="line">\<span class="string">'    single quote</span></span><br><span class="line"><span class="string">\"    double quote</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="问号"><a href="#问号" class="headerlink" title="? 问号"></a>? 问号</h2><ul><li>在<code>文件名扩展(Filename expansion)</code>上扮演的角色是<code>匹配一个任意的字符</code>，但不包含空字符，注意是<strong>一个字符，不能是0个也不能是两个</strong>，注意和正则表达式的用法区分。比如：<code>ls a?c.txt</code>可以得到abc.txt和amc.txt 但是不能得到abbc.txt，也不能得到ac.txt</li><li>在正则表达式式中，<code>?</code>表示匹配<strong>前面的字符0次或1次</strong>，<strong>不是任意字符</strong>，注意和文件名拓展的区分。<mark>同时在正则表达式中还可以用来表示非贪婪匹配</mark></li><li>在<code>bash</code>中，这个变量是<strong>上一个执行的命令所回传的值</strong>。当我们执行某些命令时，这些命令都会回传一个执行后的代码，一般说，<u>如果成功执行该命令，则会回传一个0值</u>，如果执行过程<u>发生错误</u>，就会回传错误代码，一般<u>以非0的数值来替代</u></li></ul><hr><h2 id="变量的正规表达式"><a href="#变量的正规表达式" class="headerlink" title="${} 变量的正规表达式"></a>${} 变量的正规表达式</h2><p>一般情况下，<code>$var</code>与<code>${var}</code>是没有区别的，但是用<code>${}</code>会<strong>比较精确的界定变量名称的范围</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个明确说明了var才是变量</span></span><br><span class="line"><span class="variable">$&#123;var&#125;</span>_suffix</span><br><span class="line"></span><br><span class="line"><span class="variable">$var_suffix</span></span><br></pre></td></tr></table></figure><h3 id="参数替换"><a href="#参数替换" class="headerlink" title="${} 参数替换"></a>${} 参数替换</h3><ul><li><code>${var_name}</code> 等价于<code>$var_name</code>（通常用这种简写方式）</li><li><code>$(var:-default)</code> 和 <code>$(var-default)</code><ul><li><code>$(var:-default)</code>：当<strong>var为空或未定义</strong>时<strong>整个表达式的值为default</strong></li><li><code>$(var-default)</code>：当且<strong>仅当var未定义</strong>时<strong>整个表达式的值为default</strong></li></ul></li><li><code>$(var:=default)</code> 和 <code>$(var=default)</code><ul><li><code>$(var:=default)</code>：当var<strong>为空或未定义</strong>时<strong>整个表达式的值为default</strong>，<strong>并且将var的值设置为default</strong></li><li><code>$(var=default)</code>：当且<strong>仅当var未定义</strong>时<strong>整个表达式的值为default</strong>，<strong>并且将var的值设置为default</strong></li></ul></li><li><code>$(var:?default)</code> 和 <code>$(var?message)</code><ul><li><code>$(var:?message)</code>：当var<strong>为空或未定义</strong>时，<strong>打印错误信息</strong>，信息内容为message表示的值</li><li><code>$(var?message)</code>：当且<strong>仅当var未定义</strong>时，<strong>打印错误信息</strong>，信息内容为message表示的值</li></ul></li><li><code>$(var:+default)</code> 和 <code>$(var+default)</code><ul><li><code>$(var:+default)</code>：当<strong>var已定义且不为空</strong>时整个表达式的值为default</li><li><code>$(var+default)</code>：当<strong>var已定义时</strong>整个表达式的值为default(<strong>不管var是否是空</strong>)</li></ul></li></ul><hr><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="${} 字符串截取"></a>${} 字符串截取</h3><ul><li><code>${str:offest}</code>：从下标<strong>offset(含)开始截取到末尾</strong>的子串</li><li><code>${str:offest:length}</code>：从<strong>下标offset(含)开始向后截取长度为length</strong>的子串，长度超出不报错</li><li><code>${str:offest:index}</code>：</li></ul><hr><h3 id="变量匹配"><a href="#变量匹配" class="headerlink" title="${} 变量匹配"></a>${} 变量匹配</h3><p><code>${!prefix*}</code>、<code>${!prefix@}</code>：将带有<strong>前缀为prefix的变量名打印</strong>出来</p><hr><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="${} 数组操作"></a>${} 数组操作</h3><ul><li><code>${!name[@]}</code>、<code>${!name[*]}</code>：将<strong>数组name的所有<code>下标</code></strong>返回，如果<em>变量name不是数组则返回0,不存在则空</em></li><li><code>${name[@]}</code>、<code>${name[*]}</code>：将<strong>数组name的所有<code>元素</code></strong>返回，如果<em>变量name不是数组则返回name的值,不存在则空</em></li><li><code>${\#name[@]}</code>、<code>${\#name[*]}</code>：返回<strong>数组元素总个数</strong></li><li><code>${name[index]}</code>：将<strong>数组name的index处的<code>元素</code></strong>返回，如果<em>变量name不是数组且index为0时返回name的值</em>，<em>变量或索引index处的元素不存在则返回空</em></li><li><code>${\#name[index]}</code>：返回<strong>数组name的index处的<code>元素长度</code></strong></li><li><code>name[index]=xyz</code>：<strong>数组name的index处的元素重新<code>赋值</code></strong></li></ul><div class="note info"><p>上面的<code>${\#name[@]}</code>中对<code>#</code>做了转义处理，不然博客可能报错，参考<a href="https://github.com/hexojs/hexo/issues/2904" target="_blank" rel="noopener">github issue</a>，正常情况下使用时不用加<code>\</code>进行转义。</p></div><hr><h3 id="正则匹配替换"><a href="#正则匹配替换" class="headerlink" title="${} 正则匹配替换"></a>${} 正则匹配替换</h3><ul><li><code>${parameter#word}</code>、<code>${parameter##word}</code>：<strong>从头开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>#</code>为<strong>最短</strong>匹配，<code>##</code>为<strong>最长</strong>匹配</li><li><code>${parameter%word}</code>、<code>${parameter%%word}</code>：<strong>从尾开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>%</code>为<strong>最短</strong>匹配，<code>%%</code>为<strong>最长</strong>匹配</li><li><code>${parameter/pattern/string}</code>、<code>${parameter//pattern/string}</code>：使用string替换pattern，<code>/</code>表示<strong>只替换一次</strong>；<code>//</code>表示<strong>全部替换</strong></li><li><code>${\#parameter}</code>：获取变量长度</li></ul><div class="note info"><p>上述的<code>parameter</code>都是可以不用引用的，因为<code>${var}</code>本来就和<code>$var</code>是一个意思</p></div><hr><h2 id="得到脚本变量"><a href="#得到脚本变量" class="headerlink" title="$* 得到脚本变量"></a>$* 得到脚本变量</h2><p><code>$*</code>引用script的执行引用变量，引用参数的算法与一般指令相同，<strong>script本身为0</strong>，其后第一个为1，然后依此类推。引用变量的代表方式如下：<code>$0</code>, <code>$1</code>, <code>$2</code>, <code>$3</code>, <code>${10}</code>, <code>${11}</code>，注意个位数的，可直接使用数字，但<strong>两位数以上，则必须使用 {} 符号来括住</strong>。</p><p><code>$*</code> 则是代表<strong>所有引用变量</strong>的符号，使用时得视情况加上双引号，如<code>echo &quot;$*&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash example.sh var1 var2 var3</span><br><span class="line"><span class="comment"># $0是example.sh、$1是var1、$2是var2、$3是var3</span></span><br></pre></td></tr></table></figure><hr><h2 id="得到脚本变量-1"><a href="#得到脚本变量-1" class="headerlink" title="$@ 得到脚本变量"></a>$@ 得到脚本变量</h2><ul><li><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的<strong>所有参数</strong>，<strong>不被双引号(“ “)包含时</strong>，都以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> … <code>&quot;$n&quot;</code> 的形式输出所有参数</li><li>但是<strong>当它们被双引号(“ “)包含时</strong>，<code>&quot;$*&quot;</code> 会将<strong>所有的参数作为一个整体</strong>，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> … <code>&quot;$n&quot;</code> 的形式输出所有参数</li><li>也就是说<code>$@</code>不管有没有被双引号包围，其输出结果<strong>都是单个的变量形式</strong>，而<code>$*</code>在<strong>不被双引号</strong>包围时输出<strong>单个变量的形式</strong>，<strong>被双引号包围</strong>时，所有的参数<strong>以整体的形式输出</strong></li></ul><hr><h2 id="变量总数"><a href="#变量总数" class="headerlink" title="$# 变量总数"></a>$# 变量总数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出变量总数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="与declare-i-整数运算"><a href="#与declare-i-整数运算" class="headerlink" title="$(())与declare -i 整数运算"></a>$(())与declare -i 整数运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i total=<span class="variable">$firstnu</span>*<span class="variable">$secnu</span></span><br><span class="line">total=$((<span class="variable">$firstnu</span>*<span class="variable">$secnu</span>))</span><br></pre></td></tr></table></figure><p>区别就是小方括号内可以加上空格符，也是合法的写法，而declare -i 不可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2*3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2* 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错</span></span><br><span class="line">total=$((2*3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取</span></span><br><span class="line">a=5;b=7;c=2</span><br><span class="line"><span class="built_in">echo</span> $((a+b*c))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>+<span class="variable">$b</span>*<span class="variable">$c</span>))</span><br></pre></td></tr></table></figure><p><code>declare -i</code>加空格报错：</p><blockquote><p>bash: declare: 2<em>: syntax error: operand expected (error token is “</em>“)</p></blockquote><p><code>$(())</code>在等号左右加空格报错：</p><blockquote><p>bash: 6: command not found</p></blockquote><p><strong><code>$(())</code>进制转化：将其他进制转成十进制数显示出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值</span></span><br><span class="line"><span class="built_in">echo</span> $((N<span class="comment">#xx))</span></span><br></pre></td></tr></table></figure><hr><h2 id="执行计算"><a href="#执行计算" class="headerlink" title="((  )) 执行计算"></a>(( )) 执行计算</h2><p>和linux<code>let</code>指令相似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=5;b=7</span><br><span class="line">((a--));<span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;5;i++));<span class="keyword">do</span> <span class="built_in">echo</span>  <span class="variable">$i</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h2 id="指令群组"><a href="#指令群组" class="headerlink" title="(  ) 指令群组"></a>( ) 指令群组</h2><p>用括号将一串连续指令括起来，这被称为指令群组</p><p>指令群组有一个特性，shell会以产生subshell来执行这组指令，因此，在<strong>指令群组所定义的变量，仅作用于指令群组本身</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"test"</span></span><br><span class="line">(<span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>);<span class="built_in">echo</span> <span class="variable">$test</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>/home/usr<br>test</p></blockquote><p><strong><code>( )</code>也可被用于数组的声明中：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array=(element1 element2 element3)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="大括号"><a href="#大括号" class="headerlink" title="{ } 大括号"></a>{ } 大括号</h2><h3 id="作为代码块"><a href="#作为代码块" class="headerlink" title="作为代码块"></a>作为代码块</h3><p><strong>代码块</strong>，又被称为内部组，这个结构事实上创建了一个<strong>匿名函数</strong>。与上面小括号中的指令群组不同，花括号内的命令不会新开一个子shell运行，即<strong>脚本余下部分仍可使用括号内变量</strong>，因此，这样写 script也是相当好的一件事。尤其对<em>输出输入的重导向</em>上，这个做法可<strong>精简 script 的复杂度</strong>。括号内的<strong>命令间用分号隔开</strong>，<strong>最后一个也必须有分号</strong>。<strong><code>{}</code>的第一个命令和左括号之间必须要有一个空格</strong>。</p><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个命令和左括号之间没有空格</span></span><br><span class="line">&#123;<span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一个命令没有分号</span></span><br><span class="line">&#123; <span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确用法</span></span><br><span class="line">&#123; <span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>;&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>第一个命令和左括号之间没有空格</strong>报错：</p><blockquote><p>bash: {cd: command not found<br>/home/user/test}<br>/home/user/test</p></blockquote><p><strong>最后一个命令没有分号</strong>报错：</p><blockquote><p>> ^C</p></blockquote><p>正确输出：</p><blockquote><p>/home/user<br>/home/user</p></blockquote><h3 id="作为拓展"><a href="#作为拓展" class="headerlink" title="作为拓展"></a>作为拓展</h3><p>通配(globbing)将<strong>对花括号中的文件名做扩展</strong>。在大括号中，<strong>不允许有空白</strong>，<strong>除非</strong>这个空白被引用或转义。</p><ul><li>对大括号中的以逗号分割的<strong>文件列表进行拓展</strong>。如 <code>touch {a,b}.txt</code> 结果为<code>a.txt</code> <code>b.txt</code></li><li>对大括号中以点点<code>（..）</code>分割的<strong>顺序文件列表起拓展作用</strong>，如：<code>touch {a..d}.txt</code> 结果为<code>a.txt</code> <code>b.txt</code> <code>c.txt</code> <code>d.txt</code></li><li>对大括号中以点点<code>（..）</code>分割的<strong>顺序文件列表起拓展作用</strong>，如 <code>for i in {1..2};do echo $i;done</code> 结果为<code>1</code> <code>2</code></li></ul><h3 id="进行组合"><a href="#进行组合" class="headerlink" title="进行组合"></a>进行组合</h3><p>大括号<code>{}</code>里面的内容以<strong>逗号分隔</strong>，两个或多个大括号内的内容进行组合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3x3的组合，中间的短横线是分割线，可以自定义</span></span><br><span class="line">mkdir &#123;userA,userB,userC&#125;-&#123;home,bin,data&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行嵌套使用</span></span><br><span class="line">chown root /usr/&#123;ucb/&#123;ex,edit&#125;,lib/&#123;ex?.?*,how_ex&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="中括号"><a href="#中括号" class="headerlink" title="[ ] 中括号"></a>[ ] 中括号</h2><ul><li>在<strong>通配符和正则表达式</strong>中<code>[]</code>代表一定有一个在中括号内的字符，例如<code>[abcd]</code>代表一定有一个字符，可能是a、b、c、d这四个任何一个，<code>[num1-num2]</code>表示范围、<code>[^]</code>表示非</li><li><strong>流程控制</strong>中，扮演括住判断式的作用，<code>[]</code>中可用的比较运算符只有<code>==</code>和<code>!=</code>，两者<strong>都是用于字符串比较的</strong>，<strong>不可用于整数比较</strong>，<strong>整数比较只能使用<code>-eq</code>，<code>-gt</code>这种形式</strong>。无论是字符串比较还是整数比较<strong>都不支持大于号小于号</strong>。如果实在想用，对于字符串比较可以使用<strong>转义形式</strong>，如果比较<code>&quot;ab&quot;</code>和<code>&quot;bc&quot;</code>：<code>[ ab &lt; bc ]</code>，结果为真，也就是返回状态为0。<strong><code>[ ]</code>中的逻辑与和逻辑或使用-a 和-o 表示</strong></li><li>在一个array结构的上下文中，中括号用来引用数组的索引</li></ul><hr><h2 id="双中括号"><a href="#双中括号" class="headerlink" title="[[  ]] 双中括号"></a>[[ ]] 双中括号</h2><ul><li>这组符号与先前的 <code>[]</code> 符号，基本上作用相同，但是<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code>和<code>&gt;</code> 操作符能够正常存在于<code>[[ ]]</code>条件判断结构中，但是如果出现在<code>[ ]</code>结构中的话，会报错。</li><li><strong>支持字符串的模式匹配</strong>，使用<code>=~</code>操作符时甚至支持shell的<strong>正则表达式</strong>，字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如<code>[[ hello == hell? ]]</code>，结果为真。<strong><code>[[ ]]</code>中匹配字符串或通配符，不需要引号</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># [[ 2\&lt;3 ]] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ 2 -lt 3 ]] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ 2 \&lt; 3 ]] &amp;&amp; echo true || false</span></span><br><span class="line">-bash: 期待二元条件运算符</span><br><span class="line">-bash: `\&lt;<span class="string">' 附近有语法错误，这是因为空格的原因</span></span><br><span class="line"><span class="string">[root@localhost ~]# [ 2 \&lt; 3 ] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="string">true</span></span><br><span class="line"><span class="string">[root@localhost ~]# [ 2 &lt; 3 ] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="string">-bash: 3: 没有那个文件或目录</span></span><br></pre></td></tr></table></figure><hr><h2 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="|| 逻辑符号"></a>|| 逻辑符号</h2><p>在中括号中<code>[]</code>代表 <code>or</code> 逻辑的符号</p><p>在命令行中：<br><code>cmd1||cmd2</code><br>若<strong>cmd1执行完毕且正确执行($?=0)</strong>，则cmd2<strong>不执行</strong><br>若<strong>cmd1执行完毕且为错误($?≠0)</strong>，则开始<strong>执行cmd2</strong></p><hr><h2 id="amp-amp-逻辑符号"><a href="#amp-amp-逻辑符号" class="headerlink" title="&amp;&amp; 逻辑符号"></a>&amp;&amp; 逻辑符号</h2><p>在中括号中<code>[]</code>代表 <code>and</code> 逻辑的符号</p><p>在命令行中如下:<br><code>cmd1&amp;&amp;cmd2</code><br>若<strong>cmd1执行完毕且正确执行（$?=0）</strong>,则<strong>开始执行cmd2</strong><br>若<strong>cmd1执行完毕且为错误（$?≠0）</strong>，则<strong>cmd2不执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果./symbol/abc目录不存在则创建这个目录，成功后在目录下创建hehe文件</span></span><br><span class="line">ls ./symbol/abc || mkdir  ./symbol/abc &amp;&amp; touch ./symbol/abc/hehe</span><br></pre></td></tr></table></figure><blockquote><p>目录不存在，ls的报错信息<br>ls: cannot access ./symbol/abc: No such file or directory</p></blockquote><hr><h2 id="lt-…-gt-单字边界"><a href="#lt-…-gt-单字边界" class="headerlink" title="\&lt;…\&gt; 单字边界"></a>\&lt;…\&gt; 单字边界</h2><p>这组符号在规则表达式中，被定义为”边界”的意思。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除能完整匹配This这个单词的行</span></span><br><span class="line">sed <span class="string">'/\&lt;This\&gt;/d'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="文件操作符合输出-输入重定向"><a href="#文件操作符合输出-输入重定向" class="headerlink" title="文件操作符合输出/输入重定向"></a>文件操作符合输出/输入重定向</h2><ul><li><code>&gt;</code>：表示重定向</li><li><code>&amp;</code>：表示等同于的意思</li><li>文件描述符是和文件的输入、输出相关联的非负整数，Linux内核（kernel）利用文件描述符（file descriptor）来访问文件。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。常见的文件描述符是stdin、stdout和stderr。</li></ul><p><strong>常用的文件描述符如下：</strong></p><table><thead><tr><th>文件描述符</th><th>名称</th><th>常用缩写</th><th>默认值</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td>stdin</td><td>键盘</td></tr><tr><td>1</td><td>标准输出</td><td>stdout</td><td>屏幕</td></tr><tr><td>2</td><td>标准错误输出</td><td>stderr</td><td>屏幕</td></tr></tbody></table><p><strong>在简单地用<code>&lt;</code>或<code>&gt;</code>时，相当于使用 <code>0&lt;</code> 或 <code>1&gt;</code>，注意文件描述符和重定向符号之间不能存在空格，同时也可以将<code>&gt;</code>改为<code>&gt;&gt;</code>追加而不是覆盖文本信息</strong></p><ul><li><code>cmd &gt; file</code>等同于<code>cmd 1&gt; file</code>：把cmd命令的<strong>输出重定向到文件file中</strong>，如果file已经存在，则<strong>覆盖原有文件</strong></li><li><code>cmd &gt;&gt; file</code>等同于<code>cmd 1&gt;&gt; file</code>：把cmd命令的<strong>输出重定向到文件file中</strong>，如果file已经存在，则把信息<strong>加在原有文件后面</strong></li><li><code>cmd &lt; file</code>等同于<code>cmd 0&lt; file</code>：使cmd命令从<strong>file</strong>读入，<strong>必须是文件</strong>，不能是字符</li><li><code>cmd &lt;&lt; text</code>等同于<code>cmd 0&lt;&lt; text</code>：从命令行读取输入，直到一个与text字符相同的行结束</li><li><code>cmd 2&gt; file</code>：把cmd命令的<strong>标准错误输出重定向到文件file中</strong>，如果file已经存在，则<strong>覆盖原有文件</strong></li><li><code>cmd 2&gt;&gt; file</code>：把cmd命令的<strong>标准错误输出重定向到文件file中</strong>，如果file已经存在，则把信息<strong>加在原有文件后面</strong></li><li><code>cmd &gt;&amp;n</code>等同于<code>cmd 1&gt;&amp;n</code>：把输出重定向到文件描述符n，通过对<code>&amp;</code>的解读：标准输出的重定向等同于文件描述符n</li><li><code>cmd m&gt;&amp;n</code> ：把输出到文件符m的信息重定向到文件描述符n</li></ul><p><strong>从命令行读取输入：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; wang &gt; haha.txt</span><br></pre></td></tr></table></figure><p></p><p>从命令行得到输入，直到出现<code>wang</code>为止</p><blockquote><p><code>cat &lt;&lt; wang &gt;haha.txt</code><br>> test<br>> test2<br>> wang</p></blockquote><ul><li><code>cmd &lt;&lt;&lt; word</code>：将word(字符)，注意不是上面的file读入</li></ul><p><strong>标准错误输出：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># test.file不存在，没有任何错误提示，正常运行</span></span><br><span class="line">cat test.file 2&gt; out.txt  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 与上面的方法结果相同，错误的信息都被输入到了out.txt中</span></span><br><span class="line">cat test.file &amp;&gt; out.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将错误输出丢弃到/dev/null中，/dev/null是一个特殊的设备文件，这个文件接受到任何数据都会被丢系，通常被称为位桶、黑洞</span></span><br><span class="line">cat test.file  2&gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将标准输出重定向大list.txt文件中，标准错误输出重定向到list.err文件中</span></span><br><span class="line">cat test.file  1&gt; list.txt   2&gt; list.err</span><br></pre></td></tr></table></figure><p><strong>将标准错误stderr与stdout一同重定向到test.log文件:</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将标准输出重定向到test.log中，然后文件描述符2（标准错误输出）的重定向等同于文件描述符1（标准输出）</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>文件描述符支持自定义，<a href="http://man.linuxde.net/shell-script/shell-2" target="_blank" rel="noopener">参考文章</a></p></div><hr><p><br></p><h2 id="实战总结："><a href="#实战总结：" class="headerlink" title="实战总结："></a>实战总结：</h2><h3 id="得到数字用于循环的方法汇总"><a href="#得到数字用于循环的方法汇总" class="headerlink" title="得到数字用于循环的方法汇总"></a>得到数字用于循环的方法汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5);<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++));<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; ;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.chinaunix.net/uid-16946891-id-5088144.html" target="_blank" rel="noopener">linux 特殊符号大全</a></li><li><a href="https://www.cnblogs.com/dirt2/p/5991033.html" target="_blank" rel="noopener">Linux命令中特殊符号，排版更好看</a></li><li><a href="https://www.jianshu.com/p/986e88819441" target="_blank" rel="noopener">Linux中的特殊符号及含义</a></li><li><a href="http://www.178linux.com/35067" target="_blank" rel="noopener">linux中特殊符号用法</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Linux常见特殊符号作用，包括&lt;code&gt;#&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;~+&lt;/code&gt;、&lt;code&gt;~-&lt;/code&gt;、&lt;code&gt;;&lt;/code&gt;、&lt;code&gt;;;&lt;/code&gt;、&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;&amp;#39;&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;、&lt;code&gt;`&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;\&lt;/code&gt;、&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;!&lt;/code&gt;、&lt;code&gt;:&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;**&lt;/code&gt;、&lt;code&gt;$&lt;/code&gt;、&lt;code&gt;$$&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;${}&lt;/code&gt;、&lt;code&gt;$*&lt;/code&gt;、&lt;code&gt;$@&lt;/code&gt;、&lt;code&gt;$#&lt;/code&gt;、&lt;code&gt;$(())&lt;/code&gt;、&lt;code&gt;(())&lt;/code&gt;、&lt;code&gt;()&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;、&lt;code&gt;[[]]&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt; 、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;\&amp;lt;...\&amp;gt;&lt;/code&gt;和文件操作符以及重定向。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="Linux特殊符号用法" scheme="http://showteeth.tech/tags/Linux%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日总结和计划</title>
    <link href="http://showteeth.tech/posts/51961.html"/>
    <id>http://showteeth.tech/posts/51961.html</id>
    <published>2019-02-24T13:20:17.000Z</published>
    <updated>2019-03-04T15:26:42.355Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>2019-2-24开始的每日学习总结与计划</p></div><a id="more"></a><style type="text/css">.tg{border-collapse:collapse;border-spacing:0;border-color:#999}.tg td{font-family:Arial,sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#f7fdfa}.tg th{font-family:Arial,sans-serif;font-size:14px;font-weight:400;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ade4}.tg .tg-phtq{background-color:#d2e4fc;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-hmp3{background-color:#d2e4fc;text-align:left;vertical-align:top}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><h2 id="2019-2-24"><a href="#2019-2-24" class="headerlink" title="2019-2-24"></a>2019-2-24</h2><h3 id="今日学习完成情况"><a href="#今日学习完成情况" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sed</td><td class="tg-phtq">学习了基本语法、掌握了选项i、n、e、f以及命令s、p、g</td><td class="tg-hmp3">2小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">markdown</td><td class="tg-0pky">完成了markdown基本语法的学习</td><td class="tg-0lax">3个小时</td></tr></table><div class="note success"><p>今日学习情况总结：首先是学习了markdown基本语法，收获了很多，比如html块元素是必须要进行留空白行的、有序列表前的数字不关键、创建表格以及进行相应的优化（还不够完善）等新内容；也开始学习了linux基本命令sed，对其使用有了基本的了解，明天还要接着学习！</p></div><hr><h3 id="明日学习哪些内容"><a href="#明日学习哪些内容" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>markdown表格的优化（宽度调整）</li><li>shell中特殊符号的学习</li><li>sed命令的学习</li></ul></div><hr><p><br></p><h2 id="2019-2-25"><a href="#2019-2-25" class="headerlink" title="2019-2-25"></a>2019-2-25</h2><h3 id="今日学习完成情况-1"><a href="#今日学习完成情况-1" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sed</td><td class="tg-phtq">完成了sed的学习</td><td class="tg-hmp3">大概3个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是完成了sed命令的学习，学习过程中发现sed和之前学的其他命令如awk、grep等有很多相似之处，有了之前的基础学起来更加容易理解，果然是学的越多学得越快！！！通过对sed命令的学习，在以后处理文本时就又增加了一个非常有力的工具！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-1"><a href="#明日学习哪些内容-1" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>shell中特殊符号的处理</del></li><li><del>markdown表格的优化（宽度调整）</del>~</li><li>sort排序命令</li></ul></div><hr><p><br></p><h2 id="2019-2-26"><a href="#2019-2-26" class="headerlink" title="2019-2-26"></a>2019-2-26</h2><h3 id="今日学习完成情况-2"><a href="#今日学习完成情况-2" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">其他一些常用内容总结</td><td class="tg-phtq">Linux中特殊符号用法</td><td class="tg-hmp3">大概4个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">markdown基本语法</td><td class="tg-0pky">表格优化-单元格宽度自定义</td><td class="tg-0lax">大概30分钟</td></tr></table><div class="note success"><p>今日学习情况总结：主要学习和总结了linux中很多特殊的符号的常见用法，加强了对前面学习知识的理解与认知，如sed命令中出现变量引用需要将单引号修改为双引号在这里就找到了答案，同时这也是普适的用法，因为<strong>单引号防止任何变量替换</strong>，而<strong>双引号恰好可以允许变量替换</strong>，同时还有很多提高脚本效率的知识，并且觉得这部分内容比较杂（需要不断更新和回顾），但是很重要，如果很多符号的含义不清楚，后面学习其他命令很容易迷糊和犯错。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-2"><a href="#明日学习哪些内容-2" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>sort排序命令</del></li><li><del>整理字符串截取和浮点计算并保留小数的方法</del></li></ul></div><hr><p><br></p><h2 id="2019-2-27"><a href="#2019-2-27" class="headerlink" title="2019-2-27"></a>2019-2-27</h2><h3 id="今日学习完成情况-3"><a href="#今日学习完成情况-3" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sort、其他一些常用内容总结</td><td class="tg-phtq">完成了sort命令学习、字符串截取方法和浮点计算并保留小数</td><td class="tg-hmp3">大概5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了sort命令的使用，对其中的-k参数进行了深刻的理解，同时学习到了一些实战用法也很实用！同时也温习和补充了之前学习的字符串截取方法和浮点计算并保留小数内容。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-3"><a href="#明日学习哪些内容-3" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>uniq、join</del>、cut</li><li>单行命令嵌套</li><li>准备学习李航老师的机器学习内容</li><li><del>安装并使用pdf2htmlex</del></li></ul></div><hr><p><br></p><h2 id="2019-2-28"><a href="#2019-2-28" class="headerlink" title="2019-2-28"></a>2019-2-28</h2><h3 id="今日学习完成情况-4"><a href="#今日学习完成情况-4" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">完成了join命令、uniq命令学习、开始了cut命令学习</td><td class="tg-hmp3">大概5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了几个非常使用的命令，完成了uniq、join还有开始了大部分的cut命令学习，这些都是非常常用的命令，平常都有使用，但是掌握不够完善，这里系统的学习有助于后续应用同时也可以当做笔记查询。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-4"><a href="#明日学习哪些内容-4" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>继续学习cut</del></li><li>~单行命令嵌套~</li><li>准备学习李航老师的机器学习内容</li><li>~完成研究~</li></ul></div><hr><p><br></p><h2 id="2019-3-1"><a href="#2019-3-1" class="headerlink" title="2019-3-1"></a>2019-3-1</h2><h3 id="今日学习完成情况-5"><a href="#今日学习完成情况-5" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令、其他一些常用内容总结</td><td class="tg-phtq">完成了cut命令学习、总结了位、字节、字符和编码、单行命令嵌套</td><td class="tg-hmp3">大概5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：完成了cut命令学习、总结了位、字节、字符和编码、单行命令嵌套等相关内容</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-5"><a href="#明日学习哪些内容-5" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>继续学习cut</del></li><li><del>单行命令嵌套</del></li><li>准备学习李航老师的机器学习内容</li><li><del>完成研究</del></li></ul></div><hr><p><br></p><h2 id="2019-3-2"><a href="#2019-3-2" class="headerlink" title="2019-3-2"></a>2019-3-2</h2><h3 id="今日学习完成情况-6"><a href="#今日学习完成情况-6" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">其他一些常用内容总结</td><td class="tg-phtq">监控脚本运行脚本</td><td class="tg-hmp3">大概3个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要在进行研究，完善之前的脚本，同时还整理了一下关于后台脚本监控相关内容，这个非常实用！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-6"><a href="#明日学习哪些内容-6" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>准备学习李航老师的机器学习内容</li><li><del>完成研究</del></li><li><del>整理lncRNA分析流程</del></li><li><del>将脚本监控上传到github</del></li></ul></div><hr><p><br></p><h2 id="2019-3-3"><a href="#2019-3-3" class="headerlink" title="2019-3-3"></a>2019-3-3</h2><h3 id="今日学习完成情况-7"><a href="#今日学习完成情况-7" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用工具整理</td><td class="tg-0pky">jupyter notebook优化-主题和插件</td><td class="tg-0lax">大概3个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky">coding_pages使用</td><td class="tg-0pky">coding_pages使用以及mkdocs</td><td class="tg-0lax">大概1个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天完成了研究内容，同时对jupyter notebook进行了相应的优化并且也开通了coding pages，准备将projects转移过去。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-7"><a href="#明日学习哪些内容-7" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>准备学习李航老师的机器学习内容</li><li>整理研究结果，形成文档给师兄看看</li><li><del>整理lncRNA分析流程</del></li><li><del>将脚本监控上传到github</del></li></ul></div><hr><p><br></p><h2 id="2019-3-4"><a href="#2019-3-4" class="headerlink" title="2019-3-4"></a>2019-3-4</h2><h3 id="今日学习完成情况-8"><a href="#今日学习完成情况-8" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky">coding_pages以及mkdocs使用、PDF转HTML-pdf2htmlex</td><td class="tg-0pky">coding_pages使用以及mkdocs、PDF转HTML-pdf2htmlex</td><td class="tg-0lax">大概3个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天对lncRNA的分析步骤进行了一定的整理(发现事后去整理分析步骤真的很难受，所以以后还是在边分析边整理比较好)；搭建了基于mkdocs的项目管理系统；将后台程序监控脚本上传到了github</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-8"><a href="#明日学习哪些内容-8" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>准备学习李航老师的机器学习内容</li><li>整理研究结果，形成文档给师兄看看</li><li>coding pages搭建好</li></ul></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;2019-2-24开始的每日学习总结与计划&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="规划" scheme="http://showteeth.tech/categories/%E8%A7%84%E5%88%92/"/>
    
    
      <category term="每日总结和计划" scheme="http://showteeth.tech/tags/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93%E5%92%8C%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>markdown基础语法</title>
    <link href="http://showteeth.tech/posts/65136.html"/>
    <id>http://showteeth.tech/posts/65136.html</id>
    <published>2019-02-24T04:09:11.000Z</published>
    <updated>2019-02-27T12:27:53.785Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结markdown基础语法，便于后续查找和使用。<a href="http://showteeth.tech/posts/37746.html">另有一篇next-markdown技巧和模板</a>总结了博客写作中常用的markdown技巧和模板，有些并不是原生的markdown语法，但是写作效果很好看，需要的时候可以查阅这个。</p></div><a id="more"></a><h2 id="markdown特性"><a href="#markdown特性" class="headerlink" title="markdown特性"></a>markdown特性</h2><ul><li>Markdown 的目标是实现<strong>易读易写</strong></li><li><strong>兼容HTML</strong>，不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了，不过<em>有一些标签需要特殊注意</em></li><li><strong>特殊字符转换</strong>：特殊字符如HTML中需要特殊处理的字符<code>&lt;</code>和<code>&amp;</code>，在非代码单位内，markdown会将其自动转化为<code>&amp;lt;</code> 和 <code>&amp;amp;</code>这种实体的形式（虽然在markdown中看不到，但是实际上在生成html时markdown自动将其转化为上述实体的形式），但是在code 范围内，不论是行内还是区块， <code>&lt;</code>和 <code>&amp;</code> 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code。附上<a href="http://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">HTML 中有用的字符实体</a></li></ul><div class="note warning"><ul><li>在markdown使用HTML标签<mark>需要特殊注意的是 HTML 的区块元素</mark>，比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在<strong>前后加上空行</strong>与其它内容区隔开，还要求它们的<strong>开始标签与结尾标签不能用制表符或空格来缩进</strong>;Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上<em>不必要</em>的 <code>&lt;p&gt;</code> 标签</li><li>HTML 区块标签间的 Markdown 格式语法将<strong>不会被处理</strong>，如<code>&lt;p&gt;这是**一个**测试&lt;/p&gt;</code>中一个不会加粗显示</li><li>HTML 的行内标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用</li><li>与处在 HTML 区块标签间不同，<strong>Markdown 语法在 HTML 行内标签间是有效的</strong></li></ul></div><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h3><h4 id="换行和段落"><a href="#换行和段落" class="headerlink" title="换行和段落"></a>换行和段落</h4><p>在markdown中进行<strong>换行</strong>操作：一行<strong>文本末尾增加两个以上的空格然后回车</strong>，如果<strong>只使用回车，不添加或者没加够空格看上去两行的文字会变为一行</strong>。</p><p>markdown<strong>区分段落的关键</strong>是：这两行文字之间<strong>是否有空行</strong>，空行的定义是显示上看起来像是空的，便会被视为空行。比如，若某一行<strong>只包含空格和制表符，则该行也会被视为空行</strong>。如果这两行文字之间有空行，就代表这两行文字为两个段落，如果这两行文字之间没有空行，仅仅使用另个以上空格加回车进行换行，这两行文字仍旧是属于同一个段落。</p><div class="note info"><ul><li>得到空行的方法：在上一行<strong>文本末尾加上两个以上空格然后回车</strong>，<strong>再加上<code>&lt;br /&gt;</code>即可</strong></li><li>两个段落之间有一个空行就可以证明其为两个段落，再多的空行也不会在html中渲染（上述添加<code>&lt;br /&gt;</code>制造空行的方式除外，增加几个<code>&lt;br /&gt;</code>就会有几个空行）。</li></ul></div><hr><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>markdown依据<code>#</code>的数量，支持六级的标题，一个<code>#</code>代表一级标题，<strong>用于标题的<code>#</code>数目最多为6个</strong>，当数目<strong>大于6个时不再以标题的形式显现</strong>，如<code>####### 7</code>将直接显示为####### 7，而不是以标题的形式。<br><br><br>当然也可以选择闭合标题的<code>#</code>，在标题之后加上若干数目的<code>#</code>，标题的级别是依据标题之前的<code>#</code>数目决定，和之后的<code>#</code>数目无关。如<code># 1 ##########</code>还是代表的1级标题。</p><hr><h4 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h4><ul><li>markdown使用<code>&gt;</code>进行引用</li><li><strong>段落内多行一同进行区块引用</strong>可以在每一行之前都加上<code>&gt;</code>，也可以进行偷懒，在整个<strong>段落</strong>的第一行加上<code>&gt;</code>引用一整行</li><li>引用可以进行<strong>嵌套</strong>，如加两个&gt;&gt;三个&gt;&gt;&gt;</li></ul><blockquote><p>这是一句引用</p><blockquote><p>这也是一个引用</p><blockquote><p>当然，这个还是一个引用</p></blockquote></blockquote></blockquote><ul><li>使用blockquotes标签进行引用，可以修改文字颜色以及左边框颜色。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">"color:red;border-left: 3px solid #F44336;"</span>&gt;</span>使用blockquotes标签进行引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><blockquote style="color:red;border-left:3px solid #f44336">使用blockquotes标签进行引用</blockquote><ul><li>引用的<strong>区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; #### 这是一个标题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1.   这是第一行列表项</span><br><span class="line">&gt; 2.   这是第二行列表项</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">"color:red;border-left: 3px solid #F44336;"</span>&gt;</span>使用blockquotes标签进行引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">&gt; **引用**结束</span><br></pre></td></tr></table></figure><hr><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>markdown支持<strong>有序列表</strong>和<strong>无序列表</strong>。</p><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表使用<strong>星号</strong>、<strong>加号</strong>或是<strong>减号</strong>作为列表标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>有序列表则使用<strong>数字接着一个英文句点</strong>作为列表标记。值得注意的是有序列表<mark>中英文句号前面的数字并不重要</mark>，也就是说<strong>可以是完全相同或者不连续的数字</strong>，这些都不会影响最终解析得到的html信息，<strong>得到的结果都是相同的</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br></pre></td></tr></table></figure><h5 id="多级列表"><a href="#多级列表" class="headerlink" title="多级列表"></a>多级列表</h5><p>多级列表的产生：先得到一级列表，然后使用<code>tab键</code>将后续的列表依次缩进即可得到多级列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* this is a test </span><br><span class="line">  * this is a test </span><br><span class="line">    * this is a test</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><ul><li>this is a test<ul><li>this is a test<ul><li>this is a test</li></ul></li></ul></li></ul><h5 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h5><p>列表项目<strong>可以包含多个段落</strong>，每个项目下的段落都<strong>必须缩进 4 个空格或是 1 个制表符</strong>。</p><p>段落的<strong>每一行都可以进行缩进</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span><br><span class="line">    mi posuere lectus.</span><br><span class="line"></span><br><span class="line">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span><br><span class="line">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span><br><span class="line">    sit amet velit.</span><br><span class="line"></span><br><span class="line">2.  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ol><li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p><p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p></li><li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li></ol><p>当然也支持<strong>只对段落首行进行缩进</strong>，和上面的段落每行都缩进结果是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line">    This is the second paragraph in the list item. You're</span><br><span class="line">only required to indent the first line. Lorem ipsum dolor</span><br><span class="line">sit amet, consectetuer adipiscing elit.</span><br><span class="line"></span><br><span class="line">*   Another item in the same list.</span><br></pre></td></tr></table></figure><h5 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h5><p>如果要在<strong>列表项目内放进引用</strong>，那 <code>&gt;</code> 就需要缩进：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line">    &gt; This is a blockquote</span><br><span class="line">    &gt; inside a list item.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><p>A list item with a blockquote:</p><blockquote><p>This is a blockquote<br>inside a list item.</p></blockquote></li></ul><h5 id="包含代码块的列表"><a href="#包含代码块的列表" class="headerlink" title="包含代码块的列表"></a>包含代码块的列表</h5><p>如果要<strong>放代码块</strong>的话，该代码块就需要缩进两次，也<strong>就是 8 个空格或是 2 个制表符</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   一列表项包含一个列表区块：</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">代码写在这</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note warning"><ul><li>如果在<strong>行首出现数字-句点-空白</strong>，可能会误认为是有序列表，要避免这样的状况，你可以在句点前面加上<strong>反斜杠</strong>，如1986. What a great season.</li><li>标记后面最少有一个<strong>空格</strong>或<strong>制表符</strong></li><li><mark>必须和前后文本存在空行</mark>，不然列表可能<strong>不能正确解析</strong>以及后面的文本可能<strong>出现偏移</strong>。</li></ul></div><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h5 id="使用markdown原生的方式插入表格"><a href="#使用markdown原生的方式插入表格" class="headerlink" title="使用markdown原生的方式插入表格"></a>使用markdown原生的方式插入表格</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td><em>短文本</em></td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><div class="note warning"><ul><li>表格的语句<mark>上一行必须为空行</mark>，不然表格不生效;</li><li>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;</li><li>-的数量至少有一个;</li><li>|、-、:之间的多余空格会被忽略，不影响布局;</li><li>表格内容中可以套用其他用法，如加粗、斜体等；</li><li><mark>直接在markdown原生表格之前添加html样式（style）也可以对表格样式进行修改</mark>。</li></ul></div><h5 id="设置表格宽度自适应"><a href="#设置表格宽度自适应" class="headerlink" title="设置表格宽度自适应"></a>设置表格宽度自适应</h5><p>解决了按照<strong>第一列表头宽度进行自适应</strong>的问题：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table th:first-of-type &#123;</span></span><br><span class="line"><span class="undefined">width: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>为每一列单独设置宽度：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">35%</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">45%</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span>第四列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>第一列占整个表格宽度的10%、第二列占35%、第三列占45%、第四列占10%。</p><div class="note warning"><ul><li><code>th:first-of-type</code> 的意思是每个 <code>&lt;th&gt;</code> 为其父级的<strong>第一个元素</strong>，就是指第一列的表头，同理第二、三个使用 <code>th:nth-of-type(2)</code>、<code>th:nth-of-type(3)</code></li><li>修改表头的宽度表头对应的列的宽度也就得到了修改</li><li>这里有一篇关于markdown表格样式优化的<a href="https://www.tuicool.com/articles/mueEZjr" target="_blank" rel="noopener">文章</a>，包括<code>鼠标悬停变色</code>、<code>表格滚动条</code>、<code>隔行变色</code>、<code>表头不换行</code>和<code>首列不换行</code>等优化</li><li><strong>excel也能导出html</strong>，先在excel中创建表格，然后保存为html，最后复制其中的表格，<a href="https://blog.csdn.net/sunbocong/article/details/81033915" target="_blank" rel="noopener">参考文章</a></li></ul></div><h5 id="表格对齐问题"><a href="#表格对齐问题" class="headerlink" title="表格对齐问题"></a>表格对齐问题</h5><ul><li>-:表示内容和标题栏居右对齐；</li><li>:-表示内容和标题栏居左对齐；</li><li>:-:表示内容和标题栏居中对齐；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| :------ | :------: | ------: |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th style="text-align:left">一个普通标题</th><th style="text-align:center">一个普通标题</th><th style="text-align:right">一个普通标题</th></tr></thead><tbody><tr><td style="text-align:left"><em>短文本</em></td><td style="text-align:center">中等文本</td><td style="text-align:right">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:center">短文本</td><td style="text-align:right">中等文本</td></tr></tbody></table><h5 id="使用html插入表格"><a href="#使用html插入表格" class="headerlink" title="使用html插入表格"></a>使用html插入表格</h5><p>上述markdown原生的方法只能创建一些简单的表格，如果想创建复杂的表格，如<mark>合并单元格</mark>、<mark>调整表格颜色</mark>等就需要直接使用html进行创建表格。</p><p>实现合并单元格：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>b1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>b2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>b3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>c2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>c3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果：</strong></p><table><br><tr><br><th>项目1</th><br><th>项目2</th><br><th>项目3</th><br></tr><br><tr><br><td>a1</td><br><td colspan="2">a2</td><br></tr><br><tr><br><td rowspan="2">b1</td><br><td>b2</td><br><td>b3</td><br></tr><br><tr><br><td>c2</td><br><td>c3</td><br></tr><br></table><div class="note info"><ul><li><code>table</code>标签：定义 HTML 表格</li><li><code>tr</code> 元素定义表格<code>行</code></li><li><code>th</code> 元素定义<code>表头</code></li><li><code>td</code> 元素定义表格<code>单元</code></li><li><code>td</code>标签下的<code>colspan（跨列-合并一行的多列）及rowspan（跨行-合并一列的多行）</code>属性进行单元格的合并。</li></ul></div><h5 id="使用html插入表格需要注意空行"><a href="#使用html插入表格需要注意空行" class="headerlink" title="使用html插入表格需要注意空行"></a>使用html插入表格需要注意空行</h5><p>markdown在处理上述的表格时会<strong>产生大量的空行</strong>，除非将整个表格写成一行，不然空行的书目和整个html代码占的行数相同，解决方法是加上<code>escape</code>标签，将整个table套起来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">escape</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>b1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>b2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>b3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>c2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>c3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">escape</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><table><tr><th>项目1</th><th>项目2</th><th>项目3</th></tr><tr><td>a1</td><td colspan="2">a2</td></tr><tr><td rowspan="2">b1</td><td>b2</td><td>b3</td></tr><tr><td>c2</td><td>c3</td></tr></table><h5 id="偷懒方法之直接复制html代码"><a href="#偷懒方法之直接复制html代码" class="headerlink" title="偷懒方法之直接复制html代码"></a>偷懒方法之直接复制html代码</h5><p>从上面html代码可以看出来写着比较麻烦，为了解决这个问题，这里有一个专门生成<code>Latex</code>、<code>html</code>、<code>markdown</code>、<code>text</code>、<code>mediawiki</code>支持的表格源码的网站，只需要选取相应的内容即可，还可以<strong>调整表格颜色</strong>，生成相应的css样式。</p><a class="btn" href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>生成表格源码的网站</a><hr><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块有两种写法：使用反引号加代码语言种类，代码写完后面也跟三个相同的符号（这种方法最为常用）；第二种写法就是简单地缩进 4 个空格或是 1 个制表符就可以。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个普通段落：</span><br><span class="line"></span><br><span class="line">    这是一个代码区块。</span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>需要和<strong>普通段落之间存在空行</strong></li><li><strong>最后的三个反引号之后不能存在空格</strong>，不然会出错</li></ul></div><hr><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>你可以在一行中用<mark>三个以上</mark>的<code>星号</code>、<code>减号</code>、<code>底线</code>来<strong>建立一个分隔线</strong>，<em>行内不能有其他东西</em>。你也<em>可以在星号或是减号中间插入空格</em>。下面每种写法都可以建立分隔线：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">_____</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><hr><hr><hr><hr><hr><hr><div class="note info"><p>使用带空格的<code>星号</code>、<code>减号</code>、<code>底线</code>建立空格线，空格线会粗一些。</p></div><hr><p><br></p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>markdown支持两种形式的链接语法：<code>行内式</code>和<code>参考式</code>两种形式，一般行内式使用较为简单和普遍，所以这里就采用行内式的方式。</p><p>链接的使用形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/ "Title")</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br><a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a></p><div class="note info"><ul><li>方括号内的文字（an example）表示链接作用的文字</li><li>圆括号内部第一个是链接地址</li><li>第二个是title：鼠标移到链接文字上显示的内容</li></ul></div><p>如果你是要链接到<strong>同样主机的资源，你可以使用相对路径</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">See my [About](/about/) page for details.</span><br></pre></td></tr></table></figure><p><mark>关于参考式链接:</mark></p><ul><li>参考式的链接其实重点不在于它比较好写，而是它比较好读</li><li>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断</li><li>具体关于参考是的讲解可以参考<a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">这篇文章</a>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        "Google"</span><br><span class="line">  [2]: http://search.yahoo.com/  "Yahoo Search"</span><br><span class="line">  [3]: http://search.msn.com/    "MSN Search"</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><hr><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5><p>markdown使用星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被<code>*</code>或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code>标签包围，显示出斜体的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于*斜体*的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<em>斜体</em>的测试</p><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5><p>markdown使用两个星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被两个<code>*</code>或 <code>_</code> 包围的字词会被转成用 <code>&lt;strong&gt;</code>（加粗显示）包围，显示出加粗的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于**加粗**的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<strong>加粗</strong>的测试</p><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5><p>使用以上的斜体和加粗叠加可以实现斜体和加粗的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于***斜体加粗***的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<strong><em>斜体</em></strong>的测试</p><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><p>要加删除线的文字左右分别用<code>两个~~</code>号包起来，这个也可以叠加斜体以及加粗标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于~~删除线~~的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<del>删除线</del>的测试</p><div class="note info"><ul><li>星号<code>*</code>和底线<code>_</code>与被包围的文字之间不能有空格，不然星号<code>*</code>和底线<code>_</code>就会被当成普通的字符显示</li><li>如果想加入普通的星号<code>*</code>和底线<code>_</code>，你可以用反斜线，如</li></ul></div><hr><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>行内插入代码，可以直接使用反引号（<code>`</code>）将代码包围起来即可。如<code>&lt;div&gt; &lt;/div&gt;</code>就是写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span><br></pre></td></tr></table></figure><p><mark>行内代码中加入反引号：</mark>可以用<strong>多个反引号来开启和结束代码区段</strong>，同时起始和结束端都可以放入一个空白，<em>起始端后面一个，结束端前面一个</em>，这样你就可以<strong>在区段的一开始就插入反引号</strong>：如 A backtick-delimited string in a code span: <code>`foo`</code>、三个反引号就是写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`` `foo` ``</span><br><span class="line"># 三个反引号在hexo博客中显示可能会出问题</span><br><span class="line">`` ``` ``</span><br></pre></td></tr></table></figure><hr><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><h5 id="使用markdown语法插入图片："><a href="#使用markdown语法插入图片：" class="headerlink" title="使用markdown语法插入图片："></a>使用markdown语法插入图片：</h5><p>使用markdown插入图片与插入链接类似，也有两种方式：<strong>行内式和参考式</strong>，这里讲解的主要为行内式。关于参考式的用法可以<em>参考链接参考式</em>的用法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")</span><br><span class="line"><span class="comment">&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")</span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" alt="markdown_pic" title="使用markdown插入图片"></p><center><br><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" alt="markdown_pic" title="使用markdown+center标签居中插入图片"><br></center><div class="note info"><p><code>Optional title</code> 是用来在鼠标移到图片上时显示的title</p></div><div class="note warning"><p>使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别</p></div><hr><h5 id="html代码插入图片"><a href="#html代码插入图片" class="headerlink" title="html代码插入图片"></a>html代码插入图片</h5><p><strong>针对使用markdown插入图片的缺点，使用html语句可以很好的解决</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用img标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pn9abh3rj.bkt.clouddn.com/test.png"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"图片名称"</span> <span class="attr">align</span>=<span class="string">center</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用div标签包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pn9abh3rj.bkt.clouddn.com/test.png"</span>  <span class="attr">title</span>=<span class="string">"使用html插入图片"</span>  <span class="attr">alt</span>=<span class="string">"图片名称"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" width="300" height="200" alt="图片名称" title="使用html插入图片" align="center"></p><div align="center"><br><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" title="使用html插入图片" alt="图片名称"><br></div><div class="note warning"><ul><li>不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；</li><li>推荐使用div标签包裹img标签。</li></ul></div><hr><p><br></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>markdown支持以下这些符号前面<strong>加上反斜杠来帮助插入普通的符号</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="常见错误原因集锦："><a href="#常见错误原因集锦：" class="headerlink" title="常见错误原因集锦："></a>常见错误原因集锦：</h3><div class="note warning"><ul><li>html<strong>块级元素上下没有空格</strong>，块级元素是指 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签</li><li><strong>列表</strong>与前后内容之间没有空格</li><li><strong>列表</strong>内容和标记之间没有空格</li><li><strong>换行操作</strong>只回车没有在上一行文本末尾增加两个以上空格</li><li><strong>停止引用</strong>需要和下一行文本空行（另起一段），不然也会被引用进去</li><li><strong>代码</strong>最后的<code>`</code> <code></code>之后不能存在空格，不然会将后面的内容也写入代码内</li><li><strong>强调</strong>，不管是加粗还是斜体，<strong>标记<code>*</code>或`</strong><code>不能与文本之间存在距离**，不然会失效，标记会显示成标记本身，即</code>*<code>或</code>**`</li><li><strong>表格</strong>的语句<mark>上一行必须为空行</mark>，不然表格不生效</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener">markdown融合单元单元格问题</a></li><li><a href="http://www.tablesgenerator.com/text_tables" target="_blank" rel="noopener">Latex|html|markdown|text|mediawiki制作表格并得到相应源代码的利器</a></li><li><a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></li><li><a href="http://wow.kuapp.com/markdown/basic.html" target="_blank" rel="noopener">Markdown: Basics （快速入门）</a></li><li><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">Markdown 基本语法</a></li><li><a href="https://github.com/guoyunsky/Markdown-Chinese-Demo" target="_blank" rel="noopener">Markdown-Chinese-Demo</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结markdown基础语法，便于后续查找和使用。&lt;a href=&quot;http://showteeth.tech/posts/37746.html&quot;&gt;另有一篇next-markdown技巧和模板&lt;/a&gt;总结了博客写作中常用的markdown技巧和模板，有些并不是原生的markdown语法，但是写作效果很好看，需要的时候可以查阅这个。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="markdown" scheme="http://showteeth.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>sed-文本处理工具</title>
    <link href="http://showteeth.tech/posts/1752.html"/>
    <id>http://showteeth.tech/posts/1752.html</id>
    <published>2019-02-24T04:08:41.000Z</published>
    <updated>2019-03-01T03:37:04.806Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>sed处理文本，包括sed命令的基本格式、参数和命令说明、文本的替换、打印、删除、增加、插入以及其他常用的技巧（分组、传入参数、命令连用以及对文件进行读取和写入等）。</p></div><a id="more"></a><h2 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h2><p>sed是一种流编辑器，它是文本处理中非常中的工具，能够<strong>完美的配合正则表达式</strong>使用，功能不同凡响。处理时，把<strong>当前处理的行</strong>存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，<strong>接着处理下一行，这样不断重复，直到文件末尾（和awk都是对文件和输入的每一行进行操作）</strong>。<strong>文件内容并没有改变</strong>，除非你使用重定向存储输出。</p><p>sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><hr><h2 id="sed-用法"><a href="#sed-用法" class="headerlink" title="sed 用法"></a>sed 用法</h2><h3 id="sed-命令格式"><a href="#sed-命令格式" class="headerlink" title="sed 命令格式"></a>sed 命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...</span><br><span class="line"></span><br><span class="line">sed [options] <span class="string">'command'</span> file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure><hr><h3 id="sed-options说明"><a href="#sed-options说明" class="headerlink" title="sed options说明"></a>sed options说明</h3><table><tr><th width="20%">参数</th><th width="20%">完整参数</th><th width="60%">说明</th></tr><tr><td>-e script</td><td>–expression=script</td><td>以选项中的指定的script来处理输入的文本文件，直接在命令行模式上进行sed动作编辑，此为默认选项</td></tr><tr><td>-f script</td><td>–files=script</td><td>以选项中的指定的script文件来处理输入的文本文件</td></tr><tr><td>-i</td><td>–in-place</td><td>直接在原位修改原文件</td></tr><tr><td>-n</td><td>–quiet –silent</td><td>仅显示script处理后的结果</td></tr><tr><td>-V</td><td>–version</td><td>显示版本信息</td></tr><tr><td>-h</td><td>–help</td><td>显示帮助</td></tr></table><hr><h3 id="sed-command说明"><a href="#sed-command说明" class="headerlink" title="sed command说明"></a>sed command说明</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>在当前行下面插入文本。</td></tr><tr><td>i</td><td>在当前行上面插入文本。</td></tr><tr><td>c</td><td>把选定的行改为新的文本。</td></tr><tr><td>d</td><td>删除，删除选择的行</td></tr><tr><td>D</td><td>删除模板块的第一行</td></tr><tr><td>s</td><td>替换指定字符</td></tr><tr><td>h</td><td>拷贝模板块的内容到内存中的缓冲区</td></tr><tr><td>H</td><td>追加模板块的内容到内存中的缓冲区</td></tr><tr><td>g</td><td>获得内存缓冲区的内容，并替代当前模板块中文本</td></tr><tr><td>G</td><td>获得内存缓冲区的内容，并追加到当前模板块文本的后面</td></tr><tr><td>l</td><td>列表不能打印字符的清单</td></tr><tr><td>n</td><td>读取下一个输入行，用下一个命令处理新的行而不是第一个命令</td></tr><tr><td>N</td><td>追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码</td></tr><tr><td>p</td><td>打印模板块的行</td></tr><tr><td>P</td><td>打印模板块的第一行</td></tr><tr><td>q</td><td>退出sed</td></tr><tr><td>b label</td><td>分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾</td></tr><tr><td>r file</td><td>从file中读行</td></tr><tr><td>t label</td><td>if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾</td></tr><tr><td>T label</td><td>错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾</td></tr><tr><td>w file</td><td>写并追加模板块到file末尾</td></tr><tr><td>W file</td><td>写并追加模板块的第一行到file末尾</td></tr><tr><td>!</td><td>表示后面的命令对所有没有被选定的行发生作用</td></tr><tr><td>=</td><td>打印当前行号</td></tr><tr><td>#</td><td>把注释扩展到第一个换行符以前</td></tr></tbody></table><hr><h3 id="sed-正则匹配元字符集"><a href="#sed-正则匹配元字符集" class="headerlink" title="sed 正则匹配元字符集"></a>sed 正则匹配元字符集</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配行开始，如：/^sed/匹配所有以sed开头的行。</td></tr><tr><td>$</td><td>匹配行结束，如：/sed$/匹配所有以sed结尾的行。</td></tr><tr><td>.</td><td>匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</td></tr><tr><td>*</td><td>匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</td></tr><tr><td>[]</td><td>匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。</td></tr><tr><td>[^]</td><td>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</td></tr><tr><td>(..)</td><td>匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。</td></tr><tr><td>&amp;</td><td>保存搜索字符用来替换其他字符，如s/love/&amp;/，love这成love。</td></tr><tr><td>&lt;</td><td>匹配单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</td></tr><tr><td>&gt;</td><td>匹配单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</td></tr><tr><td>x{m}</td><td>重复字符x，m次，如：/0{5}/匹配包含5个0的行。</td></tr><tr><td>x{m,}</td><td>重复字符x，至少m次，如：/0{5,}/匹配至少有5个0的行。</td></tr><tr><td>x{m,n}</td><td>重复字符x，至少m次，不多于n次，如：/0{5,10}/匹配5~10个0的行。</td></tr></tbody></table><hr><p><br></p><h2 id="sed-用法实例"><a href="#sed-用法实例" class="headerlink" title="sed 用法实例"></a>sed 用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test.txt</code><br>my cat’s name is betty<br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><h4 id="sed-替换标记"><a href="#sed-替换标记" class="headerlink" title="sed 替换标记"></a>sed 替换标记</h4><style>table th:first-of-type{width:10%}</style><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>g</td><td>表示行内全面替换</td></tr><tr><td>p</td><td>表示打印行</td></tr><tr><td>w</td><td>表示把行写入一个文件</td></tr><tr><td>x</td><td>表示互换模板块中的文本和缓冲区中的文本</td></tr><tr><td>y</td><td>表示把一个字符翻译为另外的字符（但是不用于正则表达式）</td></tr><tr><td>\1</td><td>子串匹配标记</td></tr><tr><td>&amp;</td><td>已匹配字符串标记</td></tr></tbody></table><hr><h4 id="sed-s-替换指定字符"><a href="#sed-s-替换指定字符" class="headerlink" title="sed s 替换指定字符"></a>sed s 替换指定字符</h4><p>将每一行文本中的This替换为sub<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">'s/is/are/'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略-e</span></span><br><span class="line">sed  <span class="string">'s/is/are/'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name are betty<br>Th<strong>are</strong> <strong>is</strong> your dog<br>my dog’s name are frank<br>Th<strong>are</strong> <strong>is</strong> your fish<br>my fareh’s name is george<br>Th<strong>are</strong> <strong>is</strong> your goat<br>my goat’s name are adam</p></blockquote><div class="note info"><ul><li>option的默认就是-e，所以-e可以省略</li><li><code>s命令</code>：替换指定字符指的是每一行的第一个发生替换，第二个以及后续的不会发生替换</li></ul></div><hr><h4 id="只打印那些发生替换的行"><a href="#只打印那些发生替换的行" class="headerlink" title="只打印那些发生替换的行"></a>只打印那些发生替换的行</h4><p><code>-n选项</code>和<code>p命令</code>一起使用表示<code>只打印</code>那些发生替换的行</p><div class="note info"><ul><li><code>-n选项</code>:仅显示script处理后的结果</li><li><code>p命令</code>:打印模板块的行</li><li>选项、命令、命令三者连用就是：打印处理后的模板块的行</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'s/is/are/p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name <strong>are</strong> betty<br>Th<strong>are</strong> is your dog<br>my dog’s name <strong>are</strong> frank<br>Th<strong>are</strong> is your fish<br>my f<strong>are</strong>h’s name is george<br>Th<strong>are</strong> is your goat<br>my goat’s name <strong>are</strong> adam</p></blockquote><hr><h4 id="全局替换"><a href="#全局替换" class="headerlink" title="全局替换"></a>全局替换</h4><p><code>g命令</code>表示行内全面替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  <span class="string">'s/is/are/g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><blockquote><p>my cat’s name <strong>are</strong> betty<br>Th<strong>are</strong> <strong>are</strong> your dog<br>my dog’s name <strong>are</strong> frank<br>Th<strong>are</strong> <strong>are</strong> your f<strong>are</strong>h<br>my f<strong>are</strong>h’s name <strong>are</strong> george<br>Th<strong>are</strong> <strong>are</strong> your goat<br>my goat’s name <strong>are</strong> adam</p></blockquote><div class="note info"><ul><li>注意与<code>单独的s命令</code>的结果对比</li><li><code>命令s</code>、<code>命令g</code>之间的<strong>顺序是固定的</strong></li></ul></div><hr><h4 id="从第几处开始替换"><a href="#从第几处开始替换" class="headerlink" title="从第几处开始替换"></a>从第几处开始替换</h4><p>从第二处开始替换：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/is/are/2'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果:</strong></p><blockquote><p>my cat’s name is betty<br>This are your dog<br>my dog’s name is frank<br>Th<em>is</em> <strong>are</strong> your f<em>is</em>h<br>my fish’s name are george<br>This are your goat<br>my goat’s name is adam</p></blockquote><div class="note info"><p>数字后面可以接<code>命令g</code>或者<code>命令p</code>等</p></div><p><strong>从每行中第N除开始全局替换：</strong></p><p><code>g命令</code><strong>之前加上数字N</strong>，表示从第N处之后的匹配开始全局替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/is/are/2g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name <strong>is</strong> betty<br>Th<strong>is</strong> <strong>are</strong> your dog<br>my dog’s name is frank<br>Th<strong>is</strong> <strong>are</strong> your f<strong>are</strong>h<br>my fish’s name are george<br>This are your goat<br>my goat’s name is adam</p></blockquote><div class="note info"><p>从第二处（包括）开始，后面的所有匹配上的都被替换掉了</p></div><hr><h3 id="以行为单位进行替换"><a href="#以行为单位进行替换" class="headerlink" title="以行为单位进行替换"></a>以行为单位进行替换</h3><p><code>命令c</code>：把选定的行改为新的文本</p><p>将第2-5行的内容取代成为this is sub of line 2-5<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c 和文字之间有没有空行都可以</span></span><br><span class="line">sed <span class="string">'2,5c this is sub of line 2-5'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br><em>this is sub of line 2-5</em><br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><p><strong>替换为多行的内容，只需要通过<code>\n</code>进行文本的换行即可：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2,5cthis is sub of line 2-5 \nthis is a second sub'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br><em>this is sub of line 2-5</em><br><em>this is a second sub</em><br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="原位修改文件"><a href="#原位修改文件" class="headerlink" title="原位修改文件"></a>原位修改文件</h3><p><code>选项i</code>：在文件的<strong>原位修改，不在屏幕输出</strong>，如果<strong>-i后跟着suffix</strong>，则会产生备份文件，形式为<code>原文件名suffix</code>。</p><p><code>命令g</code>也可以替换为其他命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i_suffix <span class="string">'s/is/are/g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p><code>ls</code><br>test.txt<br>test.txt_suffix</p></blockquote><blockquote><p><code>cat test.txt</code><br>my cat’s name are betty<br>Thare are your dog<br>my dog’s name are frank<br>Thare are your fareh<br>my fareh’s name are george<br>Thare are your goat<br>my goat’s name are adam</p></blockquote><hr><h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符/"></a>定界符/</h3><p>命令中字符 <code>/</code> 在sed中作为<code>定界符</code>使用，也<strong>可以使用任意的定界符</strong>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用冒号替代</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">'s:sk:ma:4g'</span></span><br><span class="line"><span class="comment"># 使用竖线替代</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">'s|sk|ma|4g'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>sksksk<strong>mamama</strong></p></blockquote><blockquote><p>sksksk<strong>mamama</strong></p></blockquote><div class="note info"><ul><li>定界符出现在样式内部时，需要进行<strong>转义</strong>或者直接<strong>更换定界符</strong></li><li>这个定界符个人感觉其实是用来作为<strong>正则匹配</strong>的，和<code>awk</code>用法相似</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/bin'</span> |sed <span class="string">'s/\/usr/\/test/g'</span></span><br><span class="line"><span class="comment"># 直接更换定界符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/bin'</span> |sed <span class="string">'s|/usr|/test|g'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>/test/local/bin</p></blockquote><blockquote><p>/test/local/bin</p></blockquote><hr><h3 id="已匹配字符串标记-amp"><a href="#已匹配字符串标记-amp" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><ul><li><code>&amp;</code>：已经匹配上的内容暂存在这个变量中，方便对已匹配内容进行处理</li></ul><p>正则表达式<code>\w\+</code>匹配每一个单词，使用<code>[&amp;]</code>替换它，<code>&amp;</code>对应之前所匹配到的单词：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span> line | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo test is a test line |sed &#39;s/\w\+/[&amp;]/g&#39;</code><br>[test] [is] [a] [test] [line]</p></blockquote><div class="note info"><ul><li>从上面可以看出，这种方法主要是用来针对<strong>一次匹配多个字符串</strong>，然后<strong>对多个字符串进行分开处理</strong>，而不是使用相同的处理（如使用同一个字符替换）</li></ul></div><hr><h3 id="分组标记-1-、-2"><a href="#分组标记-1-、-2" class="headerlink" title="分组标记\1 、\2"></a>分组标记\1 、\2</h3><ul><li><code>\1</code> 、<code>\2</code>：表示正则匹配的分组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">'s/digit \([0-9]\)/\1/'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo this is digit 7 in a number |sed &#39;s/digit \([0-9]\)/\1/&#39;</code><br>this is 7 in a number</p></blockquote><p>命令中digit 7，被替换成7。样式匹配到的子串是7，<code>\(..\)</code>用于匹配子串，对于匹配到的<strong>第一个子串</strong>标记为<code>\1</code>，依此类推匹配到的<strong>第二个结果</strong>就是<code>\2</code>,例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> aaa BBB | sed <span class="string">'s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo aaa BBB | sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;</code><br>BBB aaa</p></blockquote><div class="note info"><ul><li>括号需要进行转义</li></ul></div><hr><h3 id="传入变量-引用"><a href="#传入变量-引用" class="headerlink" title="传入变量-引用"></a>传入变量-引用</h3><p><code>sed</code>作为文本处理工具，可能经常需要传入变量来进行操作，这里提供了关于传入变量的方法，但是需要注意的是，<mark>如果表达式内部存在变量字符串，<strong>command的单引号就要变成双引号</strong></mark>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">"s/hello/<span class="variable">$test</span>/"</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo &quot;hello WORLD&quot; |sed &quot;s/hello/$test/&quot;</code><br>HELLO WORLD</p></blockquote><hr><h3 id="组合多个命令"><a href="#组合多个命令" class="headerlink" title="组合多个命令 ;"></a>组合多个命令 ;</h3><p>命令组合在Linux中是非常常见的，一般是使用<code>管道符</code>，在sed命令中可以使用<code>;</code>分割命令，这种用法同样和<code>awk</code>使用非常相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'表达式'</span> | sed <span class="string">'表达式'</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'表达式; 表达式'</span></span><br></pre></td></tr></table></figure><hr><h3 id="多个命令连用-e"><a href="#多个命令连用-e" class="headerlink" title="多个命令连用 -e"></a>多个命令连用 -e</h3><p><strong>选项-e本就是sed的默认选项</strong>，用于说明使用的是command而不是文件命令形式，多个命令连用，<strong>注意是有前后顺序的连用</strong>，在连用的command之前加上-e即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">'1,5d'</span> -e <span class="string">'s/my/MY/'</span> test.txt</span><br></pre></td></tr></table></figure><p>先删除test.txt文件中的第1、5行，输出删除的内容，然后对这两行进行将my替换为MY。</p><p><strong>最终结果：</strong></p><blockquote><p>This is your goat<br>MY goat’s name is adam</p></blockquote><div class="note info"><p>这个方式进行命令的连用和上面使用分号<code>;</code>将不同命令连写的方式<strong>效果相同</strong></p></div><hr><h3 id="使用-连用命令"><a href="#使用-连用命令" class="headerlink" title="使用{}连用命令"></a>使用<code>{}</code>连用命令</h3><p>使用<code>{}</code>将需要连用的命令包围，并使用<code>;</code>将多个命令隔开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/This/&#123;s/This/this/;n;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><div class="note info"><ul><li><code>命令n</code>：当前匹配行的下一行</li><li><code>选项n</code>：仅显示script处理后的结果</li></ul></div><hr><h3 id="选定行的范围-逗号"><a href="#选定行的范围-逗号" class="headerlink" title="选定行的范围 ,(逗号)"></a>选定行的范围 ,(逗号)</h3><p>选取行的范围来对文本进行处理，可以使用在不同行之间加逗号<code>,</code>的方式</p><p>打印从<strong>第5行开始</strong>到<strong>第一个包含以this开始的行之间的所有行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'5,/^This/p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>sed -n ‘5,/^This/p’ test.txt<br>my fish’s name is george<br>This is your goat</p></blockquote><div class="note info"><ul><li>行的索引<strong>开始于1</strong></li><li>需要注意的是：是包含尾部的，<code>5,7p</code>是<strong>包含</strong>第七行的</li><li>选取行号之后不仅仅可以用来做打印，还可以进行其他操作，具体见本文<strong>使用实战</strong></li></ul></div><hr><h3 id="打印命令-p"><a href="#打印命令-p" class="headerlink" title="打印命令 p"></a>打印命令 p</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印第3行</span></span><br><span class="line">sed -n <span class="string">'3p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第3-5行</span></span><br><span class="line">sed -n <span class="string">'3,5p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字和正则表达式连用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第1行开始，第一次出现This结束之间的行（起始行固定，终止行第一次正则匹配位置）</span></span><br><span class="line">sed -n <span class="string">'1,/This/p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始行固定，终止行第一次正则匹配位置</span></span><br><span class="line">sed -n <span class="string">"/my cat's name is betty/,/This/p"</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次匹配到This的行到第3行，然后再输出所有匹配到This的行</span></span><br><span class="line">sed -n <span class="string">'/This/,3p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果含有This的行在第1行之后，则打印所有含有This的行</span></span><br><span class="line">sed -n <span class="string">'/This/,1p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始行和终止行都不固定，打印全文</span></span><br><span class="line">sed -n <span class="string">'/my/,/This/p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;3p&#39; test.txt</code><br>my dog’s name is frank</p></blockquote><blockquote><p><code>sed -n &#39;3,5p&#39; test.txt</code><br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george</p></blockquote><blockquote><p><code>sed -n &#39;1,/This/p&#39; test.txt</code><br>my cat’s name is betty<br>This is your dog</p></blockquote><blockquote><p><code>sed -n &quot;/my cat&#39;s name is betty/,/This/p&quot; test.txt</code><br>my cat’s name is betty<br>This is your dog</p></blockquote><blockquote><p><code>sed -n &#39;/This/,3p&#39; test.txt</code><br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>This is your goat</p></blockquote><blockquote><p><code>sed -n &#39;/This/,1p&#39; test.txt</code><br>This is your dog<br>This is your fish<br>This is your goat</p></blockquote><blockquote><p><code>sed -n &#39;/my/,/This/p&#39; test.txt</code><br>my cat’s name is betty<br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><div class="note warning"><ul><li>使用<strong>打印命令p</strong>时需要注意，<strong>sed默认会打印出所有的行</strong>（命令d除外，只会打印保留下来的行），所以<strong>想要打印出特定修改过的行需要加上选项n</strong>，如果不加，<mark>匹配上的行会打印两遍</mark></li><li>使用正则表达式进行匹配打印时需要特别小心</li><li>如果数字在前面，是<strong>从数字开始</strong>到<strong>第一次匹配到正则表达式的部分（1就是从1开始，3就是从3开始看后面第一次匹配的）</strong></li><li><mark>如果数字在后面，正则表达式在前面，那么一定会将全文中包含正则表达式的全部输出，其他部分如果数字大于正则表达式第一次出现的行，则输出正则表达式第一次出现的行到数字之间的其他内容，如果数字小于正则表达式第一次出现的行，那就只会打印包含正则表达式的行。<strong>全文匹配正则表达式的输出以及正则表达式第一次出现的行到数字之间的其他内容输出</strong></mark></li><li>如果<strong>前后都为正则表达式</strong>，则<strong>输出全文内容</strong></li><li>关于上述正则表达式我的理解：因为数字是完全确定的，开始和结束行都很确定，所以可以很明确输出想要的结果，但是如果是正则表达式的话，不是唯一的匹配结果（段落中有几行都可以匹配上），那么如果正则表达式在前，则不知道从第几行开始当起始行，所以如果数字大于第一个匹配位置所在的行，那么以第一个匹配位置所在的行为起始行到数字规定的终止行之间的行都会输出，同时起始行可能有很多（其他位置也有匹配），所以还会输出其他匹配位置作为开始，这时如果数字小于第二个匹配位置的话，就只会输出匹配正则表达式的行，同时如果数字大于第二个匹配位置，由于第一个匹配位置的输出已经包含第二个位置，所以不会再输出一遍第二个匹配位置到终止行的信息</li></ul></div><div class="note info"><p>说了很多，总结一下：<mark>使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。</mark></p></div><hr><h3 id="匹配模式取反-！"><a href="#匹配模式取反-！" class="headerlink" title="匹配模式取反 ！"></a>匹配模式取反 ！</h3><p>打印除第一行和第二行之外的其他行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'1,2!p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;1,2!p&#39; test.txt</code><br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号 ="></a>显示行号 =</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/my/&#123;=;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;/my/{=;p}&#39; test.txt</code><br>1<br>my cat’s name is betty<br>3<br>my dog’s name is frank<br>5<br>my fish’s name is george<br>7<br>my goat’s name is adam</p></blockquote><hr><h3 id="删除命令-d"><a href="#删除命令-d" class="headerlink" title="删除命令 d"></a>删除命令 d</h3><ul><li><code>命令d</code>：删除，删除选择的行</li></ul><h4 id="删除空白行"><a href="#删除空白行" class="headerlink" title="删除空白行"></a>删除空白行</h4><blockquote><p><code>cat test2.txt</code><br>my cat’s name is betty</p><p>this is your this dog</p><p>my dog’s name is this frank</p><p>this is your fish</p><p>my fish’s name is this george</p><p>this is your goat</p><p>my goat’s name is this adam</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^$/d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>this is your this dog<br>my dog’s name is this frank<br>this is your fish<br>my fish’s name is this george<br>this is your goat<br>my goat’s name is this adam</p></blockquote><div class="note info"><ul><li>空白行的表示方法：<code>^$</code> (开头和结尾之间的内容为空)</li></ul></div><hr><h4 id="删除含有固定单词的行"><a href="#删除含有固定单词的行" class="headerlink" title="删除含有固定单词的行"></a>删除含有固定单词的行</h4><p><code>&lt;</code>：匹配单词的开始，注意需要转义<br><code>&gt;</code>：匹配单词的结束，注意需要转义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/\&lt;This\&gt;/d'</span> test.txt</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>sed &#39;/\&lt;This\&gt;/d&#39; test.txt</code><br>my cat’s name is betty<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><hr><h4 id="正则匹配删除-删除文件中所有以my开头的行"><a href="#正则匹配删除-删除文件中所有以my开头的行" class="headerlink" title="正则匹配删除-删除文件中所有以my开头的行"></a>正则匹配删除-删除文件中所有以my开头的行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>this is your this dog</p><p>this is your fish</p><p>this is your goat</p></blockquote><hr><h4 id="从某一行开始删除"><a href="#从某一行开始删除" class="headerlink" title="从某一行开始删除"></a>从某一行开始删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2,$d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed &#39;2,$d&#39; test2.txt</code><br>my cat’s name is betty</p></blockquote><div class="note info"><ul><li>最后一行：<code>$</code></li><li>首行不是<code>^</code>，直接使用1</li></ul></div><hr><h4 id="删除文件最后一行"><a href="#删除文件最后一行" class="headerlink" title="删除文件最后一行"></a>删除文件最后一行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'$d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty</p><p>this is your this dog</p><p>my dog’s name is this frank</p><p>this is your fish</p><p>my fish’s name is this george</p><p>this is your goat</p></blockquote><div class="note info"><ul><li>最后一行：<code>$</code></li><li>可以发现前面删掉空行的操作没有影响原始文件，如果想修改原始文件，可以加上<code>选项i</code></li></ul></div><hr><h3 id="写入文件-w命令"><a href="#写入文件-w命令" class="headerlink" title="写入文件 w命令"></a>写入文件 w命令</h3><p>在test.txt中所有包含my的行都被<strong>写入test2.txt</strong>里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/my/w test2.txt'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>cat test2.txt</code><br>my cat’s name is betty<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><hr><h3 id="从文件读入-r命令"><a href="#从文件读入-r命令" class="headerlink" title="从文件读入 r命令"></a>从文件读入 r命令</h3><p>file里的内容被读进来，<strong>显示在与test.txt匹配的行后面</strong>，如果<strong>匹配多行</strong>，则file的内容将<strong>显示在所有匹配行的下面</strong>：</p><blockquote><p>cat test1.txt<br>aaaaaaaa</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/my/r test1.txt'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><strong>my</strong> cat’s name is betty<br><em>aaaaaaaaa</em><br>This is your dog<br><strong>my</strong> dog’s name is frank<br><em>aaaaaaaaa</em><br>This is your fish<br><strong>my</strong> fish’s name is george<br><em>aaaaaaaaa</em><br>This is your goat<br><strong>my</strong> goat’s name is adam<br><em>aaaaaaaaa</em></p></blockquote><hr><h3 id="追加文件-a"><a href="#追加文件-a" class="headerlink" title="追加文件 a\"></a>追加文件 a\</h3><p><strong>追加与上述读取不同</strong>，虽然两者<strong>都是讲在匹配的行下增加文本信息</strong>，但是读取处理的是<strong>两个文件</strong>，追加处理的是<strong>一个文件和一行或多行文本</strong>。</p><p><strong>a后面的反斜杠可有可无</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/a\this is a test line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><em>my</em> cat’s name is betty<br><em>this is a test line</em><br>This is your dog<br><em>my</em> dog’s name is frank<br><em>this is a test line</em><br>This is your fish<br><em>my</em> fish’s name is george<br><em>this is a test line</em><br>This is your goat<br><em>my</em> goat’s name is adam<br><em>this is a test line</em></p></blockquote><p>同样也可以通过追加操作也<strong>增加两行甚至多行内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/a\this is a test line \nthis is second line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>通过使用<code>\n</code>进行换行操作来达到增加多行的目的</strong></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>this is a test line<br><em>this is second line</em><br>This is your dog<br>my dog’s name is frank<br>this is a test line<br><em>this is second line</em><br>This is your fish<br>my fish’s name is george<br>this is a test line<br><em>this is second line</em><br>This is your goat<br>my goat’s name is adam<br>this is a test line<br><em>this is second line</em></p></blockquote><div class="note info"><p>如果命令a之前什么都不加，表明给在每一行下都增加文本<br>当然，a之前也可以是单纯的数字</p></div><hr><h3 id="插入操作-i"><a href="#插入操作-i" class="headerlink" title="插入操作 i\"></a>插入操作 i\</h3><p>插入操作和上述追加和读取操作都不同，<mark>插入是在匹配行的上面进行插入，而追加和读取是在匹配行的下方进行的追加</mark>，同时插入和追加操作都是针对单个文件和一行或多行文本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/i\this is insert line'</span> test.txt</span><br></pre></td></tr></table></figure><blockquote><p><em>this is insert line</em><br>my cat’s name is betty<br>This is your dog<br><em>this is insert line</em><br>my dog’s name is frank<br>This is your fish<br><em>this is insert line</em><br>my fish’s name is george<br>This is your goat<br><em>this is insert line</em><br>my goat’s name is adam</p></blockquote><p><strong>在匹配文本上方插入多行的操作与追加类似，都是使用<code>\n</code>换行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/i\this is insert line \nthis is second insert line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p>this is insert line<br><em>this is second insert line</em><br>my cat’s name is betty<br>This is your dog<br>this is insert line<br><em>this is second insert line</em><br>my dog’s name is frank<br>This is your fish<br>this is insert line<br><em>this is second insert line</em><br>my fish’s name is george<br>This is your goat<br>this is insert line<br><em>this is second insert line</em><br>my goat’s name is adam</p></blockquote><hr><h3 id="匹配行的下一行-n命令"><a href="#匹配行的下一行-n命令" class="headerlink" title="匹配行的下一行 n命令"></a>匹配行的下一行 n命令</h3><p>打印匹配字符串的下一行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个写法会使得以my开头的行被打印两遍，是错误的</span></span><br><span class="line">sed <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法是仅显示script处理后的结果</span></span><br><span class="line">sed -n <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;/my/{n;p}&#39; test.txt</code><br>hhhh is your dog<br>This is your fish<br>This is your goat</p></blockquote><p><strong>在原始test文件中增加了一行用于防止和普通的替换混淆</strong></p><p>如果my被匹配，则<strong>移动到匹配行的下一行</strong>，<strong>替换这一行</strong>的this为This,并打印该行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/my/&#123;n;s/This/this/; &#125;'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述式子不等于</span></span><br><span class="line">sed <span class="string">'/my/n;s/This/this/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终输出：</strong></p><blockquote><p>my cat’s name is betty<br>hhhh is your dog<br><strong>This</strong> is your dog<br>my dog’s name is frank<br><strong>this</strong> is your fish<br>my fish’s name is george<br><strong>this</strong> is your goat<br>my goat’s name is adam</p></blockquote><p><strong>不是以my为开头的下一行的This不会被替换为this</strong></p><div class="note info"><p>注意<code>花括号{}</code>，不能丢掉</p></div><p><mark>使用grep、awk得到匹配行的下一行</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -A 1 my test.txt</span><br><span class="line">sed -n <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br><span class="line">awk <span class="string">'/my/&#123;getline; print&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="字符变换-y命令"><a href="#字符变换-y命令" class="headerlink" title="字符变换 y命令"></a>字符变换 y命令</h3><p>把1~10行内所有<strong>abcde转变为大写</strong>，注意，<strong>正则表达式元字符不能使用这个命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1,10y/abcde/ABCDE/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my CAt’s nAmE is BEtty<br>hhhh is your Dog<br>This is your Dog<br>my Dog’s nAmE is frAnk<br>This is your fish<br>my fish’s nAmE is gEorgE<br>This is your goAt<br>my goAt’s nAmE is ADAm</p></blockquote><div class="note info"><ul><li>注意这个和<strong>普通的替换不同</strong>，替换是将abcde这个字符串进行替换为ABCDE字符串，而这里是将<strong>a、b、c、d、e变为大写</strong>；</li><li>与通过<strong>已匹配字符串&amp;</strong>也不同，这个更为简单</li></ul></div><hr><h3 id="显示分隔符等详细信息-l命令"><a href="#显示分隔符等详细信息-l命令" class="headerlink" title="显示分隔符等详细信息 l命令"></a>显示分隔符等详细信息 l命令</h3><p>如果想知道文件内容的具体分割符，以及其他不能打印的字符信息可以使用’l’命令：</p><blockquote><p><code>sed -n &#39;l&#39; test3.txt</code><br>tab<code>\t</code>sep<code>\t</code>end<code>$</code><br>blank sep end<code>$</code><br>adsfaaaaaaaaaaaaaaaaafdadfasdfasdfasdfasdfsaaavfcadsasd asda asafdafa<code>\</code><br>sd<code>$</code></p></blockquote><p><strong>每行显示30个字符（包括最后的<code>\</code>）</strong>:</p><blockquote><p><code>sed -n &#39;l30&#39; test3.txt</code><br>tab<code>\t</code>sep<code>\t</code>end<code>$</code><br>blank sep end<code>$</code><br>adsfaaaaaaaaaaaaaaaaafdadfasd<code>\</code><br>fasdfasdfasdfsaaavfcadsasd as<code>\</code><br>da asafdafasd<code>$</code></p></blockquote><div class="note info"><p><code>l</code>命令用明确的形式显示模版空间的数据：</p><ul><li>以<code>C-style</code>的<strong>转义形式显示不能打印的字符(换行符、制表符等)</strong>和<strong>本身的<code>\Char</code>形式</strong></li><li><strong>长的行将进行分割</strong>，以字符<code>\</code>结尾的行<strong>表示分割</strong>，以字符<code>$</code>结尾的行表示<strong>分割结束</strong></li><li><code>n</code>指定显示行的长度，超过就进行分割；<strong>若为0表示不分割所有行</strong>；没有指定时就取命令行选项<code>-l</code>的设置，再没有就取<strong>默认值70</strong>。这是GNU的扩展功能</li></ul></div><hr><h3 id="打印奇数行或偶数行"><a href="#打印奇数行或偶数行" class="headerlink" title="打印奇数行或偶数行"></a>打印奇数行或偶数行</h3><h4 id="方法一：通过下一行（命令n）的方式"><a href="#方法一：通过下一行（命令n）的方式" class="headerlink" title="方法一：通过下一行（命令n）的方式"></a>方法一：通过下一行（命令n）的方式</h4><p><strong>打印奇数行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'p;n'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>This is your dog<br>This is your fish<br>This is your goat</p></blockquote><p><strong>打印偶数行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'n;p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>hhhh is your dog<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><div class="note info"><ul><li><code>命令n在前</code>而<code>p在后</code>为打印偶数行</li><li><code>命令p在前</code>而<code>n在后</code>为打印奇数行</li><li><code>命令n</code>为当前匹配的下一行</li></ul></div><hr><h4 id="方法二：简单方法"><a href="#方法二：简单方法" class="headerlink" title="方法二：简单方法"></a>方法二：简单方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印奇数行</span></span><br><span class="line">sed -n <span class="string">'1~2p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印偶数行</span></span><br><span class="line">sed -n <span class="string">'2~2p'</span> test.txt</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="在开头添加start"><a href="#在开头添加start" class="headerlink" title="在开头添加start"></a>在开头添加start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要里面的空格也是有用的</span></span><br><span class="line">sed <span class="string">'s/^/start /'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><code>sed &#39;s/^/start /&#39; test.txt</code><br>start my cat’s name is betty<br>start This is your dog<br>start my dog’s name is frank<br>start This is your fish<br>start my fish’s name is george<br>start This is your goat<br>start my goat’s name is adam</p></blockquote><hr><h3 id="在结尾增加end"><a href="#在结尾增加end" class="headerlink" title="在结尾增加end"></a>在结尾增加end</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要里面的空格也是有用的</span></span><br><span class="line">sed <span class="string">'s/$/ END/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><code>sed &#39;s/$/ END/&#39; test.txt</code><br>my cat’s name is betty END<br>This is your dog END<br>my dog’s name is frank END<br>This is your fish END<br>my fish’s name is george END<br>This is your goat END<br>my goat’s name is adam END</p></blockquote><hr><h3 id="在前三行之前增加-号做注释"><a href="#在前三行之前增加-号做注释" class="headerlink" title="在前三行之前增加#号做注释"></a>在前三行之前增加#号做注释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1,3s/^/# /'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed &#39;1,3s/^/# /&#39; test.txt</code><br># my cat’s name is betty<br># This is your dog<br># my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><p><br></p><h2 id="使用技巧及注意事项"><a href="#使用技巧及注意事项" class="headerlink" title="使用技巧及注意事项"></a>使用技巧及注意事项</h2><ul><li>使用<strong>打印命令p</strong>时需要注意，<strong>sed默认会打印出所有的行</strong>（命令d除外，只会打印保留下来的行），所以<strong>想要打印出特定修改过的行需要加上选项n</strong></li><li>区分<code>选项</code>和<code>命令</code>的<strong>关系和书写相对位置</strong>（如选项和命令都有n，但是作用却不同）</li></ul><div class="note info"><p>使用正则表达式进行匹配打印时需要特别小心，总结一下：<mark>使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。</mark></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/sed" target="_blank" rel="noopener">sed命令</a></li><li><a href="https://www.cnblogs.com/ctaixw/p/5860221.html" target="_blank" rel="noopener">sed命令详解，很多关于实战的讲的很好！！！</a></li><li><a href="https://www.cnblogs.com/maxincai/p/5146338.html" target="_blank" rel="noopener">sed命令用法</a></li><li><a href="https://github.com/dongweiming/sed_and_awk/blob/master/index.html" target="_blank" rel="noopener">sed_and_awk，github上148星</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;sed处理文本，包括sed命令的基本格式、参数和命令说明、文本的替换、打印、删除、增加、插入以及其他常用的技巧（分组、传入参数、命令连用以及对文件进行读取和写入等）。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>大致计划</title>
    <link href="http://showteeth.tech/posts/18198.html"/>
    <id>http://showteeth.tech/posts/18198.html</id>
    <published>2019-02-23T15:13:17.000Z</published>
    <updated>2019-02-27T12:34:30.908Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>对于想学习内容的大致实施计划，需要根据实际情况灵活更改。</p></div><a id="more"></a><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><div class="note success"><ul><li>Linux的内容比较细小，可以使用零散的时间来学习；</li><li>机器学习的内容需要学习的连贯性，需要大量时间学习和理解；</li><li>Python学习还好，介于Linux和机器学习内容之间；</li><li>其他内容的学习不是很急切，但是一些工具性的可以先学习，比如git以及markdown，时间需求不是很大；</li><li>可以将Linux中比较大的内容和其他内容学习中比较小的内容搭配，比如sed命令和下面的markdown搭配这种；</li><li>大块的内容比如机器学习和Python可以放在晚上10-1点半之间（每天3个小时）？这个还需要考虑；</li><li>机器学习和Python学习的内容可以放在github上。</li></ul></div><h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="机器学习学习"><a href="#机器学习学习" class="headerlink" title="机器学习学习"></a>机器学习学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="其他内容学习"><a href="#其他内容学习" class="headerlink" title="其他内容学习"></a>其他内容学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;对于想学习内容的大致实施计划，需要根据实际情况灵活更改。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="规划" scheme="http://showteeth.tech/categories/%E8%A7%84%E5%88%92/"/>
    
    
      <category term="每日学习" scheme="http://showteeth.tech/tags/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>其他想学习的内容</title>
    <link href="http://showteeth.tech/posts/49862.html"/>
    <id>http://showteeth.tech/posts/49862.html</id>
    <published>2019-02-23T12:17:33.000Z</published>
    <updated>2019-02-27T03:15:08.448Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>其他想学习的内容汇总，包括Latex排版、git使用、readthedocs+mkdocs静态网站、markdown学习、docker学习以及snakemake等内容，如果遇到后续会持续添加。</p></div><a id="more"></a><h2 id="markdown学习"><a href="#markdown学习" class="headerlink" title="markdown学习"></a>markdown学习</h2><p>&emsp;&emsp;在后面的学习中，我将尽可能使用markdown进行文档的编写，这样看着更加美观，所以有必要对齐进行完善的学习，同时在真正的语法与在博客中遇到的可能有所差别，所以这里的将主要关注一些基础的语法，其他在博客写作中常用的可以参考之前写的博客。</p><div><br><a class="btn" href="http://showteeth.tech/posts/65136.html"><i class="fa fa-telegram fa-lg fa-fw"></i>markdown基础语法学习</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/37746.html"><i class="fa fa-telegram fa-lg fa-fw"></i>next-markdown技巧和模板</a><br></div><hr><p><br></p><h2 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h2><p>&emsp;&emsp;接触到github之后，git操作是经常需要使用的，所以对其进行学习非常有必要。</p><div><br><a class="btn" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Git教程-廖雪峰</a><br></div><div><br><a class="btn" href="http://iissnan.com/progit/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Pro Git</a><br></div><hr><p><br></p><h2 id="Latex排版"><a href="#Latex排版" class="headerlink" title="Latex排版"></a>Latex排版</h2><p>&emsp;&emsp;第一次真正见识到latex是看到清本大佬使用latex对课程<mark>论文进行排版</mark>以及<mark>数学公式编写</mark>，觉得非常牛逼，同时也反思了自己的本科经历，果然大佬就是大佬！啥也不说了学习吧。</p><div><br><a class="btn" href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>一份其实很短的 LaTeX 入门文档</a><br></div><div><br><a class="btn" href="http://liyangbit.com/math/jupyter-latex/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Markdown中输入数学公式及LaTex常用数学符号整理</a><br></div><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>刘海洋-latex入门</a><br></div><hr><p><br></p><h2 id="readthedocs-mkdocs静态网站"><a href="#readthedocs-mkdocs静态网站" class="headerlink" title="readthedocs+mkdocs静态网站"></a>readthedocs+mkdocs静态网站</h2><p>&emsp;&emsp;在binbin师兄的带领下，也算是接触了一下readthedocs+mkdocs静态网站（写技术文档），感觉也挺好看的，可以用来展示自己使用markdown编写的一些文本，主要是指项目。</p><div><br><a class="btn" href="https://www.mkdocs.org/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>mkdocs的官方网站</a><br></div><hr><h3 id="好用的参考"><a href="#好用的参考" class="headerlink" title="好用的参考"></a>好用的参考</h3><div class="note info"><ul><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">很好的教程</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/extensions/admonition/" target="_blank" rel="noopener">mkdocs可用的拓展</a></li></ul></div><hr><p><br></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>&emsp;&emsp;docker是开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><div><br><a class="btn" href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Docker——从入门到实践</a><br></div><div><br><a class="btn" href="https://adoubi.life/posts/2017-8-19/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>docker学习笔记</a><br></div><hr><p><br></p><h2 id="snakemake"><a href="#snakemake" class="headerlink" title="snakemake"></a>snakemake</h2><p>&emsp;&emsp;snakemake是用来编写任务流程的工具。</p><div><br><a class="btn" href="https://www.jianshu.com/p/14b9eccc0c0e" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>snakemake使用笔记</a><br></div><div><br><a class="btn" href="https://slowkow.com/notes/snakemake-tutorial/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>snakemake-tutorial</a><br></div><div><br><a class="btn" href="https://www.jianshu.com/p/8e57fd2b81b2" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>使用Snakemake搭建分析流程</a><br></div><div><br><a class="btn" href="https://www.jianshu.com/p/14b9eccc0c0e" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>实例-binbin师兄写的</a><br></div><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;其他想学习的内容汇总，包括Latex排版、git使用、readthedocs+mkdocs静态网站、markdown学习、docker学习以及snakemake等内容，如果遇到后续会持续添加。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="规划" scheme="http://showteeth.tech/categories/%E8%A7%84%E5%88%92/"/>
    
    
      <category term="学习计划" scheme="http://showteeth.tech/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
