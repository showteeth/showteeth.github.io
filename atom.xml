<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-04-02T02:55:16.034Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python系列之文件读写(转载)</title>
    <link href="http://showteeth.tech/posts/57951.html"/>
    <id>http://showteeth.tech/posts/57951.html</id>
    <published>2019-04-02T01:11:24.000Z</published>
    <updated>2019-04-02T02:55:16.034Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要包括<code>I/O操作概述</code>、<code>文件读写实现原理与操作步骤</code>、<strong><code>文件打开模式及其区别</code></strong>、<code>Python文件操作步骤示例</code>、<code>Python文件读取相关方法</code>以及 <strong><code>文件读写与字符编码</code></strong>。</p></div><a id="more"></a><h2 id="I-O操作概述"><a href="#I-O操作概述" class="headerlink" title="I/O操作概述"></a>I/O操作概述</h2><hr><p>I/O在计算机中是指Input/Output，也就是Stream(流)的输入和输出。这里的输入和输出是相对于内存来说的，Input Stream(输入流)是指数据从外(磁盘、网络)流进内存，Output Stream是数据从内存流出到外面(磁盘、网络)。程序运行时，数据都是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方(通常是磁盘、网络操作)就需要IO接口。</p><p><strong><em>那么这个IO接口是由谁提供呢？高级编程语言中的IO操作是如何实现的呢？</em></strong></p><p>操作系统是个通用的软件程序，其通用目的如下：</p><ul><li>硬件驱动</li><li>进程管理</li><li>内存管理</li><li>网络管理</li><li>安全管理</li><li>I/O管理</li></ul><p>操作系统屏蔽了底层硬件，向上提供通用接口。因此，操作I/O的能力是由操作系统的提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来供开发者使用，Python也不例外。</p><h2 id="文件读写实现原理与操作步骤"><a href="#文件读写实现原理与操作步骤" class="headerlink" title="文件读写实现原理与操作步骤"></a>文件读写实现原理与操作步骤</h2><hr><h3 id="文件读写实现原理"><a href="#文件读写实现原理" class="headerlink" title="文件读写实现原理"></a>文件读写实现原理</h3><p>文件读写就是一种常见的IO操作。那么根据上面的描述，可以推断python也应该封装操作系统的底层接口，直接提供了文件读写相关的操作方法。事实上，也确实如此，而且Java、PHP等其他语言也是。</p><p><strong><em>那么我们要操作的对象是什么呢？我们又如何获取要操作的对象呢？</em></strong></p><p>由于操作I/O的能力是由操作系统提供的，且现代操作系统不允许普通程序直接操作磁盘，所以读写文件时需要请求操作系统打开一个对象(通常被称为文件描述符–<code>file descriptor</code>, 简称<code>fd</code>)，这就是我们在程序中要操作的文件对象。</p><p>通常高级编程语言中会提供一个内置的函数，通过接收”文件路径”以及“文件打开模式”等参数来打开一个文件对象，并返回该文件对象的文件描述符。因此通过这个函数我们就可以获取要操作的文件对象了。这个内置函数在Python中叫<code>open()</code>, 在PHP中叫<code>fopen()</code>,</p><h3 id="文件读写操作步骤"><a href="#文件读写操作步骤" class="headerlink" title="文件读写操作步骤"></a>文件读写操作步骤</h3><p>不同的编程语言读写文件的操作步骤大体都是一样的，都分为以下几个步骤：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)打开文件，获取文件描述符</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)操作文件描述符--读/写</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)关闭文件</span><br></pre></td></tr></table></figure><p></p><p>只是不同的编程语言提供的读写文件的api是不一样的，有些提供的功能比较丰富，有些比较简陋。</p><div class="note info"><p>需要注意的是： <strong><em>文件读写操作完成后，应该及时关闭</em></strong> 。一方面，<strong>文件对象会占用操作系统的资源</strong>；另外一方面，<strong>操作系统对同一时间能打开的文件描述符的数量是有限制的</strong>，在Linux操作系统上可以通过<code>ulimit -n</code> 来查看这个显示数量。如果<strong>不及时关闭文件，还可能会造成数据丢失</strong>。因为我将数据写入文件时，操作系统<strong>不会立刻把数据写入磁盘</strong>，而是先把数据放到内存缓冲区异步写入磁盘。当调用close方法时，操作系统会保证把没有写入磁盘的数据全部写到磁盘上，否则可能会丢失数据。</p></div><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><hr><p>我们先来看下在Python、PHP和C语言中打开文件的函数定义</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource fopen ( string $filename , string $mode [, bool $use_include_path = <span class="keyword">false</span> [, resource $context ]] )</span><br></pre></td></tr></table></figure><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>会发现以上3种编程语言内置的打开文件的方法接收的参数中，除了都包含一个“文件路径名称”，还会包含一个mode参数(C语言的open函数中的flags参数作用相似)。这么mode参数定义的是打开文件时的模式，常见的文件打开模式有：只读、只写、可读可写、只追加。不同的编程语言中对文件打开模式的定义有些微小的差别，我们来看下Python中的文件打开模式有哪些。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>文件打开模式</th><th>描述</th></tr></thead><tbody><tr><td><code>r</code></td><td>以<strong>只读模式</strong>打开文件，并将<strong>文件指针指向文件头</strong>；如果<strong>文件不存在会报错</strong></td></tr><tr><td><code>w</code></td><td>以<strong>只写模式</strong>打开文件，并将<strong>文件指针指向文件头</strong>；如果<strong>文件存在则将其内容清空</strong>，如果文件<strong>不存在则创建</strong></td></tr><tr><td><code>a</code></td><td>以<strong>只追加可写模式</strong>打开文件，并将<strong>文件指针指向文件尾部</strong>；如果<strong>文件不存在则创建</strong></td></tr><tr><td><code>r+</code></td><td>在<code>r</code>的基础上增加了可写功能</td></tr><tr><td><code>w+</code></td><td>在<code>w</code>的基础上增加了可读功能</td></tr><tr><td><code>a+</code></td><td>在<code>a</code>的基础上增加了可读功能</td></tr><tr><td><code>b</code></td><td><strong>读写二进制文件(默认是t，表示文本)</strong>，需要与上面几种模式搭配使用，如<code>ab</code>，<code>wb</code>, <code>ab</code>, <code>ab+</code>(POSIX系统，包括Linux都会忽略该字符)</td></tr></tbody></table><div class="note info"><p><strong><em>思考1：</em></strong> <code>r+</code>、<code>w+</code>和<code>a+</code>都可以实现对文件的读写，那么他们有什么区别呢？</p><ul><li><code>r+</code>会<strong>覆盖当前文件指针所在位置的字符</strong>，如原来文件内容是”<code>Hello，World</code>“，打开文件后写入”<code>hi</code>“则文件内容会变成”<code>hillo, World</code>“(因为 <strong><code>r</code>模式打开文件时文件指针指向文件头</strong>)</li><li><code>w+</code>与<code>r+</code>的不同是，<code>w+</code>在打开文件时就会<strong>先将文件内容清空</strong>，不知道它有什么用(<strong>感觉和单独的使用<code>w</code>模式没什么差别</strong>)</li><li><code>a+</code>与<code>r+</code>的不同是，<strong><code>a+</code>只能写到文件末尾</strong>(无论当前文件指针在哪里)</li></ul><p><br></p><p><strong><em>思考2：</em></strong> 为什么要定义这些模式呢？为什么不能像我们用word打开一篇文档一样既可以读，又可以写，还可修改呢？<br>关于这个问题，我查了很多资料，也没找到很权威的说明。在跟同行朋友交流过程中，发现大家主要有两种观点：</p><ul><li><strong>跟安全有关</strong> ，有这种观点的大部分是做运维的朋友，他们认为这就像linux上的rwx(读、写、执行)权限。</li><li><strong>跟操作系统内核管理I/O的机制有关</strong> ，有这种观点的大部分是做C开发的，特别是与内核相关的开发人员。为了提高读写速度，要写入磁盘的数据会先放进内存缓冲区，之后再回写。由于可能会同时打开很多文件，当要回写数据时，需要遍历以打开的文件判断是否需要回写。他们认为如果打开文件时指定了读写模式，那么需要回写时，只要去查找以“可写模式”打开的文件就可以了。</li></ul></div><h2 id="Python文件操作步骤示例"><a href="#Python文件操作步骤示例" class="headerlink" title="Python文件操作步骤示例"></a>Python文件操作步骤示例</h2><hr><p>我们来读取这样一个文本文件：song.txt，该文件的字符编码为<code>utf-8</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br></pre></td></tr></table></figure><h3 id="菜鸟实现-只是实现功能"><a href="#菜鸟实现-只是实现功能" class="headerlink" title="菜鸟实现(只是实现功能)"></a>菜鸟实现(只是实现功能)</h3><p>Python3实现：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：(以只读模式)打开文件</span></span><br><span class="line">f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：读取文件内容</span></span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p></p><p>这里说下Python2的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：(以只读模式)打开文件</span></span><br><span class="line">f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：读取文件内容</span></span><br><span class="line">print(f.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>Python3中已经内置对Unicode的支持，字符串str已经是真正的Unicode字符串。也就是说Python3中的文件读取方法已经自动完成了解码处理，因此无需再手动进行解码，可以直接将读取的文件中的内容进行打印；Python2中的字符串str是字节串，读取文件得到的也是字节串，在打印之前应该手动将其解码成Unicode字符串。关于这部分的说明，可以参考之前这篇文章<a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">&lt;&gt;</a>。</p><h3 id="中级实现"><a href="#中级实现" class="headerlink" title="中级实现"></a>中级实现</h3><p>在实现基本功能的前提下，考虑一些可能的意外因素。因为文件读写时都有可能产生IO错误(IOError)，一旦出错，后面包括<code>f.close()</code>在内的所有代码都不会执行了。因此我们要保证文件无论如何都能被关闭。那么可以用<code>try...finally</code>来实现，这实际上就是<code>try...except..finally</code>的简化版(我们只用Python3来进行示例演示)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">''</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;finally'</span>)</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;<span class="keyword">finally</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>输出结果说明，尽管with代码块中出现了异常，但是”&gt;&gt;&gt;&gt;&gt;&gt;finally“ 信息还是被打印了，说明finally代码块被执行，即文件关闭操作被执行。但是结果中错误信息还是被输出了，因此还是建议用一个完成的<code>try...except...finally</code>语句对异常信息进行捕获和处理。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免忘记或者为了避免每次都要手动关闭文件，我们可以使用<code>with</code>语句(一种语法糖，语法糖语句通常是为了简化某些操作而设计的)。with语句会在其代码块执行完毕之后自动关闭文件。因此我们可以这样来改写上面的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line">print(f.closed)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>是不是变得简介多了，代码结构也比较清晰了。<code>with</code>之后打印的<code>f.closed</code>属性值为<code>True</code>，说明文件确实被关闭了。</p><blockquote><p><strong>思考:</strong><br><strong>with语句会帮我们自动处理异常信息吗</strong>？</p></blockquote><p>要回答这个问题就要提到“上下文管理器” 和 with语句的工作流程。</p><p>with语句不仅仅可以用于文件操作，它实际上是一个很通用的结构，允许使用所谓的上下文管理器(context manager)。上下文管理器是一种支持<code>__enter__()</code>和<code>__exit__()</code>这两个方法的对象。<code>__enter__()</code>方法不带任何参数，它在进入with语句块的时候被调用，该方法的返回值会被赋值给as关键字之后的变量。<code>__exit__()</code>方法带有3个参数：<code>type(异常类型)</code>, <code>value(异常信息)</code>, <code>trace(异常栈)</code>，当<code>with</code>语句的代码块执行完毕或执行过程中因为异常而被终止都会调用<code>__exit__()</code>方法。正常退出时该方法的3个参数都为None，异常退出时该方法的3个参数会被分别赋值。如果<code>__exit__()</code>方法返回值(真值测试结果)为True则表示异常已经被处理，命令执行结果中就不会抛出异常信息了；反之，如果<code>__exit__()</code>方法返回值(真值测试结果)为False，则表示异常没有被处理并且会向外抛出该异常。</p><p>现在我们应该明白了，异常信息会不会被处理是由with后的语句返回对象的<code>__exit__()</code>方法决定的。文件可以被用作上下文管理器。它的<code>__enter__</code>方法返回文件对象本身，<code>__exit__</code>方法会关闭文件并返回None。我们看下file类中关于这两个方法的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">""" __enter__() -&gt; self. """</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *excinfo)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">""" __exit__(*excinfo) -&gt; None.  Closes the file. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可见，file类的<code>__exit__()</code>方法的返回值为None，None的真值测试结果为False，因此用于文件读写的with语句代码块中的异常信息还是会被抛出来，需要我们自己去捕获并处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面所说的<code>__exit__()</code>方法返回值(真值测试结果)为True则表示异常已经被处理，指的是<code>with</code>代码块中出现的异常。它对于<code>with</code>关键字之后的代码中出现的异常是不起作用的，因为还没有进入上下文管理器就已经发生异常了。<strong>因此，无论如何，还是建议在必要的时候在with语句外面套上一层<code>try...except</code>来捕获和处理异常</strong>。</p><p>有关“上下文管理器”这个强大且高级的特性的更多信息，请参看Python参考手册中的上下文管理器部分。或者可以在Python库参考中查看上下文管理器和contextlib部分。</p><h2 id="Python文件读取相关方法"><a href="#Python文件读取相关方法" class="headerlink" title="Python文件读取相关方法"></a>Python文件读取相关方法</h2><hr><p>我们知道，对文件的读取操作需要将文件中的数据加载到内存中，而上面所用到的read()方法会一次性把文件中所有的内容全部加载到内存中。这明显是不合理的，当遇到一个几个G的的文件时，必然会耗光机器的内存。这里我们来介绍下Python中读取文件的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>read()</code></td><td><strong>一次读取文件所有内容</strong>，返回一个<strong>str</strong></td></tr><tr><td><code>read(size)</code></td><td>每次最多读取指定长度的内容，返回一个<strong>str</strong>；在Python2中size指定的是字节长度，在Python3中size指定的是字符长度</td></tr><tr><td><code>readlines()</code></td><td>一次读取文件<strong>所有内容</strong>，按行返回一个<strong>list</strong></td></tr><tr><td><code>readline()</code></td><td>每次<strong>只读取一行</strong>内容</td></tr></tbody></table><p>此外，还要两个与文件指针位置相关的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>seek(n)</code></td><td>将文件指针移动到指定字节的位置</td></tr><tr><td><code>tell()</code></td><td>获取当前文件指针所在字节位置</td></tr></tbody></table><p>下面来看下操作实例</p><h3 id="读取指定长度的内容"><a href="#读取指定长度的内容" class="headerlink" title="读取指定长度的内容"></a>读取指定长度的内容</h3><p><strong>Python2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">12</span>).decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年</span><br></pre></td></tr></table></figure><blockquote><p>结果说明：Python2中<code>read(size)</code>方法的size参数指定的要读取的字节数，而song.txt文件是<code>UTF-8</code>编码的内容，一个汉字占3个字节，因此12个字节刚好是4个汉字。</p></blockquote><p><strong>Python3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说</span><br></pre></td></tr></table></figure><blockquote><p>结果说明：Python3中read(size)方法的size参数指定的要读取的字符数，这与文件的字符编码无关，就是返回12个字符。</p></blockquote><h3 id="读取文件中的一行内容"><a href="#读取文件中的一行内容" class="headerlink" title="读取文件中的一行内容"></a>读取文件中的一行内容</h3><p><strong>Python2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readline())</span><br></pre></td></tr></table></figure><p><strong>Python3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readline().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>输出结果都一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br></pre></td></tr></table></figure><h3 id="遍历打印一个文件中的每一行"><a href="#遍历打印一个文件中的每一行" class="headerlink" title="遍历打印一个文件中的每一行"></a>遍历打印一个文件中的每一行</h3><p>这里我们只以Python3来进行实例操作，Python2仅仅是需要在读取到内容后进行手动解码而已，上面已经有示例。</p><p><strong>方式一：先一次性读取所有行到内存，然后再遍历打印</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line"></span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line"></span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line"></span><br><span class="line">只有等别人兑现</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这种方式的缺点与read()方法是一样的，都是会消耗大量的内存空间。</span><br><span class="line"></span><br><span class="line">**方式二：通过迭代器一行一行的读取并打印**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line"></span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line"></span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line"></span><br><span class="line">只有等别人兑现</span><br></pre></td></tr></table></figure><p>另外，发现上面的输出结果中行与行之间多了一个空行。这是因为文件每一行的默认都有换行符，而print()方法也会输出换行，因此就多了一个空行。去掉空行也比较简单：可以用<code>line.rstrip()</code>去除字符串右边的换行符，也可以通过print(line, end=’’)避免print方法造成的换行。</p><p>file类的其他方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>flush()</code></td><td>刷新缓冲区数据，将缓冲区中的数据立刻写入文件</td></tr><tr><td><code>next()</code></td><td>返回文件下一行，这个方法也是file对象实例可以被当做迭代器使用的原因</td></tr><tr><td><code>truncate([size])</code></td><td>截取文件中指定字节数的内容，并覆盖保存到文件中，如果不指定size参数则文件将被清空; Python2无返回值，Python3返回新文件的内容字节数</td></tr><tr><td><code>write(str)</code></td><td>将字符串写入文件，没有返回值</td></tr><tr><td><code>writelines(sequence)</code></td><td>向文件写入一个字符串或一个字符串列表，如果字符串列表中的元素需要换行要自己加入换行符</td></tr><tr><td><code>fileno()</code></td><td>返回一个整型的文件描述符，可以用于一些底层IO操作上(如，os模块的read方法)</td></tr><tr><td><code>isatty()</code></td><td>判断文件是否被连接到一个虚拟终端，是则返回True，否则返回False</td></tr></tbody></table><h2 id="文件读写与字符编码"><a href="#文件读写与字符编码" class="headerlink" title="文件读写与字符编码"></a>文件读写与字符编码</h2><hr><p>前面已经写过一篇介绍Python中字符编码的相关文件<a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">&lt;&gt;</a> 里面花了很大的篇幅介绍Python中字符串与字符编码的关系以及转换过程。其中谈到过两个指定的字符编码的地方，及其作用：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python两个指定编码位置.png" alt="Python两个指定编码位置.png"></p><ul><li><strong><em>PyCharm等IDE开发工具指定的项目工程和文件的字符编码：</em></strong> 它的主要作用是告诉Pycharm等IDE开发工具保存文件时应该将字符转换为怎样的字节表示形式，以及打开并展示文件内容时应该以什么字符编码将字节码转换为人类可识别的字符。</li><li><strong><em>Python源代码文件头部指定的字符编码，如<code>*-* coding:utf-8 -*-</code>：</em></strong> 它的主要作用是告诉Python解释器当前python代码文件保存时所使用的字符编码，Python解释器在执行代码之前，需要先从磁盘读取该代码文件中的字节然后通过这里指定的字符编码将其解码为unicode字符。Python解释器执行Python代码的过程与IDE开发工具是没有什么关联性的。</li></ul><p><strong>那么这里为什么又要谈起字符编码的问题呢？</strong></p><p>或者换个问法，既然从上面已经指定了字符编码，为什么对文件进行读写时还要指定字符编码呢？从前面的描述可以看出：上面两个地方指定的是Python代码文件的字符编码，是给Python解释器和Pycharm等程序软件用的；而<strong>被读写文件的字符编码与Python代码文件的字符编码没有必然联系，读写文件时指定的字符编码是给我们写的程序软件用的</strong>。这是不同的主体和过程，希望我说明白了。</p><p><strong>读写文件时怎样指定字符编码呢？</strong></p><p>上面解释了读写文件为什么要指定字符编码，这里要说下怎样指定字符编码(其实这里主要讨论是读取外部数据时的情形)。这个问题其实在上面的文件读取示例中已经使用过了，这里我们再详细的说一下。</p><p>首先，再次看一下Python2和Python3中open函数的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>可以看到，Python3的open函数中多了几个参数，其中包括一个encoding参数。是的，这个encoding就是用来指定被操作文件的字符编码的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.write(<span class="string">'你好'</span>))</span><br></pre></td></tr></table></figure><p>那么Python2中怎样指定呢？<strong>Python2中的对文件的read和write操作都是字节</strong>，也就说Python2中文件的read相关方法读取的是字节串(如果包含中文字符，会发现len()方法的结果不等于读取到的字符个数，而是字节数)。<strong>如果我们要得到正确的字符串</strong>，需要手动将读取到的结果<code>decode(解码)</code>为字符串；相反，要以特定的字符编码保存要写入的数据时，需要手动<code>encode(编码)</code>为字节串。这个<code>encode()</code>和<code>decode()</code>函数可以接收一个字符编码参数。<strong>Python3中read和write操作的都是字符串</strong>，实际上是Python解释器帮我们自动完成了写入时的<code>encode(编码)</code>和读取时的<code>decode(解码)</code>操作，因此我们只需要在打开文件(open函数)时指定字符编码就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song2.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># f.write(u'你好'.encode('utf-8'))</span></span><br><span class="line">    <span class="comment"># f.write('你好'.decode('utf-8').encode('utf-8'))</span></span><br><span class="line">    f.write(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure><p><strong>文件读写时有没有默认编码呢？</strong></p><p>Python3中<code>open</code>函数的<code>encoding</code>参数显然是可以不指定的，这时候就会用一个“默认字符编码”。<br>看下Python3中open函数文档对<code>encoding</code>参数的说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoding <span class="keyword">is</span> the name of the encoding used to decode <span class="keyword">or</span> encode the</span><br><span class="line">file. This should only be used <span class="keyword">in</span> text mode. The default encoding <span class="keyword">is</span></span><br><span class="line">platform dependent, but any encoding supported by Python can be</span><br><span class="line">passed.  See the codecs module <span class="keyword">for</span> the list of supported encodings.</span><br></pre></td></tr></table></figure><p>也就是说，<code>encoding</code>参数的默认值是与平台有关的，比如<code>Window</code>上默认字符编码为<code>GBK</code>，<code>Linux</code>上默认字符编码为<code>UTF-8</code>。</p><p>而对于Python2来说，在进行文件写操作时，字节会被直接保存；在进行文件读操作时，如果不手动进行来<code>decode</code>操作自然也就用不着默认字符编码了。但是这时候在不同的字符终端打印的时候，会用当前平台的字符编码自动将字节解码为字符，此时可能会出现乱码。如song.txt文件时<code>UTF-8</code>编码的，在<code>windows(字符编码为GBK)</code>的命令行终端进行如下操作就会出现乱码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    print(f.read())</span><br><span class="line">...</span><br><span class="line">鍖嗗寙閭ｅ勾鎴戜滑 绌剁珶璇翠簡鍑犻亶 鍐嶈涔嬪悗鍐嶆嫋寤?</span><br><span class="line">鍙儨璋佹湁娌℃湁 鐖辫繃涓嶆槸涓€鍦?涓冩儏涓婇潰鐨勯泟杈?</span><br><span class="line">鍖嗗寙閭ｅ勾鎴戜滑 涓€鏃跺寙蹇欐拏涓?闅句互鎵垮彈鐨勮瑷€</span><br><span class="line">鍙湁绛夊埆浜哄厬鐜</span><br></pre></td></tr></table></figure><p>我们应该尽可能的获取被操作文件的字符编码，并明确指定<code>encoding</code>参数的值。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a href="https://www.cnblogs.com/yyds/p/6186621.html" target="_blank" rel="noopener">Python之文件读写</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，主要包括&lt;code&gt;I/O操作概述&lt;/code&gt;、&lt;code&gt;文件读写实现原理与操作步骤&lt;/code&gt;、&lt;strong&gt;&lt;code&gt;文件打开模式及其区别&lt;/code&gt;&lt;/strong&gt;、&lt;code&gt;Python文件操作步骤示例&lt;/code&gt;、&lt;code&gt;Python文件读取相关方法&lt;/code&gt;以及 &lt;strong&gt;&lt;code&gt;文件读写与字符编码&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之sys-程序与python解释器的交互</title>
    <link href="http://showteeth.tech/posts/38877.html"/>
    <id>http://showteeth.tech/posts/38877.html</id>
    <published>2019-04-01T16:21:21.000Z</published>
    <updated>2019-04-02T08:46:48.564Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之glob-文件名规则匹配</title>
    <link href="http://showteeth.tech/posts/24468.html"/>
    <id>http://showteeth.tech/posts/24468.html</id>
    <published>2019-04-01T16:14:52.000Z</published>
    <updated>2019-04-02T08:46:24.738Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Python中的常用模块<code>glob</code>，其作用是<strong>查找特定目录中符合匹配规则的文件(或目录)</strong>，主要包括三个函数：<code>glob.glob()</code>、<code>glob.iglob()</code>和<code>glob.escape()</code>，其中最主要的函数是<code>glob.glob()</code>，<code>glob.iglob()</code>和<code>glob.glob()</code>功能相似，但是<strong>返回的不再是列表而是迭代器对象</strong>，而<code>glob.escape()</code>主要是<strong>用来生成特殊字符匹配的pattern</strong>；在使用中<strong>需要注意通配符和正则表达式的区别</strong>。</p></div><a id="more"></a><h2 id="glob模块简介"><a href="#glob模块简介" class="headerlink" title="glob模块简介"></a>glob模块简介</h2><p><code>glob</code>模块是使用 <code>Unix shell</code> 规则去<strong>查找匹配模式的文件</strong>，<strong>返回的结果是无序的</strong>；在进行匹配时使用的是shell的通配符而不是正则表达式，关于正则表达式与通配符的区别，之前有过<a href="http://showteeth.tech/posts/37480.html">一篇文章</a>，如果忘记的话可以查看一下。</p><p><code>glob</code>模块其实也可以看做是<code>os</code>模块的补充，<code>os</code>模块中的<code>os.listdir()</code>可以列出某个目录下所有的文件和目录，但是这种列出是没有筛选性的，这在某些情况下并不是很适用，比如我想挑选出符合某个命名规则的文件，而<code>glob</code>模块就可以达到这个目的。</p><hr><h2 id="通配符规则"><a href="#通配符规则" class="headerlink" title="通配符规则"></a>通配符规则</h2><p>这里列出了glob模块支持的通配符规则(和shell的通配符规则有细微差别)：</p><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td><code>?</code></td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td><code>[char]</code></td><td>匹配<strong>原始字符char，相当于转义操作</strong></td><td>a[?]b：a与b之间<strong>只有一个字符且为<code>?</code></strong>,此时的<code>?</code>已经不再具有匹配任意一个字符的功能 如: a?b.txt</td></tr><tr><td><code>[list]</code></td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td><code>[!list]</code></td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr></tbody></table><hr><h2 id="返回所有匹配文件名-glob-glob"><a href="#返回所有匹配文件名-glob-glob" class="headerlink" title="返回所有匹配文件名-glob.glob()"></a>返回所有匹配文件名-glob.glob()</h2><p><strong>命令</strong>：<code>glob.glob(pathname, *, recursive=False)</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>pathname</code></strong>：绝对路径或者相对路径，可以包含通配符</li><li><strong><code>recursive</code></strong>：如果<code>recursive</code>是True，<strong>模式`</strong><code>会匹配任何文件以及0个或多个目录和子目录**；如果模式是</code>os.sep`，只有目录和子目录会被匹配；<strong>可以用于递归匹配目录和子目录的内容</strong></li></ul><h3 id="与os模块对比使用"><a href="#与os模块对比使用" class="headerlink" title="与os模块对比使用"></a>与os模块对比使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用os模块列出所有的文件</span></span><br><span class="line">os.listdir(<span class="string">'full_path'</span>)</span><br><span class="line">  [<span class="string">'a?c.txt'</span>, <span class="string">'abc.txt'</span>, <span class="string">'acc.txt'</span>, <span class="string">'adc.txt'</span>, <span class="string">'a[*]c.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用glob模块列出所有的文件</span></span><br><span class="line">glob.glob(<span class="string">'full_path/'</span>)</span><br><span class="line">  <span class="comment"># 没得到正确结果</span></span><br><span class="line">  [<span class="string">'full_path/'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'full_path/*'</span>)</span><br><span class="line">  [<span class="string">'full_path/a?c.txt'</span>, <span class="string">'full_path/abc.txt'</span>, \</span><br><span class="line">    <span class="string">'full_path/acc.txt'</span>, <span class="string">'full_path/adc.txt'</span>, <span class="string">'full_path/a[*]c.txt'</span>]</span><br></pre></td></tr></table></figure><div class="note info"><p>通过上面的示例我们可以看出<code>glob.glob()</code>和<code>os.listdir()</code>在使用和返回结果的区别：</p><ul><li><strong>使用方面</strong>：<code>os.listdir()</code>更为简单，<strong>只需要列出路径</strong>即可；而<code>glob.glob()</code>还<strong>需要设置通配符</strong>来达到匹配的目的</li><li><strong>返回结果方面</strong>：<code>os.listdir()</code>返回<strong>文件名称(不带路径)</strong>，而<code>glob.glob()</code>会返回<strong>文件名称+路径</strong>(和指定的路径相同模式，指定时使用绝对路径，返回结果前也是绝对路径，指定时使用相对路径，返回结果前也是相对路径)</li></ul></div><hr><h3 id="匹配任意一个或多个字符"><a href="#匹配任意一个或多个字符" class="headerlink" title="*-匹配任意一个或多个字符"></a>*-匹配任意一个或多个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配任意一个或多个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a*c.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回只要是以a开头、以c结尾的文件名，具体中间字符的数量没有限制</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abbc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配任意单个字符"><a href="#匹配任意单个字符" class="headerlink" title="?-匹配任意单个字符"></a>?-匹配任意单个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配任意单个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 如果不想输出以a开头、以c结尾并且中间包含两个以上字符的文件名，可以使用?</span></span><br><span class="line">  <span class="comment"># 表示中间只有任意一个字符，abbc.txt就不符合条件了</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="[]-匹配特殊字符"></a>[]-匹配特殊字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配单个特殊字符</span></span><br><span class="line">glob.glob(<span class="string">'./a[?]c.txt'</span>)</span><br><span class="line"> <span class="comment"># 如果文件名中含有特殊字符，比如这里的?</span></span><br><span class="line"> <span class="comment"># 对其进行匹配可以使用[] </span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'./a\?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 不同于shell可以使用\进行转义，这里转义后不能正确匹配</span></span><br><span class="line">  []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里是单个字符，不能匹配得到多个的情况</span></span><br><span class="line"><span class="comment"># 如果需要匹配多个，可以重复使用</span></span><br><span class="line">glob.glob(<span class="string">'./a[?][?]c.txt'</span>)</span><br><span class="line">  [<span class="string">'./a??c.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配得到单个和多个特殊字符的</span></span><br><span class="line">glob.glob(<span class="string">'./a[?]*c.txt'</span>)</span><br><span class="line">  <span class="comment"># 注意这的*不是任意多个前一个字符(正则表达式中的定义)</span></span><br><span class="line">  <span class="comment"># 因为*可以匹配任意字符，?也不例外，前面使用了[?]作为限制</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./a??c.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配字符范围"><a href="#匹配字符范围" class="headerlink" title="[]-匹配字符范围"></a>[]-匹配字符范围</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配字符范围，同样是单个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a[b-d]c.txt'</span>)</span><br><span class="line">  <span class="comment"># a和c之间存在一个字符，且该字符的范围是b-d</span></span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不能表示为范围，可以单独列出字符的范围</span></span><br><span class="line">glob.glob(<span class="string">'./a[bcd]c.txt'</span>)</span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="char-排除字符"><a href="#char-排除字符" class="headerlink" title="[!char]-排除字符"></a>[!char]-排除字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配中间字符不为b的文件</span></span><br><span class="line">glob.glob(<span class="string">'./a[!b]c.txt'</span>)</span><br><span class="line">  <span class="comment"># 排除了abc.txt</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="递归匹配子目录内容"><a href="#递归匹配子目录内容" class="headerlink" title="递归匹配子目录内容"></a>递归匹配子目录内容</h3><p>上述方法都是常用的匹配当前目录文件名的方法，如果<strong>还想要匹配子目录的内容</strong>，上述方法是显然不行的：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建子目录sub_dir，包含如下几个文件</span></span><br><span class="line">abbc.txt  abc.txt  acc.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果也想匹配出上面列出的文件</span></span><br><span class="line"><span class="comment"># 单纯的使用如下命令是不行的</span></span><br><span class="line">glob.glob(<span class="string">'./*'</span>)</span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abcd.txt'</span>, <span class="string">'./wre.txt'</span>, <span class="string">'./abbc.txt'</span>, <span class="string">'./a??c.txt'</span>, <span class="string">'./sub_dir'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样使用如下命令也不行</span></span><br><span class="line">glob.glob(<span class="string">'./*/*'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 只会得到子目录下的文件</span></span><br><span class="line">  [<span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>, <span class="string">'./sub_dir/abbc.txt'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是真正的做法就需要使用前面提到的recursive参数</span></span><br><span class="line">glob.glob(<span class="string">'./**'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"> <span class="comment"># 得到当前目录和子目录下所有文件</span></span><br><span class="line">  [<span class="string">'./'</span>, <span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abcd.txt'</span>, <span class="string">'./wre.txt'</span>, <span class="string">'./abbc.txt'</span>, <span class="string">'./a??c.txt'</span>, <span class="string">'./sub_dir'</span>, <span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>, <span class="string">'./sub_dir/abbc.txt'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'./**/a[b-d]c.txt'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 得到当前目录和子目录下所有符合pattern的文件</span></span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有的目录和子目录</span></span><br><span class="line">glob.glob(<span class="string">'./**/'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  [<span class="string">'./'</span>, <span class="string">'./sub_dir/'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="开头文件的匹配"><a href="#开头文件的匹配" class="headerlink" title=".开头文件的匹配"></a>.开头文件的匹配</h3><p><strong>如果目录中包含以<code>.</code>开头的文件，默认情况下不会对其进行匹配(使用<code>*</code>也达不到目的)，如果想要匹配需要显式指定<code>.</code></strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">  <span class="comment"># 不会匹配出.开头的 </span></span><br><span class="line">  [<span class="string">'card.gif'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'.c*'</span>)</span><br><span class="line">  <span class="comment"># 显式指定.，匹配出以.开头的文件</span></span><br><span class="line">  [<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="返回所有匹配文件名的迭代器-glob-iglob"><a href="#返回所有匹配文件名的迭代器-glob-iglob" class="headerlink" title="返回所有匹配文件名的迭代器-glob.iglob()"></a>返回所有匹配文件名的迭代器-glob.iglob()</h2><p><strong>命令</strong>：glob.iglob(pathname, *, recursive=False)</p><p><strong>参数</strong>：和前面的glob.glob()相同</p><p><strong>使用实例</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和glob的用法相同，只是会返回一个迭代器</span></span><br><span class="line">glob.iglob(<span class="string">'./*.txt'</span>)</span><br><span class="line">  <span class="comment"># 输出一个迭代器对象</span></span><br><span class="line">  &lt;generator object _iglob at <span class="number">0x7fa8dd9022b0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到具体的结果可以使用循环</span></span><br><span class="line">f=glob.iglob(<span class="string">'./*.txt'</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">   <span class="comment"># 遍历这个迭代器对象</span></span><br><span class="line">   <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  ./a?c.txt</span><br><span class="line">  ./abc.txt</span><br><span class="line">  ./acc.txt</span><br><span class="line">  ./adc.txt</span><br><span class="line">  ./abcd.txt</span><br><span class="line">  ./wre.txt</span><br><span class="line">  ./abbc.txt</span><br><span class="line">  ./a??c.txt</span><br></pre></td></tr></table></figure><p></p><p>其他用法参考<code>glob.glob()</code>。</p><hr><p><br></p><h2 id="转义元字符-glob-escape"><a href="#转义元字符-glob-escape" class="headerlink" title="转义元字符-glob.escape()"></a>转义元字符-glob.escape()</h2><p>前面提到了如果想要<strong>匹配一些特殊字符</strong>，如<code>?</code>可以<strong>使用<code>[]</code>将其括起来的方式表示原始字符</strong>，不进行通配，这里glob还专门提供了一个方法<code>glob.escape()</code>来达到上述的目的，其<strong>返回的是一个构造好的pattern，其中的特殊字符都会被<code>[]</code>括起来</strong>。</p><p>特殊的字符主要包括三个：<code>?</code>、<code>*</code>和<code>[</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回构造好的pattern</span></span><br><span class="line">glob.escape(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 和自己加[]效果是一样的 </span></span><br><span class="line">  <span class="string">'./a[?]c.txt'</span></span><br><span class="line"></span><br><span class="line">pattern=glob.escape(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">glob.glob(pattern)</span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/glob.html" target="_blank" rel="noopener">glob — Unix style pathname pattern expansion</a></li><li><a href="https://learnku.com/docs/pymotw/glob-file-name-rule-matching/3393" target="_blank" rel="noopener">7.4. glob — 文件名规则匹配</a></li><li><a href="https://www.jianshu.com/p/542e55b29324" target="_blank" rel="noopener">[Python] glob 模块(查找文件路径)</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Python中的常用模块&lt;code&gt;glob&lt;/code&gt;，其作用是&lt;strong&gt;查找特定目录中符合匹配规则的文件(或目录)&lt;/strong&gt;，主要包括三个函数：&lt;code&gt;glob.glob()&lt;/code&gt;、&lt;code&gt;glob.iglob()&lt;/code&gt;和&lt;code&gt;glob.escape()&lt;/code&gt;，其中最主要的函数是&lt;code&gt;glob.glob()&lt;/code&gt;，&lt;code&gt;glob.iglob()&lt;/code&gt;和&lt;code&gt;glob.glob()&lt;/code&gt;功能相似，但是&lt;strong&gt;返回的不再是列表而是迭代器对象&lt;/strong&gt;，而&lt;code&gt;glob.escape()&lt;/code&gt;主要是&lt;strong&gt;用来生成特殊字符匹配的pattern&lt;/strong&gt;；在使用中&lt;strong&gt;需要注意通配符和正则表达式的区别&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title> Python系列之shutil-高级文件操作</title>
    <link href="http://showteeth.tech/posts/51574.html"/>
    <id>http://showteeth.tech/posts/51574.html</id>
    <published>2019-03-31T14:11:24.000Z</published>
    <updated>2019-04-02T01:06:54.252Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python中用来进行<strong>高级文件操作</strong>的模块<code>shutil</code>，其主要包括文件或者目录的<strong>赋值</strong>、<strong>删除</strong>、<strong>剪切</strong>以及<strong>压缩和解压缩操作</strong>，是对上一个学习的<a href="http://showteeth.tech/posts/24368.html">os模块</a>功能的补充。</p></div><a id="more"></a><h2 id="shutil简介"><a href="#shutil简介" class="headerlink" title="shutil简介"></a>shutil简介</h2><p>前面已经学习了<strong>os模块中的常用目录及文件操作</strong>，虽然其中有很多非常强大的功能，但是<strong>其中也有一些需要补足的地方</strong>，比如<strong>删除非空文件夹(这个是os模块不能直接做到的)、文件复制</strong>等，基于上述的补足，这里学习一下Python中高级文件操作的模块shutil，注意高级文件操作是Python官方给的名称，不是我直接编出来的，所以可见这个模块的强大。从主要功能上来看<strong>shutil模块是对os模块的补充</strong>，主要针对文件的<code>拷贝</code>、<code>删除</code>、<code>移动</code>、<code>压缩</code>和<code>解压</code>操作。</p><hr><h2 id="高级文件目录管理"><a href="#高级文件目录管理" class="headerlink" title="高级文件目录管理"></a>高级文件目录管理</h2><h3 id="复制文件内容到另一个文件"><a href="#复制文件内容到另一个文件" class="headerlink" title="复制文件内容到另一个文件"></a>复制文件内容到另一个文件</h3><p><strong>命令</strong>：<code>shutil.copyfileobj(fsrc, fdst[, length=16*1024])</code>，其中的<code>fsrc</code>和<code>fdst</code>都是<code>file-like object</code>(使用<code>open()</code>方法打开后的文件对象)。</p><p><strong>功能</strong>：copy文件内容(部分或全部)到另一个文件(<strong>从fsrc复制到fdst中</strong>)，<strong>可以copy指定大小的内容</strong>，默认的大小为<code>16*1024</code>；<strong>如果length设置为负值</strong>，则会<strong>读取整个文件内容</strong>，而不是以块的方式进行迭代读取；<mark>fdst文件是清空重写还是追加写入需要开文件的打开模式</mark></p><p><strong>程序的源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyfileobj</span><span class="params">(fsrc, fdst, length=<span class="number">16</span>*<span class="number">1024</span>)</span>:</span></span><br><span class="line">    <span class="string">"""copy data from file-like object fsrc to file-like object fdst"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 程序的核心是这个read()</span></span><br><span class="line">        buf = fsrc.read(length)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buf:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        fdst.write(buf)</span><br></pre></td></tr></table></figure><p></p><p>看了上述源码，发现很多问题就很简单了，包括从什么写入什么，read()参数的理解等等，所以说<strong>看源码才是王道啊</strong>！</p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source文件内容</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"><span class="comment"># destination文件内容</span></span><br><span class="line">this <span class="keyword">is</span> destination file!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># source文件使用mode r读取打开</span></span><br><span class="line">s =open(<span class="string">'source.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># destination文件使用mode w写入打开</span></span><br><span class="line"><span class="comment"># w模式打开会清空文件内容</span></span><br><span class="line"><span class="comment"># 如果需要写入文件，可以使用a模式打开</span></span><br><span class="line">d=open(<span class="string">'target.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，从source文件复制到destination文件</span></span><br><span class="line">shutil.copyfileobj(s,d,length=<span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 由于前面使用了w模式打开文件，所以文件内容被清空了</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用追加模式打开destination文件</span></span><br><span class="line">d=open(<span class="string">'target.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line">shutil.copyfileobj(s,d,length=<span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 由于前面使用了a模式打开文件，所以source文件内容是追加在后面</span></span><br><span class="line">this <span class="keyword">is</span> target file!</span><br><span class="line">this <span class="keyword">is</span> source file!</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>部分或者全部复制</strong>：Note that if the <strong>current file position of the fsrc object is not 0</strong>, <strong>only the contents from the current file position to the end of the file will be copied</strong>.</li><li><code>fdst</code>文件是<strong>清空重写(w模式)</strong>还是<strong>追加写入(a模式)</strong>需要开文件的打开模式</li></ul></div><hr><h3 id="复制整个文件内容到另一个文件"><a href="#复制整个文件内容到另一个文件" class="headerlink" title="复制整个文件内容到另一个文件"></a>复制整个文件内容到另一个文件</h3><p><strong>命令</strong>：<code>shutil.copyfile(src, dst)</code>，和上一个命令比较相似，<strong>不同于上一个命令的是src和dst是字符串形式的文件路径而不是文件对象</strong>，也就是说使用之前不用open()。</p><p><strong>功能</strong>：拷贝整个文件(src)内容到另一个文件(dst)；如果source文件和destination<strong>文件是相同</strong>的，则会<strong>产生错误</strong>，同时<strong>destination文件必须是可写</strong>的，<strong>不然也会报错</strong>；同时<mark>需要注意如果目标文件destination中有内容，执行操作后会覆盖</mark>。</p><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyfile</span><span class="params">(src, dst, *, follow_symlinks=True)</span>:</span></span><br><span class="line">    <span class="string">"""Copy data from src to dst.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If follow_symlinks is not set and src is a symbolic link, a new</span></span><br><span class="line"><span class="string">    symlink will be created instead of copying the file it points to.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断文件是否相同，如果相同就报错</span></span><br><span class="line">    <span class="keyword">if</span> _samefile(src, dst):</span><br><span class="line">        <span class="keyword">raise</span> SameFileError(<span class="string">"&#123;!r&#125; and &#123;!r&#125; are the same file"</span>.format(src, dst))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> [src, dst]:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            st = os.stat(fn)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="comment"># File most likely does not exist</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># XXX What about other special files? (sockets, devices...)</span></span><br><span class="line">            <span class="keyword">if</span> stat.S_ISFIFO(st.st_mode):</span><br><span class="line">                <span class="keyword">raise</span> SpecialFileError(<span class="string">"`%s` is a named pipe"</span> % fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks <span class="keyword">and</span> os.path.islink(src):</span><br><span class="line">        os.symlink(os.readlink(src), dst)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(src, <span class="string">'rb'</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">            <span class="comment"># 这里的打开模式需要注意，会清空原始的target的文件内容</span></span><br><span class="line">            <span class="keyword">with</span> open(dst, <span class="string">'wb'</span>) <span class="keyword">as</span> fdst:</span><br><span class="line">                <span class="comment"># 调用了前面提到的shutil.copyfileobj</span></span><br><span class="line">                copyfileobj(fsrc, fdst)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source文件内容</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"><span class="comment"># destination文件内容</span></span><br><span class="line">this <span class="keyword">is</span> destination file!</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 先修改工作目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，从source文件复制到destination文件</span></span><br><span class="line">shutil.copyfile(<span class="string">'source.txt'</span>,<span class="string">'target.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 可见原始的文件内容被清空了</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>全部复制</strong>，<strong>目标文件的原有内容会被清空</strong>，可以从源码中文件的打开模式看出</li><li><strong>传递的是表示文件地址的字符串</strong>，而不是像前面的<code>shutil.copyfileobj(fsrc, fdst[, length=16*1024])</code>传递的是文件对象</li></ul></div><hr><h3 id="仅复制权限"><a href="#仅复制权限" class="headerlink" title="仅复制权限"></a>仅复制权限</h3><p><strong>命令</strong>：<code>shutil.copymode(src, dst)</code>：<strong>仅拷贝权限</strong>，内容、组、用户均不变；<strong>src和dst是字符串形式的文件路径而不是文件对象</strong></p><hr><h3 id="仅复制状态信息"><a href="#仅复制状态信息" class="headerlink" title="仅复制状态信息"></a>仅复制状态信息</h3><p><strong>命令</strong>：<code>shutil.copystat(src, dst)</code>：<strong>仅复制所有的状态信息，包括权限，组，用户，修改时间等</strong>；<strong>src和dst是字符串形式的文件路径而不是文件对象</strong></p><h3 id="复制文件内容和权限"><a href="#复制文件内容和权限" class="headerlink" title="复制文件内容和权限"></a>复制文件内容和权限</h3><p><strong>命令</strong>：<code>shutil.copy(src,dst)</code>：</p><ul><li><strong>同时复制文件的内容以及权限</strong></li><li><strong>相当于先copyfile()然后copymode()</strong></li><li>如果<strong>dst是一个目录</strong>，一个和src文件的basename相同的文件会被创建(或重写)；</li><li><strong>src和dst是字符串形式的文件路径而不是文件对象</strong></li></ul><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(src, dst, *, follow_symlinks=True)</span>:</span></span><br><span class="line">    <span class="string">"""Copy data and mode bits ("cp src dst"). Return the file's destination.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The destination may be a directory.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If follow_symlinks is false, symlinks won't be followed. This</span></span><br><span class="line"><span class="string">    resembles GNU's "cp -P src dst".</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If source and destination are the same file, a SameFileError will be</span></span><br><span class="line"><span class="string">    raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断，如果dst是一个目录，就使用src的basename创建文件</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(dst):</span><br><span class="line">        dst = os.path.join(dst, os.path.basename(src))</span><br><span class="line">    copyfile(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">    copymode(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 先修改工作目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，其中的dst为目录</span></span><br><span class="line">shutil.copy(<span class="string">'source.txt'</span>,<span class="string">'old_name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在old_name目录下生成了source.txt文件，和src名称相同，而且内容也相同</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="复制文件内容和状态"><a href="#复制文件内容和状态" class="headerlink" title="复制文件内容和状态"></a>复制文件内容和状态</h3><p><strong>命令</strong>：<code>shutil.copy2(src, dst)</code>：与copy函数功能大部分一致，<strong>只是会把所有的文件元数据()都复制(copymode-&gt;copystat)</strong>；同时<strong>复制文件的内容</strong>以及<strong>文件的所有状态信息</strong>；相当于先<code>copyfile()</code>后<code>copystat()</code>；元数据的复制是通过<code>shutil.copystat(src, dst)</code>来完成；</p><p><strong>补充(元数据的定义)</strong>：主要是<strong>描述数据属性(property)的信息</strong>，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能，<strong>是一种数据的数据</strong>，更多关于元数据可以看<a href="https://www.cnblogs.com/XWShuai/p/5936531.html" target="_blank" rel="noopener">这篇文章</a>。</p><hr><h3 id="排除指定的文件"><a href="#排除指定的文件" class="headerlink" title="排除指定的文件"></a>排除指定的文件</h3><p><strong>命令</strong>：<code>shutil.ignore_patterns(*patterns)</code>：接收<strong>一个或多个通配符字符串</strong>，然后<strong>创建</strong>一个可以被<strong>传递给shutil.copytree()方法的’ignore’参数</strong>的<strong>函数</strong>；当文件名与指定的通配符匹配时，则不会被赋值，也就是<strong>排除指定的文件</strong>。</p><hr><h3 id="递归复制目录和子目录"><a href="#递归复制目录和子目录" class="headerlink" title="递归复制目录和子目录"></a>递归复制目录和子目录</h3><p><strong>命令</strong>：<code>shutil.copytree(src, dst, symlinks=False, ignore=None)</code>：</p><ul><li><strong>递归</strong>地复制<strong>src目录及其子目录</strong>的<strong>文件</strong>和<strong>状态信息</strong>到目标<strong>目录dst</strong></li><li><strong>目标目录dst必须是不存在的</strong></li><li>如果目标目录的<strong>父目录不存在</strong>，则会<strong>一同创建</strong></li><li>目录的<strong>权限和时间</strong>通过<code>shutil.copystat()</code>来拷贝，<strong>单个文件</strong>通过<code>shutil.copy2()</code>来拷贝</li></ul><p><strong>参数</strong>：</p><ul><li><strong><code>symlinks</code>参数</strong>：指定是否复制软链接(小心陷入死循环)，<strong>如果为true</strong>，则以链接的形式进行复制；<strong>如果为false或者默认情况下</strong>，则会将链接文件的内容进行复制</li><li><strong><code>ignore</code>参数</strong>：指定<strong>不参与复制的文件</strong>，其值应该是一个<code>ignore_patterns()</code>方法；也是<strong>递归的ignore</strong>，每个目录下的符合ignore的都会被忽略，因为这个参数是传递给<code>copytree</code>的，而<code>copytree</code>是递归调用的</li></ul><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False, ignore=None, copy_function=copy2,</span></span></span><br><span class="line"><span class="function"><span class="params">             ignore_dangling_symlinks=False)</span>:</span></span><br><span class="line">    <span class="string">"""Recursively copy a directory tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The destination directory must not already exist.</span></span><br><span class="line"><span class="string">    If exception(s) occur, an Error is raised with a list of reasons.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the optional symlinks flag is true, symbolic links in the</span></span><br><span class="line"><span class="string">    source tree result in symbolic links in the destination tree; if</span></span><br><span class="line"><span class="string">    it is false, the contents of the files pointed to by symbolic</span></span><br><span class="line"><span class="string">    links are copied. If the file pointed by the symlink doesn't</span></span><br><span class="line"><span class="string">    exist, an exception will be added in the list of errors raised in</span></span><br><span class="line"><span class="string">    an Error exception at the end of the copy process.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can set the optional ignore_dangling_symlinks flag to true if you</span></span><br><span class="line"><span class="string">    want to silence this exception. Notice that this has no effect on</span></span><br><span class="line"><span class="string">    platforms that don't support os.symlink.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The optional ignore argument is a callable. If given, it</span></span><br><span class="line"><span class="string">    is called with the `src` parameter, which is the directory</span></span><br><span class="line"><span class="string">    being visited by copytree(), and `names` which is the list of</span></span><br><span class="line"><span class="string">    `src` contents, as returned by os.listdir():</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        callable(src, names) -&gt; ignored_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Since copytree() is called recursively, the callable will be</span></span><br><span class="line"><span class="string">    called once for each directory that is copied. It returns a</span></span><br><span class="line"><span class="string">    list of names relative to the `src` directory that should</span></span><br><span class="line"><span class="string">    not be copied.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The optional copy_function argument is a callable that will be used</span></span><br><span class="line"><span class="string">    to copy each file. It will be called with the source path and the</span></span><br><span class="line"><span class="string">    destination path as arguments. By default, copy2() is used, but any</span></span><br><span class="line"><span class="string">    function that supports the same signature (like copy()) can be used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># names中存储了目录所有文件的列表---不能区分文件或者目录</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    <span class="keyword">if</span> ignore <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        ignored_names = ignore(src, names)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ignored_names = set()</span><br><span class="line">    <span class="comment"># 这里是os.makedirs，所以是递归创建目录的，也就是可以创建父目录</span></span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="comment"># 判断是不是复制ignore的条件，符合就直接进行下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> ignored_names:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                <span class="comment"># 函数传递的参数</span></span><br><span class="line">                <span class="keyword">if</span> symlinks:</span><br><span class="line">                    <span class="comment"># We can't just leave it to `copy_function` because legacy</span></span><br><span class="line">                    <span class="comment"># code with a custom `copy_function` may rely on copytree</span></span><br><span class="line">                    <span class="comment"># doing the right thing.</span></span><br><span class="line">                    os.symlink(linkto, dstname)</span><br><span class="line">                    copystat(srcname, dstname, follow_symlinks=<span class="keyword">not</span> symlinks)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># ignore dangling symlink if the flag is on</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(linkto) <span class="keyword">and</span> ignore_dangling_symlinks:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># otherwise let the copy occurs. copy2 will raise an error</span></span><br><span class="line">                    <span class="keyword">if</span> os.path.isdir(srcname):</span><br><span class="line">                        <span class="comment"># 这部分是递归复制</span></span><br><span class="line">                        copytree(srcname, dstname, symlinks, ignore,</span><br><span class="line">                                 copy_function)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        copy_function(srcname, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks, ignore, copy_function)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Will raise a SpecialFileError for unsupported file types</span></span><br><span class="line">                copy_function(srcname, dstname)</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># Copying file access times may fail on Windows</span></span><br><span class="line">        <span class="keyword">if</span> getattr(why, <span class="string">'winerror'</span>, <span class="keyword">None</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            errors.append((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略pyc文件和tmp文件</span></span><br><span class="line"><span class="comment"># 注意destination肯定是不存在的</span></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br><span class="line">copytree(<span class="string">'folder1'</span>, <span class="string">'folder2'</span>, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制链接，不是复制链接指向文件的内容</span></span><br><span class="line">copytree(<span class="string">'f1'</span>, <span class="string">'f2'</span>, symlinks=<span class="keyword">True</span>, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="递归删除"><a href="#递归删除" class="headerlink" title="递归删除"></a>递归删除</h3><p><strong>命令</strong>：<code>shutil.rmtree(path[, ignore_errors[, onerror]])</code>，<strong>递归地删除目录(path，不能为链接目录)及子目录内的文件</strong>。注意！该方法不会询问yes或no，被删除的文件也不会出现在回收站里，<strong>请务必小心</strong>！</p><p><strong>参数</strong>：</p><ul><li><strong><code>path</code></strong>：指定目录，但不能是链接指向的目录，传递的是<strong>字符串形式的文件路径而不是文件对象</strong></li><li><strong><code>ignore_errors</code></strong>：设置为true，删除过程中的出错不会被抛出，会被忽略；如果为false或者忽略这个参数，删除过程中的错误会调用onerror中的错误处理方式进行处理，如果<code>onerror</code>中没有定义处理方式，就会抛出错误。</li><li><strong>onerror</strong>：一旦提供这个参数，就必须有三个参数<code>function</code>、<code>path</code>和<code>excinfo</code>.<ul><li><code>function</code>：抛出异常的函数，是<code>os.path.islink()</code>、<code>os.listdir()</code>、 <code>os.remove()</code>或者<code>os.rmdir()</code></li><li><code>path</code>：传递给function参数的path名</li><li><code>excinfo</code>：<code>sys.exc_info()</code>返回的异常信息</li><li><code>onerror</code>的异常不会被捕获</li></ul></li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="comment"># 去除文件的只读属性，尝试再次删除</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    <span class="comment"># 这里的func是针对前面抛出异常的操作</span></span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>需要注意的方面</strong>：<br><strong>删除路径的最后一个目录，而不是整个路径</strong>，例如<code>shutil.rmtree(&#39;user/tester/noob&#39;)</code>只会删除最后的<code>noob</code>目录的所有内容，而不会将整个路径<code>&#39;user/tester/noob&#39;</code>包含的文件夹都删除，参考<a href="https://stackoverflow.com/questions/10873364/shutil-rmtree-clarification" target="_blank" rel="noopener">这个链接</a>。</p></div><hr><h3 id="剪切目录"><a href="#剪切目录" class="headerlink" title="剪切目录"></a>剪切目录</h3><p><strong>命令</strong>：<code>shutil.move(src, dst)</code>，递归地移动文件或者目录，类似<code>mv</code>命令；如果destination是一个已经存在的目录，src会直接移动到这个目录中；如果destination已经存在但不是一个目录，destination将会被重写；如果是同一个文件或者目录，重命名。</p><hr><h3 id="查找文件路径"><a href="#查找文件路径" class="headerlink" title="查找文件路径"></a>查找文件路径</h3><p><strong>命令</strong>：<code>which(cmd, mode=os.F_OK | os.X_OK, path=None)</code>，返回文件路径，类似Linux的<code>which</code>命令</p><p><strong>参数讲解</strong>：</p><ul><li><strong><code>cmd</code></strong>：需要查找的内容-字符串形式</li><li><strong><code>mode</code></strong>：查找内容的权限，默认情况<code>os.F_OK</code>：path是否存在以及<code>os.X_OK</code>：path是否可执行</li><li><strong><code>path</code></strong>：在指定路径中查找</li></ul><p><strong>使用场景</strong>：典型的使用场景是在环境变量 <code>PATH</code> 定义的路径中查找<strong>可执行程序</strong>的位置，如果<strong>没有找到文件</strong>，<code>which()</code> 返回 <code>None</code></p><hr><p><br></p><h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><h3 id="查看支持的压缩文件格式"><a href="#查看支持的压缩文件格式" class="headerlink" title="查看支持的压缩文件格式"></a>查看支持的压缩文件格式</h3><p><strong>命令</strong>：<code>shutil.get_archive_formats()</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> format, description <span class="keyword">in</span> shutil.get_archive_formats():</span><br><span class="line">    print(<span class="string">'&#123;:&lt;5&#125;: &#123;&#125;'</span>.format(format, description))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    bztar: bzip2<span class="string">'ed tar-file</span></span><br><span class="line"><span class="string">    gztar: gzip'</span>ed tar-file</span><br><span class="line">    tar  : uncompressed tar file</span><br><span class="line">    xztar: xz<span class="string">'ed tar-file</span></span><br><span class="line"><span class="string">    zip  : ZIP file</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建归档或压缩文件"><a href="#创建归档或压缩文件" class="headerlink" title="创建归档或压缩文件"></a>创建归档或压缩文件</h3><p><strong>命令</strong>：<code>shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>base_name</code></strong>：<strong>压缩后的文件名(不包含拓展名)</strong>；如果不指定绝对路径，则压缩文件保存在当前目录下；<strong>这个参数必须指定</strong></li><li><strong><code>format</code></strong>：<strong>压缩格式</strong>，可以是<code>zip</code>、<code>tar</code>、<code>bztar(tar.bz2)</code>、<code>gztar(tar.gz)</code>、<code>xztar</code>中的一种；<strong>这个参数也必须指定</strong></li><li><strong><code>root_dir</code></strong>：<strong>设置压缩包里的根目录</strong>，即在创建归档之前先切换到它指定的目录，一般使用默认值，不特别指定</li><li><strong><code>base_dir</code></strong>：要<strong>进行压缩的源文件或目录</strong>，如果<strong>没有提供</strong>则<strong>对root_dir目录下的所有文件进行归档压缩</strong></li><li><strong><code>dry_run</code></strong>：如果值为Ture表示不会创建归档，但是操作输出会被记录到logger中，<strong>可用于测试</strong></li><li><strong><code>owner</code></strong>：<strong>用户</strong>，默认当前用户</li><li><strong><code>group</code></strong>：<strong>组</strong>，默认当前组</li><li><strong><code>logger</code></strong>：用于<strong>记录日志</strong>，通常是logging.Logger对象</li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供base_dir</span></span><br><span class="line">shutil.make_archive(base_name=<span class="string">"test"</span>, format=<span class="string">"gztar"</span>,  base_dir=<span class="string">"./cat"</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    <span class="string">'test.tar.gz'</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 注意文件中显示的路径，如果前面设置的是全路径，会创建全路径的文件夹</span></span><br><span class="line">    drwxrwxr-x user/user     <span class="number">0</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./cat/</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">13</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">28</span> ./cat/test1.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">7</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./cat/test2.txt</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">20</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./cat/test3.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">14</span> ./cat/filename</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./cat/test4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只提供root_dir</span></span><br><span class="line">shutil.make_archive(base_name=<span class="string">"test2"</span>, format=<span class="string">"gztar"</span>,  root_dir=<span class="string">"./cat"</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    <span class="string">'absolute_path/test2.tar.gz'</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    drwxrwxr-x user/user     <span class="number">0</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">13</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">28</span> ./test1.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">7</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./test2.txt</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">20</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./test3.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">14</span> ./filename</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./test4.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>设置<code>base_dir</code>之后</strong>会在压缩的文件中会出现设置的<code>base_dir</code>路径(<strong>保留了原始路径信息</strong>)，这个需要特别注意，如果设置的是全路径指向某一个文件，解压的结果中也会包含那个全路径；<strong>如果设置的是<code>root_dir</code>，不设置<code>base_dir</code></strong>，默认对<code>root_dir</code>中的进行压缩，则不会有上述麻烦，生成的文件解压后直接可以看到内容，<strong>不会出现全路径</strong>。</p></div><hr><h3 id="解压缩后缀与格式的对应"><a href="#解压缩后缀与格式的对应" class="headerlink" title="解压缩后缀与格式的对应"></a>解压缩后缀与格式的对应</h3><p><strong>命令</strong>：<code>shutil.get_unpack_formats()</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> format, exts, description <span class="keyword">in</span> shutil.get_unpack_formats():</span><br><span class="line">    print(<span class="string">'&#123;:&lt;5&#125;: &#123;&#125;, names ending in &#123;&#125;'</span>.format(</span><br><span class="line">        format, description, exts))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">    bztar: bzip2<span class="string">'ed tar-file, names ending in ['</span>.tar.bz2<span class="string">', '</span>.tbz2<span class="string">']</span></span><br><span class="line"><span class="string">    gztar: gzip'</span>ed tar-file, names ending <span class="keyword">in</span> [<span class="string">'.tar.gz'</span>, <span class="string">'.tgz'</span>]</span><br><span class="line">    tar  : uncompressed tar file, names ending <span class="keyword">in</span> [<span class="string">'.tar'</span>]</span><br><span class="line">    xztar: xz<span class="string">'ed tar-file, names ending in ['</span>.tar.xz<span class="string">', '</span>.txz<span class="string">']</span></span><br><span class="line"><span class="string">    zip  : ZIP file, names ending in ['</span>.zip<span class="string">']</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="解压缩或解包源文件"><a href="#解压缩或解包源文件" class="headerlink" title="解压缩或解包源文件"></a>解压缩或解包源文件</h3><p><strong>命令</strong>：<code>shutil.unpack_archive(filename[, extract_dir[, format]])</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>filename</code></strong>：是压缩文档的<strong>完整路径</strong></li><li><strong><code>extract_dir</code></strong>：是<strong>解压缩路径</strong>，默认为当前目录</li><li><strong><code>format</code></strong>：是<strong>压缩格式</strong>，<strong>默认使用文件后缀名代码的压缩格式</strong>，可以是<code>zip</code>、<code>tar</code>、<code>bztar(tar.bz2)</code>、<code>gztar(tar.gz)</code>、<code>xztar</code>中的一种；如果<strong>不提供这个参数</strong>，程序会<strong>根据filename的后缀名</strong>来自动选择方法。</li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># filename是全路径</span></span><br><span class="line">shutil.unpack_archive(<span class="string">"full_path/test.tar.gz"</span>, <span class="string">"./test"</span>, <span class="string">'gztar'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/61" target="_blank" rel="noopener">shutil</a></li><li><a href="https://www.cnblogs.com/yyds/p/6427349.html" target="_blank" rel="noopener">Python之文件与目录操作（os、zipfile、tarfile、shutil）</a></li><li><a href="https://docs.python.org/3/library/shutil.html" target="_blank" rel="noopener">shutil — High-level file operations</a></li><li><a href="https://learnku.com/docs/pymotw/shutil-high-order-file-operation/3397" target="_blank" rel="noopener">实例教程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python中用来进行&lt;strong&gt;高级文件操作&lt;/strong&gt;的模块&lt;code&gt;shutil&lt;/code&gt;，其主要包括文件或者目录的&lt;strong&gt;赋值&lt;/strong&gt;、&lt;strong&gt;删除&lt;/strong&gt;、&lt;strong&gt;剪切&lt;/strong&gt;以及&lt;strong&gt;压缩和解压缩操作&lt;/strong&gt;，是对上一个学习的&lt;a href=&quot;http://showteeth.tech/posts/24368.html&quot;&gt;os模块&lt;/a&gt;功能的补充。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之os-使用操作系统相关功能</title>
    <link href="http://showteeth.tech/posts/24368.html"/>
    <id>http://showteeth.tech/posts/24368.html</id>
    <published>2019-03-31T03:08:21.000Z</published>
    <updated>2019-04-01T10:08:08.177Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python使用操作系统相关功能的os模块，其主要功能包括：<strong>系统相关</strong>、<strong>目录及文件操作</strong>、<strong>执行命令和管理进程</strong>，这里主要学习了<strong>常用的目录及文件操作</strong>，其中涉及到的功能非常多，需要时可以查看使用，最后还学习了<strong>系统相关中的查看和新增环境变量操作</strong>，较为实用。</p></div><a id="more"></a><h2 id="os模块简介"><a href="#os模块简介" class="headerlink" title="os模块简介"></a>os模块简介</h2><ul><li><code>os</code>模块是Python标准库中的一个用于<strong>访问操作系统相关功能</strong>的模块，<code>os</code>模块提供了一种<strong>可移植</strong>的使用操作系统功能的方法</li><li>使用<code>os</code>模块中提供的接口，可以<strong>实现跨平台访问</strong>，但是，<strong>并不是所有的</strong><code>os</code>模块中的接口在全平台都通用，<strong>有些接口的实现是依赖特定平台</strong>的，比如linux相关的文件权限管理和进程管理</li><li><code>os</code>模块的<strong>主要功能</strong>：<strong>系统相关</strong>、<strong>目录及文件操作</strong>、<strong>执行命令和管理进程</strong></li><li>在使用<code>os</code>模块的时候，如果出现了问题，会抛出<code>OSError</code>异常，表明<strong>无效的路径名或文件名</strong>，<strong>或者路径名(文件名)无法访问</strong>，<strong>或者当前操作系统不支持该操作</strong></li></ul><hr><h2 id="目录及文件操作"><a href="#目录及文件操作" class="headerlink" title="目录及文件操作"></a>目录及文件操作</h2><p>因为平常使用<code>os</code>模块一般也就是文件以及目录操作，所以这里先学习文件及目录相关操作的命令。<br><code>os</code>模块中包含了一系列文件操作相关的函数，<strong>其中有一部分是Linux平台专用方法</strong>(Linux是用C写的，底层的<code>libc</code>库和系统调用的接口都是<code>C API</code>，Python的<code>os</code>模块中包括了对这些接口的Python实现，通过Python的<code>os</code>模块，可以调用Linux系统的一些底层功能，进行系统编程，关于Linux的相关方法，内容较为复杂，可根据需要自行查阅官方文档），这里只介绍一些<strong>常用的，各平台通用</strong>的方法(包括了<code>os</code>模块和<code>os.path</code>模块):</p><table><thead><tr><th width="30%">方法和变量</th><th width="70%">用途</th></tr></thead><tbody><tr><td><code>os.getcwd()</code></td><td>获取当前工作目录，即当前python脚本工作的目录路径</td></tr><tr><td><code>os.chdir("dirname")</code></td><td>改变当前脚本工作目录；相当于shell下cd</td></tr><tr><td><code>os.curdir</code></td><td>返回当前目录: ('.')</td></tr><tr><td><code>os.pardir</code></td><td>获取当前目录的父目录字符串名：('..')</td></tr><tr><td><code>os.makedirs('dir1/dir2')</code></td><td>可生成<strong>多层递归目录</strong></td></tr><tr><td><code>os.removedirs(‘dirname1’)</code></td><td><strong>递归删除空</strong>目录（要小心）</td></tr><tr><td><code>os.mkdir('dirname')</code></td><td>生成<strong>单级</strong>目录</td></tr><tr><td><code>os.rmdir('dirname')</code></td><td><strong>删除单级空</strong>目录，若目录不为空则无法删除并报错</td></tr><tr><td><code>os.listdir('dirname')</code></td><td>列出指定目录下的所有文件和子目录，<strong>包括隐藏文件</strong></td></tr><tr><td><code>os.scandir('dirname')</code></td><td>更详细地列出所有文件和子目录，相当于<code>os.listdir('dirname')</code>的升级版</td></tr><tr><td><code>os.remove('filename')</code></td><td>删除一个文件</td></tr><tr><td><code>os.rename("oldname","new")</code></td><td>重命名文件/目录</td></tr><tr><td><code>os.stat('path/filename')</code></td><td>获取文件/目录信息</td></tr><tr><td><code>os.access(path, mode)</code></td><td>检测文件或目录的访问权限</td></tr><tr><td><code>os.chmod(path, mode)</code></td><td>修改文件权限</td></tr><tr><td><code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code></td><td>遍历整个目录结构，对每一个目录都返回一个三元元组(dirpath, dirnames, filenames)</td></tr><tr><td><code>os.path.abspath(path)</code></td><td>返回path规范化的<strong>绝对路径</strong></td></tr><tr><td><code>os.path.split(path)</code></td><td>将path分割成<strong>目录和文件名二元组返回</strong></td></tr><tr><td><code>os.path.splitext(path)</code></td><td>分割路径为后缀名(eg:.txt)和之前部分</td></tr><tr><td><code>os.path.dirname(path)</code></td><td>返回path的目录。其实就是<code>os.path.split(path)</code>的第一个元素</td></tr><tr><td><code>os.path.basename(path)</code></td><td>返回path最后的文件名。如果path以<code>／</code>或<code>\</code>结尾，那么就会返回空值。</td></tr><tr><td><code>os.path.exists(path或者file)</code></td><td>如果path存在，返回True；如果path不存在，返回False</td></tr><tr><td><code>os.path.isabs(path)</code></td><td>如果path是绝对路径，返回True</td></tr><tr><td><code>os.path.isfile(path)</code></td><td>如果path是一个存在的文件，返回True。否则返回False</td></tr><tr><td><code>os.path.isdir(path)</code></td><td>如果path是一个存在的目录，则返回True。否则返回False</td></tr><tr><td><code>os.path.join(path1[, path2[, ...]])</code></td><td>将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</td></tr><tr><td><code>os.path.getatime(path)</code></td><td>返回path所指向的文件或者目录的最后存取时间</td></tr><tr><td><code>os.path.getmtime(path)</code></td><td>返回path所指向的文件或者目录的最后修改时间</td></tr><tr><td><code>os.path.relpath(path, start)</code></td><td>返回path<strong>相对于start(比如os.curdir)的相对路径,start默认为根目录</strong></td></tr><tr><td><code>os.path.realpath(path)</code></td><td>获取path的真实、绝对路径(<strong>可用于获取软链接文件指向的文件路径</strong>)</td></tr><tr><td><code>os.path.samefile(path1, path2)</code></td><td>判断path1和path2是否为同一个文件</td></tr><tr><td><code>os.path.getsize(filename)</code></td><td>返回文件包含的字符数量</td></tr></tbody></table><h3 id="获取当前工作目录-os-getcwd"><a href="#获取当前工作目录-os-getcwd" class="headerlink" title="获取当前工作目录-os.getcwd()"></a>获取当前工作目录-os.getcwd()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回当前工作目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python文件地址：</span></span><br><span class="line"><span class="comment"># "c:\FastFolder\learn_test\os_learn.py"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出工作目录而不是python文件所在的目录</span></span><br><span class="line"><span class="comment"># 如果需要得到文件所在目录，后续有专门的命令</span></span><br><span class="line">c:\FastFolder</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="改变当前工作目录-os-chdir"><a href="#改变当前工作目录-os-chdir" class="headerlink" title="改变当前工作目录-os.chdir()"></a>改变当前工作目录-os.chdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变工作目录</span></span><br><span class="line"><span class="comment"># 将工作目录改变到py文件所在的目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变工作目录之后输出当前工作目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现此时的工作目录已经改变</span></span><br><span class="line">c:\FastFolder\learn_test</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建单层目录-os-mkdir"><a href="#创建单层目录-os-mkdir" class="headerlink" title="创建单层目录-os.mkdir()"></a>创建单层目录-os.mkdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先返回当前目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层目录-相对路径</span></span><br><span class="line">mk_dir=<span class="string">'test_single_dir'</span></span><br><span class="line">os.mkdir(mk_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层目录-绝对路径</span></span><br><span class="line">mk_dir=<span class="string">r'c:\FastFolder\learn_test\python_test\test_single_dir'</span></span><br><span class="line">os.mkdir(mk_dir)</span><br></pre></td></tr></table></figure><div class="note info"><p>os.mkdir()还可以设置创建的目录的mode权限，具体参考<a href="https://docs.python.org/3/library/os.html#os.mkdir" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="删除单层空目录-os-rmdir"><a href="#删除单层空目录-os-rmdir" class="headerlink" title="删除单层空目录-os.rmdir()"></a>删除单层空目录-os.rmdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除单层目录，相对路径和绝对路径均可</span></span><br><span class="line">os.rmdir(mk_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录非空会报错</span></span><br><span class="line"><span class="comment"># OSError: [WinError 145] 目录不是空的。</span></span><br><span class="line">os.rmdir(mk_dir)</span><br></pre></td></tr></table></figure><hr><h3 id="递归创建目录-os-makedirs"><a href="#递归创建目录-os-makedirs" class="headerlink" title="递归创建目录-os.makedirs()"></a>递归创建目录-os.makedirs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先返回当前目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录-相对路径</span></span><br><span class="line">mk_dirs=<span class="string">'test_dir/test'</span></span><br><span class="line">os.makedirs(mk_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录-绝对路径</span></span><br><span class="line">mk_dirs=<span class="string">r'c:\FastFolder\learn_test\python_test\test_dir\test'</span></span><br><span class="line">os.makedirs(mk_dirs)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line"><span class="string">'c:\FastFolder'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录创建了test_dir/test目录</span></span><br><span class="line"><span class="comment"># 在指定的绝对路径下创建了test_dir/test目录</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>os.makedirs()还可以设置创建的目录的mode权限，具体参考<a href="https://docs.python.org/3/library/os.html#os.makedirs" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="递归删除多级空目录-os-removedirs"><a href="#递归删除多级空目录-os-removedirs" class="headerlink" title="递归删除多级空目录-os.removedirs()"></a>递归删除多级空目录-os.removedirs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归删除多级目录-绝对或者相对路径均可</span></span><br><span class="line">os.removedirs(mk_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除也需要</span></span><br><span class="line"><span class="comment"># 如果目录非空会报错：</span></span><br><span class="line"><span class="comment"># OSError: [WinError 145] 目录不是空的。: 'test_dir'</span></span><br><span class="line">os.removedirs(<span class="string">'test_dir'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>关于创建和删除单层、多层目录：</p><ul><li>创建单层和删除单层可以使用：<code>os.mkdir()</code>、<code>os.rmdir()</code></li><li>创建多层和删除多层可以使用：<code>os.makedirs()</code>、<code>os.removedirs()</code></li><li>两者之间不仅仅是<code>dirs</code>和<code>dir</code>的区别，还有<code>make</code>和<code>mk</code>、<code>remove</code>和<code>rm</code>的区别<br><br><br>Python删除目录os.removedirs()的过程：If the <strong>leaf directory is succesfully removed</strong>, removedirs <strong>tries to successively remove every parent directory displayed in path</strong>.</li></ul></div><hr><h3 id="列出所有文件和子目录-os-listdir"><a href="#列出所有文件和子目录-os-listdir" class="headerlink" title="列出所有文件和子目录-os.listdir()"></a>列出所有文件和子目录-os.listdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下的所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># 不会显示子目录内容</span></span><br><span class="line">os.listdir(<span class="string">'.'</span>)</span><br><span class="line">os.listdir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定目录下的所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># 这里使用了相对路径，使用绝对路径也是可以的</span></span><br><span class="line">os.listdir(<span class="string">'./python_test'</span>)</span><br><span class="line">os.listdir(<span class="string">'python_test'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># python_test为目录，os_learn.py为文件</span></span><br><span class="line">[<span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">'all.log'</span>, <span class="string">'argparse_parent_with_group.py'</span>, <span class="string">'argparse_test.py'</span>, <span class="string">'error.log'</span>, <span class="string">'log.txt'</span>, <span class="string">'logging_learn.py'</span>, <span class="string">'main'</span>, <span class="string">'my.log'</span>, <span class="string">'myapp.log'</span>, <span class="string">'test_dir'</span>, <span class="string">'__pycache__'</span>]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>os.listdir()</code>的缺点在于返回值为字符串组成的列表，<strong>不能从返回值中分辨它们是文件、目录还是符号连接</strong></p></div><hr><h3 id="更详细地列出所有文件和子目录-os-scandir"><a href="#更详细地列出所有文件和子目录-os-scandir" class="headerlink" title="更详细地列出所有文件和子目录-os.scandir()"></a>更详细地列出所有文件和子目录-os.scandir()</h3><p>针对上面<code>os.listdir()</code>不能从返回值中分辨它们是文件、目录还是符号连接，使用<code>os.scandir()</code>扫描目录时，返回目录中每一个项目 <code>DirEntry</code> 实例的序列，这种对象有<strong>几种属性和方法(是否为目录、文件或者链接)</strong>，可以用于访问文件的元数据：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir():</span><br><span class="line">    <span class="comment"># 判断是否为目录</span></span><br><span class="line">    <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">        typ = <span class="string">'dir'</span></span><br><span class="line">    <span class="comment"># 判断是否为文件</span></span><br><span class="line">    <span class="keyword">elif</span> entry.is_file():</span><br><span class="line">        typ = <span class="string">'file'</span></span><br><span class="line">      <span class="comment"># 判断是否为链接</span></span><br><span class="line">    <span class="keyword">elif</span> entry.is_symlink():</span><br><span class="line">        typ = <span class="string">'link'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        typ = <span class="string">'unknown'</span></span><br><span class="line">    print(<span class="string">'&#123;name&#125; &#123;typ&#125;'</span>.format(</span><br><span class="line">        name=entry.name,</span><br><span class="line">        typ=typ,</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_name.txt file</span><br><span class="line">old_name dir</span><br><span class="line">os_learn.py file</span><br><span class="line">python_test dir</span><br><span class="line">tempCodeRunnerFile.py file</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="删除文件-os-remove"><a href="#删除文件-os-remove" class="headerlink" title="删除文件-os.remove()"></a>删除文件-os.remove()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下的文件</span></span><br><span class="line">os.remove(<span class="string">'to_remove.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定目录下的文件</span></span><br><span class="line">os.remove(<span class="string">r"c:\FastFolder\learn_test\to_remove.txt"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="重命名文件或目录-os-rename"><a href="#重命名文件或目录-os-rename" class="headerlink" title="重命名文件或目录-os.rename()"></a>重命名文件或目录-os.rename()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录所有文件</span></span><br><span class="line">os.listdir()</span><br><span class="line">  <span class="comment"># old_name为文件夹，old_name.txt为文件</span></span><br><span class="line">  [<span class="string">'old_name'</span>, <span class="string">'old_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名目录</span></span><br><span class="line">os.rename(<span class="string">'old_name'</span>,<span class="string">'new_name'</span>)</span><br><span class="line">  <span class="comment"># 不管目录是否为空，都可以正常重命名</span></span><br><span class="line">  [<span class="string">'new_name'</span>, <span class="string">'old_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命令文件</span></span><br><span class="line">os.rename(<span class="string">'old_name.txt'</span>,<span class="string">'new_name.txt'</span>)</span><br><span class="line">  [<span class="string">'new_name'</span>, <span class="string">'new_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="获取文件或目录信息-os-stat"><a href="#获取文件或目录信息-os-stat" class="headerlink" title="获取文件或目录信息-os.stat()"></a>获取文件或目录信息-os.stat()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与os.listdir()不同，必须要指定目录</span></span><br><span class="line">os.stat(<span class="string">'.'</span>)</span><br><span class="line">  os.stat_result(st_mode=<span class="number">16895</span>, st_ino=<span class="number">1688849860706458</span>, st_dev=<span class="number">3422898436</span>, st_nlink=<span class="number">1</span>, st_uid=<span class="number">0</span>, st_gid=<span class="number">0</span>, st_size=<span class="number">0</span>, st_atime=<span class="number">1554014658</span>, st_mtime=<span class="number">1554014658</span>, st_ctime=<span class="number">1553005707</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="检测文件或目录的访问权限-os-access-path-mode"><a href="#检测文件或目录的访问权限-os-access-path-mode" class="headerlink" title="检测文件或目录的访问权限-os.access(path, mode)"></a>检测文件或目录的访问权限-os.access(path, mode)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#  __file__：当前脚本的路径</span></span><br><span class="line">print(<span class="string">'Testing:'</span>, __file__)</span><br><span class="line">print(<span class="string">'Exists:'</span>, os.access(__file__, os.F_OK))</span><br><span class="line">print(<span class="string">'Readable:'</span>, os.access(__file__, os.R_OK))</span><br><span class="line">print(<span class="string">'Writable:'</span>, os.access(__file__, os.W_OK))</span><br><span class="line">print(<span class="string">'Executable:'</span>, os.access(__file__, os.X_OK))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为True或者False</span></span><br></pre></td></tr></table></figure><div class="note info"><p>mode包含<code>F_OK</code>、<code>R_OK</code>、<code>W_OK</code>和<code>X_OK</code>：</p><ul><li><code>os.F_OK</code>：作为access()的mode参数，测试<strong>path是否存在</strong></li><li><code>os.R_OK</code>：包含在access()的mode参数中 ， 测试<strong>path是否可读</strong></li><li><code>os.W_OK</code>：包含在access()的mode参数中 ， 测试<strong>path是否可写</strong></li><li><code>os.X_OK</code>：包含在access()的mode参数中 ，测试<strong>path是否可执行</strong></li></ul></div><hr><h3 id="修改文件权限-os-chmod-path-mode"><a href="#修改文件权限-os-chmod-path-mode" class="headerlink" title="修改文件权限-os.chmod(path, mode)"></a>修改文件权限-os.chmod(path, mode)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> stat</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'os_stat_chmod_example.txt'</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(filename):</span><br><span class="line">    os.unlink(filename)</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'contents'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 函数判断文件当前的权限</span></span><br><span class="line"><span class="comment"># stat.S_IMODE：返回文件权限的chmod格式</span></span><br><span class="line">existing_permissions = stat.S_IMODE(os.stat(filename).st_mode)</span><br><span class="line"><span class="comment"># 得到的是类似438这种的code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.access(filename, os.X_OK):</span><br><span class="line">    print(<span class="string">'Adding execute permission'</span>)</span><br><span class="line">    <span class="comment"># stat.S_IXUSR：拥有者具有执行权限</span></span><br><span class="line">    new_permissions = existing_permissions | stat.S_IXUSR</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Removing execute permission'</span>)</span><br><span class="line">    <span class="comment"># 使用 xor 异或清除用户的执行权限</span></span><br><span class="line">    <span class="comment"># 异或操作：属于A或B，但不属于A交B---&gt;(A-B)∪(B-A)</span></span><br><span class="line">    new_permissions = existing_permissions ^ stat.S_IXUSR</span><br><span class="line"></span><br><span class="line">os.chmod(filename, new_permissions)</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>权限分组(分为三组)</strong>：</p><ul><li><strong>第一组</strong>：文件或目录所有者的权限</li><li><strong>第二组</strong>：与文件或目录所有者同一组的用户的权限</li><li><strong>第三组</strong>：不与文件或目录所有者同组的其他用户(系统中其他用户)的权限</li></ul><p><strong>使用Python的<code>os.chmod</code>修改权限时需要注意进制转换</strong>：<br>如果像在Linux中修改权限为<strong>664(八进制)</strong>，在Python中需要为<strong>0664</strong>，原因：If you’re wondering why that leading zero is important, it’s because <strong>permissions are set as an octal integer(八进制整数)</strong>, and <strong>Python automagically treats any integer with a leading zero as octal(Python会将带0的视为八进制数)</strong>. So <strong>os.chmod(“file”, 436) (in decimal-十进制)</strong>would give the same result.</p><p>进制转换参考<a href="https://stackoverflow.com/questions/15607903/python-module-os-chmodfile-664-does-not-change-the-permission-to-rw-rw-r-bu" target="_blank" rel="noopener">这个链接</a></p><p>关于<code>stat</code>模块和<code>os.stat()</code>参考<a href="https://www.cnblogs.com/maseng/p/3386140.html" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="返回绝对路径-os-path-abspath"><a href="#返回绝对路径-os-path-abspath" class="headerlink" title="返回绝对路径-os.path.abspath()"></a>返回绝对路径-os.path.abspath()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回绝对路径</span></span><br><span class="line"><span class="comment"># 注意和os.stat()相同，必须要指定目录</span></span><br><span class="line">os.path.abspath(<span class="string">'.'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回文件的绝对路径</span></span><br><span class="line">os.path.abspath(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割路径为目录和文件名-os-path-split"><a href="#分割路径为目录和文件名-os-path-split" class="headerlink" title="分割路径为目录和文件名-os.path.split()"></a>分割路径为目录和文件名-os.path.split()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果指定的path是相对路径，目录则会返回相对路径</span></span><br><span class="line">os.path.split(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回元组，第一个元素为目录，第二个元素为文件名</span></span><br><span class="line">  (<span class="string">'.'</span>, <span class="string">'new_name.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最后是以/结尾，返回的文件名为空</span></span><br><span class="line">os.path.split(<span class="string">'./'</span>) )</span><br><span class="line">  (<span class="string">'.'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定的路径为绝对路径，返回绝对路径的目录和文件名</span></span><br><span class="line">os.path.split(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回元组，第一个元素为目录，第二个元素为文件名</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test'</span>, <span class="string">'new_name.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最后是以/结尾，返回的文件名为空</span></span><br><span class="line">os.path.split(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 感觉应该就是直接从最后一个/号进行了分割，前面的返回目录，后面的作为文件名</span></span><br><span class="line"><span class="comment"># 如果path中没有/，则目录会为空，文件名不为空</span></span><br><span class="line">os.path.split(<span class="string">'test.sh'</span>)</span><br><span class="line">  (<span class="string">''</span>, <span class="string">'test.sh'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>感觉应该就是直接<strong>从最后一个<code>/</code>号进行了分割</strong>，<strong>前面的返回目录</strong>，<strong>后面的作为文件名</strong></li><li>如果最后<strong>是以<code>/</code>结尾</strong>，返回的<strong>文件名为空</strong></li><li>如果path中<strong>没有<code>/</code></strong>，则<strong>目录会为空</strong>，<strong>文件名不为空</strong></li></ul></div><hr><h3 id="分割路径为后缀名-eg-txt-和之前部分-os-path-splitext"><a href="#分割路径为后缀名-eg-txt-和之前部分-os-path-splitext" class="headerlink" title="分割路径为后缀名(eg:.txt)和之前部分-os.path.splitext()"></a>分割路径为后缀名(eg:.txt)和之前部分-os.path.splitext()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本和上面的os.path.split()差不多</span></span><br><span class="line"><span class="comment"># 唯一的区别是返回的二元组是后缀名和前部分</span></span><br><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">os.path.splitext(<span class="string">"./new_name.txt"</span>)</span><br><span class="line">  <span class="comment"># 返回的元组是后缀名和前部分</span></span><br><span class="line">  (<span class="string">'./new_name'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">os.path.splitext(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回的元组是后缀名和前部分</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有后缀名，返回空字符</span></span><br><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">os.path.splitext(<span class="string">"./new_name"</span>)</span><br><span class="line">  <span class="comment"># 没有后缀，返回的是空字符</span></span><br><span class="line">  (<span class="string">'./new_name'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">os.path.splitext(<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>)</span><br><span class="line">  <span class="comment"># 没有后缀，返回的是空字符</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不含\也和上面相同</span></span><br><span class="line">os.path.splitext(<span class="string">'test.sh'</span>)</span><br><span class="line">  (<span class="string">'test'</span>, <span class="string">'.sh'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="得到路径的目录-os-path-dirname"><a href="#得到路径的目录-os-path-dirname" class="headerlink" title="得到路径的目录-os.path.dirname()"></a>得到路径的目录-os.path.dirname()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径得到的也是相对路径</span></span><br><span class="line">os.path.dirname(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径得到的也是绝对路径</span></span><br><span class="line">os.path.dirname(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第一个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="返回文件名-os-path-basename"><a href="#返回文件名-os-path-basename" class="headerlink" title="返回文件名-os.path.basename()"></a>返回文件名-os.path.basename()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第二个元素</span></span><br><span class="line">os.path.basename(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'new_name.txt'</span></span><br><span class="line">  </span><br><span class="line">os.path.basename(<span class="string">'./'</span>)</span><br><span class="line">  <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第二个元素</span></span><br><span class="line">os.path.basename(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="string">'new_name.txt'</span></span><br><span class="line"></span><br><span class="line">os.path.basename(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="string">''</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断文件和目录是否存在-os-path-exists"><a href="#判断文件和目录是否存在-os-path-exists" class="headerlink" title="判断文件和目录是否存在-os.path.exists()"></a>判断文件和目录是否存在-os.path.exists()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line">os.path.exists(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">os.path.exists(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断目录是否存在</span></span><br><span class="line">os.path.exists(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为绝对路径-os-path-isabs"><a href="#判断是否为绝对路径-os-path-isabs" class="headerlink" title="判断是否为绝对路径-os.path.isabs()"></a>判断是否为绝对路径-os.path.isabs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径返回false</span></span><br><span class="line">os.path.isabs(<span class="string">'./'</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line">os.path.isabs(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径返回true</span></span><br><span class="line">os.path.isabs(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line">os.path.isabs(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为存在的文件-os-path-isfile"><a href="#判断是否为存在的文件-os-path-isfile" class="headerlink" title="判断是否为存在的文件-os.path.isfile()"></a>判断是否为存在的文件-os.path.isfile()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在的文件返回true</span></span><br><span class="line">os.path.isfile(<span class="string">"./new_name.txt"</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不存在的文件返回false</span></span><br><span class="line">os.path.isfile(<span class="string">"./new_namdsfae.txt"</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为存在的目录-os-path-isdir"><a href="#判断是否为存在的目录-os-path-isdir" class="headerlink" title="判断是否为存在的目录-os.path.isdir()"></a>判断是否为存在的目录-os.path.isdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.path.isdir(<span class="string">"c:\\FastFolder\\learn_test"</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path.isfile()和os.path.isdir()感觉可以使用os.path.exists()替换</span></span><br><span class="line"><span class="comment"># 特殊情况，比如通过判断是文件和目录来进行选择性的删除所有的文件，保留目录</span></span><br></pre></td></tr></table></figure><hr><h3 id="连接目录与文件名或目录-os-path-join"><a href="#连接目录与文件名或目录-os-path-join" class="headerlink" title="连接目录与文件名或目录-os.path.join()"></a>连接目录与文件名或目录-os.path.join()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将若干个目录或文件连接起来</span></span><br><span class="line"><span class="comment"># 不管目录或文件存不存在</span></span><br><span class="line">os.path.join(<span class="string">'c:\\FastFolder\\learn_test'</span>,<span class="string">'test'</span>,<span class="string">'test2'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test\\test\\test2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果根目录在第二个或者更后面，之前的路径将会忽略掉</span></span><br><span class="line">os.path.join(<span class="string">'/root'</span>, <span class="string">'/usr/local'</span>, <span class="string">'test.sh'</span>)</span><br><span class="line">  <span class="comment"># 因为第二个参数'/usr/local'是从根目录开始，第一个/root会被忽略</span></span><br><span class="line">  <span class="string">'/usr/local/test.sh'</span></span><br><span class="line"><span class="comment"># 作为对比</span></span><br><span class="line">os.path.join(<span class="string">'/root'</span>, <span class="string">'usr/local'</span>, <span class="string">'test.sh'</span>)</span><br><span class="line">  <span class="comment">#作为对比，第二个参数'usr/local'没有从根目录开始</span></span><br><span class="line">  <span class="comment"># 最后的结果中会包含第一个参数的内容，不管第一个参数是不是从根目录开始</span></span><br><span class="line"> <span class="string">'/root/usr/local/test.sh'</span></span><br></pre></td></tr></table></figure><hr><h3 id="遍历整个文件结构-os-walk"><a href="#遍历整个文件结构-os-walk" class="headerlink" title="遍历整个文件结构-os.walk()"></a>遍历整个文件结构-os.walk()</h3><p>walk方法是os模块中非常重要和强大的一个方法(<code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code>)。可以帮助我们非常便捷地以<strong>递归方式**</strong>自顶向下<strong>或者</strong>自底向上的方式遍历目录树<strong>，对</strong>每一个目录都返回一个三元元组<code>(dirpath, dirnames, filenames)</code>**:</p><ul><li><code>dirpath</code>：遍历所在目录树的位置，是一个<strong>字符串对象</strong></li><li><code>dirnames</code>：目录树中的<strong>子目录</strong>组成的<strong>列表</strong>，不包括(“.”和”..”)</li><li><code>filenames</code>：目录树中的<strong>文件</strong>组成的<strong>列表</strong></li></ul><p>如果可选参数t<code>opdown = True</code>或者<strong>没有指定</strong>，则采用<strong>自顶向下</strong>的方式进行目录遍历，也就是<strong>从父目录向子目录逐步深入遍历</strong>，如果<code>topdown = False</code>，则采用<strong>自底向上</strong>的方式遍历目录，也就是<strong>先打印子目录再打印父目录</strong>的方式。</p><p>如果可选参数<code>onerror</code>被指定，则<code>onerror</code>必须是一个<strong>函数</strong>，该函数有一个OSError实例的参数，这样可以允许在运行的时候即使出现错误的时候不会打断os.walk()的执行，或者抛出一个异常并终止os.walk()的运行。通俗的讲，<strong>就是定义这个参数用于指定当发生了错误时的处理方法</strong>。</p><p><strong>默认情况下</strong>，<code>os.walk()</code>遍历的时候<strong>不会进入符号链接</strong>，如果设置了可选参数<code>followlinks = True</code>，<strong>则会进入符号链接</strong>。注意，这<strong>可能会出现遍历死循环</strong>，因为符号链接可能会出现自己链接自己的情况，而os.walk()没有那么高的智商，无法发现这一点。</p><p><strong>只遍历输出根目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">r"./"</span>):</span><br><span class="line">        print(root)</span><br><span class="line">        <span class="comment"># for directory in dirs:</span></span><br><span class="line">        <span class="comment">#     print( directory)</span></span><br><span class="line">        <span class="comment"># for file in files:</span></span><br><span class="line">        <span class="comment">#     print(file)</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在遍历过程中，所有的目录都可能成为根目录</span></span><br><span class="line">./</span><br><span class="line">./old_name</span><br><span class="line">./python_test</span><br><span class="line">./python_test\main</span><br><span class="line">./python_test\main\__pycache__</span><br><span class="line">./python_test\__pycache__</span><br></pre></td></tr></table></figure><p></p><p><strong>遍历输出根目录及其下面的目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">r"./"</span>):</span><br><span class="line">        print(root)</span><br><span class="line">        <span class="keyword">for</span> directory <span class="keyword">in</span> dirs:</span><br><span class="line">            print( directory)</span><br><span class="line">        <span class="comment"># for file in files:</span></span><br><span class="line">        <span class="comment">#     print(file)</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">old_name</span><br><span class="line">python_test</span><br><span class="line">./old_name</span><br><span class="line">./python_test</span><br><span class="line">main</span><br><span class="line">__pycache__</span><br><span class="line">./python_test\main</span><br><span class="line">__pycache__</span><br><span class="line">./python_test\main\__pycache__</span><br><span class="line">./python_test\__pycache__</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="总结以及注意事项"><a href="#总结以及注意事项" class="headerlink" title="总结以及注意事项"></a>总结以及注意事项</h3><div class="note info"><ul><li>除了<code>os.listdir()和os.scandir()</code>可以<strong>不指定path表示当前目录</strong>之外，<strong>基本所有的都必须要指定path</strong>，即使是当前目录，也要用类似<code>&#39;.&#39;</code>的方法指定，<strong>如果不指定会报错</strong>，所以<strong>保险起见，还是都指定path吧，以免出错</strong>。<br><br></li><li>使用windows的文件路径时一定要小心，比如你要引用d盘下的1.txt文件，那么路径要以字符串的形式写成<code>&#39;d:\\1.txt&#39;</code>或者<code>r&#39;d:\1.txt‘</code>。前面的方式是使用windwos的<strong>双斜杠</strong>作为路径分隔符，后者是使用<strong>原生字符串</strong>的形式，以r开始的字符串都被认为是原始字符串，表示字符串里所有的特殊符号都以本色出演，<strong>不进行转义</strong>，此时可以使用普通windows下的路径表示方式。<strong>这两种方法使用哪种都可以，但不可混用</strong>。<br><br></li><li><code>os.path.exists()</code>可以<strong>判断文件或者目录是否存在</strong>，而具体的<code>os.path.isfile()</code>和<code>os.path.isdir()</code>可以<strong>分别判断文件和目录是否存在</strong>，从而进行单独的操作，如删除所有目录中的文件，保留目录。<br><br></li><li><code>os.rmdir()</code>、<code>os.removedirs()</code>都<mark>只能删除空的目录</mark>，而<code>os.remove()</code>只能<strong>删除单个的文件</strong>，所以如果<mark>需要删除一个带文件的目录需要结合os.listdir() os.remove() os.rmdir()等，比较麻烦</mark>。<br><br></li><li>Python删除目录os.removedirs()的过程：If the <strong>leaf directory is succesfully removed</strong>, removedirs <strong>tries to successively remove every parent directory displayed in path</strong>.</li></ul></div><hr><p><br></p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p>系统相关的一系列命令在实际使用中用的比较少，所以这里只是列出，便于在后面使用时查询，并不进行深入的学习，后续需要时再学习。<br>os模块提供了一些操作系统相关的变量，可以在跨平台的时候提供支持，<strong>便于编写移植性高，可用性好的代码</strong>。所以在<strong>涉及操作系统相关的操作</strong>时，请<strong>尽量使用本模块提供的方法</strong>，而<strong>不要使用当前平台特定的用法或格式</strong>，否则一旦移植到其他平台，可能会造成难以解决的困扰。</p><table><thead><tr><th width="20%">方法和变量</th><th width="80%">用途</th></tr></thead><tbody><tr><td><code>os.name</code></td><td>查看当前操作系统的名称。windows平台下返回‘nt’，Linux则返回‘posix’。</td></tr><tr><td><code>os.environ</code></td><td>获取系统环境变量</td></tr><tr><td><code>os.sep</code></td><td>当前平台的路径分隔符。在windows下，为‘\’，在POSIX系统中，为‘/’。</td></tr><tr><td><code>os.altsep</code></td><td>可替代的路径分隔符，在Windows中为‘/’。</td></tr><tr><td><code>os.extsep</code></td><td>文件名和文件扩展名之间分隔的符号，在Windows下为‘.’。</td></tr><tr><td><code>os.pathsep</code></td><td>PATH环境变量中的分隔符，在POSIX系统中为‘:’，在Windows中为‘;’。</td></tr><tr><td><code>os.linesep</code></td><td>行结束符。在不同的系统中行尾的结束符是不同的，例如在Windows下为‘\r\n’。</td></tr><tr><td><code>os.devnull</code></td><td>在不同的系统上null设备的路径，在Windows下为‘nul’，在POSIX下为‘/dev/null’。</td></tr><tr><td><code>os.defpath</code></td><td>当使用exec函数族的时候，如果没有指定PATH环境变量，则默认会查找os.defpath中的值作为子进程PATH的值。</td></tr></tbody></table><h3 id="环境变量-os-environ"><a href="#环境变量-os-environ" class="headerlink" title="环境变量-os.environ()"></a>环境变量-os.environ()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到目前的环境变量</span></span><br><span class="line"><span class="comment"># 返回类似字典的具有映射关系的对象</span></span><br><span class="line">print(os.environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查HOME是不是在环境变量中</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'HOME'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    print(<span class="string">'HOME environment variable is already defined. Value ='</span>, os.environ[<span class="string">'HOME'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'HOME environment variable is not defined.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，和操作字典类似</span></span><br><span class="line"><span class="comment"># 注意环境变量的值必须要是字符串，不能为数字或其他</span></span><br><span class="line">os.environ[<span class="string">'MYSQL_VERSION'</span>] = <span class="string">'5.7.18'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取环境变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用常规的这种字典操作的方式</span></span><br><span class="line"><span class="comment"># 这种方式存在的问题是如果环境变量中不存在这个MYSQL_VERSION，则会报错，显示KeyError</span></span><br><span class="line">os.environ[<span class="string">'MYSQL_VERSION'</span>]</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"C:\Users\14910\Anaconda3\lib\os.py"</span>, line <span class="number">678</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">      <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="keyword">None</span></span><br><span class="line">  KeyError: <span class="string">'MYSQL_VERSION'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用另一种方式get()</span></span><br><span class="line"><span class="keyword">print</span> (os.environ.get(<span class="string">'DATA'</span>))</span><br><span class="line">  <span class="comment"># 环境变量不存在，返回None </span></span><br><span class="line">  <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 还可以设置环境变量不存在时候的默认值</span></span><br><span class="line">print(os.environ.get(<span class="string">'DATA'</span>, <span class="string">'TXT'</span>))</span><br><span class="line"> <span class="comment"># 环境变量不存在，返回默认值</span></span><br><span class="line">  TXT</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="执行命令和管理进程"><a href="#执行命令和管理进程" class="headerlink" title="执行命令和管理进程"></a>执行命令和管理进程</h2><p>在早期的Python版本中，通常使用<code>os</code>模块的<code>system</code>或者<code>popen</code>等方法执行操作系统的命令。但是，最近Python官方逐渐弃用了这些命令，而是改用内置的<code>subprocess</code>模块执行操作系统相关命令。鉴于上述原因，这里就不对这个方面进行更深入的学习，以后详细学习<code>subprocess</code>模块。</p><p><strong>该部分主要包括两个命令</strong>：</p><ul><li><code>os.system(command)</code>：运行操作系统命令，<strong>直接显示结果</strong>；但<strong>返回值是0或-1</strong>，<strong>不能获得显示在屏幕上的数据</strong>；command是要执行的命令字符串；除非显式在后台运行该命令，否则 <code>system()</code> 的调用将阻塞，直到它完成.</li><li><code>os.popen(command, [mode, [bufsize]])</code>：该方法<strong>返回一个文件对象，可以对这个文件对象进行读或写</strong>，取决于<strong>参数mode</strong>，如果mode指定了只读，那么只能对文件对象进行读，如果mode参数指定了只写，那么只能对文件对象进行写操作。简而言之，<strong><code>popen</code>也可以运行操作系统命令</strong>，并<strong>通过<code>read()</code>方法将命令的结果返回</strong>，<strong>不像system只能看不能存，这个能存</strong>！</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/53" target="_blank" rel="noopener">很详细的教程</a></li><li><a href="https://learnku.com/docs/pymotw/os-portable-access-to-operating-system-specific-features/3481" target="_blank" rel="noopener">使用实例教程</a></li><li><a href="https://www.cnblogs.com/yyds/p/6427349.html" target="_blank" rel="noopener">Python之文件与目录操作（os、zipfile、tarfile、shutil）</a></li><li><a href="https://docs.python.org/3/library/os.html#module-os" target="_blank" rel="noopener">os — Miscellaneous operating system interfaces</a></li><li><a href="https://www.cnblogs.com/maseng/p/3386140.html" target="_blank" rel="noopener">python os.stat() 和 stat模块详解</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python使用操作系统相关功能的os模块，其主要功能包括：&lt;strong&gt;系统相关&lt;/strong&gt;、&lt;strong&gt;目录及文件操作&lt;/strong&gt;、&lt;strong&gt;执行命令和管理进程&lt;/strong&gt;，这里主要学习了&lt;strong&gt;常用的目录及文件操作&lt;/strong&gt;，其中涉及到的功能非常多，需要时可以查看使用，最后还学习了&lt;strong&gt;系统相关中的查看和新增环境变量操作&lt;/strong&gt;，较为实用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的解压缩命令</title>
    <link href="http://showteeth.tech/posts/29022.html"/>
    <id>http://showteeth.tech/posts/29022.html</id>
    <published>2019-03-30T09:28:22.000Z</published>
    <updated>2019-03-30T15:32:38.963Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习和总结了Linux中常用的解压缩命令，主要针对<code>tar.gz</code>、<code>tar.bz2</code>、<code>gz</code>、<code>bz2</code>和<code>zip</code>文件格式进行解压，分别学习了<code>tar命令(打包命令)</code>、<code>gzip命令</code>、<code>bzip2命令</code>以及<code>zip命令</code>和<code>对应的解压命令</code>来完成对上述文件格式的解压。</p></div><a id="more"></a><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p><strong><code>tar</code>命令是打包命令而不是解压命令</strong>，所谓的打包是指可以把<strong>一大堆的文件和目录</strong>全部打包<strong>成一个文件</strong>，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。我们在<strong>平常使用时都是使用<code>tar</code>结合相应参数对文件进行解压，但实际上其并不是解压缩命令，其实现解压需要结合特定的参数</strong>。</p><p><strong>这里我们很有必要了解一下打包和解压的区别</strong>：</p><ul><li><strong>打包</strong>是指将<strong>一大堆文件或目录</strong>变成一个<strong>总的文件</strong></li><li><strong>压缩</strong>则是将<strong>一个大的文件</strong>通过一些压缩算法变成一个<strong>小文件</strong></li></ul><p>我们平常解压时面对的文件名大多是<code>tar.gz</code>格式文件，其产生过程和原因是：Linux中<strong>很多压缩程序只能针对一个文件进行压缩</strong>，这样当你想要<strong>压缩一大堆文件时</strong>，你得先<strong>将这一大堆文件先打成一个包</strong>（<code>tar命令</code>），然后<strong>再用压缩程序进行压缩</strong>（<code>gzip、bzip2命令</code>）。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在学习如何解压<code>tar.gz</code>格式文件之前，先学习使用tar命令进行打包并进行压缩，知道来源再去学习针对性的解压命令.</p><p><strong>命令格式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 输入文件可以有多个，将其统一打包成输出文件</span></span><br><span class="line">  tar option out_file in_file in_file_2</span><br></pre></td></tr></table></figure><p></p><p><strong>相关参数说明</strong>：</p><ul><li><code>-c</code>：建立新的打包文件</li><li><code>-v</code>：显示指令执行过程</li><li><code>-r</code>：向已经打包的文件中<strong>追加**</strong>文件<strong>(</strong>不能向已经压缩的<code>bz2</code>、<code>gz</code>文件中添加<strong>，</strong>需要和<code>-f</code>参数一同使用**)</li><li><code>-u</code>：<strong>更新</strong>已经打包的文件中的<strong>文件</strong>(<strong>不能向已经压缩的<code>bz2</code>、<code>gz</code>文件中添加</strong>，<strong>需要和<code>-f</code>参数一同使用</strong>)</li><li><code>-A</code>：将<strong>tar文件中的文件**</strong>追加到已经打包的文件(tar文件)中**，相当于是文件的追加，而不是将整个tar文件追加进去</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li></ul><p><strong>打包实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅打包，不压缩</span></span><br><span class="line">tar -cvf Homo_sapiens.GRCh38.95.chr.gff3.tar Homo_sapiens.GRCh38.95.chr.gff3 test.txt </span><br><span class="line">  <span class="comment"># 生成tar格式文件，tar格式文件比原始文件大</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中添加test2.txt文件</span></span><br><span class="line">tar -rvf Homo_sapiens.GRCh38.95.chr.gff3.tar test2.txt</span><br><span class="line">  <span class="comment"># 生成的还是原来的tar文件，只是其中多了test2.txt</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中更新test2.txt文件</span></span><br><span class="line">tar -uvf Homo_sapiens.GRCh38.95.chr.gff3.tar test2.txt</span><br><span class="line">  <span class="comment"># tar文件中的test2.txt已经更新了</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中添加tar打包文件</span></span><br><span class="line">tar -Avf Homo_sapiens.GRCh38.95.chr.gff3.tar Homo_sapiens.GRCh38.95.chr.gff3_2.tar</span><br><span class="line">  <span class="comment"># 生成的还是原来的tar文件，只是将tar中的文件追加到前面的tar文件中</span></span><br><span class="line">  <span class="comment"># 不是将整个tar文件追加进去，如果使用-r选项就是将整个tar文件追加进去</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包后，以 gzip 压缩 </span></span><br><span class="line">tar -zcvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz Homo_sapiens.GRCh38.95.chr.gff3 test.txt</span><br><span class="line">  <span class="comment"># 生成tar.gz格式文件</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包后，以 bzip2 压缩(这个花费时间较长) </span></span><br><span class="line">tar -jcvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2  Homo_sapiens.GRCh38.95.chr.gff3 test.txt</span><br><span class="line">  <span class="comment"># 生成tar.bz2格式文件</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>打包参数是<code>-cvf</code></li><li><code>bz2</code>格式的文件对应的参数就是<code>j</code>，<strong>打包所需时间长，压缩包的大小比较小，压缩比高</strong></li><li><code>gz</code>格式的文件对应的参数就是<code>z</code>，<strong>打包所需时间较短，压缩包的大小比较大，压缩比低</strong></li><li><strong>tar格式文件比原始文件大</strong></li></ul><p><strong>上述的文件格式和参数的对应关系很关键，在接下来的所有命令中，只要是针对这两种不同格式的包都需要加上对应的参数</strong>。</p></div><hr><h3 id="查看包的内容"><a href="#查看包的内容" class="headerlink" title="查看包的内容"></a>查看包的内容</h3><p><strong>相关参数说明</strong>：</p><ul><li><code>-t</code>：列出打包文件内容</li><li><code>-v</code>：显示指令执行过程</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li></ul><p><strong>查看包的内容实例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看打包文件</span></span><br><span class="line">tar -tvf Homo_sapiens.GRCh38.95.chr.gff3.tar</span><br><span class="line">  <span class="comment"># 输出包的内容 </span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tar.gz格式文件内容</span></span><br><span class="line">tar -ztvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line">  <span class="comment"># 输出tar.gz格式文件内容 </span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tar.bz2格式文件内容</span></span><br><span class="line">tar -jtvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br><span class="line">  <span class="comment"># 输出tar.bz2格式文件内容</span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>查看包的基础参数是<code>-tvf</code></li><li><code>bz2</code>格式的文件对应的参数就是<code>j</code></li><li><code>gz</code>格式的文件对应的参数就是<code>z</code></li></ul></div><hr><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><strong>相关参数说明</strong>：</p><ul><li><code>-x</code>：提取(解压)打包文件内容</li><li><code>-v</code>：显示指令执行过程</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li><li><code>-C</code>：<strong>指定解压文件的输出目录</strong></li></ul><h4 id="解压整个文件"><a href="#解压整个文件" class="headerlink" title="解压整个文件"></a>解压整个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取tar格式文件内容</span></span><br><span class="line">tar -xvf Homo_sapiens.GRCh38.95.chr.gff3.tar</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.gz格式文件内容</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar.gz格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.bz2格式文件内容</span></span><br><span class="line">tar -jxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar.bz2格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定解压的输出文件夹</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz -C <span class="built_in">test</span></span><br><span class="line">  <span class="comment"># 解压的文件输出在test目录中</span></span><br><span class="line">  <span class="comment"># test目录必须存在，不然会报错</span></span><br></pre></td></tr></table></figure><hr><h4 id="解压部分文件"><a href="#解压部分文件" class="headerlink" title="解压部分文件"></a>解压部分文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取tar.gz格式文件中的test.txt文件</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.bz2格式文件中的test.txt文件</span></span><br><span class="line">tar -jxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定解压的输出文件夹</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz test.txt -C <span class="built_in">test</span></span><br><span class="line">  <span class="comment"># 解压的文件输出在test目录中</span></span><br><span class="line">  <span class="comment"># test目录必须存在，不然会报错</span></span><br></pre></td></tr></table></figure><div class="note info"><ul><li><strong>tar可解压压缩文件的部分内容</strong>，所以可以先通过<code>-t</code>来<strong>查看</strong>压缩包内容，然后<strong>选取自己需要</strong>的进行<strong>解压</strong>，或者直接解压整个包。</li><li><strong>可以使用<code>-C</code>参数指定解压文件的输出目录</strong></li></ul></div><hr><h2 id="gz文件"><a href="#gz文件" class="headerlink" title="gz文件"></a>gz文件</h2><p>这个没啥可以说的，就是使用gzip命令压缩得到的文件(<strong>默认情况下压缩后会使原文件消失</strong>)，对于这个命令的解压可以使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看压缩文件信息</span></span><br><span class="line"><span class="comment"># -l：list compressed file contents</span></span><br><span class="line">gzip -l Homo_sapiens.GRCh38.95.chr.gff3.gz </span><br><span class="line">  compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">    38793139           430456714  91.0% Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip -d解压</span></span><br><span class="line"><span class="comment"># -d：decompress</span></span><br><span class="line">gzip -d Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">  <span class="comment"># 解压缩后原始的gz格式文件将不会存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip解压</span></span><br><span class="line">gunzip Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">  <span class="comment"># 解压缩后原始的gz格式文件将不会存在</span></span><br></pre></td></tr></table></figure><p></p><p>如果想<strong>保留原始文件</strong>就需要使用<code>-c</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c：--stdout  write on standard output, keep original files unchanged</span></span><br><span class="line"><span class="comment"># -c：将文件输出到标准输出，并且保留原始gz格式文件不变</span></span><br><span class="line"><span class="comment"># 输出到标准输出，然后进行重定向到文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩过程如果想保留原始文件也可以使用-c参数</span></span><br><span class="line">gzip -c Homo_sapiens.GRCh38.95.chr.gff3 &gt;Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip进行解压缩并保留原始文件</span></span><br><span class="line">gunzip -c Homo_sapiens.GRCh38.95.chr.gff3.gz &gt;Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip -d解压并保留原始文件</span></span><br><span class="line">gzip -d -c Homo_sapiens.GRCh38.95.chr.gff3.gz &gt;Homo_sapiens.GRCh38.95.chr.gff3</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="bz2文件"><a href="#bz2文件" class="headerlink" title="bz2文件"></a>bz2文件</h2><p>bz2是由bzip2命令压缩得到的文件，<strong>默认情况下和<code>gzip</code>相同<code>bzip2</code>也不会保留解压缩前的原始文件</strong>，对这种格式的文件进行解压缩可以使用如下命令:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和gzip不同，bzip2命令没有能够列出压缩文件内容的选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip2 -d进行解压</span></span><br><span class="line"><span class="comment"># -d：--decompress  force decompression</span></span><br><span class="line">bzip2 -d Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br><span class="line">  <span class="comment"># 解压缩后原始的bz2格式文件将不会存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2解压</span></span><br><span class="line">bunzip2 Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br><span class="line">  <span class="comment"># 解压缩后原始的bz2格式文件将不会存在</span></span><br></pre></td></tr></table></figure><p></p><p>如果想<strong>保留原始文件</strong>就需要使用<code>-k</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -k：--keep   keep (don't delete) input files</span></span><br><span class="line"><span class="comment"># -k：保留原始的输入文件</span></span><br><span class="line"><span class="comment"># 这里bzip2也有-c选项，但是也专门提供了-k选项来保留原始文件，所以就不需要进行-c然后重定向</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩时保留原始文件</span></span><br><span class="line">bzip2 -k Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2解压并保留原始文件</span></span><br><span class="line">bunzip2 -k Homo_sapiens.GRCh38.95.chr.gff3.bz2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip2 -d进行解压并保留原始文件</span></span><br><span class="line">bzip2 -d -k Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="zip格式文件"><a href="#zip格式文件" class="headerlink" title="zip格式文件"></a>zip格式文件</h2><p>zip格式文件是通过zip命令压缩得到的文件，对其的解压使用unzip命令即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用zip命令进行压缩，与前面两个gzip和bzip2不同的是可以保留原始文件</span></span><br><span class="line"><span class="comment"># 需要自定义输出文件名</span></span><br><span class="line">zip Homo_sapiens.GRCh38.95.chr.gff3.zip Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新zip文件中的问价，使用-u参数</span></span><br><span class="line">zip -u Homo_sapiens.GRCh38.95.chr.gff3.zip test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件添加到zip文件中，使用-m参数</span></span><br><span class="line">zip -m Homo_sapiens.GRCh38.95.chr.gff3.zip  test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用unzip进行解压</span></span><br><span class="line"><span class="comment"># 解压也和前面的gzip和bzip2不同，能够保留原始文件</span></span><br><span class="line">unzip Homo_sapiens.GRCh38.95.chr.gff3.zip</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关于tar命令"><a href="#关于tar命令" class="headerlink" title="关于tar命令"></a>关于tar命令</h3><ul><li><strong>tar可解压压缩文件的部分内容</strong>，所以可以先通过<code>-t</code>来<strong>查看</strong>压缩包内容，然后<strong>选取自己需要</strong>的进行<strong>解压</strong>，或者直接解压整个包。</li><li><strong>可以使用<code>-C</code>参数指定解压文件的输出目录</strong></li><li><strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li></ul><hr><h3 id="关于压缩比"><a href="#关于压缩比" class="headerlink" title="关于压缩比"></a>关于压缩比</h3><p><strong><code>bzip2</code>的压缩比最高、其次是<code>gzip</code>、接着是<code>zip</code>、最后是打包<code>tar</code></strong>，可以看看这个示例：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/压缩比.png" alt="压缩比.png"></p><hr><h3 id="原始文件"><a href="#原始文件" class="headerlink" title="原始文件"></a>原始文件</h3><ul><li><strong><code>tar</code>和<code>zip</code>都会保留原始文件</strong></li><li><strong><code>bzip2</code>和<code>gzip</code>都不会保留原始文件</strong><ul><li><code>gzip</code>需要使用<code>-c</code>参数将结果<strong>输出到标准输出</strong>，然后<strong>重定向</strong>来保留文件(解压或者压缩)</li><li><code>bzip2</code>可以使用<code>-k</code>参数来<strong>直接保留</strong>原始文件(解压或者压缩)，也可以使用上面的<code>-c</code>参数</li></ul></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>tar</code>和<code>zip</code>进行压缩或者打包时都是先跟着输出文件(tar、zip格式文件)，再跟着输入的需要打包和压缩的文件，这个需要注意一下</li><li><code>bzip2</code>和<code>gzip</code>直接跟着需要压缩的文件即可<br><br></li><li><code>bzip2</code>和<code>gzip</code>只能针对文件，不能针对目录</li><li><code>tar</code>可以<strong>支持对目录和文件的打包</strong></li><li><code>zip</code>命令<strong>需要使用<code>-r</code>参数</strong>来支持对目录的压缩</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/tar" target="_blank" rel="noopener">tar命令</a></li><li><a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip命令</a></li><li><a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2命令</a></li><li><a href="http://man.linuxde.net/zip" target="_blank" rel="noopener">zip命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习和总结了Linux中常用的解压缩命令，主要针对&lt;code&gt;tar.gz&lt;/code&gt;、&lt;code&gt;tar.bz2&lt;/code&gt;、&lt;code&gt;gz&lt;/code&gt;、&lt;code&gt;bz2&lt;/code&gt;和&lt;code&gt;zip&lt;/code&gt;文件格式进行解压，分别学习了&lt;code&gt;tar命令(打包命令)&lt;/code&gt;、&lt;code&gt;gzip命令&lt;/code&gt;、&lt;code&gt;bzip2命令&lt;/code&gt;以及&lt;code&gt;zip命令&lt;/code&gt;和&lt;code&gt;对应的解压命令&lt;/code&gt;来完成对上述文件格式的解压。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之打印彩色字符串</title>
    <link href="http://showteeth.tech/posts/9708.html"/>
    <id>http://showteeth.tech/posts/9708.html</id>
    <published>2019-03-30T02:50:03.000Z</published>
    <updated>2019-03-30T03:56:48.148Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是Linux中<a href="http://showteeth.tech/posts/39761.html">使用echo -e进行彩色输出</a>的后续，Python也可以进行输出样式更改，包括<strong>字体颜色</strong>、<strong>背景颜色</strong>、<strong>其他输出样式更改(字体闪烁、下划线和加粗等)</strong>。</p></div><a id="more"></a><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>昨天学习了<code>Linux</code>中使用<code>echo</code>命令来进行彩色字符串的输出，后来发现<code>Python</code>也可以进行彩色字符串的输出，但是<strong>需要注意的是只能在服务器上使用才可以，在<code>Python IDE</code>或者<code>cmd</code>中支持都不是很完善(<code>IDE</code>压根不能输出而<code>CMD</code>不会出现闪烁效果)</strong>，具体的展示效果如下：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python彩色输出.png" alt="python彩色输出.png"></p><hr><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>和<code>echo</code>命令中学习的相同，控制颜色输出的由两部分构成：<code>\033[xx;xxm</code>和<code>\033[0m</code>(<strong>ANSI控制码</strong>)：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印红色字体</span></span><br><span class="line"><span class="comment"># 31m表示红色</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"\033[31mTEST\033[0m"</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>\033[xxxm</code>：表示<strong>开始样式(字体、背景、闪烁等)渲染</strong>，<strong><code>m</code>前面可以跟着多种样式渲染的数字表示(不同类型以分号<code>;</code>分隔，不用再加<code>m</code>，否则会出错)</strong>，例如：<code>print (&quot;\033[42;37mTEST\033[0m&quot;)</code>可正确输出绿底白字，而<code>print (&quot;\033[42m;37mTEST\033[0m&quot;)</code>输出结果和正确的存在差异</li><li><code>\033[0m</code>表示<strong>样式(字体、背景、闪烁等)渲染结束</strong>，<strong>这个不管是在什么样式输出情况下都是固定的</strong></li></ul></div><hr><h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><p>和<code>echo</code>命令中学习的相同，只需要将<code>echo -e</code>替换为<code>print()</code>即可，<strong>具体颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">颜色</th><th width="60%">完整命令</th></tr><tr><td>30</td><td><strong>黑色</strong></td><td><code>print ("\033[30mTEST\033[0m")</code></td></tr><tr><td>31</td><td><strong>红色</strong></td><td><code>print ("\033[31mTEST\033[0m")</code></td></tr><tr><td>32</td><td><strong>绿色</strong></td><td><code>print ("\033[32mTEST\033[0m")</code></td></tr><tr><td>33</td><td><strong>黄色</strong></td><td><code>print ("\033[33mTEST\033[0m")</code></td></tr><tr><td>34</td><td><strong>蓝色</strong></td><td><code>print ("\033[34mTEST\033[0m")</code></td></tr><tr><td>35</td><td><strong>紫色</strong></td><td><code>print ("\033[35mTEST\033[0m")</code></td></tr><tr><td>36</td><td><strong>浅蓝色</strong></td><td><code>print ("\033[36mTEST\033[0m")</code></td></tr><tr><td>37</td><td><strong>白色</strong></td><td><code>print ("\033[37mTEST\033[0m")</code></td></tr></table><p><strong>输出效果展示</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python彩色输出.png" alt="python彩色输出.png"></p><hr><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><p><strong>具体背景颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">背景颜色</th><th width="60%">完整命令(字体颜色为红色)</th></tr><tr><td>40</td><td><strong>黑色</strong></td><td><code>print ("\033[40;31mTEST\033[0m")</code></td></tr><tr><td>41</td><td><strong>红色</strong></td><td><code>print ("\033[41;31mTEST\033[0m")</code></td></tr><tr><td>42</td><td><strong>绿色</strong></td><td><code>print ("\033[42;31mTEST\033[0m")</code></td></tr><tr><td>43</td><td><strong>黄色</strong></td><td><code>print ("\033[43;31mTEST\033[0m")</code></td></tr><tr><td>44</td><td><strong>蓝色</strong></td><td><code>print ("\033[44;31mTEST\033[0m")</code></td></tr><tr><td>45</td><td><strong>紫色</strong></td><td><code>print ("\033[45;31mTEST\033[0m")</code></td></tr><tr><td>46</td><td><strong>浅蓝色</strong></td><td><code>print ("\033[46;31mTEST\033[0m")</code></td></tr><tr><td>47</td><td><strong>白色</strong></td><td><code>print ("\033[47;31mTEST\033[0m")</code></td></tr></table><p><strong>输出效果展示</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python彩色背景输出.png" alt="python彩色背景输出.png"></p><hr><h2 id="ansi控制码总结"><a href="#ansi控制码总结" class="headerlink" title="ansi控制码总结"></a>ansi控制码总结</h2><p>ansi控制码中不仅有控制颜色的控制码，还有一些提供其他功能的控制码，如闪烁、加粗、下划线等，我们来总结一下：</p><table><tr><th width="20%">ANSI控制码</th><th width="40%">说明</th><th width="40%">完整命令示例</th></tr><tr><td><code>\033[0m</code></td><td>关闭所有属性，也就是说此控制码前面的控制码将会失效。</td><td><code>print ("\033[31;0;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[1m</code></td><td><strong>设置高亮度(加粗)</strong></td><td><code>print ("\033[1;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[4m</code></td><td><strong>下划线</strong></td><td><code>print ("\033[4;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[5m</code></td><td><strong>闪烁</strong></td><td><code>print ("\033[5;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[7m</code></td><td>反显，撞色显示，显示为白底黑字，或者显示为黑底白字，也可以和字体、背景颜色搭配</td><td><code>print ("\033[7mTEST\033[0m")</code></td></tr><tr><td><code>\033[8m</code></td><td>消隐，字符颜色将会与背景颜色相同，<strong>忽略设置的字体颜色</strong></td><td><code>print ("\033[8;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[30m--\33[37m</code></td><td>设置字符颜色</td><td><code>print ("\033[31mTEST\033[0m")</code></td></tr><tr><td><code>\033[40m--\33[47m</code></td><td>设置背景色</td><td><code>print ("\033[41mTEST\033[0m")</code></td></tr></table><p><strong>实际效果</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python-ansi控制码总结.png" alt="python-ansi控制码总结.png"></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是Linux中&lt;a href=&quot;http://showteeth.tech/posts/39761.html&quot;&gt;使用echo -e进行彩色输出&lt;/a&gt;的后续，Python也可以进行输出样式更改，包括&lt;strong&gt;字体颜色&lt;/strong&gt;、&lt;strong&gt;背景颜色&lt;/strong&gt;、&lt;strong&gt;其他输出样式更改(字体闪烁、下划线和加粗等)&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>echo-字符串的输出</title>
    <link href="http://showteeth.tech/posts/39761.html"/>
    <id>http://showteeth.tech/posts/39761.html</id>
    <published>2019-03-29T04:00:15.000Z</published>
    <updated>2019-03-30T03:24:59.658Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Linux中<strong>非常常用的输出字符串命令<code>echo</code></strong>，包括使用<strong>参数<code>-n</code>来不换行输出</strong>、使用<strong>参数<code>-e</code>来支持各种转义字符</strong>、<strong>字符串不加或加单或加双引号的区别和使用范围</strong>以及最后还学习了<strong>非常强大的使用<code>-e</code>参数来进行输出样式更改(字体颜色、背景颜色、字体闪烁、下划线和加粗等)</strong>。</p></div><a id="more"></a><p>命令 echo 是用来将字符串写到标准输出，在平时工作中非常常用，这里对其进行详细的学习。</p><h2 id="echo命令格式"><a href="#echo命令格式" class="headerlink" title="echo命令格式"></a>echo命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="built_in">echo</span> [选项] [输出内容]</span><br><span class="line"><span class="comment"># echo默认会在最后一个字符后面添加换行符</span></span><br></pre></td></tr></table></figure><div class="note info"><p>注意<strong>单引号、双引号</strong>在<strong>变量替换</strong>、<strong>字符拓展</strong>以及<strong>转义符解析</strong>等方面的区别，同样适用于<code>echo</code>命令：</p><ul><li><strong>双引号允许变量和命令替换，以及转义符的解析</strong>，保护特殊元字符和通配符不被shell解析</li><li><strong>单引号不允许任何变量、元字符、通配符、转义符的解析</strong></li></ul><p><strong>字符串加不加引号的问题</strong>:</p><ul><li>不加引号：<strong>变量替换和命令替换可以正常进行</strong>，但是<strong>转义字符解析就不可以了</strong>，<strong>默认会将转义字符直接去掉(可以用来保留原始字符，去除其后紧跟的元字符或通配符的特殊意义)</strong>，例如<code>echo -e hello\nworld</code>输出结果为<code>hellonworld</code>，直接把转义字符<code>\</code>去掉了，但是<code>n</code>还是保留了下来(这种可以适用于输出原本字符，比如<code>echo \&quot;hello\&quot;</code>就可以保留双引号输出<code>&quot;hello&quot;</code>)</li></ul><p><strong>根据上面的分析建议</strong>：</p><ul><li><strong>尽量使用双引号将字符包围起来</strong>(一般情况下肯定也不会希望字符不允许任何解析)</li><li>平常使用，如<strong>变量替换、命令替换这种简单的可以使用不加引号的方法，简单，同时也可支持简单的转义(保留原始字符，去除其后紧跟的元字符或通配符的特殊意义)</strong>，比如<code>echo \&quot;hello\&quot;</code>就可以保留双引号输出<code>&quot;hello&quot;</code>，<strong>实例可见下面字体颜色中的代码</strong>。</li></ul></div><hr><h2 id="echo支持的选项"><a href="#echo支持的选项" class="headerlink" title="echo支持的选项"></a>echo支持的选项</h2><ul><li><code>-e</code>：<strong>输出转义字符</strong>（具体参见下表）</li><li><code>-n</code>：取消输出后行末的换行符号（<strong>内容输出后不换行</strong>）</li></ul><hr><h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><p>注意<a href="http://showteeth.tech/posts/55603.html">单引号、双引号特殊字符</a>的作用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line"><span class="comment"># 单引号防止任何变量替换、通配符拓展、转移符解析等</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$x'</span></span><br><span class="line">  <span class="variable">$x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号允许变量和命令替换，以及转义符的解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$x</span>"</span></span><br><span class="line">  10</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>在实际使用过程中经常需要进行命令替换也就是打印出命令执行的结果，但是<strong>需要注意打印出来的格式和真实格式是否一致</strong>：<br><strong>不使用引号，格式发生改变</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `cmp --<span class="built_in">help</span>`</span><br><span class="line">  Usage: cmp [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]] Compare two files byte by byte. -b --<span class="built_in">print</span>-bytes Print differing bytes. -i SKIP --ignore-initial=SKIP Skip the first SKIP bytes of input. -i SKIP1:SKIP2 --ignore-initial=SKIP1:SKIP2 Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2. -l --verbose Output byte numbers and values of all differing bytes. -n LIMIT --bytes=LIMIT Compare at most LIMIT bytes. -s --quiet --silent Output nothing; yield <span class="built_in">exit</span> status only. -v --version Output version info. --<span class="built_in">help</span> Output this <span class="built_in">help</span>. SKIP1 and SKIP2 are the number of bytes to skip <span class="keyword">in</span> each file. SKIP values may be followed by the following multiplicative suffixes: kB 1000, K 1024, MB 1,000,000, M 1,048,576, GB 1,000,000,000, G 1,073,741,824, and so on <span class="keyword">for</span> T, P, E, Z, Y. If a FILE is `-<span class="string">' or missing, read standard input. Report bugs to &lt;bug-gnu-utils@gnu.org&gt;.</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用引号，格式没有发生改变</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"`cmp --help`"</span></span><br><span class="line">  Usage: cmp [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]</span><br><span class="line">  Compare two files byte by byte.</span><br><span class="line"></span><br><span class="line">    -b  --<span class="built_in">print</span>-bytes  Print differing bytes.</span><br><span class="line">    -i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input.</span><br><span class="line">    -i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2</span><br><span class="line">      Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2.</span><br><span class="line">    -l  --verbose  Output byte numbers and values of all differing bytes.</span><br><span class="line">    -n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes.</span><br><span class="line">    -s  --quiet  --silent  Output nothing; yield <span class="built_in">exit</span> status only.</span><br><span class="line">    -v  --version  Output version info.</span><br><span class="line">    --<span class="built_in">help</span>  Output this <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">  SKIP1 and SKIP2 are the number of bytes to skip <span class="keyword">in</span> each file.</span><br><span class="line">  SKIP values may be followed by the following multiplicative suffixes:</span><br><span class="line">  kB 1000, K 1024, MB 1,000,000, M 1,048,576,</span><br><span class="line">  GB 1,000,000,000, G 1,073,741,824, and so on <span class="keyword">for</span> T, P, E, Z, Y.</span><br><span class="line"></span><br><span class="line">  If a FILE is `-<span class="string">' or missing, read standard input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Report bugs to &lt;bug-gnu-utils@gnu.org&gt;.</span></span><br></pre></td></tr></table></figure><p></p><hr><hr><h2 id="n-不换行输出"><a href="#n-不换行输出" class="headerlink" title="-n-不换行输出"></a>-n-不换行输出</h2><p>取消最后行末尾末尾的换行符(每行末尾会自动添加换行符)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常输出，默认在"hello world"后面有换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line">  hello world</span><br><span class="line">  [user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span></span><br><span class="line">  hello world[user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span> ;<span class="built_in">echo</span> <span class="string">"hello c"</span></span><br><span class="line">  hello world</span><br><span class="line">  hello c</span><br><span class="line">  [user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第一个-n</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span> ;<span class="built_in">echo</span> <span class="string">"hello c"</span></span><br><span class="line">  hello worldhello c</span><br><span class="line">  [user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个-n</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span> ;<span class="built_in">echo</span> -n <span class="string">"hello c"</span></span><br><span class="line">  hello worldhello c[user@C-login04 <span class="built_in">echo</span>]$</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="e-输出转义字符"><a href="#e-输出转义字符" class="headerlink" title="-e-输出转义字符"></a>-e-输出转义字符</h2><p>命令 <code>echo</code> 加上<code>-e</code>参数能够输出如下转义字符:</p><table><tr><th width="10%">字符转换</th><th width="90%">说明</th></tr><tr><td><code>\字符</code></td><td><strong>输出<code>字符</code>本身<strong></strong></strong></td></tr><tr><td><code>\a</code></td><td>输出警告音(输出时叮咚一声)</td></tr><tr><td><code>\b</code></td><td><strong>退格键，也就是向左删除一个字符<strong></strong></strong></td></tr><tr><td><code>\c</code></td><td>所有跟在<code>\c</code>序列后的字符都被忽略，同时取消输出行末的换行符</td></tr><tr><td><code>\f</code></td><td>换行，但是换行后的新行的开头位置连接着上一行的行尾</td></tr><tr><td><code>\n</code></td><td><strong>换行符<strong></strong></strong></td></tr><tr><td><code>\r</code></td><td>使用<code>\r</code>后面的字符覆盖<code>\r</code>之前的同等长度的字符</td></tr><tr><td><code>\t</code></td><td><strong>制表符，也就是Tab键<strong></strong></strong></td></tr><tr><td><code>\v</code></td><td>垂直制表符(和<code>-f</code>相同)</td></tr><tr><td><code>\0nnn</code></td><td>按照<strong>八进制<strong> ASCII 码表输出字符，其中 0 为数字 0，nnn 是三位八进制数</strong></strong></td></tr><tr><td><code>\xhh</code></td><td>按照<strong>十六进制<strong> ASCH 码表输出字符，其中 hh 是两位十六进制数</strong></strong></td></tr></table><h3 id="字符-输出字符"><a href="#字符-输出字符" class="headerlink" title="\字符-输出字符"></a>\字符-输出字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出\本身</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\\world"</span></span><br><span class="line">  hello\world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出双引号</span></span><br><span class="line"> <span class="built_in">echo</span> -e <span class="string">"\"helloworld\""</span></span><br><span class="line">  <span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然这里不加-e选项也能正确输出</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"\\helloworld\""</span></span><br><span class="line">  \helloworld<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 不加双引号也能正确输出</span></span><br><span class="line"><span class="string">echo  \\helloworld\"</span></span><br><span class="line"><span class="string">  \helloworld"</span></span><br></pre></td></tr></table></figure><hr><h3 id="b-退格键"><a href="#b-退格键" class="headerlink" title="\b-退格键"></a>\b-退格键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有当\b后面存在字符的时候才会删除前一个字符，否则不会删除</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\b"</span></span><br><span class="line">  hello </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向左删除一个</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\bworld"</span></span><br><span class="line">  <span class="comment"># 删除了字母o</span></span><br><span class="line">  hellworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># \b可以叠加使用，向前删除多个</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\b\bworld"</span></span><br><span class="line">  <span class="comment"># 删除了字母o和l</span></span><br><span class="line">  helworld</span><br></pre></td></tr></table></figure><hr><h3 id="c-去掉后续字符和换行符"><a href="#c-去掉后续字符和换行符" class="headerlink" title="\c-去掉后续字符和换行符"></a>\c-去掉后续字符和换行符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去掉\c后续的字符和换行符</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\cworld"</span></span><br><span class="line">  hello[user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当\c后面不存在字符时，相当于echo -n</span></span><br></pre></td></tr></table></figure><hr><h3 id="f和-v-换行并缩进"><a href="#f和-v-换行并缩进" class="headerlink" title="\f和\v-换行并缩进"></a>\f和\v-换行并缩进</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \f换行缩进</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\fworld"</span></span><br><span class="line">  hello</span><br><span class="line">       world</span><br><span class="line"></span><br><span class="line"><span class="comment"># \v换行缩进</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\vworld"</span></span><br><span class="line">  hello</span><br><span class="line">       world</span><br></pre></td></tr></table></figure><hr><h3 id="n-换行符"><a href="#n-换行符" class="headerlink" title="\n-换行符"></a>\n-换行符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换行</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\nworld"</span></span><br><span class="line">  hello</span><br><span class="line">  world</span><br></pre></td></tr></table></figure><hr><h3 id="t-制表符"><a href="#t-制表符" class="headerlink" title="\t-制表符"></a>\t-制表符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 制表符</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\tworld"</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><hr><h3 id="r-等长覆盖"><a href="#r-等长覆盖" class="headerlink" title="\r-等长覆盖"></a>\r-等长覆盖</h3><p>使用<code>\r</code>后面的字符覆盖<code>\r</code>之前的同等长度的字符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等长覆盖，前后长度相同</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\rworld"</span></span><br><span class="line">  world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等长覆盖，前面长于后面字符</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hellooo\rworld"</span></span><br><span class="line">  worldoo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等长覆盖，前面短于后面字符()</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"heo\rworld"</span></span><br><span class="line">  world</span><br><span class="line"></span><br><span class="line"><span class="comment"># \r后没字符，不被覆盖</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\r"</span></span><br><span class="line">  hello</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="e-彩色输出"><a href="#e-彩色输出" class="headerlink" title="-e-彩色输出"></a>-e-彩色输出</h2><p>使用echo命令的<code>-e</code>选项，除了<strong>能够输出转义字符</strong>，还能够在命令行中<strong>输出彩色的字符</strong>，或者<strong>带有彩色背景的字符</strong>，先来一个示例感受一下:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印红色字体</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果见下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo彩色打印.png" alt="echo彩色打印.png"></p><p>不仅可以显示红色，还可以设置背景、闪烁灯效果，是不是觉得很炫酷，接下来就对这个用法进行学习。</p><h3 id="颜色输出命令格式"><a href="#颜色输出命令格式" class="headerlink" title="颜色输出命令格式"></a>颜色输出命令格式</h3><p>如果排除上述命令中的需要红色标注的字串TEST，可以发现控制颜色输出的由两部分构成：<code>\033[31m</code>和<code>\033[0m</code>(<strong>ANSI控制码</strong>)，完整代码见下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>具体两部分的作用</strong>：</p><ul><li><code>\033[31m</code>表明开始对字符进行颜色渲染</li><li><code>\033[0m</code>表明停止对字符进行渲染，如果不加的话后续的整个终端都会变成红色</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo终止颜色渲染.png" alt="echo终止颜色渲染.png"></p><hr><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>通过上面的学习，我们已经知道是什么在控制颜色的输出，然而在实际应用中肯定也不会只想输出红色的内容，当然bash shell也允许更多颜色的支持，接下来我们就来了解什么控制了具体的字体颜色以及支持的字体颜色包括哪些。</p><p>还是前面用到的命令，其中<code>31m</code>中的<code>31</code>是用来控制颜色输出的，表明输出字体为红色：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>具体各个字体颜色</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 3&#123;0..7&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 输出原始命令，注意不能使用单引号，不能进行变量替换</span></span><br><span class="line">  <span class="comment"># 也不能使用双引号，不然直接输出颜色了</span></span><br><span class="line">  <span class="comment"># 刚好不加引号可以进行简单的转义以及变量替换</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="built_in">echo</span> -e \<span class="string">"\\033[<span class="variable">$&#123;i&#125;</span>mTEST\\033[0m\"</span></span><br><span class="line"><span class="string">  echo -e "</span>\033[<span class="variable">$&#123;i&#125;</span>mTEST\033[0m<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo各种颜色输出.png" alt="echo各种颜色输出.png"></p><p><strong>具体颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">颜色</th><th width="60%">完整命令</th></tr><tr><td>30</td><td><strong>黑色</strong></td><td><code>echo -e "\033[30mTEST\033[0m"</code></td></tr><tr><td>31</td><td><strong>红色</strong></td><td><code>echo -e "\033[31mTEST\033[0m"</code></td></tr><tr><td>32</td><td><strong>绿色</strong></td><td><code>echo -e "\033[32mTEST\033[0m"</code></td></tr><tr><td>33</td><td><strong>黄色</strong></td><td><code>echo -e "\033[33mTEST\033[0m"</code></td></tr><tr><td>34</td><td><strong>蓝色</strong></td><td><code>echo -e "\033[34mTEST\033[0m"</code></td></tr><tr><td>35</td><td><strong>紫色</strong></td><td><code>echo -e "\033[35mTEST\033[0m"</code></td></tr><tr><td>36</td><td><strong>浅蓝色</strong></td><td><code>echo -e "\033[36mTEST\033[0m"</code></td></tr><tr><td>37</td><td><strong>白色</strong></td><td><code>echo -e "\033[37mTEST\033[0m"</code></td></tr></table><hr><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>除了能够修改字体颜色之外，bash shell还支持对背景颜色的修改以及与字体颜色的组合：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 黄色背景，红色字体</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[43;31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>具体各个背景颜色(固定字体为红色)</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用sed命令将之前的代码注释</span></span><br><span class="line">sed -i <span class="string">'2,$s/^/#/'</span> color.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 4&#123;0..7&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="built_in">echo</span> -e \<span class="string">"\\033[<span class="variable">$&#123;i&#125;</span>\;31mTEST\\033[0m\"</span></span><br><span class="line"><span class="string">  echo -e "</span>\033[<span class="variable">$&#123;i&#125;</span>;31mTEST\033[0m<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo各种背景颜色输出.png" alt="echo各种背景颜色输出.png"></p><p><strong>具体背景颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">背景颜色</th><th width="60%">完整命令(字体颜色为红色)</th></tr><tr><td>40</td><td><strong>黑色</strong></td><td><code>echo -e "\033[40;31mTEST\033[0m"</code></td></tr><tr><td>41</td><td><strong>红色</strong></td><td><code>echo -e "\033[41;31mTEST\033[0m"</code></td></tr><tr><td>42</td><td><strong>绿色</strong></td><td><code>echo -e "\033[42;31mTEST\033[0m"</code></td></tr><tr><td>43</td><td><strong>黄色</strong></td><td><code>echo -e "\033[43;31mTEST\033[0m"</code></td></tr><tr><td>44</td><td><strong>蓝色</strong></td><td><code>echo -e "\033[44;31mTEST\033[0m"</code></td></tr><tr><td>45</td><td><strong>紫色</strong></td><td><code>echo -e "\033[45;31mTEST\033[0m"</code></td></tr><tr><td>46</td><td><strong>浅蓝色</strong></td><td><code>echo -e "\033[46;31mTEST\033[0m"</code></td></tr><tr><td>47</td><td><strong>白色</strong></td><td><code>echo -e "\033[47;31mTEST\033[0m"</code></td></tr></table><div class="note info"><p>上述的字体颜色固定为了红色，实际使用过程中背景颜色和字体颜色可以组合，形成多种输出样式。</p></div><hr><h3 id="ansi控制码总结"><a href="#ansi控制码总结" class="headerlink" title="ansi控制码总结"></a>ansi控制码总结</h3><p>ansi控制码中不仅有控制颜色的控制码，还有一些提供其他功能的控制码，如闪烁、加粗、下划线等，我们来总结一下：</p><table><tr><th width="20%">ANSI控制码</th><th width="40%">说明</th><th width="40%">完整命令示例</th></tr><tr><td><code>\033[0m</code></td><td>关闭所有属性，也就是说此控制码前面的控制码将会失效。</td><td><code>echo -e "\033[31;0;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[1m</code></td><td><strong>设置高亮度(加粗)</strong></td><td><code>echo -e "\033[1;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[4m</code></td><td><strong>下划线</strong></td><td><code>echo -e "\033[4;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[5m</code></td><td><strong>闪烁</strong></td><td><code>echo -e "\033[5;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[7m</code></td><td>反显，撞色显示，显示为白底黑字，或者显示为黑底白字，也可以和字体、背景颜色搭配</td><td><code>echo -e "\033[7mTEST\033[0m"</code></td></tr><tr><td><code>\033[8m</code></td><td>消隐，字符颜色将会与背景颜色相同，<strong>忽略设置的字体颜色</strong></td><td><code>echo -e "\033[8;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[30m--\33[37m</code></td><td>设置字符颜色</td><td><code>echo -e "\033[31mTEST\033[0m"</code></td></tr><tr><td><code>\033[40m--\33[47m</code></td><td>设置背景色</td><td><code>echo -e "\033[41mTEST\033[0m"</code></td></tr></table><p><strong>实际效果</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ansi控制码总结.png" alt="ansi控制码总结.png"></p><div class="note info"><p>上述是<strong>常用的</strong>ansi控制码总结，还有一些与<strong>光标相关(位置、移动和显隐)</strong>以及<strong>清屏相关的</strong>ansi控制码个人感觉用的很少就没有在这里列出，需要的话后续在补充学习，可以参考<a href="http://www.mamicode.com/info-detail-2555216.html" target="_blank" rel="noopener">这个链接</a>。</p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/96" target="_blank" rel="noopener">echo命令详解 （一） 真的很详细</a></li><li><a href="http://www.zsythink.net/archives/111" target="_blank" rel="noopener">echo命令详解 （二） 真的很详细</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Linux中&lt;strong&gt;非常常用的输出字符串命令&lt;code&gt;echo&lt;/code&gt;&lt;/strong&gt;，包括使用&lt;strong&gt;参数&lt;code&gt;-n&lt;/code&gt;来不换行输出&lt;/strong&gt;、使用&lt;strong&gt;参数&lt;code&gt;-e&lt;/code&gt;来支持各种转义字符&lt;/strong&gt;、&lt;strong&gt;字符串不加或加单或加双引号的区别和使用范围&lt;/strong&gt;以及最后还学习了&lt;strong&gt;非常强大的使用&lt;code&gt;-e&lt;/code&gt;参数来进行输出样式更改(字体颜色、背景颜色、字体闪烁、下划线和加粗等)&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>未完成-screen-远程会话管理工具</title>
    <link href="http://showteeth.tech/posts/33882.html"/>
    <id>http://showteeth.tech/posts/33882.html</id>
    <published>2019-03-28T16:26:28.000Z</published>
    <updated>2019-03-29T02:58:49.081Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/index.html" target="_blank" rel="noopener">linux 技巧：使用 screen 管理你的远程会话</a></li><li><a href="https://www.vpser.net/manage/screen.html" target="_blank" rel="noopener">SSH远程会话管理工具 - screen使用教程</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="noopener">Linux 技巧：让进程在后台可靠运行的几种方法</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nohup、disown和&amp;-任务管理</title>
    <link href="http://showteeth.tech/posts/19305.html"/>
    <id>http://showteeth.tech/posts/19305.html</id>
    <published>2019-03-28T08:45:22.000Z</published>
    <updated>2019-03-29T02:58:04.505Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要围绕任务管理，包括<code>不挂断地运行(nohup命令)</code>、<code>补救命令(disown命令)</code>和<code>&amp;</code>后台运行，学习了<strong>如何使用nohup</strong>、<strong>在没使用nohup的情况下如何补救</strong>、<strong>如何将任务放在后台运行</strong>以及<strong>前后台切换相关操作</strong>。</p></div><a id="more"></a><h2 id="nohup简介"><a href="#nohup简介" class="headerlink" title="nohup简介"></a>nohup简介</h2><p><strong>背景问题</strong>：我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何<strong>让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？</strong></p><p><strong>原因</strong>：当用户注销(logout)或者网络断开时，<strong>终端会收到 HUP(hangup)信号从而关闭其所有子进程</strong>；对应到上面的背景问题，当本地终端窗口关闭或者网络连接断开后，终端收到信号导致所有的任务(子进程)都被关闭，具体的过程如下：</p><ul><li>用户退出 session(终端)</li><li>系统向该 session 发出HUP信号</li><li>session 将HUP信号发给所有子进程</li><li>子进程收到HUP信号后，自动退出</li></ul><p><strong>解决办法</strong>：针对上面的问题和原因，很容易想到<strong>如果我们可以让终端忽略HUP(hangup)信号是不是就可以完美解决本地终端窗口关闭或者网络连接断开对任务的影响</strong>，这正是今天要学习的命令<code>nohup</code>的功能。</p><p><code>nohup</code>虽然一直在使用，但是关于其和<code>&amp;</code>的关系一直有些困惑，这里对<code>nohup</code>命令进行详细的学习，希望能够解决我的困惑。</p><hr><h2 id="nohup用法"><a href="#nohup用法" class="headerlink" title="nohup用法"></a>nohup用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: nohup COMMAND [ARG]...</span><br><span class="line">  or:  nohup OPTION</span><br></pre></td></tr></table></figure><p><strong>Run COMMAND, ignoring hangup signals.</strong></p><div class="note info"><p><strong>nohup命令具体作用</strong>：</p><ul><li><strong>阻止HUP信号</strong>发到session下的子进程</li><li><strong>关闭标准输入</strong>，该进程不再能够接收任何输入，<strong>即使运行在前台</strong></li><li>重定向标准输出和标准错误到文件nohup.out(默认，可以指定)</li></ul></div><hr><h2 id="nohup实例"><a href="#nohup实例" class="headerlink" title="nohup实例"></a>nohup实例</h2><h3 id="默认用法"><a href="#默认用法" class="headerlink" title="默认用法"></a>默认用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略挂起信号</span></span><br><span class="line">nohup ./test.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，会将标准输出和标准错误结果重定向到当前文件夹下的nohup.out中</span></span><br><span class="line">nohup: ignoring input and appending output to `nohup.out<span class="string">'</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>nohup</code><strong>只是可以忽略挂起信号</strong>，也就是<strong>不管终端或者网络是不是正常，都会继续运行(退出终端然后重新登录可发现<code>nohup.out</code>文件大小还在变大，程序还在运行)</strong>，但是<strong>仍然是在<u>前台运行</u></strong>，当前的窗口会一直等待命令运行结束才会允许输入下一个命令。</p></div><div class="note warning"><p>既然忽略挂起信号之后，退出终端命令还可以执行，那这和后台的区别在哪里呢？后台仅仅是解放了当前窗口吗？—&gt;后面会有解答</p></div><hr><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出重定向</span></span><br><span class="line"><span class="comment"># 标准输出重定向到文件test.log，标准错误输出(2)重定向等同于标准输出(1)</span></span><br><span class="line">nohup ./test.sh &gt;test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><hr><h3 id="终端进程与其子进程"><a href="#终端进程与其子进程" class="headerlink" title="终端进程与其子进程"></a>终端进程与其子进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略挂起信息</span></span><br><span class="line">nohup ./test.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找通过top得到的nohup命令的pid</span></span><br><span class="line"><span class="comment"># 第二列为命令的pid，第三列为命令的父进程号(这里是终端)</span></span><br><span class="line"><span class="comment"># 由于nhup命令是在一个终端上提交的，而grep是在另一个终端上执行的</span></span><br><span class="line"><span class="comment"># 所以两个命令的第三列不同，有不同的父进程号，两者属于不同的父进程</span></span><br><span class="line">ps -ef|grep 72502</span><br><span class="line">  user    72502  68858 98 17:34 pts/2    00:00:33 /bin/sh ./test.sh</span><br><span class="line">  user    72568  68932  0 17:35 pts/3    00:00:00 grep 72502</span><br></pre></td></tr></table></figure><p><strong>通过上面的命令可以知道，如果终端关闭(也就是第三列的父进程关闭)，该父进程所有的子进程(也就是第二列，在该终端上执行的所有命令)都会被关闭。</strong></p><hr><h3 id="nohup之后命令还是随终端退出"><a href="#nohup之后命令还是随终端退出" class="headerlink" title="nohup之后命令还是随终端退出"></a>nohup之后命令还是随终端退出</h3><p>这个问题我也没遇到过，但是学习的时候发现有人遇到过类似的问题，为了方便以后可能问题的解决，这里记录一下：</p><blockquote><p>有时候在nohup会有问题，当把终端关闭后，进程会自动被关闭，察看nohup.out可以看到在关闭终端瞬间服务自动关闭；咨询红旗Linux工程师后，他也不得其解，在我的终端上执行后，他启动的进程竟然在关闭终端后依然运行；在第二遍给我演示时，我才发现我和他<strong>操作终端时的一个细节不同</strong>：他是在当shell中提示了<strong>nohup成功后</strong>还需要按终端上键盘任意键<strong>退回到shell输入命令窗口</strong>，然后通过在shell中<strong>输入exit来退出终端</strong>；而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端.。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。</p></blockquote><hr><p><br></p><h2 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h2><p>前面提到的<strong>终端收到 HUP(hangup)信号从而关闭其所有子进程关闭</strong>，<strong>一种解决方法是使用nohup让终端忽略HUP(hangup)信号</strong>，<strong>另一种想法就是让提交的任务不属于当前终端的子进程(相当于上面的第三列不同)，这种做法对应的命令是<code>setsid</code>，但是感觉这是治标不治本的方法，并不是很实用</strong>，如果想了解可查看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="noopener">这个链接</a>。</p><hr><h2 id="nohup和-amp-命令的困惑"><a href="#nohup和-amp-命令的困惑" class="headerlink" title="nohup和&amp;命令的困惑"></a>nohup和&amp;命令的困惑</h2><p><strong>困惑来源</strong>：<strong>放在后台之后命令即使关闭了当前的终端，命令还是可以在后台运行，这是为啥？</strong></p><p>针对上述困惑，我在网上查找了各种资源，大多都是说<code>nohup</code>负责忽略挂起信号，而<code>&amp;</code>负责将命令放在后台运行，这与我的实际实践不符合(感觉网上很多资源都是相互复制，并没有做到自己实践，当然也有可能和自己的服务器配置相关)，随后我查找了<a href="https://stackoverflow.com/questions/15595374/whats-the-difference-between-nohup-and-ampersand" target="_blank" rel="noopener">英文资料</a>，根据文中提示的命令<code>shopt | grep hupon</code>发现我的服务器的设置为<code>huponexit off</code>，按照文中的说法是不会将HUP(hangup)信号发给所有子进程，但是前面自己实践发现退出终端后命令会直接停止，表明还是有将HUP(hangup)信号发给所有子进程，基于此，我只能继续<a href="https://www.cnblogs.com/0616--ataozhijia/p/8037887.html" target="_blank" rel="noopener">查找资料</a>，发现<strong>区别在于前台和后台</strong>：</p><ul><li><mark>前台任务会随着 session 的退出而退出：因为它收到了HUP(hangup)信号(参考文章开头的流程)</mark></li><li><mark>后台任务是否也会收到HUP(hangup)信号才是由上面的命令<code>shopt | grep hupon</code>决定的，也就是<code>huponexit off</code>，不会收到这个信号</mark></li></ul><p>自此，困惑我许久的问题得到了解决，感觉真好(网上资料非常多，自己还是要实践才能辨别好坏啊！！)</p><hr><p><br></p><h2 id="补救措施"><a href="#补救措施" class="headerlink" title="补救措施"></a>补救措施</h2><p><strong>问题背景</strong>：经过前面的学习，我们已经知道了<strong>事先在命令前加上 <code>nohup</code> 或者 <code>setsid</code> 就可以避免 HUP 信号的影响</strong>，但是<strong>如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？</strong></p><p><strong>解决方法</strong>：针对上面的问题，可以使用Linux的<code>disown</code>命令</p><h3 id="disown用法"><a href="#disown用法" class="headerlink" title="disown用法"></a>disown用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  <span class="built_in">disown</span> [-h] [-ar] [jobspec ...]</span><br></pre></td></tr></table></figure><ul><li><strong>Without options</strong>, <u>each jobspec is removed from the table of active jobs</u>.</li><li>If the <strong>-h option is given</strong>, each jobspec is not removed from the table, but is marked so that <u>SIGHUP is not sent to the job if the shell receives a SIGHUP</u>.</li><li>If <strong>no jobspec is present</strong>, <strong>and neither the -a nor the -r option is supplied</strong>, the <u>current job is used</u>.</li><li><strong>If no jobspec is supplied</strong>, <u>the -a option means to remove or mark all jobs</u>; <u>the -r option without a jobspec argument restricts operation to running jobs</u>.</li><li>The <strong>return value</strong> is 0 unless a jobspec does not specify a valid job.</li></ul><p>通过上面英文的说明，我们可以这么使用：</p><ul><li>用<code>disown -h jobspec</code>来使<strong>某个作业忽略HUP信号</strong></li><li>用<code>disown -ah</code> 来使<strong>所有的作业都忽略HUP信号</strong></li><li>用<code>disown -rh</code> 来使<strong>正在运行的作业忽略HUP信号</strong></li></ul><p>需要注意的是：<strong>当使用过 <code>disown</code> 之后，会将把目标作业从作业列表中移除，我们将不能再使用<code>jobs</code>来查看它，但是依然能够用<code>ps -ef</code>查找到它</strong>。</p><p><strong>但是还有一个问题</strong>，这种方法的<strong>操作对象是作业</strong>，如果我们在运行命令时在结尾加了<code>&quot;&amp;&quot;</code>来<strong>使它成为一个作业并在后台运行</strong>，那么就万事大吉了，我们可以通过<code>jobs</code>命令来得到所有作业的列表。但是<strong>如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？</strong>答案就是用 <code>CTRL-z</code>(按住Ctrl键的同时按住z键)了！<code>CTRL-z</code> 的用途就是<strong>将当前进程挂起(Suspend)</strong>，<strong>然后我们就可以用jobs命令来查询它的作业号</strong>，再用<code>bg jobspec</code>来<strong>将它放入后台并继续运行</strong>，<strong>需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</strong></p><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="命令已在后台运行"><a href="#命令已在后台运行" class="headerlink" title="命令已在后台运行"></a>命令已在后台运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令先放在后台运行</span></span><br><span class="line"><span class="comment"># 按照前面对我困惑的解答，其实这里已经不需要在将其设置nohup了</span></span><br><span class="line"><span class="comment"># 但是为了以防万一，以及严谨性，还是学习一番</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br><span class="line">  [1] 101367</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用jobs查看后台命令</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Running                 ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用disown命令</span></span><br><span class="line"><span class="built_in">disown</span> -h %1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程ID和父进程ID</span></span><br><span class="line">ps -ef |grep 101367</span><br><span class="line">  user   101367  91326 96 00:15 pts/4    00:00:45 bash</span><br><span class="line">  user   101426  91326  0 00:16 pts/4    00:00:00 grep 101367</span><br></pre></td></tr></table></figure><hr><h4 id="命令未放在后台"><a href="#命令未放在后台" class="headerlink" title="命令未放在后台"></a>命令未放在后台</h4><p>如果提交命令时未使用<code>&amp;</code>将命令放入后台运行，可使用 <code>CTRL-z</code> 和<code>bg jobspec</code>将其放入后台，再结合<code>jobs</code>使用<code>disown</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不放在后台的命令</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># CTRL-z挂起</span></span><br><span class="line">^Z</span><br><span class="line">  [1]+  Stopped                 ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放在后台</span></span><br><span class="line"><span class="built_in">bg</span> %1</span><br><span class="line">  [1]+ ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看后台任务</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用disown命令</span></span><br><span class="line"><span class="built_in">disown</span> -h %1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程ID和父进程ID</span></span><br><span class="line">ps -ef |grep 101496</span><br><span class="line">  user   101496  91326 88 00:17 pts/4    00:00:27 bash</span><br><span class="line">  user   101508  91326  0 00:17 pts/4    00:00:00 grep 101496</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h2><p>screen命令也可以让进程免受 HUP 信号的影响，与上面不同的是如果有大量这种命令需要在稳定的后台里运行，其可避免对每条命令都做这样的操作。由于screen命令是一个功能非常强大的命令，这里很难将其搞清楚，后续会专门学习这个命令，具体请参考<a href="http://showteeth.tech/posts/33882.html">screen-远程会话管理工具</a></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在几种方法已经介绍完毕，我们可以<strong>根据不同的场景来选择不同的方案</strong>：</p><ul><li><code>nohup/setsid</code> 无疑是临时需要时最方便的方法</li><li><code>disown</code> 能帮助我们来<strong>事后补救</strong>当前已经在运行了的作业</li><li><code>screen</code> 则是在<strong>大批量操作</strong>时不二的选择了</li></ul><hr><p><br></p><h2 id="amp-后台运行"><a href="#amp-后台运行" class="headerlink" title="&amp;后台运行"></a>&amp;后台运行</h2><p>前面其实已经提到和使用过后台运行任务的用法：在命令之后增加<code>&amp;</code>，同时也解决了我再<code>nohup</code>和<code>&amp;</code>之间存在的困惑，这里就再对<code>&amp;</code>进行更加全面的学习。</p><p>之所以需要学习后台运行任务的命令，是因为当我们在终端或控制台工作时，不希望由于运行一个作业而占住了屏幕，而常规的添加或者不添加nohup都会使得任务占据当前终端或控制台，想要进行下一步操作只能等待当前工作结束，这个非常耽误时间，而使用<code>&amp;</code>来将任务放入后台后，就可在当前终端或工作台进行更多的操作，非常方便(<strong>需要注意如果没有使用nohup、并且没有将输出重定向，屏幕会显示大量输出结果</strong>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用nohup不挂断地运行任务，并将输出重定向到默认的nohup.out</span></span><br><span class="line">nohup ./test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行，输出结果显示在屏幕上(那种正在操作其他命令，忽然输出结果的这种)</span></span><br><span class="line">./test.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行，指定输出重定向文件(屏幕不再有输出内容)</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nohup加上&amp;</span></span><br><span class="line"><span class="comment">#其实根据我上面困惑的解答，在我这台服务器上对于后台任务使不使用nohup都可以</span></span><br><span class="line">nohup ./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p></p><h3 id="后台任务的两个特点"><a href="#后台任务的两个特点" class="headerlink" title="后台任务的两个特点"></a>后台任务的两个特点</h3><ul><li><strong>继承当前 session (对话)的标准输出(stdout)和标准错误(stderr)</strong>，因此，<strong>后台任务的所有输出依然会同步地在命令行下显示</strong></li><li><strong>不再继承当前 session 的标准输入(stdin)</strong>，你<strong>无法向这个任务输入指令了</strong>，如果它试图读取标准输入，就会暂停执行(halt)</li></ul><p><strong><code>后台任务</code>与<code>前台任务</code>的<code>本质区别</code>只有一个：是否继承标准输入</strong></p><hr><h3 id="监控杀死后台任务"><a href="#监控杀死后台任务" class="headerlink" title="监控杀死后台任务"></a>监控杀死后台任务</h3><p>前面提交后台任务之后会返回得到任务的进程号，依据这个进程号我们可以监控(<code>ps -ef |grep job进程号</code>)或者杀死(<code>kill -9 job进程号或者kill %job序号</code>)后台的任务：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交后台任务</span></span><br><span class="line">nohup ./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br><span class="line">  [1] 138837</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控后台任务</span></span><br><span class="line">ps -ef |grep 138837</span><br><span class="line">  songyb   138837  91326 96 09:19 pts/4    00:00:16 /bin/sh ./test.sh</span><br><span class="line">  songyb   138912  91326  0 09:20 pts/4    00:00:00 grep 138837</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉任务</span></span><br><span class="line"><span class="built_in">kill</span> -9 138837</span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Killed                  nohup ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉任务</span></span><br><span class="line"><span class="built_in">kill</span> %1</span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">[1]+  Terminated              nohup ./test.sh &gt; test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>如果当时没有记下进程号，可以使用<code>echo $!</code>得到<strong>当前终端</strong>提交的<strong>最后一个后台任务</strong>的进程号，注意是<strong>当前终端，不能在其他终端进行查找</strong></p></div><hr><h3 id="切换前后台相关命令"><a href="#切换前后台相关命令" class="headerlink" title="切换前后台相关命令"></a>切换前后台相关命令</h3><ul><li><code>ctrl+z</code>：將前台任务丟到后台中暂停，配合<code>bg %job序号</code>使用</li><li><code>jobs</code>：查看后台的工作状态</li><li><code>bg %job序号</code>：将任务放到后台中去处理</li><li><code>fg %job序号</code>：将后台的任务拿到前台来处理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先提交一个前台的任务，终端会等待命令运行结束</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl+z挂起命令，將前台任务丟到后台中暂停</span></span><br><span class="line">^Z</span><br><span class="line">  [1]+  Stopped                 ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># jobs查看工作状态</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Stopped                 ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># bg %job序号：将任务放入后台</span></span><br><span class="line"><span class="built_in">bg</span> %1</span><br><span class="line">  [1]+ ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看任务状态</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Running                 ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># fg %job序号：将后台的任务拿到前台来处理</span></span><br><span class="line"><span class="built_in">fg</span> %1</span><br><span class="line">  ./test.sh &gt; test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>job序号</strong>就是使用<code>jobs</code>命令查看的当前终端的任务序号，如<code>[1]+ Stopped ./test.sh &gt; test.log 2&gt;&amp;1</code>中的<code>[1]</code>，而<strong>不是通过<code>top</code>查看的进程号</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="noopener">Linux 技巧：让进程在后台可靠运行的几种方法-讲解非常好</a></li><li><a href="https://www.cnblogs.com/0616--ataozhijia/p/8037887.html" target="_blank" rel="noopener">[Linux] Linux 守护进程的启动方法-背后的原理</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要围绕任务管理，包括&lt;code&gt;不挂断地运行(nohup命令)&lt;/code&gt;、&lt;code&gt;补救命令(disown命令)&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;后台运行，学习了&lt;strong&gt;如何使用nohup&lt;/strong&gt;、&lt;strong&gt;在没使用nohup的情况下如何补救&lt;/strong&gt;、&lt;strong&gt;如何将任务放在后台运行&lt;/strong&gt;以及&lt;strong&gt;前后台切换相关操作&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>wget-命令行下载工具</title>
    <link href="http://showteeth.tech/posts/44952.html"/>
    <id>http://showteeth.tech/posts/44952.html</id>
    <published>2019-03-27T14:09:41.000Z</published>
    <updated>2019-03-28T08:16:07.028Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux的命令行下载命令wget，其可以实现<strong>断点续传</strong>、<strong>代理下载</strong>、<strong>批量下载</strong>以及<strong>下载整个网站</strong>等强大的功能；这里主要学习的参数包括<code>-O</code>、<code>-q</code>、<code>-o</code>、<code>-c</code>、<code>-b</code>、<code>用户名和密码登录</code>、<code>下载限速</code>、<code>测试下载链接</code>、<code>-t</code>、<code>-i</code>、<code>下载整个网站</code>、<code>镜像下载</code>、<code>-R</code>、<code>-A</code>、<code>-w</code>、<code>-U</code>、<code>-Q</code>，其他参数可以查看帮助文档。</p></div><a id="more"></a><h2 id="wget简介"><a href="#wget简介" class="headerlink" title="wget简介"></a>wget简介</h2><p><code>wget</code>是linux上的命令行的下载工具。这是一个GPL许可证下的自由软件。<code>Linux wget</code>支持<code>HTTP</code>和<code>FTP</code>协议，支持<strong>代理服务器</strong>和<strong>断点续传功能</strong>，能够<strong>自动递归远程主机的目录</strong>，<strong>找到合乎条件的文件并将其下载到本地硬盘上</strong>；如果必要，Linux wget将恰当地转换页面中的超级链接以在本地生成可浏览的镜像。由于没有交互式界面，<strong>Linux wget可在后台运行</strong>，截获并忽略HANGUP信号，因此在用户退出登录以后，仍可继续运行。通常，Linux wget用于<strong>成批量地下载</strong>Internet网站上的文件，或<strong>制作远程网站的镜像</strong>。</p><div class="note info"><p>wget<strong>最大的缺点</strong>是单线程，不支持多线程下载</p></div><hr><h2 id="wget用法"><a href="#wget用法" class="headerlink" title="wget用法"></a>wget用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  wget [OPTION]... [URL]...</span><br></pre></td></tr></table></figure><p>由于wget的参数较多，而平常对于其使用要求也不是很高，所以这里就结合实例进行学习，对其参数不做细致学习，需要的时候可以使用<code>wget --help</code>查看帮助文档。</p><hr><h2 id="wget实例学习"><a href="#wget实例学习" class="headerlink" title="wget实例学习"></a>wget实例学习</h2><h3 id="默认-使用wget下载单个文件"><a href="#默认-使用wget下载单个文件" class="headerlink" title="默认-使用wget下载单个文件"></a>默认-使用wget下载单个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p>以下的例子是从网络下载一个文件<strong>并保存在当前目录</strong>，在下载的过程中会显示如下信息：</p><ul><li>正在下载的文件的名称</li><li>显示下载百分比的进度条</li><li>已下载文件的大小</li><li>当前下载速度</li><li>剩余下载时间(下载完成之后会显示下载用时)</li></ul><div class="note info"><p><strong>默认情况下保存的文件为下载的文件名</strong>，如上述的<code>Homo_sapiens.GRCh38.95.chr.gff3.gz</code></p></div><hr><h3 id="O-指定保存文件名"><a href="#O-指定保存文件名" class="headerlink" title="-O-指定保存文件名"></a>-O-指定保存文件名</h3><p>如上所述，wget默认会以最后一个<code>/</code>的后面的字符来命名下载的文件，这<strong>对于动态链接的下载通常会是错误的</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载动态链接内容(这里的示例不是很好，知道有这个情况即可)</span></span><br><span class="line">wget https://blog.csdn.net/chenbang110/article/details/7854384</span><br></pre></td></tr></table></figure><p></p><p>使用上述命令下载结束后会在当前目录得到名为<code>7854384</code>的文件，而实际上该文件是个<code>html</code>文件。</p><p>为了解决上面出现的问题，<strong>可以使用<code>-O</code>指定输出文件名来解决</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出文件名</span></span><br><span class="line">wget https://blog.csdn.net/chenbang110/article/details/7854384 -O test.html</span><br></pre></td></tr></table></figure><p></p><p>使用上述命令之后会在当前目录得到名为<code>test.html</code>的文件，下载到本地打开可以得到刚刚显示的博客内容，说明<strong>原本是<code>html</code>格式，但是仍然会以最后一个<code>/</code>的后面的字符来命名，忽略文件格式</strong>。</p><div class="note info"><p>个人感觉除了在动态链接下使用这个 <strong><code>-O</code>(大写的)</strong>之外，正常情况下还是使用默认的文件名吧，这样下载的文件的后缀是正确的，自己指定可能会出错，导致文件不能正确打开。</p></div><hr><h3 id="q-无提示下载"><a href="#q-无提示下载" class="headerlink" title="-q-无提示下载"></a>-q-无提示下载</h3><p><strong>默认情况下，下载的时候会显示很多信息</strong>(比如链接状态、正在下载的文件的名称、下载速度等)，<strong>如果不想显示这些内容可以使用<code>-q</code>参数来达到静默下载的目的</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动静默下载，不显示任何信息，包括网络的连接信息</span></span><br><span class="line">wget -q ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="o-保存下载日志文件"><a href="#o-保存下载日志文件" class="headerlink" title="-o-保存下载日志文件"></a>-o-保存下载日志文件</h3><p>使用上面的-q进行无提示下载虽然使得屏幕上没有了杂乱的信息，但是自己也不知道下载的具体情况，所以这个时候就希望可以将下载信息输出到下载日志文件，<strong>wget支持使用<code>-o</code>命令来指定日志文件名称</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定日志文件</span></span><br><span class="line"><span class="comment"># -o,  --output-file=FILE    log messages to FILE.</span></span><br><span class="line">wget -o test.log ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><p>指定<code>-o</code>后下载过程不会显示信息，所有的下载信息都会被保存到指定的日志文件中</p><hr><h3 id="c-断点续传"><a href="#c-断点续传" class="headerlink" title="-c-断点续传"></a>-c-断点续传</h3><p>在下载加大文件的情况下，可能会出现下载中断的情况，为了应对这种问题，<strong><code>wget</code>也支持使用<code>-c</code>来进行断点续传</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始使用默认的下载方式</span></span><br><span class="line">wget ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"><span class="comment"># 但是下载到36%下载就中断了</span></span><br><span class="line"><span class="comment"># 36% [======================================&gt;                                                                      ] 14,005,056  1.20M/s  eta 31s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来进行断点续传</span></span><br><span class="line">wget -c ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"><span class="comment"># 会接着上次下载的位置(36%)进行下载，并使用+表示之前下载的部分，=表示现在下载的部分</span></span><br><span class="line"><span class="comment"># 41% [+++++++++++++++++++++++++++++++++++++++====&gt;                                                                 ] 15,987,368   299K/s  eta 1m 57s</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="b-后台下载"><a href="#b-后台下载" class="headerlink" title="-b-后台下载"></a>-b-后台下载</h3><p>如果当前需要下载的文件比较大，直接放在前台下载有点耽误工作，<strong>wget支持使用<code>-b</code>参数启动后台下载</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动后台下载</span></span><br><span class="line">wget -b ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动后台下载之后会返回pid以及下载的日志文件wget-log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以结合tail命令查看下载进度</span></span><br><span class="line">tail wget-log</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Continuing in background, <strong>pid 190363</strong>.<br>Output will be written to <strong>“wget-log”</strong>.</p></blockquote><hr><h3 id="用户名和密码认证下载"><a href="#用户名和密码认证下载" class="headerlink" title="用户名和密码认证下载"></a>用户名和密码认证下载</h3><p><strong>上面使用<code>ftp</code>下载</strong>时，默认是匿名登录进行下载，如果<strong>需要登录用户名和密码的话需要使用<code>--ftp-user</code>和<code>--ftp-password</code>指定</strong>，具体如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认匿名登录：Logging in as anonymous ... Logged in!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ftp下载时设置用户名和密码登录</span></span><br><span class="line">wget --ftp-user=USERNAME --ftp-password=PASSWORD ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><p>上述是使用ftp进行下载，如果是<strong>使用<code>HTTP</code>下载</strong>，和上面类似，不过是<strong>使用<code>--http-user=USER</code>和<code>--http-password=PASS</code>来分别指定用户名和密码</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP下载时设置用户名和密码登录</span></span><br><span class="line">wget --http-user=USER --http-password=PASS  url</span><br></pre></td></tr></table></figure><p></p><p>wget还支持<strong>使用<code>--user=USER</code>和<code>--password=PASS</code>来统一进行用户名和密码的输入</strong>，<strong>不用区分<code>http</code>或者<code>ftp</code>下载</strong>，但是<strong>设置ftp和http的用户名和密码之后会覆盖这个设置的内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统一设置用户名和密码登录</span></span><br><span class="line">wget --user=USER --password=PASS  url</span><br></pre></td></tr></table></figure><p></p><p>如果担心密码泄露，不想直接指定密码，可以<strong>使用<code>--ask-password</code>选项来提示输入密码</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提示输入密码</span></span><br><span class="line"><span class="comment"># --ask-password   prompt for passwords.</span></span><br><span class="line">wget --user=USER --ask-password  url</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–limit-rate-限速下载"><a href="#–limit-rate-限速下载" class="headerlink" title="–limit-rate-限速下载"></a>–limit-rate-限速下载</h3><p>当执行wget的时候，它<strong>默认会占用全部可能的宽带下载</strong>。但是当你<strong>准备下载一个大文件</strong>，而你<strong>还需要下载其它文件时</strong>就有必要限速了，wget支持使用形如<code>--limit-rate=300k</code>的参数进行限速：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限速下载</span></span><br><span class="line">wget --<span class="built_in">limit</span>-rate=300k ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–spider-测试下载链接"><a href="#–spider-测试下载链接" class="headerlink" title="–spider-测试下载链接"></a>–spider-测试下载链接</h3><p>当你打算进行<strong>定时下载</strong>，你应该<strong>在预定时间测试下载链接是否有效</strong>，wget支持<strong>使用<code>--spider</code>参数进行链接有效性的检查</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试下载链接</span></span><br><span class="line">wget --spider ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p><strong>输出内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--2019-03-27 23:34:37--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">           =&gt; “Homo_sapiens.GRCh38.95.chr.gff3.gz.3”</span><br><span class="line">Resolving ftp.ensembl.org... 193.62.193.8</span><br><span class="line">Connecting to ftp.ensembl.org|193.62.193.8|:21... connected.</span><br><span class="line">Logging <span class="keyword">in</span> as anonymous ... Logged <span class="keyword">in</span>!</span><br><span class="line">==&gt; SYST ... <span class="keyword">done</span>.    ==&gt; PWD ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; TYPE I ... <span class="keyword">done</span>.  ==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; SIZE Homo_sapiens.GRCh38.95.chr.gff3.gz ... 38793139</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    --2019-03-27 23:34:39--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">           =&gt; “.listing”</span><br><span class="line">==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    ==&gt; LIST ... <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">    [ &lt;=&gt;                                                                                                         ] 3,175       --.-K/s   <span class="keyword">in</span> 0s      </span><br><span class="line"></span><br><span class="line">Removed “.listing”.</span><br><span class="line"><span class="comment"># 显示文件存在</span></span><br><span class="line">File “Homo_sapiens.GRCh38.95.chr.gff3.gz” exists.</span><br></pre></td></tr></table></figure><p></p><p><strong>如果文件不存在的话</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--2019-03-27 23:36:58--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz</span><br><span class="line">           =&gt; “Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz”</span><br><span class="line">Resolving ftp.ensembl.org... 193.62.193.8</span><br><span class="line">Connecting to ftp.ensembl.org|193.62.193.8|:21... connected.</span><br><span class="line">Logging <span class="keyword">in</span> as anonymous ... Logged <span class="keyword">in</span>!</span><br><span class="line">==&gt; SYST ... <span class="keyword">done</span>.    ==&gt; PWD ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; TYPE I ... <span class="keyword">done</span>.  ==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; SIZE Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    --2019-03-27 23:37:00--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz</span><br><span class="line">           =&gt; “.listing”</span><br><span class="line">==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    ==&gt; LIST ... <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">    [ &lt;=&gt;                                                                                                         ] 3,175       --.-K/s   <span class="keyword">in</span> 0.004s  </span><br><span class="line"></span><br><span class="line">Removed “.listing”.</span><br><span class="line"><span class="comment"># 显示文件不存在</span></span><br><span class="line">No such file “Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz”.</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>你可以在以下几种情况下使用<code>--spider</code>参数</strong>：</p><ul><li><strong>定时下载</strong>之前进行检查</li><li><strong>间隔检测网站是否可用</strong></li><li>检查网站页面的<strong>死链接</strong></li></ul></div><hr><h3 id="t-增加重试次数"><a href="#t-增加重试次数" class="headerlink" title="-t-增加重试次数"></a>-t-增加重试次数</h3><p>如果<strong>网络不稳定或者其他原因导致连接出现问题</strong>，wget支持<strong>使用<code>-t(--tries=NUMBER)</code>参数来设置重试的次数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置重试次数为40次</span></span><br><span class="line"><span class="comment"># set number of retries to NUMBER (0 unlimits)</span></span><br><span class="line">wget --tries=40 ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><p><strong>参数<code>-t</code>设置为0的时候是不对重试次数进行限制</strong></p><hr><h3 id="i-下载多个文件"><a href="#i-下载多个文件" class="headerlink" title="-i-下载多个文件"></a>-i-下载多个文件</h3><p>如果需要<strong>下载多个链接，可以将多个链接写入文件，然后使用<code>-i</code>参数进行文件链接的下载</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用cat命令创建并输入链接文件</span></span><br><span class="line">cat &gt; filelist.txt</span><br><span class="line">url1</span><br><span class="line">url2</span><br><span class="line">url3</span><br><span class="line">url4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-i进行文件链接的下载</span></span><br><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="递归下载整个网站"><a href="#递归下载整个网站" class="headerlink" title="递归下载整个网站"></a>递归下载整个网站</h3><p>比如在学习中我们遇到一个很好的网站，里面有很多自己需要的东西，一个一个下载太麻烦，这个时候就可以使用下面的命令直接下载整个网站(感觉不是很道德。。。)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载整个网站</span></span><br><span class="line">wget --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><p><strong>参数解读</strong>：</p><ul><li><code>--restrict-file-name=ascii</code>：<strong>防止出现中文乱码的问题</strong>，<a href="https://blog.csdn.net/kowity/article/details/6899256" target="_blank" rel="noopener">这个链接</a>中给出了改名字的程序，需要的时候可以看看</li><li><code>-r</code>(<code>--recursive</code>)：specify recursive download.（<strong>指定递归下载</strong>）</li><li><code>-k</code>(<code>--convert-links</code>)：make links in downloaded HTML point to local files.（<strong>将下载的HTML页面中的链接转换为相对链接即本地链接</strong>）</li><li><code>-p</code>(<code>--page-requisites</code>)：get all images, etc. needed to display HTML page.（<strong>下载所有的图片等页面显示所需的内容</strong>）</li><li><code>-np</code>(<code>--no-parent</code>): <strong>不追溯至父级目录</strong> don’t ascend to the parent directory.</li></ul><hr><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>当要下载一个<strong>完整站点并实现本地浏览</strong>的时候，可以使用如下命令进行下载：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启镜像下载</span></span><br><span class="line">wget --mirror -p -k -np -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p></p><p><strong>参数解读</strong>：</p><ul><li><code>-m</code>(<code>--miror</code>)：开户镜像下载</li><li><code>-p</code>：<strong>下载所有的图片等页面显示所需的内容</strong></li><li><code>-k</code>(<code>--convert-links</code>): make links in downloaded HTML point to local files.（<strong>将下载的HTML页面中的链接转换为相对链接即本地链接</strong>）</li><li><code>-P ./LOCAL</code>：保存所有文件和目录到本地指定目录</li><li><code>-np</code>(<code>--no-parent</code>): <strong>不追溯至父级目录</strong> don’t ascend to the parent directory.</li></ul><hr><h3 id="R-过滤指定格式文件"><a href="#R-过滤指定格式文件" class="headerlink" title="-R-过滤指定格式文件"></a>-R-过滤指定格式文件</h3><p>在下载的过程中，如果不想要下载后缀为<code>.png</code>的图片文件，可以使用<code>--reject=png</code>进行限制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤下载，使用逗号分隔不同格式</span></span><br><span class="line"><span class="comment"># -R,  --reject=LIST   comma-separated list of rejected extensions.</span></span><br><span class="line">wget --restrict-file-name=ascii -r -p -np -k -R <span class="string">'*.html'</span>,<span class="string">'*.css'</span> http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="A-指定下载文件格式"><a href="#A-指定下载文件格式" class="headerlink" title="-A-指定下载文件格式"></a>-A-指定下载文件格式</h3><p>上面讲解了使用-R进行过滤排除文件格式，当然也可以指定下载文件的格式，<strong>wget支持使用<code>-A</code>来指定下载文件格式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定文件格式下载</span></span><br><span class="line"><span class="comment"># -A,  --accept=LIST    comma-separated list of accepted extensions.</span></span><br><span class="line">wget --restrict-file-name=ascii -r -p -np -k -A <span class="string">'*.html'</span>,<span class="string">'*.css'</span> http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="w-设置下载等待时间"><a href="#w-设置下载等待时间" class="headerlink" title="-w-设置下载等待时间"></a>-w-设置下载等待时间</h3><p>上面在下载整个网站的时候，下载过快可能会导致ip被封禁，为了避免这种情况，可以<strong>使用<code>-w</code>设置两次下载之间的等待时间</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置两次下载之间的等待时间</span></span><br><span class="line"><span class="comment"># -w,  --wait=SECONDS    wait SECONDS between retrievals.</span></span><br><span class="line">wget -w 20 --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="U-设置header下载"><a href="#U-设置header下载" class="headerlink" title="-U-设置header下载"></a>-U-设置header下载</h3><p>有些网站可能会<strong>通过代理名称来判断是不是浏览器</strong>，从而可能拒绝下载请求，<strong>为了避免请求被拒绝，wget支持使用<code>-U(--user-agent)</code>参数来进行伪装</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动代理进行伪装</span></span><br><span class="line">wget --user-agent=<span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16"</span> --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><p><strong>越来越有种爬虫的感觉</strong>。。。。。</p><hr><h3 id="Q-限制总下载文件大小"><a href="#Q-限制总下载文件大小" class="headerlink" title="-Q-限制总下载文件大小"></a>-Q-限制总下载文件大小</h3><p>前面提到的下载整个网站虽然很好，但是如果网站太大，对下载的数据量不进行限制，很多能导致自己的服务器存储不够，这时可使用<strong>wget的<code>-Q</code>来指定总下载文件大小</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定总下载文件大小</span></span><br><span class="line"><span class="comment"># -Q,  --quota=NUMBER   set retrieval quota to NUMBER.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意其对单个文件的下载不起效，以下命令可正常下载</span></span><br><span class="line">wget -Q 5m ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对递归下载起效(也可以说链接不止一个)</span></span><br><span class="line">wget -Q 10k --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><p><strong>下载超过设置值时会提示</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br><span class="line">Download quota of 10K EXCEEDED!</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="Linux上下载迅雷内容"><a href="#Linux上下载迅雷内容" class="headerlink" title="Linux上下载迅雷内容"></a>Linux上下载迅雷内容</h3><p>参考<a href="https://www.linuxidc.com/Linux/2011-10/46052.htm" target="_blank" rel="noopener">这个链接</a></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/wget" target="_blank" rel="noopener">wget命令-实例讲解</a></li><li><a href="https://www.linuxidc.com/Linux/2018-02/150757.htm" target="_blank" rel="noopener">Linux wget命令实例讲解</a></li><li><a href="https://vpsps.com/1325.html" target="_blank" rel="noopener">最后列出了参数，可以看看</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux的命令行下载命令wget，其可以实现&lt;strong&gt;断点续传&lt;/strong&gt;、&lt;strong&gt;代理下载&lt;/strong&gt;、&lt;strong&gt;批量下载&lt;/strong&gt;以及&lt;strong&gt;下载整个网站&lt;/strong&gt;等强大的功能；这里主要学习的参数包括&lt;code&gt;-O&lt;/code&gt;、&lt;code&gt;-q&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;用户名和密码登录&lt;/code&gt;、&lt;code&gt;下载限速&lt;/code&gt;、&lt;code&gt;测试下载链接&lt;/code&gt;、&lt;code&gt;-t&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;下载整个网站&lt;/code&gt;、&lt;code&gt;镜像下载&lt;/code&gt;、&lt;code&gt;-R&lt;/code&gt;、&lt;code&gt;-A&lt;/code&gt;、&lt;code&gt;-w&lt;/code&gt;、&lt;code&gt;-U&lt;/code&gt;、&lt;code&gt;-Q&lt;/code&gt;，其他参数可以查看帮助文档。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>more和less-查看文本内容</title>
    <link href="http://showteeth.tech/posts/57059.html"/>
    <id>http://showteeth.tech/posts/57059.html</id>
    <published>2019-03-26T08:50:15.000Z</published>
    <updated>2019-03-29T03:16:49.780Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux查看文本内容的常用命令<code>more</code>以及<code>less</code>，两个命令很多地方都很相似，但是<code>less</code><strong>更加强大</strong>；分别学习了<code>more</code>和<code>less</code>的<strong>参数</strong>以及<strong>命令</strong>，其中<code>less</code>部分的参数和命令 <strong>只学习了常用的部分</strong>(<code>less</code>的功能很强大，对应的参数和命令很多，但是很多用不上，这里就没学习，后学如果有用在补上)。</p></div><a id="more"></a><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>more会以<strong>一页一页</strong>的显示方便使用者逐页阅读，而最基本的指令就是按<strong>空白键(space)就往下一页显示</strong>，<strong>按 b 键就会往回(back)一页显示</strong>，而且还有<strong>搜寻字串(直接跳转行)的功能</strong>,<strong>使用中按<code>h</code>可以查看说明文件</strong> 。more命令从前向后读取文件，因此在<strong>启动时就加载整个文件</strong>。</p><h3 id="more命令用法"><a href="#more命令用法" class="headerlink" title="more命令用法"></a>more命令用法</h3><h4 id="more命令格式"><a href="#more命令格式" class="headerlink" title="more命令格式"></a>more命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: </span><br><span class="line">  more [-dflpcsu] [+linenum | +/pattern] name1 name2 ...</span><br></pre></td></tr></table></figure><hr><h4 id="more-options说明"><a href="#more-options说明" class="headerlink" title="more options说明"></a>more options说明</h4><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>+n</code></td><td><strong>从笫n行开始显示</strong></td></tr><tr><td><code>-n</code></td><td><strong>定义屏幕大小为n行</strong></td></tr><tr><td><code>+/pattern</code></td><td><strong>在每个档案显示前搜寻该字串(pattern)，然后从该字串前两行之后开始显示</strong></td></tr><tr><td><code>-c</code></td><td><strong>清屏显示</strong></td></tr><tr><td><code>-d</code></td><td><strong>提示使用者，在内容下方显示 <code>[Press space to continue, &#39;q&#39; to quit.]</code> 如果按错键，则会显示 <code>[Press &#39;h&#39; for instructions.]</code> 而不是 ‘哔’ 声</strong></td></tr><tr><td><code>-l</code></td><td>忽略Ctrl+l(换页)字符</td></tr><tr><td><code>-p</code></td><td><strong>通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</strong></td></tr><tr><td><code>-s</code></td><td><strong>把连续的多个空行显示为一行</strong></td></tr><tr><td><code>-u</code></td><td>把文件内容中的下画线去掉</td></tr><tr><td><code>-f</code></td><td><strong>计算行数时，以实际上的行数，而非自动换行过后的行数(有些单行字数太长的会被扩展为两行或两行以上),可以和<code>-n</code>连用</strong></td></tr></tbody></table><hr><h4 id="more常用操作命令"><a href="#more常用操作命令" class="headerlink" title="more常用操作命令"></a>more常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>空格(space)</code></td><td><strong>向下滚动一屏</strong></td></tr><tr><td><code>z</code></td><td>向下滚动一屏</td></tr><tr><td><code>enter(return)</code></td><td><strong>向后滚动n行，默认为1</strong></td></tr><tr><td><code>q or Q or &lt;interrupt&gt;</code></td><td>退出more</td></tr><tr><td><code>b or ctrl-B</code></td><td><strong>返回上一屏</strong></td></tr><tr><td><code>=</code></td><td>输出当前行的行号</td></tr><tr><td><code>：f</code></td><td><strong>输出文件名和当前行的行号</strong></td></tr><tr><td><code>V</code></td><td>调用vi编辑器</td></tr><tr><td><code>!命令</code></td><td><strong>调用Shell，并执行命令</strong></td></tr><tr><td><code>.</code></td><td><strong>重复上一个命令</strong></td></tr></tbody></table><div class="note info"><ul><li><code>!命令</code>:输入的命令不能输错，输错了删不了；输出结果和文本内容之间使用<code>------</code>分割</li><li><code>：f</code>：使用时是按下<code>:</code>同时按下<code>f</code>，不能先按下<code>:</code>松手后再按<code>f</code></li></ul></div><hr><h4 id="参数和命令的关系"><a href="#参数和命令的关系" class="headerlink" title="参数和命令的关系"></a>参数和命令的关系</h4><div class="note info"><p><strong>参数决定了显示的内容(起始行、页面显示行数、换页是清屏还是滚动)，而命令决定了怎么去显示(翻页、滚动等)</strong>，以<code>-p</code>参数为例，规定了是清屏进行翻页，具体的翻页动作需要使用空格键操作，同时需要注意，其只规定的是换页是清屏的，如果使用<code>enter</code>进行显示下一行，仍然是滚动的方式，而不是清屏.</p></div><hr><h3 id="more命令实例"><a href="#more命令实例" class="headerlink" title="more命令实例"></a>more命令实例</h3><h4 id="n-从第n行开始显示"><a href="#n-从第n行开始显示" class="headerlink" title="+n-从第n行开始显示"></a>+n-从第n行开始显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n的索引是从1开始的</span></span><br><span class="line">more +3 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="n-每屏显示n行"><a href="#n-每屏显示n行" class="headerlink" title="-n-每屏显示n行"></a>-n-每屏显示n行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每屏显示4行，可结合空格进行翻页</span></span><br><span class="line">more -4 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="pattern-搜寻字串"><a href="#pattern-搜寻字串" class="headerlink" title="+/pattern-搜寻字串"></a>+/pattern-搜寻字串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找第一个出现"liu"字符串的行，并从该处前两行开始显示输出</span></span><br><span class="line"><span class="comment"># 输出第一行会显示...skipping</span></span><br><span class="line">more +/liu test.log</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>第一次出现字符串</li><li>出现字符串的前两行</li></ul></div><hr><h4 id="c-清屏显示"><a href="#c-清屏显示" class="headerlink" title="-c-清屏显示"></a>-c-清屏显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不使用参数的情况下，如果文件行数大于屏幕可以显示的数目，也会清屏显示</span></span><br><span class="line">more test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用了-n选项，仍然符合上面的规则，如果-n小于屏幕可以显示的数目</span></span><br><span class="line">more -4 test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c参数之后，先清屏之后再显示(不管指定的每页显示行数为多少)</span></span><br><span class="line">more -c -4 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="d-提示信息"><a href="#d-提示信息" class="headerlink" title="-d-提示信息"></a>-d-提示信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">more -d test.log</span><br><span class="line"><span class="comment"># 在显示文本下方显示</span></span><br><span class="line"><span class="comment">#  --More--(0%)[Press space to continue, 'q' to quit.</span></span><br><span class="line"><span class="comment"># 按错命令按键则会出现</span></span><br><span class="line"><span class="comment"># [Press 'h' for instructions.]</span></span><br></pre></td></tr></table></figure><hr><h4 id="f-计算实际行数"><a href="#f-计算实际行数" class="headerlink" title="-f-计算实际行数"></a>-f-计算实际行数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每页显示30行(实际行数)</span></span><br><span class="line"><span class="comment"># 如果不加-f参数的话(也就是默认情况下)显示的不是实际行数(一行太长，换行会当2行算)</span></span><br><span class="line">more -f -30 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="p-清屏换页"><a href="#p-清屏换页" class="headerlink" title="-p-清屏换页"></a>-p-清屏换页</h4><p>通过清屏来换页，而不是通过滚动页面(在同一个页面，内容增加，右侧出现滚动滑块)，和<code>-c</code>参数基本是一样的:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个结合翻页很好用，只会在页面顶端的4行显示内容，不会叠加在同一个页面</span></span><br><span class="line">more -p  -4 test.log</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p><code>less</code>工具也是<strong>对文件或其它输出进行分页显示的工具</strong>，应该说是linux<strong>正统查看文件内容的工具，功能极其强大</strong>。<code>less</code>的用法比起<code>more</code>更加的有弹性:</p><ul><li>在<code>more</code>的时候，我们并没有办法向前面翻，只能往后面看(b或者ctrl+b只是向前翻页，不能像less一样单行单行的向前滚动显示)，但若使用了 <code>less</code>，就可以使用<code>pageup</code>、<code>pagedown</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</li><li>在 <code>less</code> 里头可以拥有<strong>更多的搜索功能，不止可以向下搜，也可以向上搜</strong>，<code>more</code>只能搜素后面的，输出的内容不在搜索范围内</li></ul><h3 id="less命令格式"><a href="#less命令格式" class="headerlink" title="less命令格式"></a>less命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  less [参数]  文件</span><br></pre></td></tr></table></figure><hr><h4 id="less-options说明"><a href="#less-options说明" class="headerlink" title="less options说明"></a>less options说明</h4><p>less的功能非常强大，包含很多方面，对应的参数也非常堵，需要的可以使用<code>less --help</code>查看，这里只列出常用的参数和功能：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-m</code></td><td>显示类似more命令的百分比</td></tr><tr><td><code>-N</code></td><td>显示每行的行号</td></tr><tr><td><code>-M</code></td><td><strong>显法读取文件的百分比、行区间及总行数</strong></td></tr><tr><td><code>-e</code></td><td><strong>当文件显示结束后，自动退出</strong></td></tr><tr><td><code>-S</code></td><td><strong>Chop long lines(在单行显示较长的内容，而不换行显示)</strong></td></tr><tr><td><code>-x &lt;数字&gt;</code></td><td><strong>将TAB字符显示为指定个数的空格字符</strong></td></tr></tbody></table><hr><h4 id="less常用操作命令"><a href="#less常用操作命令" class="headerlink" title="less常用操作命令"></a>less常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>enter(回车)</code></td><td>向下移动一行</td></tr><tr><td><code>y</code></td><td>向上移动一行</td></tr><tr><td><code>pagedown</code></td><td>向下移动一行</td></tr><tr><td><code>pageup</code></td><td>向上移动一行</td></tr><tr><td><code>b</code></td><td>向上滚动一屏</td></tr><tr><td><code>空格键</code></td><td>向下滚动一屏</td></tr><tr><td><code>g</code></td><td><strong>跳到第一行</strong></td></tr><tr><td><code>G</code></td><td><strong>跳到最后一行</strong></td></tr><tr><td><code>p n%</code></td><td><strong>跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示</strong></td></tr><tr><td><code>w n</code></td><td><strong>可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的n是6，那就从第7行显示</strong></td></tr><tr><td><code>!命令</code></td><td>调用Shell，并执行命令</td></tr><tr><td><code>q</code></td><td>退出less</td></tr></tbody></table><hr><h2 id="more和less的区别"><a href="#more和less的区别" class="headerlink" title="more和less的区别"></a>more和less的区别</h2><ul><li>在<code>more</code>的时候，我们并没有办法向前面翻，只能往后面看(b或者ctrl+b只是向前翻页，不能像less一样单行单行的向前滚动显示)，但若使用了 <code>less</code>，就可以使用<code>pageup</code>、<code>pagedown</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</li><li>在 <code>less</code> 里头可以拥有<strong>更多的搜索功能，不止可以向下搜，也可以向上搜</strong>，<code>more</code>只能搜素后面的，输出的内容不在搜索范围内</li><li><code>less</code>使用退出之后屏幕<strong>不会留下显示的内容</strong>，而<code>more</code>退出之后屏幕<strong>会留下当前显示的内容</strong></li><li><code>less</code>不必读整个文件，加载速度会比<code>more</code>更快</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/aijianshi/p/5750911.html" target="_blank" rel="noopener">Linux中more和less命令用法</a></li><li><a href="http://www.cnblogs.com/xqzt/p/5414814.html" target="_blank" rel="noopener">每天一个linux命令(12):more命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux查看文本内容的常用命令&lt;code&gt;more&lt;/code&gt;以及&lt;code&gt;less&lt;/code&gt;，两个命令很多地方都很相似，但是&lt;code&gt;less&lt;/code&gt;&lt;strong&gt;更加强大&lt;/strong&gt;；分别学习了&lt;code&gt;more&lt;/code&gt;和&lt;code&gt;less&lt;/code&gt;的&lt;strong&gt;参数&lt;/strong&gt;以及&lt;strong&gt;命令&lt;/strong&gt;，其中&lt;code&gt;less&lt;/code&gt;部分的参数和命令 &lt;strong&gt;只学习了常用的部分&lt;/strong&gt;(&lt;code&gt;less&lt;/code&gt;的功能很强大，对应的参数和命令很多，但是很多用不上，这里就没学习，后学如果有用在补上)。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>未完成-Python系列之setup.py</title>
    <link href="http://showteeth.tech/posts/33963.html"/>
    <id>http://showteeth.tech/posts/33963.html</id>
    <published>2019-03-26T04:18:28.000Z</published>
    <updated>2019-03-27T06:28:05.501Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/maociping/p/6633948.html" target="_blank" rel="noopener">python的构建工具setup.py</a></li><li><a href="https://lingxiankong.github.io/2013-12-23-python-setup.html" target="_blank" rel="noopener">关于python中的setup.py</a></li><li><a href="https://blog.csdn.net/langb2014/article/details/53114341" target="_blank" rel="noopener">python的setup问题</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫之Selenium-自动化测试</title>
    <link href="http://showteeth.tech/posts/50111.html"/>
    <id>http://showteeth.tech/posts/50111.html</id>
    <published>2019-03-26T03:28:13.000Z</published>
    <updated>2019-03-26T04:06:39.725Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章将自己在使用Selenium过程中遇到的好文章进行了汇总和整理，便于后续继续使用这个工具时能尽快找到好的参考，节省时间！</p></div><a id="more"></a><h2 id="Selenium简介"><a href="#Selenium简介" class="headerlink" title="Selenium简介"></a>Selenium简介</h2><p>selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。</p><p>selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。</p><hr><h2 id="selenium用法"><a href="#selenium用法" class="headerlink" title="selenium用法"></a>selenium用法</h2><p>用python写爬虫的时候，主要用的是selenium的Webdriver，我们可以通过下面的方式先看看Selenium.Webdriver支持哪些浏览器</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193320778-188010556.png" alt></p><p>执行结果如下，从结果中我们也可以看出基本山支持了常见的所有浏览器：</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193414684-1032464838.png" alt></p><p>这里要说一下比较重要的PhantomJS,PhantomJS是一个而基于WebKit的服务端JavaScript API,支持Web而不需要浏览器支持，其快速、原生支持各种Web标准：Dom处理，CSS选择器，JSON等等。PhantomJS可以用用于页面自动化、网络监测、网页截屏，以及无界面测试</p><h3 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h3><p>上面我们知道了selenium支持很多的浏览器，但是如果想要声明并调用浏览器则需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 打开浏览器，注意需要提前下载浏览器驱动以及将其写入环境变量</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br></pre></td></tr></table></figure><p>这里只写了两个例子，当然了其他的支持的浏览器都可以通过这种方式调用。</p><p><strong>可能遇到的问题</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\selenium\webdriver\common\service.py"</span>, line <span class="number">76</span>, <span class="keyword">in</span> start</span><br><span class="line">    stdin=PIPE)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">769</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    restore_signals, start_new_session)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">1172</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">    startupinfo)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。</span><br></pre></td></tr></table></figure><p></p><p><strong>这是因为没有将浏览器驱动以及没有将浏览器驱动添加到环境变量</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 驱动下载地址</span></span><br><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载对应的chrome版本之后将压缩包解压，我下载的是chromedriver_win32.zip</span></span><br><span class="line"><span class="comment"># 发现32位的也能用，关键是只提供了32位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压上述包，然后将exe文件写入环境变量，可将exe文件放在C:\Program Files (x86)\Google\Chrome\Application目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量(可能需要重启电脑才会生效)之后直接输入</span></span><br><span class="line">chromedriver.exe</span><br><span class="line">Starting ChromeDriver <span class="number">72.0</span><span class="number">.3626</span><span class="number">.69</span> (<span class="number">3</span>c16f8a135abc0d4da2dff33804db79b849a7c38) on port <span class="number">9515</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver <span class="keyword">and</span> related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网站</span></span><br><span class="line">browser.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 输入网站源码</span></span><br><span class="line">print(browser.page_source)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>上述代码运行后，会自动打开Chrome浏览器，并登陆百度打印百度首页的源代码，然后关闭浏览器</p><hr><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="单个元素查找"><a href="#单个元素查找" class="headerlink" title="单个元素查找"></a>单个元素查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 使用id查找</span></span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">"q"</span>)</span><br><span class="line"><span class="comment"># 使用css_selector查找</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">"#q"</span>)</span><br><span class="line"><span class="comment"># 使用xpath查找</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line"></span><br><span class="line">print(input_first)</span><br><span class="line">print(input_second)</span><br><span class="line">print(input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>这里我们通过三种不同的方式去获取响应的元素，第一种是通过id的方式，第二个中是CSS选择器，第三种是xpath选择器，结果都是相同的。<br>结果如下：</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193535200-558486822.png" alt></p><p><strong>这里列举一下常用的查找元素方法</strong>：</p><ul><li><code>find_element_by_name</code></li><li><code>find_element_by_id</code></li><li><code>find_element_by_xpath</code></li><li><code>find_element_by_link_text</code></li><li><code>find_element_by_partial_link_text</code></li><li><code>find_element_by_tag_name</code></li><li><code>find_element_by_class_name</code></li><li><code>find_element_by_css_selector</code></li></ul><p>下面这种方式是比较通用的一种方式：这里需要记住By模块所以需要导入<code>from selenium.webdriver.common.by import By</code><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 设置查找的方法以及查找的对象</span></span><br><span class="line">input_first = browser.find_element(By.ID,<span class="string">"q"</span>)</span><br><span class="line"></span><br><span class="line">print(input_first)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p></p><p>当然这种方法和上述的方式是通用的，<code>browser.find_element(By.ID,&quot;q&quot;)</code>这里<code>By.ID</code>中的ID可以替换为其他几个</p><hr><h4 id="多个元素查找"><a href="#多个元素查找" class="headerlink" title="多个元素查找"></a>多个元素查找</h4><p>其实多个元素和单个元素的区别，举个例子：<code>find_elements</code>,单个元素是<code>find_element</code>,其他使用上没什么区别，通过其中的一个例子演示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 执行查找</span></span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通用的方法实现</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">lis = browser.find_elements(By.CSS_SELECTOR,<span class="string">'.service-bd li'</span>)</span><br><span class="line"></span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p></p><p>这样获得就是一个列表</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193737497-369795287.png" alt></p><p><strong>同样的在单个元素中查找的方法在多个元素查找中同样存在</strong>：</p><ul><li><code>find_elements_by_name</code></li><li><code>find_elements_by_id</code></li><li><code>find_elements_by_xpath</code></li><li><code>find_elements_by_link_text</code></li><li><code>find_elements_by_partial_link_text</code></li><li><code>find_elements_by_tag_name</code></li><li><code>find_elements_by_class_name</code></li><li><code>find_elements_by_css_selector</code></li></ul><hr><h3 id="元素交互操作"><a href="#元素交互操作" class="headerlink" title="元素交互操作"></a>元素交互操作</h3><p>对于获取的元素调用交互方法:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"></span><br><span class="line">input_str = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line"><span class="comment"># 发送信息</span></span><br><span class="line">input_str.send_keys(<span class="string">"ipad"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">input_str.clear()</span><br><span class="line"></span><br><span class="line">input_str.send_keys(<span class="string">"MakBook pro"</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line"></span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure><p></p><p><strong>运行的结果可以看出程序会自动打开Chrome浏览器并打开淘宝输入ipad,然后删除，重新输入MakBook pro，并点击搜索</strong></p><p><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">Selenium所有的api文档</a></p><p><strong>交互动作</strong></p><p><strong>将动作附加到动作链中串行执行</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">"http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable"</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"></span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line"></span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p></p><p><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">更多操作参考</a></p><hr><h3 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h3><p>这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，下面的例子是 <strong>通过登录知乎然后通过js翻到页面底部，并弹框提示</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.zhihu.com/explore"</span>)</span><br><span class="line"></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure><p></p><h4 id="获取元素属性-get-attribute-‘class’"><a href="#获取元素属性-get-attribute-‘class’" class="headerlink" title="获取元素属性-get_attribute(‘class’)"></a>获取元素属性-get_attribute(‘class’)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">logo = browser.find_element_by_id(<span class="string">'zh-top-link-logo'</span>)</span><br><span class="line"></span><br><span class="line">print(logo)</span><br><span class="line">print(logo.get_attribute(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure><hr><h4 id="获取文本值-text"><a href="#获取文本值-text" class="headerlink" title="获取文本值-text"></a>获取文本值-text</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.text)</span><br></pre></td></tr></table></figure><hr><h4 id="获取ID、位置、标签名"><a href="#获取ID、位置、标签名" class="headerlink" title="获取ID、位置、标签名"></a>获取ID、位置、标签名</h4><ul><li><code>id</code></li><li><code>location</code></li><li><code>tag_name</code></li><li><code>size</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.id)</span><br><span class="line">print(input.location)</span><br><span class="line">print(input.tag_name)</span><br><span class="line">print(input.size)</span><br></pre></td></tr></table></figure><hr><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p>在很多网页中都是有Frame标签，所以我们爬取数据的时候就涉及到切入到frame中以及切出来的问题，通过下面的例子演示<br>这里常用的是<code>switch_to.from()</code>和<code>switch_to.parent_frame()</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">print(source)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'NO LOGO'</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0</p><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>到了一定的时间发现元素还没有加载，则继续等待我们指定的时间，如果超过了我们指定的时间还没有加载就会抛出异常，如果没有需要等待的时候就已经加载完毕就会立即执行<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 设置隐式等待</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h4><p>指定一个等待条件，并且指定一个最长等待时间，会在这个时间内进行判断是否满足等待条件，如果成立就会立即返回，如果不成立，就会一直等待，直到等待你指定的最长等待时间，如果还是不满足，就会抛出异常，如果满足了就会正常返回</p><p><strong>常用的判断条件</strong>：</p><ul><li><code>title_is</code> 标题是某内容</li><li><code>title_contains</code> 标题包含某内容</li><li><code>presence_of_element_located</code> 元素加载出，传入定位元组，如(By.ID, ‘p’)</li><li><code>visibility_of_element_located</code> 元素可见，传入定位元组</li><li><code>visibility_of</code> 可见，传入元素对象</li><li><code>presence_of_all_elements_located</code> 所有元素加载出</li><li><code>text_to_be_present_in_element</code> 某个元素文本包含某文字</li><li><code>text_to_be_present_in_element_value</code> 某个元素值包含某文字</li><li><code>frame_to_be_available_and_switch_to_it</code> frame加载并切换</li><li><code>invisibility_of_element_located</code> 元素不可见</li><li><code>element_to_be_clickable</code> 元素可点击</li><li><code>staleness_of</code> 判断一个元素是否仍在DOM，可判断页面是否已经刷新</li><li><code>element_to_be_selected</code> 元素可选择，传元素对象</li><li><code>element_located_to_be_selected</code> 元素可选择，传入定位元组</li><li><code>element_selection_state_to_be</code> 传入元素对象以及状态，相等返回True，否则返回False</li><li><code>element_located_selection_state_to_be</code> 传入定位元组以及状态，相等返回True，否则返回False</li><li><code>alert_is_present</code> 是否出现Alert</li></ul><p>实例讲解，以来自<a href="https://www.cnblogs.com/yuuwee/p/6635652.html" target="_blank" rel="noopener">这篇文章</a>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"><span class="comment"># 定义等待时间，这是隐式等待，当隐式等待和显示等待都存在时，超时时间取二者中较大的，显示等待是sleep(10)这种</span></span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="comment"># 定义查找位置</span></span><br><span class="line">locator = (By.ID,<span class="string">'kw'</span>)</span><br><span class="line">driver.get(base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断title,返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.title_is(<span class="string">u"百度一下，你就知道"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断title，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.title_contains(<span class="string">u"百度一下"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被加到了dom树里，并不代表该元素一定可见，如果定位到就返回WebElement</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.presence_of_element_located((By.ID,<span class="string">'kw'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被添加到了dom里并且可见，可见代表元素可显示且宽和高都大于0</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of_element_located((By.ID,<span class="string">'su'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否可见，如果可见就返回这个元素</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of(driver.find_element(by=By.ID,value=<span class="string">'kw'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否至少有1个元素存在于dom树中，如果定位到就返回列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.presence_of_all_elements_located((By.CSS_SELECTOR,<span class="string">'.mnav'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否至少有一个元素在页面中可见，如果定位到就返回列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of_any_elements_located((By.CSS_SELECTOR,<span class="string">'.mnav'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定的元素中是否包含了预期的字符串，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.text_to_be_present_in_element((By.XPATH,<span class="string">"//*[@id='u1']/a[8]"</span>),<span class="string">u'设置'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定元素的属性值中是否包含了预期的字符串，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.text_to_be_present_in_element_value((By.CSS_SELECTOR,<span class="string">'#su'</span>),<span class="string">u'百度一下'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False，注意这里并没有一个frame可以切换进去</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.frame_to_be_available_and_switch_to_it(locator))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素在是否存在于dom或不可见,如果可见返回False,不可见返回这个元素，注意#swfEveryCookieWrap在此页面中是一个隐藏的元素</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.invisibility_of_element_located((By.CSS_SELECTOR,<span class="string">'#swfEveryCookieWrap'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素中是否可见并且是enable的，代表可点击</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_clickable((By.XPATH,<span class="string">"//*[@id='u1']/a[8]"</span>))).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='wrapper']/div[6]/a[1]"</span>).click()</span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_clickable((By.XPATH,<span class="string">"//*[@id='wrapper']/div[6]/a[1]"</span>))).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待某个元素从dom树中移除，这里没有找到合适的例子</span></span><br><span class="line"><span class="comment">#WebDriverWait(driver,10).until(EC.staleness_of(driver.find_element(By.ID,'su')))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被选中了,一般用在下拉列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_selected(driver.find_element(By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素的选中状态是否符合预期</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_selection_state_to_be(driver.find_element(By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>),<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素的选中状态是否符合预期</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_located_selection_state_to_be((By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>),<span class="keyword">True</span>))</span><br><span class="line">driver.find_element_by_xpath(<span class="string">".//*[@id='gxszButton']/a[1]"</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断页面上是否存在alert,如果有就切换到alert并返回alert的内容</span></span><br><span class="line">instance = WebDriverWait(driver,<span class="number">10</span>).until(EC.alert_is_present())</span><br><span class="line"><span class="keyword">print</span> instance.text</span><br><span class="line">instance.accept()</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>关于显式等待和隐式等待具体的讲解可以参考<a href="https://www.jianshu.com/p/bf27aad96614" target="_blank" rel="noopener">这篇文章</a></strong></li><li><strong><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions" target="_blank" rel="noopener">更多操作</a></strong>参考</li></ul><hr><h3 id="浏览器的前进和后退"><a href="#浏览器的前进和后退" class="headerlink" title="浏览器的前进和后退"></a>浏览器的前进和后退</h3><ul><li><code>back()</code></li><li><code>forward()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.python.org/'</span>)</span><br><span class="line"></span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><hr><h3 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h3><ul><li><code>get_cookies()</code></li><li><code>delete_all_cookes()</code></li><li><code>add_cookie()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'zhaofan'</span>&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure><hr><h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><ul><li>通过执行js命令实现新开选项卡<code>window.open()</code></li><li>不同的选项卡是存在列表里<code>browser.window_handles</code></li><li>通过<code>browser.window_handles[0]</code>就可以操作第一个选项卡</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line"></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常比较复杂，<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions" target="_blank" rel="noopener">官网的参考地址</a>，这里只进行简单的演示，查找一个不存在的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    print(<span class="string">'Time Out'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Element'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong>无界面模式浏览器</strong>：</p><blockquote><p>opt=webdriver.ChromeOptions()<br># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数<br>opt.set_headless()#无界面<br>self.driver=webdriver.Chrome(options=opt)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span>  webdriver</span><br><span class="line"><span class="keyword">import</span>  lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span>  etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span>  pymysql</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span>  WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span>  expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span>  By</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LagouSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        opt=webdriver.ChromeOptions()</span><br><span class="line">        <span class="comment"># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数</span></span><br><span class="line">        opt.set_headless()<span class="comment">#无界面</span></span><br><span class="line">        self.driver=webdriver.Chrome(options=opt)</span><br><span class="line">        self.url=<span class="string">"https://www.lagou.com/zhaopin/Python/"</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.driver.get(self.url)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            source = self.driver.page_source</span><br><span class="line">            <span class="comment">#此句话大致意思，执行driver 时间不超过20s 什么时候加载到xpath定位的位置神魔时候停止开始执行页面 内容爬去</span></span><br><span class="line">            WebDriverWait(driver=self.driver,timeout=<span class="number">20</span>).until(EC.presence_of_all_elements_located(By.XPATH,<span class="string">'//*[@id="s_position_list"]/div[2]/div/a[6]'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># WebDriverWait(driver=self.driver, timeout=20).until(</span></span><br><span class="line">            <span class="comment">#     EC.presence_of_element_located((By.XPATH, '//*[@id="s_position_list"]/div[2]/div/a[6]'))</span></span><br><span class="line">            <span class="comment"># )</span></span><br><span class="line">            self.parse_list_page(source)</span><br><span class="line">            <span class="comment"># 点“下一页”</span></span><br><span class="line">            next_btn=self.driver.find_element_by_xpath(  <span class="string">'//*[@id="s_position_list"]/div[2]/div/a[6]'</span>)</span><br><span class="line">            <span class="comment"># 提取下一页的按钮，注意class的值中有空格不可用。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"pager_next_disabled"</span> <span class="keyword">in</span> next_btn.get_attribute(<span class="string">"class"</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_btn.click()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># next_btn = self.driver.find_element_by_xpath(</span></span><br><span class="line">            <span class="comment">#      '//*[@id="s_position_list"]/div[2]/div/a[6]')</span></span><br><span class="line">            <span class="comment"># if "pager_next_disabled" in next_btn.get_attribute("class"):</span></span><br><span class="line">            <span class="comment">#     break</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     next_btn.click()</span></span><br><span class="line">            <span class="comment"># time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># source=self.driver.page_source</span></span><br><span class="line">        <span class="comment"># #print(source)</span></span><br><span class="line">        <span class="comment"># self.parse_list_page(source)</span></span><br><span class="line">    <span class="comment">#职位url列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_list_page</span><span class="params">(self,source)</span>:</span></span><br><span class="line">        <span class="comment">#t通过etree调用xpath</span></span><br><span class="line">        html=etree.HTML(source)</span><br><span class="line">        links=html.xpath(<span class="string">'//*[@id="s_position_list"]/ul/li/div[1]/div[1]/div[1]/a/@href'</span>)</span><br><span class="line">        <span class="keyword">for</span>  link <span class="keyword">in</span> links:</span><br><span class="line">            self.request_detail_page(link)</span><br><span class="line">            <span class="comment"># print(link)</span></span><br><span class="line">            <span class="comment">#time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行提取的url</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_detail_page</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        <span class="comment">#self.driver.get(url)</span></span><br><span class="line">        <span class="comment">#打开新的页面</span></span><br><span class="line">        self.driver.execute_script(<span class="string">"window.open('%s')"</span>%url)</span><br><span class="line">        <span class="comment">#切换句柄进入新打开的页面</span></span><br><span class="line">        self.driver.switch_to.window((self.driver.window_handles[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># self.driver.execute_script("window.open('%s')" % url)</span></span><br><span class="line">        <span class="comment"># self.driver.switch_to.window(self.driver.window_handles[1])</span></span><br><span class="line">        <span class="comment">#加载出来工作名开始爬取</span></span><br><span class="line">        WebDriverWait(driver=self.driver, timeout=<span class="number">20</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">"//div[@class='job-name']/span[@class='name']"</span>)) )</span><br><span class="line"></span><br><span class="line">        source=self.driver.page_source</span><br><span class="line">        self.parse_detail_page(source)</span><br><span class="line">        <span class="comment"># 关闭当前详情页，并且切换到列表页</span></span><br><span class="line">        self.driver.close()</span><br><span class="line">        self.driver.switch_to.window(self.driver.window_handles[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#self.parse_list_page(source)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#提取具体信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_detail_page</span><span class="params">(self,source)</span>:</span></span><br><span class="line">        html=etree.HTML(source)</span><br><span class="line">        positionName=html.xpath(<span class="string">"//div[@class='position-head']/div/div[1]/div/span/text()"</span>)[<span class="number">0</span>]</span><br><span class="line">        job_request_spans=html.xpath(<span class="string">"//div[@class='position-head']/div/div[1]/dd/p[1]/span"</span>)</span><br><span class="line">        salary=job_request_spans[<span class="number">0</span>].xpath(<span class="string">".//text()"</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        city=job_request_spans[<span class="number">1</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="comment">#city = re.match(r'&lt;span class="xh-highlight"&gt;/(.*?) /&lt;/span&gt;',city)</span></span><br><span class="line">        city = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, city)<span class="comment">#此处将"/"替换为空""</span></span><br><span class="line">        work_years = job_request_spans[<span class="number">2</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        work_years = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, work_years)</span><br><span class="line">        education = job_request_spans[<span class="number">3</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        education = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, education)</span><br><span class="line">        content = <span class="string">""</span>.join(html.xpath(<span class="string">"//dd[@class='job_bt']//text()"</span>)).strip()</span><br><span class="line">        <span class="comment">#print(positionName)</span></span><br><span class="line">        <span class="comment">#mysql=MySQLPipeline()</span></span><br><span class="line">        <span class="comment">#mysql.process_item(positionName,salary,city,work_years,education,content)</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        语法：  'sep'.join(seq)</span></span><br><span class="line"><span class="string">        参数说明</span></span><br><span class="line"><span class="string">        sep：分隔符。可以为空</span></span><br><span class="line"><span class="string">        seq：要连接的元素序列、字符串、元组、字典</span></span><br><span class="line"><span class="string">        上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串</span></span><br><span class="line"><span class="string">        返回值：返回一个以分隔符sep连接各个元素后生成的字符串</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">"root"</span>,db=<span class="string">"lagou"</span>, charset=<span class="string">'utf8'</span>)</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self,positionName,salary,city,work_years,education,content)</span>:</span></span><br><span class="line">        insert_sql = <span class="string">'''</span></span><br><span class="line"><span class="string">                    insert into lagou_table(positionName,salary,city,work_years,education,content)</span></span><br><span class="line"><span class="string">                    values(%s,%s,%s,%s,%s,%s)</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">        self.cursor.execute(insert_sql,(positionName,salary,city,work_years,education,content))</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span> <span class="comment">#TypeError: close_spider() takes 1 positional argument but 2 were given</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    spider=LagouSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/zhaof/p/6953241.html" target="_blank" rel="noopener">本文框架来源</a></li><li><a href="https://www.cnblogs.com/yuuwee/p/6635652.html" target="_blank" rel="noopener">显示等待WebDriverWait与条件判断expected_conditions实例</a></li><li><a href="https://blog.csdn.net/work_you_will_see/article/details/84638750" target="_blank" rel="noopener">实战项目来源</a></li><li><a href="https://www.jianshu.com/p/bf27aad96614" target="_blank" rel="noopener">Selenium中的“显示等待”和“隐式等待”</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章将自己在使用Selenium过程中遇到的好文章进行了汇总和整理，便于后续继续使用这个工具时能尽快找到好的参考，节省时间！&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之logging-日志</title>
    <link href="http://showteeth.tech/posts/56982.html"/>
    <id>http://showteeth.tech/posts/56982.html</id>
    <published>2019-03-22T12:31:42.000Z</published>
    <updated>2019-03-23T13:06:37.634Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章依照<a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">这篇博客</a>对Python的常用模块logging进行了学习，主要学习了<code>日志的作用</code>、<code>不同开发环境设置不同的日志输出</code>、<code>使用logging模块的日志级别函数直接记录日志</code>；也学习了logging模块的<strong>高级用法</strong>，包括<strong>使用logging模块的四大组件进行日志记录(主要用于满足多种需求，如将结果同时输出到文件和屏幕)</strong>、配置logging的几种方式、向日志输出上下文信息等；最后也总结了一些<strong>实战技巧</strong>。</p></div><a id="more"></a><h2 id="日志相关概念"><a href="#日志相关概念" class="headerlink" title="日志相关概念"></a>日志相关概念</h2><p>日志是一种可以<strong>追踪某些软件运行时所发生事件的方法</strong>。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有<strong>重要性</strong>的概念，这个重要性也可以被称为严重性级别（level）。</p><h3 id="日志的作用"><a href="#日志的作用" class="headerlink" title="日志的作用"></a>日志的作用</h3><p>通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。<br><strong>简单来讲就是</strong>，我们通过记录和分析日志可以了解一个系统或软件程序<strong>运行情况是否正常</strong>，也可以<strong>在应用程序出现故障时快速定位问题</strong>。比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。日志的作用可以<strong>简单总结</strong>为以下3点：</p><ul><li><strong>程序调试</strong></li><li><strong>了解软件程序运行情况，是否正常</strong></li><li><strong>软件程序运行故障分析与问题定位</strong></li></ul><p>如果应用的日志信息足够详细和丰富，还可以<strong>用来做用户行为分析</strong>，如：分析用户的操作行为、类型喜好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。</p><hr><h3 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h3><p>我们先来思考下下面的两个问题：</p><ul><li>作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？</li><li>作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？</li></ul><p>在<strong>软件开发阶段或部署开发环境</strong>时，为了<strong>尽可能详细</strong>的查看应用程序的运行状态来<strong>保证上线后的稳定性</strong>，我们可能<strong>需要把该应用程序所有的运行日志全部记录下来进行分析</strong>，<u>这是非常耗费机器性能的</u>。当<strong>应用程序正式发布或在生产环境部署应用程序</strong>时，我们通常<strong>只需要记录应用程序的异常信息、错误信息</strong>等，这样既可以减小服务器的<code>I/O</code>压力，也可以避免我们在排查故障时被淹没在日志的海洋里。那么，<mark><strong>怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？</strong>这就是<strong>日志等级</strong>的作用了，我们<strong>通过配置文件指定我们需要的日志等级就可以了</strong></mark>。</p><p>不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级(具体的级别高低在后面会有讲解)：</p><ul><li>DEBUG</li><li>INFO</li><li>NOTICE</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>ALERT</li><li>EMERGENCY</li></ul><hr><h3 id="日志字段信息与日志格式"><a href="#日志字段信息与日志格式" class="headerlink" title="日志字段信息与日志格式"></a>日志字段信息与日志格式</h3><p>本节开始问题提到过，<strong>一条日志信息对应的是一个事件的发生</strong>，而<strong>一个事件通常需要包括以下几个内容</strong>：</p><ul><li>事件发生<strong>时间</strong></li><li>事件发生<strong>位置</strong></li><li>事件的<strong>严重程度–日志级别</strong></li><li>事件<strong>内容</strong></li></ul><p>上面这些都是一条日志记录中可能包含的字段信息，当然<strong>还可以包括</strong>一些其他信息，如<code>进程ID</code>、<code>进程名称</code>、<code>线程ID</code>、<code>线程名称</code>等。<strong>日志格式</strong>就是用来定义一条日志记录中包含哪些字段的，且日志格式通常都是可以自定义的。</p><div class="note info"><p>输出一条日志时，<strong>日志内容</strong>和<strong>日志级别</strong>是<strong>需要开发人员明确指定的(必须的)</strong>。对于而其它字段信息，只需要是否显示在日志中就可以了。</p></div><h3 id="日志功能的实现"><a href="#日志功能的实现" class="headerlink" title="日志功能的实现"></a>日志功能的实现</h3><p>几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：<code>log4j</code>，<code>log4php</code>等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块–<code>logging</code>。</p><hr><p><br></p><h2 id="logging模块简介"><a href="#logging模块简介" class="headerlink" title="logging模块简介"></a>logging模块简介</h2><p><code>logging</code>模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。<code>logging</code>模块是Python的一个<strong>标准库模块</strong>，<strong>由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能</strong>。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><h3 id="logging模块的日志级别"><a href="#logging模块的日志级别" class="headerlink" title="logging模块的日志级别"></a>logging模块的日志级别</h3><p>logging模块默认定义了以下几个日志等级，它<strong>允许开发人员自定义其他日志级别</strong>，但是这是<strong>不被推荐的</strong>，尤其是在开发供别人使用的库时，因为这<strong>会导致日志级别的混乱</strong>。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>日志等级</th><th>数值</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>10</td><td><strong>最详细</strong>的日志信息，典型应用场景是<strong>问题诊断</strong></td></tr><tr><td>INFO</td><td>20</td><td>信息详细程度仅次于DEBUG，通常<strong>只记录关键节点信息</strong>，用于<strong>确认一切都是按照我们预期的那样进行工作</strong></td></tr><tr><td>WARNING</td><td>30</td><td>当<strong>某些不期望的事情发生</strong>时记录的信息（如，磁盘可用空间较低），但是<strong>此时应用程序还是正常运行</strong>的</td></tr><tr><td>ERROR</td><td>40</td><td>由于一个更严重的问题<strong>导致某些功能不能正常运行</strong>时记录的信息</td></tr><tr><td>CRITICAL</td><td>50</td><td>当发生严重错误，<strong>导致应用程序不能继续运行</strong>时记录的信息</td></tr></tbody></table><div class="note info"><ul><li>上面列表中的<strong>日志等级是从上到下依次升高(按照数值的大小排序)</strong>的，即：<code>DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</code>，而<strong>日志的信息量是依次减少的</strong>；</li><li><p><code>logging</code>模块<strong>可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃</strong>；</p></li><li><p><strong>开发应用程序或部署开发环境</strong>时，可以使用<code>DEBUG</code>或<code>INFO</code>级别的日志获取<strong>尽可能详细</strong>的日志信息来进行开发或部署调试；</p></li><li><strong>应用上线或部署生产环境</strong>时，应该使用<code>WARNING</code>或<code>ERROR</code>或<code>CRITICAL</code>级别的日志来降低机器的<code>I/O</code>压力和提高获取错误日志信息的效率；</li><li><strong>日志级别的指定通常都是在应用程序的配置文件中进行的</strong>。</li></ul></div><hr><h3 id="logging模块的使用方式介绍"><a href="#logging模块的使用方式介绍" class="headerlink" title="logging模块的使用方式介绍"></a>logging模块的使用方式介绍</h3><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是<strong>使用logging提供的日志级别的函数</strong></li><li>第二种方式是<strong>使用Logging日志系统的四大组件</strong></li></ul><p>其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已</p><h4 id="logging模块定义的日志级别的常用函数"><a href="#logging模块定义的日志级别的常用函数" class="headerlink" title="logging模块定义的日志级别的常用函数:"></a>logging模块定义的日志级别的常用函数:</h4><table><tr><th width="40%">函数</th><th width="60%">说明</th></tr><tr><td><code>logging.debug(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>DEBUG</code>的日志记录</td></tr><tr><td><code>logging.info(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>INFO</code>的日志记录</td></tr><tr><td><code>logging.warning(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>WARNING</code>的日志记录</td></tr><tr><td><code>logging.error(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>ERROR</code>的日志记录</td></tr><tr><td><code>logging.critical(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>CRITICAL</code>的日志记录</td></tr><tr><td><code>logging.log(level, *args, **kwargs)</code></td><td>创建一条级别为<code>level</code>的日志记录</td></tr><tr><td><code>logging.basicConfig(**kwargs)</code></td><td>对<code>root logger</code>进行一次性配置</td></tr></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定<code>要记录的日志级别</code>、<code>日志格式</code>、<code>日志输出位置</code>、<code>日志文件的打开模式</code>等信息，<strong>其他几个都是用于记录各个级别日志的函数</strong>。</p><hr><h4 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h4><table><tr><th width="20%">组件</th><th width="80%">说明</th></tr><tr><td><code>loggers</code></td><td>提供应用程序代码直接使用的接口</td></tr><tr><td><code>handlers</code></td><td>用于将日志记录发送到指定的目的位置</td></tr><tr><td><code>filters</code></td><td>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）</td></tr><tr><td><code>formatters</code></td><td>用于控制日志信息的最终输出格式</td></tr></table><div class="note info"><p>logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。</p></div><hr><p><br></p><h2 id="使用日志级别函数记录日志"><a href="#使用日志级别函数记录日志" class="headerlink" title="使用日志级别函数记录日志"></a>使用日志级别函数记录日志</h2><p>回顾下前面提到的<strong>几个重要信息</strong>：</p><ul><li>可以通过logging模块定义的日志级别方法去完成简单的日志记录</li><li><strong>只有级别大于或等于日志记录器指定级别的日志记录才会被输出，小于该级别的日志记录将会被丢弃</strong></li></ul><h3 id="最简单的日志输出"><a href="#最简单的日志输出" class="headerlink" title="最简单的日志输出"></a>最简单的日志输出</h3><p><strong>使用各种具体级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>也可以使用统一设置级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.log(logging.DEBUG, <span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.log(logging.INFO, <span class="string">"This is a info log."</span>)</span><br><span class="line">logging.log(logging.WARNING, <span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.log(logging.ERROR, <span class="string">"This is a error log."</span>)</span><br><span class="line">logging.log(logging.CRITICAL, <span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br><span class="line">================================</span><br><span class="line">WARNING:root:This <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:This <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:This <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><p>第二种写法显然没有第一种写法简单，以后还是使用第一种写法吧</p><h3 id="简单日志输出的结果分析"><a href="#简单日志输出的结果分析" class="headerlink" title="简单日志输出的结果分析"></a>简单日志输出的结果分析</h3><h4 id="为什么前面两条日志没有被打印出来？"><a href="#为什么前面两条日志没有被打印出来？" class="headerlink" title="为什么前面两条日志没有被打印出来？"></a>为什么前面两条日志没有被打印出来？</h4><p>这是因为logging模块提供的日志记录函数所使用的日志器设置的日志级别是<code>WARNING</code>(<strong>logging的默认日志级别是warning</strong>)，因此只有<code>WARNING</code>级别的日志记录以及<strong>大于等于</strong>它的<code>ERROR</code>和<code>CRITICAL</code>级别的日志记录<strong>被输出</strong>了，而<strong>小于</strong>它的<code>DEBUG</code>和<code>INFO</code>级别的日志记录<strong>被丢弃</strong>了。</p><hr><h4 id="日志信息中各字段含义？为什么会这样输出？"><a href="#日志信息中各字段含义？为什么会这样输出？" class="headerlink" title="日志信息中各字段含义？为什么会这样输出？"></a>日志信息中各字段含义？为什么会这样输出？</h4><p>上面输出结果中每行日志记录的各个字段含义分别是：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志级别:日志器名称:日志内容</span><br></pre></td></tr></table></figure><p></p><p>之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器<strong>设置的日志格式默认是<code>BASIC_FORMAT</code></strong>，其值为：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="如果将日志记录输出到文件中，而不是打印到控制台？"><a href="#如果将日志记录输出到文件中，而不是打印到控制台？" class="headerlink" title="如果将日志记录输出到文件中，而不是打印到控制台？"></a>如果将日志记录输出到文件中，而不是打印到控制台？</h4><p>因为在logging模块提供的日志记录函数所使用的日志器设置的处理器所<strong>指定的日志输出位置默认为:<code>sys.stderr</code>.</strong></p><hr><h4 id="我是怎么知道这些的？"><a href="#我是怎么知道这些的？" class="headerlink" title="我是怎么知道这些的？"></a>我是怎么知道这些的？</h4><p><strong>查看这些日志记录函数的实现代码</strong>，可以发现：当我们<strong>没有提供任何配置信息的时候</strong>，这些函数都会去调用<code>logging.basicConfig(**kwargs)</code>方法，且不会向该方法传递任何参数。继续<strong>查看<code>basicConfig()</code>方法的代码</strong>就可以找到上面这些问题的答案了。</p><p><strong>查看源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先导入模块</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">help(logging.basicConfig)</span><br><span class="line"></span><br><span class="line">The default behaviour <span class="keyword">is</span> to create a StreamHandler which writes to sys.stderr, set a formatter using the BASIC_FORMAT format string, <span class="keyword">and</span> add the handler to the root logger.</span><br><span class="line"></span><br><span class="line">BASIC_FORMAT = <span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="怎么修改这些默认设置呢？"><a href="#怎么修改这些默认设置呢？" class="headerlink" title="怎么修改这些默认设置呢？"></a>怎么修改这些默认设置呢？</h4><p>其实很简单，在我们<strong>调用上面这些日志记录函数之前</strong>，<strong>手动调用一下<code>basicConfig()</code>方法</strong>，把我们<strong>想设置的内容以参数的形式传递进去就可以了</strong>。</p><hr><h3 id="logging-basicConfig-函数说明"><a href="#logging-basicConfig-函数说明" class="headerlink" title="logging.basicConfig()函数说明"></a>logging.basicConfig()函数说明</h3><p>经过上述对简单日志输出的结果分析，发现如果我们想修改输出的信息(默认设置)就需要在调用日志记录函数之前，手动调用一下<code>basicConfig()</code>方法，所以这里来对<code>logging.basicConfig()</code>函数进行一定的学习。该方法用于为logging日志系统做一些基本配置，方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure><p></p><p><strong>该函数可接收的关键字参数</strong>如下：</p><table><tr><th width="20%">参数名称</th><th width="80%">描述</th></tr><tr><td><code>filename</code></td><td><strong>指定日志输出目标文件的文件名</strong>，指定该设置项后日志信息就不会被输出到控制台了</td></tr><tr><td><code>filemode</code></td><td>指定日志文件的打开模式，默认为<code>a</code>。需要注意的是，<strong>该选项要在filename指定时才有效</strong></td></tr><tr><td><code>format</code></td><td>指定日志格式字符串，即<strong>指定日志输出时所包含的字段信息以及它们的顺序</strong>。logging模块定义的格式字段下面会列出。</td></tr><tr><td><code>datefmt</code></td><td>指定日期/时间格式。需要注意的是，该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></td></tr><tr><td><code>level</code></td><td><strong>指定日志器的日志级别</strong></td></tr><tr><td><code>stream</code></td><td>指定日志输出目标stream，如<code>sys.stdout</code>、<code>sys.stderr</code>以及网络stream。需要说明的是，<strong>stream和filename不能同时提供，否则会引发 ValueError异常</strong></td></tr><tr><td><code>style</code></td><td>Python 3.2中新添加的配置项。<strong>指定format格式字符串的风格<strong>，可取值为<code>%</code>、<code>{</code>和<code>$</code>，默认为<code>%</code></strong></strong></td></tr><tr><td><code>handlers</code></td><td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：<strong>filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常</strong>。</td></tr></table><hr><h3 id="格式字符串字段-format"><a href="#格式字符串字段-format" class="headerlink" title="格式字符串字段(format)"></a>格式字符串字段(format)</h3><p>这里列出了<code>logging.basicConfig()</code>函数中的日志格式字符串(format)包含的字段：</p><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的<strong>时间</strong>–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–<strong>时间戳</strong>，就是当时调用<code>time.time()</code>函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的<strong>相对毫秒数</strong>（目前还不知道干嘛用的）</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的<strong>毫秒部分</strong></td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的<strong>文字形式的日志级别(‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’)</strong></td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的<strong>数字形式的日志级别(10, 20, 30, 40, 50)</strong></td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的<strong>日志器名称</strong>，<strong>默认是’root’，因为默认使用的是 rootLogger</strong></td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 <code>msg % args</code>计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td><strong>调用日志记录函数的源码文件的全路径</strong></td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的<strong>文件名部分，包含文件后缀</strong></td></tr><tr><td>module</td><td>%(module)s</td><td>filename的<strong>名称部分，不包含后缀</strong></td></tr><tr><td>lineno</td><td>%(lineno)d</td><td><strong>调用日志记录函数的源代码所在的行号</strong></td></tr><tr><td>funcName</td><td>%(funcName)s</td><td><strong>调用日志记录函数的函数名</strong></td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><div class="note info"><p>定义format的形式：<code>BASIC_FORMAT = &quot;%(levelname)s:%(name)s:%(message)s&quot;</code>这是官方的默认形式，不同字段间使用<code>:</code>分割，分割符可以自定义</p></div><hr><h3 id="自定义输出日志信息"><a href="#自定义输出日志信息" class="headerlink" title="自定义输出日志信息"></a>自定义输出日志信息</h3><h4 id="level-自定义日志级别"><a href="#level-自定义日志级别" class="headerlink" title="level-自定义日志级别"></a>level-自定义日志级别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"=====change level====="</span>)</span><br><span class="line"><span class="comment">## 自定义日志器的日志级别</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p>输出信息：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====change level=====</span><br><span class="line">DEBUG:root:this <span class="keyword">is</span> a debug log.</span><br><span class="line">INFO:root:this <span class="keyword">is</span> a info log.</span><br><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="filename-amp-format-设置日志输出目标文件和日志格式"><a href="#filename-amp-format-设置日志输出目标文件和日志格式" class="headerlink" title="filename &amp; format-设置日志输出目标文件和日志格式"></a>filename &amp; format-设置日志输出目标文件和日志格式</h4><ul><li><code>filename</code>：指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了</li><li><code>format</code>：指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。<ul><li><code>%(asctime)s</code>：日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</li><li><code>%(levelname)s</code>：该日志记录的文字形式的日志级别<code>(&#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;)</code></li><li><code>%(message)s</code>：日志记录的文本内容，通过 <code>msg % args</code>计算得到的</li></ul></li></ul><p><strong>示例代码如下</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"=====change out file and format====="</span>)</span><br><span class="line"><span class="comment"># 设置输出的format，中间的字段分隔符可以自定义</span></span><br><span class="line">LOG_FORMAT=<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line"><span class="comment"># 设置日志输出文件名以及format</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>,level=logging.DEBUG,format=LOG_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="datefmt-设置日期-时间格式"><a href="#datefmt-设置日期-时间格式" class="headerlink" title="datefmt-设置日期/时间格式"></a>datefmt-设置日期/时间格式</h4><ul><li>时间格式同<code>time.strftime()</code>，具体信息可以本文最后的补充信息</li><li>该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>从上面输出结果可以发现，前面几行是上一步生成的日志文件，下面几行是这步生成的文件，这是因为<strong>默认的<code>filemode</code>是<code>a</code>也就是追加的意思，所以没有清空原始文件的信息</strong>。</p><hr><h4 id="filemode-指定日志文件的打开模式"><a href="#filemode-指定日志文件的打开模式" class="headerlink" title="filemode-指定日志文件的打开模式"></a>filemode-指定日志文件的打开模式</h4><ul><li>该选项默认为<code>a</code></li><li>需要注意的是，<strong>该选项要在filename指定时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件打开模式更改为w，如果存在就清空然后写入，如果不存在就创建</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT,filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  03/23/2019 00:23:36 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>可以发现前一步的输出结果已经被覆盖掉了，只生成了这一步的输出结果。</p><hr><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><h4 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h4><ul><li><code>logging.basicConfig()</code>函数是一个<strong>一次性的简单配置工具</strong>，也就是说<strong>只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作</strong></li><li><strong>日志器（Logger）是有层级关系的</strong>，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为<code>root</code>，它是<strong>处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的</strong></li><li>如果要记录的<strong>日志中包含变量数据</strong>，<strong>可使用一个格式字符串</strong>作为这个事件的描述消息(<code>logging.debug</code>、<code>logging.info</code>等函数的第一个参数)，然后将变量数据作为第二个参数<code>*args</code>的值进行传递，如:<code>logging.warning(&#39;%s is %d years old.&#39;, &#39;Tom&#39;, 10)</code>，输出内容为<code>WARNING:root:Tom is 10 years old.</code>.</li></ul><hr><h4 id="日志级别方法参数的补充说明"><a href="#日志级别方法参数的补充说明" class="headerlink" title="日志级别方法参数的补充说明"></a>日志级别方法参数的补充说明</h4><ul><li><code>logging.debug()</code>, <code>logging.info()</code>等方法的定义中，除了<code>msg</code>和<code>args</code>参数外，还有一个<code>**kwargs</code>参数。它们<strong>支持3个关键字参数</strong>: <code>exc_info</code>、<code>stack_info</code>、<code>extra</code>，下面对这几个关键字参数作个说明:</li><li><code>exc_info</code>：其值为<strong>布尔值</strong>，如果该参数的值设置为<strong>True</strong>，则会<strong>将异常信息添加到日志消息中</strong>；如果<strong>没有异常信息则添加None到日志信息</strong>中</li><li><code>stack_info</code>：其值也为<strong>布尔值</strong>，<strong>默认值为False</strong>。如果该参数的值设置为<strong>True</strong>，<strong>栈信息将会被添加到日志信息中，相当于是哪一行输入了这个log信息</strong></li><li><code>extra</code>：这是一个<strong>字典（dict）参数</strong>，它可以用来<strong>自定义消息格式中所包含的字段</strong>，但是<strong>它的<code>key</code>不能与logging模块定义的字段冲突</strong></li></ul><p><strong>示例</strong>：<br>在日志消息中添加<code>exc_info</code>和<code>stack_info</code>信息，并添加<strong>两个自定义的字端</strong><code>ip</code>和<code>user</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(user)s[%(ip)s] - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置exc_info、stack_info、extra参数</span></span><br><span class="line">logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=<span class="keyword">True</span>, stack_info=<span class="keyword">True</span>, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03/23/2019 09:28:06 AM - WARNING - Tom[47.98.53.222] - Some one delete the <span class="built_in">log</span> file.</span><br><span class="line">NoneType: None</span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">"logging_learn.py"</span>, line 75, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=True, stack_info=True, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="日志模块四大组件以及日志流处理流程"><a href="#日志模块四大组件以及日志流处理流程" class="headerlink" title="日志模块四大组件以及日志流处理流程"></a>日志模块四大组件以及日志流处理流程</h2><p>在介绍logging模块的<strong>高级用法</strong>之前，很有必要对logging模块所包含的<strong>重要组件以及其工作流程做个全面、简要的介绍</strong>，这有助于我们更好的理解我们所写的代码（将会触发什么样的操作）。</p><h3 id="日志模块四大组件"><a href="#日志模块四大组件" class="headerlink" title="日志模块四大组件"></a>日志模块四大组件</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块日志级别的函数也是通过这些组件对应的类来实现的。</p><hr><h3 id="四大组件之间的关系"><a href="#四大组件之间的关系" class="headerlink" title="四大组件之间的关系"></a>四大组件之间的关系</h3><ul><li><strong>日志器(logger)需要通过处理器(handler)将日志信息输出到目标位置</strong>，如：文件、<code>sys.stdout</code>、网络等；</li><li>不同的<strong>处理器(handler)可以将日志输出到不同的位置</strong>；</li><li>日志器(logger)可以设置<strong>多个</strong>处理器(handler)将<strong>同一条</strong>日志记录输出到<strong>不同的位置</strong>；</li><li>每个<strong>处理器(handler)</strong>都可以<strong>设置自己的过滤器(filter)实现日志过滤</strong>，从而只保留感兴趣的日志；</li><li>每个<strong>处理器(handler)</strong>都可以设<strong>置自己的格式器(formatter)</strong>实现同一条日志<strong>以不同的格式输出到不同的地方</strong>。</li></ul><p>简单点说就是：<mark>日志器(logger)是入口，真正干活儿的是处理器(handler)，处理器(handler)还可以通过过滤器(filter)和格式器(formatter)对要输出的日志内容做过滤和格式化等处理操作。</mark></p><hr><h3 id="组件相关类与常用方法介绍"><a href="#组件相关类与常用方法介绍" class="headerlink" title="组件相关类与常用方法介绍"></a>组件相关类与常用方法介绍</h3><h4 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h4><p><strong>Logger对象有3个任务要做</strong>：</p><ul><li>向<strong>应用程序代码暴露几个方法</strong>，使应用程序<strong>可以在运行时记录日志消息</strong>；</li><li>基于日志严重等级(默认的过滤设施)或filter对象来<strong>决定要对哪些日志进行后续处理</strong>；</li><li>将日志消息<strong>传送给</strong>所有感兴趣的日志<strong>handlers</strong>。</li></ul><p><strong>Logger对象最常用的方法分为两类</strong>：</p><ul><li><code>配置方法</code></li><li><code>消息发送方法(创建日志)</code></li></ul><h5 id="最常用的配置方法"><a href="#最常用的配置方法" class="headerlink" title="最常用的配置方法"></a>最常用的配置方法</h5><table><tr><th>方法</th><th>描述</th></tr><tr><td><code>Logger.setLevel()</code></td><td><strong>设置<strong>日志器将会处理的日志消息的<strong>最低严重级别</strong></strong></strong></td></tr><tr><td><code>Logger.addHandler()</code>和<code>Logger.removeHandler()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>handler对象</strong></td></tr><tr><td><code>Logger.addFilter()</code>和<code>Logger.removeFilter()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>filter对象</strong></td></tr></table><div class="note info"><p>关于<code>Logger.setLevel()</code>方法的说明：内建等级中，级别最低的是<code>DEBUG</code>，级别最高的是<code>CRITICAL</code>。例如<code>setLevel(logging.INFO)</code>，此时函数参数为INFO，那么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。</p></div><hr><h5 id="创建日志记录方法"><a href="#创建日志记录方法" class="headerlink" title="创建日志记录方法"></a>创建日志记录方法</h5><p>logger对象配置完成后，可以<strong>使用下面的方法来创建日志记录</strong>：</p><table><tr><th width="50%">方法</th><th width="50%">描述</th></tr><tr><td><code>Logger.debug()</code>, <code>Logger.info()</code>, <code>Logger.warning()</code>, <code>Logger.error()</code>, <code>Logger.critical()</code></td><td>创建一个与它们的方法名对应等级的日志记录</td></tr><tr><td><code>Logger.exception()</code></td><td>创建一个类似于<code>Logger.error()</code>的日志消息</td></tr><tr><td><code>Logger.log()</code></td><td>需要获取一个明确的日志level参数来创建一个日志记录</td></tr></table><div class="note info"><ul><li><code>Logger.exception()</code>与<code>Logger.error()</code>的区别在于：<code>Logger.exception()</code>将会输出堆栈追踪信息，另外<strong>通常只是在一个exception handler中调用该方法</strong></li><li><code>Logger.log()</code>与<code>Logger.debug()</code>、<code>Logger.info()</code>等方法相比，虽然<strong>需要多传一个level参数，显得不是那么方便，但是当需要记录自定义level的日志时还是需要该方法来完成</strong></li></ul></div><h5 id="得到一个Logger对象"><a href="#得到一个Logger对象" class="headerlink" title="得到一个Logger对象"></a>得到一个Logger对象</h5><p>得到Logger对象方法有两种：</p><ul><li>第一种方式是通过<strong>Logger类的实例化方法</strong>创建一个Logger类的实例</li><li>第二种方式是<code>logging.getLogger()</code>方法，这是通常使用的方法</li></ul><p><code>logging.getLogger()</code>方法有一个<strong>可选参数</strong><code>name</code>，该参数表示将<strong>要返回的日志器的名称标识，如果不提供该参数，则其值为’root’</strong>。若以相同的<code>name</code>参数值多次调用<code>getLogger()</code>方法，将会返回指向同一个logger对象的引用。</p><div class="note info"><p>关于logger的<strong>层级结构</strong>与<strong>有效等级</strong>的说明：</p><ul><li><p>logger的名称是一个以<code>.</code>分割的层级结构，每个<code>.</code>后面的logger都是<code>.</code>前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代</p></li><li><p>logger有一个<strong>有效等级(effective level)</strong>的概念。</p><ul><li>如果一个logger上<strong>没有被明确设置一个level</strong>，那么该logger就是<strong>使用它parent的level</strong>；</li><li>如果它的<strong>parent也没有明确设置level</strong>则继续向上<strong>查找parent的parent的有效level，依次类推</strong>，直到找到个一个明确设置了level的祖先为止。</li><li>需要说明的是，<strong>root logger总是会有一个明确的level设置(默认为 WARNING)</strong>。</li><li>当<strong>决定是否去处理一个已发生的事件时</strong>，<strong>logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理</strong>。</li></ul></li><li><p><code>child loggers</code>在完成对日志消息的处理后，<strong>默认会将日志消息传递给与它们的祖先loggers相关的handlers</strong>。因此，我们<strong>不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了</strong>。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</p></li></ul></div><hr><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的<strong>作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）</strong>。Logger对象可以通过<code>addHandler()</code>方法<strong>为自己添加0个或者更多个handler对象</strong>。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>把所有日志都发送到一个日志文件中；</li><li>把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>把所有严重级别为critical的日志发送到一个email邮件地址。</li></ul><p>这种场景就需要<strong>3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置</strong>。</p><p>一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似乎唯一相关的handler方法就是下面这几个<strong>配置方法</strong>：</p><table><tr><th width="40%">方法</th><th width="60%">描述</th></tr><tr><td><code>Handler.setLevel()</code></td><td>设置handler将会处理的日志消息的最低严重级别</td></tr><tr><td><code>Handler.setFormatter()</code></td><td>为handler设置一个格式器对象</td></tr><tr><td><code>Handler.addFilter()</code>和<code>Handler.removeFilter()</code></td><td>为handler添加和删除一个过滤器对象</td></tr></table><p>需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了所有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些<strong>常用的Handler</strong>：</p><table><tr><th width="40%">Handler</th><th width="60%">描述</th></tr><tr><td><code>logging.StreamHandler</code></td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td><code>logging.FileHandler</code></td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td><code>logging.handlers.RotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td><code>logging.hanlders.TimedRotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td><code>logging.handlers.HTTPHandler</code></td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td><code>logging.handlers.SMTPHandler</code></td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td><code>logging.NullHandler</code></td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免'No handlers could be found for logger XXX'信息的出现。</td></tr></table><hr><h4 id="Formater类"><a href="#Formater类" class="headerlink" title="Formater类"></a>Formater类</h4><p>Formater对象用于<strong>配置日志信息的最终顺序、结构和内容</strong>。与logging.Handler基类不同的是，<strong>应用代码可以直接实例化Formatter类</strong>。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=<span class="keyword">None</span>, datefmt=<span class="keyword">None</span>, style=<span class="string">'%'</span>)</span><br></pre></td></tr></table></figure><p></p><p>可见，该构造方法接收3个可选参数：</p><ul><li><code>fmt</code>：指定消息格式化字符串，如果不指定该参数则<strong>默认使用message的原始值</strong></li><li><code>datefmt</code>：指定日期格式字符串，如果不指定该参数则默认使用<code>%Y-%m-%d %H:%M:%S</code></li><li><code>style</code>：Python 3.2新增的参数，可取值为<code>%</code>、<code>{</code>和<code>$</code>，如果不指定该参数则默认使用<code>%</code></li></ul><hr><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>.<span class="title">Filter</span><span class="params">(name=<span class="string">''</span>)</span></span></span><br><span class="line"><span class="class">    <span class="title">filter</span><span class="params">(record)</span></span></span><br></pre></td></tr></table></figure><p></p><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><div class="note info"><ul><li>如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性</li><li>我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等</li></ul></div><hr><h3 id="logging日志流处理流程"><a href="#logging日志流处理流程" class="headerlink" title="logging日志流处理流程"></a>logging日志流处理流程</h3><p>下面这个图描述了日志流的处理流程：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/logging处理流程.png" alt="logging处理流程.png"></p><p>我们来描述下上面这个图的日志流处理流程：</p><ul><li>（在用户代码中进行）<strong>日志记录函数调用</strong>，如：logger.info(…)，logger.debug(…)等；</li><li>判断要记录的日志级别<strong>是否满足日志器设置的级别要求</strong>（要记录的日志级别要大于或等于日志器设置的级别才算满足要求），如果不满足则该日志记录会被丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>根据日志记录函数调用时掺入的参数，<strong>创建</strong>一个<strong>日志记录（LogRecord类）对象</strong>；</li><li>判断日志记录器上设置的<strong>过滤器是否拒绝这条日志记录</strong>，如果日志记录器上的某个过滤器拒绝，则该日志记录会被丢弃并终止后续的操作，如果日志记录器上设置的过滤器不拒绝这条日志记录或者日志记录器上没有设置过滤器则继续下一步操作–<strong>将日志记录</strong>分别交给该日志器上添加的各个<strong>处理器</strong>；</li><li>判断要记录的日志级别<strong>是否满足处理器设置的级别要求</strong>（要记录的日志级别要大于或等于该处理器设置的日志级别才算满足要求），如果不满足记录将会被该处理器丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>判断该<strong>处理器上设置的过滤器</strong>是否拒绝这条日志记录，如果该处理器上的某个过滤器拒绝，则该日志记录会被当前处理器丢弃并终止后续的操作，如果当前处理器上设置的过滤器不拒绝这条日志记录或当前处理器上没有设置过滤器测继续下一步操作；</li><li>如果能到这一步，说明这条日志记录经过了层层关卡允许被输出了，此时当前<strong>处理器会根据自身被设置的格式器</strong>（如果没有设置则使用默认格式）将这条日志记录进行格式化，最后将格式化后的结果输出到指定位置（文件、网络、类文件的Stream等）；</li><li>如果日志器被设置了<strong>多个处理器</strong>的话，上面的第5-8步会执行多次；</li><li>这里才是完整流程的最后一步：<strong>判断该日志器输出的日志消息是否需要传递给上一级logger（之前提到过，日志器是有层级关系的）的处理器</strong>，如果propagate属性值为1则表示日志消息将会被输出到处理器指定的位置，同时还会被传递给parent日志器的handlers进行处理直到当前日志器的propagate属性为0停止，如果propagate值为0则表示不向parent日志器的handlers传递该消息，到此结束。</li></ul><p>可见，<strong>一条日志信息要想被最终输出需要依次经过以下几次过滤</strong>：</p><ul><li><strong>日志器等级过滤</strong></li><li>日志器的过滤器过滤</li><li><strong>日志器的处理器等级过滤</strong></li><li>日志器的处理器的过滤器过滤</li></ul><div class="note info"><p><strong>需要说明的是</strong>： 关于上面第9个步骤，如果propagate值为1，那么日志消息会直接传递交给上一级logger的handlers进行处理，此时上一级logger的日志等级并不会对该日志消息进行等级过滤。</p></div><hr><p><br></p><h2 id="使用四大组件记录日志"><a href="#使用四大组件记录日志" class="headerlink" title="使用四大组件记录日志"></a>使用四大组件记录日志</h2><p>现在，我们对logging模块的重要组件及整个日志流处理流程都应该有了一个比较全面的了解，下面我们来看一个例子。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>现在有以下几个日志记录的需求：</p><ul><li>要求将<strong>所有级别的所有日志都写入磁盘文件</strong>中</li><li><strong>all.log文件中记录所有的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 日志信息</li><li><strong>error.log文件中单独记录error及以上级别的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 文件名[:行号] - 日志信息</li><li>要求all.log在<strong>每天凌晨</strong>进行<strong>日志切割</strong></li></ul><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>要记录所有级别的日志，因此日志器的有效level需要设置为最低级别–DEBUG;</li><li><strong>日志需要被发送到两个不同的目的地</strong>，因此需要<strong>为日志器设置两个handler</strong>；另外，两个<strong>目的地都是磁盘文件</strong>，因此<strong>这两个handler都是与FileHandler相关的</strong>；</li><li>all.log要求<strong>按照时间进行日志切割</strong>，因此他需要用<code>logging.handlers.TimedRotatingFileHandler</code>; 而error.log没有要求日志切割，因此可以使用<code>FileHandler</code>;</li><li><strong>两个日志文件的格式不同</strong>，因此需要<strong>对这两个handler分别设置格式器</strong>.</li></ul><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'mylogger'</span>)</span><br><span class="line"><span class="comment"># 设置日志器的日志级别</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第一个handler，实现日志切割</span></span><br><span class="line">rf_handler = logging.handlers.TimedRotatingFileHandler(<span class="string">'all.log'</span>, when=<span class="string">'midnight'</span>, interval=<span class="number">1</span>, backupCount=<span class="number">7</span>, atTime=datetime.time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置第一个handler的格式器，使用了formatter类</span></span><br><span class="line">rf_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第二个handler</span></span><br><span class="line">f_handler = logging.FileHandler(<span class="string">'error.log'</span>)</span><br><span class="line"><span class="comment"># 设置这个handler的日志级别，实现日志过滤，在上面日志器的过滤结果中进行进一步的过滤</span></span><br><span class="line">f_handler.setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># 设置第二个handler的日志格式，使用了formatter类</span></span><br><span class="line">f_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给日志器添加第一个handler</span></span><br><span class="line">logger.addHandler(rf_handler)</span><br><span class="line"><span class="comment"># 给日志器添加第二个handler</span></span><br><span class="line">logger.addHandler(f_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同级别的日志信息 </span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat all.log</span><br><span class="line">  2019-03-23 16:53:48,763 - DEBUG - debug message</span><br><span class="line">  2019-03-23 16:53:48,766 - INFO - info message</span><br><span class="line">  2019-03-23 16:53:48,766 - WARNING - warning message</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - critical message</span><br><span class="line"></span><br><span class="line">cat error.log</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - logging_learn.py[:100] - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - logging_learn.py[:101] - critical message</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>%(filename)s[:%(lineno)d]</code>可以用来显示哪个文件的哪一行进行了这个日志输出</p></div><hr><h3 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a>其他实例</h3><h4 id="日志同时输出到文件和屏幕"><a href="#日志同时输出到文件和屏幕" class="headerlink" title="日志同时输出到文件和屏幕"></a>日志同时输出到文件和屏幕</h4><p>上面的那个实例是创建了两个handler来进行相关操作，其实也可以使用四大组件和日志级别函数结合来进行设置，<strong>以下是将日志同时输出到文件和屏幕的示例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用logging.basicConfig()来自定义日志输出信息，将日志信息输入到文件中</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                filename=<span class="string">'myapp.log'</span>,</span><br><span class="line">                filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"><span class="comment"># 使用四大组件来控制日志，因为一个handler只能输出到一个地方</span></span><br><span class="line"><span class="comment"># 这种需要输出到多个地方的肯定是需要两个handler的，上面的logging.basicConfig()相当于一个，所以还需要自己创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象#</span></span><br><span class="line">console = logging.StreamHandler()</span><br><span class="line"><span class="comment"># 设置handler的日志级别</span></span><br><span class="line">console.setLevel(logging.INFO)</span><br><span class="line"><span class="comment"># 使用foramtter类设置formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(name)-12s: %(levelname)-8s %(message)s'</span>)</span><br><span class="line"><span class="comment"># 设置handler的formatter</span></span><br><span class="line">console.setFormatter(formatter)</span><br><span class="line"><span class="comment"># 得到Logger类的对象并添加handler</span></span><br><span class="line">logging.getLogger(<span class="string">''</span>).addHandler(console)</span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'This is debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'This is info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'This is warning message'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="配置logging的几种方式"><a href="#配置logging的几种方式" class="headerlink" title="配置logging的几种方式"></a>配置logging的几种方式</h2><p>作为开发者，我们可以<strong>通过以下3中方式来配置logging</strong>:</p><ul><li>使用Python代码显式的创建loggers, handlers和formatters并分别调用它们的配置函数；</li><li>创建一个日志配置文件，然后使用fileConfig()函数来读取该文件的内容；</li><li>创建一个包含配置信息的dict，然后把它传递个dictConfig()函数；</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6885182.html" target="_blank" rel="noopener">《python之配置日志的几种方式》</a></p><hr><p><br></p><h2 id="向日志输出中添加上下文信息"><a href="#向日志输出中添加上下文信息" class="headerlink" title="向日志输出中添加上下文信息"></a>向日志输出中添加上下文信息</h2><p>除了传递给日志记录函数的参数外，有时候我们还想在<strong>日志输出中包含一些额外的上下文信息</strong>。比如，在一个网络应用中，可能希望在日志中记录客户端的特定信息，如：远程客户端的IP地址和用户名。这里我们来介绍以下几种实现方式：</p><ul><li>通过向日志记录函数传递一个<code>extra</code>参数引入上下文信息</li><li>使用<code>LoggerAdapters</code>引入上下文信息</li><li>使用<code>Filters</code>引入上下文信息</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6897964.html" target="_blank" rel="noopener">《Python之向日志输出中添加上下文信息》</a></p><hr><p><br></p><h2 id="实战技巧"><a href="#实战技巧" class="headerlink" title="实战技巧"></a>实战技巧</h2><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p><code>FileHandler</code> 创建对象时可以设置文件编码，如果将<strong>文件编码设置为 <code>utf-8</code>（utf-8 和 utf8 等价）</strong>，就可以解决中文乱码问题啦。</p><ul><li>一种方法是<strong>自定义 Logger 对象</strong>，需要写很多配置</li><li>另一种方法是<strong>使用默认配置方法 <code>basicConfig()</code>，传入 handlers 处理器列表对象</strong>，在其中的 handler 设置文件的编码</li></ul><p>关键参考代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义 Logger 配置</span></span><br><span class="line">handler = logging.FileHandler(filename=<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用默认的 Logger 配置，传入handlers时设置编码方式</span></span><br><span class="line">logging.basicConfig(handlers=[logging.FileHandler(<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)], level=logging.DEBUG)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="临时禁用日志输出"><a href="#临时禁用日志输出" class="headerlink" title="临时禁用日志输出"></a>临时禁用日志输出</h3><p>有时候我们又不想让日志输出，但在这后又想输出日志。</p><ul><li>一种方法是在<strong>使用默认配置时</strong>，给 <code>logging.disabled()</code> 方法<strong>传入禁用的日志级别</strong>，就可以禁止设置级别以下的日志输出了</li><li>另一种方法时在<strong>自定义 Logger 时</strong>，<strong>Logger 对象的 disable 属性设为 True，默认值是 False，也即不禁用</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认配置</span></span><br><span class="line">logging.disable(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的Logger</span></span><br><span class="line">logger.disabled = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割日志文件"><a href="#分割日志文件" class="headerlink" title="分割日志文件"></a>分割日志文件</h3><p><code>logging.handlers</code>文件中提供了<code>TimedRotatingFileHandler</code>和<code>RotatingFileHandler</code>类分别可以实现<strong>按时间</strong>和<strong>大小</strong>划分:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1000 Byte 划分一个日志文件，备份文件为 3 个</span></span><br><span class="line">file_handler = logging.handlers.RotatingFileHandler(<span class="string">"test.log"</span>, mode=<span class="string">"w"</span>, maxBytes=<span class="number">1000</span>, backupCount=<span class="number">3</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1小时 划分一个日志文件，interval 是时间间隔，备份文件为 10 个</span></span><br><span class="line">handler2 = logging.handlers.TimedRotatingFileHandler(<span class="string">"test.log"</span>, when=<span class="string">"H"</span>, interval=<span class="number">1</span>, backupCount=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>这个在前面的使用四大组件记录日志的示例中也有提及。</p><hr><p><br></p><h2 id="补充信息"><a href="#补充信息" class="headerlink" title="补充信息"></a>补充信息</h2><h3 id="datefmt支持的时间格式"><a href="#datefmt支持的时间格式" class="headerlink" title="datefmt支持的时间格式"></a>datefmt支持的时间格式</h3><table><tr><th width="20%">格式</th><th width="80%">含义</th></tr><tr><td><code>%a</code></td><td>本地（locale）简化星期名称</td></tr><tr><td><code>%A</code></td><td>本地完整星期名称</td></tr><tr><td><code>%b</code></td><td>本地简化月份名称</td></tr><tr><td><code>%B</code></td><td>本地完整月份名称</td></tr><tr><td><code>%c</code></td><td>本地相应的日期和时间表示</td></tr><tr><td><code>%d</code></td><td>一个月中的第几天（01 - 31）</td></tr><tr><td><code>%H</code></td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td><code>%I</code></td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td><code>%j</code></td><td>一年中的第几天（001 - 366）</td></tr><tr><td><code>%m</code></td><td>月份（01 - 12）</td></tr><tr><td><code>%M</code></td><td>分钟数（00 - 59）</td></tr><tr><td><code>%p</code></td><td>本地am或者pm的相应符</td></tr><tr><td><code>%S</code></td><td>秒（01 - 61）</td></tr><tr><td><code>%U</code></td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td></tr><tr><td><code>%w</code></td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td><code>%W</code></td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td><code>%x</code></td><td>本地相应日期</td></tr><tr><td><code>%X</code></td><td>本地相应时间</td></tr><tr><td><code>%y</code></td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td><code>%Y</code></td><td>完整的年份</td></tr><tr><td><code>%Z</code></td><td>时区的名字（如果不存在为空字符）</td></tr><tr><td><code>%%</code></td><td>‘%’字符</td></tr></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3.5/howto/logging.html" target="_blank" rel="noopener">Logging HOWTO-官方细致教程</a></li><li><a href="https://docs.python.org/3.5/howto/logging-cookbook.html" target="_blank" rel="noopener">Logging Cookbook-官方实例</a></li><li><a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">官方链接</a></li><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li><li><a href="http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html" target="_blank" rel="noopener">python 的日志logging模块学习</a></li><li><a href="https://blog.csdn.net/fxjtoday/article/details/6307285" target="_blank" rel="noopener">项目中比较需要用到的</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章依照&lt;a href=&quot;https://www.cnblogs.com/yyds/p/6901864.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇博客&lt;/a&gt;对Python的常用模块logging进行了学习，主要学习了&lt;code&gt;日志的作用&lt;/code&gt;、&lt;code&gt;不同开发环境设置不同的日志输出&lt;/code&gt;、&lt;code&gt;使用logging模块的日志级别函数直接记录日志&lt;/code&gt;；也学习了logging模块的&lt;strong&gt;高级用法&lt;/strong&gt;，包括&lt;strong&gt;使用logging模块的四大组件进行日志记录(主要用于满足多种需求，如将结果同时输出到文件和屏幕)&lt;/strong&gt;、配置logging的几种方式、向日志输出上下文信息等；最后也总结了一些&lt;strong&gt;实战技巧&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>cat-显示、读取或拼接文件内容</title>
    <link href="http://showteeth.tech/posts/24399.html"/>
    <id>http://showteeth.tech/posts/24399.html</id>
    <published>2019-03-22T12:00:42.000Z</published>
    <updated>2019-03-22T12:20:12.365Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用Linux的<code>cat</code>命令来执行文件的查看、合并和创建功能。在查看文件方面包括的参数有：<code>-n</code>、<code>-b</code>、<code>-s</code>、<code>-E</code>、<code>-T</code>；在合并文件方面学习了<strong>结合输出重定向以及前面的查看功能的参数进行合并</strong>；在创建文件方面主要有三个命令：<code>cat &gt;filename</code>、<code>cat &lt;&lt; EOF</code>和<code>cat &gt; filename &lt;&lt; EOF</code>。</p></div><a id="more"></a><h2 id="cat简介"><a href="#cat简介" class="headerlink" title="cat简介"></a>cat简介</h2><p><code>cat</code> 是一个文本文件(查看)和(连接)工具，通常是用于查看某个文件的内容，其主要有三大功能：</p><ul><li><strong>显示整个文件</strong>内容</li><li>将几个文件<strong>合并</strong>为一个文件</li><li><strong>从键盘创建一个文件</strong></li></ul><hr><p><br></p><h2 id="cat命令用法"><a href="#cat命令用法" class="headerlink" title="cat命令用法"></a>cat命令用法</h2><h3 id="cat命令格式"><a href="#cat命令格式" class="headerlink" title="cat命令格式"></a>cat命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cat [OPTION]... [FILE]...</span><br><span class="line">Description:</span><br><span class="line">  Concatenate FILE(s), or standard input, to standard output.</span><br></pre></td></tr></table></figure><hr><h3 id="cat-options说明"><a href="#cat-options说明" class="headerlink" title="cat options说明"></a>cat options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-n</strong></td><td>–number</td><td><strong>由1开始对所有输出的行数编号</strong></td></tr><tr><td><strong>-b</strong></td><td>–number-nonblank</td><td><strong>和-n相似，只不过对于空白行不编号</strong></td></tr><tr><td><strong>-s</strong></td><td>–squeeze-blank</td><td><strong>当遇到有连续两行以上的空白行，只输出一行的空白行</strong></td></tr><tr><td>-E</td><td>–show-ends</td><td>在每行结束处显示<code>$</code></td></tr><tr><td>-v</td><td>–show-nonprinting</td><td>使用<code>^</code>和<code>M-</code>符号，除了<code>LFD</code>和<code>TAB</code>之外</td></tr><tr><td>-T</td><td>–show-tabs</td><td>将<code>TAB</code>字符显示为<code>^I</code></td></tr><tr><td>-A</td><td>–show-all</td><td>等价于 <code>-vET</code></td></tr><tr><td>-e</td><td></td><td>等价于<code>-vE</code>选项</td></tr><tr><td>-t</td><td></td><td>等价于<code>-vT</code>选项</td></tr></tbody></table><hr><p><br></p><h2 id="cat用法实例"><a href="#cat用法实例" class="headerlink" title="cat用法实例"></a>cat用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>a<br>b 1</p><p>\====</p></blockquote><blockquote><p><code>cat test2.txt</code><br>c<br>d<br>\==</p></blockquote><hr><h3 id="查看文件功能"><a href="#查看文件功能" class="headerlink" title="查看文件功能"></a>查看文件功能</h3><h4 id="n-对所有行编号"><a href="#n-对所有行编号" class="headerlink" title="-n-对所有行编号"></a>-n-对所有行编号</h4><p><strong>所有行包含空白行</strong>：</p><blockquote><p><code>cat -n test1.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====</p></blockquote><hr><h4 id="b-对除空白行之外的行进行编号"><a href="#b-对除空白行之外的行进行编号" class="headerlink" title="-b-对除空白行之外的行进行编号"></a>-b-对除空白行之外的行进行编号</h4><blockquote><p><code>cat -b test1.txt</code><br>1 a<br>2 b 1</p><pre><code>3     ====  </code></pre></blockquote><p><strong>需要和上面的<code>-n</code>参数进行区分</strong></p><hr><h4 id="s-只输出连续多行空白行的其中一行"><a href="#s-只输出连续多行空白行的其中一行" class="headerlink" title="-s-只输出连续多行空白行的其中一行"></a>-s-只输出连续多行空白行的其中一行</h4><p><strong>结合前面的<code>-n</code>参数</strong>：</p><blockquote><p><code>cat -sn test1.txt</code><br>1 a<br>2 b 1<br>3<br>4 ====</p></blockquote><p>可以发现只输出了连续两行空白行中的一个，并进行编号，说明是先输出一个，然后编号的，不是先编号再输出其中一行</p><hr><h4 id="E-在每行结束处显示"><a href="#E-在每行结束处显示" class="headerlink" title="-E-在每行结束处显示$"></a>-E-在每行结束处显示$</h4><blockquote><p><code>cat -E test1.txt</code><br>a <strong>\$</strong><br>b 1<strong>\$</strong><br><strong>\$</strong><br><strong>\$</strong><br>====<strong>\$</strong></p></blockquote><hr><h4 id="T-将TAB字符显示为-I"><a href="#T-将TAB字符显示为-I" class="headerlink" title="-T-将TAB字符显示为^I"></a>-T-将TAB字符显示为^I</h4><blockquote><p>cat -nT test1.txt<br>1 a<br>2 b <strong>^I</strong>1<br>3<br>4<br>5 ====</p></blockquote><hr><p><br></p><h3 id="合并文件功能"><a href="#合并文件功能" class="headerlink" title="合并文件功能"></a>合并文件功能</h3><p>将<code>test1.txt</code>和<code>test2.txt</code>合并后重定向到<code>test3.txt</code>中：</p><blockquote><p><code>cat test1.txt test2.txt &gt;test3.txt</code><br><code>cat test3.txt</code><br>a<br>b 1</p><p>\====<br>c<br>d<br>\==</p></blockquote><p><strong>可以结合前面查看文件的参数</strong>：</p><blockquote><p><code>cat -n test1.txt test2.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====<br>6 c<br>7 d<br>8 ==</p></blockquote><div class="note info"><ul><li><strong>后面不接文件的话会输出到标准输出</strong></li><li>文件内容是<strong>按照文件顺序连接起来的</strong></li><li><strong>编号是连续的</strong>，不是每个文件单独的编号</li></ul></div><hr><p><br></p><h3 id="创建文件相关功能"><a href="#创建文件相关功能" class="headerlink" title="创建文件相关功能"></a>创建文件相关功能</h3><p>这一部分主要有三个比较重要和常见的命令：</p><ul><li><code>cat &lt;&lt; EOF</code></li><li><code>cat &gt; filename</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code></li></ul><h4 id="cat-lt-lt-EOF"><a href="#cat-lt-lt-EOF" class="headerlink" title="`cat &lt;&lt; EOF"></a>`cat &lt;&lt; EOF</h4><p><strong>以<code>EOF</code>输入字符为标准输入结束</strong>，这里的<strong>EOF并不是固定</strong>的(<code>EOF是end of file</code>，表示文本结束符，使用有含义的字符可能更容易记住用法)，可以设置为<code>mmm</code>等其他自定义的字符，示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF </span><br><span class="line">&gt; ad    <span class="comment"># 开始从标准输入读取</span></span><br><span class="line">&gt; adad</span><br><span class="line">&gt; EOF <span class="comment"># 遇到了标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad    <span class="comment"># 直接输出</span></span><br><span class="line">adad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换标准输入结束字符</span></span><br><span class="line">cat &lt;&lt; mmm</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; mmm   <span class="comment"># 遇到了上面定义的标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad</span><br><span class="line">ad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>这一部分输入输入和输出重定向部分，还可以参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h4 id="cat-gt-filename"><a href="#cat-gt-filename" class="headerlink" title="cat &gt; filename"></a><code>cat &gt; filename</code></h4><p><strong>创建文件</strong>，并<strong>把标准输入输出到filename文件</strong>中，<strong>以<code>ctrl+d</code>作为输入结束</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并写入</span></span><br><span class="line">cat &gt; filename</span><br><span class="line">ad</span><br><span class="line">adad   <span class="comment"># 这一行输入完成之后按下快捷键ctrl+d结束输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat filename </span><br><span class="line">ad</span><br><span class="line">adad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>cat &gt; filename</code>命令和上面的<code>cat &lt;&lt; EOF</code>不同之处在于：</p><ul><li><code>cat &lt;&lt; EOF</code>不会创建文件，而<code>cat &gt; filename</code>会创建文件</li><li><code>cat &lt;&lt; EOF</code>可以自定义结束的字符，而<code>cat &gt; filename</code>则是使用快捷键<code>ctrl+d</code>作为输入结束</li><li><code>cat &lt;&lt; EOF</code>输入的时候有<code>&gt;</code>提示输入，而<code>cat &gt; filename</code>没有任何提示输入的此内容</li></ul></div><hr><h4 id="cat-gt-filename-lt-lt-EOF"><a href="#cat-gt-filename-lt-lt-EOF" class="headerlink" title="cat &gt; filename &lt;&lt; EOF"></a><code>cat &gt; filename &lt;&lt; EOF</code></h4><p>这个是上面两个的合并版，<strong>既可以创建文件</strong>，<strong>又可以自定义停止输入字符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并设置停止输入字符</span></span><br><span class="line">cat &gt; test4.txt &lt;&lt; EOF</span><br><span class="line">&gt; a</span><br><span class="line">&gt; b</span><br><span class="line">&gt; c</span><br><span class="line">&gt; d</span><br><span class="line">&gt; EOF   <span class="comment"># 遇到了标准输入结束字符，结束标准输入，但是不会直接输入，因为内容已经重定向到test4.txt中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test4.txt文件内容，是刚刚输入的内容</span></span><br><span class="line">cat test4.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p></p><ul><li>上面的创建文件也<strong>可以改为追加文件</strong>：<code>cat &gt;&gt; test4.txt &lt;&lt; EOF</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code>书写的前后顺序可以调换，比如可写成：<code>cat &lt;&lt; EOF &gt; filename</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cat" target="_blank" rel="noopener">cat命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-cat.html" target="_blank" rel="noopener">Linux cat命令</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/7717602.html" target="_blank" rel="noopener">Linux cat命令详解</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5856106.html" target="_blank" rel="noopener">Linux中cat、more、less、tail、head命令的区别</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了使用Linux的&lt;code&gt;cat&lt;/code&gt;命令来执行文件的查看、合并和创建功能。在查看文件方面包括的参数有：&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-E&lt;/code&gt;、&lt;code&gt;-T&lt;/code&gt;；在合并文件方面学习了&lt;strong&gt;结合输出重定向以及前面的查看功能的参数进行合并&lt;/strong&gt;；在创建文件方面主要有三个命令：&lt;code&gt;cat &amp;gt;filename&lt;/code&gt;、&lt;code&gt;cat &amp;lt;&amp;lt; EOF&lt;/code&gt;和&lt;code&gt;cat &amp;gt; filename &amp;lt;&amp;lt; EOF&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Git系列-Git实战总结</title>
    <link href="http://showteeth.tech/posts/5778.html"/>
    <id>http://showteeth.tech/posts/5778.html</id>
    <published>2019-03-22T07:25:26.000Z</published>
    <updated>2019-03-26T02:27:55.913Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在使用Git中遇到的比较使用的技巧和问题解决方案，便于后续查询和使用。</p></div><a id="more"></a><h2 id="gitignore文件不起作用以及文件规则"><a href="#gitignore文件不起作用以及文件规则" class="headerlink" title=".gitignore文件不起作用以及文件规则"></a>.gitignore文件不起作用以及文件规则</h2><h3 id="文件书写规则"><a href="#文件书写规则" class="headerlink" title="文件书写规则"></a>文件书写规则</h3><p>在使用Git管理代码的过程中，可以修改<code>.gitignore</code>文件中的标示的方法来<strong>忽略开发者想忽略掉的文件或目录(实际项目中，很多文件都是不需要版本管理的)</strong>，如果没有<code>.gitignore</code>文件，可以自己手工创建。在<code>.gitignore</code>文件中的每一行保存一个匹配的规则例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"> </span><br><span class="line">*.a       <span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">!lib.a    <span class="comment"># 但 lib.a 除外</span></span><br><span class="line">/TODO     <span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line">build/    <span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">doc/*.txt <span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure><p></p><p>需要强调的一点是，如果你不慎在创建<code>.gitignore</code>文件之前就push了项目，那么即使你在<code>.gitignore</code>文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说，出现这种问题的原因就是<strong>Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们</strong>。所以大家一定要<strong>养成在项目开始就创建<code>.gitignore</code>文件的习惯，否则一旦push，处理起来会非常麻烦。</strong></p><div class="note info"><p>忽略整个文件夹，只需要<code>build/</code>即可，千万不要<code>build/*</code>，这样的话不会起效</p></div><hr><h3 id="清除本地缓存"><a href="#清除本地缓存" class="headerlink" title="清除本地缓存"></a>清除本地缓存</h3><p>如果一不小心在创建<code>.gitignore</code>文件之前就使用了<code>git push</code>，这样可能会使得<code>.gitignore</code>的忽略规则失效，这是因为新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在<code>.gitignore</code>中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行<code>git push</code>，这样就不会出现忽略的文件了。git清除本地缓存命令如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line">git rm -r --cached .</span><br><span class="line"><span class="comment"># 将所有文件改变上传到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 将暂存区的所有内容提交到当前分支上</span></span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="git-push-u-VS-git-push"><a href="#git-push-u-VS-git-push" class="headerlink" title="git push -u VS git push"></a>git push -u VS git push</h2><p><code>git push</code>的用法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与多个主机存在追踪关系(连接)，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用：</span></span><br><span class="line"><span class="comment"># 先使用带-u参数的git push</span></span><br><span class="line">git push -u origin master </span><br><span class="line"><span class="comment"># 后续的git push可以省略参数</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将已有的文件夹上传到github"><a href="#将已有的文件夹上传到github" class="headerlink" title="将已有的文件夹上传到github"></a>将已有的文件夹上传到github</h2><p>背景：可能有些时候并没有在文件夹创建之初没有考虑到上传到Github的情况，所以就需要将已有的文件夹上传到Github，但是又不希望先建立空的repo，然后clone下来将文件复制进去，然后就有了下面的方法：</p><ul><li>在bash下<strong>进入需要上传的文件夹</strong>：<code>cd dir</code></li><li><strong>初始化产生版本库</strong>：<code>git init</code></li><li>将所有文件<strong>添加到暂存区</strong>：<code>git add .</code></li><li>提交文件：<code>git commit -m &quot;message&quot;</code></li><li>添加远程仓库：<code>git remote add origin git@github.com:showteeth/orth_blast_docker.git</code></li><li>上传本地代码：<code>git push -u origin master</code></li><li>后续上传：<ul><li><code>git add .</code></li><li><code>git commit -m &quot;message&quot;</code></li><li><code>git push origin master</code>或者<code>git push</code></li></ul></li></ul><p>在使用<code>git push -u origin master</code>上传本地代码时，如果报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.com:showteeth/orth_blast_docker.git'</span></span><br></pre></td></tr></table></figure><p></p><ul><li>按照这个<a href="https://github.com/rtyley/bfg-repo-cleaner/issues/29" target="_blank" rel="noopener">issue</a>的说法，可以试试<code>git push -u origin master --force</code></li><li>或者按照<a href="https://blog.csdn.net/pql925/article/details/72772660" target="_blank" rel="noopener">这篇文章</a>的做法：<ul><li>合并代码：<code>git pull origin master</code>或者<code>git pull --rebase origin master</code>(<mark>文章中使用的这个，但我感觉是不是应该使用前面的，下次可以先试试前面的可不可以</mark>)</li><li>上传代码：<code>git push -u origin master</code></li></ul></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录了在使用Git中遇到的比较使用的技巧和问题解决方案，便于后续查询和使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列-Dockerfile</title>
    <link href="http://showteeth.tech/posts/31987.html"/>
    <id>http://showteeth.tech/posts/31987.html</id>
    <published>2019-03-21T13:18:13.000Z</published>
    <updated>2019-03-22T04:02:58.362Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/leveldc/article/details/85492558#_1" target="_blank" rel="noopener">Dockerfile详解</a></li><li><a href="https://www.cnblogs.com/lighten/p/6900556.html" target="_blank" rel="noopener">docker学习(3)–Dockfile详解</a></li><li><a href="https://www.centos.bz/2016/12/dockerfile-cmd-instruction/" target="_blank" rel="noopener">Dockerfile参考(8) – CMD设置运行容器时执行的命令</a></li><li><a href="https://www.jianshu.com/p/78f4591b7ff0" target="_blank" rel="noopener">Docker CMD</a></li><li><a href="https://www.cnblogs.com/51kata/p/5264894.html" target="_blank" rel="noopener">docker学习笔记16：Dockerfile 指令 ADD 和 COPY介绍</a></li><li><a href="https://www.cnblogs.com/lienhua34/p/5170335.html" target="_blank" rel="noopener">Dockerfile创建自定义Docker镜像以及CMD与ENTRYPOINT指令的比较</a></li><li><a href="http://www.dockone.io/article/1414" target="_blank" rel="noopener">九个编写Dockerfiles的常见错误</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Docker" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Docker/"/>
    
    
      <category term="Docker" scheme="http://showteeth.tech/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-构建第一个docker镜像</title>
    <link href="http://showteeth.tech/posts/371.html"/>
    <id>http://showteeth.tech/posts/371.html</id>
    <published>2019-03-21T08:54:20.000Z</published>
    <updated>2019-03-22T04:02:58.399Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是我的第一个Docker镜像，主要是依托项目是寻找两个基因之间的同源基因对。这篇文章主要记录了创建第一个镜像的过程，包括前期测试、编写Dockfile、查看镜像、运行镜像、修改镜像、退出、关闭、重启镜像、删除镜像以及后面的发布镜像、拉取镜像等操作，同时也记录了运行中的一些错误和解决办法。</p></div><a id="more"></a><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>docker 镜像是一个只读的 docker 容器模板，含有启动 docker 容器所需的文件系统结构及其内容(包括对资源需求、环境的要求、依赖的类库和运行的代码等等)，因此是启动一个 docker 容器的基础。</p><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile用于构建<strong>一致的Docker镜像</strong>，其定义了容器中的运行环境，包括像网络接口和虚拟化的磁盘驱动等硬件资源，这些资源是与宿主系统隔离开的，不会对系统有任何影响。使用Docker镜像运行Docker容器，可以让定义在该镜像中的应用程序<strong>无论在哪里运行，都有一致的功能</strong>。</p><h3 id="示例Dockerfile学习"><a href="#示例Dockerfile学习" class="headerlink" title="示例Dockerfile学习"></a>示例Dockerfile学习</h3><p>以下是官方的<code>Dockerfile</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方python镜像作为根镜像</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER <span class="string">"user_id&lt;email address&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /app 目录下</span></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外公开容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个环境变量world</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行 python app.py命令</span></span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="示例Dockerfile解读"><a href="#示例Dockerfile解读" class="headerlink" title="示例Dockerfile解读"></a>示例Dockerfile解读</h3><ul><li>FROM：FROM命令是<strong>必须的</strong>，<strong>可以是基于某个镜像</strong><ul><li><strong>从0开始构建</strong>：需要使用<code>scratch</code>，<code>scratch</code>代表着一个空白的镜像**，此时基本命令就是<code>FROM scratch</code>；</li><li>基于某个镜像：如上使用官方python镜像作为根镜像，所有的官方镜像可以在这个网站看到</li></ul></li><li>MAINTAINER：就是将维护人信息添加到脚本文件中，<strong>不一定需要，可有可无</strong></li><li>WORKDIR：定义工作目录</li><li><p>ADD：将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件拷贝到镜像中</p></li><li><p>RUN：用来执行基本命令的，基本格式有两种</p><ul><li>第一种是Shell格式：如上面安装包的命令以及<code>RUN npm install</code></li><li>第二种是exec格式：如<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ul></li></ul><p>由于<code>Dockerfile</code>每一个命令都会建立一层，RUN也不例外，在不必要的情况下使用多行RUN命令会使得镜像非常冗余和庞大，以下是一个示例:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p></p><p>类似上述例子，<strong>一共构建了7层镜像</strong>，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等，<strong>结果就是产生非常臃肿、非常 多层的镜像，不仅仅增加了构建部署的时间，也很容易出错</strong>。</p><p>正确写法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \ &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p></p><p>首先，之前所有的命令只有一个目的：编译、安装redis可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个RUN指令，并使用 <code>&amp;&amp;</code>将各个所需命令串联起来。将之前的7层，简化为了1层。其中每行命令后的 <code>\</code> 代表着换行，使dockerfile的RUN命令更具有可读性。</p><p>此外，命令的最后一行还有一个 <code>--auto-remove</code>命令，这个为<strong>清理工作</strong>的命令，<strong>删除了编译所需要的软件，清理下载以及展开的文件，并且还清理了apt缓存文件</strong>。由于镜像是一层一层构建的，每一层的多余东西并不会在下一层中被删除掉，到后面镜像会越来越大，因此<strong>清理这些没有用处的东西很有必要</strong>.</p><blockquote><p>RUN示例<a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">参考博客</a></p></blockquote><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile，其中安装Python所需要的依赖包时使用了文件进行安装，没有使用多行命令以及上述提及的使用<code>&amp;&amp;</code>的方法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p></p><p>示例的requirements.txt文件内容：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p></p><ul><li>EXPOSE：将指定的端口暴露出来，可以供外界访问，或者映射到宿主机的端口上去</li><li>CMD：容器启动命令，CMD命令和RUN命令相似，也是两种格式，分别为 <strong><code>shell</code>命令格式</strong>和 <strong><code>exec</code>命令格式</strong>。</li></ul><p>CMD 指令就是用于指定<strong>默认的容器主进程的启动命令的</strong>。在<code>exec</code>命令格式上，一般会被解析成json数组格式，<strong>需要用双引号，不能使用单引号!!!</strong></p><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile的CMD命令：<code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>，属于 <strong><code>exec</code>命令格式</strong>，<strong>注意使用的是双引号</strong>，意思是<strong>容器使用Python运行app.py文件</strong>，至于具体的app.py文件信息就不列举了。</p><div class="note info"><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">各个参数的官方解释</a></p></div><hr><h3 id="动手测试Dockerfile"><a href="#动手测试Dockerfile" class="headerlink" title="动手测试Dockerfile"></a>动手测试Dockerfile</h3><p>基于上面对示例Dockerfile的学习，接下来自己建立自己的Dockerfile</p><h4 id="建立centos的测试"><a href="#建立centos的测试" class="headerlink" title="建立centos的测试"></a>建立centos的测试</h4><p>Dockerfile内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos7</span></span><br><span class="line">FROM centos:7</span><br><span class="line"><span class="comment"># 维护人信息</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"><span class="comment"># 看看是否安装了python以及版本</span></span><br><span class="line">CMD python -v</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="创建docker镜像"><a href="#创建docker镜像" class="headerlink" title="创建docker镜像"></a>创建docker镜像</h4><p>基于上述Dockerfile使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>建立镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker build -f .\Dockerfile  -t centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line"><span class="comment"># 第一步对应于第一行</span></span><br><span class="line">Step 1/4 : FROM centos:7</span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">8ba884070f61: Pull complete</span><br><span class="line">Digest: sha256:ca58fe458b8d94bc6e3072f1cfbd334855858e05e1fd633aa07cf7f82b048e66</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:7</span><br><span class="line"> ---&gt; 9f38484d220f</span><br><span class="line"><span class="comment"># 第二步对应于第二行</span></span><br><span class="line">Step 2/4 : MAINTAINER showteeth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 75f880e1b2d9</span><br><span class="line">Removing intermediate container 75f880e1b2d9</span><br><span class="line"> ---&gt; 9ea90a7b7832</span><br><span class="line"><span class="comment"># 第三步对应于第三行</span></span><br><span class="line">Step 3/4 : WORKDIR /orth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 2c117f20ad92</span><br><span class="line">Removing intermediate container 2c117f20ad92</span><br><span class="line"> ---&gt; 07e0e346b57d</span><br><span class="line"><span class="comment"># 第四步对应于第四行 </span></span><br><span class="line">Step 4/4 : CMD python -v</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 297b155a52be</span><br><span class="line">Removing intermediate container 297b155a52be</span><br><span class="line"> ---&gt; 1f29d9e70fac</span><br><span class="line">Successfully built 1f29d9e70fac</span><br><span class="line">Successfully tagged centos:1.0</span><br><span class="line">SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have <span class="string">'-rwxr-xr-x'</span> permissions. It is recommended to double check and reset permissions <span class="keyword">for</span> sensitive files and directories.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>创建完成之后使用命令<code>docker images</code>查看镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里信息和build命令以及输出信息的对应</span></span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                     1.0                 1f29d9e70fac        8 minutes ago       202MB</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>使用<code>docker run -it centos:1.0</code>运行镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/aliases.pyc matches /usr/lib64/python2.7/encodings/aliases.py</span></span><br><span class="line">import encodings.aliases <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/aliases.pyc</span></span><br><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/ascii.pyc matches /usr/lib64/python2.7/encodings/ascii.py</span></span><br><span class="line">import encodings.ascii <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/ascii.pyc</span></span><br><span class="line">Python 2.7.5 (default, Oct 30 2018, 23:45:53)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">dlopen(<span class="string">"/usr/lib64/python2.7/lib-dynload/readline.so"</span>, 2);</span><br><span class="line">import readline <span class="comment"># dynamically loaded from /usr/lib64/python2.7/lib-dynload/readline.so</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p></p><p><strong>如上，运行之后自动运行了<code>python -v</code>，因为前面的Dockerfile的<code>CMD</code>写的就是这个命令</strong>，如果没有Python，可以参考这个链接来<a href="https://www.centos.bz/2018/01/%E5%9C%A8centos%E4%B8%8A%E5%AE%89%E8%A3%85python3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">安装Python</a></p><hr><h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h4><p>由于开始的时候设置了<code>CMD python -v</code>，导致镜像运行之后自动进入Python程序，退出Python之后也退出了整个docker环境，所以想知道可不可以修改CMD命令，查询<a href="https://serverfault.com/questions/594281/how-can-i-override-cmd-when-running-a-docker-image" target="_blank" rel="noopener">相关文档</a>之后，可以使用如下进行修改：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --entrypoint=/bin/bash <span class="variable">$IMAGE</span> -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如我可以使用如下命令进入bash shell的交互环境</span></span><br><span class="line">docker run -it --entrypoint=/bin/bash centos:1.0 -i</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="退出、关闭、重启镜像"><a href="#退出、关闭、重启镜像" class="headerlink" title="退出、关闭、重启镜像"></a>退出、关闭、重启镜像</h4><ul><li>使用命令<code>exit</code>来<strong>退出</strong>正在使用的镜像，注意退出之后并没有关闭，后台还在运行，使用<code>docker ps -a</code>可看到</li><li>使用<code>docker stop image_id|name</code>来关闭镜像</li></ul><hr><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>测试版本镜像和真正想要使用的镜像有很大差距，所以打算直接删掉重新创建一个镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有的container，这样才能够删除其中的images：</span></span><br><span class="line">docker stop $(docker ps -a -q)   <span class="comment"># Linux下可以这么使用，windows还是单个单个操作吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要删除 所有container 的话再加一个指令：</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前有些什么images</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除images，通过image的 id 来指定删除谁，注意和上面的删除容器相区分</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print <span class="variable">$3</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除 全部 image的话</span></span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：运行docker时docker desktop必须也在运行，而且不要关闭，一旦关闭，正在运行的container会直接退出</p></div><hr><h3 id="编写Dockfile"><a href="#编写Dockfile" class="headerlink" title="编写Dockfile"></a>编写Dockfile</h3><h4 id="准备文件信息"><a href="#准备文件信息" class="headerlink" title="准备文件信息"></a>准备文件信息</h4><ul><li>blast软件包</li><li>python相关运行文件</li><li>初始文件(fasta文件)</li><li>相关的脚本</li></ul><hr><h4 id="正式的Dockerfile"><a href="#正式的Dockerfile" class="headerlink" title="正式的Dockerfile"></a>正式的Dockerfile</h4><p>经过上述所有的学习和尝试，这里给出了最终可以运行的Dockerfile：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos镜像</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /orth</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /orth 目录下</span></span><br><span class="line">ADD . /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN yum -y install epel-release \</span><br><span class="line">&amp;&amp; yum -y install python-pip \ </span><br><span class="line">&amp;&amp; yum -y install vim \</span><br><span class="line">&amp;&amp; pip install -r requirements.txt \</span><br><span class="line">&amp;&amp; chmod 744 /orth/scripts/docker_blast.sh \</span><br><span class="line">&amp;&amp; tar -zxvf /orth/ncbi-blast-2.8.1+-x64-linux.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将blast加入环境变量</span></span><br><span class="line">ENV PATH /orth/ncbi-blast-2.8.1+/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行命令</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p></p><p>上面使用ADD没有执行自动解压操作，后续添加了自动解压操作，这个是官方的一个<a href="https://github.com/docker/docker-ce/releases/tag/v17.06.0-ce" target="_blank" rel="noopener">issue</a>，后续版本会改进。</p><hr><h4 id="创建和运行镜像"><a href="#创建和运行镜像" class="headerlink" title="创建和运行镜像"></a>创建和运行镜像</h4><ul><li>创建镜像：<code>docker build -f .\Dockerfile -t orth_project:2.0 .</code></li><li>运行镜像：<code>docker run -it orth_project:2.0</code></li><li>在镜像中使用<code>bash /orth/scripts/docker_blast.sh</code>运行查找同源基因的程序</li></ul><hr><p><br></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>主要步骤如下：</p><ul><li>第一步：开通<a href="https://cr.console.aliyun.com/new/new" target="_blank" rel="noopener">阿里云镜像服务</a></li><li>第二步：创建镜像仓库</li><li>第三步：推送镜像</li><li>第四步：查找验证镜像</li></ul><p>首先是开通阿里云镜像服务：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/开通阿里云镜像服务" alt="开通阿里云镜像服务"></p><hr><p>接下来创建镜像仓库：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库.png" alt="创建镜像仓库"><br><strong>仓库类型选择公开</strong><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库_2.png" alt="创建镜像仓库_2.png"><br><strong>代码源选择本地仓库</strong></p><hr><p>创建完成镜像仓库后，点击刚刚创建的镜像的管理，发现如下信息：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/推送镜像.png" alt="推送镜像.png"><br>然后，就可以按照上述图片中的提示完成镜像的推送，下面也列出了镜像推送的命令：</p><ul><li><code>docker login --username=username registry.cn-beijing.aliyuncs.com</code>输入这一步需要验证密码，验证成功会显示<code>Login Succeeded</code></li><li><code>docker tag [ImageId] registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这一步前面的<code>[ImageId]</code>使用<code>docker images</code>查看，<code>[镜像版本号]</code>是你上传上去想要显示的版本号，运行完成没有输出信息</li><li><code>docker push registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这里的<code>[镜像版本号]</code>是你上传上去想要显示的版本号，和上一步的保持一致，这一步完成会显示如下信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The push refers to repository [registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project]</span><br><span class="line">788a64a2f222: Pushed</span><br><span class="line">f652370971d2: Pushed</span><br><span class="line">d245b64a20a7: Pushed</span><br><span class="line">d69483a6face: Pushed</span><br><span class="line">1.0: digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7 size: 1161</span><br></pre></td></tr></table></figure></li></ul><div class="note info"><p>上传完成镜像后，本地也会出现一个名为<code>registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project</code>的镜像(<strong>该镜像具有和原始镜像相同的iamge id</strong>)，可以删除，通过命令<code>docker rmi -f registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</code>删除</p></div><hr><p>最后是查找验证镜像，经过上面几步已经成功将镜像上传到阿里云，接下来到阿里云中搜索自己刚刚上传的镜像：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索.png" alt="镜像搜索.png"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索结果.png" alt="镜像搜索结果.png"></p><hr><p><br></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>在上述查询到镜像结果之后，点击<strong>查看镜像的详细信息</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像的详细信息.png" alt="镜像的详细信息.png"></p><p><strong>复制公网地址</strong>并<strong>使用如下命令拉取镜像</strong>：<code>docker pull registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code></p><div class="note info"><p><strong>注意这个<code>[镜像版本号]</code>一定要指定，因为可能会存在很多版本号，这里指定后会拉取指定版本</strong></p></div><p>运行完成之后输出如下信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0: Pulling from showteeth/orth_blast_project</span><br><span class="line">Digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="build-with-gRPC-error"><a href="#build-with-gRPC-error" class="headerlink" title="build with gRPC error"></a>build with gRPC error</h3><p>使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[0000] failed to dial gRPC: cannot connect to the Docker daemon. Is <span class="string">'docker daemon'</span> running on this host?: open //./pipe/docker_engine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure><p></p><p><strong>解决办法</strong>：<br>在Github上看到了类似的<a href="https://github.com/docker-library/docker/issues/71" target="_blank" rel="noopener">issue</a>，主要的解决方法是在docker的设置中开启experimental features，如下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/experimental_features" alt="experimental_features"></p><p><strong>开启完成之后就解决了问题</strong></p><hr><h3 id="docker-image-is-being-used"><a href="#docker-image-is-being-used" class="headerlink" title="docker image is being used"></a>docker image is being used</h3><p>在使用<code>docker rmi 20ffdd2f28c0</code>删除镜像是发现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: conflict: unable to delete 20ffdd2f28c0 (must be forced) - image is being used by stopped container 7356c1e7efc0</span><br></pre></td></tr></table></figure><p></p><p><strong>解决方法：</strong></p><ul><li><p>先删除上面提示的那个占用当前镜像的<code>7356c1e7efc0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm  7356c1e7efc0</span><br></pre></td></tr></table></figure></li><li><p>然后再使用命令<code>docker rmi 20ffdd2f28c0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 20ffdd2f28c0</span><br></pre></td></tr></table></figure></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">Docker工作基本流程</a></li><li><a href="https://yq.aliyun.com/articles/596352" target="_blank" rel="noopener">Docker初体验，向Docker Hub推送第一个Docker镜像</a></li><li><a href="https://blog.csdn.net/qq_34680763/article/details/79711567" target="_blank" rel="noopener">第一次构建、运行、发布、获取docker镜像</a></li><li><a href="https://www.jianshu.com/p/4971967f7d3c" target="_blank" rel="noopener">Docker入门（二）创建您的第一个Docker镜像</a></li><li><a href="http://dockone.io/article/783" target="_blank" rel="noopener">10张图带你深入理解Docker容器和镜像</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是我的第一个Docker镜像，主要是依托项目是寻找两个基因之间的同源基因对。这篇文章主要记录了创建第一个镜像的过程，包括前期测试、编写Dockfile、查看镜像、运行镜像、修改镜像、退出、关闭、重启镜像、删除镜像以及后面的发布镜像、拉取镜像等操作，同时也记录了运行中的一些错误和解决办法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Docker" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Docker/"/>
    
    
      <category term="Docker" scheme="http://showteeth.tech/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python-博客转载项目</title>
    <link href="http://showteeth.tech/posts/26003.html"/>
    <id>http://showteeth.tech/posts/26003.html</id>
    <published>2019-03-21T08:14:20.000Z</published>
    <updated>2019-03-26T04:07:48.882Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这个项目主要是基于在转载博客时直接复制HTML后期不好修改，不能像Markdown一样生成大纲，不易管理，所以这里想做这样一个项目，<a href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener">项目地址</a>。</p></div><a id="more"></a><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="HTML装换为markdown"><a href="#HTML装换为markdown" class="headerlink" title="HTML装换为markdown"></a>HTML装换为markdown</h3><p>要想实现博客的装载，其中HTML装换为markdown是最为关键的一步，目前github上使用较多的(star较多)的HTML装换为markdown工具有三个：</p><ul><li><a href="https://github.com/domchristie/turndown" target="_blank" rel="noopener">turndown</a>，使用javascript代码，有<a href="http://domchristie.github.io/turndown/" target="_blank" rel="noopener">网页版</a>可以使用，比较好用，如果没有太大需要可以使用这个</li><li><a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener">html2text</a>，使用Python代码，可以嵌入其他程序使用，比较方便(很多印象笔记转文本的都是使用这个的)，这次我也打算使用这个</li><li><a href="https://github.com/gaojiuli/tomd" target="_blank" rel="noopener">tomd</a>，这个也是使用Python代码，但是star没有前面一个高，作为备用吧</li></ul><hr><h4 id="html2text使用"><a href="#html2text使用" class="headerlink" title="html2text使用"></a>html2text使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> html2text</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (html2text.html2text(<span class="string">"&lt;p&gt;Hello, world.&lt;/p&gt;"</span>))</span><br><span class="line">Hello, world.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = html2text.HTML2Text()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (h.handle(<span class="string">"&lt;p&gt;Hello, &lt;a href='http://earth.google.com/'&gt;world&lt;/a&gt;!"</span>))</span><br><span class="line">Hello, [world](http://earth.google.com/)!</span><br></pre></td></tr></table></figure><hr><h3 id="爬取网站内容"><a href="#爬取网站内容" class="headerlink" title="爬取网站内容"></a>爬取网站内容</h3><p>有了HTML装换markdown的工具，还需要使用工具将网页内容爬取下来，这里使用Python爬虫实现。</p><ul><li>XPATH和selector都可以通过右键复制得到</li><li><code>Selenium</code>模拟登陆很好用</li></ul><hr><h3 id="博客园、CSDN、简书博客"><a href="#博客园、CSDN、简书博客" class="headerlink" title="博客园、CSDN、简书博客"></a>博客园、CSDN、简书博客</h3><p>这几个网站作为统一的博客平台，爬虫时选取的部位固定，所以直接内置了.</p><hr><h3 id="其他自建博客"><a href="#其他自建博客" class="headerlink" title="其他自建博客"></a>其他自建博客</h3><p><strong>需要给双引号增加转义</strong>，如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python blog_parse.py -u http://rvdsd.top/2017/09/22/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-13%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/ -b others -c //*[@id=\<span class="string">"posts\"]/article/div/div -t //*[@id=\"posts\"]/article/div/header/h1</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h3><p>网上有将印象笔记先到处enex格式文件，然后根据这个文件进行转换格式的工具，但是我使用后发现并不好用.所以这里的想法是先将印象笔记分享为html的形式，然后再进行html转换为markdown，这样应该效果会好很多。</p><ul><li><a href="https://dev.yinxiang.com/doc/" target="_blank" rel="noopener">印象笔记开发者文档</a></li><li><a href="https://dev.yinxiang.com/doc/start/python.php" target="_blank" rel="noopener">印象笔记 Python SDK 快速入门指南</a></li></ul><h4 id="申请印象笔记-API-Key"><a href="#申请印象笔记-API-Key" class="headerlink" title="申请印象笔记 API Key"></a>申请印象笔记 API Key</h4><p>见官网教程</p><hr><h4 id="下载印象笔记-Python-SDK"><a href="#下载印象笔记-Python-SDK" class="headerlink" title="下载印象笔记 Python SDK"></a>下载印象笔记 Python SDK</h4><p>不要使用官网的那个链接，使用<a href="https://github.com/evernote/evernote-sdk-python3" target="_blank" rel="noopener">Python3的版本</a>，然后执行：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="测试-SDK"><a href="#测试-SDK" class="headerlink" title="测试 SDK"></a>测试 SDK</h4><p>进入Python环境，尝试导入包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\evernote3-1.25.0-py3.7.egg\evernote\api\client.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'oauth2'</span></span><br></pre></td></tr></table></figure><p></p><p>按照上面的提示，安装oauth2包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install oauth2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再进入Python环境</span></span><br><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"><span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>常规的按照印象笔记网站上的步骤，但是进行的过程中发现使用网站上的代码一直报错：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码</span></span><br><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">dev_token = <span class="string">"personal taken"</span></span><br><span class="line">client = EvernoteClient(token=dev_token,sandbox=<span class="keyword">False</span>,service_host=<span class="string">'app.yinxiang.com'</span>)</span><br><span class="line">userStore = client.get_user_store()</span><br><span class="line">user = userStore.getUser()</span><br><span class="line"><span class="keyword">print</span> (user.username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">evernote.edam.error.ttypes.EDAMSystemException: EDAMSystemException(message=<span class="string">'authenticationToken'</span>, errorCode=<span class="number">8</span>, rateLimitDuration=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p>在官方文档的各种地方查找都没有找到合适的方法，最后在<a href="https://www.tuicool.com/articles/2MV3QvU" target="_blank" rel="noopener">这篇文章中</a>找到了解决方案：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">dev_token = <span class="string">"personla taken"</span></span><br><span class="line">client = EvernoteClient(token=dev_token,sandbox=<span class="keyword">False</span>,service_host=<span class="string">'app.yinxiang.com'</span>)</span><br><span class="line">userStore = client.get_user_store()</span><br><span class="line">user = userStore.getUser()</span><br><span class="line"><span class="keyword">print</span> (user.username)</span><br></pre></td></tr></table></figure><p></p><p>吐槽一句：<strong>印象笔记的官方文档实在是太差了！！！忍不了！！！</strong></p><div class="note info"><p><a href="https://www.tuicool.com/articles/2MV3QvU" target="_blank" rel="noopener">这篇文章中</a>解决问题的步骤很值得我们学习，查看源码，找出问题，然后解决问题，很关键。</p></div><hr><h4 id="NoteStore-笔记本仓库"><a href="#NoteStore-笔记本仓库" class="headerlink" title="NoteStore-笔记本仓库"></a>NoteStore-笔记本仓库</h4><p>NoteStore 是用来创建、更新和删除笔记、笔记本还有其他在用户帐户中可找到的印象笔记的数据的。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">noteStore = client.get_note_store()</span><br><span class="line">notebooks = noteStore.listNotebooks()</span><br><span class="line"><span class="comment"># 输出笔记本的名称</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> notebooks:</span><br><span class="line">    <span class="keyword">print</span> (n.name)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出内容</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的第一个笔记本</span><br><span class="line">导入的笔记</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="Notebook-笔记本"><a href="#Notebook-笔记本" class="headerlink" title="Notebook-笔记本"></a>Notebook-笔记本</h4><ul><li>通过NoteStore类的<code>listNotebooks</code>方法可以获取一个<strong>包含所有笔记本的列表</strong></li><li><strong>在客户端视图中存在笔记本的嵌套，但实际上数据存储中所有笔记本都在同一层</strong></li><li>其下的笔记<strong>并不能通过该类的某个属性或者方法获取</strong></li><li>不管笔记本为空还是有笔记，属性都会有值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> notebook <span class="keyword">in</span> noteStore.listNotebooks():</span><br><span class="line"><span class="comment"># 得到笔记本的名字</span></span><br><span class="line">    notebookName = notebook.name</span><br><span class="line">    <span class="comment"># 得到笔记本的guid</span></span><br><span class="line">    notebookGuid = notebook.guid</span><br><span class="line">    print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(notebookName, notebookGuid))</span><br></pre></td></tr></table></figure><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我的第一个笔记本: dd36443d<span class="number">-2</span>ef1<span class="number">-4289</span>-aeb6<span class="number">-527e57</span>ce173b</span><br><span class="line">导入的笔记: <span class="number">5</span>c1dd2ec<span class="number">-8e0</span>a<span class="number">-4</span>a6e-b5f0<span class="number">-22507</span>c178086</span><br><span class="line">笔记本<span class="number">2</span>: <span class="number">3</span>f683ab0<span class="number">-4</span>ea7<span class="number">-4</span>ffb<span class="number">-800</span>d<span class="number">-4</span>c0864413c4b</span><br><span class="line">笔记本<span class="number">1</span>: <span class="number">61</span>bb02cd<span class="number">-1</span>fc2<span class="number">-404e-9</span>bc6<span class="number">-2</span>c20555dedec</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="enml-to-markdown"><a href="#enml-to-markdown" class="headerlink" title="enml to markdown"></a>enml to markdown</h4><ul><li><a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="noopener">enml格式讲解</a></li><li>不合算，放弃</li></ul><hr><h4 id="爬取动态页面"><a href="#爬取动态页面" class="headerlink" title="爬取动态页面"></a>爬取动态页面</h4><p>使用selenium模拟登陆</p><p><strong>遇到的问题</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\selenium\webdriver\common\service.py"</span>, line <span class="number">76</span>, <span class="keyword">in</span> start</span><br><span class="line">    stdin=PIPE)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">769</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    restore_signals, start_new_session)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">1172</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">    startupinfo)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。</span><br></pre></td></tr></table></figure><p></p><p>这是因为没有将浏览器驱动以及没有将浏览器驱动添加到环境变量：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 驱动下载地址</span></span><br><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载对应的chrome版本之后将压缩包解压，我下载的是chromedriver_win32.zip</span></span><br><span class="line"><span class="comment"># 发现32位的也能用，关键是只提供了32位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压上述包，然后将exe文件写入环境变量，可将exe文件放在C:\Program Files (x86)\Google\Chrome\Application目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量(可能需要重启电脑才会生效)之后直接输入</span></span><br><span class="line">chromedriver.exe</span><br><span class="line">Starting ChromeDriver <span class="number">72.0</span><span class="number">.3626</span><span class="number">.69</span> (<span class="number">3</span>c16f8a135abc0d4da2dff33804db79b849a7c38) on port <span class="number">9515</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver <span class="keyword">and</span> related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="博客园、CSDN、简书博客-1"><a href="#博客园、CSDN、简书博客-1" class="headerlink" title="博客园、CSDN、简书博客"></a>博客园、CSDN、简书博客</h3><ul><li>博客园：<code>python blog_parse.py -u https://www.cnblogs.com/zhaof/p/6953241.html -p C:/Users/14910/Desktop</code></li><li>CSDN：<code>python blog_parse.py -b csdn -u https://blog.csdn.net/work_you_will_see/article/details/84638750 -p C:/Users/14910/Desktop</code></li><li>简书博客：<code>python blog_parse.py -b jianshu -u https://www.jianshu.com/p/95331e7a98cd -p C:/Users/14910/Desktop</code></li></ul><hr><h3 id="自建博客"><a href="#自建博客" class="headerlink" title="自建博客"></a>自建博客</h3><ul><li><p>得到title的xpath：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/得到title的xpath.png" alt="得到title的xpath.png"></p></li><li><p>得到content的xpath：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/得到content的xpath.png" alt="得到content的xpath.png"></p></li><li><p>使用命令：<code>python blog_parse.py -b others -c //*[@id=\&quot;posts\&quot;]/article/div/div[1] -t //*[@id=\&quot;posts\&quot;]/article/div/header/h1 -u http://showteeth.tech/posts/56982.html -p C:/Users/14910/Desktop</code></p></li></ul><hr><h3 id="印象笔记-1"><a href="#印象笔记-1" class="headerlink" title="印象笔记"></a>印象笔记</h3><ul><li>将笔记<a href="https://help.evernote.com/hc/sr-me/articles/213420097-%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E7%AC%94%E8%AE%B0-" target="_blank" rel="noopener">导出单个html文件</a></li><li>将图片上传到图床，如果上传到图床的某个文件夹，需要指定下面的<code>-f</code>参数</li><li>使用命令：<code>python blog_parse.py -l &quot;C:/Users/14910/Desktop/VS code配置.html&quot; -f VS_code配置 -b evernote</code></li></ul><hr><p><br></p><h2 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h2><ul><li style="list-style:none"><input type="checkbox" checked> 启动这个项目 2019-3-21</li><li style="list-style:none"><input type="checkbox" checked> 印象笔记转载-API<ul><li style="list-style:none"><input type="checkbox" checked> 爬虫的方法，enml-这个就相当于使用印象笔记转markdown的那些工具，<mark>效果不好</mark></li><li style="list-style:none"><input type="checkbox" checked> 爬虫，模拟登陆— failed</li><li style="list-style:none"><input type="checkbox" checked> 既然能够模拟登陆了，那就不用在使用分享链接了啊，直接在网页版的印象笔记操作即可—&gt; <code>failed</code></li></ul></li><li style="list-style:none"><input type="checkbox" checked> 博客园</li><li style="list-style:none"><input type="checkbox" checked> CSDN</li><li style="list-style:none"><input type="checkbox" checked> 其他自建博客</li><li style="list-style:none"><input type="checkbox" checked> 爬取文章标题作为新建的markdown文件的标题</li><li style="list-style:none"><input type="checkbox" checked> 提供多种方法，加上另一个html转markdown的工具—&gt;<code>do not have the need</code></li><li style="list-style:none"><input type="checkbox" checked> 图片链接会自动换行，导致图片显示不出来 <code>fixed with set body_width = 0</code></li><li><p>[ ] 图片保留html形式，设置images_as_html=True，但没有起作用</p></li><li><p>[x] 印象笔记导出之前需要将其图片名称进行修改—&gt;两图片的空格替换为<code>%20</code></p></li><li style="list-style:none"><input type="checkbox" checked> 参数分组</li><li style="list-style:none"><input type="checkbox"> 爬取整个博客然后转化为markdown(不是很实用)</li><li style="list-style:none"><input type="checkbox"> 增加配置文件</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/littlecodersh/EasierLife" target="_blank" rel="noopener">EasierLife</a></li><li><a href="https://github.com/muzizongheng/Python/blob/master/Utility/Evernote2Blog/Main.py" target="_blank" rel="noopener">Evernote2Blog</a></li><li><a href="https://www.jianshu.com/p/bda26798f3b3" target="_blank" rel="noopener">使用Python操作Evernote API</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这个项目主要是基于在转载博客时直接复制HTML后期不好修改，不能像Markdown一样生成大纲，不易管理，所以这里想做这样一个项目，&lt;a href=&quot;https://github.com/showteeth/blog_reprint&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="项目实战" scheme="http://showteeth.tech/categories/Python/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="实战" scheme="http://showteeth.tech/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
</feed>
