<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-09-22T15:07:24.239Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>YAML语言学习</title>
    <link href="http://showteeth.tech/posts/64657.html"/>
    <id>http://showteeth.tech/posts/64657.html</id>
    <published>2019-09-20T15:09:44.000Z</published>
    <updated>2019-09-22T15:07:24.239Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文依据<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a>结合<strong>python中对yaml的调用</strong>对<code>yaml</code>语言进行了学习，主要包括其<strong>语法</strong>和<strong>数据结构</strong>，为以后<strong>使用<code>yaml</code>编写配置文件</strong>打下基础。</p></div><a id="more"></a><h2 id="yaml简介"><a href="#yaml简介" class="headerlink" title="yaml简介"></a>yaml简介</h2><p>编程免不了要<strong>写配置文件</strong>，怎么写配置也是一门学问。<code>YAML</code> 是<strong>专门用来写配置文件的语言，非常简洁和强大</strong>，远比 <code>JSON</code> 格式方便。</p><p><code>YAML</code> 语言（发音 <code>/ˈjæməl/</code> ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p><p><code>YAML</code>的基本语法和规则如下：</p><ul><li><strong>大小写敏感</strong></li><li>使用<strong>缩进表示层级关系</strong></li><li><mark>缩进时不允许使用Tab键，只允许使用空格</mark></li><li>缩进的<strong>空格数目不重要</strong>，只要<strong>相同层级的元素左侧对齐即可</strong></li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p><code>YAML</code>支持的数据结构：</p><ul><li><code>对象</code>：<strong>键值对的集合</strong>，又称为<code>映射（mapping）</code>/ <code>哈希（hashes）</code> / <code>字典（dictionary）</code></li><li><code>数组</code>：一组按次序排列的值，又称为<code>序列（sequence）</code> / <code>列表（list）</code></li><li><code>纯量（scalars）</code>：单个的、不可再分的值</li></ul><p>以下分别介绍这三种数据结构。</p><hr><p><br></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="单层字典"><a href="#单层字典" class="headerlink" title="单层字典"></a>单层字典</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure><p>使用python进行解析：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.yaml'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = yaml.load(f)</span><br><span class="line"><span class="keyword">print</span> (data)</span><br></pre></td></tr></table></figure><p></p><p>解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典的形式</span></span><br><span class="line">&#123;<span class="string">'animal'</span>: <span class="string">'pets'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="嵌套字典"><a href="#嵌套字典" class="headerlink" title="嵌套字典"></a>嵌套字典</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">Steve</span></span><br><span class="line"><span class="attr">  foo:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套的字典</span></span><br><span class="line">&#123;<span class="string">'hash'</span>: &#123;<span class="string">'name'</span>: <span class="string">'Steve'</span>, <span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p></p><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">Steve,</span> <span class="attr">foo:</span> <span class="string">bar</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'hash'</span>: &#123;<span class="string">'name'</span>: <span class="string">'Steve'</span>, <span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>一组短横线开头的行，构成一个列表。</p><h3 id="单层列表"><a href="#单层列表" class="headerlink" title="单层列表"></a>单层列表</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析之后得到列表</span></span><br><span class="line">[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>短横线开头(不需要加任何标识)，然后空格缩进之后再添加短横线就可以得到嵌套列表：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Goldfish</span></span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p></p><p>python解析：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析得到嵌套列表</span></span><br><span class="line">[[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>], [<span class="string">'test'</span>]]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字典-列表"><a href="#字典-列表" class="headerlink" title="字典+列表"></a>字典+列表</h3><p>可以将字典和列表进行组合，达到以列表作为键值的字典的目的：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">[</span> <span class="string">'Cat'</span><span class="string">,</span> <span class="string">'Dog'</span> <span class="string">]</span> </span><br><span class="line"><span class="attr">fruit:</span> <span class="string">'apple'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析得到以列表作为键值的字典</span></span><br><span class="line">&#123;<span class="string">'animal'</span>: [<span class="string">'Cat'</span>, <span class="string">'Dog'</span>], <span class="string">'fruit'</span>: <span class="string">'apple'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line"><span class="attr"> Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span> </span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure><p>python解析的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'languages'</span>: [<span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span>], </span><br><span class="line">  <span class="string">'websites'</span>: &#123;<span class="string">'YAML'</span>: <span class="string">'yaml.org'</span>, <span class="string">'Ruby'</span>: <span class="string">'ruby-lang.org'</span>, <span class="string">'Python'</span>: <span class="string">'python.org'</span>, <span class="string">'Perl'</span>: <span class="string">'use.perl.org'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于python的纯量：</p><ul><li><strong>字符串</strong>：使用引号或者双引号</li><li><strong>布尔值</strong>：<code>true</code>、<code>false</code></li><li><strong>整数</strong></li><li><strong>浮点数</strong></li><li><strong>Null</strong>：使用<code>~</code>表示</li><li><strong>时间</strong></li><li><strong>日期</strong></li><li><strong>强制类型转换</strong>：使用<code>!!</code>加上需要转换的类型进行强制类型转换</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">b:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">c:</span> <span class="string">~</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">1976</span><span class="bullet">-07</span><span class="bullet">-31</span></span><br><span class="line"><span class="attr">e:</span> <span class="type">!!str</span> <span class="number">123</span></span><br><span class="line"><span class="attr">f:</span> <span class="type">!!str</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">g:</span> <span class="string">"g"</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'a'</span>: 0, </span><br><span class="line">  <span class="string">'b'</span>: True, </span><br><span class="line">  <span class="string">'c'</span>: None, </span><br><span class="line">  <span class="string">'date'</span>: datetime.date(1976, 7, 31), </span><br><span class="line">  <span class="string">'e'</span>: <span class="string">'123'</span>, </span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'true'</span>, </span><br><span class="line">  <span class="string">'g'</span>: <span class="string">'g'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是最常见，也是最复杂的一种数据类型，不使用引号、使用单引号、使用双引号都可以表示字符串。</p><h3 id="不使用引号"><a href="#不使用引号" class="headerlink" title="不使用引号"></a>不使用引号</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">num:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动识别数据类型</span></span><br><span class="line"><span class="comment"># 字符串解析为字符串</span></span><br><span class="line"><span class="comment"># 数字解析为数字</span></span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="string">'string'</span>, <span class="string">'num'</span>: 10&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用单引号"><a href="#使用单引号" class="headerlink" title="使用单引号"></a>使用单引号</h3><p>如果字符串之中包含空格或特殊字符，需要放在引号之中:<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="attr">a:b</span></span><br><span class="line"><span class="attr">s2:</span> <span class="string">'a:b'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然解析结果没有差异，但是添加引号更保险一些</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a:b'</span>, <span class="string">'s2'</span>: <span class="string">'a:b'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>使用单引号会对字符中的特殊符号进行转义</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号</span></span><br><span class="line"><span class="attr">s1:</span> <span class="string">'a\nb'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对字符中的\n进行了转义</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a\\nb'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用双引号"><a href="#使用双引号" class="headerlink" title="使用双引号"></a>使用双引号</h3><p>双引号和单引号的作用相同，但是与单引号相比，双引号不会对字符串中的特殊字符进行转义：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="string">'a\nb'</span></span><br><span class="line"><span class="attr">s2:</span> <span class="string">"a\nb"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号会对特殊字符进行转义</span></span><br><span class="line"><span class="comment"># 双引号会对特殊字符进行转义</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a\\nb'</span>, <span class="string">'s2'</span>: <span class="string">'a\nb'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="引号嵌套"><a href="#引号嵌套" class="headerlink" title="引号嵌套"></a>引号嵌套</h3><p>单引号中嵌套单引号，必须连续使用两个单引号转义：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号连用进行转义</span></span><br><span class="line"><span class="attr">str1:</span> <span class="string">'labor'</span><span class="string">'s day'</span></span><br><span class="line"><span class="comment"># 直接使用双引号包含单引号</span></span><br><span class="line"><span class="attr">str2:</span> <span class="string">"labor's day"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号转义和使用双引号包围解析的结果是相同的</span></span><br><span class="line">&#123;<span class="string">'str1'</span>: <span class="string">"labor's day"</span>, <span class="string">'str2'</span>: <span class="string">"labor's day"</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串换行"><a href="#字符串换行" class="headerlink" title="字符串换行"></a>字符串换行</h3><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进，<strong>换行符(<code>\n</code>)会被转为空格</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">longsting:</span> <span class="string">"this is long</span></span><br><span class="line"><span class="string"> string"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># long和string之间会出现一个换行符</span></span><br><span class="line">&#123;<span class="string">'longsting'</span>: <span class="string">'this is long string'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="保留和折叠换行符"><a href="#保留和折叠换行符" class="headerlink" title="保留和折叠换行符"></a>保留和折叠换行符</h3><p>多行字符串可以<strong>使用<code>|</code>保留换行符(<code>\n</code>)</strong>，也可以<strong>使用<code>&gt;</code>折叠换行符</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br><span class="line"><span class="string"># 折叠换行符</span></span><br><span class="line"><span class="string"></span><span class="attr">that:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留换行符和折叠换行符</span></span><br><span class="line">&#123;<span class="string">'this'</span>: <span class="string">'Foo\nBar\n'</span>, <span class="string">'that'</span>: <span class="string">'Foo Bar'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果遇到重复内容需要多次书写，可以使用引用的方式，具体做法是借助锚点&amp;和别名*:<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp;用来建立锚点（defaults）</span></span><br><span class="line"><span class="comment"># &lt;&lt;表示合并到当前数据</span></span><br><span class="line"><span class="comment"># *用来引用锚点</span></span><br><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'defaults'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>&#125;, </span><br><span class="line">  <span class="string">'development'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'database'</span>: <span class="string">'myapp_development'</span>&#125;, </span><br><span class="line">  <span class="string">'test'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'database'</span>: <span class="string">'myapp_test'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>列表中的示例</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="meta">&amp;showell</span> <span class="string">Steve</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Clark</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Brian</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Oren</span> </span><br><span class="line"><span class="bullet">-</span> <span class="meta">*showell</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span>]</span><br></pre></td></tr></table></figure><p></p><p>引用实现过程：</p><ul><li>先使用<code>&amp;</code>用来建立锚点，<code>&amp;+锚点名称</code></li><li>使用<code>*+锚点名称</code>用来引用锚点</li><li><code>&lt;&lt;</code>表示合并到当前数据</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文依据&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/07/yaml.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YAML 语言教程&lt;/a&gt;结合&lt;strong&gt;python中对yaml的调用&lt;/strong&gt;对&lt;code&gt;yaml&lt;/code&gt;语言进行了学习，主要包括其&lt;strong&gt;语法&lt;/strong&gt;和&lt;strong&gt;数据结构&lt;/strong&gt;，为以后&lt;strong&gt;使用&lt;code&gt;yaml&lt;/code&gt;编写配置文件&lt;/strong&gt;打下基础。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="YAML" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/YAML/"/>
    
    
      <category term="YAML" scheme="http://showteeth.tech/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之文件的MD5校验</title>
    <link href="http://showteeth.tech/posts/60644.html"/>
    <id>http://showteeth.tech/posts/60644.html</id>
    <published>2019-09-06T13:28:43.000Z</published>
    <updated>2019-09-06T15:48:45.497Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中对文件完整性进行验证的命令<code>md5sum</code>，该命令可以<strong>对指定的文件生成MD5值</strong>，也可以<strong>根据已有的MD5值对文件进行完整性校验</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在学习和研究过程中，经常会从公司拿到很多数据，连同数据一起的还有md5文件；在数据传输和下载过程中，难免会遇到数据缺失的情况，所以得到数据后对数据进行校验非常重要。</p><h2 id="md5sum命令"><a href="#md5sum命令" class="headerlink" title="md5sum命令"></a>md5sum命令</h2><p><code>md5sum</code>命令用于<strong>生成文件的md5数字摘要</strong>，并<strong>可以验证文件内容是否发生了改变</strong>，间接地还可以检验两个文件内容是否完全相同。因为<code>md5sum</code>是读取文件内容来计算校验码的，因此<strong>只能验证文件内容，而无法验证文件属性</strong>，所以只要文件内容没有发生变化，<code>md5sum</code>命令都会将其判定为相同的文件。</p><h3 id="生成md5值"><a href="#生成md5值" class="headerlink" title="生成md5值"></a>生成md5值</h3><p>需要注意的是，如果<code>md5sum</code>命令后的文件使用的是<strong>相对路径</strong>，那么生成的<strong>md5值中的文件信息就是相对路径</strong>，而如果文件使用的是<strong>绝对路径</strong>，<strong>生成的md5值中的文件信息就是绝对路径</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum后的文件路径是相对路径</span></span><br><span class="line">md5sum test.sh</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  test.sh</span><br><span class="line"><span class="comment"># md5sum后的文件路径是绝对路径</span></span><br><span class="line">md5sum /home/user/learn/linux_learn/variable/test.sh</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  /home/user/learn/linux_learn/variable/test.sh</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看文件是否修改"><a href="#查看文件是否修改" class="headerlink" title="查看文件是否修改"></a>查看文件是否修改</h3><p>可以<strong>使用<code>md5sum -c</code>结合md5信息文件来判断文件是否完整</strong>，注意：<strong>这个检查是内容上的，权限和属性等的改变不会影响md5值，所以不会检测出问题</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c test.md5</span><br><span class="line">  test.sh: OK</span><br></pre></td></tr></table></figure><p></p><p><strong>md5文件中存储的文件路径必须要是正确</strong>的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 储存的md5值以及文件相对路径</span></span><br><span class="line">cat test.md5</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件相对路径发生变化，或者名称被修改</span></span><br><span class="line">mv test.sh test_old.sh</span><br><span class="line"></span><br><span class="line">md5sum -c test.md5</span><br><span class="line">  md5sum: test.sh: No such file or directory</span><br><span class="line">  test.sh: FAILED open or <span class="built_in">read</span></span><br><span class="line">  md5sum: WARNING: 1 listed file could not be <span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件内容被修改</span></span><br><span class="line">md5sum -c test.md5</span><br><span class="line">  test.sh: FAILED</span><br><span class="line">  md5sum: WARNING: 1 computed checksum did NOT match</span><br></pre></td></tr></table></figure><p></p><p>当使用了<code>-c</code>选项时，还支持以下选项：</p><ul><li><code>--quiet</code>：<strong>不显示验证结果为OK的记录</strong>；</li><li><code>--status</code>：<strong>完全不显示任何信息</strong>，只能通过命令的退出状态码判断验证结果是否有failed；<strong>只要有一条failed记录，则状态码为1，否则为0。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5sum --status -c test.md5</span><br><span class="line"><span class="comment"># 使用$?来获取最后运行的命令的结束代码</span></span><br><span class="line"><span class="comment"># 正常运行的命令结束代码为0，出错或者出现异常结束代码不为0</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7430264.html" target="_blank" rel="noopener">Linux中文件MD5校验</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中对文件完整性进行验证的命令&lt;code&gt;md5sum&lt;/code&gt;，该命令可以&lt;strong&gt;对指定的文件生成MD5值&lt;/strong&gt;，也可以&lt;strong&gt;根据已有的MD5值对文件进行完整性校验&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之Shell子进程以及何时进入子Shell</title>
    <link href="http://showteeth.tech/posts/36597.html"/>
    <id>http://showteeth.tech/posts/36597.html</id>
    <published>2019-09-06T07:56:49.000Z</published>
    <updated>2019-09-06T13:23:52.277Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章基于<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">子shell以及什么时候进入子shell</a>进行了学习和整理，学习了<strong>Shell的子进程</strong>以及列举了几种<strong>不产生</strong>和<strong>产生Shell子进程</strong>的场景。同时，这篇文章也是对<a href="http://showteeth.tech/posts/16586.html">关于Linux中脚本执行方式</a>以及<a href="http://showteeth.tech/posts/52906.html">全局变量、局部变量和环境变量</a>两篇文章的内容的补充和参考。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前学习的<a href="http://showteeth.tech/posts/16586.html">关于Linux中脚本执行方式</a>以及<a href="http://showteeth.tech/posts/52906.html">全局变量、局部变量和环境变量</a>中都有提到Shell进程以及如何进入Shell子进程，但是了解不够全面，恰巧读到<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">这篇文章</a>，发现讲解非常详细，所以这里主要是基于<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">这篇文章</a>的学习笔记，大部分都是与原封不动copy下来的。</p><hr><h2 id="子Shell简介"><a href="#子Shell简介" class="headerlink" title="子Shell简介"></a>子Shell简介</h2><p>子shell的概念贯穿整个shell，写shell脚本时更是不可不知。所谓<strong>子shell</strong>，即<strong>从当前shell环境新开一个shell环境</strong>，这个新开的shell环境就称为子shell(subshell)，而<strong>开启子shell的环境称为该子shell的父shell</strong>。子shell和父shell的关系其实就是子进程和父进程的关系，只不过子shell和父shell所关联的进程是bash进程。</p><p>子shell会从父shell中<strong>继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等</strong>，但<strong>子shell有很多种类型，不同类型的子shell继承的环境不相同</strong>。可以使用<code>$BASH_SUBSHELL</code>变量来<strong>查看从当前进程开始的子shell层数</strong>，<code>$BASHPID</code>查看<strong>当前所处BASH的PID</strong>，<mark>这不同于特殊变量<code>$$</code>值，因为<code>$$</code>在大多数情况下都会从父shell中继承</mark>。</p><hr><h2 id="何时产生子Shell"><a href="#何时产生子Shell" class="headerlink" title="何时产生子Shell"></a>何时产生子Shell</h2><p>要解释清楚子shell以及产生何种类型的子shell，需要搞清楚Linux中如何产生子进程。Linux上<strong>创建子进程的方式有三种</strong>：</p><ul><li>一种是<code>fork</code>出来的进程。它会复制当前进程的副本(不考虑写时复制的模式)，以适当的方式将这些资源交给子进程；所以<strong>子进程掌握的资源和父进程是一样的，包括内存中的内容，所以也包括环境变量和变量</strong>；但父子进程是完全独立的，它们是一个程序的两个实例。</li><li>一种是<code>exec</code>出来的进程。<code>exec</code>是加载另一个应用程序，替代当前运行的进程，也就是说在不创建新进程的情况下加载一个新程序；<code>exec</code>还有一个动作：在进程执行完毕后，退出<code>exec</code>所在的shell环境。</li><li>一种是<code>clone</code>出来的进程。此处无需关心<code>clone</code>，因为它用来实现Linux中的线程。</li></ul><p>所以为了保证进程安全，若要形成新的且独立的子进程，都会先<code>fork</code>一份当前进程，然后在<code>fork</code>出来的子进程上调用<code>exec</code>来加载新程序替代该子进程。例如<strong>在bash下执行cp命令，会先fork出一个bash，然后再exec加载cp程序覆盖子bash进程变成cp进程。</strong></p><p>再来说明子shell的问题。一般<code>fork</code>出来的子进程，内容和父进程是一样的(包括变量)，例如执行<code>cp</code>命令时也能获取到父进程的变量；但是<code>cp</code>命令在哪里执行呢？执行<code>cp</code>命令敲入回车后，当前的bash进程<code>fork</code>出一个<strong>子bash</strong>，然后<strong>子bash</strong>通过<code>exec</code>加载<code>cp</code>程序<strong>替代子bash</strong>。这算是进入了<strong>子shell</strong>吗？更通用的问题是：<strong>什么情况下会进入子shell环境，什么时候不进入子shel环境呢？</strong></p><p>判断是否进入了子shell的方式非常简单，执行<code>echo $BASHPID</code>，如果该值和父bash进程的pid值不同，则表示进入了子shell。</p><h3 id="不产生子Shell"><a href="#不产生子Shell" class="headerlink" title="不产生子Shell"></a>不产生子Shell</h3><h4 id="执行bash内置命令"><a href="#执行bash内置命令" class="headerlink" title="执行bash内置命令"></a>执行bash内置命令</h4><p>bash内置命令是非常特殊的，<strong>父进程不会创建子进程来执行这些命令</strong>，而是直接<strong>在当前bash环境中执行</strong>。但如果<strong>将内置命令放在管道后，就会创建子shell</strong>。关于Linux中的内置命令，可以查看<a href="#%e8%a1%a5%e5%85%85-linux%e5%86%85%e7%bd%ae%e5%91%bd%e4%bb%a4">这部分</a>。</p><p>内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span>   </span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># let命令为bash内置命令，不进入子shell</span></span><br><span class="line"><span class="built_in">let</span> a=<span class="variable">$BASHPID</span>   </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">  65230</span><br></pre></td></tr></table></figure><p></p><p>管道结合内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 增加管道后看看ID</span></span><br><span class="line"><span class="comment"># 发现这里虽然使用了内置命令，但是依然创建了子Shell</span></span><br><span class="line">ls |<span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  28580</span><br></pre></td></tr></table></figure><p></p><p>这时候的<strong>子shell的作用</strong>是为bash内置命令提供执行环境。</p><hr><h4 id="执行shell函数"><a href="#执行shell函数" class="headerlink" title="执行shell函数"></a>执行shell函数</h4><p>其实shell函数就是命令，它和bash内置命令的情况一样，直接执行时不会进入子shell，但放在管道后会进入子shell：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数，输出ID</span></span><br><span class="line"><span class="function"><span class="title">fun_test</span></span> ()&#123; <span class="built_in">echo</span> <span class="variable">$BASHPID</span>; &#125;</span><br><span class="line"><span class="comment"># 输出当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 执行函数，输出Shell的ID</span></span><br><span class="line">fun_test </span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 加入管道</span></span><br><span class="line">ls |fun_test </span><br><span class="line">  30637</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="产生子Shell"><a href="#产生子Shell" class="headerlink" title="产生子Shell"></a>产生子Shell</h3><h4 id="执行bash命令本身"><a href="#执行bash命令本身" class="headerlink" title="执行bash命令本身"></a>执行bash命令本身</h4><p>显然它<strong>会进入子shell环境</strong>，它的<strong>绝大多数环境都是新配置的</strong>，因为<strong>会加载一些环境配置文件</strong>。<mark>事实上<code>fork</code>出来的bash子进程内容完全继承父shell，但因<strong>重新加载了环境配置项</strong>，所以<strong>子shell没有继承普通变量</strong>，更准确的说是<strong>覆盖</strong>了从父shell中继承的变量</mark>。不妨试试在<code>/etc/bashrc</code>文件中定义一个变量，再在父shell中<code>export</code>名称相同值却不同的环境变量，然后到子shell中看看该变量的值为何？<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"var=55"</span> &gt;&gt;/etc/bashrc</span><br><span class="line"><span class="built_in">export</span> var=66</span><br><span class="line"><span class="comment"># 进入子Shell</span></span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">  55</span><br></pre></td></tr></table></figure><p></p><p>由结果55可知，执行bash时加载的<code>/etc/bashrc</code>中的变量<strong>覆盖</strong>了父bash中的导出的环境变量值66。</p><p>使用<code>exit</code>命令退出当前子Shell：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 执行bash命令</span></span><br><span class="line">bash</span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  29075</span><br><span class="line"><span class="comment"># 使用exit退出当前子Shell</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>变量<code>$$</code>不会被继承：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 使用bash进入子Shell</span></span><br><span class="line">bash</span><br><span class="line"><span class="comment"># 查看bash进入的子Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  32310</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="执行Shell脚本"><a href="#执行Shell脚本" class="headerlink" title="执行Shell脚本"></a>执行Shell脚本</h4><p>这里的执行Shell脚本是<a href="http://showteeth.tech/posts/16586.html">这篇文章</a>中<strong>作为可执行程序</strong>、<strong>作为解释器参数</strong>进行的执行，而不是<strong>source方式执行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  29479</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> </span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>可以发现：执行shell脚本相比于直接执行bash命令，还多了一个动作——<strong>脚本执行完毕后自动退出子shell</strong>。</p><p>变量<code>$$</code>不会被继承：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line">cat test_run.sh</span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  32477</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="执行非bash内置命令"><a href="#执行非bash内置命令" class="headerlink" title="执行非bash内置命令"></a>执行非bash内置命令</h4><p>例如执行<code>cp</code>命令、<code>grep</code>命令等，它们直接<code>fork</code>一份bash进程，然后使用<code>exec</code>加载程序替代该子bash。此类子进程<strong>会继承所有父bash的环境</strong>。但<strong>严格地说，这已经不是子shell</strong>，因为<code>exec</code>加载的程序已经把子bash进程替换掉了，这意味着丢失了很多bash环境。在bash文档中，直接<strong>称呼这种环境为”单独的环境”，和子shell的概念类似。</strong></p><hr><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p><strong>当命令行中包含了命令替换部分时，将开启一个子shell先执行这部分内容，再将执行结果返回给当前命令</strong>。因为这次的子shell<strong>不是通过bash命令</strong>进入的子shell，所以它<strong>会继承父shell的所有变量内容</strong>。这也就解释了<code>echo $(echo $$)</code>中<code>$$</code>的结果是当前bash(父Shell)的pid号，而不是子shell的pid号，但<code>echo $(echo $BASHPID)</code>却和父bash进程的pid不同，因为它不是使用bash命令进入的子shell:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$$查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$BASHPID查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令替换，使用$BASHPID查看命令替换得到的子Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  31157</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令替换，使用$$测试命令替换是不是继承了父Shell的$$变量</span></span><br><span class="line"><span class="comment"># 发现使用命令替换会继承父Shell的$$变量</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过bash命令进入子Shell</span></span><br><span class="line"><span class="comment"># 发现并没有继承父Shell的$$变量</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  31232</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="使用括号-组合一系列命令"><a href="#使用括号-组合一系列命令" class="headerlink" title="使用括号()组合一系列命令"></a>使用括号()组合一系列命令</h4><p>例如<code>(ls;date;echo haha)</code>，独立的括号将会<strong>开启一个子shell来执行括号内的命令</strong>，这种情况等同于上述<a href="#%e6%89%a7%e8%a1%8c%e9%9d%9ebash%e5%86%85%e7%bd%ae%e5%91%bd%e4%bb%a4%e6%97%b6">执行非bash内置命令</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看括号组合的命令的Shell ID </span></span><br><span class="line">(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  31804</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line">(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="放入后台的任务"><a href="#放入后台的任务" class="headerlink" title="放入后台的任务"></a>放入后台的任务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 查看放入后台命令运行的Shell ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> &amp;</span><br><span class="line">  [1] 32030</span><br><span class="line">  32030</span><br></pre></td></tr></table></figure><p>变量<code>$$</code>会被继承:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line"><span class="built_in">echo</span> $$ &amp;</span><br><span class="line">  [1] 316</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>既然是新进程了，当然进入子shell执行，例如<code>cat &lt;(echo haha)</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 进程替换，进入子Shell</span></span><br><span class="line">cat &lt;(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  32181</span><br></pre></td></tr></table></figure><p></p><p>变量<code>$$</code>会被继承:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line">cat &lt;(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>关于<code>$$</code>变量的继承：除了<strong>直接执行bash命令</strong>和<strong>shell脚本这两种子shell</strong>，<strong>其他进入子shell的情况都会继承父shell的值</strong>。前面也已经说了，其实shell脚本和直接执行bash命令开启子shell的方式是一样的，它们<strong>都不会继承<code>$$</code>值</strong>，上面对应的部分已经做过了验证。</li><li>子shell的环境设置不会粘滞到父shell环境，无论是使用<code>export</code>还是<code>source</code>，环境设置都只能从父shell到子shell，不是也不会是从子shell到父shell。也就是说<strong>子shell的变量等不会影响父shell</strong>。</li></ul><hr><p><br></p><h2 id="补充-Linux内置命令"><a href="#补充-Linux内置命令" class="headerlink" title="补充-Linux内置命令"></a>补充-Linux内置命令</h2><p>通常来说，<strong>内置命令会比外部命令执行得更快</strong>，执行外部命令时不但会<strong>触发磁盘 I/O</strong>，还需要 <code>fork</code> 出一个单独的进程来执行，执行完成后再退出。而<strong>执行内建命令相当于调用当前 Shell 进程的一个函数。</strong></p><h3 id="判断命令是不是内置命令"><a href="#判断命令是不是内置命令" class="headerlink" title="判断命令是不是内置命令"></a>判断命令是不是内置命令</h3><p>type命令可以判断命令是不是内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd命令是内置命令</span></span><br><span class="line"><span class="comment"># 返回为builtin</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span></span><br><span class="line">  <span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp不是内置命令</span></span><br><span class="line"><span class="comment"># cp不是内置命令，其路径为/usr/bin/cp</span></span><br><span class="line"><span class="built_in">type</span> cp</span><br><span class="line">  cp is /usr/bin/cp</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看内置命令帮助"><a href="#查看内置命令帮助" class="headerlink" title="查看内置命令帮助"></a>查看内置命令帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> | less</span><br><span class="line">  GNU bash, version 4.2.46(2)-release (x86_64-redhat-linux-gnu)</span><br><span class="line">  These shell commands are defined internally.  Type `<span class="built_in">help</span><span class="string">' to see this list.</span></span><br><span class="line"><span class="string">  Type `help name'</span> to find out more about the <span class="keyword">function</span> `name<span class="string">'.</span></span><br><span class="line"><span class="string">  Use `info bash'</span> to find out more about the shell <span class="keyword">in</span> general.</span><br><span class="line">  Use `man -k<span class="string">' or `info'</span> to find out more about commands not <span class="keyword">in</span> this list.</span><br><span class="line"></span><br><span class="line">  A star (*) next to a name means that the <span class="built_in">command</span> is disabled.</span><br><span class="line"></span><br><span class="line">  job_spec [&amp;]                                                 <span class="built_in">history</span> [-c] [-d offset] [n] or <span class="built_in">history</span> -anrw [filename] &gt;</span><br><span class="line">  (( expression ))                                             <span class="keyword">if</span> COMMANDS; <span class="keyword">then</span> COMMANDS; [ <span class="keyword">elif</span> COMMANDS; <span class="keyword">then</span> COMMAND&gt;</span><br><span class="line">  . filename [arguments]                                       <span class="built_in">jobs</span> [-lnprs] [jobspec ...] or <span class="built_in">jobs</span> -x <span class="built_in">command</span> [args]</span><br><span class="line">  :                                                            <span class="built_in">kill</span> [-s sigspec | -n signum | -sigspec] pid | jobspec ..&gt;</span><br><span class="line">  [ arg... ]                                                   <span class="built_in">let</span> arg [arg ...]</span><br></pre></td></tr></table></figure><hr><h3 id="内置命令列表"><a href="#内置命令列表" class="headerlink" title="内置命令列表"></a>内置命令列表</h3><table><caption>Bash Shell 内建命令</caption><tbody><tr><th width="10%">命令</th><th width="90%">说明</th></tr><tr><td>:</td><td>扩展参数列表，执行重定向操作</td></tr><tr><td>.</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>alias</td><td>为指定命令定义一个别名</td></tr><tr><td>bg</td><td>将作业以后台模式运行</td></tr><tr><td>bind</td><td>将键盘序列绑定到一个 readline 函数或宏</td></tr><tr><td>break</td><td>退出 for、while、select 或 until 循环</td></tr><tr><td>builtin</td><td>执行指定的 shell 内建命令</td></tr><tr><td>caller</td><td>返回活动子函数调用的上下文</td></tr><tr><td>cd</td><td>将当前目录切换为指定的目录</td></tr><tr><td>command</td><td>执行指定的命令，无需进行通常的 shell 查找</td></tr><tr><td>compgen</td><td>为指定单词生成可能的补全匹配</td></tr><tr><td>complete</td><td>显示指定的单词是如何补全的</td></tr><tr><td>compopt</td><td>修改指定单词的补全选项</td></tr><tr><td>continue</td><td>继续执行 for、while、select 或 until 循环的下一次迭代</td></tr><tr><td>declare</td><td>声明一个变量或变量类型。</td></tr><tr><td>dirs</td><td>显示当前存储目录的列表</td></tr><tr><td>disown</td><td>从进程作业表中刪除指定的作业</td></tr><tr><td>echo</td><td>将指定字符串输出到 STDOUT</td></tr><tr><td>enable</td><td>启用或禁用指定的内建shell命令</td></tr><tr><td>eval</td><td>将指定的参数拼接成一个命令，然后执行该命令</td></tr><tr><td>exec</td><td>用指定命令替换 shell 进程</td></tr><tr><td>exit</td><td>强制 shell 以指定的退出状态码退出</td></tr><tr><td>export</td><td>设置子 shell 进程可用的变量</td></tr><tr><td>fc</td><td>从历史记录中选择命令列表</td></tr><tr><td>fg</td><td>将作业以前台模式运行</td></tr><tr><td>getopts</td><td>分析指定的位置参数</td></tr><tr><td>hash</td><td>查找并记住指定命令的全路径名</td></tr><tr><td>help</td><td>显示帮助文件</td></tr><tr><td>history</td><td>显示命令历史记录</td></tr><tr><td>jobs</td><td>列出活动作业</td></tr><tr><td>kill</td><td>向指定的进程 ID(PID) 发送一个系统信号</td></tr><tr><td>let</td><td>计算一个数学表达式中的每个参数</td></tr><tr><td>local</td><td>在函数中创建一个作用域受限的变量</td></tr><tr><td>logout</td><td>退出登录 shell</td></tr><tr><td>mapfile</td><td>从 STDIN 读取数据行，并将其加入索引数组</td></tr><tr><td>popd</td><td>从目录栈中删除记录</td></tr><tr><td>printf</td><td>使用格式化字符串显示文本</td></tr><tr><td>pushd</td><td>向目录栈添加一个目录</td></tr><tr><td>pwd</td><td>显示当前工作目录的路径名</td></tr><tr><td>read</td><td>从 STDIN 读取一行数据并将其赋给一个变量</td></tr><tr><td>readarray</td><td>从 STDIN 读取数据行并将其放入索引数组</td></tr><tr><td>readonly</td><td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td></tr><tr><td>return</td><td>强制函数以某个值退出，这个值可以被调用脚本提取</td></tr><tr><td>set</td><td>设置并显示环境变量的值和 shell 属性</td></tr><tr><td>shift</td><td>将位置参数依次向下降一个位置</td></tr><tr><td>shopt</td><td>打开/关闭控制 shell 可选行为的变量值</td></tr><tr><td>source</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>suspend</td><td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td></tr><tr><td>test</td><td>基于指定条件返回退出状态码 0 或 1</td></tr><tr><td>times</td><td>显示累计的用户和系统时间</td></tr><tr><td>trap</td><td>如果收到了指定的系统信号，执行指定的命令</td></tr><tr><td>type</td><td>显示指定的单词如果作为命令将会如何被解释</td></tr><tr><td>typeset</td><td>声明一个变量或变量类型。</td></tr><tr><td>ulimit</td><td>为系统用户设置指定的资源的上限</td></tr><tr><td>umask</td><td>为新建的文件和目录设置默认权限</td></tr><tr><td>unalias</td><td>刪除指定的别名</td></tr><tr><td>unset</td><td>刪除指定的环境变量或 shell 属性</td></tr><tr><td>wait</td><td>等待指定的进程完成，并返回退出状态码</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">子shell以及什么时候进入子shell</a></li><li><a href="https://linux.cn/article-9343-1.html" target="_blank" rel="noopener">如何列出所有的 Bash Shell 内置命令</a></li><li><a href="http://c.biancheng.net/view/1136.html" target="_blank" rel="noopener">Shell内建命令（内置命令）</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章基于&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7446194.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子shell以及什么时候进入子shell&lt;/a&gt;进行了学习和整理，学习了&lt;strong&gt;Shell的子进程&lt;/strong&gt;以及列举了几种&lt;strong&gt;不产生&lt;/strong&gt;和&lt;strong&gt;产生Shell子进程&lt;/strong&gt;的场景。同时，这篇文章也是对&lt;a href=&quot;http://showteeth.tech/posts/16586.html&quot;&gt;关于Linux中脚本执行方式&lt;/a&gt;以及&lt;a href=&quot;http://showteeth.tech/posts/52906.html&quot;&gt;全局变量、局部变量和环境变量&lt;/a&gt;两篇文章的内容的补充和参考。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之文件目录操作</title>
    <link href="http://showteeth.tech/posts/49759.html"/>
    <id>http://showteeth.tech/posts/49759.html</id>
    <published>2019-09-05T13:26:13.000Z</published>
    <updated>2019-09-05T16:00:01.634Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>R中文件目录相关操作</strong>，主要包括：<code>查看和设置工作路径</code>、<code>查看文件或目录是否存在</code>、<code>列出目录下文件或目录</code>、<code>新建文件或目录</code>、<code>复制文件或目录</code>、<code>删除文件或目录</code>、<code>重命名文件或目录</code>。</p></div><a id="more"></a><h2 id="工作路径"><a href="#工作路径" class="headerlink" title="工作路径"></a>工作路径</h2><p>设置工作路径：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置工作路径为path/to/your/workdir</span></span><br><span class="line">setwd(<span class="string">'path/to/your/workdir'</span>)</span><br></pre></td></tr></table></figure><p></p><p>得到当前工作路径：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到当前的工作路径</span></span><br><span class="line">getwd()</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="查看文件-目录-是否存在"><a href="#查看文件-目录-是否存在" class="headerlink" title="查看文件(目录)是否存在"></a>查看文件(目录)是否存在</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个函数都可以用于查看文件(目录)是否存在</span></span><br><span class="line">dir.exists(paths)</span><br><span class="line">file.exists(paths)</span><br></pre></td></tr></table></figure><p>参数<code>paths</code>可以是<code>vector</code>，即可以<strong>批量查看文件（目录）是否存在</strong></p><hr><p><br></p><h2 id="列出目录下文件-目录"><a href="#列出目录下文件-目录" class="headerlink" title="列出目录下文件(目录)"></a>列出目录下文件(目录)</h2><ul><li>函数<code>list.files</code>和<code>dir</code>用法<strong>完全一样</strong>，可以<strong>列出路径下所有文件（包括目录）</strong>；</li><li>函数<code>list.dirs</code>只列出路径下<strong>所有目录</strong></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录下所有文件和目录</span></span><br><span class="line">list.files(path = <span class="string">"."</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">       dir(path = <span class="string">"."</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目录下的所有目录</span></span><br><span class="line">list.dirs(path = <span class="string">"."</span>, full.names = <span class="literal">TRUE</span>, recursive = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>path</code>：路径，如不填则<strong>默认为当前工作路径</strong>，即<code>getwd()</code>得到的路径；</li><li><code>pattern</code>：<strong>正则表达式</strong>，若pattern不为NULL，返回文件（目录）名满足该正则表达式的文件（目录）；</li><li><code>all.files</code>：若为<code>FALSE</code>则<strong>不显示隐藏文件（目录）</strong>，若为<code>TRUE</code>则返回所有文件（目录）；</li><li><code>full.names</code>：若为<code>FALSE</code>则<strong>只返回文件（目录）名</strong>，若为<code>TRUE</code>则返回<strong>文件（目录）路径</strong>；</li><li><code>recursive</code>：若为<code>FALSE</code>则<strong>只返回该路径的子级文件（目录）</strong>，若为<code>TRUE</code>则返回<strong>所有子、孙文件（目录）</strong>；</li><li><code>ignore.case</code>：若为<code>TRUE</code>则在匹配pattern时<strong>不区分大小写</strong>；</li><li><code>include.dirs</code>：在<code>recursive</code>为<code>TURE</code>，即显示所有子、孙文件时，若<code>include.dirs</code>为<code>FALSE</code>则只列出最终端的文件名，而不列出中间层级的目录名；</li><li><code>no..</code>：若为<code>TRUE</code>，则不显示<code>.</code>和<code>..</code>。</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; list.files(recursive=<span class="literal">TRUE</span>,include.dirs=<span class="literal">FALSE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"filtered_feature_bc_matrix/barcodes.tsv.gz"</span> <span class="string">"filtered_feature_bc_matrix/features.tsv.gz"</span></span><br><span class="line">[<span class="number">3</span>] <span class="string">"filtered_feature_bc_matrix/matrix.mtx.gz"</span>   <span class="string">"npas4l.pdf"</span>                                </span><br><span class="line">[<span class="number">5</span>] <span class="string">"top_zebrafish_cluster_markers.csv"</span>          <span class="string">"zebrafish_cluster_markers.csv"</span>             </span><br><span class="line">[<span class="number">7</span>] <span class="string">"zebrafish_first.rds"</span>                  </span><br><span class="line"></span><br><span class="line"><span class="comment"># include.dirs=TRUE时多出"filtered_feature_bc_matrix" 中间文件夹</span></span><br><span class="line">&gt; list.files(recursive=<span class="literal">TRUE</span>,include.dirs=<span class="literal">TRUE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"filtered_feature_bc_matrix"</span>                 <span class="string">"filtered_feature_bc_matrix/barcodes.tsv.gz"</span></span><br><span class="line">[<span class="number">3</span>] <span class="string">"filtered_feature_bc_matrix/features.tsv.gz"</span> <span class="string">"filtered_feature_bc_matrix/matrix.mtx.gz"</span>  </span><br><span class="line">[<span class="number">5</span>] <span class="string">"npas4l.pdf"</span>                                 <span class="string">"top_zebrafish_cluster_markers.csv"</span>         </span><br><span class="line">[<span class="number">7</span>] <span class="string">"zebrafish_cluster_markers.csv"</span>              <span class="string">"zebrafish_first.rds"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="新建文件-目录"><a href="#新建文件-目录" class="headerlink" title="新建文件(目录)"></a>新建文件(目录)</h2><p>函数<code>file.create</code>用于新建文件，<code>dir.create</code>用于新建目录：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">file.create(<span class="keyword">...</span>, showWarnings = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment"># 新建目录</span></span><br><span class="line">dir.create(path, showWarnings = <span class="literal">TRUE</span>, recursive = <span class="literal">FALSE</span>,mode = <span class="string">"0777"</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>函数默认<code>recursive</code>为<code>FALSE</code>，即<strong>只新建path中的第一级子目录</strong>，而当<code>recursive</code>为<code>TRUE</code>时可以<strong>新建多级子目录</strong>；</li><li>当目录<strong>已存在时不会新建目录覆盖原先的目录</strong>，此时如果<code>showWarnings</code>为<code>TRUE</code>，则会<strong>提醒</strong>该目录已存在，为<code>FALSE</code>时不会提醒；</li></ul><hr><p><br></p><h2 id="复制文件-目录"><a href="#复制文件-目录" class="headerlink" title="复制文件(目录)"></a>复制文件(目录)</h2><p>函数<code>file.copy</code>用于复制文件(目录)：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.copy(from, to, overwrite = recursive, recursive = <span class="literal">FALSE</span>,copy.mode = <span class="literal">TRUE</span>, copy.date = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>from</code>是<strong>原始文件（目录）名</strong>，<code>to</code>是<strong>新文件（目录）名</strong>，二者可以是vector，但是长度需相同；</li><li><code>overwrite</code> 若为<code>TRUE</code>，则<strong>文件被覆盖</strong>；</li><li><code>recursive</code> <strong>复制目录时recursive需为TRUE</strong>；</li><li><code>copy.mode</code>若为<code>TRUE</code>，<code>permission bits</code>一并复制过来；</li><li><code>copy.date</code>若为<code>TRUE</code>，文件<strong>日期一并复制过来</strong>。</li></ul><hr><p><br></p><h2 id="删除文件-目录"><a href="#删除文件-目录" class="headerlink" title="删除文件(目录)"></a>删除文件(目录)</h2><p>函数<code>unlink</code>可以用来删除<strong>文件或目录</strong>，函数<code>file.remove</code>可以用来删除<strong>文件</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(x, recursive = <span class="literal">FALSE</span>, force = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>x</code>是要删除的文件或目录，可以是<code>vector（即批量删除）</code>；</li><li>当<strong>删除目录</strong>时，<code>recursive</code>应为<code>TRUE</code>，表示目录内文件一并删除。</li></ul><hr><p><br></p><h2 id="重命名文件-目录"><a href="#重命名文件-目录" class="headerlink" title="重命名文件(目录)"></a>重命名文件(目录)</h2><p>函数<code>file.rename</code>用于重命名：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.rename(from, to)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>from</code>是<strong>原始文件（目录）名</strong>，<code>to</code>是<strong>新文件（目录）名</strong>，二者可以是<code>vector</code>，但是<code>长度需相同</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.omicsclass.com/article/338" target="_blank" rel="noopener">R语言文件目录操作</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;R中文件目录相关操作&lt;/strong&gt;，主要包括：&lt;code&gt;查看和设置工作路径&lt;/code&gt;、&lt;code&gt;查看文件或目录是否存在&lt;/code&gt;、&lt;code&gt;列出目录下文件或目录&lt;/code&gt;、&lt;code&gt;新建文件或目录&lt;/code&gt;、&lt;code&gt;复制文件或目录&lt;/code&gt;、&lt;code&gt;删除文件或目录&lt;/code&gt;、&lt;code&gt;重命名文件或目录&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell系列之局部变量、全局变量和环境变量</title>
    <link href="http://showteeth.tech/posts/52906.html"/>
    <id>http://showteeth.tech/posts/52906.html</id>
    <published>2019-08-26T08:57:43.000Z</published>
    <updated>2019-09-16T09:25:48.029Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章重点学习了Shell中<strong>变量的作用域</strong>，主要包括了<strong>局部变量</strong>、<strong>全局变量</strong>以及<strong>环境变量</strong>。其中在学习环境变量时又学习了使用<code>export</code>命令导出的<strong>临时环境变量</strong>以及<strong>在Shell进程启动时自动加载永久环境变量的过程</strong>。</p></div><a id="more"></a><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><code>Shell</code> 变量的<strong>作用域（Scope）</strong>，就是 <strong>Shell 变量的有效范围（可以使用的范围）</strong>。在<strong>不同的作用域</strong>中，同名的变量<strong>不会相互干涉</strong>；但是在<strong>相同的作用域中</strong>，同名的变量就会<strong>互相干扰</strong>，这也是为什么需要对变量作用域进行学习的原因。</p><p><code>Shell</code> 变量的作用域可以<strong>分为三种</strong>：</p><ul><li>有的变量只能在<strong>函数内部使用</strong>，这叫做<code>局部变量（local variable）</code>；</li><li>有的变量可以在<strong>当前 Shell 进程</strong>中使用，这叫做<code>全局变量（global variable）</code>；</li><li>而有的变量还可以在<strong>子进程</strong>中使用，这叫做<code>环境变量（environment variable）</code>。</li></ul><hr><p><br></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p><code>Shell</code> 也支持自定义函数，但是 <code>Shell</code> 函数和其他编程语言(如Python)函数的一个不同点就是：在 <strong>Shell 函数中定义的变量默认也是全局变量</strong>，它和在函数外部定义变量拥有一样的效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p></p><p>最后输出的结果是：99，是a的值。a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。</p><p>如果想要定义<strong>只在函数内部起作用的变量</strong>，需要在<strong>声明变量</strong>或者<strong>赋值之前</strong>加上<code>local</code>命令，这样就使得变量成为了<strong>局部变量</strong>，只在函数内部起作用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">local</span> a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p><hr><p><br></p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>所谓全局变量，就是指变量在<strong>当前的整个 Shell 进程中都有效</strong>；<strong>每个 Shell 进程(可以理解为在终端中打开的两个窗口)都有自己的作用域，彼此之间互不影响(在终端的一个窗口中定义的变量在另一个窗口中并不能调用)</strong>；<strong>在 Shell 中定义的变量，默认就是全局变量</strong>。</p><p>需要强调的是，全局变量的作用范围是<strong>当前的 Shell 进程</strong>，而<strong>不是当前的 Shell 脚本文件</strong>，它们是不同的概念；打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID；在一个 Shell 进程中可以使用 <code>source</code> 命令执行多个 Shell 脚本文件，此时<strong>全局变量在这些脚本文件中都有效</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  a.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">b=200</span><br><span class="line"></span><br><span class="line"><span class="comment">## b.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p></p><p>在打开的终端窗口中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前窗口的全局变量</span></span><br><span class="line">a=99</span><br><span class="line"></span><br><span class="line"><span class="comment"># source执行a脚本</span></span><br><span class="line">. ./a.sh</span><br><span class="line">  <span class="comment"># 输出99，也就是当前窗口的全局变量a的值</span></span><br><span class="line">  99</span><br><span class="line"></span><br><span class="line"><span class="comment"># source执行b脚本</span></span><br><span class="line">. ./b.sh</span><br><span class="line">  <span class="comment"># 输出a脚本中引入的全局变量</span></span><br><span class="line">  200</span><br></pre></td></tr></table></figure><p></p><p>这三条命令都是在<strong>一个进程</strong>中执行的，从输出结果可以发现，在 <code>Shell</code> 窗口中以命令行的形式定义的变量 <code>a</code>，在 <code>a.sh</code> 中有效；在 <code>a.sh</code>中定义的变量 <code>b</code>，在 <code>b.sh</code> 中也有效，变量 <code>b</code> 的作用范围已经超越了 <code>a.sh</code>。</p><div class="note info"><p>注意：这里是使用<code>source</code>的方式执行的脚本，效果是<strong>在当前进程下执行</strong>，而如果使用<code>bash a.sh</code>这种方式执行脚本就不会有上述结果，因为这种方式执行脚本是<strong>在子进程下执行的</strong>，具体执行方式的区别参考<a href="http://showteeth.tech/posts/16586.html">这篇文章</a>。</p></div><h3 id="全局变量冲突实例"><a href="#全局变量冲突实例" class="headerlink" title="全局变量冲突实例"></a>全局变量冲突实例</h3><p>最近在写shell脚本的时候恰巧遇到了全局变量导致程序出错的实例，这里记录一下：</p><ul><li>写了一个函数脚本，名为<code>qc.sh</code></li><li>在另一个脚本<code>run.sh</code>中对<code>qc.sh</code>进行了<code>source</code>执行</li></ul><p><code>qc.sh</code>截取：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func one</span></span><br><span class="line"><span class="function"><span class="title">func_1</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$&#123;local_variable&#125;</span>/*_test.zip)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    mv <span class="variable">$&#123;i&#125;</span> something</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># func two</span></span><br><span class="line"><span class="function"><span class="title">func_2</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$&#123;local_variable_2&#125;</span>/*_test.zip)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    mv <span class="variable">$&#123;i&#125;</span> something_2</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>run.sh</code>截取：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"190915_data"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  func_1  <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/qc</span><br><span class="line">  func_2  <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/trim <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/trim</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>最后程序在执行<code>func_2</code>时报错，而<code>func_1</code>正常执行，检查日志发现<code>func_2</code>传递的参数有误，其中的<code>${i}</code>部分变成了<code>func_1</code>中<code>for循环</code>最终停止的<code>i</code>，已经不是目标的<code>190915_data</code>，回顾之前学习的<a href="http://showteeth.tech/posts/16586.html">Linux系列之各种执行脚本方式的区别</a>，<code>source</code>方式执行脚本会打通全局变量，所以<code>func_1</code>执行之后由于其中的<code>i</code>变量<strong>不是局部变量，所以其作用域是整个脚本，并且会对之前的变量i的值进行覆盖</strong>，从而导致其值变为了<code>func_1</code>中<code>for循环</code>最终停止的<code>i</code>，并将其传递给了第二个函数<code>func_2</code>，最终导致出错。</p><p><strong>解决方法</strong>就是将<code>func_1</code>、<code>func_2</code>中的<code>i</code>声明为局部变量<code>local i</code></p><hr><p><br></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>全局变量</strong>只在<strong>当前 Shell 进程中有效</strong>，在<strong>其它 Shell 进程和子进程中都无效</strong>；如果想要使变量在Shell子进程甚至是所有的Shell进程中都有效，可以使用环境变量，环境变量又分为<strong>临时的环境变量</strong>和<strong>永久的环境变量</strong>：</p><ul><li>如果是使用<code>export</code>命令<strong>将全局变量导出</strong>，那么它就在所有的<strong>子进程</strong>中也有效了，这种变量被称为<strong>临时的环境变量</strong>；</li><li>而<strong>永久的环境变量</strong>是在shell启动时加载的，在<strong>所有的Shell进程中都有效的变量</strong>，如写在<code>~/.bashrc</code>中的变量。</li></ul><h3 id="临时的环境变量"><a href="#临时的环境变量" class="headerlink" title="临时的环境变量"></a>临时的环境变量</h3><p><strong>环境变量被创建(使用<code>export</code>命令)时所处的 Shell 进程称为父进程</strong>，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 <strong>Shell 子进程</strong>；当 Shell 子进程产生时，它会<strong>继承父进程的环境变量</strong>为自己所用，所以说环境变量可从父进程传给子进程；不难理解，环境变量还可以传递给孙进程。</p><p>注意，两个<strong>没有父子关系的 Shell 进程是不能传递使用<code>export</code>创建的环境变量的</strong>，并且这种环境变量<strong>只能向下传递而不能向上传递，即“传子不传父”</strong>。</p><p><strong>创建Shell子进程</strong>最简单的方法就是<code>bash</code>命令，退出Shell子进程的方法是<code>exit</code>命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前所处BASH的PID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  9512</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bash命令创建Shell子进程</span></span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看所处BASH的PID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  9963</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所处BASH的PID</span></span><br><span class="line"><span class="comment"># 发现回到了最开始的Shell进程</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> </span><br><span class="line">  9512</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个全局变量</span></span><br><span class="line">a=22       </span><br><span class="line"><span class="comment">#在当前Shell中输出a，成功</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line">  22</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入Shell子进程</span></span><br><span class="line">bash       </span><br><span class="line"><span class="comment">#在子进程中输出a，失败，输出为空</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#退出Shell子进程，返回上一级Shell</span></span><br><span class="line"><span class="built_in">exit</span>       </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将a导出为环境变量</span></span><br><span class="line"><span class="built_in">export</span> a   </span><br><span class="line"><span class="comment">#重新进入Shell子进程</span></span><br><span class="line">bash      </span><br><span class="line"><span class="comment">#在子进程中再次输出a，成功 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line">  22</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span>       </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出父进程，结束整个Shell会话</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现，<strong>默认情况下</strong>，<strong>a (父进程定义的变量)在 Shell 子进程中是无效的</strong>；使用 <code>export</code> 将 a <strong>导出为环境变量</strong>后，在子进程中就可以使用了；<code>export a</code>这种形式是在<strong>定义变量 a 以后</strong>再将它导出为环境变量，如果想在<strong>定义的同时导出为环境变量</strong>，可以写作<code>export a=22</code>。</p><div class="note info"><p>需要注意的是：</p><ul><li><strong>使用export导入的环境变量是临时的</strong>，这种环境变量只会在当前Shell进程及其Shell子进程(使用bash命令进入的Shell子进程)中起效，而不会在其他Shell进程(不同的终端窗口)中起效。</li><li>这种情况比较常见的是安装软件之后，没有将其写入环境变量，而是直接<code>export</code>，这种情况下，在该Shell进程以及其子Shell中都可以正常使用该软件，但是一旦切换终端窗口(其他Shell进程)就不能使用；另一种比较常见的就是编译、安装软件过程中通过<code>export</code>指定的依赖包的地址了。</li></ul></div><hr><h3 id="永久的环境变量"><a href="#永久的环境变量" class="headerlink" title="永久的环境变量"></a>永久的环境变量</h3><p>永久的环境变量主要是写在bash的<strong>环境配置文件</strong>中的变量，这些变量是在shell进程启动时<strong>自动加载</strong>的，在<strong>所有的Shell进程中都有效</strong>；bash的环境配置文件主要有<code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>、<code>/etc/bashrc</code>和<code>/etc/profile.d/*.sh</code>，其中的<code>~/.bashrc</code>文件就是平常使用中用来添加环境变量的文件；常规登录shell(交互式登录shell)之后会先读取<code>/etc/profile</code>，再依次搜索<code>~/.bash_profile</code>、<code>~/.bash_login</code>和<code>~/.profile</code>，并仅<strong>加载第一个搜索到且可读的文件(前面三个文件中的某一个)</strong>。当<strong>退出</strong>时，将执行<code>~/.bash_logout</code>中的命令。</p><p>配置文件的读取顺序中并没有包括提到的<code>/etc/profile</code>、<code>~/.bashrc</code>等常见的配置文件，主要是因为<strong>这些配置文件会被读取顺序中的文件所执行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/profile文件会以source的方式执行/etc/profile.d/*.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;-#*i&#125;</span>"</span> != <span class="string">"$-"</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile.d/*.sh包括</span></span><br><span class="line">vim.csh  vim.sh  256term.csh  256term.sh  </span><br><span class="line">lang.csh  lang.sh  csh.local  sh.local  colorls.csh  </span><br><span class="line">colorls.sh  colorgrep.csh  colorgrep.sh  </span><br><span class="line">less.csh  less.sh  which2.csh  which2.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bash_profile文件也会以source方式执行~/.bashrc</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在~/.bashrc也会以source的方式执行/etc/bashrc</span></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/bashrc其实也有以source方式执行/etc/profile.d/*.sh的语句</span></span><br><span class="line"><span class="comment"># 但是前提是非登录式shell时才会执行</span></span><br><span class="line"><span class="comment"># 这里不对shell的登录方式进行学习，只了解最简单的交互式登录</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">shopt</span> -q login_shell ; <span class="keyword">then</span>   <span class="comment"># We're not a login shell</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">"<span class="variable">$PS1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">                . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>具体的加载过程可以使用下图表示(图中的X表示在交互式登录shell中不会执行，<a href="https://www.cnblogs.com/f-ck-need-u/p/7417651.html" target="_blank" rel="noopener">图片来源</a>)：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/shell_load.png" alt="shell_load.png"></p><p>使用示例这里就不在进行列举了，感兴趣的可以自行尝试。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/view/773.html" target="_blank" rel="noopener">Shell变量的作用域：Shell全局变量、环境变量和局部变量</a></li><li><a href="https://blog.51cto.com/lspgyy/1542930" target="_blank" rel="noopener">shell函数的局部变量，全局变量</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7417651.html" target="_blank" rel="noopener">bash启动时加载配置文件过程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章重点学习了Shell中&lt;strong&gt;变量的作用域&lt;/strong&gt;，主要包括了&lt;strong&gt;局部变量&lt;/strong&gt;、&lt;strong&gt;全局变量&lt;/strong&gt;以及&lt;strong&gt;环境变量&lt;/strong&gt;。其中在学习环境变量时又学习了使用&lt;code&gt;export&lt;/code&gt;命令导出的&lt;strong&gt;临时环境变量&lt;/strong&gt;以及&lt;strong&gt;在Shell进程启动时自动加载永久环境变量的过程&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之各种执行脚本方式的区别</title>
    <link href="http://showteeth.tech/posts/16586.html"/>
    <id>http://showteeth.tech/posts/16586.html</id>
    <published>2019-08-26T08:52:56.000Z</published>
    <updated>2019-09-06T12:45:28.577Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中执行shell脚本的三种方式：<strong>作为可执行程序</strong>、<strong>作为解释器参数</strong>、<strong>source方式执行</strong>，了解了这三种方式在<strong>指定脚本解释器</strong>、<strong>变量共用性</strong>方面的区别和联系。</p></div><a id="more"></a><h2 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h2><p>在学习shell脚本执行方式之前，先学习一下脚本解释器。脚本解释器简单来说就是告诉脚本使用什么语言来执行(目前我的理解)，Linux下常用的shell脚本解释器有：</p><ul><li><code>sh</code>：即<code>Bourne shell</code>，<code>POSIX</code>（Portable Operating System Interface）标准的<strong>shell解释器</strong>，它的二进制文件路径通常是<code>/bin/sh</code>；</li><li><code>bash</code>：Bash是<code>Bourne shell</code>的替代品，属<code>GNU Project</code>，二进制文件路径通常是<code>/bin/bash</code>；</li></ul><p>在<code>centos</code>下，<code>/bin/sh</code>是一个指向<code>/bin/bash</code>的链接：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx. 1 root root      4 Jul 16 01:21 /bin/sh -&gt; bash</span><br><span class="line">-rwxr-xr-x. 1 root root 964608 Oct 30  2018 /bin/bash</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="shell脚本执行方式"><a href="#shell脚本执行方式" class="headerlink" title="shell脚本执行方式"></a>shell脚本执行方式</h2><p>shell脚本共有<strong>三种</strong>执行方式：</p><ul><li><strong>作为可执行程序</strong></li><li><strong>作为解释器参数</strong></li><li><strong>source方式执行</strong></li></ul><h2 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建脚本</span></span><br><span class="line">cat test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予权限</span></span><br><span class="line"><span class="comment"># 赋予脚本可执行的权限</span></span><br><span class="line">chmod +x test_run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>#!/bin/bash</code>：<strong>指定脚本解释器</strong>，这里是指定使用<code>/bin/bash</code>做解释器的，其中的<code>#!</code>是一个<strong>约定的标记</strong>，它<strong>告诉系统这个脚本需要什么解释器来执行</strong>。使用这种方式执行脚本，这一句话一定要正确，<strong>要和脚本使用的语言是一致的</strong>，如果脚本是使用Python编写，那么这句话加就要指定Python的解释器，指定其他的解释器可能会出错；如果编写的是<code>bash shell</code>脚本，可以省略第一行的<code>#!/bin/bash</code>，这样依旧是可以执行的。</li><li><code>./test_run.sh</code>需要<strong>具有可执行</strong>的权限；</li><li><code>./test_run.sh</code>：这句话一定要加上<code>./</code>，不然也不能正确执行；如果直接写上<code>test_run.sh</code>，linux就会在系统的环境变量(PATH)中去查找有没有<code>test_run.sh</code>这个脚本，如果有就ok，会执行这个脚本，但是如果没有将<code>test_run.sh</code>加入到环境变量，那么就会显示<code>command not found</code>；使用<code>./test_run.sh</code>的含义是告诉linux在当前目录下寻找<code>test_run.sh</code>脚本，从而使其能被找到并执行。</li></ul><div class="note info"><p>一种常见地执行脚本解释器的写法是：<code>#!/usr/bin/env python</code>，这里的<strong>env表示的是环境变量中指定的Python</strong>，而不是<code>/bin/python</code>这种默认的Python。</p></div><hr><h2 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h2><p>这种运行方式是，<strong>直接运行解释器，其参数就是shell脚本的文件名</strong>，如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定解释器的全路径</span></span><br><span class="line">/bin/bash test_run.sh</span><br><span class="line"><span class="comment"># 因为在环境变量中，所以可以直接使用bash</span></span><br><span class="line">bash test_run.sh</span><br></pre></td></tr></table></figure><p></p><p>这种方式运行的脚本，<strong>不需要在第一行指定解释器信息</strong>，写了也没用，同时也<strong>不需要脚本具有可执行权限</strong>。</p><hr><h2 id="Shell子进程"><a href="#Shell子进程" class="headerlink" title="Shell子进程"></a>Shell子进程</h2><p>上述两种执行方式都是在<strong>当前Shell进程的子进程中</strong>进行的，查看Shell当前进程的方式是使用内置的<code>$$</code>、<code>$BASHPID</code>变量查看进程ID，两种用法的区别可以参考<a href="http://showteeth.tech/posts/36597.html">这篇文章</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前shell进程</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看shell脚本执行时的进程ID</span></span><br><span class="line">cat  test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序执行</span></span><br><span class="line"><span class="comment"># shell子进程ID不同</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  23163</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释器变量执行</span></span><br><span class="line"><span class="comment"># shell子进程ID不同</span></span><br><span class="line">bash test_run.sh </span><br><span class="line">  10</span><br><span class="line">  23194</span><br></pre></td></tr></table></figure><p></p><p>既然是在不同的Shell进程中执行的命令，所以某个shell进程中的全局(局部)变量在另一个Shell进程中是无法使用的，如果想要使用可以使用环境环境变量，具体可以查看<a href="http://showteeth.tech/posts/52906.html">这篇文章</a>。</p><hr><h3 id="source方式执行"><a href="#source方式执行" class="headerlink" title="source方式执行"></a>source方式执行</h3><p><code>source</code>方式执行的脚本不同于上述两种执行方式，其是<strong>在当前Shell进程下执行的</strong>；<code>source</code>执行脚本有<strong>两种写法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两种写法都是使用source执行脚本</span></span><br><span class="line">. test_run.sh</span><br><span class="line"><span class="built_in">source</span> test_run.sh</span><br></pre></td></tr></table></figure><p></p><p>具体示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用source命令执行程序</span></span><br><span class="line"><span class="comment"># 并输出程序执行的Shell进程ID</span></span><br><span class="line"><span class="built_in">source</span> test_run.sh </span><br><span class="line">  10</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line">. test_run.sh </span><br><span class="line">  10</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell进程ID</span></span><br><span class="line"><span class="comment"># 发现和source执行脚本的进程ID相同</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>因为<code>source</code>执行的脚本是在<strong>当前Shell进程</strong>中进行的，所以<strong>当前Shell进程的全局变量以及脚本中的全局变量是共通的</strong>，两者之间可以相互使用。</p><p>其他<code>source</code>命令注意事项：</p><ul><li><code>source</code> 命令<strong>不需要脚本具有可执行权限</strong>；</li><li><code>source</code> 命令可以<strong>强行让一个脚本去立即影响当前的环境</strong>；</li><li><code>source</code> 命令通常用于<strong>重新执行刚修改的初始化文件，使修改生效</strong>，如<code>~/.bashrc</code>；</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li></li><li><a href="https://www.centos.bz/2017/12/%E8%AF%A6%E8%A7%A3shell%E4%B8%ADsource%E3%80%81sh%E3%80%81bash%E3%80%81-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">详解shell中source、sh、bash、./执行脚本的区别</a></li><li><a href="https://blog.51cto.com/xoyabc/1673249" target="_blank" rel="noopener">shell中的点命令与source命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中执行shell脚本的三种方式：&lt;strong&gt;作为可执行程序&lt;/strong&gt;、&lt;strong&gt;作为解释器参数&lt;/strong&gt;、&lt;strong&gt;source方式执行&lt;/strong&gt;，了解了这三种方式在&lt;strong&gt;指定脚本解释器&lt;/strong&gt;、&lt;strong&gt;变量共用性&lt;/strong&gt;方面的区别和联系。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之向量、矩阵、数组、数据框和列表</title>
    <link href="http://showteeth.tech/posts/30224.html"/>
    <id>http://showteeth.tech/posts/30224.html</id>
    <published>2019-08-25T03:17:31.000Z</published>
    <updated>2019-08-25T07:25:15.573Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是基于<a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">这篇文章</a>学习了R中几种常见的数据结构，包括<code>向量</code>、<code>矩阵</code>、<code>数组</code>、<code>数据框</code>以及<code>列表</code>，主要围绕这些数据结构的<code>构成</code>、<code>创建</code>、<code>获取元素</code>进行了学习，后续使用中可以查询和补充。</p></div><a id="more"></a><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量的创建"><a href="#向量的创建" class="headerlink" title="向量的创建"></a>向量的创建</h3><p>向量是用于存储<code>数值型</code>、<code>字符型</code>或<code>逻辑型</code>数据的一维数组。执行组合功能的函数<code>c()</code>可用来<strong>创建向量</strong>。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为数值：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向量创建使用示例</span></span><br><span class="line">&gt; a &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">4</span>)   <span class="comment">#数值型向量</span></span><br><span class="line">&gt; a</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span> -<span class="number">2</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt; b &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)  <span class="comment">#字符型向量</span></span><br><span class="line">&gt; b</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">&gt; c &lt;- c(<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>)  <span class="comment">#逻辑型向量</span></span><br><span class="line">&gt; c</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure><p></p><p>特别地，对于整数型向量，可以使用<code>seq</code>函数进行创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始值（from），结束值（to），步长（by）</span></span><br><span class="line">seq(from = <span class="number">1</span>, to = <span class="number">1</span>, by=step)</span><br><span class="line"><span class="comment"># 创建从1开始到5(包括)截止，步长为1的整数向量</span></span><br><span class="line">seq(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用这种方式创建步长为1的整数向量</span></span><br><span class="line"><span class="number">1</span>:<span class="number">5</span></span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h3><p>通过<code>is.*</code> 函数检查变量的类型，通过<code>as.*</code>函数转换变量的类型：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; vc &lt;- c(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>)</span><br><span class="line"><span class="comment"># 判断vc是不是字符型向量</span></span><br><span class="line">&gt; is.character(vc)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 将vc转换为整数型向量</span></span><br><span class="line">&gt; vi &lt;- as.integer(vc)</span><br><span class="line">&gt; is.integer(vi)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问向量中的元素"><a href="#访问向量中的元素" class="headerlink" title="访问向量中的元素"></a>访问向量中的元素</h3><p>通过索引的方式可以访问向量中的元素，注意<strong>R中是索引开始于1</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取索引为1的元素</span></span><br><span class="line">&gt; a[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line"><span class="comment"># 获取索引为1、5的元素</span></span><br><span class="line">&gt; a[c(<span class="number">1</span>,<span class="number">3</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 切片操作，获取1-3的元素</span></span><br><span class="line">&gt; b[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>获取逻辑判断为TRUE的元素</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过判断语句得到逻辑向量</span></span><br><span class="line">&gt; v&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; class(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"logical"</span></span><br><span class="line"><span class="comment"># 得到逻辑向量为TRUE的索引位置</span></span><br><span class="line">&gt; which(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[which(v&gt;<span class="number">2</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[v&gt;<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="向量的排序"><a href="#向量的排序" class="headerlink" title="向量的排序"></a>向量的排序</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># sort返回排序之后的向量</span></span><br><span class="line">&gt; sort(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># order返回排序后的向量元素在原始向量中的索引位置</span></span><br><span class="line">&gt; order(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 通过索引位置获取排序后的向量</span></span><br><span class="line">&gt; v[order(v)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="补充知识-NULL和NA"><a href="#补充知识-NULL和NA" class="headerlink" title="补充知识-NULL和NA"></a>补充知识-NULL和NA</h3><p><code>NULL</code>是个特殊值，表示未知值，<code>NA</code>表示缺失值，<code>NULL</code>和<code>NA</code>之间<strong>最大的区别是</strong>：<code>NA</code>是一个标量值，<code>长度为1</code>，而<code>NULL</code>不会占用任何空间，<strong>长度为零</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出长度</span></span><br><span class="line">&gt; length(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; length(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断null、na</span></span><br><span class="line">&gt; is.null(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; is.na(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h3><p>矩阵是一个二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通 过函数matrix创建矩阵。一般使用格式为：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mymatrix &lt;- matrix(vector,nrow=number_of_rows,ncol=number_of_columns,   </span><br><span class="line">    + byrow=logical_value,dimnames=list(   </span><br><span class="line">    + char_vector_rowname,char_vector_colnames))</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了矩阵的元素，</li><li><code>nrow</code>和<code>ncol</code>用以指定行和列的维数，</li><li><code>dimnames</code>包含了可选的、以字符型向量表示的行名和列名</li><li>选项<code>byrow</code>则表明矩阵应当按行填充（<code>byrow=TRUE</code>）还是按列填充（<code>byrow=FALSE</code>），默认情况下按列填充。简单示例如下：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个5*4的矩阵</span></span><br><span class="line">&gt; y &lt;- matrix(<span class="number">1</span>:<span class="number">20</span>,nrow=<span class="number">5</span>,ncol=<span class="number">4</span>)     </span><br><span class="line">&gt; y</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span>   <span class="number">11</span>   <span class="number">16</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span>   <span class="number">12</span>   <span class="number">17</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span>   <span class="number">13</span>   <span class="number">18</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span>   <span class="number">14</span>   <span class="number">19</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span>   <span class="number">15</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按行填充的2*2矩阵</span></span><br><span class="line">&gt; cells &lt;- c(<span class="number">1</span>,<span class="number">26</span>,<span class="number">24</span>,<span class="number">68</span>)</span><br><span class="line">&gt; rnames &lt;- c(<span class="string">"R1"</span>,<span class="string">"R2"</span>)</span><br><span class="line">&gt; cname &lt;- c(<span class="string">"C1"</span>,<span class="string">"C2"</span>)</span><br><span class="line">&gt; &gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">TRUE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">26</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按列填充的2*2矩阵</span></span><br><span class="line">&gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">FALSE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">24</span></span><br><span class="line">R2 <span class="number">26</span> <span class="number">68</span></span><br></pre></td></tr></table></figure><hr><h3 id="矩阵元素的获取"><a href="#矩阵元素的获取" class="headerlink" title="矩阵元素的获取"></a>矩阵元素的获取</h3><p>我们可以使用索引的方式来选择矩阵中的行、列或元素。<code>X[i,]</code>指矩阵X中的第i行，<code>X[,j]</code>指第j列，<code>X[i, j]</code>指第i行第j个元素。选择<strong>多行或多列</strong>时，下标i和j可为数值型向量，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">2</span>)</span><br><span class="line">&gt; x</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">7</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span>    <span class="number">8</span>   <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二行的元素</span></span><br><span class="line">&gt; x[<span class="number">2</span>,]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二列的元素</span></span><br><span class="line">&gt; x[,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取第一行第4列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取第一行第4列、第五列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,c(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p></p><p>矩阵都是二维的，和向量类似，<strong>矩阵中也仅能包含一种数据类型</strong>；当<strong>维度超过2时，不妨使用数组</strong>；当有<strong>多种模式的数据时，不妨使用数据框</strong>。</p><hr><p><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p>数组（array）与矩阵类似，但是维度可以大于2。数组可通过array函数创建，形式如下：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray &lt;- array(vector,dimensions,dimnames)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了数组中的数据；</li><li><code>dimensions</code>是一个数值型向量，给出了各个维度下标的最大值；</li><li><code>dimnames</code>是可选的、各维度名称标签的列表。</li></ul><p>创建三维 （2×3×4）数值型数组:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; z &lt;- array(<span class="number">1</span>:<span class="number">24</span>, c(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&gt; z</span><br><span class="line">, , <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span></span><br><span class="line">A2  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">7</span>  <span class="number">9</span> <span class="number">11</span></span><br><span class="line">A2  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">13</span> <span class="number">15</span> <span class="number">17</span></span><br><span class="line">A2 <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">19</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line">A2 <span class="number">20</span> <span class="number">22</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p></p><p>如你所见，数组是矩阵的一个自然推广；它们在编写新的统计方法时可能很有用。</p><p>像矩阵一样，<strong>数组中的数据也只能拥有一种模式</strong>。</p><hr><h3 id="数组元素的获取"><a href="#数组元素的获取" class="headerlink" title="数组元素的获取"></a>数组元素的获取</h3><p>从数组中选取元素的方式与矩阵类似：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">15</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">3</span>  <span class="number">9</span> <span class="number">15</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>由于<strong>不同的列可以包含不同模式（数值型、字符型等）的数据，但每一列的数据类型必须唯一</strong>，数据框的用途更为广泛。</p><h3 id="数据框的创建"><a href="#数据框的创建" class="headerlink" title="数据框的创建"></a>数据框的创建</h3><p>数据框可通过函数<code>data.frame()</code>创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydata &lt;- data.frame(col1,col2,col3,…)</span><br></pre></td></tr></table></figure><p></p><ul><li>列向量<code>col1</code>, <code>col2</code>, <code>col3</code>,… 可为任何类型（如字符型、数值型或逻辑型）</li><li>每一列的名称可由函数<code>names</code>指定</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientID &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt; age &lt;- c(<span class="number">25</span>,<span class="number">34</span>,<span class="number">28</span>,<span class="number">52</span>)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID,age,diabetes,status)</span><br><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br></pre></td></tr></table></figure><p></p><p>每一列数据的模式必须唯一，不过你却可以将多个模式的不同列放到一起组成数据框。</p><h3 id="数据框元素的获取"><a href="#数据框元素的获取" class="headerlink" title="数据框元素的获取"></a>数据框元素的获取</h3><p>选取数据框中元素的方式有若干种，你可以使用索引，亦可直接指定列名。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br><span class="line"><span class="comment"># 通过索引</span></span><br><span class="line">&gt; patientdata[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">  patientID age</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span></span><br><span class="line"><span class="comment"># 直接指定列名</span></span><br><span class="line">&gt; patientdata[c(<span class="string">"diabetes"</span>,<span class="string">"status"</span>)]</span><br><span class="line">  diabetes    status</span><br><span class="line"><span class="number">1</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>    Type1      Poor</span><br><span class="line">&gt; patientdata[c(<span class="string">"age"</span>)]</span><br><span class="line">  age</span><br><span class="line"><span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>  <span class="number">52</span></span><br><span class="line">&gt; class(patientdata[c(<span class="string">"age"</span>)])</span><br><span class="line">[<span class="number">1</span>] <span class="string">"data.frame"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某列的值，并得到向量</span></span><br><span class="line">&gt; patientdata$age</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">&gt; class(patientdata$age)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br></pre></td></tr></table></figure><p></p><p>第三个例子中的记号<code>$</code>是新出现的，它被用来<strong>选取一个给定数据框中的某个特定变量，并且返回向量形式</strong>。例如，如果你想生成糖尿病类型变量diabetes和病情变量status的列联表，使用以下代码即可：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; table(patientdata$diabetes,patientdata$status)</span><br><span class="line"></span><br><span class="line">        Excellent Improved Poor</span><br><span class="line">  Type1         <span class="number">1</span>        <span class="number">0</span>    <span class="number">2</span></span><br><span class="line">  Type2         <span class="number">0</span>        <span class="number">1</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>在每个变量名前都键入一次<code>patientdata$</code>可能会让人生厌，所以不妨走一些捷径。可以联合使用函数<code>attach()</code>和<code>detach()</code>或单独使用函数<code>with()</code>来简化代码.</p><p><code>attach()</code>函数可<strong>将数据框添加到R的搜索路径中</strong>，R在遇到一个变量名以后，将检查搜索路径中的数据框，以定位到这个变量：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;summary(mtcars$mpg)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line">&gt;plot(mtcars$mpg,mtcars$disp)</span><br><span class="line">&gt; <span class="comment">#也可写成：</span></span><br><span class="line"><span class="comment"># 将数据框添加到R的搜索路径中</span></span><br><span class="line">&gt;<span class="keyword">attach</span>(mtcars)</span><br><span class="line">&gt;plot(mpg,disp)</span><br><span class="line"><span class="comment"># 将数据框从搜索路径中移除</span></span><br><span class="line">&gt;<span class="keyword">detach</span>(mtcars)</span><br></pre></td></tr></table></figure><p>当<strong>名称相同的对象不止一个时</strong>，这种方法的局限性就很明显了。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; mpg &lt;- c(<span class="number">25</span>,<span class="number">36</span>,<span class="number">47</span>)</span><br><span class="line">&gt; <span class="keyword">attach</span>(mtcars)</span><br><span class="line">The following object is masked _by_ .GlobalEnv:  mpg</span><br><span class="line"><span class="comment"># mtcars中也有mpg变量</span></span><br><span class="line">&gt; plot(mpg,wt)</span><br><span class="line">Error <span class="keyword">in</span> xy.coords(x, y, xlabel, ylabel, log) : </span><br><span class="line">  <span class="string">'x'</span> and <span class="string">'y'</span> lengths differ</span><br><span class="line">&gt; mpg</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">36</span> <span class="number">47</span></span><br><span class="line"><span class="comment"># 指定mpg来源</span></span><br><span class="line">&gt; plot(mtcars$mpg,wt)</span><br></pre></td></tr></table></figure><p></p><p>这里，在数据框mtcars被绑定（attach）之前，我们的环境中已经有了一个名为mpg的对象。 在这种情况下，原始对象将取得优先权，故而报错，这个时候想使用mpg时，便要像最后一段代码示例那般指定变量来源。</p><p>除此之外，另一种方式是使用函数<code>with()</code>，你可以这样重写上例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ plot(mpg,disp)</span><br><span class="line">+ &#125;)</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，<strong>大括号{}之间的语句都针对数据框mtcars执行</strong>，这样就无须担心名称冲突了；如果<strong>仅有一条语句（例如summary(mpg)），那么大括号{}可以省略</strong>；<strong>函数<code>with()</code>的局限性在于，赋值仅在此函数的括号内生效</strong>，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;stats &lt;-summary(mpg)</span><br><span class="line">+ stats</span><br><span class="line">+ &#125;)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line"><span class="comment"># 在with的&#123;&#125;之外</span></span><br><span class="line">&gt; stats</span><br><span class="line">错误: 找不到对象<span class="string">'stats'</span></span><br></pre></td></tr></table></figure><p></p><p>如果你需要创建在<code>with()</code>结构以外存在的对象，使用<code>特殊赋值符&lt;&lt;-</code>替代<code>标准赋值符&lt;-</code>即可，它可将对象保存到<code>with()</code>之外的全局环境中。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ nokeepstats &lt;- summary(mpg)</span><br><span class="line">+ keepstats &lt;&lt;- summary(mpg)</span><br><span class="line">+ &#125;)</span><br><span class="line">&gt; nokeepstats</span><br><span class="line">错误: 找不到对象<span class="string">'nokeepstats'</span></span><br><span class="line">&gt; keepstats</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>如你所见，变量可归结为名义型、有序型或连续型变量。名义型变量是没有顺序之分的类别变量，糖尿病类型Diabetes（Type1、Type2）是名义型变量的一例，即使在数据中Type1编码为1而Type2编码为2，这也并不意味着二者是有序的。有序型变量表示一种顺序关系，而非数量关系，病情Status（poor、improved、excellent）是顺序型变量的一个上佳示例。我们明白， 病情为poor（较差）病人的状态不如improved（病情好转）的病人，但并不知道相差多少。连续型变量可以呈现为某个范围内的任意值，并同时表示了顺序和数量，年龄Age就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值，我们很清楚，15岁的人比14岁的人年长一岁。</p><p><strong>类别（名义型）变量</strong>和<strong>有序类别（有序型）变量</strong>在R中称为<strong>因子（factor）</strong>。因子在R中非常重要，因为它决定了<strong>数据的分析方式</strong>以及<strong>如何进行视觉呈现</strong>，你将在本书中通篇看到这样的例子。函数<code>factor()</code>以一个整数向量的形式存储类别值，整数的取值范围是<code>[1… k]</code>（其中<code>k</code>是名义型变量中<strong>唯一值</strong>的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</p><p>举例来说，假设有向量：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; diabetes &lt;- c( <span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; diabetes &lt;- factor(diabetes)</span><br><span class="line">&gt; diabetes</span><br><span class="line">[<span class="number">1</span>] Type1 Type2 Type1 Type1</span><br><span class="line">Levels: Type1 Type2</span><br></pre></td></tr></table></figure><p></p><p>语句<code>diabetes &lt;- factor(diabetes)</code>将此向量存储为<code>(1, 2, 1, 1)</code>，并在内部将其关联为<code>1=Type1</code>和<code>2=Type2</code>（具体赋值根据字母顺序而定）。针对向量diabetes进行的任何分析都会<strong>将其作为名义型变量对待</strong>，并<strong>自动选择适合这一测量尺度的统计方法</strong>。要表示<strong>有序型变量</strong>，需要为函数<code>factor()</code>指定参数<code>ordered=TRUE</code>。给定向量:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br></pre></td></tr></table></figure><p></p><p>语句<code>status &lt;- factor(status, ordered=TRUE)</code>会将向量编码为<code>(3, 2, 1, 3)</code>，并在内部将这些值关联为<code>1=Excellent</code>、<code>2=Improved</code>以及<code>3=Poor</code>.对于<strong>字符型向量</strong>，因子的水平<strong>默认依字母顺序创建</strong>，这对于因子status是有意义的，因为 <code>Excellent</code>、<code>Improved</code>、<code>Poor</code>的排序方式恰好与逻辑顺序相一致，如果<code>Poor</code>被编码为<code>Ailing</code>，会有问题，因为顺序将为<code>Ailing</code>、<code>Excellent</code>、<code>Improved</code>。如果理想中的顺序是<code>Poor</code>、<code>Improved</code>、<code>Excellent</code>，则会出现类似的问题：按默认的字母顺序排序的因子很少能够让人满意，你可以通过指定<code>levels</code>选项来覆盖默认排序。例如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是按照字母顺序创建</span></span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现Ailing会破坏顺序</span></span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>,<span class="string">"Ailing"</span>)</span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor      Ailing   </span><br><span class="line">Levels: Ailing &lt; Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用levels指定顺序</span></span><br><span class="line">&gt; status &lt;- factor(status,ordered=<span class="literal">TRUE</span>,</span><br><span class="line">+ levels=c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>)</span><br><span class="line">+ )</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Poor &lt; Improved &lt; Excellent</span><br></pre></td></tr></table></figure><p></p><p>因子的使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建dataframe</span></span><br><span class="line">&gt; patientdata &lt;-data.frame(patientID,age,diabetes,status)</span><br><span class="line"><span class="comment"># 查看各列数据的类型</span></span><br><span class="line">&gt; str(patientdata)</span><br><span class="line"><span class="string">'data.frame'</span>:   <span class="number">4</span> obs. of  <span class="number">4</span> variables:</span><br><span class="line">  $ patientID: num  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">  $ age      : num  <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">  $ diabetes : Factor w/ <span class="number">2</span> levels <span class="string">"Type1"</span>,<span class="string">"Type2"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  $ status   : Ord.factor w/ <span class="number">3</span> levels <span class="string">"Poor"</span>&lt;<span class="string">"Improved"</span>&lt;..: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 显示基本统计信息</span></span><br><span class="line">&gt; summary(patientdata)</span><br><span class="line">    patientID         age         diabetes       status </span><br><span class="line">  Min.   :<span class="number">1.00</span>   Min.   :<span class="number">25.00</span>   Type1:<span class="number">3</span>   Poor     :<span class="number">2</span>  </span><br><span class="line">  1st Qu.:<span class="number">1.75</span>   1st Qu.:<span class="number">27.25</span>   Type2:<span class="number">1</span>   Improved :<span class="number">1</span>  </span><br><span class="line">  Median :<span class="number">2.50</span>   Median :<span class="number">31.00</span>             Excellent:<span class="number">1</span>  </span><br><span class="line">  Mean   :<span class="number">2.50</span>   Mean   :<span class="number">34.75</span>                          </span><br><span class="line">  3rd Qu.:<span class="number">3.25</span>   3rd Qu.:<span class="number">38.50</span>                          </span><br><span class="line">  Max.   :<span class="number">4.00</span>   Max.   :<span class="number">52.00</span></span><br></pre></td></tr></table></figure><p></p><p><code>str(patientdata)</code>清楚地显示<code>diabetes</code>是一个<strong>因子</strong>，而<code>status</code>是一个<strong>有序型因子</strong>，以及此数据框在<strong>内部是如何进行编码的</strong>。注意，函数<code>summary()</code>会<strong>区别对待各个变量</strong>，它显示了连续型变量age的最小值、最大值、均值和各四分位数，并显示了类别型变量diabetes和status（各水平）的频数值。</p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）是R的数据类型中为复杂的一种，一般来说，列表就是一些对象（或成分， component）的有序集合，列表允许你整合若干（可能无关的）对象到单个对象名下。例如，某个列表中可能是若干<strong>向量</strong>、<strong>矩阵</strong>、<strong>数据框</strong>，甚至<strong>其他列表</strong>的组合。</p><p>可以使用函数<code>list()</code>创建列表:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;- list(object1,object2,…)</span><br></pre></td></tr></table></figure><p></p><p>其中的对象可以是目前为止讲到的任何结构。你还可以为列表中的对象命名：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;`- list(name1=object1,name2=object2,…)</span><br></pre></td></tr></table></figure><p>具体使用示例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; g &lt;- <span class="string">"My First List"</span></span><br><span class="line">&gt; h &lt;- c(<span class="number">25</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">39</span>)</span><br><span class="line">&gt; j &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">5</span>)</span><br><span class="line">&gt; k &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)</span><br><span class="line">&gt; mylist &lt;- list(title=g,ages=h,j,k)</span><br><span class="line">&gt; mylist</span><br><span class="line">$title</span><br><span class="line">[<span class="number">1</span>] <span class="string">"My First List"</span></span><br><span class="line"></span><br><span class="line">$ages</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">26</span> <span class="number">18</span> <span class="number">39</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p>本例创建了一个列表，其中有四个成分：一个字符串、一个数值型向量、一个矩阵以及一个字符型向量。</p><p>在访问列表中元素时，可以通过在<strong>双重方括号</strong>中<strong>指明代表某个成分的数字</strong>或<strong>名称</strong>来访问列表中的元素。此例 中，<code>mylist[[2]]</code>和<code>mylist[[“ages”]]</code>均指那个含有四个元素的向量。</p><p>由于两个原因，列表成为了R中的重要数据结构:</p><ul><li>首先，列表允许以一种简单的方式组织和重新调用不相干的信息；</li><li>其次，许多R函数的运行结果都是以列表的形式返回的，需要取出其中哪些成分由分析人员决定。</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">R语言入门之创建数据集——向量、矩阵、数组、数据框和列表</a></li><li><a href="https://www.cnblogs.com/ljhdo/p/5173674.html" target="_blank" rel="noopener">R语言学习 第一篇：变量和向量</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要是基于&lt;a href=&quot;https://blog.csdn.net/qq_28945021/article/details/52100765&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;学习了R中几种常见的数据结构，包括&lt;code&gt;向量&lt;/code&gt;、&lt;code&gt;矩阵&lt;/code&gt;、&lt;code&gt;数组&lt;/code&gt;、&lt;code&gt;数据框&lt;/code&gt;以及&lt;code&gt;列表&lt;/code&gt;，主要围绕这些数据结构的&lt;code&gt;构成&lt;/code&gt;、&lt;code&gt;创建&lt;/code&gt;、&lt;code&gt;获取元素&lt;/code&gt;进行了学习，后续使用中可以查询和补充。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之字符串处理</title>
    <link href="http://showteeth.tech/posts/28337.html"/>
    <id>http://showteeth.tech/posts/28337.html</id>
    <published>2019-08-24T13:43:57.000Z</published>
    <updated>2019-08-25T03:05:25.756Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<strong>R中的字符向量处理函数</strong>，主要包括<strong>字符数统计和字符翻译</strong>、<strong>字符串连接</strong>、<strong>字符串拆分</strong>、<strong>字符串查询</strong>、<strong>字符串替换</strong>、<strong>字符串提取</strong>、<strong>字符串显示控制</strong>等。</p></div><a id="more"></a><h2 id="字符数统计和字符翻译"><a href="#字符数统计和字符翻译" class="headerlink" title="字符数统计和字符翻译"></a>字符数统计和字符翻译</h2><h3 id="nchar和length"><a href="#nchar和length" class="headerlink" title="nchar和length"></a>nchar和length</h3><p><code>nchar</code>这个函数简单，统计<strong>向量中每个元素的字符个数</strong>，注意<strong>这个函数和<code>length</code>函数的差别</strong>：</p><ul><li><code>nchar</code>是<strong>向量元素的字符个数</strong>;</li><li>而<code>length</code>是<strong>向量长度（向量元素的个数）</strong>.</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"Hellow"</span>, <span class="string">"World"</span>, <span class="string">"!"</span>)</span><br><span class="line"><span class="comment"># 向量中每个元素的长度</span></span><br><span class="line">nchar(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">6</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量的长度</span></span><br><span class="line">length(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h3 id="tolower、toupper和chartr"><a href="#tolower、toupper和chartr" class="headerlink" title="tolower、toupper和chartr"></a>tolower、toupper和chartr</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DNA &lt;- <span class="string">"AtGCtttACC"</span></span><br><span class="line"><span class="comment"># 将上述字符转换为小写</span></span><br><span class="line">tolower(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"atgctttacc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述字符转换为大写</span></span><br><span class="line">toupper(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"ATGCTTTACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;u</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"Uu"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AuGCuuuACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;U</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"UU"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AUGCUUUACC"</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><h3 id="paste函数"><a href="#paste函数" class="headerlink" title="paste函数"></a>paste函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义分隔符</span></span><br><span class="line">paste (<span class="keyword">...</span>, sep = <span class="string">" "</span>, collapse = <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment"># 默认没有分隔符</span></span><br><span class="line">paste0(<span class="keyword">...</span>, collapse = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短的向量CK会被循环使用</span></span><br><span class="line">paste(<span class="string">"CK"</span>, <span class="number">1</span>:<span class="number">6</span>, sep = <span class="string">"|"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"CK|1"</span> <span class="string">"CK|2"</span> <span class="string">"CK|3"</span> <span class="string">"CK|4"</span> <span class="string">"CK|5"</span> <span class="string">"CK|6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短的向量会被循环使用</span></span><br><span class="line">x = c(a = <span class="string">"aaa"</span>, b = <span class="string">"bbb"</span>, c = <span class="string">"ccc"</span>)</span><br><span class="line">y = c(d = <span class="number">1</span>, e = <span class="number">2</span>)</span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>) </span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span> <span class="string">"bbb-2"</span> <span class="string">"ccc-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述操作返回的都是一个向量</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>)[<span class="number">1</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想将所有的连接成一个字符串</span></span><br><span class="line"><span class="comment"># 使用collapse参数</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>,collapse = <span class="string">";"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1;bbb-2;ccc-1"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><h3 id="strsplit函数"><a href="#strsplit函数" class="headerlink" title="strsplit函数"></a>strsplit函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strsplit(x, split, fixed = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>参数<code>x</code>为字串向量，<strong>每个元素都将单独进行拆分</strong>;</li><li>参数<code>split</code>为拆分位置的字串向量，默认<code>fixed=FALSE</code>为<strong>正则表达式匹配</strong>。如果你没接触过正则表达式，设置<code>fixed=TRUE</code>，表示使用<strong>普通文本匹配或正则表达式的精确匹配</strong>；普通文本的运算速度快;</li><li><code>perl=TRUE/FALSE</code>的设置和perl语言版本有关，如果正则表达式很长，正确设置表达式并且使用perl=TRUE可以提高运算速度;</li><li>参数<code>useBytes</code>设置<strong>是否逐个字节进行匹配</strong>，默认为FALSE，即按字符而不是字节进行匹配。</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- <span class="string">"Hello Adam!\nHello Ava!"</span></span><br><span class="line"><span class="comment"># 将上述字符按空格分隔</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span>        <span class="string">"Adam!\nHello"</span> <span class="string">"Ava!"</span> </span><br><span class="line"><span class="comment"># 返回的是一个列表</span></span><br><span class="line">class(strsplit(text, <span class="string">" "</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line"><span class="comment"># 输出分割后的第一个字符</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)[[<span class="number">1</span>]][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式进行分割</span></span><br><span class="line"><span class="comment"># 按空白分隔：空格、制表符、换行符等</span></span><br><span class="line">strsplit(text, <span class="string">"\\s"</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span> <span class="string">"Adam!"</span> <span class="string">"Hello"</span> <span class="string">"Ava!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到单个字符</span></span><br><span class="line">strsplit(text, <span class="string">""</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"d"</span>  <span class="string">"a"</span>  <span class="string">"m"</span>  <span class="string">"!"</span>  <span class="string">"\n"</span> <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"v"</span>  <span class="string">"a"</span>  <span class="string">"!"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h2><h3 id="grep和grepl函数"><a href="#grep和grepl函数" class="headerlink" title="grep和grepl函数"></a>grep和grepl函数</h3><p>这两个函数返回向量水平的匹配结果(向量中每个元素可以不可以匹配上)，不涉及匹配字符串的详细位置信息(在每个元素的什么索引位置匹配上).</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, value = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>, invert = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">grepl(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">      fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下所有的文件</span></span><br><span class="line">files &lt;- list.files(<span class="string">"./"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找以gz结尾的文件</span></span><br><span class="line"><span class="comment"># 返回的是可以匹配上的元素在整个向量中的索引位置</span></span><br><span class="line">grep(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的是向量元素中的每一个是不是可以匹配上</span></span><br><span class="line">grepl(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者虽然在输出表现上有所差异，但是在提取向量子集时结果相同</span></span><br><span class="line">files[grep(<span class="string">"\\.gz$"</span>, files)]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="regexpr、gregexpr和regexec"><a href="#regexpr、gregexpr和regexec" class="headerlink" title="regexpr、gregexpr和regexec"></a>regexpr、gregexpr和regexec</h3><p>这三个函数返回的结果包含了<strong>匹配的具体位置</strong>和<strong>匹配上的字符串长度信息</strong>，可以用于字符串的提取操作.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gregexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">         fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">regexec(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>三个函数的区别：</p><ul><li><code>regexpr</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>数字向量</strong></li><li><code>gregexpr</code>返回的是向量中每个元素<strong>所有出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li><li><code>regexec</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- c(<span class="string">"Hellow, Adam!Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素第一次出现Adam的位置</span></span><br><span class="line">class(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"integer"</span></span><br><span class="line">regexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  <span class="comment"># 匹配上的第一个字符位置 </span></span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span>  <span class="number">5</span> <span class="number">14</span></span><br><span class="line">  <span class="comment"># 匹配上的部分长度</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 获取上述结果中的match.length</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  $match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  $index.type</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line"></span><br><span class="line">  $useBytes</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 得到向量</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))$match.length</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素所有出现Adam的位置</span></span><br><span class="line">class(gregexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">gregexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span> <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 这个也是一样的方法</span></span><br><span class="line">attributes(gregexpr(<span class="string">"Adam"</span>, text)[[<span class="number">1</span>]])$match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素首次出现Adam的位置</span></span><br><span class="line">class(regexec(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">regexec(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">9</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="sub和gsub函数"><a href="#sub和gsub函数" class="headerlink" title="sub和gsub函数"></a>sub和gsub函数</h3><p>虽然<code>sub</code>和<code>gsub</code>是用于字符串替换的函数，但严格地说R语言没有字符串替换的函数，因为<strong>R语言不管什么操作对参数都是传值不传址(原始变量不会被修改)</strong>.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">    fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gsub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sub</span></span><br><span class="line"><span class="comment"># 将每个元素中的Adam替换为world</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始的text的内容还是没有发生改变</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, Adam!"</span>      <span class="string">"Hi, Adam!"</span>          <span class="string">"How are you, Adam."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gsub</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取表达式</span></span><br><span class="line"><span class="comment"># 使用转义字符+数字表示分组</span></span><br><span class="line">sub(pattern = <span class="string">".*(Adam).*"</span>, replacement = <span class="string">"\\1"</span>, text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Adam"</span> <span class="string">"Adam"</span> <span class="string">"Adam"</span></span><br></pre></td></tr></table></figure><p></p><p><code>sub</code>和<code>gsub</code>的区别：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改text内容</span></span><br><span class="line">text &lt;- c(<span class="string">"Hellow, Adam! Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub只会替换第一次出现的</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! Adam"</span> <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而gsub会将所有的都进行替换</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! world"</span> <span class="string">"Hi, world!"</span>           <span class="string">"How are you, world."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串提取"><a href="#字符串提取" class="headerlink" title="字符串提取"></a>字符串提取</h2><h3 id="substr和substring函数"><a href="#substr和substring函数" class="headerlink" title="substr和substring函数"></a>substr和substring函数</h3><p><code>substr</code>和<code>substring</code>函数<strong>通过位置进行字符串拆分或提取</strong>，它们<strong>本身并不使用正则表达式</strong>，但是结合正则表达式函数<code>regexpr</code>、<code>gregexpr</code>或<code>regexec</code>使用可以非常方便地从大量文本中提取所需信息。两者的参数设置基本相同：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substr(x, start, <span class="keyword">stop</span>)</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>)</span><br><span class="line">substr(x, start, <span class="keyword">stop</span>) &lt;- value</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>) &lt;- value</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>均为要拆分的字串向量</li><li><code>start/first</code> 为截取的起始位置向量</li><li><code>stop/last</code> 为截取字串的终止位置向量</li></ul><p>两个函数在返回值上存在差异：</p><ul><li>substr返回的字串个数等于第一个参数(要拆分的字串向量)的长度</li><li>substring返回字串个数等于三个参数中最长向量长度(要拆分的字串向量、起始位置向量、终止位置向量)，短向量循环使用</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">"123456789"</span></span><br><span class="line"><span class="comment"># 截取的区间是2-4、4-5、2-8(单向量循环使用)</span></span><br><span class="line"><span class="comment"># 因为x的长度为1，所以只会输出第一个2-4的结果</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># substring使用是输出最长向量长度的子串</span></span><br><span class="line">substring(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"45"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>关于短向量循环使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"123456789"</span>, <span class="string">"abcdefghijklmnopq"</span>)</span><br><span class="line"><span class="comment"># 因为x的长度为2，所以输出了两个</span></span><br><span class="line"><span class="comment"># 另外，x向量也会循环使用，2-4切数字、4-5切字母</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span> <span class="string">"de"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于x也可以循环可以看看substring</span></span><br><span class="line"><span class="comment"># 2-4切数字、4-5切字母、2-8切数字</span></span><br><span class="line">substring(x,c(<span class="number">2</span>,<span class="number">4</span>),c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"de"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>用<code>substring</code>函数可以很方便地把<code>DNA/RNA</code>序列进行<strong>三联拆分（用于蛋白质翻译）</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到随机序列</span></span><br><span class="line">bases = c(<span class="string">"A"</span>, <span class="string">"T"</span>, <span class="string">"G"</span>, <span class="string">"C"</span>)</span><br><span class="line">DNA = paste(sample(bases, <span class="number">12</span>, replace = <span class="literal">T</span>), collapse = <span class="string">""</span>)</span><br><span class="line">DNA</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCTGTCGGCTGC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三联拆分</span></span><br><span class="line">substring(DNA, seq(<span class="number">1</span>, <span class="number">10</span>, by = <span class="number">3</span>), seq(<span class="number">3</span>, <span class="number">12</span>, by = <span class="number">3</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCT"</span> <span class="string">"GTC"</span> <span class="string">"GGC"</span> <span class="string">"TGC"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串显示控制"><a href="#字符串显示控制" class="headerlink" title="字符串显示控制"></a>字符串显示控制</h2><h3 id="显示宽度-strtrim函数"><a href="#显示宽度-strtrim函数" class="headerlink" title="显示宽度-strtrim函数"></a>显示宽度-strtrim函数</h3><p>用于将字符串修剪到特定的显示宽度，其用法为<code>strtrim(x, width)</code>，<strong>返回字符串向量的长度等于x的长度</strong>。因为是“修剪”，所以<strong>只能去掉多余的字符不能增加其他额外的字符(这就感觉很鸡肋了。。。。)</strong>; 如果<strong>字符串本身的长度小于width，得到的是原字符串</strong>，别指望它会用空格或其他什么字符补齐：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大于width的字符部分会被去除</span></span><br><span class="line">strtrim(c(<span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>), c(<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"a"</span>      <span class="string">"abcde"</span>  <span class="string">"abcdef"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不足width的字符会输出原字符串</span></span><br><span class="line">strtrim(c(<span class="number">1</span>, <span class="number">123</span>, <span class="number">1234567</span>), <span class="number">4</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"1"</span>    <span class="string">"123"</span>  <span class="string">"1234"</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串段落化-strwrap函数"><a href="#字符串段落化-strwrap函数" class="headerlink" title="字符串段落化-strwrap函数"></a>字符串段落化-strwrap函数</h3><p>strwrap函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串，其帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strwrap(x, width = <span class="number">0.9</span> * getOption(<span class="string">"width"</span>), indent = <span class="number">0</span>,</span><br><span class="line">        exdent = <span class="number">0</span>, prefix = <span class="string">""</span>, simplify = <span class="literal">TRUE</span>, initial = prefix)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>表示待处理的字符向量</li><li><code>width</code>表示每行的宽度</li><li><code>indent</code>表示首行缩进</li><li><code>exdent</code>表示除首行外的其他行的缩进</li><li><code>simplify</code>表示结果的显示形式，<code>TRUE</code>表示返回向量，<code>FALSE</code>表示返回列表</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"Each character string in the input is first split into paragraphs\n(or lines containing whitespace only).  The paragraphs are then\nformatted by breaking lines at word boundaries.  The target\ncolumns for wrapping lines and the indentation of the first and\nall subsequent lines of a paragraph can be controlled\nindependently."</span></span><br><span class="line">str2 = rep(str1, <span class="number">2</span>)</span><br><span class="line">strwrap(str2, width = <span class="number">80</span>, indent = <span class="number">2</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">2</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">3</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">4</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">5</span>] <span class="string">"controlled independently."</span>                                                    </span><br><span class="line">  [<span class="number">6</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">7</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">9</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">10</span>] <span class="string">"controlled independently."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><p>##参考链接</p><ul><li><a href="https://blog.csdn.net/duqi_yc/article/details/9817243" target="_blank" rel="noopener">R字符串处理-grep/grepl/sub/gsub等等</a></li><li><a href="https://likan.info/cn/post/pattern-matching-and-replacement/" target="_blank" rel="noopener">R 中字符串的查找和替换</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了&lt;strong&gt;R中的字符向量处理函数&lt;/strong&gt;，主要包括&lt;strong&gt;字符数统计和字符翻译&lt;/strong&gt;、&lt;strong&gt;字符串连接&lt;/strong&gt;、&lt;strong&gt;字符串拆分&lt;/strong&gt;、&lt;strong&gt;字符串查询&lt;/strong&gt;、&lt;strong&gt;字符串替换&lt;/strong&gt;、&lt;strong&gt;字符串提取&lt;/strong&gt;、&lt;strong&gt;字符串显示控制&lt;/strong&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python中常用的snippets</title>
    <link href="http://showteeth.tech/posts/21065.html"/>
    <id>http://showteeth.tech/posts/21065.html</id>
    <published>2019-08-24T09:05:46.000Z</published>
    <updated>2019-08-24T16:03:33.988Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。</p></div><a id="more"></a><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> qgrid</span><br><span class="line"><span class="comment"># qgrid.show_grid(df, show_toolbar=True)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"><span class="comment"># ignore warning info</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># sns.set_style("white")</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.style.use('ggplot')</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># interactive visualization</span></span><br><span class="line"><span class="keyword">from</span> bokeh.palettes <span class="keyword">import</span> Spectral11</span><br><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_notebook, show</span><br><span class="line"><span class="keyword">from</span> bokeh.models <span class="keyword">import</span> LinearAxis, Range1d</span><br><span class="line">output_notebook()</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse, sys, os, errno</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,format=<span class="string">"%(levelname)s-%(filename)s:[%(lineno)d]-%(message)s"</span>)</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之正则表达式系统梳理</title>
    <link href="http://showteeth.tech/posts/28940.html"/>
    <id>http://showteeth.tech/posts/28940.html</id>
    <published>2019-08-23T03:15:01.000Z</published>
    <updated>2019-09-28T02:36:51.572Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">正则表达式学习</a></li><li><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">正则表达式在线练习</a></li><li><a href="http://aandds.com/blog/lang-regex.html" target="_blank" rel="noopener">Regular Expressions</a></li><li><a href="https://juejin.im/post/5b4a9539f265da0f521de210" target="_blank" rel="noopener">正则中关于环视（lookaround）的小例子</a></li><li><a href="https://zhuanlan.zhihu.com/p/50789818" target="_blank" rel="noopener">正则表达式中 Lookaround</a></li><li><a href="http://www.ayqy.net/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">正则表达式学习笔记</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之grep进阶</title>
    <link href="http://showteeth.tech/posts/5793.html"/>
    <id>http://showteeth.tech/posts/5793.html</id>
    <published>2019-08-22T12:52:16.000Z</published>
    <updated>2019-08-22T15:41:40.762Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对学习中经常遇到的几种情况：<strong>允许mismatch的grep</strong>、<strong>加速grep</strong>、<strong>管道grep高亮</strong>等问题，探索了一些解决方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>针对以下需求：</p><ul><li><code>grep</code>仅支持<strong>完全的匹配</strong>，如果想要进行<strong>支持mismatch的操作</strong>，该怎么办？</li><li>常规的<code>grep</code>在进行大文件的查找时很慢，如果<strong>加速这种查找</strong>？</li><li><code>grep</code>加入管道之后，查找出来的<strong>字符就不高亮</strong>了，如何解决？</li></ul><hr><h2 id="允许mismatch的grep"><a href="#允许mismatch的grep" class="headerlink" title="允许mismatch的grep"></a>允许mismatch的grep</h2><h3 id="agrep工具"><a href="#agrep工具" class="headerlink" title="agrep工具"></a>agrep工具</h3><p><code>agrep</code>命令简介：</p><blockquote><p>AGREP is a powerful tool for <strong>fast searching</strong> a file or many files for a <strong>string or regular expression</strong>, with <strong>approximate matching</strong> capabilities and <strong>user-definable records</strong>. AGREP is similar to egrep (or grep or fgrep), but it is <strong>much more general</strong> and usually <strong>faster</strong>. Approximate matching allows finding records that <strong>contain the pattern</strong> with several errors including <strong>substitutions</strong>, <strong>insertions</strong>, and <strong>deletions</strong>.</p></blockquote><h4 id="agrep安装"><a href="#agrep安装" class="headerlink" title="agrep安装"></a>agrep安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget ftp://ftp.cs.arizona.edu/agrep/agrep-2.04.tar</span><br><span class="line"><span class="comment"># 提取文件</span></span><br><span class="line">tar -xvf  agrep-2.04.tar</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 写入环境变量</span></span><br></pre></td></tr></table></figure><hr><h4 id="agrep命令格式及相关参数"><a href="#agrep命令格式及相关参数" class="headerlink" title="agrep命令格式及相关参数"></a>agrep命令格式及相关参数</h4><p>命令格式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agrep [ -<span class="comment">#cdehiklnpstvwxBDGIS ] pattern [ -f patternfile ] [ filename... ]</span></span><br></pre></td></tr></table></figure><p></p><p>相关参数：</p><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td>-#</td><td>find matches with at most # errors</td></tr><tr><td>-c</td><td>output the number of matched records</td></tr><tr><td>-d</td><td>define record delimiter</td></tr><tr><td>-h</td><td>do not output file names</td></tr><tr><td>-i</td><td>case-insensitive search, e.g., 'a' = 'A'</td></tr><tr><td>-l</td><td>output the names of files that contain a match</td></tr><tr><td>-n</td><td>output record prefixed by record number</td></tr><tr><td>-v</td><td>output those records containing no matches</td></tr><tr><td>-w</td><td>pattern has to match as a word, e.g., 'win' will not match 'wind'</td></tr><tr><td>-B</td><td>best match mode. find the closest matches to the pattern</td></tr><tr><td>-G</td><td>output the files that contain a match</td></tr><tr><td>-D<span style="font-style:italic">k</span></td><td>Set the cost of a deletion to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr><tr><td>-I<span style="font-style:italic">k</span></td><td>Set the cost of an insertion to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr><tr><td>-S<span style="font-style:italic">k</span></td><td>Set the cost of a substitution to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr></table><hr><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><hr><h4 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h4><p>近似匹配直接使用<code>-num</code>开启，其中<code>num</code>表示<code>mismatch</code>的个数，最终输出的结果是<code>mismatch&lt;=num</code>的行。</p><p>允许<strong>一个</strong>mimatch：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'ABCDEFG'</span> test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>允许<strong>两个</strong>mimatch：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">agrep -2 <span class="string">'ABCDEFG'</span> test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="设置罚分"><a href="#设置罚分" class="headerlink" title="设置罚分"></a>设置罚分</h4><p>测试文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p><strong>不设置</strong>罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>设置<strong>增加deletion</strong>的罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deletiond 的罚分增加到2</span></span><br><span class="line"><span class="comment"># 这样将会去除deletion的匹配</span></span><br><span class="line">agrep -1 -D2 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>设置<strong>增加deletion、insertion</strong>的罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deletiond、insertion的罚分增加到2</span></span><br><span class="line"><span class="comment"># 这样将会去除deletion、insertion的匹配</span></span><br><span class="line">agrep -1 -D2 -I2 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="结合正则表达式"><a href="#结合正则表达式" class="headerlink" title="结合正则表达式"></a>结合正则表达式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'abc[0-9](de|fg)*[x-z]'</span> foo</span><br></pre></td></tr></table></figure><p>Outputs the lines containing, <strong>within up to one error</strong>, the string that starts with “abc” followed by one digit, followed by zero or more repetitions of either “de” or “fg”, followed by either “x”, “y”, or “z”.</p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.biostars.org/p/4346/" target="_blank" rel="noopener">Question: Matching Strings With Mismatches</a></li><li><a href="https://github.com/Wikinaut/agrep" target="_blank" rel="noopener">github链接</a></li><li><a href="https://linux.die.net/man/1/agrep" target="_blank" rel="noopener">agrep(1) - Linux man page</a></li><li><a href="https://www.computerhope.com/unix/agrep.htm" target="_blank" rel="noopener">Linux agrep command-使用实例</a></li></ul><hr><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul><li><a href="https://github.com/laurikari/tre" target="_blank" rel="noopener">tre-The approximate regex matching library and agrep command line tool.</a></li><li><a href="https://metacpan.org/release/LIMAONE/Bio-Grep-v0.10.6" target="_blank" rel="noopener">Bio::Grep-perl module</a></li></ul><hr><p><br></p><h2 id="加速grep操作"><a href="#加速grep操作" class="headerlink" title="加速grep操作"></a>加速grep操作</h2><h3 id="parallel命令"><a href="#parallel命令" class="headerlink" title="parallel命令"></a>parallel命令</h3><p>结合之前学习了<a href="http://showteeth.tech/posts/25074.html">parallel命令</a>的<code>--pipe</code>模式对<code>grep</code>进行加速：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未进行优化的grep</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz | grep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line"></span><br><span class="line">  real    2m3.063s</span><br><span class="line">  user    2m14.375s</span><br><span class="line">  sys     0m10.078s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用parallel命令</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |parallel --pipe --block 1M --roundrobin --<span class="built_in">jobs</span> 10 grep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line">  real    2m53.983s</span><br><span class="line">  user    2m57.954s</span><br><span class="line">  sys     0m24.801s</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="优化grep"><a href="#优化grep" class="headerlink" title="优化grep"></a>优化grep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化后的grep</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz | LC_ALL=C fgrep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line"></span><br><span class="line">  real    2m12.462s</span><br><span class="line">  user    2m24.124s</span><br><span class="line">  sys     0m11.276s</span><br></pre></td></tr></table></figure><ul><li>Prefix your grep command with <code>LC_ALL=C</code> to use the <code>C locale</code> instead of <code>UTF-8</code>.</li><li>Use <code>fgrep</code> because you’re searching for a <code>fixed string</code>, not a regular expression.</li></ul><hr><h3 id="使用ripgrep"><a href="#使用ripgrep" class="headerlink" title="使用ripgrep"></a>使用ripgrep</h3><p>安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/BurntSushi/ripgrep/releases/download/11.0.2/ripgrep-11.0.2-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf  ripgrep-11.0.2-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ripgrep-11.0.2-x86_64-unknown-linux-musl</span><br><span class="line"></span><br><span class="line">./rg --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |/Share2/home/wangjb/songyabing/software/ripgrep-11.0.2-x86_64-unknown-linux-musl/rg <span class="string">"GTGAGATAGGAA"</span> dev/null</span><br><span class="line">  real    2m12.286s</span><br><span class="line">  user    2m26.400s</span><br><span class="line">  sys     0m12.404s</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用agrep"><a href="#使用agrep" class="headerlink" title="使用agrep"></a>使用agrep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |/Share2/home/wangjb/songyabing/software/agrep-2.04/agrep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line">  real    2m12.551s</span><br><span class="line">  user    2m26.266s</span><br><span class="line">  sys     0m10.803s</span><br></pre></td></tr></table></figure><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/9066609/fastest-possible-grep/9067042" target="_blank" rel="noopener">Fastest possible grep</a></li><li><a href="https://stackoverflow.com/questions/13913014/grepping-a-huge-file-80gb-any-way-to-speed-it-up" target="_blank" rel="noopener">Grepping a huge file (80GB) any way to speed it up?</a></li><li><a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">ripgrep recursively searches directories for a regex pattern</a></li><li><a href="https://github.com/chinanf-boy/ripgrep-zh#%E6%9B%B4%E6%96%B0-" target="_blank" rel="noopener">ripgrep 是一个面向行的搜索工具</a></li></ul><div class="note info"><p>虽然大部分的网站都给出了上述几种加速的方法，但是<strong>实际测试之后发现效果并不是很好</strong>，难道是不适用我这种情况？后续再看看吧。</p></div><hr><p><br></p><h2 id="管道grep高亮"><a href="#管道grep高亮" class="headerlink" title="管道grep高亮"></a>管道grep高亮</h2><p>使用<code>--color=always</code>参数可以使grep的结果<strong>一直保持高亮</strong>，不管处于管道的什么位置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat test2.txt|grep --color=always <span class="string">"ABCD"</span> |more </span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章针对学习中经常遇到的几种情况：&lt;strong&gt;允许mismatch的grep&lt;/strong&gt;、&lt;strong&gt;加速grep&lt;/strong&gt;、&lt;strong&gt;管道grep高亮&lt;/strong&gt;等问题，探索了一些解决方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之parallel-并行化工具</title>
    <link href="http://showteeth.tech/posts/25074.html"/>
    <id>http://showteeth.tech/posts/25074.html</id>
    <published>2019-08-18T09:36:41.000Z</published>
    <updated>2019-08-24T08:06:53.438Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中强大的并行工具<code>parallel</code>，其主要有<strong>两种工作模式</strong>：给<strong>命令传递参数</strong>以及<strong>管道模式(<code>--pipe</code>参数)</strong>，在实际使用中其主要作用在于<strong>改写for循环、减少重复性的操作</strong>。</p></div><a id="more"></a><h2 id="parallel介绍"><a href="#parallel介绍" class="headerlink" title="parallel介绍"></a>parallel介绍</h2><p><a href="https://www.gnu.org/software/parallel/" target="_blank" rel="noopener">官网介绍</a>：</p><blockquote><p>GNU parallel is a shell tool for <strong>executing jobs in parallel using one or more computers</strong>. A job can be a <strong>single command</strong> or <strong>a small script</strong> that has to be <strong>run for each of the lines in the input</strong>. The typical input is <strong>a list of files</strong>, <strong>a list of hosts</strong>, <strong>a list of users</strong>, <strong>a list of URLs</strong>, or <strong>a list of tables</strong>. A job can also be a command that <strong>reads from a pipe</strong>. GNU parallel can then <strong>split the input and pipe it into commands in parallel</strong>.</p><p>If you use <strong>xargs</strong> and tee today you will find GNU parallel very easy to use as GNU parallel is written to <strong>have the same options as xargs</strong>. If you write <strong>loops in shell</strong>, you will find GNU parallel may be able to <strong>replace most of the loops and make them run faster</strong> by running several jobs in parallel.</p><p>GNU parallel makes sure output from the commands is the same output as you would get had you run the commands sequentially. This makes it possible to use output from GNU parallel as input for other programs.</p><p>For each line of input GNU parallel will execute command with the line as arguments. If no command is given, the line of input is executed. Several lines will be run in parallel. <strong>GNU parallel can often be used as a substitute for xargs or cat | bash.</strong></p></blockquote><hr><p><br></p><h2 id="安装parallel"><a href="#安装parallel" class="headerlink" title="安装parallel"></a>安装parallel</h2><p>parallel并不是系统自带的命令，所以需要先下载安装才可以正常使用，这里是<strong>非root</strong>下的下载安装过程，root下要简单很多，具体的<a href="https://ftp.gnu.org/gnu/parallel/" target="_blank" rel="noopener">下载地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/parallel/parallel-20190722.tar.bz2</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -jxvf parallel-20190722.tar.bz2</span><br><span class="line"><span class="comment"># 为编译做准备</span></span><br><span class="line">./configure --prefix=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 测试安装是否成功</span></span><br><span class="line"><span class="built_in">cd</span> bin </span><br><span class="line">./parallel --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑环境变量</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="parallel命令格式"><a href="#parallel命令格式" class="headerlink" title="parallel命令格式"></a>parallel命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"><span class="comment"># 模式一：传递参数给command</span></span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] &lt; list_of_arguments</span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] (::: arguments|:::: argfile(s))...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式二：pipe模式，给command传递stdin</span></span><br><span class="line">cat ... | parallel --pipe [options] [<span class="built_in">command</span> [arguments]]</span><br></pre></td></tr></table></figure><h2 id="parallel使用示例"><a href="#parallel使用示例" class="headerlink" title="parallel使用示例"></a>parallel使用示例</h2><h3 id="参数输入方式"><a href="#参数输入方式" class="headerlink" title="参数输入方式"></a>参数输入方式</h3><h4 id="命令行输入"><a href="#命令行输入" class="headerlink" title="命令行输入"></a>命令行输入</h4><p><code>tee命令</code>：<code>Linux tee</code>命令将<strong>数据重定向到文件</strong>，<strong>另一方面</strong>还可以提供一份重定向数据的副本<strong>作为后续命令的stdin</strong>。简单的说就是<strong>把数据重定向到给定文件和屏幕上。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个输入源</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: a b c d e |tee test.txt</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p>第一次使用还会输出引用的提示：</p><blockquote><p>Academic tradition requires you to cite works you base your article on.<br>If you use programs that use GNU Parallel to process data for an article in a<br>scientific publication, please cite:</p><p>O. Tange (2018): GNU Parallel 2018, Mar 2018, ISBN 9781387509881,<br>DOI <a href="https://doi.org/10.5281/zenodo.1146014" target="_blank" rel="noopener">https://doi.org/10.5281/zenodo.1146014</a></p><p>This helps funding further development; AND IT WON’T COST YOU A CENT.<br>If you pay 10000 EUR you should feel free to use GNU Parallel without citing.</p><p>More about funding GNU Parallel and the citation notice:<br><a href="https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice" target="_blank" rel="noopener">https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice</a></p><p>To silence this citation notice: run ‘parallel –citation’ once.</p></blockquote><hr><h4 id="管道输入"><a href="#管道输入" class="headerlink" title="管道输入"></a>管道输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt |parallel <span class="built_in">echo</span></span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><hr><h4 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用重定向符号进行文件输入</span></span><br><span class="line">parallel <span class="built_in">echo</span> &lt; test.txt </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::输入文件</span></span><br><span class="line">parallel <span class="built_in">echo</span> :::: test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="组合输入的信息"><a href="#组合输入的信息" class="headerlink" title="组合输入的信息"></a>组合输入的信息</h3><p>将输入的信息进行组合，需要指定<strong>多个输入源</strong>，指定多个输入源的方法主要包括：</p><ul><li><strong>多个命令行形式</strong>的输入源</li><li><strong>多个文件形式(-a参数或者::::)</strong>的输入源</li><li><strong>命令行、管道和文件形式的输入源组合</strong></li></ul><h4 id="命令行输入-1"><a href="#命令行输入-1" class="headerlink" title="命令行输入"></a>命令行输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parallel <span class="built_in">echo</span> ::: a b c ::: a b c</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  c a</span><br><span class="line">  c b</span><br><span class="line">  c c</span><br></pre></td></tr></table></figure><hr><h4 id="文件输入-1"><a href="#文件输入-1" class="headerlink" title="文件输入"></a>文件输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意下面两种方法的echo位置</span></span><br><span class="line">parallel -a test.txt -a test2.txt  <span class="built_in">echo</span></span><br><span class="line">parallel <span class="built_in">echo</span> :::: test.txt test2.txt</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  a d</span><br><span class="line">  a e</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><div class="note info"><p>当使用<code>-a</code>传递文件作为参数的时候，<code>-a</code>作为<code>parallel</code>的<strong>参数</strong>在<code>echo</code>命令<strong>前面</strong>；而直接使用<code>::::</code>传递文件作为输入的时候，文件作为<code>arguments</code>在<code>command</code>的<strong>后面</strong>。</p></div><hr><h4 id="混合输入"><a href="#混合输入" class="headerlink" title="混合输入"></a>混合输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a指定文件和管道的组合</span></span><br><span class="line">cat test.txt |parallel -a - -a test2.txt <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::指定文件和管道的组合</span></span><br><span class="line">cat test.txt |parallel <span class="built_in">echo</span> ::::  - test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::指定文件和:::指定命令行的组合</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: a b :::: test.txt</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  a d</span><br><span class="line">  a e</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  b d</span><br><span class="line">  b e</span><br></pre></td></tr></table></figure><hr><h3 id="取消输入的组合"><a href="#取消输入的组合" class="headerlink" title="取消输入的组合"></a>取消输入的组合</h3><p>如果<strong>不想在进行多个输入源的输入时出现的组合现象</strong>，可以使用<code>--xapply</code>指定从<strong>每个输入源中获取一个参数(或一行)</strong>，<strong>较短的输入源会进行重复直到较长的输入源全部输出</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个输入源长度相同</span></span><br><span class="line">parallel --xapply <span class="built_in">echo</span> ::: a b c ::: d e f </span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个输入源长度不同，较短的重复至较长的输出完</span></span><br><span class="line">parallel --xapply <span class="built_in">echo</span> ::: a b c ::: d e f g h</span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line">  a g</span><br><span class="line">  b h</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数分隔符"><a href="#指定参数分隔符" class="headerlink" title="指定参数分隔符"></a>指定参数分隔符</h3><p>在进行命令行参数输入时，如果遇到<code>:::</code>或<code>::::</code>被占用时，可以使用<code>--arg-sep</code>和<code>--arg-file-sep</code>分别指定命令行和文件的参数分隔符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定命令行的参数分隔符</span></span><br><span class="line">parallel --xapply --arg-sep ,,, <span class="built_in">echo</span> ,,, a b c ,,, d e f g h</span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line">  a g</span><br><span class="line">  b h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件的参数分隔符</span></span><br><span class="line">parallel --arg-file-sep ,,, <span class="built_in">echo</span> ,,, test.txt </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数定界符"><a href="#指定参数定界符" class="headerlink" title="指定参数定界符"></a>指定参数定界符</h3><p>默认的参数定界符为<code>\n</code>，也就是把<strong>每一行当做一个参数</strong>，可以通过参数<code>-d</code>来<strong>改变参数定界符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变参数定界符为\t</span></span><br><span class="line">paste test.txt  test2.txt |parallel -d <span class="string">"\t"</span> <span class="built_in">echo</span> :::: - </span><br><span class="line">  a</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数结束值"><a href="#指定参数结束值" class="headerlink" title="指定参数结束值"></a>指定参数结束值</h3><p><code>Parallel</code>支持通过<code>-E</code>参数<strong>指定一个值做为结束标志</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parallel -E stop <span class="built_in">echo</span> ::: A B stop C D</span><br><span class="line">  A</span><br><span class="line">  B</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="跳过空行"><a href="#跳过空行" class="headerlink" title="跳过空行"></a>跳过空行</h3><p><code>Parallel</code>使用 <code>--no-run-if-empty</code> 来跳过空行:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> 1; <span class="built_in">echo</span>; <span class="built_in">echo</span> 2) | parallel --no-run-if-empty <span class="built_in">echo</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对输入参数进行替换"><a href="#对输入参数进行替换" class="headerlink" title="对输入参数进行替换"></a>对输入参数进行替换</h3><p>Parallel支持多种方式来对输入的参数进行字符串替换，默认使用的是符号是 <code>{}</code>，也就是<strong>输出原始输入，没有任何替换(占位符)</strong>。其<strong>最常见的字符串替换</strong>如下：</p><ul><li><code>{.}</code>: 去掉<strong>扩展名</strong>；</li><li><code>{/}</code>: <strong>去掉路径</strong>，只<strong>保留文件名</strong>；</li><li><code>{//}</code>: 只<strong>保留路径</strong>；</li><li><code>{/.}</code>: <strong>同时去掉路径和扩展名</strong>；</li><li><code></code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入是A目录下存在B.C这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数-I来改变默认的占位符符号&#123;&#125;</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: A/B.C ; parallel <span class="built_in">echo</span> &#123;&#125; ::: A/B.C ; parallel -I ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉输出参数中包括的拓展名信息</span></span><br><span class="line"><span class="comment"># 将默认的&#123;.&#125;替换为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;.&#125; ::: A/B.C ; parallel --extensionreplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  A/B</span><br><span class="line">  A/B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中包括的文件名信息，和basename命令作用相同</span></span><br><span class="line"><span class="comment"># 将默认的&#123;/&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;/&#125; ::: A/B.C ; parallel --basenamereplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  B.C</span><br><span class="line">  B.C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中包括的路径信息</span></span><br><span class="line"><span class="comment"># 将默认的&#123;//&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;//&#125; ::: A/B.C ; parallel --dirnamereplace ,, <span class="built_in">echo</span> ,, ::: A/B.C </span><br><span class="line">  A</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中的文件名信息(不包括后缀)</span></span><br><span class="line"><span class="comment"># 将默认的&#123;/.&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;/.&#125; ::: A/B.C ; parallel --basenameextensionreplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  B</span><br><span class="line">  B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入并行的任务编号</span></span><br><span class="line"><span class="comment"># 将默认的&#123;#&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;<span class="comment">#&#125; ::: A B C ; parallel --seqreplace ,, echo ,, ::: A B C</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><hr><h3 id="指定输入源输出顺序"><a href="#指定输入源输出顺序" class="headerlink" title="指定输入源输出顺序"></a>指定输入源输出顺序</h3><p>如果有多个输入源时，可以通过 <code>{编号}</code> <strong>代指某一个输入源的参数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;1&#125;表示输入源1中的内容，&#123;2&#125;表示输入源2中的内容</span></span><br><span class="line">parallel --xapply  <span class="built_in">echo</span> &#123;1&#125; and &#123;2&#125; ::: A B ::: C D;parallel --xapply  <span class="built_in">echo</span> &#123;2&#125; and &#123;1&#125; ::: A B ::: C D</span><br><span class="line">  A and C</span><br><span class="line">  B and D</span><br><span class="line">  C and A</span><br><span class="line">  D and B</span><br></pre></td></tr></table></figure><p></p><p>输入源也可以使用<strong>负数指定，表示倒着数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parallel <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; -1=&#123;-1&#125; -2=&#123;-2&#125; ::: A B ::: C D</span><br><span class="line">  1=A 2=C -1=C -2=A</span><br><span class="line">  1=A 2=D -1=D -2=A</span><br><span class="line">  1=B 2=C -1=C -2=B</span><br><span class="line">  1=B 2=D -1=D -2=B</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数名和参数"><a href="#指定参数名和参数" class="headerlink" title="指定参数名和参数"></a>指定参数名和参数</h3><p>使用 <code>--header</code>指定每一行输入中的第一个值做为参数名:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parallel --xapply --header : <span class="built_in">echo</span> f1=&#123;f1&#125; f2=&#123;f2&#125; ::: f1 A B ::: f2 C D | tee d.txt</span><br><span class="line">  f1=A f2=C</span><br><span class="line">  f1=B f2=D</span><br></pre></td></tr></table></figure><p></p><p>使用 <code>--colsep</code> 指定列分隔符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'printf "f1\tf2\nA\tB\nC\tD\n"'</span> &gt; tsv-file.tsv</span><br><span class="line">parallel --header : --colsep <span class="string">'\t'</span> <span class="built_in">echo</span> f1=&#123;f1&#125; f2=&#123;f2&#125; :::: tsv-file.tsv </span><br><span class="line">  f1=A f2=B</span><br><span class="line">  f1=C f2=D</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="背景文本"><a href="#背景文本" class="headerlink" title="背景文本"></a>背景文本</h3><p>占位符<code>{}</code>可以是<strong>输出字符的一部分</strong>，使用<code>-m</code>参数表示<strong>每个jobs不重复输出背景文本(除去替换字符串之外的字符内容)</strong>，而<code>-X</code>参数与<code>-m</code>参数<strong>功能相反</strong>，会在<strong>每个jobs中都输出背景文本</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下是会输出背景文本的</span></span><br><span class="line"><span class="comment"># 并且每个参数输出一行</span></span><br><span class="line">parallel  --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A-post</span><br><span class="line">  pre-B-post</span><br><span class="line">  pre-C-post</span><br><span class="line">  pre-D-post</span><br><span class="line">  pre-E-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-m参数取消在每个jobs中输出背景文本</span></span><br><span class="line"><span class="comment"># 并且同一个jobs中的参数在同一行输出</span></span><br><span class="line">parallel -m --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A B-post</span><br><span class="line">  pre-C D-post</span><br><span class="line">  pre-E-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-X参数指定在每个jobs中输出背景文本</span></span><br><span class="line"><span class="comment"># 并且同一个jobs中的参数在同一行输出</span></span><br><span class="line">parallel -X --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A-post pre-B-post</span><br><span class="line">  pre-C-post pre-D-post</span><br><span class="line">  pre-E-post</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="限制每次读取的参数个数"><a href="#限制每次读取的参数个数" class="headerlink" title="限制每次读取的参数个数"></a>限制每次读取的参数个数</h3><p><code>parallel</code>使用 <code>-N</code> 限制每次参数的个数，其中<code>-N0</code>表示一次<strong>只读取一个参数，且不输入这个参数（作为计数器来使用）</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次读取四个参数，并将所有读取的参数输出</span></span><br><span class="line"><span class="comment"># 相当于依次把数据分成了四个源，然后进行不带组合的输出</span></span><br><span class="line">parallel -N 4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125; 4=&#123;4&#125; ::: A B C D E F G H</span><br><span class="line">  1=A 2=B 3=C 4=D</span><br><span class="line">  1=E 2=F 3=G 4=H</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次读取四个参数，只输出其中的一部分参数</span></span><br><span class="line">parallel -N 4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125;  ::: A B C D E F G H</span><br><span class="line">  1=A 2=B 3=C</span><br><span class="line">  1=E 2=F 3=G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当做计数器使用，不会输出后续的参数</span></span><br><span class="line">parallel -N 0 <span class="built_in">echo</span> &#123;&#125;_foo ::: A B C</span><br><span class="line">  _foo</span><br><span class="line">  _foo</span><br><span class="line">  _foo</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="去除输入参数的空格"><a href="#去除输入参数的空格" class="headerlink" title="去除输入参数的空格"></a>去除输入参数的空格</h3><p><code>parallel</code>使用<code>--trim</code>去除参数两头的空格，其有三种模式，去除左边的空格(<code>--trim l</code>)、右边的空格(<code>--trim r</code>)、左右的空格(<code>--trim lr</code>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除右边的空格</span></span><br><span class="line">parallel --trim r <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre- A-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除左边的空格</span></span><br><span class="line">parallel --trim l <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre-A -post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除左右两边的空格</span></span><br><span class="line">parallel --trim lr <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre-A-post</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="添加输出前缀"><a href="#添加输出前缀" class="headerlink" title="添加输出前缀"></a>添加输出前缀</h3><p><code>parallel</code>允许使用<code>--tag</code>参数来指定<strong>以参数作为输出字符的前缀</strong>，使用<code>--tagstring</code>来<strong>自定义输出前缀</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --tag：输入参数作为输出前缀</span></span><br><span class="line">parallel --tag <span class="built_in">echo</span> foo_&#123;&#125; ::: A B C</span><br><span class="line">  A       foo_A</span><br><span class="line">  B       foo_B</span><br><span class="line">  C       foo_C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改输出前缀</span></span><br><span class="line">parallel --tagstring &#123;&#125;_foo <span class="built_in">echo</span> foo_&#123;&#125; ::: A B C</span><br><span class="line">  A_foo   foo_A</span><br><span class="line">  B_foo   foo_B</span><br><span class="line">  C_foo   foo_C</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="运行之前打印命令"><a href="#运行之前打印命令" class="headerlink" title="运行之前打印命令"></a>运行之前打印命令</h3><p><code>parallel</code>使用<code>--verbose</code>参数来指定在运行命令之前先打印命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parallel --verbose <span class="built_in">echo</span> &#123;&#125; ::: A B C</span><br><span class="line">  <span class="built_in">echo</span> A</span><br><span class="line">  <span class="built_in">echo</span> B</span><br><span class="line">  <span class="built_in">echo</span> C</span><br><span class="line">  A</span><br><span class="line">  B</span><br><span class="line">  C</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="任务运行日志"><a href="#任务运行日志" class="headerlink" title="任务运行日志"></a>任务运行日志</h3><p>使用<code>--joblog</code>参数能够<strong>生成各个任务的日志文件</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parallel的运行日志为/tmp/log</span></span><br><span class="line">parallel --joblog /tmp/<span class="built_in">log</span> <span class="built_in">exit</span>  ::: 1 2 3 0</span><br><span class="line">cat /tmp/<span class="built_in">log</span> </span><br><span class="line">  Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">  1   :   1523950890.344       0.018  0   0   1   0   <span class="built_in">exit</span> 1</span><br><span class="line">  2   :   1523950890.350       0.014  0   0   2   0   <span class="built_in">exit</span> 2</span><br><span class="line">  3   :   1523950890.357       0.006  0   0   3   0   <span class="built_in">exit</span> 3</span><br><span class="line">  4   :   1523950890.363       0.006  0   0   0   0   <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p><strong>运行失败任务</strong>处理：</p><ul><li>通过<code>--resume-failed</code>参数可以重新运行失败的任务;</li><li><code>--retry-failed</code>的作用与<code>--resume-failed</code>类似，只是<code>--resume-failed</code>从<strong>命令行</strong>读取失败任务，而<code>--retry-failed</code>则是从<strong>日志文件</strong>中读取失败任务：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从命令行读取失败任务</span></span><br><span class="line"><span class="comment"># 所以需要加载最开始的运行命令中</span></span><br><span class="line">parallel --resume-failed --joblog /tmp/<span class="built_in">log</span> <span class="built_in">exit</span>  ::: 1 2 3 0 0 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从日志文件读取失败任务</span></span><br><span class="line"><span class="comment"># 只用指定日志文件即可</span></span><br><span class="line">parallel --retry-failed --joblog /tmp/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><hr><h3 id="终止任务"><a href="#终止任务" class="headerlink" title="终止任务"></a>终止任务</h3><p><code>parallel</code>支持<strong>在某一情况下</strong>（如第一个失败或成功时，或者20%任务失败时）终止任务，终止任务又有<strong>两种类型</strong>:</p><ul><li>其一为<strong>立即终止（通过<code>--halt now</code>指定）</strong>，<strong>杀死所有正在运行</strong>的任务并停止生成新的任务;</li><li>其二为<strong>稍后终止（通过<code>--halt soon</code>指定）</strong>，停止生成新任务并<strong>等待正在运行任务完成</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在遇到一个失败任务之后待正在运行的任务完成就终止</span></span><br><span class="line">parallel -j2 --halt soon,fail=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在遇到一个失败任务之后立即终止</span></span><br><span class="line">parallel -j2 --halt now,fail=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在失败任务数达到20%之后待正在运行的任务完成就终止</span></span><br><span class="line">parallel -j2 --halt soon,fail=20% <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 1 2 3 4 5 6 7 8 9  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在成功的任务数达到1之后立即终止</span></span><br><span class="line">parallel -j2 --halt now,success=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 1 2 3 0 4 5 6</span><br></pre></td></tr></table></figure><hr><h3 id="管道模式–pipe"><a href="#管道模式–pipe" class="headerlink" title="管道模式–pipe"></a>管道模式–pipe</h3><p>前面学习的所有内容基本都是<strong>传参数模式</strong>，也就是不管是从文件还是命令行获取输入，都会作为命令的参数；而使用<code>--pipe</code>模式之后则会将<strong>管道前面的内容作为标准输入传给后面的命令</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_large_log   |parallel --pipe grep pattern</span><br></pre></td></tr></table></figure><p></p><p>如果不加 <code>--pipe</code> ，相当于 <code>my_large_log</code>中的<strong>每一行</strong>都变成 <code>grep pattern line</code>的命令展开了；而加入了<code>--pipe</code>，则和 <code>cat my_large_log | grep pattern</code> 没有区别，只是分配到各个核上去执行了。</p><p>具体的，<code>--pipe</code>参数会<strong>将输入(stdin)分为多个block</strong>，然后<strong>分配给多个核运行</strong>，具体的过程：</p><blockquote><p>command_A | command_B. By default GNU parallel will start an instance of command_B, read a chunk of 1 MB, and pass that to the instance. Then start another instance, read another chunk, and pass that to the second instance.</p></blockquote><p>可以使用<code>--block</code>参数可以指定每块的大小，<strong>默认为1M(The size of the chunk is not exactly 1 MB because GNU parallel only passes full lines - never half a line, thus the blocksize is only 1 MB on average.)</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并行计算文件行数</span></span><br><span class="line">cat num30000 | parallel --pipe wc -l</span><br><span class="line">  30000 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置block大小为100k</span></span><br><span class="line">cat num30000 | parallel --block 100k  --pipe wc -l </span><br><span class="line">  18517</span><br><span class="line">  11483</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用原始方法计算</span></span><br><span class="line">wc -l num30000</span><br><span class="line">  30000 num30000</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>输出结果的顺序不重要</strong>，可以使用<code>--roundrobin</code>参数，并且结合<code>--jobs</code>参数指定任务，那么所有的block就会在指定的任务数中执行，某个提前运行完了就会接着运行下一个(或者一部分)，这样更加均衡；如果不加<code>--roundrobin</code>参数，每个block都会开启一个任务，不会管均衡不均衡。</p><hr><p><br></p><h2 id="parallel相关实战"><a href="#parallel相关实战" class="headerlink" title="parallel相关实战"></a>parallel相关实战</h2><h3 id="改写for循环"><a href="#改写for循环" class="headerlink" title="改写for循环"></a>改写for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始的for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *jpeg</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  convert <span class="variable">$i</span> <span class="variable">$i</span>.png </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改写后的命令行</span></span><br><span class="line"><span class="comment"># --max-args表示每次读取的参数个数，使用-N2也是一样的效果</span></span><br><span class="line"><span class="comment"># -I修改了占位符</span></span><br><span class="line">find . -name <span class="string">"*jpeg"</span> | parallel -I % --max-args 1 convert % %.png</span><br></pre></td></tr></table></figure><h3 id="一次传入多个参数"><a href="#一次传入多个参数" class="headerlink" title="一次传入多个参数"></a>一次传入多个参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意需要将&gt;使用引号括起来，不然得到的结果是所有的文件保存到了&#123;1&#125;_&#123;2&#125;.person中</span></span><br><span class="line">ls -1 | parallel --max-args=2 cat &#123;1&#125; &#123;2&#125; <span class="string">"&gt;"</span> &#123;1&#125;_&#123;2&#125;.person</span><br><span class="line"><span class="comment"># 使用-N2也是一样的效果</span></span><br><span class="line">ls -1 | parallel -N2 cat &#123;1&#125; &#123;2&#125; <span class="string">"&gt;"</span> &#123;1&#125;_&#123;2&#125;.png</span><br></pre></td></tr></table></figure><hr><h3 id="负载管理"><a href="#负载管理" class="headerlink" title="负载管理"></a>负载管理</h3><p>关于<a href="https://www.cnblogs.com/muahao/p/6492665.html" target="_blank" rel="noopener">cpu负载</a>：</p><blockquote><p>单核单CPU：如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。<br>单核多CPU：2个CPU，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍；所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。<br>多CPU多核：在系统负荷方面，多核CPU与多CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过1.0，就表明电脑正常运行。</p></blockquote><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parallel --eta -j 2 --load 80% --noswap \</span><br><span class="line">  <span class="string">'blastp -db pdb_blast_db_example/pdb_seqres.txt -query &#123;&#125; \</span></span><br><span class="line"><span class="string">  -out blastp_outfiles/&#123;.&#125;.out -evalue 0.0001 -word_size 7 -outfmt "6 std stitle staxids sscinames" \</span></span><br><span class="line"><span class="string">  -max_target_seqs 10 -num_threads 1'</span> \</span><br><span class="line">  ::: test_seq*.fas</span><br></pre></td></tr></table></figure><p></p><p>其中：</p><ul><li><code>--eta</code>：显示任务完成的预计剩余时间；</li><li><code>-j 2</code>或<code>-jobs 2</code>：同时运行的命令数，在本例中设置为2；</li><li><code>--load 80%</code>：<strong>最大cpu负载</strong>；在上面的命令中，我们指定最多可以运行80％的CPU</li><li><code>--noswap</code>：如果服务器处于大量<strong>内存负载</strong>下，则<strong>不会启动新作业</strong>，以便在存储新信息之前从内存中删除信息。</li></ul><p>其他：</p><ul><li><code>--memfree 1G</code>：内存只有内存满足时才启动任务，Additionally, GNU parallel will kill off the <strong>youngest job if the memory free falls below 50% of the size</strong>. The killed job will put back on the queue and retried later.</li></ul><hr><h3 id="对脚本进行parallel"><a href="#对脚本进行parallel" class="headerlink" title="对脚本进行parallel"></a>对脚本进行parallel</h3><p>创建<code>python</code>脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"the input num of arguments is \t:%s"</span> %str(len(sys.argv)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br></pre></td></tr></table></figure><p></p><p>运行<code>parallel</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">parallel python parallel.py ::: a b c d e</span><br><span class="line">  <span class="comment"># 发现每次输出的参数格式都是2，说明是并行运行的，不是串行的</span></span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  d</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  a</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  b</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  c</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接运行python</span></span><br><span class="line">python parallel.py a b c d e</span><br><span class="line">  the input num of arguments is   :6</span><br><span class="line">  parallel.py</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.gnu.org/software/parallel/parallel_tutorial.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.youtube.com/watch?v=OpaiGYxkSuQ&amp;list=PL284C9FF2488BC6D1" target="_blank" rel="noopener">官方操作视频</a></li><li><a href="https://linux.cn/article-9718-1.html" target="_blank" rel="noopener">使用 GNU Parallel 提高 Linux 命令行执行效率</a></li><li><a href="http://blog.sciencenet.cn/blog-3353749-1130387.html" target="_blank" rel="noopener">强大的并行工具 GNU Parallel</a></li><li><a href="https://www.jianshu.com/p/cc54a72616a1" target="_blank" rel="noopener">Linux下的并行神器——parallel</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中强大的并行工具&lt;code&gt;parallel&lt;/code&gt;，其主要有&lt;strong&gt;两种工作模式&lt;/strong&gt;：给&lt;strong&gt;命令传递参数&lt;/strong&gt;以及&lt;strong&gt;管道模式(&lt;code&gt;--pipe&lt;/code&gt;参数)&lt;/strong&gt;，在实际使用中其主要作用在于&lt;strong&gt;改写for循环、减少重复性的操作&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Mac远程连接Windows</title>
    <link href="http://showteeth.tech/posts/11103.html"/>
    <id>http://showteeth.tech/posts/11103.html</id>
    <published>2019-08-17T06:29:26.000Z</published>
    <updated>2019-08-24T16:02:19.970Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了<strong>在mac上远程连接windows</strong>进行的设置。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近新购置了一台mac笔记本，但是因为之前使用的windows，并且很多资料都在windows上，所以迁移可能会花一点时间，所以就想先用mac，在遇到资料的时候直接远程windows获取资料即可。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里使用的工具是<code>Windows</code>官方为<code>Mac OS X</code>系统打造的远程连接<code>Windows</code>的软件，名字叫做<code>Microsoft Remote Desktop</code>，<a href="https://rink.hockeyapp.net/apps/5e0c144289a51fca2d3bfa39ce7f2b06/" target="_blank" rel="noopener">下载地址</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先是安装软件，这一步没啥问题直接跳过。</p><hr><h3 id="设置windows"><a href="#设置windows" class="headerlink" title="设置windows"></a>设置windows</h3><p>此电脑—&gt;属性—&gt;远程设置—&gt;远程—&gt;允许远程连接到此计算机。</p><hr><h3 id="添加windows"><a href="#添加windows" class="headerlink" title="添加windows"></a>添加windows</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_1.png" alt="Remote_Desktop_1.png"></p><p>其中的<code>PC name</code>是<strong>远程windows的IP地址</strong>，具体可以通过如下方式查看：</p><ul><li>打开<code>cmd</code></li><li>输入<code>ipconfig</code></li><li><code>IPv4 地址</code>即为这里需要填写的<code>PC name</code>信息</li></ul><p>其中的<code>friendly name</code>就是<code>Microsoft Remote Desktop</code>显示的远程桌面名称。</p><hr><h3 id="连接远程windows"><a href="#连接远程windows" class="headerlink" title="连接远程windows"></a>连接远程windows</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_2.png" alt="Remote_Desktop_2.png"></p><p>正确输入windows的用户名和密码之后就可以完成连接；<strong>第一次连接会有点慢和卡顿</strong>，这是正常的，后续连接几次就正常了。</p><p>需要注意的是：<strong>一旦mac远程连接了windows，那么windows就会回到锁屏界面，如果在windows上打开锁屏界面，回到桌面，那么mac就会出现如下报错</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_3.png" alt="Remote_Desktop_3.png"></p><hr><h2 id="使用中的问题"><a href="#使用中的问题" class="headerlink" title="使用中的问题"></a>使用中的问题</h2><h3 id="mac和windows连接不同的网络报错"><a href="#mac和windows连接不同的网络报错" class="headerlink" title="mac和windows连接不同的网络报错"></a>mac和windows连接不同的网络报错</h3><p>在上述操作完成之后，如果windows和mac在同一网络下是可以正常使用的，但一旦两者连接的网络不同，就会报错：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_4.png" alt="Remote_Desktop_4.png"></p><p>上述的<a href="#%e8%ae%be%e7%bd%aewindows">设置windows</a>步骤中只是打开了服务</p><p>解决方法：<br>看着好像都需要购买域名。。。。弃！</p><hr><h3 id="添加共享目录"><a href="#添加共享目录" class="headerlink" title="添加共享目录"></a>添加共享目录</h3><p>进行如下设置：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_5.png" alt="Remote_Desktop_5.png"></p><p>得到的效果：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_6.png" alt="Remote_Desktop_6.png"></p><p>上述操作完成后就可以在mac和windows之间共享文件了，只要放在这个目录下即可。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.hudongdong.com/skill/259.html" target="_blank" rel="noopener">mac远程控制windows</a></li><li><a href="https://www.jianshu.com/p/be9d825fc4a3" target="_blank" rel="noopener">Mac如何远程控制Windows</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了&lt;strong&gt;在mac上远程连接windows&lt;/strong&gt;进行的设置。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="远程连接" scheme="http://showteeth.tech/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之添加动态链接库地址</title>
    <link href="http://showteeth.tech/posts/10801.html"/>
    <id>http://showteeth.tech/posts/10801.html</id>
    <published>2019-08-14T03:59:15.000Z</published>
    <updated>2019-08-17T01:07:16.096Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对<strong>安装Python包没有出错但是在调用的时候却出错</strong>而发现的<strong>动态链接库地址不完整</strong>的问题，通过<strong>在环境变量(<code>~/.bashrc</code>)</strong>中添加<code>LD_LIBRARY_PATH</code>地址来解决；同时也学习了使用<code>locate</code>命令来直接查找文件。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在<strong>安装Python包的时候一直很顺利</strong>，并没有出现任何错误，但是在<strong>导入包的时候却报错</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libhdf5.so<span class="number">.101</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p></p><p>错误提示是找不到动态链接库<code>libhdf5.so.101</code>，但使用<code>find ~ -name &quot;libhdf5.so.101&quot;</code>是可以找到的。。。</p><h2 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h2><p>之前一直使用的是<code>find ~ -name &quot;libhdf5.so.101&quot;</code>来查找文件，虽说已经可以满足需求，但是毕竟需要输入这么长的命令，感觉有些麻烦，刚好发现了<code>locate</code>命令可以<strong>直接搜索文件名</strong>，所以这里就使用这个进行查找文件。</p><h3 id="安装locate"><a href="#安装locate" class="headerlink" title="安装locate"></a>安装locate</h3><p>使用<code>locate</code>的时候发现集群没有安装这个命令，所以需要先安装才能使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用yum查找一下</span></span><br><span class="line">yum search locate</span><br><span class="line">  mlocate.x86_64 : An utility <span class="keyword">for</span> finding files by name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装mlocate</span></span><br><span class="line">yum  install mlocate</span><br></pre></td></tr></table></figure><p></p><p>安装<code>mlocate</code>之后，使用<code>locate</code>命令的时候提示：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate: can not <span class="built_in">stat</span> () `/var/lib/mlocate/mlocate.db<span class="string">': No such file or directory</span></span><br></pre></td></tr></table></figure><p></p><p>解决方法是使用<code>updatedb</code>命令：</p><blockquote><p>This manual page documents the GNU version of updatedb, which <strong>updates</strong><br><strong>file name databases used by GNU locate</strong>. The file name databases<br>contain lists of files that were in particular directory trees when<br>the databases <strong>were last updated</strong>. The file name of the default<br>database is determined when locate and updatedb are configured and<br>installed. <strong>The frequency with which the databases are updated and</strong><br><strong>the directories for which they contain entries depend on how often</strong><br><strong>updatedb is run, and with which arguments.</strong></p></blockquote><p>因为是第一次运行<code>updatedb</code>，所以运行的时间很长，虽然后续运行也会很久。。。</p><h3 id="使用locate命令"><a href="#使用locate命令" class="headerlink" title="使用locate命令"></a>使用locate命令</h3><p><code>updatedb</code>命令运行完成之后就可以顺利使用<code>locate</code>命令了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">locate libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hba1933b_1/lib/libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hba1933b_1/lib/libhdf5.so.101.1.0</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hc401514_3/lib/libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hc401514_3/lib/libhdf5.so.101.1.0</span><br></pre></td></tr></table></figure><p></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>回到最开始的找不到动态链接库<code>libhdf5.so.101</code>上，首先剖析出现这个问题的过程：</p><ul><li>安装的时候没有报错，说明编译是没有问题的，可以找到动态链接库<code>libhdf5.so.101</code></li><li>调用的时候报错了，说明是在程序加载过程中没有找到动态链接库<code>libhdf5.so.101</code></li></ul><p>既然是调用过程中没有找到，那么可能就是安装包的过程中没有将这个动态链接库放在<code>LD_LIBRARY_PATH</code>中(<code>LD_LIBRARY_PATH</code>环境变量用于在<strong>程序加载运行期间</strong>查找动态链接库时指定的除了系统默认路径之外的其他路径).</p><p>接下来就是查看<code>LD_LIBRARY_PATH</code>以及确认<code>libhdf5.so.101</code>不在这个路径中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span> </span><br><span class="line">  /usr/<span class="built_in">local</span>/lib:</span><br><span class="line"></span><br><span class="line">ls /usr/<span class="built_in">local</span>/lib</span><br><span class="line">  <span class="comment"># 没有出现libhdf5.so.101</span></span><br></pre></td></tr></table></figure><p></p><p>上述结果表明<code>LD_LIBRARY_PATH</code>确实是没有动态链接库<code>libhdf5.so.101</code>，那么最直接的方法就是将<code>libhdf5.so.101</code>放在<code>/usr/local/lib</code>中，但是显然不是没有人都有权限修改这个文件夹的内容的，那么就只能修改<code>LD_LIBRARY_PATH</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一劳永逸的方法是修改环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/your/custom/path/</span><br><span class="line"><span class="comment"># 使修改生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p></p><p>经过以上过程之后再次导入包发现解决了问题。</p><div class="note info"><p><a href="https://www.cnblogs.com/panfeng412/archive/2011/10/20/library_path-and-ld_library_path.html" target="_blank" rel="noopener">补充说明</a>：</p><ul><li><code>LIBRARY_PATH</code>环境变量用于在程序<strong>编译期间</strong>查找动态链接库时指定查找共享库的路径，例如，指定gcc编译需要用到的动态链接库的目录</li></ul></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/11581898/hdf5-h5py-importerror-libhdf5-so-7" target="_blank" rel="noopener">hdf5 / h5py ImportError: libhdf5.so.7</a></li><li><a href="https://stackoverflow.com/questions/13428910/how-to-set-the-environmental-variable-ld-library-path-in-linux" target="_blank" rel="noopener">How to set the environmental variable LD_LIBRARY_PATH in linux</a></li><li><a href="https://my.oschina.net/shootercn/blog/94498" target="_blank" rel="noopener">设置 Linux 的 LD_LIBRARY_PATH 变量</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章针对&lt;strong&gt;安装Python包没有出错但是在调用的时候却出错&lt;/strong&gt;而发现的&lt;strong&gt;动态链接库地址不完整&lt;/strong&gt;的问题，通过&lt;strong&gt;在环境变量(&lt;code&gt;~/.bashrc&lt;/code&gt;)&lt;/strong&gt;中添加&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;地址来解决；同时也学习了使用&lt;code&gt;locate&lt;/code&gt;命令来直接查找文件。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之查看package源代码</title>
    <link href="http://showteeth.tech/posts/33992.html"/>
    <id>http://showteeth.tech/posts/33992.html</id>
    <published>2019-08-14T03:26:05.000Z</published>
    <updated>2019-08-17T01:07:16.117Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了查看R语言中源代码的方法：首先直接<strong>输出函数名</strong>或者使用<code>page</code>函数、<code>edit</code>函数查看，一般的函数可以直接显示源代码；如果出现<code>UseMethod(&quot;mean&quot;)</code>表明是使用S3对象进行面向对象封装，此时结合<code>methods</code>函数以及<code>getAnywhere()</code>、<code>package:::function</code>查看源代码；如果出现<code>standardGeneric(&quot;chol2inv&quot;)</code>就是表明使用的<strong>S4对象进行面向对象封装</strong>，此时结合<code>showMethods</code>函数以及<code>getMethod</code>查看源代码。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做项目过程中需要使用到R(虽然之前学过R，但是很久没用，所以已经有些生疏了)，想要看某个package中函数的源代码。</p><hr><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>直接输入函数名就可以得到相应的源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lm</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="page函数"><a href="#page函数" class="headerlink" title="page函数"></a>page函数</h3><p><code>page</code>函数会<strong>打开新窗口</strong>显示源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page(lm)</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><p>edit函数会<strong>弹出新窗口</strong>显示源代码，<strong>修改完成之后可以直接保存修改</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page(lm)</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对于S3对象系统"><a href="#对于S3对象系统" class="headerlink" title="对于S3对象系统"></a>对于S3对象系统</h3><p>在<a href="http://blog.fens.me/r-class-s3/" target="_blank" rel="noopener">R的面向对象编程</a>中，有<strong>3种底层对象类型</strong>，一种是<code>S3类型</code>，一种是<code>S4类型</code>，还有一种是<code>RC类型</code>:</p><ul><li><code>S3对象</code>简单、具有动态性、结构化特征不明显；</li><li><code>S4对象</code>结构化、功能强大；</li><li><code>RC对象</code>是2.12版本后使用的新类型，用于解决S3,S4很难实现的对象。</li></ul><h4 id="S3对象特征"><a href="#S3对象特征" class="headerlink" title="S3对象特征"></a>S3对象特征</h4><p><code>S3对象</code>的特征：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mean</span><br><span class="line">  standardGeneric <span class="keyword">for</span> <span class="string">"mean"</span> defined from package <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  standardGeneric(<span class="string">"mean"</span>)</span><br><span class="line">  &lt;environment: <span class="number">0x92ef470</span>&gt;</span><br><span class="line">  Methods may be defined <span class="keyword">for</span> arguments: x</span><br><span class="line">  Use  showMethods(<span class="string">"mean"</span>)  <span class="keyword">for</span> currently available ones.</span><br></pre></td></tr></table></figure><p></p><p>出现<code>UseMethod(&quot;mean&quot;)</code>的情况就是表明使用的<strong>S3对象进行面向对象封装</strong>。</p><hr><h4 id="查看内部行为函数-methods"><a href="#查看内部行为函数-methods" class="headerlink" title="查看内部行为函数-methods"></a>查看内部行为函数-methods</h4><p>对于S3对象进行面向对象封装的函数可以使用<code>methods</code>函数<strong>查看S3对象中的定义的内部行为函数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods(mean)</span><br><span class="line">  [<span class="number">1</span>] mean,ANY-method          mean,Matrix-method       mean,sparseMatrix-method mean,sparseVector-method</span><br><span class="line">  [<span class="number">5</span>] mean.Date                mean.default             mean.difftime            mean.IDate*</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是<strong>带星号的表示the function is not exported from its package’s namespace.</strong></p><p>这里列出来的<strong>不同的mean</strong>可能是<strong>针对不同的数据类型进行不同的计算方式</strong>，比如求一个向量的平均值和求一个数据框的平均值就有所差异，就要<strong>编写多个mean函数，然后“封”起来，以一个统一的mean出现，方便使用</strong>。</p><hr><h4 id="查看源代码-getAnywhere"><a href="#查看源代码-getAnywhere" class="headerlink" title="查看源代码-getAnywhere()"></a>查看源代码-getAnywhere()</h4><p>使用<code>getAnywhere()</code> 查看源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getAnywhere(mean.default)</span><br><span class="line">  A single object matching ‘mean.default’ was found</span><br><span class="line">  It was found <span class="keyword">in</span> the following places</span><br><span class="line">    package:base</span><br><span class="line">    registered S3 method <span class="keyword">for</span> mean from namespace base</span><br><span class="line">    namespace:base</span><br><span class="line">  with value</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, trim = <span class="number">0</span>, na.rm = <span class="literal">FALSE</span>, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) &#123;</span><br><span class="line">          <span class="keyword">warning</span>(<span class="string">"argument is not numeric or logical: returning NA"</span>)</span><br><span class="line">          <span class="keyword">return</span>(<span class="literal">NA_real_</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>使用<code>getAnywhere()</code>不仅能查看<strong>不带星号的函数的源代码</strong>，还能查看<strong>带星号的函数的源代码</strong></li><li>同时使用<code>getAnywhere()</code>查看函数的源代码可以<strong>不用指定函数的来源</strong>，这个后面的使用<code>package:::function</code>查看方式不同</li></ul></div><hr><h4 id="查看源代码-package-function"><a href="#查看源代码-package-function" class="headerlink" title="查看源代码-package:::function"></a>查看源代码-package:::function</h4><p>也可以使用<code>package:::function</code>查看：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base::mean.default</span><br><span class="line">  <span class="keyword">function</span> (x, trim = <span class="number">0</span>, na.rm = <span class="literal">FALSE</span>, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) &#123;</span><br><span class="line">          <span class="keyword">warning</span>(<span class="string">"argument is not numeric or logical: returning NA"</span>)</span><br><span class="line">          <span class="keyword">return</span>(<span class="literal">NA_real_</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p></p><p>但使用<code>package:::function</code><strong>不能查看带星号的函数的源代码</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base::mean.IDate</span><br><span class="line">  Error <span class="keyword">in</span> get(name, envir = ns, inherits = <span class="literal">FALSE</span>) : </span><br><span class="line">    object <span class="string">'mean.IDate'</span> not found</span><br><span class="line"></span><br><span class="line">stats::predict.ar</span><br><span class="line">  Error: <span class="string">'predict.ar'</span> is not an exported object from <span class="string">'namespace:stats'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对于S4对象系统"><a href="#对于S4对象系统" class="headerlink" title="对于S4对象系统"></a>对于S4对象系统</h3><h4 id="S4对象特征"><a href="#S4对象特征" class="headerlink" title="S4对象特征"></a>S4对象特征</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chol2inv</span><br><span class="line">  standardGeneric <span class="keyword">for</span> <span class="string">"chol2inv"</span> defined from package <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  standardGeneric(<span class="string">"chol2inv"</span>)</span><br><span class="line">  &lt;bytecode: <span class="number">0x7907390</span>&gt;</span><br><span class="line">  &lt;environment: <span class="number">0x78fbfc0</span>&gt;</span><br><span class="line">  Methods may be defined <span class="keyword">for</span> arguments: x</span><br><span class="line">  Use  showMethods(<span class="string">"chol2inv"</span>)  <span class="keyword">for</span> currently available ones.</span><br></pre></td></tr></table></figure><p>出现<code>standardGeneric(&quot;chol2inv&quot;)</code>就是表明使用的<strong>S4对象进行面向对象封装</strong>.</p><hr><h4 id="查看内部行为函数-showMethods"><a href="#查看内部行为函数-showMethods" class="headerlink" title="查看内部行为函数-showMethods"></a>查看内部行为函数-showMethods</h4><p>对于S4对象进行面向对象封装的函数可以使用<code>showMethods</code>函数<strong>查看S4对象中的定义的内部行为函数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showMethods(chol2inv)</span><br><span class="line">  Function: chol2inv (package base)</span><br><span class="line">  x=<span class="string">"ANY"</span></span><br><span class="line">  x=<span class="string">"CHMfactor"</span></span><br><span class="line">  x=<span class="string">"denseMatrix"</span></span><br><span class="line">  x=<span class="string">"diagonalMatrix"</span></span><br><span class="line">  x=<span class="string">"dtrMatrix"</span></span><br><span class="line">  x=<span class="string">"sparseMatrix"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看源代码-getMethod"><a href="#查看源代码-getMethod" class="headerlink" title="查看源代码-getMethod"></a>查看源代码-getMethod</h4><p>使用<code>getMethod</code>查看源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getMethod (<span class="string">"chol2inv"</span>, <span class="string">"diagonalMatrix"</span>)</span><br><span class="line">  Method Definition:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      chk.s(<span class="keyword">...</span>, which.call = -<span class="number">2</span>)</span><br><span class="line">      tcrossprod(solve(x))</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;bytecode: <span class="number">0x50dac48</span>&gt;</span><br><span class="line">  &lt;environment: namespace:Matrix&gt;</span><br><span class="line"></span><br><span class="line">  Signatures:</span><br><span class="line">          x               </span><br><span class="line">  target  <span class="string">"diagonalMatrix"</span></span><br><span class="line">  defined <span class="string">"diagonalMatrix"</span></span><br></pre></td></tr></table></figure><p></p><p></p><hr><br><br><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://rfaqs.com/source-code-of-r-method" target="_blank" rel="noopener">How to View Source Code of R Method/ Function?</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了查看R语言中源代码的方法：首先直接&lt;strong&gt;输出函数名&lt;/strong&gt;或者使用&lt;code&gt;page&lt;/code&gt;函数、&lt;code&gt;edit&lt;/code&gt;函数查看，一般的函数可以直接显示源代码；如果出现&lt;code&gt;UseMethod(&amp;quot;mean&amp;quot;)&lt;/code&gt;表明是使用S3对象进行面向对象封装，此时结合&lt;code&gt;methods&lt;/code&gt;函数以及&lt;code&gt;getAnywhere()&lt;/code&gt;、&lt;code&gt;package:::function&lt;/code&gt;查看源代码；如果出现&lt;code&gt;standardGeneric(&amp;quot;chol2inv&amp;quot;)&lt;/code&gt;就是表明使用的&lt;strong&gt;S4对象进行面向对象封装&lt;/strong&gt;，此时结合&lt;code&gt;showMethods&lt;/code&gt;函数以及&lt;code&gt;getMethod&lt;/code&gt;查看源代码。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之集群之间不输入密码传输数据</title>
    <link href="http://showteeth.tech/posts/17109.html"/>
    <id>http://showteeth.tech/posts/17109.html</id>
    <published>2019-08-14T01:15:50.000Z</published>
    <updated>2019-08-17T01:07:16.100Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在多个集群之间设置免密传输数据的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做项目的过程中经常会遇到将<strong>数据在多个集群中移动</strong>的步骤，但是<strong>每个集群的密码都不一样</strong>，记住密码比较麻烦，同时<strong>需要输入密码的行为也不适合写成脚本</strong>来运行，所以这里就想对各个集群进行设置，使其可以免密传输。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>之前学习过<a href="http://showteeth.tech/posts/51573.html">使用ssh key来将本地项目免密传输到远程的github以及coding pages</a>，这里也是使用ssh key来进行类似的设置。</p><h3 id="server1配置"><a href="#server1配置" class="headerlink" title="server1配置"></a>server1配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">  <span class="comment"># 输出如下内容，期间内容之间按enter即可</span></span><br><span class="line">  ssh-keygen -t rsa</span><br><span class="line">  Generating public/private rsa key pair.</span><br><span class="line">  Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Share2/home/wangjb//.ssh/id_rsa): </span><br><span class="line">  Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">  Enter same passphrase again: </span><br><span class="line">  Your identification has been saved <span class="keyword">in</span> /Share2/home/wangjb//.ssh/id_rsa.</span><br><span class="line">  Your public key has been saved <span class="keyword">in</span> /Share2/home/wangjb//.ssh/id_rsa.pub.</span><br><span class="line">  The key fingerprint is:</span><br><span class="line">  11:65:05:8c:ac:93:6b:40:4d:9d:91:c4:65:6c:68:fb wangjb@loginview02</span><br><span class="line">  The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">  +--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">  |     o.=+@*o.    |</span></span><br><span class="line"><span class="string">  |    . . X++      |</span></span><br><span class="line"><span class="string">  |   .   +.o       |</span></span><br><span class="line"><span class="string">  |    . + ..       |</span></span><br><span class="line"><span class="string">  |     . oS.       |</span></span><br><span class="line"><span class="string">  |      o   E      |</span></span><br><span class="line"><span class="string">  |     .           |</span></span><br><span class="line"><span class="string">  |                 |</span></span><br><span class="line"><span class="string">  |                 |</span></span><br><span class="line"><span class="string">  +-----------------+</span></span><br></pre></td></tr></table></figure><p>上述步骤会在<code>~/.ssh</code>生成<code>id_rsa</code>、<code>id_rsa.pub</code>，其中的<code>id_rsa</code>是私钥，<strong>不能泄露出去</strong>，<code>id_rsa.pub</code>是公钥，可以用于与其他远程平台的交互。</p><h3 id="server2配置"><a href="#server2配置" class="headerlink" title="server2配置"></a>server2配置</h3><p>将上述得到的公钥(以<code>pub</code>结尾的文件)内容复制到<code>server2</code>的<code>~/.ssh</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;authorized_keys</span><br></pre></td></tr></table></figure><p></p><p>执行上述步骤之后进行scp测试，发现<strong>还是不能免密传输</strong>，这时需要修改<code>server2</code>的<code>authorized_keys</code>权限为<code>600</code>，同时设置<code>~/.ssh</code>文件夹权限为<code>700</code>，<strong>保证同组或其他用户不能对这个进行修改</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p></p><p>完成权限设置之后就可以在<strong>从server1到server2进行免密传输了</strong>，但是<strong>server2到server1之间还是不能进行免密传输</strong>，如果想要在server2到server1上进行免密传输还需要反过来设置一次。</p><h3 id="多个authorized-keys"><a href="#多个authorized-keys" class="headerlink" title="多个authorized_keys"></a>多个authorized_keys</h3><p>如果存在<code>3个以上</code>的集群之间免密，就需要在每个集群上的<code>authorized_keys</code>中加入多个集群的<code>id_rsa.pub</code>内容，添加的方式是<strong>直接追加<code>&gt;&gt;</code>即可</strong>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/182483/scp-without-password-prompt-using-different-username" target="_blank" rel="noopener">SCP without password prompt using different username</a></li><li><a href="https://blogs.oracle.com/jkini/how-to-scp,-ssh-and-rsync-without-prompting-for-password" target="_blank" rel="noopener">How To scp, ssh and rsync without prompting for password</a></li><li><a href="https://stackoverflow.com/questions/1462284/how-to-respond-to-password-prompt-when-using-scp-in-a-shell-script" target="_blank" rel="noopener">How to respond to password prompt when using SCP in a shell script?</a></li><li><a href="https://stackoverflow.com/questions/6377009/adding-public-key-to-ssh-authorized-keys-does-not-log-me-in-automatically" target="_blank" rel="noopener">Adding public key to ~/.ssh/authorized_keys does not log me in automatically</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在多个集群之间设置免密传输数据的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之导入python文件</title>
    <link href="http://showteeth.tech/posts/14806.html"/>
    <id>http://showteeth.tech/posts/14806.html</id>
    <published>2019-08-13T11:45:32.000Z</published>
    <updated>2019-08-17T01:07:16.110Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了将不同目录下的文件导入到另一个文件的方法，主要有两种：将<strong>文件路径加到package的搜索路径</strong>以及<strong>在需要导入的文件目录中加入<code>__init__.py</code>文件使其变成一个可以直接导入的包</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在画韦恩图的时候遇到一个<a href="https://github.com/tctianchi/pyvenn" target="_blank" rel="noopener">画图的脚本</a>不错，但是这个没有形成一个package，想要使用的话只能直接导入python文件，从而使用其中的绘图函数。</p><h2 id="导入python文件"><a href="#导入python文件" class="headerlink" title="导入python文件"></a>导入python文件</h2><p>这里有两种方法可以导入python文件从而使用其中的函数：</p><ul><li>将文件夹添加到<strong>系统路径(python package的安装和搜索路径)</strong></li><li>在需要导入的文件夹中添加<code>__init__.py</code>文件</li></ul><h3 id="添加到搜索路径"><a href="#添加到搜索路径" class="headerlink" title="添加到搜索路径"></a>添加到搜索路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_file.py</span></span><br><span class="line">import sys</span><br><span class="line"><span class="comment"># insert at 1, 0 is the script path (or '' in REPL)</span></span><br><span class="line">sys.path.insert(1, <span class="string">'/path/to/application/app/folder'</span>)</span><br><span class="line"></span><br><span class="line">import file</span><br></pre></td></tr></table></figure><hr><h3 id="添加init-py文件"><a href="#添加init-py文件" class="headerlink" title="添加init.py文件"></a>添加<strong>init</strong>.py文件</h3><p><code>__init__.py</code>文件的作用：<strong>It can be an empty file. Its very existence tells Python to treat the directory as a package.</strong></p><p>添加<code>__init__.py</code>文件之后，如果需要导入的文件的路径：<code>application/app/folder/file.py</code>，可以通过如下命令导入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from application.app.folder.file import func_name</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder" target="_blank" rel="noopener">Importing files from different folder</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了将不同目录下的文件导入到另一个文件的方法，主要有两种：将&lt;strong&gt;文件路径加到package的搜索路径&lt;/strong&gt;以及&lt;strong&gt;在需要导入的文件目录中加入&lt;code&gt;__init__.py&lt;/code&gt;文件使其变成一个可以直接导入的包&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之用户、用户组和权限管理</title>
    <link href="http://showteeth.tech/posts/61241.html"/>
    <id>http://showteeth.tech/posts/61241.html</id>
    <published>2019-08-13T05:29:19.000Z</published>
    <updated>2019-08-13T07:14:28.338Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>Linux</code>中<strong>用户、用户组和权限管理</strong>的相关知识。<strong>用户管理</strong>中，首先使用<code>adduser</code><strong>创建账号</strong>，然后使用<code>passwd</code>给创建的账号<strong>设置密码</strong>；在<strong>分组管理</strong>中，首先使用<code>groups</code>和<code>id</code>命令<strong>查看了用户的分组</strong>信息，然后使用<code>usermod</code><strong>更改了用户主分组</strong>；在<strong>权限管理</strong>中，首先介绍了文件(夹)的权限信息，然后使用<code>chmod</code><strong>修改文(夹)权限</strong>，最后使用<code>chown</code> 和 <code>chgrp</code> 命令来分别<strong>修改文件(夹)的所属用户和组</strong></p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室新来了几个同学，需要给他们创建账号使用集群，刚好实验室之前的集群用户和用户组非常混乱，这里就统一学习和管理一下。</p><hr><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>首先需要创建新账户，创建账户有两个命令：<code>useradd</code>和<code>adduser</code>，关于<a href="https://askubuntu.com/questions/345974/what-is-the-difference-between-adduser-and-useradd" target="_blank" rel="noopener">两者的区别</a>：</p><blockquote><p>adduser and addgroup add users and groups to the system according to command line options and configuration information in <strong>/etc/adduser.conf</strong>. They are <strong>friendlier front ends</strong> to the low level tools like useradd, groupadd and usermod programs, by default choosing Debian policy conformant UID and GID values, creating a home directory with skeletal configuration, running a custom script, and other features.</p></blockquote><blockquote><p>useradd is a <strong>low level utility</strong> for adding users. On Debian, administrators should usually use adduser(8) instead.</p></blockquote><p>另外使用<code>useradd</code>命令不会自动创建<code>/home/username</code>目录(可以通过添加<code>-m</code>参数指定创建)，而使用<code>adduser</code>会自动创建<code>/home/username</code>目录，两个命令创建的用户家目录都可以通过<code>-d</code>参数指定。</p><p>这里我使用的命令是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户名为zhengshuang，家目录在/workstation/zhengshuang的用户</span></span><br><span class="line">adduser -d /workstation/zhengshuang zhengshuang</span><br><span class="line"></span><br><span class="line">  drwx------.  2 zhengshuang zhengshuang 4.0K Aug 13 02:17 zhengshuang</span><br><span class="line">  drwxr-xr--.  6 root        root        4.0K Aug  8 11:55 softwares</span><br></pre></td></tr></table></figure><p></p><p>发现创建完成之后会自动创建一个与用户名同名的分组，这种情况下如果创建多个账号，每个人都是不同的分组，以后不方便管理，所以这里需要对其分组进行更改。</p><hr><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">passwd zhengshuang</span><br><span class="line">  Changing password <span class="keyword">for</span> user zhengshuang.</span><br><span class="line">  New password: </span><br><span class="line">  Retype new password: </span><br><span class="line">  passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><hr><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除账号以及家目录</span></span><br><span class="line"><span class="comment"># -r, --remove：remove home directory and mail spool</span></span><br><span class="line">userdel -r username</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h2><h3 id="查看分组信息"><a href="#查看分组信息" class="headerlink" title="查看分组信息"></a>查看分组信息</h3><p>可以先看看所有的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分组信息</span></span><br><span class="line">getent group</span><br><span class="line"><span class="comment"># 查看所有分组信息</span></span><br><span class="line">cut -d<span class="string">':'</span> -f 1 /etc/group</span><br><span class="line"><span class="comment"># 也可以顺便查看所有的用户信息</span></span><br><span class="line">cut -d<span class="string">':'</span> -f 1 /etc/passwd</span><br></pre></td></tr></table></figure><p></p><p>使用<code>groups</code>命令查看某个用户的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看zhengshuang的分组信息</span></span><br><span class="line">groups zhengshuang</span><br><span class="line">  zhengshuang : zhengshuang</span><br></pre></td></tr></table></figure><p></p><p>使用<code>id</code>命令查看某个用户的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id zhengshuang</span><br><span class="line">  uid=1027(zhengshuang) gid=1029(zhengshuang) groups=1029(zhengshuang)</span><br></pre></td></tr></table></figure><p></p><p>可以发现这个结果比前面使用<code>groups</code>的输出更加复杂一些：这里有一个 <code>gid</code>，表示<strong>主工作组(primary group)</strong>，后面还有个 <code>groups</code>，它列出了用户<strong>所在的所有组</strong>；<strong>主工作组只有一个，而后者(secondary groups)的数量则不限</strong>。总的来说，可以使用<code>id</code>命令看到用户组的结果和使用 <code>groups</code> 命令看到的结果是一致的。</p><hr><p>###添加组</p><p>为了解决创建用户步骤遗留下来的问题，首先需要添加组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加lab分组</span></span><br><span class="line">groupadd lab</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="更改用户主分组"><a href="#更改用户主分组" class="headerlink" title="更改用户主分组"></a>更改用户主分组</h3><p>更改用户主分组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g:force use GROUP as new primary group</span></span><br><span class="line">usermod -g lab zhengshuang</span><br><span class="line">  drwx------.  2 zhengshuang lab         4.0K Aug 13 02:17 zhengshuang</span><br><span class="line">  drwxr-xr--.  6 root        root        4.0K Aug  8 11:55 softwares</span><br></pre></td></tr></table></figure><p></p><p>这里使用了<code>-g</code>来改变用户的主用户组，也就是前面<code>gid</code>显示组别，也是<code>ll</code>显示的组别，而如果不想改变主用户组，而是添加用户组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a:append the user to the supplemental GROUPS </span></span><br><span class="line"><span class="comment">#    mentioned by the -G option without removing him/her from other groups</span></span><br><span class="line"><span class="comment"># -G:new list of supplementary GROUPS</span></span><br><span class="line">usermod -a -G examplegroup exampleusername1,exampleusername2,exampleusername3...</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建用户并指定分组"><a href="#创建用户并指定分组" class="headerlink" title="创建用户并指定分组"></a>创建用户并指定分组</h3><p>在使用adduser创建用户的同时也可以指定分组信息：</p><ul><li><code>-g</code>：name or ID of the primary group of the new account</li><li><code>-G</code>：list of supplementary groups of the new account</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser -d /workstation/zhengshuang zhengshuang -g lab</span><br></pre></td></tr></table></figure><hr><h3 id="删除分组"><a href="#删除分组" class="headerlink" title="删除分组"></a>删除分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认创建用户时的分组</span></span><br><span class="line">groupdel zhengshuang</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><div class="note info"><p>这部分参考了<a href="https://cuiqingcai.com/6284.html" target="_blank" rel="noopener">这篇博客文章</a>，讲解非常细致。</p></div><h3 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ls -l  /etc/nginx </span><br><span class="line">  total 80</span><br><span class="line">  drwxr-xr-x   7 root root  4096 Jun 21 22:16 ./</span><br><span class="line">  drwxr-xr-x 103 root root  4096 Sep  4 18:04 ../</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jul 12  2017 conf.d/</span><br><span class="line">  -rw-r--r--   1 root root  1077 Feb 12  2017 fastcgi.conf</span><br><span class="line">  -rw-r--r--   1 root root  1007 Feb 12  2017 fastcgi_params</span><br><span class="line">  -rw-r--r--   1 root root  2837 Feb 12  2017 koi-utf</span><br><span class="line">  -rw-r--r--   1 root root  2223 Feb 12  2017 koi-win</span><br><span class="line">  -rw-r--r--   1 root root  3957 Feb 12  2017 mime.types</span><br><span class="line">  -rw-r--r--   1 root root  1505 Jun 21 20:24 nginx.conf</span><br><span class="line">  -rw-r--r--   1 root root 12288 Jun 21 20:44 .nginx.conf.swp</span><br><span class="line">  -rw-r--r--   1 root root   180 Feb 12  2017 proxy_params</span><br><span class="line">  -rw-r--r--   1 root root   636 Feb 12  2017 scgi_params</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 22:42 sites-available/</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 19:08 sites-enabled/</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 19:08 snippets/</span><br><span class="line">  -rw-r--r--   1 root root   664 Feb 12  2017 uwsgi_params</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 22 02:44 vhosts/</span><br><span class="line">  -rw-r--r--   1 root root  3071 Feb 12  2017 win-utf</span><br></pre></td></tr></table></figure><p>可以发现每一行都是一个文件或文件夹的信息，一共包括七列：</p><ul><li>第一列是文件的<strong>权限信息</strong></li><li>第二列表示该文件夹<strong>连接的文件数(？？)</strong></li><li>第三列表示文件<strong>所属用户</strong></li><li>第四列表示文件<strong>所属用户组</strong></li><li>第五列表示<strong>文件大小（字节）</strong></li><li>第六列表示<strong>最后修改日期</strong></li><li>第七列表示<strong>文件名</strong></li></ul><p>其中<strong>第一列</strong>的文件<strong>权限信息</strong>是非常重要的，它由十个字符组成：</p><ul><li>第一个字符代表文件的类型，有三种，<code>-</code> 代表这是一个文件，<code>d</code> 代表这是一个文件夹，<code>l</code> 代表这是一个链接。</li><li>第 <code>2-4</code> 个字符代表文件<strong>所有者</strong>对该文件的权限，<ul><li><code>r</code> 就是读</li><li><code>w</code> 就是写</li><li><code>x</code> 就是执行，如果是<strong>文件夹</strong>的话，<strong>执行就意味着查看文件夹下的内容</strong>，例如 <code>rw-</code> 就代表文件所有者可以对该文件进行读取和写入。</li></ul></li><li>第 <code>5-7</code> 个字符代表文件<strong>所属组</strong>对该文件的权限，含义是一样的，如 <code>r-x</code>就代表该文件<strong>所属组内的所有用户</strong>对该文件有读取和执行的权限。</li><li>第 <code>8-10</code> 个字符代表是<strong>其他用户</strong>对该文件的权限，含义也是一样的，如 <code>r–</code> 就代表<strong>非所有者、非用户组的用户</strong>只拥有对该文件的读取权限。</li></ul><hr><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>可以使用<code>chmod</code>命令来修改文件的权限，其中<strong>权限的表示</strong>有两种：</p><ul><li>一种是<strong>数字权限命名</strong>，<code>rwx</code> 对应一个<strong>二进制数字</strong>，如 <code>101</code> 就代表拥有<strong>读取和执行</strong>的权限，而转为十进制的话，<code>r</code> 就代表 <code>4</code>，<code>w</code>就代表 <code>2</code>，<code>x</code> 就代表 <code>1</code>，然后<strong>三个数字加起来就和二进制数字对应起来了</strong>。如 <code>7=4+2+1</code>，这就对应着 <code>rwx</code>；<code>5=4+1</code>，这就对应着 <code>r-x</code>。所以，相应地 <code>777</code> 就代表了 <code>rwxrwxrwx</code>，即<strong>所有者、所属用户组、其他用户对该文件都拥有读取、写入、执行的权限，这是相当危险的</strong>！</li><li>也可以使用<strong>代号来赋予权限</strong>，代号有 <code>u</code>、<code>g</code>、<code>o</code>、<code>a</code> 四中，分别代表<strong>所有者权限</strong>，<strong>用户组权限</strong>，<strong>其他用户权限</strong>和<strong>所有用户权限</strong>，这些代号后面通过 <code>+</code> 和 <code>–</code> 符号来<strong>控制权限的添加和移除</strong>，再后面跟上权限类型就好。例如：<code>u-x</code>就是给所有者移除 <code>x</code> 权限，也就是执行权限.</li></ul><p>如果是需要修改<strong>文件夹</strong>的权限，可以对文件夹进行<strong>递归赋权限</strong>操作：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 share 文件夹和其内所有内容都赋予 777 权限</span></span><br><span class="line">chmod -R 777 share</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="修改文件所有者和组"><a href="#修改文件所有者和组" class="headerlink" title="修改文件所有者和组"></a>修改文件所有者和组</h3><p>通过上面的<code>chmod</code>命令可以给文件(夹)针对不同的用户和组添加不同的权限，但是前提是要确定文件(夹)所属的用户和组具体。这里可以使用<code>chown</code> 和 <code>chgrp</code> 命令来分别<strong>修改文件(夹)的所属用户和组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件的所属用户</span></span><br><span class="line">chown &lt;username&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 修改文件的所属组</span></span><br><span class="line">chgrp &lt;group&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件夹的所属用户</span></span><br><span class="line">chown -R &lt;username&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 修改文件夹的所属组</span></span><br><span class="line">chgrp -R &lt;group&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p></p><p>实践：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 root root 4.0K Aug 13 03:46 Mouseproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件的所属用户</span></span><br><span class="line">chown -R zhengshuang Mouseproject</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 zhengshuang root 4.0K Aug 13 03:46 Mouseproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件的所属组</span></span><br><span class="line">chgrp lab -R Mouseproject</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 zhengshuang lab 4.0K Aug 13 03:46 Mouseproject</span><br></pre></td></tr></table></figure><p></p><p>通过上述修改(没有修改文件权限，默认的权限即可满足需求)，Mouseproject文件夹中的数据就可以被<code>zhengshuang</code>用户<code>rwx</code>，被<code>lab</code>组的其他用户<code>r-x</code>，被<code>非lab组</code>的其他用户<code>r-x</code>了。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/" target="_blank" rel="noopener">Create a New User and Assign a Group in One Command</a></li><li><a href="https://cuiqingcai.com/6284.html" target="_blank" rel="noopener">详解 Linux 下的用户管理、用户组管理和权限管理</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;code&gt;Linux&lt;/code&gt;中&lt;strong&gt;用户、用户组和权限管理&lt;/strong&gt;的相关知识。&lt;strong&gt;用户管理&lt;/strong&gt;中，首先使用&lt;code&gt;adduser&lt;/code&gt;&lt;strong&gt;创建账号&lt;/strong&gt;，然后使用&lt;code&gt;passwd&lt;/code&gt;给创建的账号&lt;strong&gt;设置密码&lt;/strong&gt;；在&lt;strong&gt;分组管理&lt;/strong&gt;中，首先使用&lt;code&gt;groups&lt;/code&gt;和&lt;code&gt;id&lt;/code&gt;命令&lt;strong&gt;查看了用户的分组&lt;/strong&gt;信息，然后使用&lt;code&gt;usermod&lt;/code&gt;&lt;strong&gt;更改了用户主分组&lt;/strong&gt;；在&lt;strong&gt;权限管理&lt;/strong&gt;中，首先介绍了文件(夹)的权限信息，然后使用&lt;code&gt;chmod&lt;/code&gt;&lt;strong&gt;修改文(夹)权限&lt;/strong&gt;，最后使用&lt;code&gt;chown&lt;/code&gt; 和 &lt;code&gt;chgrp&lt;/code&gt; 命令来分别&lt;strong&gt;修改文件(夹)的所属用户和组&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell系列之eval、printf和组合数</title>
    <link href="http://showteeth.tech/posts/13990.html"/>
    <id>http://showteeth.tech/posts/13990.html</id>
    <published>2019-08-12T13:09:39.000Z</published>
    <updated>2019-08-13T12:23:09.105Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>使用shell得到组合数</strong>，其中用到了三个方面的trick：<code>特殊符号{}</code>、<code>printf中的{,}</code>，<code>eval命令</code>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在学习过程中遇到一个步骤需要得到组合数，之前也学习过使用使用python的<a href="http://showteeth.tech/posts/49907.html">itertools库(itertools.combinations)</a>得到组合数，但是这里是在shell中某一步需要得到组合数，再使用Python非常不划算，就想着直接使用shell得到组合数，在shell中得到组合数可以使用特殊符号<code>{}</code>，这个<a href="http://showteeth.tech/posts/55603.html">之前</a>也学习过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单纯的数字的组合数</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;0..1&#125;</span><br><span class="line">  00 01 10 11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字结合字母的组合数</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;a..b&#125;</span><br><span class="line">  0a 0b 1a 1b</span><br></pre></td></tr></table></figure><p>这里主要是遇到了两个trick进行命令行的简化。</p><h2 id="命令行的简化"><a href="#命令行的简化" class="headerlink" title="命令行的简化"></a>命令行的简化</h2><p>先给出简化的命令行形式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line">  000 001 010 011 100 101 110 111</span><br></pre></td></tr></table></figure><p></p><p>上述命令涉及到两个小trick：</p><ul><li><code>printf的{,}</code></li><li><code>eval命令</code></li></ul><h3 id="printf的"><a href="#printf的" class="headerlink" title="printf的{,}"></a>printf的{,}</h3><p>分解上述命令为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line">  &#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现printf应该是将<code>&#39;{0..1}&#39;</code>作为字符串打印了三遍，这是为什么呢？其中的<code>{,,}</code>是干什么的呢？</p><p>再次将上述命令分解为常见的形式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>)</span><br><span class="line">  &#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现，这里只打印出了一遍<code>{0..1}</code>，相较于存在<code>{,,}</code>的情形少打印了两遍，也就是说，存在<code>{,,}</code>会打印三遍<code>{0..1}</code>，两个逗号打印三遍，刚好两个逗号将3个字符(串)分开，那么如果如果存在一个逗号，是不是就是打印两遍呢？：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,&#125; )</span><br><span class="line">  &#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里确实是打印了两遍，联想之前学习的<a href="http://showteeth.tech/posts/47162.html">printf的用法</a>，猜测{,}是重复之前的字符，并且其中的,是重复的次数-1：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'abc'</span>&#123;,&#125;)</span><br><span class="line">  abcabc</span><br></pre></td></tr></table></figure><p></p><h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>在搞清楚上面<code>printf</code>的trick之后，再来看看<code>eval</code>命令，关于<code>eval</code>命令，大部分的介绍都是：当将命令行放入<code>eval</code>命令中后，shell在执行命令行之前扫描它两次，第一次会进行变量替换或运算，第二次是执行替换之后的命令(将<code>eval</code>之后的命令当成一个命令执行)；其<a href="https://www.tutorialspoint.com/unix_commands/eval" target="_blank" rel="noopener">英文说明</a>：</p><blockquote><p>eval is a built in linux or unix command. The eval command is used to <strong>execute the arguments as a shell command on unix or linux system</strong>. Eval command comes in handy <strong>when you have a unix or linux command stored in a variable</strong> and you <strong>want to execute that command stored in the string</strong>. The eval command <strong>first evaluates the argument</strong> and then <strong>runs the command stored in the argument</strong>.</p></blockquote><p>使用示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COMMAND=<span class="string">"ls -lrt"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="variable">$&#123;COMMAND&#125;</span></span><br><span class="line">  total 702</span><br><span class="line">  -rw-rw-r-- 1 user user 3595660 Aug 12 12:02 H12881_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user 3447580 Aug 12 12:02 H892.2_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user    7803 Aug 12 12:03 H892.2_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  -rw-rw-r-- 1 user user    7799 Aug 12 12:03 H12881_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  -rw-rw-r-- 1 user user 3621459 Aug 12 12:19 H892_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user    7816 Aug 12 12:19 H892_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  drwxrwxr-x 2 user user    4096 Aug 12 20:15 dir</span><br><span class="line">  -rw-rw-r-- 1 user user 4653958 Aug 12 20:35 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>具体到这次的命令行中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：</span></span><br><span class="line">将$(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )替换为&#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于<code>eval</code>命令的更多用法，在后续学习中慢慢补充吧。</p><ul><li><strong>eval变量替换、执行结果替换、指定命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=5</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">printf</span> <span class="string">',%.0s'</span> &#123;1..$(expr <span class="variable">$&#123;num&#125;</span> - 1)&#125;</span><br><span class="line">  ,,,,</span><br></pre></td></tr></table></figure></li></ul><p><strong>eval嵌套</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=4</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">eval</span> <span class="built_in">printf</span> <span class="string">"'&#123;0..1&#125;'%.0s"</span> &#123;1..<span class="variable">$&#123;num&#125;</span>&#125;)</span><br><span class="line">  0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/204069/all-possible-combinations-of-characters-and-numbers" target="_blank" rel="noopener">All possible combinations of characters and numbers</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;使用shell得到组合数&lt;/strong&gt;，其中用到了三个方面的trick：&lt;code&gt;特殊符号{}&lt;/code&gt;、&lt;code&gt;printf中的{,}&lt;/code&gt;，&lt;code&gt;eval命令&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell系列之cp和mv的进阶用法</title>
    <link href="http://showteeth.tech/posts/15765.html"/>
    <id>http://showteeth.tech/posts/15765.html</id>
    <published>2019-08-10T13:45:12.000Z</published>
    <updated>2019-08-13T07:14:28.345Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>cp</code>和<code>mv</code>命令将<strong>多个文件(夹)复制或者剪切到同一个目录</strong>中的方法以及<strong>将一(多)个文件拷贝到多个目录</strong>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>linux</code>下使用<code>cp</code>和<code>mv</code>命令时，经常会遇到需要<strong>将多个文件复制或者剪切到同一个目录</strong>下以及<strong>将一(多)个文件复制到多个目录中</strong>，这种时候使用简单的<code>cp</code>和<code>mv</code>就很难达到目的。</p><hr><h2 id="将多个文件复制到同一个目录"><a href="#将多个文件复制到同一个目录" class="headerlink" title="将多个文件复制到同一个目录"></a>将多个文件复制到同一个目录</h2><p><code>cp</code>命令使用较多的是<code>-r</code>和<code>-f</code>参数，但是这两个参数并不能解决目前的问题，这里需要使用另一个参数：<code>-t</code>-<strong>将所有的原文件(夹)复制到目标文件夹(copy all SOURCE arguments into DIRECTORY)</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个目录复制到同一个目录</span></span><br><span class="line">cp -r dir1 dir2 dir3 -t target_dir</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将一-多-个文件拷贝到多个目录"><a href="#将一-多-个文件拷贝到多个目录" class="headerlink" title="将一(多)个文件拷贝到多个目录"></a>将一(多)个文件拷贝到多个目录</h2><p>在这种情况下单凭<code>cp</code>命令是不能完成这个任务的，因为<code>cp</code>命令的介绍：<code>Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</code>并没有提到过可以将一(多)个文件复制到多个目录，这种情况下就需要借助之前学习的命令<a href="http://showteeth.tech/posts/30003.html">xargs</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xargs -n：指定一次处理的参数个数</span></span><br><span class="line"><span class="comment"># 每次只传递给cp一个目录</span></span><br><span class="line"><span class="built_in">echo</span> dir1 dir2 dir3 | xargs -n 1 cp file1 file2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意<code>xargs</code>一定要加<code>-n 1</code>，不然会将<code>dir1</code>、<code>dir2</code>、<code>file1</code>、<code>file2</code>全部复制到<code>dir3</code></p></div><hr><h2 id="将多个文件剪切到同一个目录"><a href="#将多个文件剪切到同一个目录" class="headerlink" title="将多个文件剪切到同一个目录"></a>将多个文件剪切到同一个目录</h2><p>和<code>cp</code>命令类似，<code>mv</code>命令也有一个<code>-t</code>参数，可以将多个文件(夹)剪切到同一个目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 dir2 dir3 -t target_dir1</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/195655/how-to-copy-a-file-to-multiple-directories-using-the-gnu-cp-command" target="_blank" rel="noopener">How to copy a file to multiple directories using the gnu cp command</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了使用&lt;code&gt;cp&lt;/code&gt;和&lt;code&gt;mv&lt;/code&gt;命令将&lt;strong&gt;多个文件(夹)复制或者剪切到同一个目录&lt;/strong&gt;中的方法以及&lt;strong&gt;将一(多)个文件拷贝到多个目录&lt;/strong&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
