<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-03-18T16:19:04.239Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-main函数的理解</title>
    <link href="http://showteeth.tech/posts/32155.html"/>
    <id>http://showteeth.tech/posts/32155.html</id>
    <published>2019-03-18T10:06:52.000Z</published>
    <updated>2019-03-18T16:19:04.239Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇之前学习过的关于Python main函数的理解，今天重新看了一遍，并将其整理到博客</p></div><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><strong>程序入口：</strong><br>&emsp;&emsp;对于<strong>很多编程语言</strong>来说，<strong>程序都必须要有一个入口</strong>，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，<strong>C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始</strong>。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。<br>&emsp;&emsp;而 <strong>Python 则有不同</strong>，它<strong>属于脚本语言</strong>，不像编译型语言那样先将程序编译成二进制再运行，而是<strong>动态的逐行解释运行</strong>。也就是<strong>从脚本第一行开始运行，没有统一的入口</strong>，结合Python<strong>使用缩进对齐组织代码</strong>的执行，所有<strong>没有缩进的代码（非函数定义和类定义），都会被当成Python的main函数，在载入时自动执行</strong>。<br>&emsp;&emsp; 一个 Python 源码文件除了<strong>可以被直接运行</strong>外，还<strong>可以作为模块（也就是库）被导入</strong>。<strong>不管是导入还是直接运行，最顶层的代码都会被运行（没有设置缩进的代码）</strong>，<strong>而实际上在导入的时候，有一部分代码我们是不希望被运行的，这一部分代码可以放在main函数中，当作为模块进行导入时就不会被执行</strong></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'AAA'</span>)                <span class="comment">#没有所进的代码，会被直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'BBB'</span>)             <span class="comment">#函数中的内容，被调用后会被执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (__name__)              <span class="comment">#是内置变量，用于表示当前模块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment">#当name是main的时候执行</span></span><br><span class="line">   test()</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'CCC'</span>)</span><br></pre></td></tr></table></figure><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p><strong>直接运行文件的输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line"></span><br><span class="line">__main__</span><br><span class="line"></span><br><span class="line">BBB</span><br><span class="line">CCC</span><br></pre></td></tr></table></figure><p></p><p>可以看出<strong>直接执行文件</strong>的时候<strong>先是两个print会被执行</strong>，并且从输出信息可以<strong>看出<code>__name__</code>是<code>__main__</code>，满足<code>if</code>的判断条件，所以<code>test()</code>函数会被执行，并且输出<code>CCC</code></strong>。</p><hr><h3 id="当成模块引入"><a href="#当成模块引入" class="headerlink" title="当成模块引入"></a>当成模块引入</h3><ul><li>将上述代码保存为<code>test_main.py</code>文件</li><li>在同一个目录下创建另一个文件，里面只写入<code>from test_main import test</code>，运行该文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只导入包的时候出现</span></span><br><span class="line"><span class="keyword">from</span> test_main <span class="keyword">import</span> test</span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件中继续写入 test()，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只写 test，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">&lt;function test at <span class="number">0x03433970</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>导入包的时候，和上面一样，两个print也会被直接执行</strong>，<strong>需要注意的是这里的<code>__name__</code>已经变成了<code>module</code>的名称（test_main）</strong>，由于<strong>此时的<code>__name__</code>不等于<code>__main___</code>，不满足if的条件，所以不会直接执行test函数和输出CCC</strong>；<strong>导入之后，调用其中的test函数（被导入的函数），原始的test函数就会被执行。</strong></p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>&emsp;&emsp;<strong><code>__name__ == &#39;__main__&#39;</code>含义是“Make a script both importable and executable”</strong>，也就是<strong>让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行</strong>。每个python模块(python文件)都包含内置的变量<code>__name__</code>，当运行模块被直接执行的时候，<code>__name__</code>等于<code>&#39;__main__&#39;</code>；如果import到其他模块中，则<code>__name__</code>等于模块名称(不包含后缀.py)。而在程序中的判断条件是<code>if __name__ == &#39;__main__&#39;</code>，所以当模块被直接执行时，<code>__name__ == &#39;__main__&#39;</code>结果为真；而当模块被import到其他模块中时，<code>__name__ == &#39;__main__&#39;</code>结果为假，就是不调用对应的方法。简单来说： <strong>如果模块是被直接运行的，则if语句中的代码块被运行，如果模块是被导入的，则if语句中的代码块不被运行</strong>。</p><div class="note info"><p>这个功能有一个用处：调试代码的时候，在<code>if __name__ == &#39;__main__&#39;</code>中加入一些我们的调试代码，我们可以<strong>让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</strong></p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/51892.htm" target="_blank" rel="noopener">浅析python 中<strong>name</strong> = ‘<strong>main</strong>‘ 的作用</a></li><li><a href="https://zhuanlan.zhihu.com/p/34366092" target="_blank" rel="noopener">python编程中的if <strong>name</strong> == ‘main’ 的作用和原理</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇之前学习过的关于Python main函数的理解，今天重新看了一遍，并将其整理到博客&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python常用程序块</title>
    <link href="http://showteeth.tech/posts/58475.html"/>
    <id>http://showteeth.tech/posts/58475.html</id>
    <published>2019-03-18T09:49:43.000Z</published>
    <updated>2019-03-18T16:19:04.253Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇博客总结一些常用的Python程序块，避免重复造轮子</p></div><a id="more"></a><h2 id="添加中文注释"><a href="#添加中文注释" class="headerlink" title="添加中文注释"></a>添加中文注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><hr><h2 id="正则匹配-分组、非贪婪"><a href="#正则匹配-分组、非贪婪" class="headerlink" title="正则匹配(分组、非贪婪)"></a>正则匹配(分组、非贪婪)</h2><p>正则匹配是经常使用的，也是经常容易出错的，这个给出比较常用的带<strong>分组</strong>和<strong>非贪婪</strong>模式的匹配：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">'&gt;AT1G01060.4 | Symbols: LHY, LHY1 | Homeodomain-like superfamily protein | chr1:33992-37061 REVERSE LENGTH=644'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配前面的AT1G01060</span></span><br><span class="line">pattern=re.compile(<span class="string">'^&gt;(.*?)\.'</span>)</span><br><span class="line"></span><br><span class="line">re.search(pattern,s).group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>‘AT1G01060’</p></blockquote><div class="note info"><ul><li>需要注意的：<code>&#39;^&gt;(.*?)\.&#39;</code>这里<code>?</code>加在<code>*</code>的后面，因为<code>*</code>才是贪婪匹配的来源；不应该加载<code>()</code>后面，那样起不到非贪婪匹配的作用</li><li><code>group(0)</code>或者<code>group()</code>表示的是整个匹配上的字符串，比如这里指的就是<code>&#39;&gt;AT1G01060.&#39;</code>；<code>group(1)</code>才是匹配的括号内的内容</li><li><code>re.match</code><strong>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None</strong>；而<code>re.search</code>匹配<strong>整个字符串，直到找到一个匹配</strong></li><li><strong><code>re.match</code> 和 <code>re.search</code> 是匹配一次 <code>re.findall</code> 匹配所有，返回列表</strong></li></ul></div><hr><h2 id="自动调用函数执行"><a href="#自动调用函数执行" class="headerlink" title="自动调用函数执行"></a>自动调用函数执行</h2><p>关于main函数的理解，请参考<a href="http://showteeth.tech/">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义主函数</span></span><br><span class="line">def main():</span><br><span class="line">    my_func()</span><br><span class="line">    my_func_1()</span><br><span class="line">    my_func_2()</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="输出固定长度的字串"><a href="#输出固定长度的字串" class="headerlink" title="输出固定长度的字串"></a>输出固定长度的字串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改every即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wrapped</span><span class="params">(string, every=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\n'</span>.join(string[i:i+every] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), every))</span><br></pre></td></tr></table></figure><hr><h2 id="字典相关操作："><a href="#字典相关操作：" class="headerlink" title="字典相关操作："></a>字典相关操作：</h2><h3 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的字典</span></span><br><span class="line">dic=&#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="string">'3'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用collections中的defaultdict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dic_test=defaultdict(list)</span><br><span class="line">dic_test[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 具体的形式：defaultdict(&lt;type 'list'&gt;, &#123;'a': [1]&#125;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="两个列表组成字典"><a href="#两个列表组成字典" class="headerlink" title="两个列表组成字典"></a>两个列表组成字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"></span><br><span class="line">dictionary = dict(zip(keys, values)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (dictionary) </span><br><span class="line"><span class="comment"># 输出: </span></span><br><span class="line"><span class="comment">#      &#123;'a': 1, 'c': 3, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方法创建方法都可以使用以下方法遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">  <span class="keyword">print</span> (k)</span><br><span class="line">  <span class="keyword">print</span> (v)</span><br></pre></td></tr></table></figure><hr><h3 id="将字典写入文件"><a href="#将字典写入文件" class="headerlink" title="将字典写入文件"></a>将字典写入文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dic_file</span><span class="params">(dic,out_file)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(out_file,<span class="string">'w'</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">out.write(k+<span class="string">'\n'</span>)</span><br><span class="line">out_s=write_wrapped(v, every=<span class="number">60</span>)</span><br><span class="line">out.write(out_s)</span><br><span class="line">out.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="获取字典最值"><a href="#获取字典最值" class="headerlink" title="获取字典最值"></a>获取字典最值</h3><p><strong>利用<code>min(dict, key=dict.get)</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="number">3</span>:<span class="number">2</span>&#125;</span><br><span class="line">min(d, key=d.get)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     2</span></span><br></pre></td></tr></table></figure><p></p><p><strong>利用<code>lambda</code>函数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到索引和值</span></span><br><span class="line">min(d.items(), key=lambda x: x[1])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     (2, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只得到值</span></span><br><span class="line">min(d, key=lambda x: d[x])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#      2</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="判断最后一行文本"><a href="#判断最后一行文本" class="headerlink" title="判断最后一行文本"></a>判断最后一行文本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bug:if second last is same as last, this will be wrong </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">last_line=total_lines[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> line == last_line:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># fix bug above</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line_num)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">total_line_num=len(total_lines)</span><br><span class="line"><span class="keyword">if</span> line_num==total_line_num:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇博客总结一些常用的Python程序块，避免重复造轮子&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python常见错误</title>
    <link href="http://showteeth.tech/posts/61409.html"/>
    <id>http://showteeth.tech/posts/61409.html</id>
    <published>2019-03-18T07:52:34.000Z</published>
    <updated>2019-03-18T16:19:04.246Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要整理了在Python学习过程中遇到的具有典型性的问题，搜集起来，以免以后遇到同样的错误重新找解决方法。</p></div><a id="more"></a><h2 id="常规报错"><a href="#常规报错" class="headerlink" title="常规报错"></a>常规报错</h2><h2 id="pandas报错"><a href="#pandas报错" class="headerlink" title="pandas报错"></a>pandas报错</h2><h2 id="jupyter报错"><a href="#jupyter报错" class="headerlink" title="jupyter报错"></a>jupyter报错</h2><h3 id="jupyter启动报错"><a href="#jupyter启动报错" class="headerlink" title="jupyter启动报错"></a>jupyter启动报错</h3><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\Scripts\jupyter-notebook-script.py"</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from notebook.notebookapp import main</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\notebookapp.py"</span>, line 81, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .services.kernels.kernelmanager import MappingKernelManager</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\services\kernels\kernelmanager.py"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.session import Session</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\session.py"</span>, line 61, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.jsonutil import extract_dates, squash_dates, date_default</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\jsonutil.py"</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from dateutil.parser import parse as _dateutil_parse</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\dateutil\parser.py"</span>, line 158</span><br><span class="line">    l.append(<span class="string">"%s=%s"</span> % (attr, `value`))</span><br><span class="line">                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall python-dateutil</span><br><span class="line">pip install python-dateutil</span><br></pre></td></tr></table></figure><hr><h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p>之前安装的将印象笔记转化为markdown格式的时候安装的包将某个包的版本降低了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ever2simple 2.0 has requirement python-dateutil&lt;2.0, but you<span class="string">'ll have python-dateutil 2.8.0 which is incompatible.</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要整理了在Python学习过程中遇到的具有典型性的问题，搜集起来，以免以后遇到同样的错误重新找解决方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>shell-数组</title>
    <link href="http://showteeth.tech/posts/46714.html"/>
    <id>http://showteeth.tech/posts/46714.html</id>
    <published>2019-03-17T10:36:25.000Z</published>
    <updated>2019-03-17T12:31:40.606Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要对Shell的数组进行了学习，主要内容包括<code>创建数组</code>、<code>数组赋值</code>、<code>读取数组</code>、<code>获取数组长度</code>、<code>获取数组使用的下标</code>、<code>在数组末尾添加元素</code>、<code>数组排序</code>、<code>删除数组</code>和<code>关联数组</code>。</p></div><a id="more"></a><h2 id="shell数组简介"><a href="#shell数组简介" class="headerlink" title="shell数组简介"></a>shell数组简介</h2><p>数组是可以存放多个值的一种数据结构，Bash shell也支持数组，但是其对数组的支持比较有限，下面列出了Bash shell数组的特征：</p><ul><li>Bash Shell <strong>只支持一维数组(不支持多维数组)</strong></li><li>初始化时<strong>不需要定义数组大小</strong></li><li>数组元素的<strong>下标由0开始</strong>(与大部分编程语言类似)</li><li>数组用<strong>括号来表示</strong>，<strong>元素用”空格”符号分割</strong>开</li></ul><hr><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="提前创建"><a href="#提前创建" class="headerlink" title="提前创建"></a>提前创建</h3><p><strong>特殊符号<code>( )</code></strong>被用于数组的声明中，因此可以使用如下命令提前创建数组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array=(element1 element2 element3 ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组时直接指定元素的索引值</span></span><br><span class="line">array=([1]=element1 [2]=element2 [3]=element3)</span><br></pre></td></tr></table></figure><p></p><p>更多关于特殊符号<code>( )</code>的用法参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><p><strong>也可以使用declare命令创建数组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array=<span class="string">'(element1 element2 element3 ...)'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p>数组变量就像其它 bash 变量一样命名，当<strong>被访问的时候，它们会被自动地创建</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[1]=foo</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  foo</span><br></pre></td></tr></table></figure><p></p><p>上面是一个赋值并访问数组元素的例子，通过<code>a[1]=foo</code>，数组索引为1(开始于0)的元素被赋值为foo(索引为0的位置可以访问，但是输出为空)；通过<code>echo ${a[1]}</code>访问数组索引为1的元素，<code>${}</code>可以进行数组操作，具体的请看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><div class="note info"><p>可以不使用连续的下标创建数组，而且下标的范围没有限制</p></div><hr><h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>在上述创建数组的过程中其实已经实现了数组的赋值：</p><ul><li><strong>单个元素</strong>赋值：<code>array[index]=value</code></li><li><strong>多个元素</strong>赋值：<code>array=(element1 element2 element3 ...)</code></li><li><strong>多个元素结合索引</strong>进行赋值：<code>array=([1]=element1 [2]=element2 [3]=element3)</code></li></ul><p><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次赋值</span></span><br><span class="line">a=(a b c)</span><br><span class="line"><span class="comment"># $&#123;a[@]&#125;是获取数组所有元素，后面会讲到</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次赋值</span></span><br><span class="line">a=(d e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a b c<br>d e f g</p></blockquote><div class="note info"><ul><li>数组的<code>index</code>是<strong>一个大于或等于零的整数（或算术表达式）</strong></li><li>数组<strong>第一个元素的下标是0</strong>， 而不是1</li><li>数组<strong>元素的值可以是一个字符串或整数</strong></li><li><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong></li></ul></div><hr><h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><h3 id="读取数组单个元素"><a href="#读取数组单个元素" class="headerlink" title="读取数组单个元素"></a>读取数组单个元素</h3><p>读取数组使用特殊符号<code>${}</code>，一般形式为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><p>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=A</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>A<br>2<br>3<br>4</p></blockquote><hr><h3 id="读取数组所有元素"><a href="#读取数组所有元素" class="headerlink" title="读取数组所有元素"></a>读取数组所有元素</h3><p><strong>如果想要获取数组的所有元素，使用<code>@</code> 或 <code>*</code></strong> :<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1 2 3 4<br>1 2 3 4</p></blockquote><p><code>@</code>和<code>*</code>的区别和使用<a href="http://showteeth.tech/posts/55603.html"><code>$*</code>或<code>$@</code>得到所有脚本变量</a>的区别相同：</p><ul><li><strong>不使用双引号括起来时完全相同</strong>：都以”element1” “element2” … “elementn” 的形式输出所有参数</li><li><strong>使用双引号括起来时不同</strong>：<code>&quot;${!array[*]}&quot;</code> 会将所有的元素作为一个整体，以”element1 element2 … elementn”的形式输出所有元素；<code>&quot;${!array[@]}&quot;</code> 会将各个元素分开，以”element1” “element2” … “elementn” 的形式输出所有元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>不使用双引号括起来时输出结果完全相同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>使用双引号括起来时输出结果不同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><blockquote><p>1 2 3 4</p></blockquote><div class="note info"><ul><li>读取数组所有元素需要注意<code>${array[*]}</code>和<code>${array[@]}</code>加引号和不加引号输出结果的区别</li><li>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong></li></ul></div><hr><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>获取数组长度(元素个数)的方法与获取字符串长度的方法相同，仍然是使用特殊符号<code>${}</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>4</p></blockquote><p><strong>如果上面不是使用了<code>@</code>和<code>*</code>，而是使用了具体的索引位置，则会得到指定索引位置的元素长度：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[1]=test_length</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[1]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>11 &emsp;&emsp;&emsp;# 输出的是test_length的长度</p></blockquote><p>还有需要注意的地方是：<strong>如果赋值时数组的索引不是连续的，数组的长度不是最大索引对应的长度，而是有具体值的索引的个数，也就是说没有赋值的那些索引不计入数组长度(但是仍然可以通过索引访问，返回结果为空)</strong>。示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[100]=100</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>5 &emsp;&emsp;&emsp;# 这里输出结果是5，而不是101，即使最后一个有值的索引为100，但是5-99的索引位置并没有赋值，也就没有计入数组长度</p></blockquote><div class="note info"><ul><li><strong>使用<code>@</code>和<code>*</code></strong>获取的是<strong>数组的长度</strong></li><li><strong>使用具体的索引位置</strong>获取的是<strong>指定索引位置的元素长度</strong></li><li><strong>未赋值的索引不计入输入长度的计算</strong></li></ul></div><hr><h2 id="获取数组使用的下标"><a href="#获取数组使用的下标" class="headerlink" title="获取数组使用的下标"></a>获取数组使用的下标</h2><p>因为shell数组允许赋值的数组下标包含 “间隔”，所以确定哪些下标在数组中是具有值的有时候很关键：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>0 1 2 3 100</p></blockquote><p><strong>和前面提到的使用双引号和不使用双引号括起来输出结果不同相同，这里两种方法在使用双引号括起来的时候也会存在差异</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;!array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;!array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><code>&quot;${!array[@]}&quot;</code>输出结果：</p><blockquote><p>0<br>1<br>2<br>3<br>100</p></blockquote><p><code>&quot;${!array[*]}&quot;</code>输出结果：</p><blockquote><p>0 1 2 3 100</p></blockquote><div class="note info"><ul><li>获取数组下标时需要注意<code>${!array[*]}</code>和<code>${!array[@]}</code>加引号和不加引号输出结果的区别</li><li><code>${array[*]}</code>和<code>${array[@]}</code>是获取数组所有元素的方法，而<code>!</code>具有取反的作用，<strong>数组元素的反理解为索引</strong>的话就很好记忆了</li></ul></div><hr><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><p>如果我们需要<strong>在数组末尾附加数据</strong>，那么知道数组中元素的个数是没用的，因为通过 <code>*</code> 和 <code>@</code>表示法返回的数值<strong>不能告诉我们使用的最大数组索引</strong>，并且<strong>直接不加索引继续赋值的话第二次的赋值会覆盖前一次的赋值结果</strong>。幸运地是，shell 为我们提供了一种解决方案：<strong>通过使用 <code>+=</code> 赋值运算符，我们能够自动地把值附加到数组末尾(索引接着最后一个索引)</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=(a b c)</span><br><span class="line"><span class="built_in">test</span>[100]=d</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>+=(e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100 101 102 103</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>Shell 没有直接对数组元素排序的方法，但是可以通过获取值然后排序再利用排序后的值重新赋值给另一个数组即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=(a d c f e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将排序后的结果赋值给新数组，这里使用了循环接入管道的操作</span></span><br><span class="line"><span class="comment"># 可以不使用新数组，直接赋值给原始数组即可覆盖原始数组的值</span></span><br><span class="line">a_sorted=($(<span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;a[@]&#125;</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span> |sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在同一行输出新数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;a_sorted[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a c d e f</p></blockquote><hr><h2 id="删除数组相关操作"><a href="#删除数组相关操作" class="headerlink" title="删除数组相关操作"></a>删除数组相关操作</h2><p>删除数组相关操作都会使用 <code>unset</code> 命令</p><h3 id="删除整个数组"><a href="#删除整个数组" class="headerlink" title="删除整个数组"></a>删除整个数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> foo</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出为空</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> <span class="string">'foo[2]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b d e f</span></span><br></pre></td></tr></table></figure><hr><h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>现在最新的 bash 版本支持关联数组了，<strong>关联数组使用字符串而不是整数作为数组索引(AWK只支持关联数组，但可以把数字下标转化为字符)</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用-A也可以使用-a</span></span><br><span class="line"><span class="comment"># 也可以直接在使用的时候创建</span></span><br><span class="line"><span class="built_in">declare</span> -A colors</span><br><span class="line">colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#ff0000 #0000ff #00ff00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种创建输出会出问题：</span></span><br><span class="line">array=([<span class="string">"red"</span>]=<span class="string">"#ff0000"</span> [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span> [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#0000ff</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/chapter4/46.html" target="_blank" rel="noopener">shell-guide</a></li><li><a href="https://baijiahao.baidu.com/s?id=1608244941950314734&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/hanframe/p/3564313.html" target="_blank" rel="noopener">shell编程中使用数组进行操作</a></li><li><a href="http://www.runoob.com/linux/linux-shell-array.html" target="_blank" rel="noopener">Shell 数组</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要对Shell的数组进行了学习，主要内容包括&lt;code&gt;创建数组&lt;/code&gt;、&lt;code&gt;数组赋值&lt;/code&gt;、&lt;code&gt;读取数组&lt;/code&gt;、&lt;code&gt;获取数组长度&lt;/code&gt;、&lt;code&gt;获取数组使用的下标&lt;/code&gt;、&lt;code&gt;在数组末尾添加元素&lt;/code&gt;、&lt;code&gt;数组排序&lt;/code&gt;、&lt;code&gt;删除数组&lt;/code&gt;和&lt;code&gt;关联数组&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="shell编程" scheme="http://showteeth.tech/categories/Linux/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git系列(一):Git简介</title>
    <link href="http://showteeth.tech/posts/60073.html"/>
    <id>http://showteeth.tech/posts/60073.html</id>
    <published>2019-03-17T02:52:57.000Z</published>
    <updated>2019-03-17T03:18:16.170Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>在有了前面两篇转载的偏实战文章的学习之后，打算针对Git进行一系列的学习，这次是偏系统，因为在实战学习中发现有些命令和操作不是很懂，同时在这篇文章的参考链接中也给出了一些Git相关的系列教程</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></li><li><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5" target="_blank" rel="noopener">Git官方教程</a></li><li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/article-8478-1.html" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/daima/git_code/" target="_blank" rel="noopener">Git实例</a></li><li></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;在有了前面两篇转载的偏实战文章的学习之后，打算针对Git进行一系列的学习，这次是偏系统，因为在实战学习中发现有些命令和操作不是很懂，同时在这篇文章的参考链接中也给出了一些Git相关的系列教程&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>转载-Git常用命令及日常问题集锦</title>
    <link href="http://showteeth.tech/posts/13404.html"/>
    <id>http://showteeth.tech/posts/13404.html</id>
    <published>2019-03-16T06:04:30.000Z</published>
    <updated>2019-03-17T04:20:56.603Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的博客，主要记录了<code>Git</code>的常用命令，包括<code>新建代码库</code>、<code>Git相关配置</code>、<code>添加文件到暂存区</code>、<code>删除工作区文件</code>、<code>代码提交</code>、<code>分支操作</code>、<code>标签</code>、<code>查看信息</code>、<code>远程同步</code>，还整理了一些使用过程中<code>常见的问题</code>。</p></div><a id="more"></a><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><ul><li>在<strong>当前目录</strong>新建一个Git代码库(初始化)：<code>git init</code></li><li><strong>新建一个目录</strong>，<strong>将其初始化</strong>为Git代码库：<code>git init [project-name]</code></li><li><strong>下载一个项目和它的整个代码历史</strong>：<code>git clone [url]</code></li></ul><hr><h2 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h2><ul><li><strong>显示当前</strong>的Git配置：<code>git config --list</code></li><li><strong>编辑</strong>Git配置文件：<code>git config -e [--global]</code></li><li><strong>设置提交代码时的用户信息</strong>：<code>git config [--global] user.name &quot;[name]&quot;</code>和<code>git config [--global] user.email &quot;[email address]&quot;</code></li></ul><hr><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><ul><li><strong>添加</strong>指定<strong>文件</strong>到<strong>暂存区</strong>：<code>git add [file1] [file2] ...</code></li><li>添加指定<strong>目录到暂存区</strong>，<strong>包括子目录</strong>：<code>git add [dir]</code></li><li>添加<strong>当前目录的所有文件到暂存区</strong>：<code>git add .</code></li><li>添加<strong>每个变化</strong>前，都会<strong>要求确认</strong>(对于<strong>同一个文件的多处变化</strong>，可以实现<strong>分次提交</strong>)：<code>git add -p</code></li></ul><hr><h2 id="删除工作区文件"><a href="#删除工作区文件" class="headerlink" title="删除工作区文件"></a>删除工作区文件</h2><ul><li><strong>删除工作区</strong>文件，并且将这次删除<strong>放入暂存区</strong>：<code>git rm [file1] [file2] ...</code></li><li><strong>停止追踪</strong>指定文件，但该文件会<strong>保留在工作区</strong>：<code>git rm --cached [file]</code></li><li><strong>改名</strong>文件，并且将这个<strong>改名放入暂存区</strong>：<code>git mv [file-original] [file-renamed]</code></li></ul><hr><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><ul><li>提交<strong>暂存区到仓库区</strong>：<code>git commit -m [message]</code></li><li>提交<strong>暂存区的指定文件到仓库区</strong>：<code>git commit [file1] [file2] ... -m [message]</code></li><li>提交<strong>工作区自上次commit之后的变化，<u>直接到仓库区</u></strong>：<code>git commit -a</code><br><br></li><li>提交时<strong>显示所有diff信息</strong>：<code>git commit -v</code><br><br></li><li><strong>使用一次新的commit，替代上一次提交(如果代码没有任何新变化，则用来改写上一次commit的提交信息)</strong>：<code>git commit --amend -m [message]</code></li><li><strong>重做上一次commit，并包括指定文件的新变化</strong>：<code>git commit --amend [file1] [file2] ...</code></li></ul><hr><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ul><li><strong>列出</strong>所有<strong>本地分支</strong>：<code>git branch</code></li><li><strong>列出</strong>所有<strong>远程分支</strong>：<code>git branch -r</code></li><li><strong>列出</strong>所有<strong>本地分支和远程分支</strong>：<code>git branch -a</code><br><br></li><li><strong>新建</strong>一个分支，但<strong>依然停留在当前分支</strong>：<code>git branch [branch-name]</code></li><li><strong>新建</strong>一个分支，并<strong>切换到该分支</strong>：<code>git checkout -b [branch]</code></li><li><strong>新建</strong>一个分支，<strong>指向指定commit</strong>：<code>git branch [branch] [commit]</code></li><li><strong>新建</strong>一个分支，<strong>与指定的远程分支建立追踪关系(连接)</strong>：<code>git branch --track [branch] [remote-branch]</code><br><br></li><li><strong>切换</strong>到<strong>指定</strong>分支，并<strong>更新工作区</strong>：<code>git checkout [branch-name]</code></li><li><strong>切换</strong>到<strong>上一个</strong>分支：<code>git checkout -</code></li><li><strong>建立追踪关系(连接)</strong>，在<strong>现有分支</strong>与<strong>指定的远程分支</strong>之间：<code>git branch --set-upstream [branch] [remote-branch]</code><br><br></li><li><strong>合并指定分支</strong>到<strong>当前分支</strong>：<code>git merge [branch]</code></li><li><strong>选择一个commit</strong>，<strong>合并进当前分支</strong>：<code>git cherry-pick [commit]</code><br><br></li><li><strong>删除</strong>分支：<code>git branch -d [branch-name]</code></li><li><strong>删除远程</strong>分支：<code>git push origin --delete [branch-name]</code>或者<code>git branch -dr [remote/branch]</code></li></ul><hr><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><strong>列出</strong>所有tag：<code>git tag</code></li><li><strong>查看</strong>tag信息：<code>git show [tag]</code><br><br></li><li><strong>新建</strong>一个tag<strong>在当前commit</strong>：<code>git tag [tag]</code></li><li><strong>新建</strong>一个tag在<strong>指定commit</strong>：<code>git tag [tag] [commit]</code><br><br></li><li><strong>删除本地</strong>tag：<code>git tag -d [tag]</code></li><li><strong>删除远程</strong>tag：<code>git push origin :refs/tags/[tagName]</code><br><br></li><li><strong>提交指定</strong>tag：<code>git push [remote] [tag]</code></li><li><strong>提交所有</strong>tag：<code>git push [remote] --tags</code><br><br></li><li><strong>新建一个分支</strong>，<strong>指向某个tag</strong>：<code>git checkout -b [branch] [tag]</code></li></ul><hr><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul><li><strong>显示有变更的文件</strong>：<code>git status</code><br><br></li><li>显示<strong>暂存区</strong>和<strong>工作区的差异</strong>：<code>git diff</code></li><li>显示<strong>暂存区</strong>和<strong>上一个commit的差异</strong>：<code>git diff --cached [file]</code></li><li>显示<strong>工作区</strong>与<strong>当前分支最新commit之间的差异</strong>：<code>git diff HEAD</code></li><li>显示<strong>两次提交之间的差异</strong>：<code>git diff [commit_1] [commit_2]</code></li><li><strong>显示今天你写了多少行代码</strong>：<code>git diff --shortstat &quot;@{0 day ago}&quot;</code><br><br></li><li>显示<strong>某次提交</strong>的<strong>元数据和内容变化</strong>：<code>git show [commit]</code></li><li>显示<strong>某次提交发生变化的文件</strong>：<code>git show --name-only [commit]</code></li><li>显示<strong>某次提交时，某个文件的内容</strong>：<code>git show [commit]:[filename]</code><br><br></li><li><strong>显示当前分支的版本历史</strong>：<code>git log</code></li><li><strong>显示commit历史</strong>，以及<strong>每次commit发生变更的文件</strong>：<code>git log --stat</code></li><li><strong>根据关键词搜索提交历史</strong>：<code>git log -S [keyword]</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>每个commit占据一行</strong>：<code>git log [tag] HEAD --pretty=format:%s</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>其”提交说明”必须符合搜索条件</strong>：<code>git log [tag] HEAD --grep feature</code></li><li>显示<strong>某个文件的版本历史</strong>，<strong>包括文件改名</strong>：<code>git log --follow [file]</code>或者<code>git whatchanged [file]</code></li><li>显示<strong>指定文件</strong>相关的<strong>每一次diff</strong>：<code>git log -p [file]</code></li><li><strong>显示过去5次提交</strong>，且<strong>每个commit占据一行</strong>：<code>git log -5 --pretty --oneline</code><br><br></li><li><strong>记录几乎当前分支的所有改变，带版本号</strong>：<code>git reflog</code><br><br></li><li>显示<strong>所有提交过的用户</strong>，<strong>按提交次数排序</strong>：<code>git shortlog -sn</code></li><li>显示<strong>指定文件</strong>是<strong>什么人在什么时间修改过</strong>：<code>git blame [file]</code></li></ul><hr><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><ul><li><strong>下载远程仓库的所有变动</strong>：<code>git fetch [remote]</code></li><li><strong>取回远程仓库的变化</strong>，并<strong>与本地分支合并</strong>：<code>git pull [remote] [branch]</code><br><br></li><li>上传<strong>本地指定分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] [branch]</code></li><li><strong>强行</strong>推送<strong>当前分支</strong>到<strong>远程仓库</strong>，<strong>即使有冲突</strong>：<code>git push [remote] --force</code></li><li>推送<strong>所有分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] --all</code><br><br></li><li><strong>显示所有远程仓库</strong>：<code>git remote -v</code></li><li>显示<strong>某个远程仓库</strong>的信息：<code>git remote show [remote]</code></li><li><strong>增加一个新的远程仓库</strong>，<strong>并命名</strong>：<code>git remote add [shortname] [url]</code></li></ul><hr><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li>恢复<strong>暂存区的指定文件</strong>到<strong>工作区</strong>：<code>git checkout [file]</code></li><li>恢复<strong>暂存区的所有文件</strong>到<strong>工作区</strong>：<code>git checkout .</code></li><li>恢复<strong>某个commit的指定文件</strong>到<strong>暂存区和工作区</strong>：<code>git checkout [commit] [file]</code><br><br></li><li>重置<strong>暂存区的指定文件</strong>，与<strong>上一次commit保持一致</strong>，但<strong>工作区不变</strong>：<code>git reset [file]</code></li><li>重置<strong>暂存区与工作区</strong>，与<strong>上一次commit保持一致</strong>：<code>git reset --hard</code></li><li>重置<strong>当前分支的指针为指定commit</strong>，同时<strong>重置暂存区</strong>，但<strong>工作区不变</strong>：<code>git reset [commit]</code></li><li>重置<strong>当前分支的HEAD为指定commit</strong>，同时<strong>重置暂存区和工作区</strong>，<strong>与指定commit一致</strong>：<code>git reset --hard [commit]</code></li><li>重置<strong>当前HEAD为指定commit</strong>，但<strong>保持暂存区</strong>和<strong>工作区不变</strong>：<code>git reset --keep [commit]</code><br><br></li><li><strong>新建一个commit</strong>，<strong>用来撤销指定commit(后者的所有变化都将被前者抵消，并且应用到当前分支)</strong>：<code>git revert [commit]</code><br><br></li><li><strong>暂时将未提交的变化移除，稍后再移入</strong>：<code>git stash</code>和<code>git stash pop</code></li></ul><div><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr><div class="RichText ztext Post-RichText"><h2 id="常见问题">常见问题</h2><h3 id="failed to push some refs to git">failed to push some refs to git</h3><p style="font-weight:700">Question1</p><div class="highlight"><pre><code class="language-text"><span></span>如何解决: failed to push some refs to git    </code></pre></div><p style="font-weight:700">Answer1</p><div class="highlight"><pre><code class="language-text"><span></span>git pull --rebase origin master  # 进行代码合并    git push -u origin master  # 即可完成代码上传    </code></pre></div><hr><h3 id="git pull未指定本地与远程连接报错">git pull未指定本地与远程连接报错</h3><p style="font-weight:700">Question2</p><p><code>If you wish to set tracking information for this branch you can do so with:</code></p><p><code>git branch --set-upstream-to=origin/ master</code></p><p style="font-weight:700">Answer2</p><p>指定当前工作分支跟远程仓库分支之间的联系</p><p><code>git branch --set-upstream master origin/master</code></p><hr><h3 id="获取最新代码报错">获取最新代码报错</h3><p style="font-weight:700">Question3</p><p><code>git pull</code> 获取最新代码报以下错误</p><p><code>fatal: refusing to merge unrelated histories</code></p><p style="font-weight:700">Answer3</p><p>git pull之后加上可选参数 --allow-unrelated-histories 强制合并</p><p><code>git pull origin master --allow-unrelated-histories</code></p><hr><h3 id="使用钩子报错">使用钩子报错</h3><p style="font-weight:700">Question4</p><p>使用钩子<code>pre-commit</code>，提交代码提示如下错误：</p><div class="highlight"><pre><code class="language-text"><span></span>$ git commit -m '.'    sh: eslint: command not found    pre-commit:    pre-commit: We've failed to pass the specified git pre-commit hooks as the `fix`    pre-commit: hook returned an exit code (1). If you're feeling adventurous you can    pre-commit: skip the git pre-commit hooks by adding the following flags to your commit:    pre-commit:    pre-commit:   git commit -n (or --no-verify)    pre-commit:    pre-commit: This is ill-advised since the commit is broken.    pre-commit:    </code></pre></div><p style="font-weight:700">Answer4</p><ul><li>打开项目中的<code>.git/hooks</code>文件夹，找到<code>pre-commit.sample</code>文件，将以下代码替换到文件中，或者，<code>npm install pre-commit --save</code>也可以，这个命令会自动执行以下操作。</li></ul><div class="highlight"><pre><code class="language-text"><span></span>#!/bin/bash    TSLINT="$(git rev-parse --show-toplevel)/node_modules/.bin/tslint"    for file in $(git diff --cached --name-only | grep -E '\.ts$')    do            git show ":$file" | "$TSLINT" "$file"            if [ $? -ne 0 ]; then                    exit 1            fi    done    </code></pre></div><ul><li>将<code>pre-commit.sample</code>文件名修改为<code>pre-commit</code>。</li></ul><hr><h3 id=".gitignore规则不生效">.gitignore规则不生效</h3><p style="font-weight:700">Question5</p><p><code>.gitignore规则不生效的解决办法</code></p><p style="font-weight:700">Answer5</p><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</p><div class="highlight"><pre><code class="language-text"><span></span>git rm -r --cached . 或者 git rm -r README.md    git add .    git commit -m 'update .gitignore'    </code></pre></div><p><br>作者：五月君<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/269298" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/26929</span><span class="invisible">8</span><span class="ellipsis"></span></a><br>来源：慕课网<br>本文首次发布于慕课网 ，转载请注明出处，谢谢合作</p></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的博客，主要记录了&lt;code&gt;Git&lt;/code&gt;的常用命令，包括&lt;code&gt;新建代码库&lt;/code&gt;、&lt;code&gt;Git相关配置&lt;/code&gt;、&lt;code&gt;添加文件到暂存区&lt;/code&gt;、&lt;code&gt;删除工作区文件&lt;/code&gt;、&lt;code&gt;代码提交&lt;/code&gt;、&lt;code&gt;分支操作&lt;/code&gt;、&lt;code&gt;标签&lt;/code&gt;、&lt;code&gt;查看信息&lt;/code&gt;、&lt;code&gt;远程同步&lt;/code&gt;，还整理了一些使用过程中&lt;code&gt;常见的问题&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>转载-Git讲解与使用实战</title>
    <link href="http://showteeth.tech/posts/13035.html"/>
    <id>http://showteeth.tech/posts/13035.html</id>
    <published>2019-03-16T05:44:08.000Z</published>
    <updated>2019-03-17T04:43:16.906Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要偏向实战，通过实战讲解Git的用法，比较全面，包括<code>创建版本库</code>、<code>版本回退</code>、<code>撤销修改和删除文件操作</code>、<code>远程仓库相关操作</code>以及<code>分支操作</code>，总的来说是一篇不错的文章。</p></div><a id="more"></a><div class="RichText ztext Post-RichText"><h2 id="简介与安装">Git简介与安装</h2><h3 id="Git是什么？">Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。工作原理 / 流程：</p><img 图片1 src="http://img.mukewang.com/59c31e4400013bc911720340.png" alt="图片描述" data-original="http://img.mukewang.com/59c31e4400013bc911720340.png" style="cursor:pointer;display:block"><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><hr><h3 id="SVN与Git的最主要的区别">SVN与Git的最主要的区别</h3><p><code>SVN</code>是<strong>集中式版本控制系统</strong>，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。<strong>集中式版本控制系统是必须联网才能工作</strong>，如果在<u>局域网</u>还可以，带宽够大，速度够快，如果在<u>互联网下</u>，如果网速慢的话，就纳闷了。</p><p><code>Git</code>是<strong>分布式版本控制系统</strong>，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就<strong>不需要联网</strong>了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><hr><h3 id="在windows上安装Git">在windows上安装Git</h3><p><code>msysgit</code>是 windows版的Git,如下：</p><img 图片2 src="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" style="cursor:pointer;display:block"><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 "Git --&gt; Git Bash",如下：<br></p><img 图片3 src="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" style="cursor:pointer;display:block"><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：<br></p><img 图片4 src="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" style="cursor:pointer;display:block"><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><img 图片5 src="http://img.mukewang.com/59c1d041000110d906460213.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1d041000110d906460213.jpg" style="cursor:pointer;display:block"><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p>注意：<code>git config --global</code> 参数，有了这个参数，表示<strong>你这台机器上所有的Git仓库都会使用这个配置</strong>，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><hr><br><h2 id="Git使用">Git使用</h2><h3 id="创建版本库">创建版本库</h3><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><img 图片6 src="http://img.mukewang.com/59c1d1060001909005780268.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d1060001909005780268.png" style="cursor:pointer;display:block"><p>pwd 命令是用于显示当前的目录。</p><h4 id="把这个目录变成git可以管理的仓库">把这个目录变成git可以管理的仓库</h4><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><img 图片7 src="http://img.mukewang.com/59c1d12b0001b08305270077.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d12b0001b08305270077.png" style="cursor:pointer;display:block"><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><img 图片8 src="http://img.mukewang.com/59c1d143000112df06120173.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d143000112df06120173.png" style="cursor:pointer;display:block"><hr><h4 id="把文件添加到版本库中">把文件添加到版本库中</h4><p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><b>示例demo：</b></p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p><strong>第一步：使用命令 <code>git add readme.txt</code>添加到暂存区</strong>里面去，如下：<br></p><img 图片9 src="http://img.mukewang.com/59c1d2080001e4bb04490080.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2080001e4bb04490080.png" style="cursor:pointer;display:block"><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p><strong>第二步：用命令 <code>git commit</code>告诉Git，把文件提交到仓库</strong>:<br></p><img 图片10 src="http://img.mukewang.com/59c1d2200001f05b04930121.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2200001f05b04930121.png" style="cursor:pointer;display:block"><p>这样我们就已经提交了一个readme.txt文件了</p><p><strong>第三步：使用命令<code>git status</code>来查看是否还有文件未提交</strong>，如下：<br></p><img 图片11 src="http://img.mukewang.com/59c1d2340001a87904690107.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2340001a87904690107.png" style="cursor:pointer;display:block"><p>说明没有任何文件未提交</p><p><strong>第四步：继续来修改readme.txt内容，比如我在下面添加一行2222222222内容，继续使用<code>git status</code>来查看下结果</strong>，如下：<br></p><img 图片12 src="http://img.mukewang.com/59c1d2500001634606170171.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2500001634606170171.png" style="cursor:pointer;display:block"><p>上面的命令告诉我们 readme.txt文件已被修改，但是<strong>未被提交的修改</strong>。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？</p><p><strong>第五步：使用<code>git diff readme.txt</code>查看文件到底改了什么内容</strong>，如下：<br></p><img 图片13 src="http://img.mukewang.com/59c1d2cb00010a0304960202.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2cb00010a0304960202.png" style="cursor:pointer;display:block"><p>如上可以看到，readme.txt文件内容从一行11111111改成二行添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是<code>git add</code>；第二步是：<code>git commit</code>)，如下：<br></p><img 图片14 src="http://img.mukewang.com/59c1d2ff00015a9606180342.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2ff00015a9606180342.png" style="cursor:pointer;display:block"><hr><br><h3 id="版本回退">版本回退</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为<strong>33333333333333</strong>继续执行命令如下：</p><img 图片15 src="http://img.mukewang.com/59c1d32b00012ba604570139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d32b00012ba604570139.png" style="cursor:pointer;display:block"><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？</p><h4 id="使用命令 git log 查看历史记录">使用命令 git log 查看历史记录</h4><img 图片16 src="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" style="cursor:pointer;display:block"><p><code>git log</code>命令显示<strong>从最近到最远</strong>的修改日志，我们可以看到最近有三次提交，最近的一次是：增加内容为333333；上一次是添加内容222222；第一次默认是 111111.<br></p><p>如果<strong>嫌上面显示的信息太多的话，我们可以使用命令 <code>git log –pretty=oneline</code></strong>演示如下：<br></p><img 图片17 src="http://img.mukewang.com/59c1d3fc00013ad206040097.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d3fc00013ad206040097.png" style="cursor:pointer;display:block"><hr><h4 id="使用命令 git reset 进行版本回退">使用命令 git reset 进行版本回退</h4><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令：<br></p><ul><li>第一种是：<code>git reset --hard HEAD^</code>，那么如果要回退到<strong>上上个版本只需把HEAD^ 改成 HEAD^^，以此类推</strong></li><li>第二种是：<code>git reset --hard HEAD~1</code>，第一种方法如果要回退到前100个版本的话，肯定不方便，这时可以使用简便命令操作：<code>git reset --hard HEAD~100</code></li></ul><p><strong>未回退之前</strong>的readme.txt内容如下：<br></p><img 图片18 src="http://img.mukewang.com/59c1d4140001a0c404490165.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4140001a0c404490165.png" style="cursor:pointer;display:block"><p>如果想<strong>回退到上一个版本</strong>的命令如下操作：</p><img 图片19 src="http://img.mukewang.com/59c1d429000199fc04610105.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d429000199fc04610105.png" style="cursor:pointer;display:block"><p><strong>使用命令cat readme.txt查看下 readme.txt内容</strong>，如下：<br></p><img 图片20 src="http://img.mukewang.com/59c1d4470001fcdc04360085.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4470001fcdc04360085.png" style="cursor:pointer;display:block"><p>可以看到，<strong>内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息</strong>，如下：<br></p><img 图片21 src="http://img.mukewang.com/59c1d45300012d9604800219.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d45300012d9604800219.png" style="cursor:pointer;display:block"><p>发现增加333333内容已经没有了</p><hr><h4 id="使用命令 git reset 结合 git reflog 进行版本号回退">使用命令 git reset 结合 git reflog 进行版本号回退</h4><p>如果现在想<strong>回退到最新的版本</strong>，如：有333333的内容要如何恢复呢？我们可以<strong>通过版本号回退</strong>，使用命令：<code>git reset --hard 版本号</code> ，但是现在的问题<strong>假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？</strong><br></p><p>可以<strong>通过<code>git reflog</code>命令获取到版本号</strong>，演示如下：<br></p><img 图片22 src="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" style="cursor:pointer;display:block"><p>通过上面的显示我们可以知道，增加内容3333的版本号是 <code>6fcfc89</code>。我们现在可以使用命令：<code>git reset --hard 6fcfc89</code>来恢复了，演示如下：<br></p><img 图片23 src="http://img.mukewang.com/59c1d53a0001b8b305050153.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d53a0001b8b305050153.png" style="cursor:pointer;display:block"><p>可以看到目前已经是最新的版本了。</p><hr><br><h3 id="理解工作区与暂存区的区别">理解工作区与暂存区的区别</h3><ul><li>工作区：就是你在<strong>电脑上看到的目录</strong>，比如目录下testgit里的文件(<code>.git</code>隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li><li>版本库(Repository)：<strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库</strong>。其中版本库里面存了很多东西，其中最重要的就是<strong>stage(暂存区)</strong>，还有Git为我们<strong>自动创建了第一个分支master</strong>,以及<strong>指向master的一个指针HEAD</strong>。</li></ul><p>我们前面说过使用<strong>Git提交文件到版本库有两步</strong>：</p><ul><li>第一步：是使用<code>git add</code>把文件添加进去，实际上就是把文件<strong>添加到暂存区</strong></li><li>第二步：使用<code>git commit</code>提交更改，实际上就是<strong>把暂存区的所有内容提交到当前分支上</strong></li></ul><p>继续使用demo来演示下：</p><p>我们在readme.txt再<u>添加一行内容为4444444</u>，接着在目录下<u>新建一个文件为test.txt 内容为test</u>，我们先用命令<code>git status</code>来查看下状态，如下：</p><img 图片24 src="http://img.mukewang.com/59c1d55a0001a3c306430241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d55a0001a3c306430241.png" style="cursor:pointer;display:block"><p>现在我们先<strong>使用<code>git add</code>命令把2个文件都添加到暂存区</strong>中，再使用<code>git status</code>来查看下状态，如下：</p><img 图片25 src="http://img.mukewang.com/59c1d56a0001a28704700241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d56a0001a28704700241.png" style="cursor:pointer;display:block"><p>接着我们可以<strong>使用<code>git commit</code>一次性提交到分支上</strong>，如下：</p><img 图片26 src="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" style="cursor:pointer;display:block"><hr><br><h3 id="撤销修改和删除文件操作">撤销修改和删除文件操作</h3><h4 id="撤销修改">撤销修改</h4><p>现在在readme.txt文件里面增加一行内容为555555555555，我们先通过命令查看如下：<br></p><img 图片27 src="http://img.mukewang.com/59c1d5e40001806803930139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5e40001806803930139.png" style="cursor:pointer;display:block"><p>在我<strong>未提交之前</strong>，我发现添加5555555555555内容有误，所以我得马上<strong>恢复以前的版本</strong>，现在我可以有如下几种方法可以做修改：</p><ul><li>第一：如果我知道要删掉那些内容的话，直接<strong>手动更改</strong>去掉那些需要的文件，然后add添加到暂存区，最后commit掉</li><li>第二：使用<code>git reset --hard HEAD^</code>直接恢复到上一个版本</li><li>第三：使用撤销命令<code>git checkout --</code>，下面讲解如何使用撤销命令</li></ul><p>首先在做撤销之前，我们可以先用<code>git status</code>查看下当前的状态。如下所示：</p><img 图片28 src="http://img.mukewang.com/59c1d5fa0001b07806400168.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5fa0001b07806400168.png" style="cursor:pointer;display:block"><p>可以发现，Git会告诉你，<strong><code>git checkout -- file</code>可以丢弃工作区的修改</strong>，例如使用<code>git checkout -- readme.txt</code>：</p><img 图片29 src="http://img.mukewang.com/59c1d6390001419705210140.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6390001419705210140.png" style="cursor:pointer;display:block"><p><strong>命令<code>git checkout --readme.txt</code>意思就是：把readme.txt文件在工作区做的修改全部撤销</strong>，这里有2种情况：</p><ul><li>readme.txt自动修改后，还<strong>没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态</strong></li><li>readme.txt<strong>已经放入暂存区了，接着又作了修改，撤销修改就回到<u>添加暂存区后</u>的状态</strong></li></ul><p><strong>也就是说<code>git checkout --readme.txt</code>只能撤销没有提交到暂存区的修改</strong></p><p>对于上面列举的<strong>第二种情况</strong>，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我<code>git add</code>添加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><img 图片30 src="http://img.mukewang.com/59c1d6ca0001782f06160482.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6ca0001782f06160482.png" style="cursor:pointer;display:block"><p><mark>注意：命令<code>git checkout -- readme.txt</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了。</mark></p><hr><h4 id="删除文件">删除文件</h4><p>假如我现在版本库testgit目录<u>添加一个文件b.txt,然后提交</u>，如下：<br></p><img 图片31 src="http://img.mukewang.com/59c1d6de0001a31606390392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6de0001a31606390392.png" style="cursor:pointer;display:block"><p>如上：一般情况下，可以<strong>直接在文件目录中把文件删了</strong>，或者<strong>使用如上<code>rm</code>命令：<code>rm b.txt</code></strong>，如果我想<strong>彻底从版本库中删掉了此文件的话，可以再执行commit命令提交掉</strong>，现在目录是这样的：<br></p><img 图片32 src="http://img.mukewang.com/59c1d78200017e8f07030192.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d78200017e8f07030192.png" style="cursor:pointer;display:block"><hr><h4 id="撤销删除操作">撤销删除操作</h4><p>只要<strong><u>没有commit之前</u>，如果我想在版本库中恢复此文件如何操作呢？</strong>，可以使用如下命令<strong><code>git checkout -- b.txt</code></strong>，如下所示：</p><img 图片33 src="http://img.mukewang.com/59c1d7980001368e05570244.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7980001368e05570244.png" style="cursor:pointer;display:block"><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><img 图片34 src="http://img.mukewang.com/59c1d7b70001308907550258.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7b70001308907550258.png" style="cursor:pointer;display:block"><hr><br><h3 id="远程仓库">远程仓库</h3><h4 id="建立传输连接">建立传输连接</h4><p>以Github为例进行远程仓库的操作，首先需要建立本地Git仓库和Github仓库之间的传输(通过SSH加密的)连接</p><p><strong>第一步：创建SSHKey</strong>。在用户主目录下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入命令：<code>ssh-keygen -t rsa –C “youremail@example.com”</code>, 结果如下所示：</p><img 图片35 src="http://img.mukewang.com/59c1d7d7000120d107530169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7d7000120d107530169.png" style="cursor:pointer;display:block"><p>注意：<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第二步：在Github中添加公钥</strong>。登录Github,打开“settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴<code>id_rsa.pub</code>文件的内容。<br></p><img 图片36 src="http://img.mukewang.com/59c1d7ef0001c75411330860.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7ef0001c75411330860.png" style="cursor:pointer;display:block"><p>点击Add Key，你就应该可以看到已经添加的key。<br></p><img 图片37 src="http://img.mukewang.com/59c1d8540001eb3707620373.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8540001eb3707620373.png" style="cursor:pointer;display:block"><hr><h4 id="添加远程库">添加远程库</h4><p><strong>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在Github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样Github的仓库可以作为备份，又可以其他人通过该仓库来协作。</strong></p><p>首先，登录Github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><img 图片38 src="http://img.mukewang.com/59c1d86a0001044b10840605.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d86a0001044b10840605.png" style="cursor:pointer;display:block"><p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br></p><img 图片39 src="http://img.mukewang.com/59c1d8850001b5ea10260661.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8850001b5ea10260661.png" style="cursor:pointer;display:block"><p>目前，在GitHub上的这个testgit仓库还是空的，GitHub提示我们，<strong>可以从这个仓库克隆出新的仓库</strong>，<strong>也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库</strong>。<br>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p><img 图片40 src="http://img.mukewang.com/59c1d8a70001c86206320252.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8a70001c86206320252.png" style="cursor:pointer;display:block"><p><strong>把本地库的内容推送到远程，使用<code>git push</code>命令，实际上是把当前分支master推送到远程。</strong></p><div class="note info"><p>由于远程库是空的，我们第一次推送master分支时，加上了<code>–u</code>参数，<strong>Git不但会把本地的master分支内容推送的远程新的master分支</strong>，还会<strong>把本地的master分支和远程的master分支关联起来</strong>，在以后的推送或者拉取时就可以简化命令。</p></div><p>推送成功后，可以立刻在Github页面中看到远程库的内容已经和本地一模一样了:<br></p><img 图片41 src="http://img.mukewang.com/59c1d8bb00019ff310480655.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8bb00019ff310480655.png" style="cursor:pointer;display:block"><p><strong>从现在起，只要本地作了提交，就可以通过命令：<code>git push origin master</code>把本地master分支的最新修改推送到Github上了，现在你就拥有了真正的分布式版本库了。</strong></p><hr><h4 id="克隆远程库到本地">克隆远程库到本地</h4><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。现在我们想，假如<strong>远程库有新的内容了，我想克隆到本地来，如何克隆呢？</strong></p><p>首先，登录Github，创建一个新的仓库，名字叫testgit2，如下：</p><img 图片42 src="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" style="cursor:pointer;display:block"> <img 图片43 src="http://img.mukewang.com/59c1d97400014d4e10360484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d97400014d4e10360484.png" style="cursor:pointer;display:block"><p>接下来，使用命令<code>git clone</code>克隆一个本地库了。如下所示：</p><img 图片44 src="http://img.mukewang.com/59c1d9860001e0d806370127.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9860001e0d806370127.png" style="cursor:pointer;display:block"><p>操作完成后可以发现在我本地目录下生成testgit2目录了，如下所示：</p><img 图片45 src="http://img.mukewang.com/59c1d99500016a2e07130197.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d99500016a2e07130197.png" style="cursor:pointer;display:block"><hr><br><h3 id="分支操作">分支操作</h3><p>在版本回填退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<strong>主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p><strong>Git的分支操作主要包括：创建分支、合并分支、删除分支</strong></p><h4 id="创建分支">创建分支</h4><p>首先，我们来<strong>创建dev分支</strong>，然后<strong>切换到dev分支上</strong>，如下操作：</p><img 图片46 src="http://img.mukewang.com/59c1d9aa0001c15604080167.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9aa0001c15604080167.png" style="cursor:pointer;display:block"><div class="note info"><ul><li><strong><code>git checkout</code>命令加上<code>–b</code>参数表示创建并切换，相当于2条命令</strong>：<ul><li><strong><code>git branch dev</code>(新建分支)</strong></li><li><strong><code>git checkout dev</code>(切换分支)</strong></li></ul></li><li><strong><code>git branch</code>查看分支，会列出所有的分支，当前分支前面会添加一个星号</strong></li></ul></div><p>接下来我们<strong>在dev分支上</strong>继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><img 图片47 src="http://img.mukewang.com/59c1da3f0001b5b703890392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da3f0001b5b703890392.png" style="cursor:pointer;display:block"><p>现在dev分支工作已完成，现在我们<strong>切换到主分支master</strong>上，继续查看readme.txt内容如下：</p><img 图片48 src="http://img.mukewang.com/59c1da520001d44c06340206.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da520001d44c06340206.png" style="cursor:pointer;display:block"><div class="note info"><p>不同分支上的内容修改是不共享的，如果想要共享需要使用合并操作，具体请看下文</p></div><hr><h4 id="合并分支">合并分支</h4><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令<code>git merge dev</code>如下所示：<br></p><img 图片49 src="http://img.mukewang.com/59c1da69000145ca05320255.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da69000145ca05320255.png" style="cursor:pointer;display:block"><ul><li><strong><code>git merge</code>命令用于合并指定分支到当前分支上</strong>，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的</li><li><strong>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快</strong></li></ul><hr><h4 id="删除分支">删除分支</h4><p>合并完成后，我们可以使用命令<code>git branch –d dev</code>删除dev分支了，操作如下：</p><img 图片50 src="http://img.mukewang.com/59c1da91000120cd06430139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da91000120cd06430139.png" style="cursor:pointer;display:block"><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><hr><h4 id="分支合并冲突">分支合并冲突</h4><p><mark>当我们同时在两个分支中修改同一个文件，并将其合并的时候会出现分支合并冲突</mark>，示例如下：<br><strong>首先</strong>，先新建一个新分支，比如名字叫fenzhi1，<strong>在readme.txt添加一行内容8888888，然后提交</strong>，如下所示：<br></p><img 图片51 src="http://img.mukewang.com/59c1db410001036105690462.png" alt="图片描述" data-original="http://img.mukewang.com/59c1db410001036105690462.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，我们现在<strong>切换到master分支上来，也在readme.txt最后一行添加内容，内容为99999999，然后提交</strong>，如下所示：</p><img 图片52 src="http://img.mukewang.com/59c1daaf0001133205840500.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daaf0001133205840500.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们在master分支上来合并fenzhi1，<strong>直接使用<code>git merge</code>会提示conflict，然后使用<code>git status</code>查看发现在两个分支中readme.txt都被修改了，此时打开readme.txt文件发现出现了冲突的内容显示</strong>，具体内容和操作截图如下：</p><img 图片53 src="http://img.mukewang.com/59c1daff000106eb06340589.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daff000106eb06340589.png" style="cursor:pointer;display:block"><p><strong>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以手动对readme.txt文件进行如下修改后保存</strong>：<br></p><img 图片54 src="http://img.mukewang.com/59c1dbaf00015f2205770266.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbaf00015f2205770266.png" style="cursor:pointer;display:block"><p><strong>最后</strong>，使用命令<code>git log</code>命令查看分支合并的情况：<br></p><img 图片55 src="http://img.mukewang.com/59c1dbc50001076c04970869.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbc50001076c04970869.png" style="cursor:pointer;display:block"><hr><h4 id="分支合并模式">分支合并模式</h4><p><strong>通常合并分支时，Git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</strong><br>首先我们来做demo演示下：</p><div class="highlight"><pre><code class="language-text">            创建一个dev分支;            修改readme.txt内容;            添加到暂存区;            切换回主分支(master);            合并dev分支，使用命令 git merge –no-ff -m “注释” dev;            查看历史记录;        </code></pre></div><img 图片56 src="http://img.mukewang.com/59c1dbdc0001836d06030780.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbdc0001836d06030780.png" style="cursor:pointer;display:block"><hr><h4 id="分支管理策略">分支管理策略</h4><div class="note info"><p><strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</strong></p></div><hr><h4 id="创建bug分支">创建bug分支</h4><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，<strong>每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</strong></p><p>例如，我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，<strong>当前的dev分支上的工作还没有提交</strong>，具体如下：</p><img 图片57 src="http://img.mukewang.com/59c1dc4e000141b306260166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc4e000141b306260166.png" style="cursor:pointer;display:block"><p><strong>这里并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成</strong>。怎么办呢？还好，<strong>Git还提供了一个<code>stash</code>功能，可以把当前工作现场”隐藏起来”，等以后恢复现场后继续工作</strong>。如下：</p><img 图片58 src="http://img.mukewang.com/59c1dc63000121ff06510188.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc63000121ff06510188.png" style="cursor:pointer;display:block"><p>现在我可以通过创建issue-404分支来修复bug了，具体的实施步骤如下：</p><p><strong>首先</strong>，我们要<strong>确定在哪个分支上修复bug</strong>，比如我现在是在主分支master上来修复的，现在我要在master分支上<strong>创建</strong>一个临时分支，演示如下：</p><img 图片59 src="http://img.mukewang.com/59c1dc7000010f8506010533.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc7000010f8506010533.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，在<strong>修复完成</strong>后<strong>切换</strong>到master分支上，并完成<strong>合并</strong>，最后<strong>删除</strong>issue-404分支。演示如下：</p><img 图片60 src="http://img.mukewang.com/59c1dce00001c1ed06120441.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dce00001c1ed06120441.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们<strong>回到dev分支</strong>上干活:<br></p><img 图片61 src="http://img.mukewang.com/59c1dcfa00019c8104220136.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dcfa00019c8104220136.png" style="cursor:pointer;display:block"><p><strong>但是</strong>，我们发现<strong>工作区是干净的</strong>，那么我们工作现场去哪里呢？我们可以<strong>使用命令<code>git stash list</code>来查看工作现场</strong>。如下：</p><img 图片62 src="http://img.mukewang.com/59c1dd07000152b404340093.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd07000152b404340093.png" style="cursor:pointer;display:block"><p>通过<code>git stash list</code>发现工作现场还在，Git把<code>stash</code>内容存在某个地方了，但是需要<strong>恢复</strong>一下，可以使用如下2个方法：</p><ul><li><code>git stash apply</code>恢复，<strong>恢复后，<code>stash</code>内容并不删除，你需要使用命令<code>git stash drop</code>来删除</strong></li><li>另一种方式是使用<code>git stash pop</code>，<strong>恢复的同时把<code>stash</code>内容也删除了</strong></li></ul><p>示例如下：</p><img 图片63 src="http://img.mukewang.com/59c1dd1f000174d406380466.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd1f000174d406380466.png" style="cursor:pointer;display:block"><hr><h4 id="多人协作">多人协作</h4><h5 id="查看远程库的信息">查看远程库的信息</h5><p>当你从<strong>远程库克隆</strong>时候，<strong>实际上Git自动把本地的master分支和远程的master分支对应起来了，并且<u>远程库的默认名称是origin</u>。</strong></p><p>要<strong>查看远程库的信息</strong>，使用<code>git remote</code><br>要<strong>查看远程库的详细信息</strong>，使用<code>git remote –v</code>，具体操作如下：</p><img 图片64 src="http://img.mukewang.com/59c1dd7d000136fd06190169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd7d000136fd06190169.png" style="cursor:pointer;display:block"><hr><h5 id="推送分支">推送分支</h5><p>推送分支就是<strong>把该分支上所有本地提交到远程库</strong>中，推送时<strong>要指定本地分支</strong>，这样Git就会<strong>把该分支推送到远程库对应的远程分支上</strong></p><p><strong>把本地分支推送到远程分支</strong>，使用<code>git push origin master</code></p><p>例如，我的<strong>Github(远程库)</strong>上的readme.txt代码如下：<br></p><img 图片65 src="http://img.mukewang.com/59c1dd90000164a508280459.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd90000164a508280459.png" style="cursor:pointer;display:block"><p><strong>本地</strong>的readme.txt代码如下：<br></p><img 图片66 src="http://img.mukewang.com/59c1dda60001771804210205.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dda60001771804210205.png" style="cursor:pointer;display:block"><p>现在我想把<strong>本地更新</strong>的readme.txt代码<strong>推送到远程库</strong>中，使用命令如下：<br></p><img 图片67 src="http://img.mukewang.com/59c1ddbf0001271e05410203.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddbf0001271e05410203.png" style="cursor:pointer;display:block"><p>我们可以看到如上Git信息提示，推送成功，然后我们可以看看Github上的readme.txt内容 如下：</p><img 图片68 src="http://img.mukewang.com/59c1ddcf0001771f08100484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddcf0001771f08100484.png" style="cursor:pointer;display:block"><p>可以看到推送成功了，如果我们现在要<strong>推送到其他分支</strong>，比如dev分支上，我们还是那个命令<code>git push origin dev</code></p><div class="note info"><p>那么一般情况下，那些分支要推送呢？</p><p><strong>master分支是主分支</strong>，因此要<strong>时刻与远程同步</strong>；一些<strong>修复bug分支不需要推送到远程去</strong>，可以<strong>先合并</strong>到主分支(或者dev分支)上，然后把主分支master(或者dev分支)推送到远程去</p></div><hr><h5 id="抓取分支">抓取分支</h5><p><strong>多人协作时，大家都会往master分支上推送各自的修改</strong>。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到Github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2，具体的协作步骤如下：</p><p><strong>首先</strong>，我要把dev分支也要<strong>推送</strong>到远程去，如下：</p><img 图片69 src="http://img.mukewang.com/59c1ded800014adf05030151.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1ded800014adf05030151.jpg" style="cursor:pointer;display:block"><p><strong>然后</strong>，进入testgit2目录，进行<strong>克隆</strong>远程的库到本地来(模拟的协作)，如下：<br></p><img 图片70 src="http://img.mukewang.com/59c1deb70001ec7605080170.png" alt="图片描述" data-original="http://img.mukewang.com/59c1deb70001ec7605080170.png" style="cursor:pointer;display:block"><p>现在目录下生成有如下所示：<br></p><img 图片71 src="http://img.mukewang.com/59c1defe0001942707180256.png" alt="图片描述" data-original="http://img.mukewang.com/59c1defe0001942707180256.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们的小伙伴要在dev分支上做开发，就必须<strong>把远程的origin的dev分支到本地来</strong>，于是可以<strong>使用命令创建本地dev分支：<code>git checkout –b dev origin/dev</code></strong>。创建完成后，小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时，如下：<br></p><img 图片72 src="http://img.mukewang.com/59c1df160001ef1e06020730.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df160001ef1e06020730.png" style="cursor:pointer;display:block"><p><strong>下一步</strong>，小伙伴们<strong>已经向origin/dev分支上推送了提交</strong>，而我在<strong>我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库</strong>时，如下：<br></p><img 图片73 src="http://img.mukewang.com/59c1df340001209306470759.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df340001209306470759.png" style="cursor:pointer;display:block"><p>由上面可知：推送失败，<strong>因为我的小伙伴最新提交的和我试图推送的有冲突</strong>，<strong>解决的办法</strong>也很简单，上面已经提示我们，<strong>先用<code>git pull</code>把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</strong></p><img 图片74 src="http://img.mukewang.com/59c1dfa60001473e05940282.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfa60001473e05940282.png" style="cursor:pointer;display:block"><p><code>git pull</code>也失败了，原因是<strong>没有指定本地dev分支与远程origin/dev分支的链接</strong>，根据提示，<strong>设置dev和origin/dev的链接，使用<code>git branch --set-upstream dev origin/dev</code></strong>，如下：</p><img 图片75 src="http://img.mukewang.com/59c1dfc8000159c106460199.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfc8000159c106460199.png" style="cursor:pointer;display:block"><p>这回git pull成功，但是<strong>合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</strong>。解决后，提交，再push。我们可以先来看看readme.txt内容：</p><img 图片76 src="http://img.mukewang.com/59c1dff70001a87605190277.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dff70001a87605190277.png" style="cursor:pointer;display:block"><p>手动解决完后，接着再提交，再push到远程库里面去。如下所示：<br></p><img 图片77 src="http://img.mukewang.com/59c1e0130001843906050480.png" alt="图片描述" data-original="http://img.mukewang.com/59c1e0130001843906050480.png" style="cursor:pointer;display:block"><div class="note info"><p>总结一下，多人协作工作模式一般是这样的：</p><ul><li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li><li>如果<strong>推送失败</strong>，则因为远程分支比你的本地更新早，需要先用<code>git pull</code>试图合并；</li><li>如果<strong>合并有冲突</strong>，则需要解决冲突，并在本地提交，然后再用<code>git push origin branch-name</code>推送。</li></ul></div><p>感谢龙恩的贡献：<a href="http://link.zhihu.com/?target=http%3A//www.cnblogs.com/tugenhua0707/p/4050072.html" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">cnblogs.com/tugenhua070</span><span class="invisible">7/p/4050072.html</span><span class="ellipsis"></span></a></p><hr><br><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，主要偏向实战，通过实战讲解Git的用法，比较全面，包括&lt;code&gt;创建版本库&lt;/code&gt;、&lt;code&gt;版本回退&lt;/code&gt;、&lt;code&gt;撤销修改和删除文件操作&lt;/code&gt;、&lt;code&gt;远程仓库相关操作&lt;/code&gt;以及&lt;code&gt;分支操作&lt;/code&gt;，总的来说是一篇不错的文章。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Git" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/Git/"/>
    
    
      <category term="Git" scheme="http://showteeth.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>shell解析命令行过程以及eval命令</title>
    <link href="http://showteeth.tech/posts/29719.html"/>
    <id>http://showteeth.tech/posts/29719.html</id>
    <published>2019-03-15T13:46:10.000Z</published>
    <updated>2019-03-17T02:21:59.222Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的过程以及eval命令</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>HTML常用字符实体</title>
    <link href="http://showteeth.tech/posts/45689.html"/>
    <id>http://showteeth.tech/posts/45689.html</id>
    <published>2019-03-15T10:33:39.000Z</published>
    <updated>2019-03-15T13:17:01.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括<code>特色字符实体</code>、<code>常用字符实体</code>、<code>货币类字符实体</code>、<code>数字类字符实体</code>、<code>方向类字符实体</code>以及<code>其他字符实体</code>，以供需要时查阅</p></div><a id="more"></a><h2 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h2><p>一些字符在 HTML 中拥有特殊的含义，比如小于号<code>&lt;</code>用于定义 HTML 标签的开始，在这种情况下如果我们<strong>希望浏览器正确地显示这些字符</strong>，我们必须在 HTML 源码中<strong>插入字符实体</strong>来使HTML不将其当做具有特殊含义的字符，例如，要在 HTML 文档中显示小于号，我们需要这样写：<code>&amp;lt;</code> 或者 <code>&amp;#60;</code>。</p><p><strong>字符实体有三部分：</strong></p><ul><li>一个和号<code>&amp;</code></li><li>一个实体名称，或者 <code>#</code> 和一个实体编号</li><li>以及一个分号 <code>;</code></li></ul><p>使用<strong>实体名称</strong>而<strong>不是实体编号</strong>的<strong>好处</strong>在于，名称相对来说更容易记忆；而这么做的<strong>坏处</strong>是，并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。</p><p><strong>注意：实体对大小写敏感。</strong></p><hr><h2 id="特色HTML字符实体"><a href="#特色HTML字符实体" class="headerlink" title="特色HTML字符实体"></a>特色HTML字符实体</h2><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:40%}</style><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线，常用作菜单或导航中的分隔符</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>圆点，有时被用来作为菜单分隔符</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头，常用作网页“返回页面顶部”标识</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元标识</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2，数学中的平方，在数字处理中常用到，例如：<strong>1000²</strong></td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>心型，用来表达你的心</td></tr></tbody></table><hr><h2 id="常用HTML字符实体"><a href="#常用HTML字符实体" class="headerlink" title="常用HTML字符实体"></a>常用HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&nbsp;</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td>空格</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td>&amp;#38;</td><td>and符号，与</td></tr><tr><td>"</td><td>&amp;quot;</td><td>&amp;#34;</td><td>引号</td></tr><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>®</td><td>&amp;reg;</td><td>&amp;#187;</td><td>注册标志</td></tr><tr><td>™</td><td>&amp;trade;</td><td>&amp;#153;</td><td>商标标志</td></tr><tr><td>“</td><td>&amp;ldquo;</td><td>&amp;#147;</td><td>左双引号</td></tr><tr><td>”</td><td>&amp;rdquo;</td><td>&amp;#148;</td><td>右双引号</td></tr><tr><td>‘</td><td>&amp;lsquo;</td><td>&amp;#145;</td><td>做单引号</td></tr><tr><td>’</td><td>&amp;rsquo;</td><td>&amp;#146;</td><td>右单引号</td></tr><tr><td>«</td><td>&amp;laquo;</td><td>&amp;#171;</td><td>左三角双引号</td></tr><tr><td>»</td><td>&amp;raquo;</td><td>&amp;#187;</td><td>右三角双引号</td></tr><tr><td>‹</td><td>&amp;lsaquo;</td><td>&amp;#8249;</td><td>左三角单引号</td></tr><tr><td>›</td><td>&amp;rsaquo;</td><td>&amp;#8250;</td><td>右三角单引号</td></tr><tr><td>§</td><td>&amp;sect;</td><td>&amp;#167;</td><td>章节标志</td></tr><tr><td>¶</td><td>&amp;para;</td><td>&amp;#182;</td><td>段落标志</td></tr><tr><td>•</td><td>&amp;bull;</td><td>&amp;#149;</td><td>列表圆点（大）</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>列表圆点（中）</td></tr><tr><td>…</td><td>&amp;hellip;</td><td>&amp;#8230;</td><td>省略号</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线</td></tr><tr><td>¦</td><td>&amp;brvbar;</td><td>&amp;#166;</td><td>断的竖线</td></tr><tr><td>–</td><td>&amp;ndash;</td><td>&amp;#150;</td><td>短破折号</td></tr><tr><td>—</td><td>&amp;mdash;</td><td>&amp;#151;</td><td>长破折号</td></tr></tbody></table><hr><h2 id="货币类HTML字符实体"><a href="#货币类HTML字符实体" class="headerlink" title="货币类HTML字符实体"></a>货币类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>¤</td><td>&amp;curren;</td><td>&amp;#164;</td><td>一般货币符号</td></tr><tr><td>$</td><td>&nbsp;</td><td>&amp;#36;</td><td>美元符号</td></tr><tr><td>¢</td><td>&amp;cent;</td><td>&amp;#162;</td><td>分</td></tr><tr><td>£</td><td>&amp;pound;</td><td>&amp;#163;</td><td>英镑</td></tr><tr><td>¥</td><td>&amp;yen;</td><td>&amp;#165;</td><td>日元</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元</td></tr></tbody></table><hr><h2 id="数字类HTML字符实体"><a href="#数字类HTML字符实体" class="headerlink" title="数字类HTML字符实体"></a>数字类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&amp;#60;</td><td>小于号</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&amp;#62;</td><td>大于号</td></tr><tr><td>≤</td><td>&amp;le;</td><td>&amp;#8804;</td><td>小于等于号</td></tr><tr><td>≥</td><td>&amp;ge;</td><td>&amp;#8805;</td><td>大于等于号</td></tr><tr><td>×</td><td>&amp;times;</td><td>&amp;#215;</td><td>乘号</td></tr><tr><td>÷</td><td>&amp;divide;</td><td>&amp;#247;</td><td>除号</td></tr><tr><td>−</td><td>&amp;minus;</td><td>&amp;#8722;</td><td>减号</td></tr><tr><td>±</td><td>&amp;plusmn;</td><td>&amp;#177;</td><td>加/减 号</td></tr><tr><td>≠</td><td>&amp;ne;</td><td>&amp;#8800;</td><td>不等于号</td></tr><tr><td>¹</td><td>&amp;sup1;</td><td>&amp;#185;</td><td>上标1</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2</td></tr><tr><td>³</td><td>&amp;sup3;</td><td>&amp;#179;</td><td>上标3</td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>¼</td><td>&amp;frac14;</td><td>&amp;#188;</td><td>四分之一</td></tr><tr><td>¾</td><td>&amp;frac34;</td><td>&amp;#190;</td><td>四分之三</td></tr><tr><td>‰</td><td>&amp;permil;</td><td>&amp;#8240;</td><td>千分率</td></tr><tr><td>°</td><td>&amp;deg;</td><td>&amp;#176;</td><td>度</td></tr><tr><td>√</td><td>&amp;radic;</td><td>&amp;#8730;</td><td>平方根</td></tr><tr><td>∞</td><td>&amp;infin;</td><td>&amp;#8734;</td><td>无限大</td></tr></tbody></table><hr><h2 id="方向类HTML字符实体"><a href="#方向类HTML字符实体" class="headerlink" title="方向类HTML字符实体"></a>方向类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>←</td><td>&amp;larr;</td><td>&amp;#8592;</td><td>左箭头</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头</td></tr><tr><td>→</td><td>&amp;rarr;</td><td>&amp;#8594;</td><td>右箭头</td></tr><tr><td>↓</td><td>&amp;darr;</td><td>&amp;#8595;</td><td>下箭头</td></tr><tr><td>↔</td><td>&amp;harr;</td><td>&amp;#8596;</td><td>左右箭头</td></tr><tr><td>↵</td><td>&amp;crarr;</td><td>&amp;#8629;</td><td>回车箭头</td></tr><tr><td>⌈</td><td>&amp;lceil;</td><td>&amp;#8968;</td><td>左上限</td></tr><tr><td><strong>⌉</strong></td><td>&amp;rceil;</td><td>&amp;#8969;</td><td>右上限</td></tr><tr><td><strong>⌊</strong></td><td>&amp;lfloor;</td><td>&amp;#8970;</td><td>左下限</td></tr><tr><td><strong>⌋</strong></td><td>&amp;rfloor;</td><td>&amp;#8971;</td><td>右下限</td></tr></tbody></table><hr><h2 id="其他HTML字符实体"><a href="#其他HTML字符实体" class="headerlink" title="其他HTML字符实体"></a>其他HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>♠</td><td>&amp;spades;</td><td>&amp;#9824;</td><td>黑桃</td></tr><tr><td>♣</td><td>&amp;clubs;</td><td>&amp;#9827;</td><td>梅花</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>红桃，心</td></tr><tr><td>♦</td><td>&amp;diams;</td><td>&amp;#9830;</td><td>方块牌</td></tr><tr><td>◊</td><td>&amp;loz;</td><td>&amp;#9674;</td><td>菱形</td></tr><tr><td>†</td><td>&amp;dagger;</td><td>&amp;#8224;</td><td>匕首</td></tr><tr><td>‡</td><td>&amp;Dagger;</td><td>&amp;#8225;</td><td>双剑号</td></tr><tr><td>¡</td><td>&amp;iexcl;</td><td>&amp;#161;</td><td>反向感叹号</td></tr><tr><td>¿</td><td>&amp;iquest;</td><td>&amp;#191;</td><td>反向问号</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/cutdragonhit/p/9785350.html" target="_blank" rel="noopener">HTML实体符号</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/4159374.html" target="_blank" rel="noopener">网页中常用HTML字符实体</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括&lt;code&gt;特色字符实体&lt;/code&gt;、&lt;code&gt;常用字符实体&lt;/code&gt;、&lt;code&gt;货币类字符实体&lt;/code&gt;、&lt;code&gt;数字类字符实体&lt;/code&gt;、&lt;code&gt;方向类字符实体&lt;/code&gt;以及&lt;code&gt;其他字符实体&lt;/code&gt;，以供需要时查阅&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="http://showteeth.tech/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://showteeth.tech/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux通配符和正则表达式及其区别</title>
    <link href="http://showteeth.tech/posts/37480.html"/>
    <id>http://showteeth.tech/posts/37480.html</id>
    <published>2019-03-15T07:42:47.000Z</published>
    <updated>2019-03-17T02:19:28.214Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像<code>awk</code>、<code>sed</code>、<code>grep</code>使用正则表达式、像<code>find</code>、<code>ls</code>、<code>cp</code>使用通配符。</p></div><a id="more"></a><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls <span class="built_in">test</span>*.txt</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls d*.txt</span><br><span class="line">  ls: cannot access d*.txt: No such file or directory</span><br></pre></td></tr></table></figure><hr><h3 id="通配符的作用方式"><a href="#通配符的作用方式" class="headerlink" title="通配符的作用方式"></a>通配符的作用方式</h3><p><strong>通配符是由<code>shell</code>处理的</strong>(不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍), 它只会出现在命令的<strong>参数</strong>里(它不用在命令名称里， 也不用在操作符上)。<strong>当shell在参数中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个<u>普通字符传递给命令</u>，然后再由命令进行处理</strong>。总之，<strong>通配符实际上就是一种shell实现的路径扩展功能</strong>。在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。</p><p>我们回过头分析上面命令：</p><ul><li>在第2个命令中，<strong>test*.txt 实际shell搜索文件,找到了符合条件的文件，命令会变成</strong>：<code>ls test2.txt test3.txt test.txt</code> ,实际在执行<code>ls</code>时候传给它的<strong>参数</strong>是test2.txt test3.txt test.txt。</li><li>而命令3，<code>d*.txt</code> 由于当前目录下面没有这样的文件或目录，直接将<code>d*.txt</code>作为普通字符传给<code>ls</code>作为参数。这个时候<code>*</code>只是一个普通的 <code>ls</code>参数而已，已经<strong>失去了它通配意义</strong>。由于找不到文件，所以会出现：无法访问提示！</li></ul><p>了解了shell通配符，我们现在看下，shell常见通配符有哪些了。</p><hr><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>*</td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td>?</td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td>[list]</td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td>[!list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[^list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[^0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[c1-c2]</td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)<strong>其一字符串</strong></td><td>a{abc,xyz,123}b：a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><div class="note info"><p>需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种</p></div><hr><h3 id="通配符示例"><a href="#通配符示例" class="headerlink" title="通配符示例"></a>通配符示例</h3><p><code>[!list]</code> 和<code>[^list]</code>：</p><blockquote><p><code>ls test[^1-2].txt</code><br>test3.txt</p></blockquote><blockquote><p><code>ls test[!1-2].txt</code><br>test3.txt</p></blockquote><p>注意不会出现test.txt，因为test和.txt之间必须要有一个字符，而test.txt不具备这个条件</p><hr><p><br></p><h2 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>^word</td><td>待搜寻的字串(word)在<strong>行首</strong></td><td>grep -n ‘^#’ regular_express.txt：搜寻行首为 # 开始的那一行，并列出行号</td></tr><tr><td>word$</td><td>待搜寻的字串(word)在<strong>行尾</strong></td><td>grep -n ‘!$’ regular_express.txt：将行尾为 ! 的那一行打印出来，并列出行号</td></tr><tr><td>.</td><td>代表<strong>一定有一个任意字符</strong>的字符</td><td>grep -n ‘e.e’ regular_express.txt：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定<strong>仅有一个字符，而空白字符也是字符！</strong></td></tr><tr><td>\</td><td>转义字符，将特殊符号的特殊意义去除</td><td>grep -n \’ regular_express.txt：搜寻含有单引号 ‘ 的那一行</td></tr><tr><td>*</td><td>重复<strong>零个到无穷多个的前一个字符</strong></td><td>grep -n ‘ess*’ regular_express.txt：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字串。另外，之前也可以紧接着一个 RE 字符，例如任意字符则为 “.”</td></tr><tr><td>[list]</td><td>字符集合，匹配list 中的任意单个字符</td><td>grep -n ‘g[ld]’ regular_express.txt：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思</td></tr><tr><td>[n1-n2]</td><td>字符范围，匹配n1-n2中的任意单个字符</td><td>grep -n ‘[A-Z]’ regular_express.txt：搜寻含有大写字母的那一行。需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关。</td></tr><tr><td>[^list]</td><td>字符集合，匹配 除list 中的任意单一字符(一定要有一个)</td><td>不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字</td></tr><tr><td>{n,m}</td><td>连续 n 到 m 个的前一个字符；若为 {n} 则是连续 n 个的前一个字符；若是 {n,} 则是连续 n 个以上的前一个字符</td><td>grep -n ‘go{2,3}g’ regular_express.txt：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)</td></tr></tbody></table><hr><h3 id="延伸正则表达式字符"><a href="#延伸正则表达式字符" class="headerlink" title="延伸正则表达式字符"></a>延伸正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>重复<strong>一个或一个以上的前一个字符</strong></td><td>egrep -n ‘go+d’ regular_express.txt：搜寻 (god) (good) (goood)… 等等的字串，那个 o+ 代表一个以上的 o</td></tr><tr><td>?</td><td><strong>零个或一个的前一个字符</strong></td><td>egrep -n ‘go?d’ regular_express.txt：搜寻 (gd) (god) 这两个字串，那个 o? 代表空的或 1 个 o</td></tr><tr><td>&#124;</td><td>用<strong>或( or )的方式找出数个字串</strong></td><td>egrep -n ‘gd&#124;good’ regular_express.txt：搜寻 gd 或 good 这两个字串</td></tr><tr><td>()</td><td>找出<strong>群组字串</strong></td><td>egrep -n ‘g(la&#124;oo)d’ regular_express.txt：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来</td></tr><tr><td>()+</td><td><strong>多个重复群组的判别</strong></td><td>echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’</td></tr></tbody></table><div class="note info"><p><code>grep</code> <strong>默认仅支持基础正则表达式</strong>，如果要<strong>使用延伸型正则表达式</strong>，你可以使用 <code>grep -E</code> ， 不过更建议直接使用 <code>egrep</code>！直接区分指令比较好记忆！其实 <code>egrep</code> 与 <code>grep -E</code> 是类似命令别名的关系啦！</p></div><h2 id="通配符和正则表达式关系"><a href="#通配符和正则表达式关系" class="headerlink" title="通配符和正则表达式关系"></a>通配符和正则表达式关系</h2><ul><li>在<strong>文本过滤工具里，都是用正则表达式</strong>，比如像<code>awk</code>、<code>sed</code>、<code>grep</code>等，是针对文件的内容的；而<strong>通配符多用在文件名</strong>上，比如<code>find</code>、<code>ls</code>、<code>cp</code>等等</li><li>正则表达式中有部分与通配符是相近的含义，如<code>[list]</code>、<code>[n1-n2]</code>、<code>[^list]</code>，但也有一些差异非常大，如<code>*</code> <strong>在通配符中表示匹配0或多个</strong>字符(可以独立使用)，但<strong>在正则表达式中表示重复零个到无穷多个的<u>前一个字符</u></strong>(不能独立使用)</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://blog.csdn.net/swjtuwyp/article/details/51817472" target="_blank" rel="noopener">linux通配符和正则表达式</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;使用正则表达式、像&lt;code&gt;find&lt;/code&gt;、&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;cp&lt;/code&gt;使用通配符。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell-循环结构</title>
    <link href="http://showteeth.tech/posts/16486.html"/>
    <id>http://showteeth.tech/posts/16486.html</id>
    <published>2019-03-15T03:04:40.000Z</published>
    <updated>2019-03-17T07:43:23.499Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇博客主要学习了<code>shell</code>的循环结构，包括<code>for</code>、<code>while</code>、<code>until</code>循环，重点学习了前两个，整理了这两种循环的不同使用情形，同时也学习了循环控制结构的<code>break</code>和<code>continue</code>语句</p></div><a id="more"></a><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环适用于<strong>已经知道需要进行多少次的循环</strong>，所以for循环也叫<strong>固定循环</strong>。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      程序段</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p>为了防止可能的字符分割(变量存在空格)问题，con1 con2 con3都需要被引用(使用双引号括起来)，关于字符分割的示例可以查看<a href="http://showteeth.tech/posts/58105.html">shell-if条件测试</a></p></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用变量进行循环"><a href="#使用变量进行循环" class="headerlink" title="使用变量进行循环"></a>使用变量进行循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line">field1=$(cut -d <span class="string">' '</span> -f 1 test.txt)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;field1&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>this<br>that<br>there<br>those</p></blockquote><blockquote><p><code>name=&quot;my name is test&quot;</code><br><code>for i in ${name};do echo $i;done</code></p></blockquote><p><strong>输出</strong>：</p><blockquote><p>my<br>name<br>is<br>test</p></blockquote><hr><h4 id="使用seq命令进行循环"><a href="#使用seq命令进行循环" class="headerlink" title="使用seq命令进行循环"></a>使用seq命令进行循环</h4><p><strong>seq命令的用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line"></span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -f, --format=FORMAT      use <span class="built_in">printf</span> style floating-point FORMAT</span><br><span class="line">  -s, --separator=STRING   use STRING to separate numbers (default: \n)</span><br><span class="line">  -w, --equal-width        equalize width by padding with leading zeroes</span><br></pre></td></tr></table></figure><p></p><p><strong>默认用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>设置步长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 2 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>1<br>3<br>5</p></blockquote><p><strong>-w设置输出等长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w 1 2 12`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>01<br>03<br>05<br>07<br>09<br>11</p></blockquote><hr><h4 id="使用特殊符号-进行循环"><a href="#使用特殊符号-进行循环" class="headerlink" title="使用特殊符号{}进行循环"></a>使用特殊符号{}进行循环</h4><p><strong>特殊符号<code>{}</code>用法</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  &#123;FIRST..LAST..INCREMENT &#125;</span><br><span class="line">  </span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><p></p><p>对<strong>数字</strong>循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字循环设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>1<br>3<br>5</p></blockquote><p>对<strong>字母</strong>循环：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字母循环也可以设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a&#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..2&#125;&#123;a..d&#125;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>a<br>b<br>c<br>d</p></blockquote><blockquote><p>a<br>c</p></blockquote><blockquote><p>aa<br>ab<br>ac<br>ad</p></blockquote><blockquote><p>1a<br>1b<br>1c<br>1d<br>2a<br>2b<br>2c<br>2d</p></blockquote><p>特殊符号<code>{}</code>中的<strong>两个小数点来代表连续出现的意思</strong>，更多关于特殊符号<code>{}</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用特殊符号-进行循环-1"><a href="#使用特殊符号-进行循环-1" class="headerlink" title="使用特殊符号(())进行循环"></a>使用特殊符号(())进行循环</h4><p><strong>使用形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> （（ 初始值; 限制值; 执行步阶 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i=i+2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i+=2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>特殊符号<code>(())</code>表示<strong>执行计算</strong>，和linux <code>let</code>命令相似，更多关于特殊符号<code>(())</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用通配符进行循环"><a href="#使用通配符进行循环" class="headerlink" title="使用通配符进行循环"></a>使用通配符进行循环</h4><p>通配符主要有星号(<code>*</code>)和问号(<code>?</code>)，用来<strong>模糊搜索文件</strong>。关于shell中常见的通配符以及通配符和正则表达式的区别请参考<a href="http://showteeth.tech/posts/37480.html">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">test</span>*.txt</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  test2.txt  </span><br><span class="line">  test3.txt  </span><br><span class="line">  test.txt  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="comment">#           ^  Bash 在检测到通配表达式时，</span></span><br><span class="line"><span class="comment">#+             会进行文件名扩展。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ls -l <span class="string">"<span class="variable">$file</span>"</span>  <span class="comment"># 列出 $PWD（当前工作目录）下的所有文件。</span></span><br><span class="line">  <span class="comment">#  回忆一下，通配符 "*" 会匹配所有的文件名，</span></span><br><span class="line">  <span class="comment">#+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  如果没有匹配到文件，那么它将会扩展为它自身。</span></span><br><span class="line">  <span class="comment">#  为了防止出现这种情况，需要设置 nullglob 选项。</span></span><br><span class="line">  <span class="comment">#+    (shopt -s nullglob)。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> [jx]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="variable">$file</span>    <span class="comment"># 删除当前目录下所有以 "j" 或 "x" 开头的文件。</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Removed file \"<span class="variable">$file</span>\""</span>.</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="每个元素多个参数"><a href="#每个元素多个参数" class="headerlink" title="每个元素多个参数"></a>每个元素多个参数</h4><p>用于循环的每个参数可以继续分解为多个参数，这里使用 <code>set</code> 命令<strong>强制解析循环内容中的每一个元素</strong>，并将元素的每一个部分分配给位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个行星与其到太阳的距离放在一起。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> planet <span class="keyword">in</span> <span class="string">"Mercury 36"</span> <span class="string">"Venus 67"</span> <span class="string">"Earth 93"</span> <span class="string">"Mars 142"</span> <span class="string">"Jupiter 483"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">set</span> -- <span class="variable">$planet</span>  <span class="comment">#  解析变量 "planet"</span></span><br><span class="line">                  <span class="comment">#+ 并将其每个部分赋值给位置参数。</span></span><br><span class="line">  <span class="comment"># "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。</span></span><br><span class="line">  <span class="comment"># 你可以使用数组来保存</span></span><br><span class="line">  <span class="comment">#         original_params=("$@")</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>        <span class="variable">$2</span>,000,000 miles from the sum"</span></span><br><span class="line">  <span class="comment">#-------两个制表符---将后面的一系列 0 连到参数 $2 上。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>Mercury 36,000,000 miles from the sum<br>Venus 67,000,000 miles from the sum<br>Earth 93,000,000 miles from the sum<br>Mars 142,000,000 miles from the sum<br>Jupiter 483,000,000 miles from the sum</p></blockquote><p>示例来源于<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part3/11_1_loops.html" target="_blank" rel="noopener">这本书</a></p><hr><h4 id="集成管道符"><a href="#集成管道符" class="headerlink" title="集成管道符"></a>集成管道符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$( find $directory -type 1 )</span>"</span>   <span class="comment"># -type 1 = 符号链接</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span> | sort</span><br></pre></td></tr></table></figure><blockquote><p><code>for i in test*.txt;do echo $i;done |wc -l</code></p></blockquote><blockquote><p>3</p></blockquote><hr><p><br></p><h2 id="while-until循环"><a href="#while-until循环" class="headerlink" title="while/until循环"></a>while/until循环</h2><p><code>while/until</code>循环适用于条件判断，<strong>条件成立则进行循环，具体多少次的循环不知道</strong>，只要条件成立即可，所以<code>while/until</code>循环也叫<strong>不定循环</strong>。<code>while</code>和<code>until</code>循环在进行条件判断时执行的是完全相反的操作，<code>while</code>是条件成立则进行循环，而<code>until</code>这是条件成立终止循环，是完全相反的，所以后续的学习主要集中于使用较多的<code>while</code>循环，<code>until</code>循环一样的道理，只是将条件判断改变即可。</p><h3 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止</span></span><br><span class="line"><span class="keyword">while</span> [ condition ]  <span class="comment"># 括号内的状态就是判断式</span></span><br><span class="line"><span class="keyword">do</span>                   <span class="comment"># do 是循环的开始！</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span>                 <span class="comment"># done 是循环的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 condition 条件成立时，就终止循环， 否则就持续进行循环的程序段(和while循环相反)</span></span><br><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>while</code>和<code>until</code>循环中当<strong>使用条件测试进行循环时和前面在if条件测试分支结构中使用的条件测试是相同的</strong>，具体的各种测试形式这里就不在列出，后续可以查看<a href="http://showteeth.tech/posts/58105.html">这篇文章</a></p></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用条件测试进行循环"><a href="#使用条件测试进行循环" class="headerlink" title="使用条件测试进行循环"></a>使用条件测试进行循环</h4><p>和 <code>if</code> 一样， 使用条件测试进行循环时 <code>while</code> 会计算一系列命令的退出状态。只要<strong>退出状态为零(条件测试执行成功)，它就执行循环内的命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=0  <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0  <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]   <span class="comment"># 变量使用双引号在进行变量替换的同时防止字符分割</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+1))   <span class="comment"># 每次 i 都会增加 1 </span></span><br><span class="line">    s=$((<span class="variable">$s</span>+<span class="variable">$i</span>))  <span class="comment"># 每次都会加总一次！</span></span><br><span class="line">                  <span class="comment"># 使用了特殊符号$(())来执行计算</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is  <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p><mark>如果一个 while 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止，这个也和if命令相同:</mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环，输出this is true</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">false</span>;<span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="循环读取文件"><a href="#循环读取文件" class="headerlink" title="循环读取文件"></a>循环读取文件</h4><p>使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this is a test<br>that is a test<br>there is a test<br>those are tests</p></blockquote><p>也可以<strong>按字段读取文件的每行内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 field3 field4 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field3</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field4</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this<br>is a test<br>that<br>is a test<br>there<br>is a test<br>those<br>are tests</p></blockquote><blockquote><p>this<br>is<br>a<br>test<br>that<br>is<br>a<br>test<br>there<br>is<br>a<br>test<br>those<br>are<br>tests<br><em>这是空行</em></p></blockquote><div class="note info"><ul><li>为了重定向文件到循环中，可以将重定向操作符放置到 <code>done</code> 语句之后。循环使用 <code>read</code> 从重定向文件中读取字段；<strong>这个 <code>read</code> 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾，这时候它的退出状态为非零数值，因此终止循环</strong>。</li><li><strong>指定字段数小于每行字段数</strong>：第一个字段为第一个空格之前的内容，剩下的所有字段为第二个字段(这里只指定了两个字段来读取每一行)</li><li><strong>指定字段数大于每行字段数</strong>：不足的字段使用空格填补</li></ul></div><hr><h4 id="集成管道符-1"><a href="#集成管道符-1" class="headerlink" title="集成管道符"></a>集成管道符</h4><p>上面使用使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件的操作也可以使用管道符实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt|<span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>因为管道将会在<strong>子 shell</strong> 中执行循环，<strong>当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失</strong>，记住这一点很重要(这个还没测试过，先mark一下)</p></div><hr><p><br></p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break-终止循环"><a href="#break-终止循环" class="headerlink" title="break-终止循环"></a>break-终止循环</h3><p><code>break</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳出当前所在的循环体(终止循环)，执行循环体之后的语句</strong>。</p><h4 id="终止单层循环"><a href="#终止单层循环" class="headerlink" title="终止单层循环"></a>终止单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"></span><br><span class="line">  <span class="built_in">break</span>---------+</span><br><span class="line">                |</span><br><span class="line">  commands      |</span><br><span class="line">  commands      | 跳出(终止)循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">                |</span><br><span class="line"><span class="keyword">done</span>            |</span><br><span class="line">                |</span><br><span class="line">commands&lt;-------+</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; <span class="built_in">break</span>  <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>在循环中一旦发现目录，则立即停止循环并退出</p><hr><h4 id="终止多层循环"><a href="#终止多层循环" class="headerlink" title="终止多层循环"></a>终止多层循环</h4><p><mark><code>break</code> 命令可以接受一个参数，普通的 <code>break</code> 命令<strong>仅仅跳出其所在的那层循环</strong>，而 <code>break N</code> 命令则可以<strong>跳出其上 N 层的循环</strong></mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outerloop</span>:   "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> innerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$innerloop</span> "</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$innerloop</span>"</span> -eq 3 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">break</span> 2 <span class="comment"># 尝试一下 break 2 看看会发生什么。</span></span><br><span class="line">             <span class="comment"># （它同时中止了内层和外层循环。）</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>直接使用<code>break</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3<br>Group 2: 1 2 3<br>Group 3: 1 2 3<br>Group 4: 1 2 3<br>Group 5: 1 2 3</p></blockquote><p>使用了<code>break 2</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3</p></blockquote><p>可以发现使用<code>break 2</code>不仅跳出了本层循环，还跳出了本层循环的外层循环，也就是跳出了2层循环</p><hr><h3 id="continue-进行下一次循环"><a href="#continue-进行下一次循环" class="headerlink" title="continue-进行下一次循环"></a>continue-进行下一次循环</h3><p><code>continue</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</strong>。</p><h4 id="影响单层循环"><a href="#影响单层循环" class="headerlink" title="影响单层循环"></a>影响单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]&lt;-------+</span><br><span class="line"><span class="keyword">do</span>                         |</span><br><span class="line">                           |</span><br><span class="line">  commands                 | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">  commands                 |</span><br><span class="line">                           |</span><br><span class="line">  <span class="built_in">continue</span> ----------------+</span><br><span class="line"></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">commands</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -d <span class="string">"<span class="variable">$f</span>"</span> ] || <span class="built_in">continue</span>    <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line">    chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>如果是目录，添加权限；如果不是，跳过当前循环，continue 后面代码不再执行，而是直接执行下次循环。</p><hr><h4 id="影响多层循环"><a href="#影响多层循环" class="headerlink" title="影响多层循环"></a>影响多层循环</h4><p><mark>与 <code>break</code> 类似，<code>continue</code> 也可以接受一个参数，普通的 <code>continue</code> 命令<strong>仅仅影响其所在的那层循环</strong>，而 <code>continue N</code> 命令则可以<strong>影响其上 N 层的循环</strong></mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outer <span class="keyword">in</span> I II III IV V           <span class="comment"># 外层循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span>; <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outer</span>: "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> inner <span class="keyword">in</span> 1 2 3 4 5 6 7 8 9 10  <span class="comment"># 内层循环</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$inner</span>"</span> -eq 7 &amp;&amp; <span class="string">"<span class="variable">$outer</span>"</span> = <span class="string">"III"</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">continue</span> 2  <span class="comment"># 影响两层循环，包括“外层循环”。</span></span><br><span class="line">                  <span class="comment"># 将其替换为普通的 "continue"，那么只会影响内层循环。</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$inner</span> "</span>  <span class="comment"># 7 8 9 10 将不会出现在 "Group III."中。</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>直接使用<code>continue</code>的输出结果(只有第三组少了数字7)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6 8 9 10<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><p>使用了<code>continue 2</code>的输出结果(第三组7以后的数字全消失了)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><div class="note warning"><p><code>continue N</code> 结构<strong>不易理解并且可能在一些情况下有歧义，因此不建议使用</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇博客主要学习了&lt;code&gt;shell&lt;/code&gt;的循环结构，包括&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;until&lt;/code&gt;循环，重点学习了前两个，整理了这两种循环的不同使用情形，同时也学习了循环控制结构的&lt;code&gt;break&lt;/code&gt;和&lt;code&gt;continue&lt;/code&gt;语句&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="shell编程" scheme="http://showteeth.tech/categories/Linux/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>shell-if条件测试</title>
    <link href="http://showteeth.tech/posts/58105.html"/>
    <id>http://showteeth.tech/posts/58105.html</id>
    <published>2019-03-14T15:35:59.000Z</published>
    <updated>2019-03-17T02:20:33.540Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了shell中的条件测试命令，包括<code>test</code>命令、<code>[ ]</code>、<code>[[ ]]</code>、<code>(( ))</code>，主要介绍了前三个，其中<code>[ ]</code>和<code>[[ ]]</code>可以用在<strong>if条件测试分支结构</strong>中，两者之间的优缺点在文中也有讲解；也学习了<strong>if条件测试分支结构</strong>在多种情形下的多种形式以及<code>exit</code>命令设定程序退出状态</p></div><a id="more"></a><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>本来打算直接学习if判断分支结构，但是在阅读相关资料后发现if判断分支中的条件判断其实就是shell条件测试，所以这里先对shell的条件测试进行学习。shell的条件测试可以使用<code>test</code>命令、<code>[ ]</code>判断式、<code>[[ ]]</code>判断式以及<code>(( ))</code>判断式，其中<code>[ ]</code>和<code>[[ ]]</code>是if判断分支结构中主要使用的。</p><h3 id="test命令测试"><a href="#test命令测试" class="headerlink" title="test命令测试"></a>test命令测试</h3><p>test命令是 shell 环境中用于测试条件表达式的工具，当条件成立时，命令执行后的返回值为0，否则为其他数值。</p><h4 id="test命令结构"><a href="#test命令结构" class="headerlink" title="test命令结构"></a>test命令结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> ! EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -a EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -o EXPRESSION</span><br></pre></td></tr></table></figure><p><mark><strong>test EXPRESSION</strong>执行结果并<strong>不会显示任何信息</strong>，如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</mark></p><p><strong>使用<code>$?</code></strong>：</p><blockquote><p><code>test -f test1.txt</code> # 不输出结果<br><code>echo $?</code> # $?返回最后运行的命令的结束代码</p></blockquote><blockquote><p>0 # 正常运行的命令结束代码为0，也就是条件成立</p></blockquote><blockquote><p><code>test -f test2.txt</code><br><code>echo $?</code></p></blockquote><blockquote><p>1 # 出错或者异常结束代码为非0，也就是条件不成立</p></blockquote><p><strong>使用<code>&amp;&amp;</code>和<code>||</code>的组合</strong>：</p><blockquote><p><code>test -f test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><p><strong>注意<code>&amp;&amp;</code>和<code>||</code>的顺序不能随意，如果上面的顺序调换</strong>：</p><blockquote><p><code>test -f test2.txt || echo &quot;Not exist&quot; &amp;&amp; echo &quot;exist&quot;</code><br>Not exist<br>exist</p></blockquote><p>上面的判断是按顺序执行的，具体<code>&amp;&amp;</code>和<code>||</code>前后命令的执行规则参考<a href="http://showteeth.tech/posts/55603.html">这篇博客</a></p><hr><h4 id="文件是否存在测试"><a href="#文件是否存在测试" class="headerlink" title="文件是否存在测试"></a>文件是否存在测试</h4><p>使用示例：<strong>test -e filename</strong></p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-e</strong></td><td>该“文件名”<strong>是否存在</strong>（常用）</td></tr><tr><td><strong>-f</strong></td><td>该“文件名”是否存在且为<strong>文件</strong>（file）（常用）</td></tr><tr><td><strong>-d</strong></td><td>该“文件名”是否存在且为<strong>目录</strong>（directory）（常用）</td></tr><tr><td><strong>-s</strong></td><td>侦测该文件名是否存在且为“非空白文件”(<strong>文件大小不为0</strong>) （常用）</td></tr><tr><td>-b</td><td>该“文件名”是否存在且为一个 block device 设备</td></tr><tr><td>-c</td><td>该“文件名”是否存在且为一个 character device 设备</td></tr><tr><td>-S</td><td>该“文件名”是否存在且为一个 Socket 文件</td></tr><tr><td>-p</td><td>该“文件名”是否存在且为一个 FIFO （pipe） 文件</td></tr><tr><td>-L</td><td>该“文件名”是否存在且为一个<strong>链接文件</strong></td></tr></tbody></table><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -e test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -d test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="权限测试"><a href="#权限测试" class="headerlink" title="权限测试"></a>权限测试</h4><p>使用示例：<strong>test -r filename</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>侦测该文件名是否存在且<strong>具有“可读”的权限</strong></td></tr><tr><td>-w</td><td>侦测该文件名是否存在且<strong>具有“可写”的权限</strong></td></tr><tr><td>-x</td><td>侦测该文件名是否存在且<strong>具有“可执行”的权限</strong></td></tr><tr><td>-u</td><td>侦测该文件名是否存在且具有“SUID”的属性</td></tr><tr><td>-g</td><td>侦测该文件名是否存在且具有“SGID”的属性</td></tr><tr><td>-k</td><td>侦测该文件名是否存在且具有“Sticky bit”的属性</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt</p></blockquote><blockquote><p><code>test -r test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -w test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -x test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="文件之间的测试"><a href="#文件之间的测试" class="headerlink" title="文件之间的测试"></a>文件之间的测试</h4><p>使用示例：<strong>test file1 -nt file2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-nt</td><td>（<strong>newer than</strong>）判断 file1 是否比 file2 新</td></tr><tr><td>-ot</td><td>（<strong>older than</strong>）判断 file1 是否比 file2 旧</td></tr><tr><td>-ef</td><td>判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上（通过硬链接两个文件名指向相同的文件）</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt<br>-rw-rw-r– 1 user user 0 Mar 14 21:20 test2.txt</p></blockquote><blockquote><p><code>test test1.txt -nt test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test test1.txt -ot test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><hr><h4 id="整数之间的测试"><a href="#整数之间的测试" class="headerlink" title="整数之间的测试"></a>整数之间的测试</h4><p>使用示例：<strong>test n1 -eq n2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>两数值相等 （<strong>equal</strong>）</td></tr><tr><td>-ne</td><td>两数值不等 （<strong>not equal</strong>）</td></tr><tr><td>-gt</td><td>n1 大于 n2 （<strong>greater than</strong>）</td></tr><tr><td>-lt</td><td>n1 小于 n2 （<strong>less tha</strong>n）</td></tr><tr><td>-ge</td><td>n1 大于等于 n2 （<strong>greater than or equal</strong>）</td></tr><tr><td>-le</td><td>n1 小于等于 n2 （<strong>less than or equal</strong>）</td></tr></tbody></table><blockquote><p><code>test 2 -eq 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist<br><code>test 2 -ne 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="字符串的测试"><a href="#字符串的测试" class="headerlink" title="字符串的测试"></a>字符串的测试</h4><p>使用示例：<strong>test str1 == str2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>test -z string</td><td>判定字串是否为 0 ，若 string <strong>为空字串(空格不为空)，则为 true</strong></td></tr><tr><td>test -n string</td><td>判定字串是否非为 0 ，若 string <strong>为空字串，则为 false</strong>。 -n 亦可省略</td></tr><tr><td>test str1 == str2</td><td>判定 str1 <strong>是否等于</strong> str2 ，若相等，则回传 true</td></tr><tr><td>test str1 != str2</td><td>判定 str1 <strong>是否不等于</strong> str2 ，若相等，则回传 false</td></tr></tbody></table><p>注意：<code>==</code>前后需要空格隔开，不用空格隔开可能会出问题</p><hr><h4 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h4><p>使用示例：<strong>test -r file -a -x file</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>（<strong>and</strong>）两状况同时成立！例如 <em>test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true</em>。</td></tr><tr><td>-o</td><td>（<strong>or</strong>）两状况任何一个成立！例如 <em>test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true</em>。</td></tr><tr><td>!</td><td>反向状态，如 <em>test ! -x file ，当 file 不具有 x 时，回传 true</em></td></tr></tbody></table><hr><div class="note info"><p><code>test</code>命令最需要注意的是：单纯的<code>test</code>命令不会返回任何信息，所以如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</p></div><hr><h3 id="判断式"><a href="#判断式" class="headerlink" title="[]判断式"></a>[]判断式</h3><div class="note info"><ul><li>条件测试会使用一个特殊的命令 <code>[</code>，等同于 <code>test</code> 命令，它是一个<strong>内建命令</strong>，写法更加简洁高效。该命令<strong>将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）</strong></li><li>Bash 在 2.02 版本中引入了扩展测试命令 <code>[[ ]]</code>，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， <code>[[</code> 是一个<strong>关键字 而非一个命令</strong>，Bash 将 <code>[[ $a -lt $b ]]</code> 视为一整条语句，执行并返回退出状态</li><li><code>[]</code>有<a href="http://showteeth.tech/posts/55603.html">几种不同的功能</a>，如果想要用来作为条件测试必须要注意<strong>中括号的两端以及判断符前后需要有空白字符来分隔</strong>，如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code></li></ul><ul><li>中括号和test命令的各种测试是相同的，<code>[ ]</code>判断式和test命令可以相互转换，比如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code>可以转换为test “$HOME” == “$MAIL”，所以上面提到的各种测试都可以在中括号中使用</li><li>在中括号 <code>[ ]</code> 内的<strong>每个元件都需要有空白键来分隔</strong></li><li>在中括号内的<strong>变量</strong>，最好都<strong>以双引号括号起来</strong></li><li>在中括号内的<strong>常数</strong>，最好都<strong>以单或双引号括号起来</strong></li><li><code>[ ]</code>以及<code>test</code>命令中所有的表达式和操作符都被 shell 看作是命令参数，对于 bash 有特殊含义的字符，比如说 <code>(</code>、 <code>)</code>、<code>&gt;</code>、<code>&lt;</code><strong>必须引起来或者是转义</strong></li></ul><ul><li>在复合测试中，仅仅引用字符串可能还不够，比如表达式<code>[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</code> 在<strong>某些 Bash 版本</strong>下，如果 <code>$string</code> 为空可能会出错。更加安全的方式是，<strong>对于可能为空的字符串，添加一个额外的字符</strong>，例如 <code>[ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]</code>（其中的 x 互相抵消）</li></ul></div><p><strong>[]判断式需要注意的问题-字符分割</strong>：</p><blockquote><p>test=”my name”<br>[ ${test} == “my” ]</p></blockquote><blockquote><p>bash: [: too many arguments</p></blockquote><p>上面的出错显示判断式中存在太多参数，但是明明就只有test一个参数，为什么会出现这个问题呢？因为 <code>${test}</code> 如果<strong>没有使用双引号括起来</strong>，那么上面的判定式会变成：</p><blockquote><p>[ my name == “my” ]</p></blockquote><p>如果写成这个样子就会发现问题，因为一个判断式仅能有两个数据的比对，上面 my 与 name 还有 “my” 就有三个数据！所以会出错，而我们需要的是：</p><blockquote><p>[ “my name” == “my” ]</p></blockquote><p>所以这就说明了(如果字符串中带有空格，以防万一都带上吧)需要<strong>使用双引号括起来，不用单引号</strong>的原因是单引号会<a href="http://showteeth.tech/posts/55603.html">防止任何变量替换</a></p><hr><h3 id="判断式-1"><a href="#判断式-1" class="headerlink" title="[[]]判断式"></a>[[]]判断式</h3><p>在 <strong>Bash(限制条件)</strong> 里，<code>[[ ]]</code> 是比 <code>[ ]</code> 更加通用的写法，使用 <code>[[ ]]</code> 代替<code>[ ]</code>可以避免很多逻辑错误。比如可以在 <code>[[ ]]</code> 中使用 <code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code> 和 <code>&gt;</code> 操作符，而在 <code>[ ]</code> 中使用则会报错</p><p>下面列出<code>[[ ]]</code> 比 <code>[ ]</code>更好用的几点：</p><h4 id="使用正则匹配"><a href="#使用正则匹配" class="headerlink" title="使用正则匹配"></a>使用正则匹配</h4><p>增加了一个重要的新的字符串表达式来使用正则匹配</p><blockquote><p><strong>string1 =~ regex</strong></p></blockquote><h4 id="不需要使用双引号"><a href="#不需要使用双引号" class="headerlink" title="不需要使用双引号"></a>不需要使用双引号</h4><p><code>[[ ]]</code>判断式<strong>不需要</strong>对其中的变量和常数使用<strong>双引号</strong>括起来：</p><blockquote><p><code>[[ ${test} == &quot;my&quot; ]] &amp;&amp; echo &quot;right&quot; || echo &quot;wrong&quot;</code><br>wrong</p></blockquote><h4 id="操作符支持模式匹配"><a href="#操作符支持模式匹配" class="headerlink" title="==操作符支持模式匹配:"></a>==操作符支持模式匹配:</h4><blockquote><p>FILE=foo.bar<br>if [[ $FILE == foo.* ]]; then<br>> echo “$FILE matches pattern ‘foo.*‘“<br>> fi</p></blockquote><blockquote><p>foo.bar matches pattern ‘foo.*’</p></blockquote><p>使<code>[[ ]]</code>有助于计算文件和路径名，如果<code>foo.*</code>外加了双引号就没有正则匹配的意思，单纯的字符相等的意思</p><h4 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h4><blockquote><p><code>[[ condition1 &amp;&amp; condition2 ]]</code> <code>[[ condition1 || condition2 ]]</code></p></blockquote><h4 id="对不同进制的数直接进行比较"><a href="#对不同进制的数直接进行比较" class="headerlink" title="对不同进制的数直接进行比较"></a>对不同进制的数直接进行比较</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">decimal=15</span><br><span class="line">octal=017   <span class="comment"># = 15 (十进制)</span></span><br><span class="line">hex=0x0f    <span class="comment"># = 15 (十进制)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span>       <span class="comment"># 15 不等于 017</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在单括号 [ ] 之间不会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span>                <span class="comment"># 15 等于 017</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在双括号 [[ ]] 之间会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$hex</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$hex</span>"</span>                  <span class="comment"># 15 等于 0x0f</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$hex</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 十六进制也可以进行转换。</span></span><br></pre></td></tr></table></figure><hr><h3 id="数值判断"><a href="#数值判断" class="headerlink" title="(())数值判断"></a>(())数值判断</h3><p>使用<strong>小于</strong>和<strong>大于</strong>符号，以及<code>==</code>用来测试是否相等，专为整数设计</p><p>不仔细讲解，因为这些也可以使用上面提到的<code>[ ]</code>和<code>[[ ]]</code>进行较好的替代，后续想学习可以参考：<a href="https://www.kancloud.cn/thinkphp/linux-command-line/39459" target="_blank" rel="noopener">文章一</a>、<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part2/07_1_test_constructs.html" target="_blank" rel="noopener">文章二</a>。</p><hr><p><br></p><h2 id="if条件测试分支结构"><a href="#if条件测试分支结构" class="headerlink" title="if条件测试分支结构"></a>if条件测试分支结构</h2><p>在学习<code>test</code>命令以及<code>[ ]</code>判断式过程中我们发现条件测试默认是不会返回任何信息的，如果想要进行操作或者返回信息就要使用<code>&amp;&amp;</code>或者<code>||</code>，这些其实和这里的if条件测试分支结构的作用的相同的，只是if条件测试分支结构可以支持的命令更加多和复杂，有利于大程序的编写。</p><p><strong>if条件测试分支结构工作原理</strong>：通过<strong>判断条件测试的退出状态</strong>，如果<strong>执行成功(命令退出状态为0)</strong>则执行<code>then</code>中的命令，<strong>否则(命令退出状态为非0)</strong>终止判断语句或者执行<code>else</code>或者执行下一层判断等。</p><h3 id="单层、简单条件判断式"><a href="#单层、简单条件判断式" class="headerlink" title="单层、简单条件判断式"></a>单层、简单条件判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  这里的条件判断式就是前面条件测试中使用的[]判断式</span><br></pre></td></tr></table></figure><hr><h3 id="多个表达式、多重判别"><a href="#多个表达式、多重判别" class="headerlink" title="多个表达式、多重判别"></a>多个表达式、多重判别</h3><p>前面在test命令中讲过关于使用多个表达式、多重判断的情况，在多个表达式之间<strong>使用-a表示and、-o表示or</strong>，示例如下：</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; -o &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p>如果想要使用<strong>多个括号将不同的表达式隔开</strong>可以使用<code>&amp;&amp;</code>和<code>||</code>:</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; ] || [ &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p><mark>上面的多重判别实际是写成了一个判断式的形式，而如果 if 之后跟随一系列命令(使用<code>;</code>隔开)，则将计算列表中的<strong>最后一个命令</strong>：</mark></p><blockquote><p><code>if false; true; then echo &quot;It&#39;s true.&quot;; fi</code> 因为true在后，所以得到退出状态为0，输出结果<br>It’s true.</p></blockquote><blockquote><p><code>if true; false; then echo &quot;It&#39;s true.&quot;; fi</code> 因为false在后，所以得到退出状态为非0，不输出结果</p></blockquote><hr><h3 id="双层判断式"><a href="#双层判断式" class="headerlink" title="双层判断式"></a>双层判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 一个条件判断，分成功进行与失败进行 （else）</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><hr><h3 id="多层、复杂判断式"><a href="#多层、复杂判断式" class="headerlink" title="多层、复杂判断式"></a>多层、复杂判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 多个条件判断 （if ... elif ... elif ... else） 分多种不同情况执行</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式一 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式一成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">elif</span> [ 条件判断式二 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式二成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式一与二均不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>if</code>、<code>elif</code>后面需要使用<code>then</code>，而<code>else</code>后面就不用使用<code>then</code>，因为<code>elif</code> 也是个判断式，因此出现 <code>elif</code> 后面都要接 <code>then</code> 来处理！但是 <code>else</code> 已经是最后的没有成立的结果了， 所以 <code>else</code> 后面并没有 <code>then</code></p></div><hr><h3 id="exit程序退出状态"><a href="#exit程序退出状态" class="headerlink" title="exit程序退出状态"></a>exit程序退出状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &lt;name&gt;"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>在运行此脚本时，如果没有输入参数，则提示正确的使用方法，<strong>非正常退出(exit 1)</strong>；否则，打印输入的参数，<strong>程序正常退出(exit 0)</strong>。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文主要学习了shell中的条件测试命令，包括&lt;code&gt;test&lt;/code&gt;命令、&lt;code&gt;[ ]&lt;/code&gt;、&lt;code&gt;[[ ]]&lt;/code&gt;、&lt;code&gt;(( ))&lt;/code&gt;，主要介绍了前三个，其中&lt;code&gt;[ ]&lt;/code&gt;和&lt;code&gt;[[ ]]&lt;/code&gt;可以用在&lt;strong&gt;if条件测试分支结构&lt;/strong&gt;中，两者之间的优缺点在文中也有讲解；也学习了&lt;strong&gt;if条件测试分支结构&lt;/strong&gt;在多种情形下的多种形式以及&lt;code&gt;exit&lt;/code&gt;命令设定程序退出状态&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="shell编程" scheme="http://showteeth.tech/categories/Linux/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pv-命令执行的进度信息</title>
    <link href="http://showteeth.tech/posts/6225.html"/>
    <id>http://showteeth.tech/posts/6225.html</id>
    <published>2019-03-13T15:27:07.000Z</published>
    <updated>2019-03-17T02:20:17.421Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这个需要安装pv，需要root权限，后面在有root权限的机器上执行这个操作</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/pv" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.poftut.com/linux-pv-command-tutorial-examples-monitor-progress-copybackupcompress/" target="_blank" rel="noopener">很好的英文示例讲解博客</a></li><li><a href="https://www.tecmint.com/monitor-copy-backup-tar-progress-in-linux-using-pv-command/" target="_blank" rel="noopener">英文示例博客</a></li><li><a href="https://wangchujiang.com/linux-command/c/pv.html" target="_blank" rel="noopener">中文讲解博客</a></li><li><a href="https://ywnz.com/linux/pv/" target="_blank" rel="noopener">中文讲解博客</a></li><li><a href="https://linux.cn/article-6734-1.html?pr" target="_blank" rel="noopener">中文讲解博客</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这个需要安装pv，需要root权限，后面在有root权限的机器上执行这个操作&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>HTML块级标签和行内标签</title>
    <link href="http://showteeth.tech/posts/8829.html"/>
    <id>http://showteeth.tech/posts/8829.html</id>
    <published>2019-03-13T14:16:09.000Z</published>
    <updated>2019-03-15T10:24:43.436Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇<a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">转载</a>的文章，主要记录了HTML的块级标签和行内标签各自包括的内容</p></div><a id="more"></a><h2 id="块级标签"><a href="#块级标签" class="headerlink" title="块级标签"></a>块级标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;address&gt;</td><td style="text-align:left">定义地址</td></tr><tr class="even"><td style="text-align:left">&lt;article&gt;</td><td style="text-align:left">定义文章</td></tr><tr class="odd"><td style="text-align:left">&lt;aside&gt;</td><td style="text-align:left">定义页面内容之外的内容</td></tr><tr class="even"><td style="text-align:left">&lt;audio&gt;</td><td style="text-align:left">定义声音内容</td></tr><tr class="odd"><td style="text-align:left">&lt;blockquote&gt;</td><td style="text-align:left">定义长的引用</td></tr><tr class="even"><td style="text-align:left">&lt;canvas&gt;</td><td style="text-align:left">定义图形</td></tr><tr class="odd"><td style="text-align:left">&lt;caption&gt;</td><td style="text-align:left">定义表格标题</td></tr><tr class="even"><td style="text-align:left">&lt;dd&gt;</td><td style="text-align:left">定义定义列表中项目的描述</td></tr><tr class="odd"><td style="text-align:left">&lt;div&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;dl&gt;</td><td style="text-align:left">定义定义列表</td></tr><tr class="odd"><td style="text-align:left">&lt;dt&gt;</td><td style="text-align:left">定义定义列表中的项目</td></tr><tr class="even"><td style="text-align:left">&lt;details&gt;</td><td style="text-align:left">定义元素的细节</td></tr><tr class="odd"><td style="text-align:left">&lt;fieldset&gt;</td><td style="text-align:left">定义围绕表单中元素的边框</td></tr><tr class="even"><td style="text-align:left">&lt;figcaption&gt;</td><td style="text-align:left">定义 figure 元素的标题</td></tr><tr class="odd"><td style="text-align:left">&lt;figure&gt;</td><td style="text-align:left">定义媒介内容的分组，以及它们的标题</td></tr><tr class="even"><td style="text-align:left">&lt;footer&gt;</td><td style="text-align:left">定义 section 或 page 的页脚</td></tr><tr class="odd"><td style="text-align:left">&lt;form&gt;</td><td style="text-align:left">定义供用户输入的 HTML 表单</td></tr><tr class="even"><td style="text-align:left">&lt;h1&gt; to &lt;h6&gt;</td><td style="text-align:left">定义 HTML 标题</td></tr><tr class="odd"><td style="text-align:left">&lt;header&gt;</td><td style="text-align:left">定义 section 或 page 的页眉</td></tr><tr class="even"><td style="text-align:left">&lt;hr&gt;</td><td style="text-align:left">定义水平线</td></tr><tr class="odd"><td style="text-align:left">&lt;legend&gt;</td><td style="text-align:left">定义 fieldset 元素的标题</td></tr><tr class="even"><td style="text-align:left">&lt;li&gt;</td><td style="text-align:left">定义列表的项目</td></tr><tr class="odd"><td style="text-align:left">&lt;menu&gt;</td><td style="text-align:left">定义命令的列表或菜单</td></tr><tr class="even"><td style="text-align:left">&lt;meter&gt;</td><td style="text-align:left">定义预定义范围内的度量</td></tr><tr class="odd"><td style="text-align:left">&lt;nav&gt;</td><td style="text-align:left">定义导航链接</td></tr><tr class="even"><td style="text-align:left">&lt;noframes&gt;</td><td style="text-align:left">定义针对不支持框架的用户的替代内容</td></tr><tr class="odd"><td style="text-align:left">&lt;noscript&gt;</td><td style="text-align:left">定义针对不支持客户端脚本的用户的替代内容</td></tr><tr class="even"><td style="text-align:left">&lt;ol&gt;</td><td style="text-align:left">定义有序列表</td></tr><tr class="odd"><td style="text-align:left">&lt;output&gt;</td><td style="text-align:left">定义输出的一些类型</td></tr><tr class="even"><td style="text-align:left">&lt;p&gt;</td><td style="text-align:left">定义段落</td></tr><tr class="odd"><td style="text-align:left">&lt;pre&gt;</td><td style="text-align:left">定义预格式文本</td></tr><tr class="even"><td style="text-align:left">&lt;section&gt;</td><td style="text-align:left">定义 section</td></tr><tr class="odd"><td style="text-align:left">&lt;table&gt;</td><td style="text-align:left">定义表格</td></tr><tr class="even"><td style="text-align:left">&lt;tbody&gt;</td><td style="text-align:left">定义表格中的主体内容</td></tr><tr class="odd"><td style="text-align:left">&lt;td&gt;</td><td style="text-align:left">定义表格中的单元</td></tr><tr class="even"><td style="text-align:left">&lt;tfoot&gt;</td><td style="text-align:left">定义表格中的表注内容（脚注）</td></tr><tr class="odd"><td style="text-align:left">&lt;th&gt;</td><td style="text-align:left">定义表格中的表头单元格</td></tr><tr class="even"><td style="text-align:left">&lt;thead&gt;</td><td style="text-align:left">定义表格中的表头内容</td></tr><tr class="odd"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="even"><td style="text-align:left">&lt;tr&gt;</td><td style="text-align:left">定义表格中的行</td></tr><tr class="odd"><td style="text-align:left">&lt;ul&gt;</td><td style="text-align:left">定义无序列表</td></tr></tbody></table><hr><p><br></p><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;a&gt;</td><td style="text-align:left">定义锚</td></tr><tr class="even"><td style="text-align:left">&lt;abbr&gt;</td><td style="text-align:left">定义缩写</td></tr><tr class="odd"><td style="text-align:left">&lt;acronym&gt;</td><td style="text-align:left">定义只取首字母的缩写</td></tr><tr class="even"><td style="text-align:left">&lt;b&gt;</td><td style="text-align:left">定义粗体字</td></tr><tr class="odd"><td style="text-align:left">&lt;bdo&gt;</td><td style="text-align:left">定义文字方向</td></tr><tr class="even"><td style="text-align:left">&lt;big&gt;</td><td style="text-align:left">定义大号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;br&gt;</td><td style="text-align:left">定义简单的折行</td></tr><tr class="even"><td style="text-align:left">&lt;button&gt;</td><td style="text-align:left">定义按钮 (push button)</td></tr><tr class="odd"><td style="text-align:left">&lt;cite&gt;</td><td style="text-align:left">定义引用(citation)</td></tr><tr class="even"><td style="text-align:left">&lt;code&gt;</td><td style="text-align:left">定义计算机代码文本</td></tr><tr class="odd"><td style="text-align:left">&lt;command&gt;</td><td style="text-align:left">定义命令按钮</td></tr><tr class="even"><td style="text-align:left">&lt;dfn&gt;</td><td style="text-align:left">定义定义项目</td></tr><tr class="odd"><td style="text-align:left">&lt;del&gt;</td><td style="text-align:left">定义被删除文本</td></tr><tr class="even"><td style="text-align:left">&lt;em&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;embed&gt;</td><td style="text-align:left">定义外部交互内容或插件</td></tr><tr class="even"><td style="text-align:left">&lt;i&gt;</td><td style="text-align:left">定义斜体字</td></tr><tr class="odd"><td style="text-align:left">&lt;img&gt;</td><td style="text-align:left">定义图像</td></tr><tr class="even"><td style="text-align:left">&lt;input&gt;</td><td style="text-align:left">定义输入控件</td></tr><tr class="odd"><td style="text-align:left">&lt;kbd&gt;</td><td style="text-align:left">定义键盘文本</td></tr><tr class="even"><td style="text-align:left">&lt;label&gt;</td><td style="text-align:left">定义 input 元素的标注</td></tr><tr class="odd"><td style="text-align:left">&lt;map&gt;</td><td style="text-align:left">定义图像映射</td></tr><tr class="even"><td style="text-align:left">&lt;mark&gt;</td><td style="text-align:left">定义有记号的文本</td></tr><tr class="odd"><td style="text-align:left">&lt;objec&gt;</td><td style="text-align:left">定义内嵌对象</td></tr><tr class="even"><td style="text-align:left">&lt;progress&gt;</td><td style="text-align:left">定义任何类型的任务的进度</td></tr><tr class="odd"><td style="text-align:left">&lt;q&gt;</td><td style="text-align:left">定义短的引用</td></tr><tr class="even"><td style="text-align:left">&lt;samp&gt;</td><td style="text-align:left">定义计算机代码样本</td></tr><tr class="odd"><td style="text-align:left">&lt;select&gt;</td><td style="text-align:left">定义选择列表（下拉列表）</td></tr><tr class="even"><td style="text-align:left">&lt;small&gt;</td><td style="text-align:left">定义小号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;span&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;strong&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;sub&gt;</td><td style="text-align:left">定义下标文本</td></tr><tr class="even"><td style="text-align:left">&lt;sup&gt;</td><td style="text-align:left">定义上标文本</td></tr><tr class="odd"><td style="text-align:left">&lt;textarea&gt;</td><td style="text-align:left">定义多行的文本输入控件</td></tr><tr class="even"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="odd"><td style="text-align:left">&lt;tt&gt;</td><td style="text-align:left">定义打字机文本</td></tr><tr class="even"><td style="text-align:left">&lt;var&gt;</td><td style="text-align:left">定义文本的变量部分</td></tr><tr class="odd"><td style="text-align:left">&lt;video&gt;</td><td style="text-align:left">定义视频</td></tr><tr class="even"><td style="text-align:left">&lt;wbr&gt;</td><td style="text-align:left">定义可能的换行符</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/d69878549d92" target="_blank" rel="noopener">关于两者之间的转换</a></li><li><a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">HTML中块级元素和行内元素的总结和区分，本文内容摘自此文章</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇&lt;a href=&quot;https://www.cnblogs.com/yanqiu/p/8987126.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载&lt;/a&gt;的文章，主要记录了HTML的块级标签和行内标签各自包括的内容&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="http://showteeth.tech/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://showteeth.tech/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>转载其他博主博客</title>
    <link href="http://showteeth.tech/posts/52283.html"/>
    <id>http://showteeth.tech/posts/52283.html</id>
    <published>2019-03-13T12:40:50.000Z</published>
    <updated>2019-03-13T15:03:24.867Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载<strong>CSDN博客</strong>、<strong>博客园博客</strong>、<strong>简书</strong>以及<strong>其他自建博客</strong>等</p></div><a id="more"></a><h2 id="转载CSDN博客"><a href="#转载CSDN博客" class="headerlink" title="转载CSDN博客"></a>转载CSDN博客</h2><div id="article_content" class="article_content csdn-tracking-statistics tracking-click"><div class="markdown_views"><h3 id="检查"><a name="t2"></a><a target="_blank"></a>博客页面右键，点击【检查】</h3><img src="https://img-blog.csdn.net/20180205164141852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> 点击检查后，页面右侧出现<strong>html</strong>代码，如下图： <img src="https://img-blog.csdn.net/20180205164538679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="找内容"><a name="t3"></a><a target="_blank"></a>找到article_content内容</h3><img src="https://img-blog.csdn.net/20180205164709557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="复制"><a name="t4"></a><a target="_blank"></a>复制article_content内容</h3>在选中html的article_content代码处右键，点击<strong>【Copy】</strong>,再点击<strong>【Copy outerHTML】</strong>即可，至此，博客内容的html代码复制完成 <img src="https://img-blog.csdn.net/20180205164702137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="新建"><a name="t5"></a><a target="_blank"></a>新建markdown博客</h3><ul><li>如果是<strong>转载到CSDN博客</strong>需要注意：<strong>使用markdown编辑器</strong>，CSDN博客默认的是<a href="https://www.baidu.com/s?wd=html%E7%BC%96%E8%BE%91%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank"><strong>html编辑器</strong></a>，在博客设置中<strong>修改成markdown编辑器</strong>，在html编辑器中是无法将html代码转换成相应博客内容</li><li>如果是<strong>转载到自己搭建的博客</strong>，比如我的这个博客，需要注意：按照上述方法会得到<mark>很多的空格</mark>，这是因为直接使用html来编写markdown，只要存在换行(如标签换行)都会在最终生成的页面中得到一个空格，为了解决这个问题可以在整个<code>article_content</code>标签外加上<code>escape</code>标签即可，这个和<a href="http://showteeth.tech/posts/65136.html" target="_blank"><strong>插入html表格</strong></a>的处理是一样的</li><li>HTML <mark>区块标签间的 Markdown 格式语法将不会被处理</mark>，但 Markdown 语法在 HTML <mark>行内标签间是有效的</mark>，具体的行内标签和区块标签包含的内容见<mark><a href="http://showteeth.tech/posts/8829.html" target="_blank">这篇博客</a></mark></li><li>在手动更改html内容时需要注意：每个标题的<code>id</code>是<mark>不可以相同</mark>的，不然<strong>生成的目录会出问题</strong>，点击不能到达相应的标题(目录是根据<code>id</code>生成的)</li><li>最后特别要注意的是，我们发表转载文章的时候一定要标注<strong>转载</strong>，尊重原创！！</li></ul></div></div><hr><h2 id="转载博客园博客"><a href="#转载博客园博客" class="headerlink" title="转载博客园博客"></a>转载博客园博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>data-note-content</code>即可</p><hr><h2 id="转载简书博客"><a href="#转载简书博客" class="headerlink" title="转载简书博客"></a>转载简书博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>cnblogs_post_body</code>即可</p><hr><h2 id="转载其他自建博客"><a href="#转载其他自建博客" class="headerlink" title="转载其他自建博客"></a>转载其他自建博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>post-body</code>即可</p><p>其他博客依据上述规律<strong>找到对应的文章主体内容</strong>，然后按照转载CSDN博客的方法进行处理即可</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/zhongjianblackberry/article/details/79456338" target="_blank" rel="noopener">CSDN怎么转载别人的博客</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载&lt;strong&gt;CSDN博客&lt;/strong&gt;、&lt;strong&gt;博客园博客&lt;/strong&gt;、&lt;strong&gt;简书&lt;/strong&gt;以及&lt;strong&gt;其他自建博客&lt;/strong&gt;等&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>diff-比较文件差异</title>
    <link href="http://showteeth.tech/posts/56778.html"/>
    <id>http://showteeth.tech/posts/56778.html</id>
    <published>2019-03-06T12:14:22.000Z</published>
    <updated>2019-03-17T02:18:12.632Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用<code>diff</code>命令对<strong>文件和目录</strong>进行比较，对文件比较时采用的是<strong>逐行进行比较</strong>；包括的参数有<code>-r</code>、<code>-q</code>、<code>-i</code>、<code>-s</code>、<code>-b</code>、<code>-y</code>、<code>-W</code>、<code>-c</code>、<code>-C</code>、<code>-u</code>和<code>-U</code>。</p></div><a id="more"></a><h2 id="diff简介"><a href="#diff简介" class="headerlink" title="diff简介"></a>diff简介</h2><p><code>diff</code>命令能<strong>比较(单个)文件或者目录</strong>内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，并<strong>以逐行的方式</strong>，比较文本文件的异同；如果指定<strong>比较的是目录</strong>，diff 命令会比较两个目录下名字相同但内容不同的文本文件，列出公共子目录和只在一个目录出现的文件和目录。</p><p><mark>这个和前面讲到的<code>comm</code>命令和<code>cmp</code>命令的不同之处在于</mark>：<code>diff</code>和<code>comm</code>命令都是以逐行的方式进行比较，而<code>cmp</code>是<strong>Compare two files byte by byte</strong>；同时<code>diff</code>命令可以比较<strong>单个文件</strong>，而<code>comm</code>和<code>cmp</code>都是针对的两个文件的比较，其中<code>comm</code>还需要文件是排过序的；<code>diff</code>命令还能用来对目录进行排序；感觉<code>diff</code>在比较两个文件或目录时是将两个文件当成了同一个文件修改前后的不同版本，通过<code>diff</code>可以知道新文件是在旧文件上进行了哪些操作得到的，得到的结果也更复杂。</p><p>总结一下三个命令的适用情形：<br></p><div class="note info"><ul><li>comm适合简单的比较，需要<strong>排序</strong>，<strong>逐行</strong>比较，用于比较的文件不是同一个文件的不同版本(新旧文件)，得到的结果<strong>简单清晰</strong>(文件求交、并、补等)，便于提取分析</li><li>cmp可以应用于对两个文件<strong>逐字节</strong>的比较，可以<strong>跳过一定的字节</strong>(个人感觉这个实用性不是很强，不同系统编码方式字节也有所不同)</li><li>diff适合<strong>逐行</strong>比较<strong>文件修改前后</strong>的区别(类似版本控制，新文件是旧文件经过什么操作得到的)，也可以<strong>对目录进行比较</strong>，但是输出<strong>结果较为复杂</strong>，还可以输出<strong>上下文</strong>关系的信息</li></ul></div><p></p><hr><h2 id="diff命令用法"><a href="#diff命令用法" class="headerlink" title="diff命令用法"></a>diff命令用法</h2><h3 id="diff命令格式"><a href="#diff命令格式" class="headerlink" title="diff命令格式"></a>diff命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  diff [OPTION]... FILES</span><br></pre></td></tr></table></figure><p><strong>Compare files line by line</strong></p><hr><h3 id="diff-options说明"><a href="#diff-options说明" class="headerlink" title="diff options说明"></a>diff options说明</h3><p>由于diff命令的参数较多，这里就不一一列举，详细请查看帮助文档，比较常用的请看用法实例。</p><hr><p><br></p><h2 id="diff用法实例"><a href="#diff用法实例" class="headerlink" title="diff用法实例"></a>diff用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Hi,<br>Hello,<br>How are you?<br>I am fine,<br>Thank you.</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Hello,<br>Hi,<br>How are you?<br>I am fine.</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><h4 id="比较两个文件"><a href="#比较两个文件" class="headerlink" title="比较两个文件"></a>比较两个文件</h4><blockquote><p><code>diff test1.txt test2.txt</code><br>1d0<br>&lt; Hi,<br>2a2<br>> Hi,<br>4,5c4<br>&lt; I am fine,<br>&lt; Thank you.<br>-–<br>> I am fine.</p></blockquote><p><strong>结果解读：</strong></p><ul><li>可以将test1.txt当做旧文件，test2.txt当做新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li><code>1d0</code>这一行意味着旧文件的第一行应该被<strong>删除(d)</strong>以使两个文件的第一行同步，<strong>旧文件中需要被删除的行</strong>以<code>&lt;</code>标记</li><li><code>2a2</code>行意味着<strong>新文件中的第二行应该加到旧文件的第二行后</strong>，要<strong>添加的行显示在输出的下一行</strong>用<code>&gt;</code>标记</li><li><code>4,5c4</code>这一行意味着在<strong>旧文件中的4到5行现在已被改变并且需要用新文件中的第4行代替</strong>，代替和删除的行分别用<code>&gt;</code>和<code>&lt;</code>表示，<code>---</code>用于隔开先后进行的不同操作，如先删除旧文件中的4到5行，然后再用新文件中的第4行代替，这两步之间使用<code>---</code>分割</li></ul><div class="note info"><ul><li><code>diff</code>命令的第一个参数被视为旧文件而第二个参数被视为新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li>像<code>1d0</code>、<code>2a2</code>、<code>4,5c4</code>这种表达式可以用语法解码为 <strong>[旧文件的行号或者行的范围][行为][新文件的行号或者行的范围]</strong>，这里的<strong>行为</strong>可以是追加(<code>a，代表addition</code>)、删除(<code>d，代表deletion</code>)或者改变替换(<code>c，代表change</code>)</li><li><code>&lt;</code>代表删除的行，而<code>&gt;</code>代表添加的行，<code>---</code>用于改变替换(<code>c，代表change</code>)中分割先后的操作</li></ul></div><hr><h4 id="比较两个目录"><a href="#比较两个目录" class="headerlink" title="比较两个目录"></a>比较两个目录</h4><blockquote><p><code>ls new_dir/</code><br>comm_dir new_new_dir test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls new_dir/new_new_dir/</code> and <code>ls new_dir/comm_dir/</code><br>test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls orig_dir/</code><br>comm_dir orig_orig_dir test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>ls orig_dir/orig_orig_dir/</code> and <code>ls orig_dir/comm_dir/</code><br>test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>diff orig_dir/ new_dir/</code><br>Common subdirectories: new_dir/comm_dir and orig_dir/comm_dir # 两个目录共有的子目录，不会比较子目录中的文件信息<br>Only in new_dir/: new_new_dir # 只出现在new_dir中的目录，不会比较子目录中的文件信息<br>Only in orig_dir/: orig_orig_dir # 只出现在orig_dir中的目录，不会比较子目录中的文件信息<br>diff orig_dir/test1.txt new_dir/test1.txt # new_dir和orig_dir共有的同名文件内容的差异<br>0a1 # 具体的差异信息<br>> asdfaf # 具体的差异信息<br>Only in new_dir/: test3.txt # 只出现在new_dir中的文件<br>Only in orig_dir/: test4.txt # 只出现在orig_dir中的文件</p></blockquote><p><strong>比较两个目录可以找到每个目录共有的、独有的文件和目录信息；对于共有的子目录，不会继续比较子目录中的信息；对于共有的文件，会得出文件的差异信息</strong></p><hr><h3 id="r-比较子目录中的文件"><a href="#r-比较子目录中的文件" class="headerlink" title="-r-比较子目录中的文件"></a>-r-比较子目录中的文件</h3><p>上述对目录进行比较时默认不会比较子目录中的文件信息，使用-r参数可以对这些文件进行比较：</p><blockquote><p><code>diff -r orig_dir/ new_dir/</code><br>diff -r orig_dir/comm_dir/test1.txt new_dir/comm_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/comm_dir: test3.txt<br>Only in orig_dir/comm_dir: test4.txt<br>Only in new_dir/: new_new_dir<br>Only in orig_dir/: orig_orig_dir<br>diff -r orig_dir/test1.txt new_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/: test3.txt<br>Only in orig_dir/: test4.txt</p></blockquote><hr><h3 id="q-只显示有无差异"><a href="#q-只显示有无差异" class="headerlink" title="-q-只显示有无差异"></a>-q-只显示有无差异</h3><p>默认情况下如果文件存在差异会显示差异信息，使用<code>-q</code>参数只会显示有无差异不会显示具体的差异信息:</p><blockquote><p><code>diff -q test1.txt test2.txt</code><br>Files test1.txt and test2.txt differ</p></blockquote><hr><h3 id="i-忽略文件中文本大小写"><a href="#i-忽略文件中文本大小写" class="headerlink" title="-i-忽略文件中文本大小写"></a>-i-忽略文件中文本大小写</h3><blockquote><p><code>diff file1.txt file2.txt</code><br>1c1<br>&lt; hi<br>-–<br>> HI</p></blockquote><p>默认情况下是会区分文件中文本信息大小写的</p><blockquote><p><code>diff -i file1.txt file2.txt</code></p></blockquote><p>使用了<code>-i</code>参数没有输出内容，因为忽略大小写之后文件中文本信息是相同的</p><hr><h3 id="s-在文件内容相同条件下报告信息"><a href="#s-在文件内容相同条件下报告信息" class="headerlink" title="-s-在文件内容相同条件下报告信息"></a>-s-在文件内容相同条件下报告信息</h3><p>上面使用了<code>-i</code>参数得到了文件内容是相同的，这时默认就不会输出信息，如果想要在文件内容相同时报告文件内容是相同的，需要使用<code>-s</code>参数</p><blockquote><p><code>diff -is file1.txt file2.txt</code><br>Files file1.txt and file2.txt are identical</p></blockquote><hr><h3 id="b-忽略文本中的空格"><a href="#b-忽略文本中的空格" class="headerlink" title="-b-忽略文本中的空格"></a>-b-忽略文本中的空格</h3><blockquote><p><code>cat file1</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>cat file2</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>diff file1 file2</code><br>1c1<br>&lt; Hi, how are you?<br>-–<br>> Hi, how are you?</p></blockquote><p>上述文件中的区别仅仅是file2多了一个空格，但是使用<code>diff</code>命令后仍然会输出不同，而常规情形下，这应该被认为是相同的，这时就可以使用<code>-b</code>参数</p><blockquote><p><code>diff -bs file1 file2</code><br>Files file1 and file2 are identical</p></blockquote><hr><h3 id="y-以并列的方式显示文件的异同之处"><a href="#y-以并列的方式显示文件的异同之处" class="headerlink" title="-y-以并列的方式显示文件的异同之处"></a>-y-以并列的方式显示文件的异同之处</h3><blockquote><p><code>diff -y test1.txt test2.txt</code><br>Hi, &lt;<br>Hello, Hello,<br>&gt; Hi,<br>How are you? How are you?<br>I am fine, | I am fine.<br>Thank you. &lt;</p></blockquote><ul><li><code>|</code>：表示前后2个文件内容存在差异</li><li><code>&gt;</code>：表示第一个文件删除的行</li><li><code>&lt;</code>：表示第二个文件增加的行</li></ul><hr><h3 id="W-在使用-y参数时，指定栏宽"><a href="#W-在使用-y参数时，指定栏宽" class="headerlink" title="-W-在使用-y参数时，指定栏宽"></a>-W-在使用-y参数时，指定栏宽</h3><p>如果指定的栏宽太窄，会显示每行的部分信息：</p><blockquote><p><code>diff -y -W 10 test1.txt test2.txt</code><br>Hi &lt;<br>He He<br>> Hi<br>Ho Ho<br>I | I<br>Th &lt;</p></blockquote><hr><h3 id="c-上下文格式输出"><a href="#c-上下文格式输出" class="headerlink" title="-c-上下文格式输出"></a>-c-上下文格式输出</h3><p>显示不同行的信息时一同显示上下文信息，默认是存在不同的上下3行：</p><blockquote><p><code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><ul><li><code>***</code>表示变动前的文件，<code>---</code>表示变动后的文件</li><li><code>*** 1,5 ****</code>表示变动前文件的1到5行，<code>--- 1,4 ----</code>表示变动后文件的1到4行</li><li>文件内容的每一行最前面，还有一个标记位<ul><li>如果为<code>空</code>，表示该行无变化</li><li>如果是感叹号（<code>!</code>），表示该行有改动</li><li>如果是减号（<code>-</code>），表示该行被删除</li><li>如果是加号（<code>+</code>），表示该行为新增</li></ul></li></ul><hr><h3 id="C-NUM-指定具体是上下文行数"><a href="#C-NUM-指定具体是上下文行数" class="headerlink" title="-C NUM-指定具体是上下文行数"></a>-C NUM-指定具体是上下文行数</h3><p>这个功能和上面的<code>-c</code>是相同的，只是<code>-c</code>只能是默认的上下3行，而<code>-C num</code>可以指定具体的上下文行数</p><blockquote><p><code>diff -C 3 test1.txt test2.txt</code> 等同于 <code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><hr><h3 id="u-合并格式输出"><a href="#u-合并格式输出" class="headerlink" title="-u-合并格式输出"></a>-u-合并格式输出</h3><p>如果两个文件<strong>相似度很高</strong>，那么<strong>上下文格式的<code>diff</code>，将显示大量重复的内容</strong>，很浪费空间，这个时候使用合并格式输出<strong>将f1和f2的上下文(默认3行)合并在一起显示</strong>：</p><blockquote><p><code>diff -u test1.txt test2.txt</code><br>— test1.txt 2019-03-14 15:26:48.960323475 +0800<br>+++ test2.txt 2019-03-14 15:27:07.411322620 +0800<br>@@ -1,5 +1,4 @@<br>-Hi,<br>Hello,<br>+Hi,<br>How are you?<br>-I am fine,<br>-Thank you.<br>+I am fine.</p></blockquote><ul><li><code>---</code>表示变动前的文件，<code>+++</code>表示变动后的文件</li><li>变动的位置用两个<code>@</code>作为起首和结束，<code>-1,5</code>表示第一个文件的1到5行，<code>+1,4</code>表示第二个文件的1到4行</li><li>每一行最前面的标志位，<strong>空表示无变动</strong>，<strong>减号表示第一个文件删除的行</strong>，<strong>加号表示第二个文件新增的行</strong></li></ul><hr><h3 id="U-NUM-指定合并格式上下文的行数"><a href="#U-NUM-指定合并格式上下文的行数" class="headerlink" title="-U NUM-指定合并格式上下文的行数"></a>-U NUM-指定合并格式上下文的行数</h3><p>这个功能和上面的<code>-u</code>是相同的，只是<code>-u</code>只能是默认的上下3行，而<code>-U num</code>可以指定具体的上下文行数</p><hr><h3 id="结合patch进行内容更新"><a href="#结合patch进行内容更新" class="headerlink" title="结合patch进行内容更新"></a>结合patch进行内容更新</h3><p>这个暂时应该用不到，所以就不学习了，后期如果使用的话再进行学习补充，后面列出的参考链接有对应的示例。</p><hr><p><br></p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><div class="note info"><ul><li>diff的<strong>几种输出模式</strong>：<strong>并列输出(-y)</strong>、<strong>上下文格式输出(-c)</strong>、<strong>合并格式输出(-u)</strong>之间的不兼容的，只能使用其中一种，参数不能混用</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/12/2814048.html" target="_blank" rel="noopener">实例较多</a></li><li><a href="https://linux.cn/article-2298-1.html" target="_blank" rel="noopener">举例说明Linux diff 命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-diff.html" target="_blank" rel="noopener">参数讲解</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">清晰的讲解</a></li><li><a href="http://wiki.jikexueyuan.com/project/shell-learning/file-comparing-cmp-diff-patch.html" target="_blank" rel="noopener">文件比较 cmp，diff，patch</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了使用&lt;code&gt;diff&lt;/code&gt;命令对&lt;strong&gt;文件和目录&lt;/strong&gt;进行比较，对文件比较时采用的是&lt;strong&gt;逐行进行比较&lt;/strong&gt;；包括的参数有&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-q&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-y&lt;/code&gt;、&lt;code&gt;-W&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-C&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;和&lt;code&gt;-U&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>cmp-比较文件差异</title>
    <link href="http://showteeth.tech/posts/62860.html"/>
    <id>http://showteeth.tech/posts/62860.html</id>
    <published>2019-03-06T11:57:37.000Z</published>
    <updated>2019-03-17T02:17:48.524Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<code>cmp</code>对<strong>两个文件</strong>进行比较，比较时是<strong>逐字节</strong>进行的；包括的参数：<code>-b</code>、<code>-i</code>、<code>-i</code>、<code>-l</code>、<code>-n</code>、<code>-s</code>以及<strong>显示运行进度</strong>。</p></div><a id="more"></a><h2 id="cmp简介"><a href="#cmp简介" class="headerlink" title="cmp简介"></a>cmp简介</h2><p><code>cmp</code>命令用于比较两个文件是否有差异；当相互比较的两个文件<strong>完全一样</strong>时，则该命令不会有输出结果；若发现<strong>有所差异</strong>，<strong>默认会标示出第一个不同之处的字符和列数编号</strong></p><p>若不指定任何文件名称或是所给予的文件名为<code>-</code>，则<code>cmp</code>指令会从标准输入读取数据</p><p><mark>这个和前面讲到的<code>comm</code>命令的不同之处在于</mark>：comm命令对已排序的文件进行比较并将结果分为3列，便于提取文件比较的结果，如得到两个文件的差集、交集、并集和对称差集等，而<code>cmp</code>命令侧重于比较两个文件差异，大多用于比较同一个文件修改之后和修改之前的差异，并且<code>cmp</code>比较文件不需要进行排序；<code>cmp</code>命令比较文件是<strong>byte by byte</strong>，而comm命令比较文件是<strong>line by line</strong>。</p><hr><p><br></p><h2 id="cmp命令用法"><a href="#cmp命令用法" class="headerlink" title="cmp命令用法"></a>cmp命令用法</h2><h3 id="cmp命令格式"><a href="#cmp命令格式" class="headerlink" title="cmp命令格式"></a>cmp命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  cmp [OPTION] FILE1 [FILE2 [SKIP1 [SKIP2]]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The optional SKIP1 and SKIP2 specify the number of bytes to skip</span></span><br><span class="line"><span class="comment"># at the beginning of each file (zero by default).</span></span><br></pre></td></tr></table></figure><p><strong>Compare two files byte by byte</strong></p><hr><h3 id="cmp-options说明"><a href="#cmp-options说明" class="headerlink" title="cmp options说明"></a>cmp options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–print-bytes</td><td>除了标明差异处所在之外，一并显示该字符所对应字符和字节值</td></tr><tr><td>-i SKIP</td><td>–ignore-initial=SKIP</td><td>跳过一定的字节数(不包括SKIP)</td></tr><tr><td>-i SKIP1:SKIP2</td><td>–ignore-initial=SKIP1:SKIP2</td><td>从两个文件中跳过不同的字节数，SKIP1是FILE1跳过的字节数，SKIP为FILE2跳过的字节数</td></tr><tr><td>-l</td><td>–verbose</td><td>显示所有不同字节的字节位置（和值）</td></tr><tr><td>-n</td><td>–bytes=LIMIT</td><td>限制要比较的字节数(包括LIMIT)</td></tr><tr><td>-s</td><td>–quiet, –silent</td><td>抑制正常生成的输出，只返回文件是否相同的退出码(可以通过<code>$?</code>得到)</td></tr></tbody></table><hr><h3 id="cmp-i选项可选单位"><a href="#cmp-i选项可选单位" class="headerlink" title="cmp -i选项可选单位"></a>cmp -i选项可选单位</h3><table><thead><tr><th>简写</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>kB</td><td>kilobytes</td><td>1000</td></tr><tr><td>K</td><td>kibibytes</td><td>1024</td></tr><tr><td>MB</td><td>megabytes</td><td>1,000,000</td></tr><tr><td>M</td><td>mebibytes</td><td>1,048,576</td></tr><tr><td>GB</td><td>gigabytes</td><td>1,000,000,000</td></tr><tr><td>G</td><td>gibibytes</td><td>1,073,741,824</td></tr></tbody></table><hr><p><br></p><h2 id="cmp用法实例"><a href="#cmp用法实例" class="headerlink" title="cmp用法实例"></a>cmp用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Absncn 50<br>Asldssja 60<br>Jslkadjls 85</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Absncn 50<br>AsldssjE 62<br>Jslkadjls 85</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><p>默认会告诉在第几行的第几个字节出现不同：</p><blockquote><p><code>cmp test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2</p></blockquote><p><strong>注意这里的<code>byte 18</code>来源：系统默认编码方式为UTF-8(查看方式见<a href="http://showteeth.tech/posts/56690.html">这篇文章</a>)，1个英文字符 = 1个字节；换行符占一个字节；空格占一个字节；第二行的结果存在差异的话，字符会从第一行的第一个开始算起，叠加的，不是单独每一行算</strong></p><h3 id="b-显示不同的字节及字节值"><a href="#b-显示不同的字节及字节值" class="headerlink" title="-b-显示不同的字节及字节值"></a>-b-显示不同的字节及字节值</h3><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is <strong>141 a 105 E</strong></p></blockquote><p><strong>只会显示第一个，不会显示所有的</strong>，具体是字母a和E不同，字节值分别为141和105(这个没算。。。)</p><hr><h3 id="i-跳过指定的字节"><a href="#i-跳过指定的字节" class="headerlink" title="-i-跳过指定的字节"></a>-i-跳过指定的字节</h3><blockquote><p><code>cmp -b -i 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 3</strong>, line 1 is 60 0 62 2</p></blockquote><p>跳过<strong>前18个之后开始的第3个字节</strong>，0和2不同</p><div class="note info"><p>注意这个是<strong>不包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置</p></div><hr><h3 id="i-从两个文件跳过不同数量的字节"><a href="#i-从两个文件跳过不同数量的字节" class="headerlink" title="-i-从两个文件跳过不同数量的字节"></a>-i-从两个文件跳过不同数量的字节</h3><blockquote><p><code>cmp -b -i 18:18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 3, line 1 is 60 0 62 2</p></blockquote><p>18:18：第一个文件跳过的字节数为18，第二个文件跳过的字节数也是18</p><hr><h3 id="l-显示所有不同字节的字节位置（和值）"><a href="#l-显示所有不同字节的字节位置（和值）" class="headerlink" title="-l-显示所有不同字节的字节位置（和值）"></a>-l-显示所有不同字节的字节位置（和值）</h3><blockquote><p><code>cmp -l test1.txt test2.txt</code><br>18 141 105<br>21 60 62</p></blockquote><p>输出结果：</p><ul><li>第一列（如上所示）表示不同<strong>字节的位置</strong>（字节数）</li><li>第二列表示<strong>第一个文件</strong>中不同字节的字节值</li><li>第三列表示<strong>第二个文件</strong>中不同字节的字节值</li></ul><p>前面的<code>-b</code>等参数只会显示<strong>第一个</strong>不同的字节位置和值，这里会<strong>显示所有的</strong>字节数字和值</p><hr><h3 id="n-限制要比较的字节数"><a href="#n-限制要比较的字节数" class="headerlink" title="-n-限制要比较的字节数"></a>-n-限制要比较的字节数</h3><p>最多只比较的字符数：</p><blockquote><p><code>cmp -n 17 test1.txt test2.txt</code><br><code>cmp -n 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 18</strong>, line 2</p></blockquote><p>如果和<code>-i</code>参数联合使用：</p><blockquote><p><code>cmp -b -l -i 3 -n 18 test1.txt test2.txt</code><br>15 141 a 105 E<br>18 60 0 62 2</p></blockquote><p>注意这里相比于没有设置跳过字节会多出一行差异的结果，<strong>表明-n是相对字节位置，而不是绝对的字节位置</strong></p><p>和不使用<code>-i</code>的对比：</p><blockquote><p><code>cmp -b -l -n 18 test1.txt test2.txt</code><br>18 141 a 105 E</p></blockquote><div class="note info"><ul><li>注意这里是<strong>包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置，因为包括了所以才会输出在byte18位置存在区别</li><li><strong>-n指定的是相对字节位置，而不是绝对字节位置</strong>，比如上面跳过前3个字符之后出现差异的就成了第15个字节位置的，同时因为-n设置为18向后推移3个字节，就会出现了第二个不同的位置，而如果不设置-i参数就不会得到第二个不同的位置</li></ul></div><hr><h3 id="s-抑制正常生成的输出，只返回反映文件是否相同的退出码"><a href="#s-抑制正常生成的输出，只返回反映文件是否相同的退出码" class="headerlink" title="-s-抑制正常生成的输出，只返回反映文件是否相同的退出码"></a>-s-抑制正常生成的输出，只返回反映文件是否相同的退出码</h3><blockquote><p><code>cmp -s -b test1.txt test2.txt</code></p></blockquote><p>没有输出结果，也就是原本需要输出的在哪一行存在差异都不会输出来了，然后查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果是<code>1</code>，表明文件是不相同的，这样可<strong>得到文件是否相同的信息，但是并不关注具体的差异在什么地方</strong></p><p>而如果不加<code>-s</code>就会正常输出：</p><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is 141 a 105 E</p></blockquote><p>同时不加<code>-s</code>查看查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果和加了<code>-s</code>一样都返回的是<code>1</code></p><div class="note info"><p>在脚本中使用<code>cmp</code>命令时，此选项可以会派上用场。 例如，根据文件是否相同(通过访问命令的退出代码可以知道)来进行下一步的操作，这个时候我们可能并<strong>不关心具体文件的差异在什么地方，而是关心文件是不是有差异这个整体的结果</strong></p></div><h3 id="显示运行进度"><a href="#显示运行进度" class="headerlink" title="显示运行进度"></a>显示运行进度</h3><p>这个需要结合<a href="http://showteeth.tech/posts/6225.html">pv命令</a>，安装和使用<a href="http://showteeth.tech/posts/6225.html">pv命令</a>之后再进行学习，参考参考链接的前两个</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtoforge.com/linux-cmp-command/" target="_blank" rel="noopener">Linux cmp command tutorial for beginners （7 examples）</a></li><li><a href="https://www.howtoing.com/linux-cmp-command" target="_blank" rel="noopener">Linux初学者的cmp命令教程（7个例子）</a></li><li><a href="https://www.computerhope.com/unix/ucmp.htm" target="_blank" rel="noopener">Linux cmp command-关于-i参数单位的问题很好</a></li><li><a href="https://www.tutorialspoint.com/unix_commands/cmp.htm" target="_blank" rel="noopener">cmp - Unix, Linux Command</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了&lt;code&gt;cmp&lt;/code&gt;对&lt;strong&gt;两个文件&lt;/strong&gt;进行比较，比较时是&lt;strong&gt;逐字节&lt;/strong&gt;进行的；包括的参数：&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;以及&lt;strong&gt;显示运行进度&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>journey</title>
    <link href="http://showteeth.tech/posts/34270.html"/>
    <id>http://showteeth.tech/posts/34270.html</id>
    <published>2019-03-06T08:12:34.000Z</published>
    <updated>2019-03-13T12:14:03.220Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><h3 id="磁器口"><a href="#磁器口" class="headerlink" title="磁器口"></a>磁器口</h3><ul><li>吃的：陈麻花-推荐<strong>陈昌银</strong>或者<strong>夏麻花</strong>、<strong>张老汉手工酸辣粉</strong>（磁器口必吃之一）</li><li>有很多文艺的小咖啡馆或者书店</li><li>磁器口的主街人满为患，商业化严重，<strong>更建议去侧街</strong>，也是咖啡馆一条街，客量少，店面装饰都很有文艺味儿，<strong>是来磁器口的正确打开方式</strong>。（在此安利一家咖啡馆——<strong>懒鱼时光馆</strong>，上图即是该咖啡馆，是一家有故事的咖啡馆）</li></ul><h3 id="洪崖洞"><a href="#洪崖洞" class="headerlink" title="洪崖洞"></a>洪崖洞</h3><ul><li><strong>晚上去</strong>，白天不好看，晚上有灯光</li><li>主要是建筑构造和风貌</li></ul><h3 id="南山一棵树观景台"><a href="#南山一棵树观景台" class="headerlink" title="南山一棵树观景台"></a>南山一棵树观景台</h3><ul><li>可以将重庆所有的美景尽收眼底！建议<strong>夜晚去</strong>，重庆的夜景很美很美很美！<ul><li>门票：门票30，学生证15</li></ul></li><li>吃的：泉水鸡、枇杷园（火锅）</li></ul><h3 id="十八梯"><a href="#十八梯" class="headerlink" title="十八梯"></a><del>十八梯</del></h3><ul><li>电影《从你的全世界路过》</li><li>十八梯是重庆渝中半岛的一条街，从重庆城的上半城（山顶）通到下半城（山脚），全部由石阶铺成，<strong>把山顶的繁华商业区和山下江边的老城区连起来</strong>。</li><li><strong>拆迁了</strong></li></ul><h3 id="朝天门两江游"><a href="#朝天门两江游" class="headerlink" title="朝天门两江游"></a>朝天门两江游</h3><ul><li>重庆很出名的两江交汇：<strong>长江与嘉陵江</strong></li><li>夜景</li></ul><h3 id="长江索道"><a href="#长江索道" class="headerlink" title="长江索道"></a>长江索道</h3><ul><li>到达对岸后不用着急回来可以在那边拍拍照，然后再返回来</li></ul><h3 id="皇冠大扶梯"><a href="#皇冠大扶梯" class="headerlink" title="皇冠大扶梯"></a>皇冠大扶梯</h3><ul><li>亚洲第二长的一级提升坡地大扶梯</li><li>这个扶梯<strong>不用刻意去</strong>，如果方便可以去坐坐，其实<em>就是一个长长的扶梯</em>，但是因为有坡度而且特别长所以很炫酷！</li></ul><h3 id="中山四路"><a href="#中山四路" class="headerlink" title="中山四路"></a>中山四路</h3><ul><li>历史遗迹很多，除了中国民主党派博物馆的特园外，此地还有桂园、周公馆、戴公馆、张骧公馆、国民政府总统府旧址等</li></ul><h3 id="解放碑"><a href="#解放碑" class="headerlink" title="解放碑"></a>解放碑</h3><ul><li><strong>解放碑是重庆的标志</strong>，特别是圣诞节和跨年的时候，大家会不约而同地去解放碑一同度过！场面壮观到每年都会提前进行封路。</li><li>解放碑那有一条<strong>好吃街</strong>，可以去吃吃～</li><li><strong>李串串</strong></li></ul><h3 id="两江影视城民国街"><a href="#两江影视城民国街" class="headerlink" title="两江影视城民国街"></a>两江影视城民国街</h3><ul><li>再现了百年老重庆风土人情</li><li>影视城里重现了当时的解放碑、磁器口、朝天门、十八梯，特别有意思</li><li>当地也可以<strong>租民国服装</strong></li></ul><h2 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h2><h3 id="重庆小面"><a href="#重庆小面" class="headerlink" title="重庆小面"></a>重庆小面</h3><h3 id="重庆火锅"><a href="#重庆火锅" class="headerlink" title="重庆火锅"></a>重庆火锅</h3><ul><li><strong>大龙火锅</strong>。以<strong>超辣</strong>闻名，吃这家店的人超级多，中午都得排很久的队</li></ul><h3 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h3><ul><li>串串推荐小郡肝、李记、怒火八零等等</li></ul><h3 id="酸辣粉-凉粉-冰粉凉虾-凉糕"><a href="#酸辣粉-凉粉-冰粉凉虾-凉糕" class="headerlink" title="酸辣粉/凉粉/冰粉凉虾/凉糕"></a>酸辣粉/凉粉/冰粉凉虾/凉糕</h3><ul><li><strong>莱得快</strong>的杂酱酸辣粉</li><li><strong>阿坤</strong>的杂酱酸辣粉、苕皮、海带，有点辣。但是阿坤里面有甜品所以可以也点一份甜品，防止被辣着，推荐它们的双皮奶。</li><li>好又来酸辣粉（口碑店家）、手工酸辣粉（视觉和味觉两不误）</li></ul><h3 id="麻辣鱼-酸菜鱼-尖椒兔"><a href="#麻辣鱼-酸菜鱼-尖椒兔" class="headerlink" title="麻辣鱼/酸菜鱼/尖椒兔"></a>麻辣鱼/酸菜鱼/尖椒兔</h3><ul><li>大渡口，店名是：<strong>霸王兔</strong></li></ul><h3 id="夜啤酒-万州烤鱼-烧烤"><a href="#夜啤酒-万州烤鱼-烧烤" class="headerlink" title="夜啤酒/万州烤鱼/烧烤"></a>夜啤酒/万州烤鱼/烧烤</h3><h3 id="奶制品"><a href="#奶制品" class="headerlink" title="奶制品"></a>奶制品</h3><ul><li>重庆本土的<strong>天友</strong>，以及后发的<strong>奶牛梦工厂</strong></li></ul><h2 id="参考路线"><a href="#参考路线" class="headerlink" title="参考路线"></a>参考路线</h2><ul><li><a href="https://www.zhihu.com/question/36219939/answer/109923082" target="_blank" rel="noopener">两天</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://showteeth.tech/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="旅游" scheme="http://showteeth.tech/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>comm-文件比较，文本文件的交集、差集与求差</title>
    <link href="http://showteeth.tech/posts/39582.html"/>
    <id>http://showteeth.tech/posts/39582.html</id>
    <published>2019-03-06T06:22:30.000Z</published>
    <updated>2019-03-17T02:17:59.560Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>comm</code>命令对两个文件内容进行比较，注意文件<strong>需要排序</strong>，相比于其他比较文件的命令，<code>comm</code>可以将文件内容不同的分列显示，<strong>便于提取(文件求交、并、差、对称差等)所需要的内容</strong>，另外两个文件比较命令包括<a href="http://showteeth.tech/posts/62860.html">cmp</a>、<a href="http://showteeth.tech/posts/56778.html">diff</a>。</p></div><a id="more"></a><h2 id="comm用法"><a href="#comm用法" class="headerlink" title="comm用法"></a>comm用法</h2><p><code>comm</code>命令会<strong>一行行(line by line)地</strong>比较两个<mark>已排序文件</mark>的差异，并将其结果显示出来，如果没有指定任何参数，则会把<strong>结果分成3行显示</strong>：</p><ul><li>第1行<strong>仅</strong>是在<strong>第1个文件中</strong>出现过的列</li><li>第2行是<strong>仅</strong>在<strong>第2个文件中</strong>出现过的列</li><li>第3行则是在第1与第2个文件里<strong>都出现过</strong>的列。</li></ul><p>若给予的文件名称为<code>-</code>，则<code>comm</code>命令会从<strong>标准输入</strong>设备读取数据</p><h3 id="comm命令格式"><a href="#comm命令格式" class="headerlink" title="comm命令格式"></a>comm命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  comm [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="comm-options说明"><a href="#comm-options说明" class="headerlink" title="comm options说明"></a>comm options说明</h3><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>不显示第1列（即不显示只在file1中找到的行）</td></tr><tr><td>-2</td><td>不显示第2列（即不显示只在file2中找到的行）</td></tr><tr><td>-3</td><td>不显示第3列（即不显示在两个文件中都找到的行）</td></tr><tr><td>–check-order</td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td>不判断所有输入文件是不是已经排好序</td></tr><tr><td>–output-delimiter=STR</td><td>指定输出结果的分隔符</td></tr></tbody></table><hr><p><br></p><h2 id="comm用法实例"><a href="#comm用法实例" class="headerlink" title="comm用法实例"></a>comm用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat a.txt<br>aaa<br>bbb<br>ccc<br>111<br>ddd<br>eee<br>222</p></blockquote><blockquote><p>cat b.txt<br>bbb<br>ccc<br>aaa<br>hhh<br>ttt<br>jjj</p></blockquote><p>注意上面两个文件都没有排序，看看comm对没排序文件的处理</p><hr><h3 id="使用默认方式对文本进行比较"><a href="#使用默认方式对文本进行比较" class="headerlink" title="使用默认方式对文本进行比较"></a>使用默认方式对文本进行比较</h3><blockquote><p><code>comm a.txt b.txt</code><br>aaa<br>bbb<br>ccc<br>comm: file 1 is not in sorted order<br>comm: file 2 is not in sorted order<br>111<br>aaa<br>ddd<br>eee<br>222<br>hhh<br>ttt<br>jjj</p></blockquote><p>从上面可以看出，没排序comm命令会爆出问题，但是仍然会运行得到结果；发现因为没有排序的原因，第二个文件的<code>aaa</code>在第一个文件中也存在但是却被当成了file2独有的。<strong>总的来说就是如果没排序，comm命令会爆出问题但不会停止运行，并且结果会存在问题</strong>，正常结果如下：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><p>可以看出默认情况会输出三列，第一列是第一个文件独有的内容，第二列是第二个文件独有的内容，第三列是第三个文件独有的内容，各列是以制表符<code>\t</code>作为定界符，可以通过对定界符-制表符<code>\t</code>的操作来达到相应的目的。</p><p>由于参数较为简单，这里就不单独列出每个参数单独的用法的示例，主要给出<strong>参数组合用法以及和定界符组合使用的示例如下</strong>：</p><table><thead><tr><th>集合操作</th><th>含义及对应的参数组合</th></tr></thead><tbody><tr><td>A∩B</td><td>文件交集，-12</td></tr><tr><td>A∪B</td><td>文件的并集，将输出整合为一列，去掉定界符\t</td></tr><tr><td>A-B</td><td>差集，-23</td></tr><tr><td>B-A</td><td>差集，-13</td></tr><tr><td>A∆B</td><td>对称差集，并集减去交集，也就是去除文件中相同的部分，需要使用-3以及将剩下两列整合为一列</td></tr></tbody></table><h3 id="12-A∩B-文件交集"><a href="#12-A∩B-文件交集" class="headerlink" title="-12-A∩B-文件交集"></a>-12-A∩B-文件交集</h3><p>默认输出结果的第三列就是两个文件共有的部分：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -12 - &lt;(sort -k 1,1 b.txt)</code><br>aaa<br>bbb<br>ccc</p></blockquote><hr><h3 id="定界符-t-A∪B-文件的并集"><a href="#定界符-t-A∪B-文件的并集" class="headerlink" title="定界符\t-A∪B-文件的并集"></a>定界符\t-A∪B-文件的并集</h3><p>并集就是将三列输出结果合并：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="23-A-B-差集"><a href="#23-A-B-差集" class="headerlink" title="-23-A-B-差集"></a>-23-A-B-差集</h3><p>差集就是在A中但是不在B中的部分，去掉第三列(A、B共有的)以及第二列B独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -23 - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>ddd<br>eee</p></blockquote><hr><h3 id="12-B-A-差集"><a href="#12-B-A-差集" class="headerlink" title="-12-B-A-差集"></a>-12-B-A-差集</h3><p>差集就是在B中但是不在A中的部分，去掉第三列(A、B共有的)以及第一列A独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -13 - &lt;(sort -k 1,1 b.txt)</code><br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="3-定界符-t-A∆B-对称差集"><a href="#3-定界符-t-A∆B-对称差集" class="headerlink" title="-3+定界符\t-A∆B-对称差集"></a>-3+定界符\t-A∆B-对称差集</h3><p>对称差集就是两个文件独有的内容的并集：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -3 - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="多列文件的处理"><a href="#多列文件的处理" class="headerlink" title="多列文件的处理"></a>多列文件的处理</h3><p>多列文件处理会<strong>将一整行当成一个元素进行比较</strong>，来列出各个文件独有的、文件共有的信息，具体的每列代表的意思和单列文件相同，注意如果<strong>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠</strong></p><blockquote><p><code>cat c.txt</code><br>aaa 111<br>bbb 222</p></blockquote><blockquote><p><code>cat d.txt</code><br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><blockquote><p><code>comm c.txt d.txt</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><p>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠：</p><blockquote><p><code>sed &#39;s/ /\t/&#39; c.txt |comm - &lt;(sed &#39;s/ /\t/&#39; d.txt)</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/comm" target="_blank" rel="noopener">comm命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-comm.html" target="_blank" rel="noopener">Linux comm命令</a></li><li><a href="https://www.cnblogs.com/nerxious/archive/2013/01/09/2853004.html" target="_blank" rel="noopener">简明Linux命令行笔记：comm</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了使用&lt;code&gt;comm&lt;/code&gt;命令对两个文件内容进行比较，注意文件&lt;strong&gt;需要排序&lt;/strong&gt;，相比于其他比较文件的命令，&lt;code&gt;comm&lt;/code&gt;可以将文件内容不同的分列显示，&lt;strong&gt;便于提取(文件求交、并、差、对称差等)所需要的内容&lt;/strong&gt;，另外两个文件比较命令包括&lt;a href=&quot;http://showteeth.tech/posts/62860.html&quot;&gt;cmp&lt;/a&gt;、&lt;a href=&quot;http://showteeth.tech/posts/56778.html&quot;&gt;diff&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>anaconda安装多版本python及常用命令</title>
    <link href="http://showteeth.tech/posts/34297.html"/>
    <id>http://showteeth.tech/posts/34297.html</id>
    <published>2019-03-05T15:27:36.000Z</published>
    <updated>2019-03-17T02:17:39.157Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本是通过anaconda给电脑安装的python3，但是今天在从github上下载使用一个package时候报错：</p><blockquote><p>SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(‘File does not exist: %s’ % filepath)?</p></blockquote><p>后来发现这个是因为<strong>python版本的问题</strong>，所以就需要<strong>重新再安装一个python2的环境</strong></p><hr><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><p>这个本来可以使用简单地打开<code>anaconda navigator</code>图形界面进行<code>creat</code>环境即可，但是秉承着想对anaconda进行学习的态度，这里主要使用命令行的形式。</p><h3 id="显示所有环境名字和路径"><a href="#显示所有环境名字和路径" class="headerlink" title="显示所有环境名字和路径"></a>显示所有环境名字和路径</h3><p>创建新环境之前先看看目前的电脑有哪些环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>发现电脑只有一个原装的<code>base</code>环境，也就是<code>python3</code>的环境以及我自己安装的<code>rstudio</code>环境，同时需要注意<strong>上面的<code>*</code>表明是当前使用的环境！</strong></p><hr><h3 id="创建环境并指定环境名称和python版本"><a href="#创建环境并指定环境名称和python版本" class="headerlink" title="创建环境并指定环境名称和python版本"></a>创建环境并指定环境名称和python版本</h3><p>这一步是使用<code>conda create</code>创建环境，同时指定环境的名称为<code>pyenv2_7</code>，使用的python版本为<code>python=2.7</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pyenv2_7 python=2.7</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="再次显示所有环境名字和路径"><a href="#再次显示所有环境名字和路径" class="headerlink" title="再次显示所有环境名字和路径"></a>再次显示所有环境名字和路径</h3><p>创建新环境再次查看现在所有的环境名称和对应的路径：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><p>发现已经出现了新建的环境：</p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>pyenv2_7 C:\Users\14910\Anaconda3\envs\pyenv2_7<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>由于只是创建了环境，还没有激活，所以当前使用的环境(<code>*</code>标记的)还是<code>base</code>环境，<strong>新建的环境需要激活才能够使用</strong></p><hr><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>为了能够使用新创建的环境还需要激活：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pyenv2_7</span><br></pre></td></tr></table></figure><p></p><p>为了验证环境是不是已经成功应用，检查python版本：</p><blockquote><p>python –version<br>Python 2.7.15 :: Anaconda, Inc.</p></blockquote><p>发现环境已经安装成功</p><hr><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><p>使用完成之后推出新建的环境，回到<code>base</code>环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p></p><p><strong>注意<code>conda deactivate</code>后面不需要跟退出的环境名，直接就退出当前环境，退出环境之后直接就进入了base环境</strong>。</p><hr><h2 id="anaconda-常用命令"><a href="#anaconda-常用命令" class="headerlink" title="anaconda 常用命令"></a>anaconda 常用命令</h2><ul><li>activate // 切换到base环境</li><li>activate learn // 切换到learn环境</li><li>conda deactivate // 退出当前环境</li><li>conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)</li><li>conda env list (conda env –info) // 列出conda管理的所有环境</li><li>conda list // 列出当前环境的所有包</li><li>conda install requests (pip install requests) // 安装requests包</li><li>conda remove requests (pip uninstall requests) // 卸载requets包</li><li>conda update requests // 更新requests包</li><li>conda remove -n learn –all // <strong>删除learn环境及下属所有包</strong></li><li>conda env export &gt; environment.yaml // <strong>导出当前环境的包信息</strong></li><li>conda env create -f environment.yaml // <strong>用配置文件创建新的虚拟环境</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/tangwenbo124/article/details/74784044" target="_blank" rel="noopener">ananconda创建新环境，python 2.7、3.5共存，pycharm 使用conda新环境，win10、linux下通用</a></li><li><a href="https://www.jb51.net/article/114614.htm" target="_blank" rel="noopener">利用Anaconda完美解决Python 2与python 3的共存问题</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Python/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
