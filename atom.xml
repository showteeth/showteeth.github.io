<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-04-23T16:17:14.408Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shuf-随机打乱文件</title>
    <link href="http://showteeth.tech/posts/50731.html"/>
    <id>http://showteeth.tech/posts/50731.html</id>
    <published>2019-04-23T15:14:29.000Z</published>
    <updated>2019-04-23T16:17:14.408Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>对文件以及命令行输入进行随机打乱的命令<code>shuf</code></strong>，主要参数包括<code>-e</code>、<code>-i</code>、<code>-n</code>、<code>-o</code>、<code>-r</code>等。</p></div><a id="more"></a><h2 id="shuf简介"><a href="#shuf简介" class="headerlink" title="shuf简介"></a>shuf简介</h2><p><code>shuf</code>命令可以<strong>对文件或者命令行输入进行随机打乱并输出到标准输出或者指定的文件中</strong>，还<strong>可以指定<code>shuf</code>的随机模式(有放回地抽取)</strong></p><hr><h2 id="shuf命令格式"><a href="#shuf命令格式" class="headerlink" title="shuf命令格式"></a>shuf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: shuf [OPTION]... [FILE]</span><br><span class="line">  or:  shuf -e [OPTION]... [ARG]...</span><br><span class="line">  or:  shuf -i LO-HI [OPTION]...</span><br><span class="line"></span><br><span class="line">Write a random permutation of the input lines to standard output.</span><br></pre></td></tr></table></figure><hr><h2 id="shuf参数"><a href="#shuf参数" class="headerlink" title="shuf参数"></a>shuf参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-e</code></td><td><code>--echo</code></td><td>将参数作为输入信息进行随机打乱</td></tr><tr><td><code>-i</code></td><td><code>--input-range=LO-HI</code></td><td>在特定范围内生成随机数</td></tr><tr><td><code>-n</code></td><td><code>--head-count=COUNT</code></td><td>最大输出行数</td></tr><tr><td><code>-o</code></td><td><code>--output=FILE</code></td><td>指定输出文件</td></tr><tr><td></td><td><code>--random-source=FILE</code></td><td>get random bytes from FILE</td></tr><tr><td><code>-r</code></td><td><code>--repeat</code></td><td>有放回地抽取，需要结合<code>-n</code>参数一同使用</td></tr><tr><td><code>-z</code></td><td><code>--zero-terminated</code></td><td>以0 结束行而非换行符</td></tr></table><hr><h2 id="shuf使用实例"><a href="#shuf使用实例" class="headerlink" title="shuf使用实例"></a>shuf使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line6</span><br><span class="line">  line7</span><br><span class="line">  line8</span><br><span class="line">  line9</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="shuf默认行为"><a href="#shuf默认行为" class="headerlink" title="shuf默认行为"></a>shuf默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shuf test.txt</span><br><span class="line"><span class="comment"># 将test.txt随机打乱 </span></span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line7</span><br><span class="line">  line5</span><br><span class="line">  line10</span><br><span class="line">  line6</span><br><span class="line">  line8</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line1</span><br></pre></td></tr></table></figure><hr><h3 id="e-将参数作为输入信息进行随机打乱"><a href="#e-将参数作为输入信息进行随机打乱" class="headerlink" title="-e-将参数作为输入信息进行随机打乱"></a>-e-将参数作为输入信息进行随机打乱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shuf -e <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"mbc"</span></span><br><span class="line">  mbc</span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line"></span><br><span class="line">a=badad</span><br><span class="line">b=asdf</span><br><span class="line">c=sadfa</span><br><span class="line">shuf -e <span class="variable">$a</span> <span class="variable">$b</span> <span class="variable">$c</span></span><br><span class="line"><span class="comment"># 变量拓展</span></span><br><span class="line">  badad</span><br><span class="line">  sadfa</span><br><span class="line">  asdf</span><br></pre></td></tr></table></figure><hr><h3 id="i-在指定范围内生成随机数"><a href="#i-在指定范围内生成随机数" class="headerlink" title="-i-在指定范围内生成随机数"></a>-i-在指定范围内生成随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成1-10范围内的随机数</span></span><br><span class="line"><span class="comment"># 包括1和10</span></span><br><span class="line">shuf -i 1-10</span><br><span class="line">  3</span><br><span class="line">  7</span><br><span class="line">  4</span><br><span class="line">  6</span><br><span class="line">  1</span><br><span class="line">  9</span><br><span class="line">  2</span><br><span class="line">  5</span><br><span class="line">  10</span><br><span class="line">  8</span><br></pre></td></tr></table></figure><hr><h3 id="n-最大输出行数"><a href="#n-最大输出行数" class="headerlink" title="-n-最大输出行数"></a>-n-最大输出行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出随机打乱后结果的其中3行</span></span><br><span class="line">shuf -n 3 test.txt</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line9</span><br></pre></td></tr></table></figure><hr><h3 id="o-指定输出文件"><a href="#o-指定输出文件" class="headerlink" title="-o-指定输出文件"></a>-o-指定输出文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机打乱并将结果输出到shuf.txt</span></span><br><span class="line">shuf test.txt -o shuf.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">cat shuf.txt </span><br><span class="line">  line7</span><br><span class="line">  line1</span><br><span class="line">  line4</span><br><span class="line">  line6</span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line3</span><br><span class="line">  line5</span><br><span class="line">  line8</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="r-有放回地抽取"><a href="#r-有放回地抽取" class="headerlink" title="-r-有放回地抽取"></a>-r-有放回地抽取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有放回的抽取15行结果</span></span><br><span class="line">shuf -n 15 -r test.txt </span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line8</span><br><span class="line">  line1</span><br><span class="line">  line6</span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line1</span><br><span class="line">  line10</span><br><span class="line">  line7</span><br><span class="line">  line10</span><br><span class="line">  line10</span><br><span class="line">  line8</span><br></pre></td></tr></table></figure><div class="note info"><p><strong><code>-r</code>参数一定要结合<code>-n</code>参数一同使用</strong>，不然会一直运行有放回地抽取，<strong>相当于死循环</strong>，一直输出</p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.cn/article-9635-1.html" target="_blank" rel="noopener">给初学者看的 shuf 命令教程</a></li><li><a href="https://www.howtoforge.com/linux-shuf-command/" target="_blank" rel="noopener">Linux shuf Command Tutorial for Beginners (with Examples)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了linux中&lt;strong&gt;对文件以及命令行输入进行随机打乱的命令&lt;code&gt;shuf&lt;/code&gt;&lt;/strong&gt;，主要参数包括&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-o&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shell中的float问题</title>
    <link href="http://showteeth.tech/posts/61435.html"/>
    <id>http://showteeth.tech/posts/61435.html</id>
    <published>2019-04-20T01:51:47.000Z</published>
    <updated>2019-04-23T15:09:17.380Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了shell中<strong>处理浮点比较</strong>相关的内容，主要学习了<strong>使用<code>awk</code>以及<code>bc</code>命令来进行浮点比较和运算</strong>，此前还有一篇<a href="http://showteeth.tech/posts/28430.html">相关的文章</a></p></div><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在编写shell脚本的时候<strong>发现shell中使用浮点的比较</strong>会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 0.1 -lt 1 ]];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  -bash: [[: 0.1: syntax error: invalid arithmetic operator (error token is <span class="string">".1"</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>shell是不支持浮点的，不管是浮点的运算还是浮点的比较</p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="使用awk"><a href="#使用awk" class="headerlink" title="使用awk"></a>使用awk</h3><p>awk是支持浮点，包括运算以及比较：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点运算</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2/3&#125;'</span></span><br><span class="line">  0.666667</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&lt;3&#125;'</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&gt;3&#125;'</span></span><br><span class="line"><span class="comment"># 假则不输出结果</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用bc"><a href="#使用bc" class="headerlink" title="使用bc"></a>使用bc</h3><p>bc是shell中支持浮点相关方法的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点计算，如果结果小于0，会省略0，这里使用方法加上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br><span class="line"><span class="comment"># 输出结果，保留两位小数</span></span><br><span class="line">  0.66</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点的比较</span></span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &gt;= 0.3"</span></span><br><span class="line"><span class="comment"># 假值返回0</span></span><br><span class="line">  0</span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &lt;= 0.3"</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>注意<code>&lt;&lt;&lt;</code>、<code>&lt;&lt;</code>、<code>&lt;</code>的区别</strong>：</p><ul><li><code>&lt;</code>：表示从文件file中读取</li><li><code>&lt;&lt;</code>：表示从命令行读取到指定的结束字符</li><li><code>&lt;&lt;&lt;</code>：读取后面紧接的字符串</li><li>具体的用法实例参考<a href="http://showteeth.tech/posts/55603.html">文章</a><br><br></li></ul><p>关于浮点运算可以参考之前的<a href="http://showteeth.tech/posts/28430.html">文章</a></p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/2424770/floating-point-comparison-in-shell-script" target="_blank" rel="noopener">Floating Point Comparison in Shell Script</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了shell中&lt;strong&gt;处理浮点比较&lt;/strong&gt;相关的内容，主要学习了&lt;strong&gt;使用&lt;code&gt;awk&lt;/code&gt;以及&lt;code&gt;bc&lt;/code&gt;命令来进行浮点比较和运算&lt;/strong&gt;，此前还有一篇&lt;a href=&quot;http://showteeth.tech/posts/28430.html&quot;&gt;相关的文章&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据竞赛Top解决方案开源整理</title>
    <link href="http://showteeth.tech/posts/49396.html"/>
    <id>http://showteeth.tech/posts/49396.html</id>
    <published>2019-04-15T03:46:19.000Z</published>
    <updated>2019-04-15T07:22:25.958Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。</p></div><a id="more"></a><h2 id="纯数据竞赛"><a href="#纯数据竞赛" class="headerlink" title="纯数据竞赛"></a>纯数据竞赛</h2><h3 id="2018科大讯飞AI营销算法大赛"><a href="#2018科大讯飞AI营销算法大赛" class="headerlink" title="2018科大讯飞AI营销算法大赛"></a>2018科大讯飞AI营销算法大赛</h3><ul><li><strong>Rank1</strong>：<a href="https://zhuanlan.zhihu.com/p/47807544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47807544</a></li></ul><hr><h3 id="2018-IJCAI-阿里妈妈搜索广告转化预测"><a href="#2018-IJCAI-阿里妈妈搜索广告转化预测" class="headerlink" title="2018 IJCAI 阿里妈妈搜索广告转化预测"></a>2018 IJCAI 阿里妈妈搜索广告转化预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/plantsgo/ijcai-2018" target="_blank" rel="noopener">https://github.com/plantsgo/ijcai-2018</a></li><li><strong>Rank2</strong>：<ul><li><a href="https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution" target="_blank" rel="noopener">https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution</a></li><li><a href="https://blog.csdn.net/Bryan__/article/details/80600189" target="_blank" rel="noopener">https://blog.csdn.net/Bryan__/article/details/80600189</a></li></ul></li><li><strong>Rank3</strong>: <a href="https://github.com/luoda888/2018-IJCAI-top3" target="_blank" rel="noopener">https://github.com/luoda888/2018-IJCAI-top3</a></li><li><strong>Rank8</strong>: <a href="https://github.com/fanfanda/ijcai_2018" target="_blank" rel="noopener">https://github.com/fanfanda/ijcai_2018</a></li><li><strong>Rank8</strong>: <a href="https://github.com/Gene20/IJCAI-18" target="_blank" rel="noopener">https://github.com/Gene20/IJCAI-18</a></li><li><strong>Rank9（第一赛季）</strong>：<a href="https://github.com/yuxiaowww/IJCAI-18-TIANCHI" target="_blank" rel="noopener">https://github.com/yuxiaowww/IJCAI-18-TIANCHI</a></li><li><strong>Rank29</strong>: <a href="https://github.com/bettenW/IJCAI18_Tianchi_Rank29" target="_blank" rel="noopener">https://github.com/bettenW/IJCAI18_Tianchi_Rank29</a></li><li><strong>Rank41</strong>: <a href="https://github.com/cmlaughing/IJCAI-18" target="_blank" rel="noopener">https://github.com/cmlaughing/IJCAI-18</a></li><li><strong>Rank48</strong>: <a href="https://github.com/YunaQiu/IJCAI-18alimama" target="_blank" rel="noopener">https://github.com/YunaQiu/IJCAI-18alimama</a></li><li><strong>Rank53</strong>: <a href="https://github.com/altmanWang/IJCAI-18-CVR" target="_blank" rel="noopener">https://github.com/altmanWang/IJCAI-18-CVR</a></li><li><strong>Rank60</strong>: <a href="https://github.com/Chenyaorui/ijcai_2018" target="_blank" rel="noopener">https://github.com/Chenyaorui/ijcai_2018</a></li><li><strong>Rank81</strong>: <a href="https://github.com/wzp123456/IJCAI_18" target="_blank" rel="noopener">https://github.com/wzp123456/IJCAI_18</a></li><li><strong>Rank94</strong>: <a href="https://github.com/Yangtze121/-IJCAI-18-" target="_blank" rel="noopener">https://github.com/Yangtze121/-IJCAI-18-</a></li></ul><hr><h3 id="2018腾讯广告算法大赛"><a href="#2018腾讯广告算法大赛" class="headerlink" title="2018腾讯广告算法大赛"></a>2018腾讯广告算法大赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/DiligentPanda/Tencent_Ads_Algo_2018" target="_blank" rel="noopener">https://github.com/DiligentPanda/Tencent_Ads_Algo_2018</a></li><li><strong>Rank6</strong>: <a href="https://github.com/nzc/tencent-contest" target="_blank" rel="noopener">https://github.com/nzc/tencent-contest</a></li><li><strong>Rank7</strong>: <a href="https://github.com/guoday/Tencent2018_Lookalike_Rank7th" target="_blank" rel="noopener">https://github.com/guoday/Tencent2018_Lookalike_Rank7th</a></li><li><strong>Rank9</strong>: <a href="https://github.com/ouwenjie03/tencent-ad-game" target="_blank" rel="noopener">https://github.com/ouwenjie03/tencent-ad-game</a></li><li><strong>Rank10</strong>: <a href="https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th" target="_blank" rel="noopener">https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th</a></li><li><strong>rank10（初赛）</strong>: <a href="https://github.com/ShawnyXiao/2018-Tencent-Lookalike" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-Tencent-Lookalike</a></li><li><strong>Rank11</strong>:<ul><li><a href="https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest" target="_blank" rel="noopener">https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest</a></li><li><a href="https://my.oschina.net/xtzggbmkk/blog/1865680" target="_blank" rel="noopener">https://my.oschina.net/xtzggbmkk/blog/1865680</a></li></ul></li><li><strong>Rank26</strong>: <a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="noopener">https://github.com/zsyandjyhouse/TencentAD_contest</a></li><li><strong>Rank33</strong>: <a href="https://github.com/John-Yao/Tencent_Social_Ads2018" target="_blank" rel="noopener">https://github.com/John-Yao/Tencent_Social_Ads2018</a></li><li><strong>Rank69</strong>: <a href="https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest" target="_blank" rel="noopener">https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest</a></li></ul><hr><h3 id="2018高校大数据挑战赛-快手活跃用户预测"><a href="#2018高校大数据挑战赛-快手活跃用户预测" class="headerlink" title="2018高校大数据挑战赛-快手活跃用户预测"></a>2018高校大数据挑战赛-快手活跃用户预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://github.com/drop-out/RNN-Active-User-Forecast" target="_blank" rel="noopener">https://github.com/drop-out/RNN-Active-User-Forecast</a></li><li><a href="https://zhuanlan.zhihu.com/p/42622063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42622063</a></li></ul></li><li><strong>Rank4</strong>: <a href="https://github.com/chantcalf/2018-Rank4-" target="_blank" rel="noopener">https://github.com/chantcalf/2018-Rank4-</a></li><li><strong>Rank13(初赛 a榜rank2 b榜rank5)</strong>: <a href="https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions" target="_blank" rel="noopener">https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions</a></li><li><strong>Rank15</strong>: <a href="https://github.com/sunwantong/Kuaishou-Active-User" target="_blank" rel="noopener">https://github.com/sunwantong/Kuaishou-Active-User</a></li><li><strong>Rank20</strong>: <a href="https://github.com/bigzhao/Kuaishou_2018_rank20th" target="_blank" rel="noopener">https://github.com/bigzhao/Kuaishou_2018_rank20th</a></li><li><strong>Rank28(初赛 a榜rank1 b榜rank2)</strong>：<ul><li><a href="https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-" target="_blank" rel="noopener">https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-</a></li><li><a href="https://github.com/FNo0/2018-KUAISHOU-Top28" target="_blank" rel="noopener">https://github.com/FNo0/2018-KUAISHOU-Top28</a></li></ul></li></ul><hr><h3 id="2018JDATA-用户购买时间预测"><a href="#2018JDATA-用户购买时间预测" class="headerlink" title="2018JDATA 用户购买时间预测"></a>2018JDATA 用户购买时间预测</h3><ul><li><strong>Rank9</strong>：<a href="https://zhuanlan.zhihu.com/p/45141799" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45141799</a></li></ul><hr><h3 id="2018-DF风机叶片开裂预警"><a href="#2018-DF风机叶片开裂预警" class="headerlink" title="2018 DF风机叶片开裂预警"></a>2018 DF风机叶片开裂预警</h3><ul><li><strong>Rank2</strong>：<a href="https://github.com/SY575/DF-Early-warning-of-the-wind-power-system" target="_blank" rel="noopener">https://github.com/SY575/DF-Early-warning-of-the-wind-power-system</a></li></ul><hr><h3 id="2018-DF光伏发电量预测"><a href="#2018-DF光伏发电量预测" class="headerlink" title="2018 DF光伏发电量预测"></a>2018 DF光伏发电量预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168</a></li><li><a href="https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g</a></li></ul></li></ul><hr><h3 id="AI全球挑战者大赛-违约用户风险预测"><a href="#AI全球挑战者大赛-违约用户风险预测" class="headerlink" title="AI全球挑战者大赛-违约用户风险预测"></a>AI全球挑战者大赛-违约用户风险预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/chenkkkk/User-loan-risk-prediction" target="_blank" rel="noopener">https://github.com/chenkkkk/User-loan-risk-prediction</a></li></ul><hr><h3 id="2016融360-用户贷款风险预测"><a href="#2016融360-用户贷款风险预测" class="headerlink" title="2016融360-用户贷款风险预测"></a>2016融360-用户贷款风险预测</h3><ul><li><strong>Rank7</strong>：<a href="https://github.com/hczheng/Rong360" target="_blank" rel="noopener">https://github.com/hczheng/Rong360</a></li></ul><hr><h3 id="2016-CCF-020优惠券使用预测"><a href="#2016-CCF-020优惠券使用预测" class="headerlink" title="2016 CCF-020优惠券使用预测"></a>2016 CCF-020优惠券使用预测</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="noopener">https://github.com/wepe/O2O-Coupon-Usage-Forecast</a></li></ul><hr><h3 id="2016-ccf-农产品价格预测"><a href="#2016-ccf-农产品价格预测" class="headerlink" title="2016 ccf-农产品价格预测"></a>2016 ccf-农产品价格预测</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/xing89qs/CCF_Product" target="_blank" rel="noopener">https://github.com/xing89qs/CCF_Product</a></li><li><strong>Rank35</strong>: <a href="https://github.com/wqlin/ccf-price-prediction" target="_blank" rel="noopener">https://github.com/wqlin/ccf-price-prediction</a></li></ul><hr><h3 id="2016-ccf-客户用电异常"><a href="#2016-ccf-客户用电异常" class="headerlink" title="2016 ccf-客户用电异常"></a>2016 ccf-客户用电异常</h3><ul><li><strong>Rank4</strong>: <a href="https://github.com/AbnerYang/2016CCF-StateGrid" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-StateGrid</a></li></ul><hr><h3 id="2016-ccf-搜狗的用户画像比赛"><a href="#2016-ccf-搜狗的用户画像比赛" class="headerlink" title="2016 ccf-搜狗的用户画像比赛"></a>2016 ccf-搜狗的用户画像比赛</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/hengchao0248/ccf2016_sougou" target="_blank" rel="noopener">https://github.com/hengchao0248/ccf2016_sougou</a></li><li><strong>Rank3</strong>: <a href="https://github.com/AbnerYang/2016CCF-SouGou" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-SouGou</a></li><li><strong>Rank5</strong>:<ul><li><a href="https://github.com/dhdsjy/2016_CCFsougou" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou</a></li><li><a href="https://github.com/dhdsjy/2016_CCFsougou2" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou2</a></li><li><a href="https://github.com/prozhuchen/2016CCF-sougou" target="_blank" rel="noopener">https://github.com/prozhuchen/2016CCF-sougou</a></li><li><a href="https://github.com/coderSkyChen/2016CCF_BDCI_Sougou" target="_blank" rel="noopener">https://github.com/coderSkyChen/2016CCF_BDCI_Sougou</a></li></ul></li></ul><hr><h3 id="2016-ccf-联通的用户轨迹"><a href="#2016-ccf-联通的用户轨迹" class="headerlink" title="2016 ccf-联通的用户轨迹"></a>2016 ccf-联通的用户轨迹</h3><ul><li><strong>RankX</strong>: <a href="https://github.com/xuguanggen/2016CCF-unicom" target="_blank" rel="noopener">https://github.com/xuguanggen/2016CCF-unicom</a></li></ul><hr><h3 id="2016-ccf-Human-or-Robots"><a href="#2016-ccf-Human-or-Robots" class="headerlink" title="2016 ccf-Human or Robots"></a>2016 ccf-Human or Robots</h3><ul><li><strong>Rank6</strong>: <a href="https://github.com/pickou/ccf_human_or_robot" target="_blank" rel="noopener">https://github.com/pickou/ccf_human_or_robot</a></li></ul><hr><h3 id="菜鸟-需求预测与分仓规划"><a href="#菜鸟-需求预测与分仓规划" class="headerlink" title="菜鸟-需求预测与分仓规划"></a>菜鸟-需求预测与分仓规划</h3><ul><li><strong>Rank6</strong>:<a href="https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning" target="_blank" rel="noopener">https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning</a></li><li><strong>Rank10</strong>: <a href="https://github.com/xing89qs/TianChi_CaiNiao_Season2" target="_blank" rel="noopener">https://github.com/xing89qs/TianChi_CaiNiao_Season2</a></li></ul><hr><p><br></p><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="2018-DC达观-文本智能处理挑战"><a href="#2018-DC达观-文本智能处理挑战" class="headerlink" title="2018 DC达观-文本智能处理挑战"></a>2018 DC达观-文本智能处理挑战</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess</a></li><li><strong>Rank4</strong>: <a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li><li><strong>Rank10</strong>: <a href="https://github.com/moneyDboat/data_grand" target="_blank" rel="noopener">https://github.com/moneyDboat/data_grand</a></li><li><strong>Rank18</strong>: <a href="https://github.com/nlpjoe/daguan-classify-2018" target="_blank" rel="noopener">https://github.com/nlpjoe/daguan-classify-2018</a></li><li><strong>RankX</strong>: <a href="https://github.com/yanqiangmiffy/daguan" target="_blank" rel="noopener">https://github.com/yanqiangmiffy/daguan</a></li></ul><hr><h3 id="智能客服问题相似度算法设计——第三届魔镜杯大赛"><a href="#智能客服问题相似度算法设计——第三届魔镜杯大赛" class="headerlink" title="智能客服问题相似度算法设计——第三届魔镜杯大赛"></a>智能客服问题相似度算法设计——第三届魔镜杯大赛</h3><ul><li><strong>rank6</strong>：<a href="https://github.com/qrfaction/paipaidai" target="_blank" rel="noopener">https://github.com/qrfaction/paipaidai</a></li><li><strong>rank12</strong>：<a href="https://www.jianshu.com/p/827dd447daf9" target="_blank" rel="noopener">https://www.jianshu.com/p/827dd447daf9</a> <a href="https://github.com/LittletreeZou/Question-Pairs-Matching" target="_blank" rel="noopener">https://github.com/LittletreeZou/Question-Pairs-Matching</a></li><li><strong>Rank16</strong>：<a href="https://github.com/guoday/PaiPaiDai2018_rank16" target="_blank" rel="noopener">https://github.com/guoday/PaiPaiDai2018_rank16</a></li><li><strong>Rank29</strong>: <a href="https://github.com/wangjiaxin24/daguan_NLP" target="_blank" rel="noopener">https://github.com/wangjiaxin24/daguan_NLP</a></li></ul><hr><h3 id="2018JD-Dialog-Challenge-任务导向型对话系统挑战赛"><a href="#2018JD-Dialog-Challenge-任务导向型对话系统挑战赛" class="headerlink" title="2018JD Dialog Challenge 任务导向型对话系统挑战赛"></a>2018JD Dialog Challenge 任务导向型对话系统挑战赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/zengbin93/jddc_solution_4th" target="_blank" rel="noopener">https://github.com/zengbin93/jddc_solution_4th</a></li></ul><hr><h3 id="2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛"><a href="#2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛" class="headerlink" title="2018CIKM AnalytiCup  – 阿里小蜜机器人跨语言短文本匹配算法竞赛"></a>2018CIKM AnalytiCup – 阿里小蜜机器人跨语言短文本匹配算法竞赛</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/zake7749/Closer" target="_blank" rel="noopener">https://github.com/zake7749/Closer</a></li><li><strong>Rank12</strong>：<a href="https://github.com/Leputa/CIKM-AnalytiCup-2018" target="_blank" rel="noopener">https://github.com/Leputa/CIKM-AnalytiCup-2018</a></li><li><strong>Rank18</strong>: <a href="https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018" target="_blank" rel="noopener">https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018</a></li></ul><hr><p><br></p><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h3 id="Kaggle-TGS"><a href="#Kaggle-TGS" class="headerlink" title="Kaggle-TGS"></a>Kaggle-TGS</h3><ul><li><strong>Rank56</strong>：<a href="https://github.com/Gary-Deeplearning/TGS-Sal" target="_blank" rel="noopener">https://github.com/Gary-Deeplearning/TGS-Sal</a></li></ul><hr><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><h3 id="经验文章"><a href="#经验文章" class="headerlink" title="经验文章"></a>经验文章</h3><ul><li><p><strong>介绍featexp 一个帮助理解特征的工具包</strong>：<a href="http://www.sohu.com/a/273552971_129720" target="_blank" rel="noopener">http://www.sohu.com/a/273552971_129720</a></p></li><li><p>Ask Me Anything session with a Kaggle Grandmaster Vladimir I. Iglovikov PDF：<a href="https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ</a></p></li></ul><hr><h3 id="大佬的Github"><a href="#大佬的Github" class="headerlink" title="大佬的Github"></a>大佬的Github</h3><ul><li><strong>植物</strong> ：<a href="https://github.com/plantsgo" target="_blank" rel="noopener">https://github.com/plantsgo</a></li><li><strong>wepon</strong> ：<a href="https://github.com/wepe" target="_blank" rel="noopener">https://github.com/wepe</a></li><li><strong>Snake</strong>：<a href="https://github.com/luoda888" target="_blank" rel="noopener">https://github.com/luoda888</a></li><li><strong>Drop-out</strong>：<a href="https://github.com/drop-out" target="_blank" rel="noopener">https://github.com/drop-out</a></li><li><strong>金老师的知乎</strong>：<a href="https://zhuanlan.zhihu.com/jlbookworm" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/jlbookworm</a></li><li><strong>渣大</strong>：<a href="https://github.com/nzc" target="_blank" rel="noopener">https://github.com/nzc</a></li><li><strong>郭大</strong>：<a href="https://github.com/guoday" target="_blank" rel="noopener">https://github.com/guoday</a></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>数据比赛资讯</strong>：<a href="https://github.com/iphysresearch/DataSciComp" target="_blank" rel="noopener">https://github.com/iphysresearch/DataSciComp</a></li><li><strong>ApacheCN 的kaggle资料链接</strong>：<a href="https://github.com/apachecn/kaggle" target="_blank" rel="noopener">https://github.com/apachecn/kaggle</a></li><li><strong>Kaggle top方案整理</strong>：<a href="https://github.com/EliotAndres/kaggle-past-solutions" target="_blank" rel="noopener">https://github.com/EliotAndres/kaggle-past-solutions</a></li></ul><hr><h3 id="团队联系方式"><a href="#团队联系方式" class="headerlink" title="团队联系方式"></a>团队联系方式</h3><ul><li><strong>Smile</strong> qq:240485545 Email:<a href="mailto:smile.xuhc@gmail.com" target="_blank" rel="noopener">smile.xuhc@gmail.com</a></li><li><strong>PUSH</strong> qq:1471386635 Email：<a href="mailto:1471386635@qq.com" target="_blank" rel="noopener">1471386635@qq.com</a></li><li><strong>dive2space</strong> qq: 1124361357 Email:<a href="mailto:dive2space@qq.com" target="_blank" rel="noopener">dive2space@qq.com</a></li></ul><hr><h2 id="来源链接"><a href="#来源链接" class="headerlink" title="来源链接"></a>来源链接</h2><p><a href="https://mp.weixin.qq.com/s/_4QG0dWhh784lF0n1wymcw" target="_blank" rel="noopener">竞赛|数据竞赛Top解决方案开源整理</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://showteeth.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="竞赛" scheme="http://showteeth.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="开源代码" scheme="http://showteeth.tech/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>anaconda管理软件和环境</title>
    <link href="http://showteeth.tech/posts/42087.html"/>
    <id>http://showteeth.tech/posts/42087.html</id>
    <published>2019-04-14T02:49:27.000Z</published>
    <updated>2019-04-15T14:49:51.909Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><ul><li>印象笔记里面的两篇文章</li><li>斌斌师兄的脚本看看(里面有2和3兼容的问题)</li></ul><p>主要想解决的问题：</p><ul><li>环境备份的问题—多台集群环境如何管理</li><li>软件冲突时如何将软件安装在另一个环境中，使用的时候是怎么使用的呢？—直接找到环境的bin目录，然后将给软件指定alias指定到这个目录？</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>csplit-根据文本内容切割文件</title>
    <link href="http://showteeth.tech/posts/1958.html"/>
    <id>http://showteeth.tech/posts/1958.html</id>
    <published>2019-04-12T13:34:07.000Z</published>
    <updated>2019-04-14T01:26:35.109Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux常用的按照文件内容来对文件进行分割的命令csplit，前面学习的split主要是根据文件的外部信息进行的分割；主要学习了利用pattern模式分割以及参数使用；patern方面主要学习了<code>INTEGER</code>、<code>/REGEXP/[OFFSET]</code>、<code>{INTEGER}</code>、<code>{*}</code>以及<code>%REGEXP%[OFFSET]</code>；参数主要学习了<code>-f</code>、<code>-b</code>、<code>-n</code>、<code>-z</code>、<code>-k</code>和<code>-s</code>。</p></div><a id="more"></a><h2 id="csplit简介"><a href="#csplit简介" class="headerlink" title="csplit简介"></a>csplit简介</h2><p><code>csplit</code>主要是依据<strong>文件内容</strong>来进行切割文件，与<code>split</code>不同，<code>split</code>只是<strong>依据文件外部的信息</strong>，包括<strong>大小</strong>、<strong>行数</strong>以及<strong>分割得到的文件数目</strong>来进行限制。</p><hr><h2 id="csplit命令格式"><a href="#csplit命令格式" class="headerlink" title="csplit命令格式"></a>csplit命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  csplit [OPTION]... FILE PATTERN...</span><br></pre></td></tr></table></figure><p><strong>默认输出</strong>：</p><ul><li>每个小文件的字节数目</li><li>文件名为xx00、xx01这种</li></ul><h2 id="csplit-options参数"><a href="#csplit-options参数" class="headerlink" title="csplit options参数"></a>csplit options参数</h2><table><thead><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td><code>-suffix-format=FORMAT</code></td><td>预预设的输出格式其文件名称为xx00，xx01等，用户可以通过改变format来改变输出的文件名；</td></tr><tr><td><code>-f</code></td><td><code>--prefix=PREFIX</code></td><td>设置输出文件名的前缀，替换默认的xx</td></tr><tr><td><code>-k</code></td><td><code>--keep-files</code></td><td>就算发生错误或者终止运行，也不删除已经输出的文件</td></tr><tr><td><code>-n</code></td><td><code>--digits=DIGITS</code></td><td>默认输出的文件后缀为两位数字，这个参数可以修改后缀数字的数目，默认为2</td></tr><tr><td><code>-s</code></td><td><code>--quiet, --silent</code></td><td>静默输出，不显示执行过程</td></tr><tr><td><code>-z</code></td><td><code>--elide-empty-files</code></td><td>删除(不输出)空的输出文件</td></tr></tbody></table><hr><h2 id="csplit-匹配模式"><a href="#csplit-匹配模式" class="headerlink" title="csplit 匹配模式"></a>csplit 匹配模式</h2><p><escepe></escepe></p><p><table><br><thead><br><tr><br><th width="15%">参数</th><br><th width="85%">说明</th><br></tr><br></thead><br><tbody><br><tr><br><td><code>INTEGER</code></td><br><td>使用行数来分割文件(不包括指定的行数)</td><br></tr><br><tr><br><td><code>/REGEXP/[OFFSET]</code></td><br><td>使用REGEXP来分割文件(不包含REGEXP行)</td><br></tr><br><tr><br><td><code>%REGEXP%[OFFSET]</code></td><br><td>跳过REGEXP之前的行，从之后的行开始输出</td><br></tr><br><tr><br><td><code>{INTEGER}</code></td><br><td>重复前面的pattern指定的次数</td><br></tr><br><tr><br><td><code>{*}</code></td><br><td>尽可能多地重复前面的pattern</td><br></tr><br></tbody><br></table><br></p><hr><p><br></p><h2 id="csplit匹配模式使用实例"><a href="#csplit匹配模式使用实例" class="headerlink" title="csplit匹配模式使用实例"></a>csplit匹配模式使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat server.log </span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-3</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><hr><h3 id="INTEGER-按行划分"><a href="#INTEGER-按行划分" class="headerlink" title="INTEGER-按行划分"></a>INTEGER-按行划分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割为前一行 和 剩余的行</span></span><br><span class="line"><span class="comment"># 注意是不包括数字指定的行</span></span><br><span class="line">csplit server.log 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出划分得到的小文件的字节大小</span></span><br><span class="line">  9</span><br><span class="line">  273</span><br></pre></td></tr></table></figure><p><strong>输出内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user   9 Apr 13 16:15 xx00</span><br><span class="line">-rw-rw-r--. 1 user user 273 Apr 13 16:15 xx01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不包括第二行</span></span><br><span class="line">cat xx00</span><br><span class="line">  SERVER-1</span><br></pre></td></tr></table></figure><p></p><p>也可以指定<strong>多个整数</strong>来分割：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定多行文本进行划分</span></span><br><span class="line"><span class="comment"># 分别得到0-1、2-4、5-6、7-最后的文件</span></span><br><span class="line">csplit server.log 2 5 7</span><br><span class="line">  9</span><br><span class="line">  63</span><br><span class="line">  30</span><br><span class="line">  180</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user   9 Apr 13 16:20 xx00</span><br><span class="line">-rw-rw-r--. 1 user user  63 Apr 13 16:20 xx01</span><br><span class="line">-rw-rw-r--. 1 user user  30 Apr 13 16:20 xx02</span><br><span class="line">-rw-rw-r--. 1 user user 180 Apr 13 16:20 xx03</span><br><span class="line"></span><br><span class="line"><span class="comment"># server.log的第2、3、4行</span></span><br><span class="line">cat xx01</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="REGEXP-OFFSET-匹配分割文件"><a href="#REGEXP-OFFSET-匹配分割文件" class="headerlink" title="/REGEXP/[OFFSET]-匹配分割文件"></a>/REGEXP/[OFFSET]-匹配分割文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以SERVER-2为模式进行分割</span></span><br><span class="line"><span class="comment"># 不包括模式匹配上的这一行</span></span><br><span class="line">csplit server.log /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 16:43 xx00</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 16:43 xx01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不包括SERVER-2这一行</span></span><br><span class="line">cat xx00</span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br></pre></td></tr></table></figure><p></p><p><strong>匹配的是pattern第一次出现的位置</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上述测试文件的SERVER-3修改为SERVER-2</span></span><br><span class="line">csplit server.log /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第一次出现SERVER的位置分割</span></span><br><span class="line"><span class="comment"># 因为SERVER出现在第一行，所以第一个文件大小为0</span></span><br><span class="line">csplit server.log /SERVER*/ </span><br><span class="line">  0</span><br><span class="line">  282</span><br></pre></td></tr></table></figure><p></p><p><strong>第一次匹配输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从第一次匹配到SERVER-2的位置进行分割</span></span><br><span class="line">more xx01</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><p><strong>指定模式之后的偏移</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以SERVER-2为模式进行分割</span></span><br><span class="line"><span class="comment">#  并且向下移一行，这样就包括了模式匹配上的那一行</span></span><br><span class="line"><span class="comment"># 偏移+表示向下多输出一行</span></span><br><span class="line"><span class="comment"># -表示向上少输出一样</span></span><br><span class="line">csplit server.log /SERVER-2/+1</span><br><span class="line">  102</span><br><span class="line">  180</span><br></pre></td></tr></table></figure><p></p><p><strong>偏移后的输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SERVER-1</span><br><span class="line">[con] 10.10.10.1 suc</span><br><span class="line">[con] 10.10.10.2 fai</span><br><span class="line">[dis] 10.10.10.3 pen</span><br><span class="line">[con] 10.10.10.4 suc</span><br><span class="line">SERVER-2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>REGEXP</code>匹配的是第一次出现的位置，只会在<strong>第一次出现位置</strong>处切割</li><li>可以设置<code>[OFFSET]</code>来进行匹配行的上下偏移</li></ul></div><hr><h3 id="INTEGER-和-重复前面的pattern"><a href="#INTEGER-和-重复前面的pattern" class="headerlink" title="{INTEGER}和{*}-重复前面的pattern"></a>{INTEGER}和{*}-重复前面的pattern</h3><p>前面的<code>/REGEXP/[OFFSET]</code>只会在第一次出现pattern的位置进行切割，如果想要在所有的pattern匹配位置进行切割，可以借助<code>{INTEGER}</code>和<code>{*}</code>分别进行<strong>指定次数的重复</strong>pattern以及<strong>任意次数的重复</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复前面的pettern一次</span></span><br><span class="line"><span class="comment"># 是重复一次，原本中有2个SERVER-2，只用重复一次即可</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;1&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置重复两次会出错</span></span><br><span class="line"><span class="comment"># 这种情况不会有结果输出</span></span><br><span class="line"><span class="comment"># 可以借助后面的-k参数来保留结果</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复任意次数</span></span><br><span class="line"><span class="comment"># 这样可以避免出现不知道pettern出现几次而出现错误</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;*&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  96</span><br></pre></td></tr></table></figure><p></p><p><strong>结果输出</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost csplit]$ cat xx00 </span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br><span class="line">(base) [user@localhost csplit]$ cat xx01</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">(base) [user@localhost csplit]$ cat xx02</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>{INTEGER}</code>和<code>{*}</code>可以有效<strong>解决<code>/REGEXP/[OFFSET]</code>只会对第一次出现的pattern进行分割的问题</strong>，<strong>重复指定的次数</strong>或者<strong>任意多次</strong>的pattern来对文件进行分割，从而达到<strong>将文件从所有出现pattern的位置进行切割的目的</strong>；</p></div><hr><h3 id="REGEXP-OFFSET-逃过模式之前的行"><a href="#REGEXP-OFFSET-逃过模式之前的行" class="headerlink" title="%REGEXP%[OFFSET]-逃过模式之前的行"></a>%REGEXP%[OFFSET]-逃过模式之前的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过SERVER-2之前的行</span></span><br><span class="line"><span class="comment"># 这里剩下的部分会包含模式这一行</span></span><br><span class="line"><span class="comment"># 相当于把按模式分割的前面几个文件给删掉了</span></span><br><span class="line">csplit server.log %SERVER-2%</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat xx00</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-3</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><p>这个和前面的<code>/REGEXP/[OFFSET]</code>相同，都可以指定<code>[OFFSET]</code>偏移量。</p><hr><h2 id="csplit参数使用实例"><a href="#csplit参数使用实例" class="headerlink" title="csplit参数使用实例"></a>csplit参数使用实例</h2><h3 id="f-设置输出前缀"><a href="#f-设置输出前缀" class="headerlink" title="-f-设置输出前缀"></a>-f-设置输出前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出文件前缀为test</span></span><br><span class="line"><span class="comment"># 以SERVER-2为分割</span></span><br><span class="line">csplit server.log -f <span class="built_in">test</span> /SERVER-2/</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 16:09 test00</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 16:09 test01</span><br><span class="line"></span><br><span class="line">cat test00 </span><br><span class="line"><span class="comment"># 输出内容不包含匹配行</span></span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="b-设置输出文件名称格式"><a href="#b-设置输出文件名称格式" class="headerlink" title="-b-设置输出文件名称格式"></a>-b-设置输出文件名称格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置输出文件名格式之后加上.log后缀</span></span><br><span class="line"><span class="comment"># 设置文件名称等宽，并使用0填充 --&gt; 02d</span></span><br><span class="line">csplit server.log -f <span class="built_in">test</span> -b <span class="string">"%02d.log"</span> /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况是两位的数字后缀，并且指定输出格式一定要是02d，用0填充</span></span><br><span class="line"><span class="comment"># 如果不加0表示用0填充，那么会出现空格填充的情况</span></span><br><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:22 test00.log</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 18:22 test01.log</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-设置后缀数字数目"><a href="#n-设置后缀数字数目" class="headerlink" title="-n-设置后缀数字数目"></a>-n-设置后缀数字数目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csplit server.log -f <span class="built_in">test</span> -b <span class="string">"%03d.log"</span> -n 3 /SERVER-2/</span><br><span class="line">93</span><br><span class="line">189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:28 test000.log</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 18:28 test001.log</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="k-保留运行错误的结果文件"><a href="#k-保留运行错误的结果文件" class="headerlink" title="-k-保留运行错误的结果文件"></a>-k-保留运行错误的结果文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的这个示例</span></span><br><span class="line"><span class="comment"># 因为存在错误，所以不会得到结果文件</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上-k参数来避免这种情况</span></span><br><span class="line"><span class="comment"># 依然后提示错误信息</span></span><br><span class="line"><span class="comment"># 但是会得到能够正确分割的文件</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125; -k</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:33 xx00</span><br><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:33 xx01</span><br><span class="line">-rw-rw-r--. 1 user user  96 Apr 13 18:33 xx02</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="z-不输出空文件"><a href="#z-不输出空文件" class="headerlink" title="-z-不输出空文件"></a>-z-不输出空文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下会输出文件大小为0的文件</span></span><br><span class="line">csplit server.log /SERVER/</span><br><span class="line">  0</span><br><span class="line">  282</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-z参数就不会输出空文件</span></span><br><span class="line">csplit server.log /SERVER/ -z</span><br><span class="line">  282</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds1/csplit.htm" target="_blank" rel="noopener">csplit 命令</a></li><li><a href="http://man.linuxde.net/csplit" target="_blank" rel="noopener">csplit命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux常用的按照文件内容来对文件进行分割的命令csplit，前面学习的split主要是根据文件的外部信息进行的分割；主要学习了利用pattern模式分割以及参数使用；patern方面主要学习了&lt;code&gt;INTEGER&lt;/code&gt;、&lt;code&gt;/REGEXP/[OFFSET]&lt;/code&gt;、&lt;code&gt;{INTEGER}&lt;/code&gt;、&lt;code&gt;{*}&lt;/code&gt;以及&lt;code&gt;%REGEXP%[OFFSET]&lt;/code&gt;；参数主要学习了&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-z&lt;/code&gt;、&lt;code&gt;-k&lt;/code&gt;和&lt;code&gt;-s&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看CPU型号、内存、硬盘等信息</title>
    <link href="http://showteeth.tech/posts/9853.html"/>
    <id>http://showteeth.tech/posts/9853.html</id>
    <published>2019-04-12T03:33:53.000Z</published>
    <updated>2019-04-13T09:53:32.152Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习和总结了Linux中查看CPU型号、内存、硬盘等信息的命令，便于日常使用查询。</p></div><a id="more"></a><h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><p>CPU相关的信息都保存在<code>/proc/cpuinfo</code>文件中</p><h3 id="查看CPU个数"><a href="#查看CPU个数" class="headerlink" title="查看CPU个数"></a>查看CPU个数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="查看CPU核数"><a href="#查看CPU核数" class="headerlink" title="查看CPU核数"></a>查看CPU核数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">cpu cores: 6</span><br></pre></td></tr></table></figure><hr><h3 id="查看CPU型号"><a href="#查看CPU型号" class="headerlink" title="查看CPU型号"></a>查看CPU型号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">'model name'</span> |uniq</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz</span><br></pre></td></tr></table></figure><hr><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><p>内存信息保存在<code>/proc/meminfo</code>中</p><h3 id="查看内存大小"><a href="#查看内存大小" class="headerlink" title="查看内存大小"></a>查看内存大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo | grep MemTotal</span><br><span class="line"><span class="comment"># 输出内存大小，Kb为单位</span></span><br><span class="line"><span class="comment"># 大小为49G</span></span><br><span class="line">MemTotal:       49219420 kB</span><br></pre></td></tr></table></figure><hr><h3 id="查看内存条数"><a href="#查看内存条数" class="headerlink" title="查看内存条数"></a>查看内存条数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dmidecode |grep -A16 <span class="string">"Memory Device$"</span></span><br><span class="line"><span class="comment"># 实验室集群安装了6个8G的，还有8个卡槽没有安装内存条</span></span><br><span class="line">  Memory Device</span><br><span class="line">    Array Handle: 0x002F</span><br><span class="line">    Error Information Handle: Not Provided</span><br><span class="line">    Total Width: 72 bits</span><br><span class="line">    Data Width: 64 bits</span><br><span class="line">    Size: 8192 MB      <span class="comment"># 这里安装了一个8G的内存</span></span><br><span class="line">    Form Factor: DIMM</span><br><span class="line">    Set: None</span><br><span class="line">    Locator: DIMM1_CPU1</span><br><span class="line">    Bank Locator: Not Specified</span><br><span class="line">    Type: Other</span><br><span class="line">    Type Detail: Synchronous</span><br><span class="line">    Speed: 2400 MHz</span><br><span class="line">    Manufacturer: Undefined</span><br><span class="line">    Serial Number: 131087AA</span><br><span class="line">    Asset Tag: DIMM1_CPU1_AssetTag</span><br><span class="line">    Part Number: KHX2400C15/8G</span><br></pre></td></tr></table></figure><hr><h2 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h2><h3 id="查看硬盘大小"><a href="#查看硬盘大小" class="headerlink" title="查看硬盘大小"></a>查看硬盘大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l | grep Disk</span><br><span class="line"><span class="comment"># 输出的硬盘信息</span></span><br><span class="line">  Disk /dev/sda: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00097e63</span><br><span class="line">  Disk /dev/sdb: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00091a2b</span><br><span class="line">  Disk /dev/sdc: 4000.8 GB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00000000</span><br><span class="line">  Disk /dev/sdd: 2000.4 GB, 2000398934016 bytes, 3907029168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x4120a342</span><br><span class="line">  Disk /dev/mapper/centos-root: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">  Disk /dev/mapper/centos-swap: 8388 MB, 8388608000 bytes, 16384000 sectors</span><br><span class="line">  Disk /dev/mapper/centos-home: 1937.7 GB, 1937730699264 bytes, 3784630272 sectors</span><br></pre></td></tr></table></figure><hr><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><h3 id="查看Linux系统信息"><a href="#查看Linux系统信息" class="headerlink" title="查看Linux系统信息"></a>查看Linux系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">Linux localhost.localdomain 3.10.0-327.18.2.el7.x86_64 <span class="comment">#1 SMP Thu May 12 11:03:55 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/97157.htm" target="_blank" rel="noopener">Linux下查看CPU型号,内存大小,硬盘空间的命令(详解)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习和总结了Linux中查看CPU型号、内存、硬盘等信息的命令，便于日常使用查询。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>split-按大小分割文件</title>
    <link href="http://showteeth.tech/posts/41178.html"/>
    <id>http://showteeth.tech/posts/41178.html</id>
    <published>2019-04-11T14:37:37.000Z</published>
    <updated>2019-04-12T02:08:22.298Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux中用于按照<strong>指定的需求(大小、行数、文件数目)拆分文件的命令</strong><code>split</code>，是<code>cat</code>命令合并文件功能的反向操作；主要参数包括：<code>-l</code>、<code>-b(K、M、T，默认是bytes)</code>、<code>-d(--numeric-suffixes=num)</code>、<code>文件前缀</code>、<code>-a(默认为2)</code>、<code>--additional-suffix=str</code>、<code>-n(N、K/N、l/N、l/K/N)</code>、<code>-e</code>等参数；最后可以通过<code>md5sum</code>命令检查split之后cat命令合并得到的文件和原始文件相比<strong>是否完整</strong>。</p></div><a id="more"></a><h2 id="split简介"><a href="#split简介" class="headerlink" title="split简介"></a>split简介</h2><p><code>Linux split</code>命令可以将一个大文件分割成指定大小的很多个小文件，并且拆分速度非常的快，可以看成是<code>cat</code>命令合并文件功能的反操作，其主要<strong>特点</strong>：</p><ul><li>可以指定子文件的行数、大小以及子文件的数目</li><li>指定大小以及子文件数目(默认情况)会对一行甚至是一个单词的内容进行切割，指定子文件数目中可以读这种情况进行调整</li><li>指定的文件前缀名需要放在split文件之后，不然会报错，前缀默认为x</li><li>可以指定文件的后缀(数字、字符)以及后缀的数目，后缀默认是从aa开始递增的两位字符</li><li>可以文件添加统一的后缀(作为文件的拓展名)</li></ul><h2 id="split命令格式"><a href="#split命令格式" class="headerlink" title="split命令格式"></a>split命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  split [OPTION]... [INPUT [PREFIX]]</span><br></pre></td></tr></table></figure><ul><li>Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ..</li><li><strong>default size</strong> is 1000 lines</li><li><strong>default PREFIX</strong> is ‘x’</li><li><strong>With no INPU</strong>T, or when INPUT is <code>-</code>, read standard input</li></ul><hr><h2 id="split参数"><a href="#split参数" class="headerlink" title="split参数"></a>split参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-l</code></td><td><code>--lines=NUMBER</code></td><td>指定每多少行切成一个小文件</td></tr><tr><td><code>-b</code></td><td><code>--bytes=SIZE</code></td><td>指定每多少字节切成一个小文件，单位可以是K、M、G</td></tr><tr><td><code>-d</code></td><td><code>--numeric-suffixes[=FROM]</code></td><td>使用数字作为小文件名称的后缀，默认从0开始(使用from调节)</td></tr><tr><td></td><td><code>--additional-suffix=SUFFIX</code></td><td>小文件名称的后缀，默认从 aa 开始</td></tr><tr><td><code>-n</code></td><td><code>--number=CHUNKS</code></td><td>分得的文件(CHUNKS)数目</td></tr><tr><td><code>-a</code></td><td><code>--suffix-length=N</code></td><td>后缀长度，默认是2，也就是按 aa、ab、ac 这样的格式依次编号</td></tr><tr><td><code>-C</code></td><td><code>--line-bytes=SIZE</code></td><td>put at most SIZE bytes of lines per output file</td></tr><tr><td><code>-e</code></td><td><code>--elide-empty-files</code></td><td>在使用-n参数的时候不产生空的文件</td></tr><tr><td></td><td><code>--verbose</code></td><td>显示分割进度</td></tr></table><p><strong>CHUNKS</strong>:</p><table><tr><th width="15%">参数</th><th width="85%">说明</th></tr><tr><td><code>N</code></td><td>分割为N个文件</td></tr><tr><td><code>K/N</code></td><td>将N个文件中的第K个输出到标准输出</td></tr><tr><td><code>l/N</code></td><td><strong>在不分割行</strong>的情况下分割为N个文件</td></tr><tr><td><code>l/K/N</code></td><td>将<strong>在不分割行</strong>的情况下得到的N个文件中的第K个输出到标准输出</td></tr><tr><td><code>r/N</code></td><td>like 'l' but use round robin distribution</td></tr><tr><td><code>r/K/N</code></td><td>likewise but only output Kth of N to stdout</td></tr></table><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="l-指定每个文件的行数"><a href="#l-指定每个文件的行数" class="headerlink" title="-l-指定每个文件的行数"></a>-l-指定每个文件的行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件的行数</span></span><br><span class="line">wc -l test.txt </span><br><span class="line">  51 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个文件10行</span></span><br><span class="line">split -l 10 test.txt</span><br><span class="line">  <span class="comment"># 生成6个文件</span></span><br><span class="line">  <span class="comment"># 其中最后一个文件只有一行</span></span><br><span class="line">-rw-rw-r--. 1 user user 5779 Apr 12 00:10 test.txt</span><br><span class="line">-rw-rw-r--. 1 user user  338 Apr 12 00:12 xaa</span><br><span class="line">-rw-rw-r--. 1 user user 1900 Apr 12 00:12 xab</span><br><span class="line">-rw-rw-r--. 1 user user 1513 Apr 12 00:12 xac</span><br><span class="line">-rw-rw-r--. 1 user user 1523 Apr 12 00:12 xad</span><br><span class="line">-rw-rw-r--. 1 user user  432 Apr 12 00:12 xae</span><br><span class="line">-rw-rw-r--. 1 user user   73 Apr 12 00:12 xaf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="comment"># 空行也算行</span></span><br><span class="line"><span class="comment"># 换行算一行，不进行切割</span></span><br><span class="line">cat -n xac</span><br><span class="line">     1</span><br><span class="line">     2In particular, Anaconda Distribution contains re-distributable, run-time, shared-library files from the Intel(TM) Math Kernel Library (<span class="string">"MKL binaries"</span>). You are specifically authorized to use the MKL binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the MKL binaries with Anaconda Distribution or <span class="keyword">in</span> the conda package that contains them. Use and redistribution of the MKL binaries are subject to the licensing terms located at https://software.intel.com/en-us/license/intel-simplified-software-license. If needed, instructions <span class="keyword">for</span> removing the MKL binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line">     3</span><br><span class="line">     4Anaconda Distribution also contains cuDNN software binaries from NVIDIA Corporation (<span class="string">"cuDNN binaries"</span>). You are specifically authorized to use the cuDNN binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the cuDNN binaries with an Anaconda Distribution package that contains them. If needed, instructions <span class="keyword">for</span> removing the cuDNN binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line">     5</span><br><span class="line">     6</span><br><span class="line">     7Anaconda Distribution also contains Visual Studio Code software binaries from Microsoft Corporation (<span class="string">"VS Code"</span>). You are specifically authorized to use VS Code with your installation of Anaconda Distribution. Use of VS Code is subject to the licensing terms located at https://code.visualstudio.com/License.</span><br><span class="line">     8</span><br><span class="line">     9Cryptography Notice</span><br><span class="line">    10===================</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>不足指定行数的也放在一个文件中</li><li>空行也算行</li><li>一行文本太长换行的话算一行，不进行切割</li></ul></div><hr><h3 id="b-指定分割文件大小"><a href="#b-指定分割文件大小" class="headerlink" title="-b-指定分割文件大小"></a>-b-指定分割文件大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认单位是b</span></span><br><span class="line">split -b 1000 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 可以和前面-l的输出结果对比</span></span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xab</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xac</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xad</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:35 xaf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看输出文件内容</span></span><br><span class="line"><span class="comment"># 会对一行的内容甚至的一个单词进行切割</span></span><br><span class="line">cat xab</span><br><span class="line">  DING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANACONDA, INC. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"></span><br><span class="line">  Notice of Third Party Software Licenses</span><br><span class="line">  =======================================</span><br><span class="line"></span><br><span class="line">  Anaconda Distribution contains open <span class="built_in">source</span> software packages from third parties. These are available on an <span class="string">"as is"</span> basis and subject to their individual license agreements. These licenses are available <span class="keyword">in</span> Anaconda Distribution or at http://docs.anaconda.com/anaconda/pkg-docs. Any binary packages of thes</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>不同于<code>-l</code>参数会<strong>保留行的完整性</strong>，<code>-b</code>参数<strong>会对同一行甚至同一个单词进行切割</strong></li><li><code>-b</code>参数可以指定的单位包括<code>K</code>、<code>M</code>、<code>G</code>，<strong>默认是字节</strong></li></ul></div><hr><h3 id="指定文件名前缀"><a href="#指定文件名前缀" class="headerlink" title="指定文件名前缀"></a>指定文件名前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件的前缀需要放在split文件之后</span></span><br><span class="line"><span class="comment"># 不然会报错</span></span><br><span class="line">split <span class="built_in">test</span> -b 1000 test.txt</span><br><span class="line">  split: cannot open ‘<span class="built_in">test</span>’ <span class="keyword">for</span> reading: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到的文件的前缀为test</span></span><br><span class="line"><span class="comment"># 替换默认的前缀x</span></span><br><span class="line">split -b 1000 test.txt <span class="built_in">test</span></span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testab</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testac</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testad</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testae</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:38 testaf</span><br></pre></td></tr></table></figure><hr><h3 id="d-指定数字后缀"><a href="#d-指定数字后缀" class="headerlink" title="-d-指定数字后缀"></a>-d-指定数字后缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的后缀的aa开始的</span></span><br><span class="line"><span class="comment"># 这里指定以数字作为后缀</span></span><br><span class="line"><span class="comment"># 默认后缀从0开始</span></span><br><span class="line">split -b 1000 -d test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x00</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x01</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x02</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x03</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x04</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:45 x05</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置后缀从10开始</span></span><br><span class="line"><span class="comment"># 注意这里只能使用完整的参数形式，不能使用-d这种简写的</span></span><br><span class="line">split -b 1000 --numeric-suffixes=10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x10</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x11</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x12</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x13</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x14</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:49 x15</span><br></pre></td></tr></table></figure><hr><h3 id="a-设置后缀的长度"><a href="#a-设置后缀的长度" class="headerlink" title="-a-设置后缀的长度"></a>-a-设置后缀的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置数字后缀的长度为3</span></span><br><span class="line">split -b 1000 -a 3 -d test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x000</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x001</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x002</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x003</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x004</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:47 x005</span><br></pre></td></tr></table></figure><hr><h3 id="在文件名最后添加额外的后缀"><a href="#在文件名最后添加额外的后缀" class="headerlink" title="在文件名最后添加额外的后缀"></a>在文件名最后添加额外的后缀</h3><p>这里额外的后缀和前面的数字和默认字符串后缀不同，这个后缀是统一的(<strong>可以用来指定文件格式</strong>)，所有文件的都相同，而前面的数字和默认字符串后缀会随着文件数目而变化：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定额外的后缀为test</span></span><br><span class="line">split -b 1000 --numeric-suffixes=10 --additional-suffix=<span class="string">'.txt'</span>  test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x10.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x11.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x12.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x13.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x14.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 01:33 x15.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-设置文件的数目"><a href="#n-设置文件的数目" class="headerlink" title="-n-设置文件的数目"></a>-n-设置文件的数目</h3><h4 id="N-分割为N个文件"><a href="#N-分割为N个文件" class="headerlink" title="N-分割为N个文件"></a>N-分割为N个文件</h4><p><strong>以文件大小为依据平均分割为N个文件</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定分割的文件数目为10</span></span><br><span class="line"><span class="comment"># 注意和前面的-b、-l区分，这里的数目是固定的</span></span><br><span class="line"><span class="comment"># 每个文件的大小是相同的，最后一个文件可能大或者小</span></span><br><span class="line">split -n 10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xad</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xai</span><br><span class="line">  -rw-rw-r--. 1 user user  586 Apr 12 00:55 xaj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看其中一个文件内容，发现有些行被中间截断了</span></span><br><span class="line">cat xaf</span><br><span class="line">  n are available at http://www.anaconda.com.</span><br><span class="line"></span><br><span class="line">  Anaconda Distribution also contains cuDNN software binaries from NVIDIA Corporation (<span class="string">"cuDNN binaries"</span>). You are specifically authorized to use the cuDNN binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the cuDNN binaries with an Anaconda Distribution package that contains them. If needed, instructions <span class="keyword">for</span> removing the cuDNN binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Anaconda Distribution also contains Visual Studio Code softw</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>前面的<code>-l</code>、<code>-b</code>参数是按照<strong>指定行数或者大小来分割文件</strong>，<strong>文件数目不可控</strong>；而<code>-n</code>指定<strong>分割得到的文件数目</strong>，<strong>数目多少是可控的</strong>，并且<strong>除最后一个文件外，大小是相同的</strong>；</li><li><code>-n</code>参数会依据文件大小<strong>严格分割</strong>得到n个文件，<strong>可能会对同一行甚至是一个单词的内容进行切割</strong>，这个<strong>和<code>-b</code>参数类似</strong>;</li></ul></div><hr><h4 id="K-N-将N个文件中的第K个输出到标准输出"><a href="#K-N-将N个文件中的第K个输出到标准输出" class="headerlink" title="K/N-将N个文件中的第K个输出到标准输出"></a>K/N-将N个文件中的第K个输出到标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在屏幕输出分割得到的10个文件中的第1个</span></span><br><span class="line"><span class="comment"># 不会得到分割的文件</span></span><br><span class="line"><span class="comment"># 还是会对行进行分割</span></span><br><span class="line">split -n 1/10 test.txt </span><br><span class="line">  ===================================</span><br><span class="line">  Anaconda End User License Agreement</span><br><span class="line">  ===================================</span><br><span class="line"></span><br><span class="line">  Copyright 2015, Anaconda, Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">  Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of <span class="built_in">source</span> code must retain the above copyright notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright notice, this list of conditions and the</span><br></pre></td></tr></table></figure><hr><h4 id="l-N-在不分割行的情况下分割为N个文件"><a href="#l-N-在不分割行的情况下分割为N个文件" class="headerlink" title="l/N-在不分割行的情况下分割为N个文件"></a>l/N-在不分割行的情况下分割为N个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不分割行的情况下分割为10个文件</span></span><br><span class="line"><span class="comment"># 分割得到10个文件，保持了行的连续性</span></span><br><span class="line"><span class="comment"># 可能会得到大小为0的文件，不一定在最后</span></span><br><span class="line">split -n l/10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  674 Apr 12 01:21 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  940 Apr 12 01:21 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  624 Apr 12 01:21 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  691 Apr 12 01:21 xad</span><br><span class="line">  -rw-rw-r--. 1 user user    0 Apr 12 01:21 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  781 Apr 12 01:21 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  535 Apr 12 01:21 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  650 Apr 12 01:21 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  378 Apr 12 01:21 xai</span><br><span class="line">  -rw-rw-r--. 1 user user  506 Apr 12 01:21 xaj</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-n l/N</code>：在<strong>指定分割得到的文件数目</strong>的<strong>同时保留了每个文件中行的完整性</strong></p></div><hr><h4 id="e-在使用-n参数的时候不产生空的文件"><a href="#e-在使用-n参数的时候不产生空的文件" class="headerlink" title="-e-在使用-n参数的时候不产生空的文件"></a>-e-在使用-n参数的时候不产生空的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不输出空的文件</span></span><br><span class="line"><span class="comment"># 对比前面的-n l/10，这里不产生空的文件(前面的xae)</span></span><br><span class="line">split -n l/10 -e test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  674 Apr 12 01:30 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  940 Apr 12 01:30 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  624 Apr 12 01:30 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  691 Apr 12 01:30 xad</span><br><span class="line">  -rw-rw-r--. 1 user user  781 Apr 12 01:30 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  535 Apr 12 01:30 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  650 Apr 12 01:30 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  378 Apr 12 01:30 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  506 Apr 12 01:30 xai</span><br></pre></td></tr></table></figure><hr><h4 id="l-K-N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出"><a href="#l-K-N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出" class="headerlink" title="l/K/N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出"></a>l/K/N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类似于前面的K/N</span></span><br><span class="line"><span class="comment"># 直接在屏幕输出分割得到的10个文件中的第1个</span></span><br><span class="line"><span class="comment"># 只是保留了行的完整性</span></span><br><span class="line">split -n l/1/10 test.txt </span><br><span class="line">  ===================================</span><br><span class="line">  Anaconda End User License Agreement</span><br><span class="line">  ===================================</span><br><span class="line"></span><br><span class="line">  Copyright 2015, Anaconda, Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">  Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of <span class="built_in">source</span> code must retain the above copyright notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer <span class="keyword">in</span> the documentation and/or other materials provided with the distribution.</span><br></pre></td></tr></table></figure><hr><h3 id="cat合并并校验文件"><a href="#cat合并并校验文件" class="headerlink" title="cat合并并校验文件"></a>cat合并并校验文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先拆分为3个文件</span></span><br><span class="line">split -n 3 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1926 Apr 12 09:37 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1926 Apr 12 09:37 xab</span><br><span class="line">  -rw-rw-r--. 1 user user 1927 Apr 12 09:37 xac</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看原始的md5值</span></span><br><span class="line">md5sum test.txt </span><br><span class="line">  27272b6fb8e9e0b22f8f0f5afc6e1346  test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并文件</span></span><br><span class="line">cat xa&#123;a..c&#125; &gt;merged.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看合并后文件的md5值</span></span><br><span class="line">md5sum merged.txt </span><br><span class="line">  27272b6fb8e9e0b22f8f0f5afc6e1346  merged.txt</span><br></pre></td></tr></table></figure><div class="note info"><p>对<strong>split之后的文件</strong>进行<strong>cat操作得到的文件md5值和原始文件相同</strong></p></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/split.html" target="_blank" rel="noopener">split命令_Linux split命令：切割（拆分）文件</a></li><li></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了linux中用于按照&lt;strong&gt;指定的需求(大小、行数、文件数目)拆分文件的命令&lt;/strong&gt;&lt;code&gt;split&lt;/code&gt;，是&lt;code&gt;cat&lt;/code&gt;命令合并文件功能的反向操作；主要参数包括：&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-b(K、M、T，默认是bytes)&lt;/code&gt;、&lt;code&gt;-d(--numeric-suffixes=num)&lt;/code&gt;、&lt;code&gt;文件前缀&lt;/code&gt;、&lt;code&gt;-a(默认为2)&lt;/code&gt;、&lt;code&gt;--additional-suffix=str&lt;/code&gt;、&lt;code&gt;-n(N、K/N、l/N、l/K/N)&lt;/code&gt;、&lt;code&gt;-e&lt;/code&gt;等参数；最后可以通过&lt;code&gt;md5sum&lt;/code&gt;命令检查split之后cat命令合并得到的文件和原始文件相比&lt;strong&gt;是否完整&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>paste-合并文件</title>
    <link href="http://showteeth.tech/posts/22454.html"/>
    <id>http://showteeth.tech/posts/22454.html</id>
    <published>2019-04-11T13:41:51.000Z</published>
    <updated>2019-04-14T00:51:25.154Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中常用的<strong>合并文件命令</strong><code>paste</code>，主要参数包括<code>-s</code>、<code>-d</code>，这个参数与<code>cut</code>命令的功能相反；<strong>与<code>cat</code>命令相比</strong>，<code>paste</code><strong>默认按行合并</strong>，如果指定<code>-s</code>参数之后进行<strong>先在一个文件内部按指定的分隔符将所有的行合并</strong>，<strong>然后在所有的文件之间按列合并</strong>。</p></div><a id="more"></a><h2 id="paste简介"><a href="#paste简介" class="headerlink" title="paste简介"></a>paste简介</h2><p><code>paste</code>命令主要用来将多个文件的内容合并(<strong>按行或者按列合并</strong>)，与<code>cut</code>命令完成的功能刚好相反。<br>特点：</p><ul><li>可以指定分隔符</li><li>可以先在一个文件内部按指定的分隔符将所有的行合并，然后在所有的文件之间按列合并</li><li>注意与cat命令合并文件的区别：<ul><li>cat只能按列合并文件</li><li>paste默认按行合并，如果指定-s参数之后进行先在一个文件内部按指定的分隔符将所有的行合并，然后在所有的文件之间按列合并</li></ul></li></ul><h2 id="paste命令格式"><a href="#paste命令格式" class="headerlink" title="paste命令格式"></a>paste命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  paste [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p>Write lines consisting of the sequentially corresponding lines from each FILE, separated by TABs, to standard output.<br>With <strong>no FILE</strong>, or when FILE is <code>-</code>, <strong>read standard input</strong>.</p><hr><h2 id="paste命令参数"><a href="#paste命令参数" class="headerlink" title="paste命令参数"></a>paste命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-d</code></td><td><code>--delimiters=LIST</code></td><td>设置分割字符，默认为tab</td></tr><tr><td><code>-s</code></td><td><code>--serial</code></td><td>先在文件内部按指定的分隔符合并行，然后所有的文件之间按列合并</td></tr></table><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat test1.txt<br>1<br>2<br>3</p></blockquote><blockquote><p>cat test2.txt<br>a<br>b<br>c</p></blockquote><blockquote><p>cat test3.txt<br>d<br>e<br>f<br>g</p></blockquote><blockquote><p>cat test4.txt<br>a<br>c<br>b</p></blockquote><hr><h3 id="默认连接文件"><a href="#默认连接文件" class="headerlink" title="默认连接文件"></a>默认连接文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下以tab分隔两个不同的文件内容</span></span><br><span class="line">paste test1.txt test2.txt |cat -T</span><br><span class="line"><span class="comment"># cat -T显示tab为^I</span></span><br><span class="line">  1^Ia</span><br><span class="line">  2^Ib</span><br><span class="line">  3^Ic</span><br></pre></td></tr></table></figure><hr><h3 id="d-设置分隔符"><a href="#d-设置分隔符" class="headerlink" title="-d-设置分隔符"></a>-d-设置分隔符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置分隔符为$</span></span><br><span class="line">paste -d <span class="string">'$'</span> test1.txt test2.txt</span><br><span class="line">1<span class="variable">$a</span></span><br><span class="line">2<span class="variable">$b</span></span><br><span class="line">3<span class="variable">$c</span></span><br></pre></td></tr></table></figure><hr><h3 id="s-设置按列合并"><a href="#s-设置按列合并" class="headerlink" title="-s-设置按列合并"></a>-s-设置按列合并</h3><p><code>-s</code>参数相当于<strong>先将每一个文件内部按照指定的分隔符进行合并</strong>，然后<strong>再和另一个文件按列进行合并</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paste -d <span class="string">'$'</span> -s test1.txt test2.txt </span><br><span class="line">  <span class="comment"># 先在文件内部合并为一行，然后两个文件按列合并</span></span><br><span class="line">  1<span class="variable">$2</span><span class="variable">$3</span></span><br><span class="line">  a<span class="variable">$b</span><span class="variable">$c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独的一个文件内部合并为一行</span></span><br><span class="line">paste -d <span class="string">'$'</span> -s test1.txt </span><br><span class="line">1<span class="variable">$2</span><span class="variable">$3</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="行数不同"><a href="#行数不同" class="headerlink" title="行数不同"></a>行数不同</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于合并的文件如果行数不同，则会空行</span></span><br><span class="line"><span class="comment"># 不会报错</span></span><br><span class="line">paste test1.txt test3.txt </span><br><span class="line">  1d</span><br><span class="line">  2e</span><br><span class="line">  3f</span><br><span class="line">    g</span><br></pre></td></tr></table></figure><hr><h3 id="文件未排序"><a href="#文件未排序" class="headerlink" title="文件未排序"></a>文件未排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paste test1.txt test4.txt </span><br><span class="line"><span class="comment"># 文件未排序也能正常合并</span></span><br><span class="line">  1a</span><br><span class="line">  2c</span><br><span class="line">  3b</span><br></pre></td></tr></table></figure><hr><h3 id="cat-按列合并"><a href="#cat-按列合并" class="headerlink" title="cat-按列合并"></a>cat-按列合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt test2.txt </span><br><span class="line"><span class="comment"># 按列合并</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br></pre></td></tr></table></figure><hr><h3 id="标准输出的特殊用法"><a href="#标准输出的特殊用法" class="headerlink" title="标准输出的特殊用法"></a>标准输出的特殊用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[user@localhost paste]$ cat test1.txt |paste -</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"><span class="comment"># 一个-表示从前面读取一行用于合并</span></span><br><span class="line"><span class="comment"># 可以将一行看做一个文件</span></span><br><span class="line">[user@localhost paste]$ cat test1.txt |paste - -</span><br><span class="line">12</span><br><span class="line">3</span><br><span class="line">[user@localhost paste]$ cat test1.txt |paste - - -</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中常用的&lt;strong&gt;合并文件命令&lt;/strong&gt;&lt;code&gt;paste&lt;/code&gt;，主要参数包括&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-d&lt;/code&gt;，这个参数与&lt;code&gt;cut&lt;/code&gt;命令的功能相反；&lt;strong&gt;与&lt;code&gt;cat&lt;/code&gt;命令相比&lt;/strong&gt;，&lt;code&gt;paste&lt;/code&gt;&lt;strong&gt;默认按行合并&lt;/strong&gt;，如果指定&lt;code&gt;-s&lt;/code&gt;参数之后进行&lt;strong&gt;先在一个文件内部按指定的分隔符将所有的行合并&lt;/strong&gt;，&lt;strong&gt;然后在所有的文件之间按列合并&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Windows和Linux下使用tree命令</title>
    <link href="http://showteeth.tech/posts/15686.html"/>
    <id>http://showteeth.tech/posts/15686.html</id>
    <published>2019-04-07T12:38:56.000Z</published>
    <updated>2019-04-10T06:47:40.885Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><code>tree</code>命令可以<strong>以树的形式显示文件夹的结构</strong>，便于观察，这里记录了在<code>windows</code>和<code>linux</code>平台上安装和使用<code>tree</code>命令的过程。</p></div><a id="more"></a><h2 id="windows下简便用法"><a href="#windows下简便用法" class="headerlink" title="windows下简便用法"></a>windows下简便用法</h2><p>在<code>git bash</code>中使用命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd //c tree</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文件夹 PATH 列表</span><br><span class="line">卷序列号为 AC83-2977</span><br><span class="line">D:.</span><br><span class="line">├─docs</span><br><span class="line">│  ├─css</span><br><span class="line">│  ├─img</span><br><span class="line">│  ├─js</span><br><span class="line">│  ├─projects</span><br><span class="line">│  ├─resource</span><br><span class="line">│  └─software</span><br><span class="line">└─site</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：这个在<code>cmd</code>中<strong>不能使用</strong></p></div><hr><h2 id="windows下安装使用"><a href="#windows下安装使用" class="headerlink" title="windows下安装使用"></a>windows下安装使用</h2><ul><li><p>从<a href="http://gnuwin32.sourceforge.net/packages/tree.htm" target="_blank" rel="noopener">这个链接</a>中下载<a href="http://downloads.sourceforge.net/gnuwin32/tree-1.5.2.2-setup.exe" target="_blank" rel="noopener">tree-1.5.2.2-setup.exe</a>文件，然后进行常规的<strong>安装步骤</strong>，<strong>得到</strong><code>tree.exe</code>文件;</p></li><li><p>然后将<strong>安装得到</strong>的<code>tree.exe</code>文件<strong>复制到Git的安装目录</strong>：<code>C:\Program Files\Git\usr\bin</code>，注意<strong>一定要是usr下的这个目录</strong>，<strong>不能直接放在git下的bin目录</strong>;</p></li><li><p>最后在<code>git bash</code>下就可以使用tree命令了，<code>cmd</code>下在执行tree-1.5.2.2-setup.exe安装之后就可以使用，<strong>不过使用局限较大，只有两个参数，默认显示所有的文件夹，可以使用<code>/F</code>显示所有的文件</strong>:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd下使用</span></span><br><span class="line"><span class="comment"># 不加参数，直接指定文件夹</span></span><br><span class="line">tree chIA-drop</span><br><span class="line">  文件夹 PATH 列表</span><br><span class="line">  卷序列号为 CC05-4904</span><br><span class="line">  C:\USERS\user\DESKTOP\CHIA-DROP</span><br><span class="line">  └─scripts</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd下查看命令帮助</span></span><br><span class="line">tree /?</span><br><span class="line">以图形显示驱动器或路径的文件夹结构。</span><br><span class="line"></span><br><span class="line">TREE [drive:][path] [/F] [/A]</span><br><span class="line"><span class="comment"># 可以发现cmd下只有两个参数</span></span><br><span class="line">   /F   显示每个文件夹中文件的名称。</span><br><span class="line">   /A   使用 ASCII 字符，而不使用扩展字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># git bash下可以正常使用</span></span><br></pre></td></tr></table></figure><hr><h2 id="Linux下安装使用"><a href="#Linux下安装使用" class="headerlink" title="Linux下安装使用"></a>Linux下安装使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要管理员权限</span></span><br><span class="line">yum install tree -y</span><br></pre></td></tr></table></figure><hr><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree命令行参数：</span><br><span class="line"></span><br><span class="line">-a 显示所有文件和目录。</span><br><span class="line">-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span><br><span class="line">-C 在文件和目录清单加上色彩，便于区分各种类型。</span><br><span class="line">-d 显示目录名称而非内容。</span><br><span class="line">-D 列出文件或目录的更改时间。</span><br><span class="line">-f 在每个文件或目录之前，显示完整的相对路径名称。</span><br><span class="line">-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"="</span>,<span class="string">"@"</span>,<span class="string">"|"</span>号。</span><br><span class="line">-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span><br><span class="line">-i 不以阶梯状列出文件或目录名称。</span><br><span class="line">-I 不显示符合范本样式的文件或目录名称。</span><br><span class="line">-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span><br><span class="line">-n 不在文件和目录清单加上色彩。</span><br><span class="line">-N 直接列出文件和目录名称，包括控制字符。</span><br><span class="line">-p 列出权限标示。</span><br><span class="line">-P 只显示符合范本样式的文件或目录名称。</span><br><span class="line">-q 用<span class="string">"?"</span>号取代控制字符，列出文件和目录名称。</span><br><span class="line">-s 列出文件或目录大小。</span><br><span class="line">-t 用文件和目录的更改时间排序。</span><br><span class="line">-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span><br><span class="line">-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.computerhope.com/unix/tree.htm" target="_blank" rel="noopener">Linux tree command</a></li><li><a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener">tree(1) - Linux man page</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;tree&lt;/code&gt;命令可以&lt;strong&gt;以树的形式显示文件夹的结构&lt;/strong&gt;，便于观察，这里记录了在&lt;code&gt;windows&lt;/code&gt;和&lt;code&gt;linux&lt;/code&gt;平台上安装和使用&lt;code&gt;tree&lt;/code&gt;命令的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tree" scheme="http://showteeth.tech/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="http://showteeth.tech/posts/43102.html"/>
    <id>http://showteeth.tech/posts/43102.html</id>
    <published>2019-04-05T04:05:20.000Z</published>
    <updated>2019-04-05T10:29:55.173Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了<strong>使用xx-net进行科学上网的过程，包括安装、配置以及在使用中遇到的问题和解决</strong>；最后采取的科学上网策略是在蓝灯流量没使用完之前<strong>先使用蓝灯</strong>，蓝灯流量用完之后<strong>再使用xx-net</strong>。</p></div><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>XX-net</strong>：</p><ul><li><strong>下载地址</strong>：<a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="noopener">地址</a></li><li><strong>使用chrome浏览器的配置</strong>：<a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">Chrome</a></li></ul><p><strong>优点</strong>：</p><ul><li><strong>免费</strong></li><li>操作简单</li><li><strong>速度还可以</strong></li><li><strong>比较稳定</strong></li></ul><p><strong>蓝灯</strong>：</p><ul><li>下载地址：<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">地址</a></li><li><strong>优点</strong>：<ul><li>稳定</li><li>速度很快</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>免费</strong>的只有500M流量每个月</li><li><strong>专业版</strong>的每年要差不多180RMB(好贵。。。)</li></ul></li></ul><div class="note info"><p>所以可以<strong>先使用蓝灯(快)</strong>啊，然后等蓝灯<strong>流量用完之后再使用xx-net(免费、慢)</strong>，感觉自己有点小机灵~~~~</p></div><p>接下来<strong>主要介绍自己安装配置xx-net的步骤和遇到的问题</strong>，<strong>蓝灯的使用非常简单，直接下载安装就可以使用了</strong>。</p><hr><h2 id="安装配置过程"><a href="#安装配置过程" class="headerlink" title="安装配置过程"></a>安装配置过程</h2><h3 id="运行start-bat"><a href="#运行start-bat" class="headerlink" title="运行start.bat"></a>运行start.bat</h3><p>通过执行start.bat来完成xx-net的相关配置，我在这一步遇到了<code>运行之后浏览器不能上网，并且出现错误</code>，具体的解决方案见出现的问题及解决章节。</p><p>正常运行完成之后就会得到一个<strong>XX-NET的快捷方式</strong>，以后只用<strong>双击这个快捷方式</strong>就可以运行xx-net。</p><hr><h3 id="设置ipv6"><a href="#设置ipv6" class="headerlink" title="设置ipv6"></a>设置ipv6</h3><p>按照xx-net的说明，其主要有<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener"><code>GAE_proxy</code>和<code>X-Tunnel</code></a>，其中的<strong>GAE_proxy是免费</strong>的，有免费的当然使用免费的呀，但是其需要<code>开启IPV6</code>，可以按照官方给定的教程来来开启，官方提供了<a href="https://github.com/XX-net/XX-Net/wiki/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFIPv6" target="_blank" rel="noopener">mac、windows(7、10)、Linux的不同开启说明</a>，我这里选择了<a href="https://github.com/XX-net/XX-Net/wiki/IPv6-Win10" target="_blank" rel="noopener">win10教程</a>，其中有个简单的开启方法：运行<code>code\default\gae_proxy\local\ipv6_tunnel</code>目录下的<code>enable_ipv6.bat</code>文件即可开启，当然<strong>也可以手动开启</strong>，具体按照上面的教程。</p><hr><h3 id="设置自动代理"><a href="#设置自动代理" class="headerlink" title="设置自动代理"></a>设置自动代理</h3><p>ipv6开启之后再按照<a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">官方设置代理教程</a>的简单方法就可以访问谷歌等国外网站，但是<strong>这的缺点是</strong>：<strong>访问国内网站(不用科学上网的网站)也会很慢</strong>，这个时候就可以<strong>使用谷歌的浏览器插件来进行自动代理切换</strong>，这个在官方的设置代理教程中也有给出。</p><p><a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8#%E6%96%B9%E6%A1%88%E4%BA%8C%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E5%88%87%E6%8D%A2%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener">具体步骤</a></p><ul><li>建议在谷歌浏览器插件中下载安装<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a></li></ul><hr><h2 id="出现的问题以及解决"><a href="#出现的问题以及解决" class="headerlink" title="出现的问题以及解决"></a>出现的问题以及解决</h2><h3 id="启动start-bat之后浏览器不能上网，并且出现错误"><a href="#启动start-bat之后浏览器不能上网，并且出现错误" class="headerlink" title="启动start.bat之后浏览器不能上网，并且出现错误"></a>启动start.bat之后浏览器不能上网，并且出现错误</h3><p>错误信息如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/xx-net错误.png" alt="xx-net错误.png"></p><ul><li>首先，<strong>解决浏览器不能上网</strong>：chrome浏览器设置—&gt;高级设置—&gt;系统(打开代理设置)—&gt;局域网(LAN)设置按下图修改</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/xx-net不能上网.png" alt="xx-net不能上网.png"></p><ul><li><p>接下来，<strong>修改xx-net配置文件</strong>：<code>XX-Net-3.13.1\data\launcher\config.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules:</span><br><span class="line">  gae_proxy: &#123;auto_start: 1&#125;</span><br><span class="line">  launcher: &#123;allow_remote_connect: 0, control_port: 8085, last_run_version: 3.13.1,</span><br><span class="line">    proxy: pac&#125;</span><br><span class="line">  smart_router: &#123;auto_start: 1&#125;</span><br><span class="line">  <span class="comment"># 将这里的1改为0</span></span><br><span class="line">  x_tunnel: &#123;auto_start: 1&#125;</span><br><span class="line">update: &#123;last_path: <span class="string">'C:\Users\user\Desktop\XX-Net-3.13.1\XX-Net-3.13.1\code\default\launcher'</span>,</span><br><span class="line">  postUpdateStat: noChange, uuid: a58ace84-79fb-4dd5-bcc8-8c36e7cde706&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>然后再次执行start.bat即可</strong></p></li></ul><hr><h2 id="其他工具和方法"><a href="#其他工具和方法" class="headerlink" title="其他工具和方法"></a>其他工具和方法</h2><ul><li>youtube上的这个视频介绍了一种使用<strong>shadowsocks</strong>的方法，使用免费的ip和密码来实现翻墙，具体的<a href="https://www.youtube.com/watch?v=D81vP_o0-6o" target="_blank" rel="noopener">视频链接</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录了&lt;strong&gt;使用xx-net进行科学上网的过程，包括安装、配置以及在使用中遇到的问题和解决&lt;/strong&gt;；最后采取的科学上网策略是在蓝灯流量没使用完之前&lt;strong&gt;先使用蓝灯&lt;/strong&gt;，蓝灯流量用完之后&lt;strong&gt;再使用xx-net&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之subprocess-子进程管理</title>
    <link href="http://showteeth.tech/posts/57519.html"/>
    <id>http://showteeth.tech/posts/57519.html</id>
    <published>2019-04-04T00:57:21.000Z</published>
    <updated>2019-04-04T10:02:44.740Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python常用模块<code>subprocess</code>，这是一个<strong>子进程管理的模块</strong>，用来<strong>在Python代码中执行操作系统级别的命令</strong>(如linux下的命令行命令)；主要学习了其中的两大API：<code>subprocess.run()</code>和<code>subprocess.Popen()</code>，学习了如何<strong>传递要执行的命令</strong>、如何<strong>获取命令的退出状态码(returncode)</strong>、<strong>输出(stdout)</strong>、<strong>错误(stderr)</strong>以及<strong>如何与进程交互</strong>等。</p></div><a id="more"></a><h2 id="subprocess模块简介"><a href="#subprocess模块简介" class="headerlink" title="subprocess模块简介"></a>subprocess模块简介</h2><p><code>subprocess</code>模块主要用于<strong>创建</strong>子进程，并<strong>连接它们的输入、输出和错误管道</strong>，<strong>获取它们的返回状态</strong>。通俗地说就是通过这个模块，你可以<strong>在Python的代码里执行操作系统级别的命令</strong>，比如<code>ipconfig</code>、<code>du -sh</code>等等。<code>subprocess</code>模块替代了一些老的模块(<code>os</code>模块)和函数，比如：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system</span><br><span class="line">os.spawn*</span><br></pre></td></tr></table></figure><p></p><p><code>subprocess</code>过去版本中的<code>call()</code>，<code>check_call()</code>和<code>check_output()</code>已经被<code>run()</code>方法取代了，<code>run()</code>方法为3.5版本新增。</p><p><strong>大多数情况下</strong>，<strong>推荐使用<code>run()</code>方法调用子进程，执行操作系统命令</strong>。在<strong>更高级</strong>的使用场景，你还可以使用<code>Popen</code>接口。<strong>其实run()方法在底层调用的就是Popen接口。</strong></p><hr><h2 id="运行外部命令-subprocess-run"><a href="#运行外部命令-subprocess-run" class="headerlink" title="运行外部命令-subprocess.run()"></a>运行外部命令-subprocess.run()</h2><h3 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.run(args, *, stdin=<span class="keyword">None</span>, input=<span class="keyword">None</span>,\</span><br><span class="line">               stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, shell=<span class="keyword">False</span>, \</span><br><span class="line">               timeout=<span class="keyword">None</span>, check=<span class="keyword">False</span>, \</span><br><span class="line">               encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>执行<code>args</code>参数所表示的命令，等待命令结束，并返回一个<code>CompletedProcess</code>实例，可以获取其属性的值。</p><hr><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>args</code>：表示<strong>要执行的命令</strong>，必须是<strong>一个字符串</strong>或者<strong>字符串参数列表</strong>；<strong>推荐使用字符串列表</strong>的形式，这样可以处理任何必要的转义和引用参数(例如，允许文件名中的空格)，如果传递<strong>单个字符串</strong>，则<code>shell</code>必须为True，<strong>或者</strong>字符串必须简单地命名要执行的程序而不指定任何参数</li><li><code>stdin</code>、<code>stdout</code>和<code>stderr</code>：<strong>子进程的标准输入</strong>、<strong>输出</strong>和<strong>错误</strong>；其值可以是：<ul><li><code>subprocess.PIPE</code>：表示为子进程创建新的管道</li><li><code>subprocess.DEVNULL</code>：表示使用<code>os.devnull</code>，类似于Linux下的/dev/nulls</li><li><strong>一个已经存在的文件描述符</strong></li><li><strong>已经打开的文件对象</strong></li><li><strong>None</strong>，这是<strong>默认的设置</strong>，表示什么都不做，结果输出到父进程上(如控制台)</li><li>另外，<code>stderr</code>可以合并到<code>stdout</code>里一起输出</li></ul></li><li><code>timeout</code>：<strong>设置命令超时时间</strong>；如果<strong>命令执行时间超时</strong>，<strong>子进程将被杀死</strong>，并弹出<code>TimeoutExpired</code>异常</li><li><code>check</code>：如果该参数设置为<code>True</code>，并且进程<strong>退出状态码不是0</strong>，则弹出<code>CalledProcessError</code>异常</li><li><code>encoding</code>：如果<strong>指定了该参数</strong>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>可以接收或输出<strong>字符串</strong>数据，并以该编码方式编码，<strong>否则只接收或输出bytes类</strong>型的数据</li><li><code>shell</code>：如果该参数为True，将<strong>通过操作系统的shell执行指定的命令</strong></li></ul><div class="note info"><p>关于<a href="https://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">文件描述符和文件对象的区别</a>：</p><ul><li><strong>文件描述符</strong>是Linux内核为了<strong>高效管理已被打开的文件或其他输入输出资源所创建的索引</strong>，其是一个非负整数(通常是小整数)，<strong>用于指代被打开的文件或其他输入输出资源</strong>，<strong>所有执行I/O操作的系统调用都通过文件描述符</strong>；常见的，<strong>0(标准输入)</strong>、<strong>1(标准输出)</strong>、<strong>2(标准错误输出)</strong>都是文件描述符(程序开始时这三个就已经存在，然后打开的第一个文件的文件描述符就是3)。(In <strong>Unix and related</strong> computer operating systems, a <strong>file descriptor (FD, less frequently fildes)</strong> is an abstract indicator (handle) <strong>used to access a file</strong> or <strong>other input/output resource</strong>, such as a pipe or network socket.)</li><li><strong>每一个文件描述符会与一个打开文件相对应</strong>，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为<strong>每一个进程</strong>维护了一个<strong>文件描述符表</strong>，该表的<strong>值都是从0开始的</strong>，所以<strong>在不同的进程中你会看到相同的文件描述符</strong>，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。</li><li><strong>文件对象</strong>是在文件被打开时创建的一个<code>file</code>结构组成，Python的<code>open()</code>方法就是打开并创建一个文件对象</li></ul></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="args参数使用-字符串和字符串列表"><a href="#args参数使用-字符串和字符串列表" class="headerlink" title="args参数使用-字符串和字符串列表"></a>args参数使用-字符串和字符串列表</h4><p><code>args</code>参数表示<strong>要执行的命令</strong>，必须是<strong>一个字符串</strong>或者<strong>字符串参数列表</strong>；<strong>推荐使用字符串列表</strong>的形式，这样可以<strong>避免转义以及其他会被 shell 解析的特殊字符</strong>，如果传递<strong>单个字符串</strong>，则<code>shell</code>必须为True，<strong>或者</strong>字符串必须简单地命名要执行的程序而不指定任何参数:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单个字符串</span></span><br><span class="line">subprocess.run(<span class="string">"ls"</span>)</span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls'</span>, returncode=<span class="number">0</span>)</span><br><span class="line">subprocess.run(<span class="string">'ls'</span>)</span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls'</span>, returncode=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 当单个字符串中间有空格时会出错</span></span><br><span class="line"><span class="comment"># 这样会导致命令不能传递参数</span></span><br><span class="line">subprocess.run(<span class="string">'ls -l'</span>) <span class="keyword">or</span> subprocess.run(<span class="string">"ls -l"</span>)</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">472</span>, <span class="keyword">in</span> run</span><br><span class="line">      <span class="keyword">with</span> Popen(*popenargs, **kwargs) <span class="keyword">as</span> process:</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">775</span>, <span class="keyword">in</span> __init__</span><br><span class="line">      restore_signals, start_new_session)</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">1522</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">      <span class="keyword">raise</span> child_exception_type(errno_num, err_msg, err_filename)</span><br><span class="line">  FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'ls -l'</span>: <span class="string">'ls -l'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单个字符串传递参数，并且制定shell=True</span></span><br><span class="line"><span class="comment"># 就可以传递参数了</span></span><br><span class="line">subprocess.run(<span class="string">"ls -l"</span>,shell=<span class="keyword">True</span>)</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls -l'</span>, returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用的是字符串列表，针对上面不能传递参数的行为就可以改善</span></span><br><span class="line"><span class="comment"># 避免转义引号以及其他会被 shell 解析的特殊字符</span></span><br><span class="line"><span class="comment"># 如果需要传递参数不需要指定shell=True</span></span><br><span class="line">subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>])</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-l'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在使用字符串列表之后还指定了shell=True</span></span><br><span class="line"><span class="comment"># 只会执行字符串列表的第一个</span></span><br><span class="line"><span class="comment"># 字符串列表剩余部分会被舍弃</span></span><br><span class="line">subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>],shell=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 只输出了ls的结果</span></span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-l'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的返回结果都是CompletedProcess 实例，包含进程退出码以及输出等信息</span></span><br><span class="line"><span class="comment"># 可以通过属性的方式获取其值</span></span><br><span class="line">test=subprocess.run(<span class="string">"ls -l"</span>,shell=<span class="keyword">True</span>)</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line"><span class="comment"># 获取命令的退出状态码</span></span><br><span class="line">test.returncode</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>总结一下args参数的用法：</p><ul><li>如果命令是<strong>字符串</strong>，并且<strong>中间存在空格(给命令传递了参数)</strong>，<strong>必须</strong>加上参数<code>shell=True</code>，不然运行会出错，<strong>或者</strong>就<strong>是运行不加参数的命令(命令不能带空格)</strong></li><li>命令是<strong>字符串列表</strong>时，<strong>可以使用带参数的命令</strong>，这个时候就<strong>不能添加参数</strong><code>shell=True</code>，如果加上了<strong>不会出错</strong>，但是<strong>参数就会失效，只会运行单独的命令</strong></li><li>在<strong>不加</strong><code>shell=True</code>参数运行命令时，<strong>字符串不能存在空格(如<code>[&quot;ls&quot; &quot;-l &quot;]</code>、<code>&quot;ls &quot;</code>)</strong>，运行会报错</li><li>以上均为linux上的情况，<strong>windows下使用更加随意</strong>，<code>subprocess.run(&quot;ls -l&quot;)</code>、<code>subprocess.run(&quot;ls -l&quot;,shell=True)</code>、<code>subprocess.run([&quot;ls&quot;,&quot;-l&quot;])</code>、<code>subprocess.run([&quot;ls&quot;,&quot;-l&quot;],shell=True)</code><strong>运行结果都是一样的</strong>，都是<strong>正确</strong>答案。</li></ul></div><hr><h4 id="stdin、stdout和stderr-控制子进程的输入、输出和错误"><a href="#stdin、stdout和stderr-控制子进程的输入、输出和错误" class="headerlink" title="stdin、stdout和stderr-控制子进程的输入、输出和错误"></a>stdin、stdout和stderr-控制子进程的输入、输出和错误</h4><p><code>stdin</code>、<code>stdout</code>和<code>stderr</code>：<strong>子进程的标准输入</strong>、<strong>输出</strong>和<strong>错误</strong>；其值可以是：</p><ul><li><code>subprocess.PIPE</code>：表示为子进程创建新的管道</li><li><code>subprocess.DEVNULL</code>：表示使用<code>os.devnull</code></li><li><strong>一个已经存在的文件描述符</strong></li><li><strong>已经打开的文件对象</strong></li><li><strong>None</strong>，这是<strong>默认的设置</strong>，表示什么都不做，结果输出到父进程上</li><li>另外，<code>stderr</code>可以合并到<code>stdout</code>里一起输出</li></ul><p>默认情况下，由 <code>run()</code> 启动的进程的<strong>标准输入输出渠道绑定在了父进程上</strong>，那就意味着<strong>调用程序不能捕获命令的输出(前面实例中直接输出在控制台上)</strong>，给 <code>stdout</code> 和 <code>stderr</code> 参数传递 <code>PIPE</code> 可以捕获输出用于后续处理:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子进程创建新的管道</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE)</span><br><span class="line">completed</span><br><span class="line">  <span class="comment"># 看到返回的这个实例中间的stdout中有结果</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-1'</span>], returncode=<span class="number">0</span>, stdout=<span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不创建管道作为对比</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>])</span><br><span class="line">  test1.txt</span><br><span class="line">  test2.txt</span><br><span class="line">  test3.txt</span><br><span class="line">  test4.txt</span><br><span class="line">  test5.txt</span><br><span class="line">completed</span><br><span class="line">  <span class="comment"># 这个返回的实例中不包含结果，结果被输出在上面的屏幕上</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-1'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要输出子进程的返回值</span></span><br><span class="line"><span class="comment"># 同样是通过获取属性的值</span></span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 可以看到返回的结果是byte类型的</span></span><br><span class="line">  <span class="comment"># 这是以为我们没有设置encoding参数</span></span><br><span class="line">  <span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用utf-8进行解码</span></span><br><span class="line">completed.stdout.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接设置encoding参数就不用进行decode操作</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 直接返回字符串，不用进行decode操作</span></span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="stdin-使用文件与进程交互"><a href="#stdin-使用文件与进程交互" class="headerlink" title="stdin-使用文件与进程交互"></a>stdin-使用文件与进程交互</h4><p>前面提到<code>stdin</code>可以传入一个文件对象，这里将需要<strong>执行的命令</strong>写入文件，从而达到<strong>与进程通信的目的</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux下，先进入Python环境，然后执行文件中的命令</span></span><br><span class="line">fd = open(<span class="string">"cmd.txt"</span>,<span class="string">'r'</span>)</span><br><span class="line">ret = subprocess.run(<span class="string">"python"</span>, stdin=fd, stdout=subprocess.PIPE,shell=<span class="keyword">True</span>)</span><br><span class="line">print(ret.stdout)</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  <span class="string">b'hello world\\!\n'</span></span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="check-检查退出码"><a href="#check-检查退出码" class="headerlink" title="check-检查退出码"></a>check-检查退出码</h4><p><code>check</code>：如果该参数设置为<code>True</code>，并且进程<strong>退出状态码(<code>CompletedProcess</code> 的 <code>returncode</code> 属性)不是0</strong>，则弹出<code>CalledProcessError</code>异常:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用check=True，即使命令错误了，也不会报错</span></span><br><span class="line">subprocess.run([<span class="string">'false'</span>])</span><br><span class="line">  <span class="comment"># 命令执行不成功，返回状态码为1</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'false'</span>], returncode=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加check=True</span></span><br><span class="line"><span class="comment"># 会对命令的执行状态码进行检查，如果执行失败(不为0)，就报错</span></span><br><span class="line">subprocess.run([<span class="string">'false'</span>], check=<span class="keyword">True</span>)</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">487</span>, <span class="keyword">in</span> run</span><br><span class="line">      output=stdout, stderr=stderr)</span><br><span class="line">  subprocess.CalledProcessError: Command <span class="string">'['</span>false<span class="string">']'</span> returned non-zero exit status <span class="number">1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subprocess.run([<span class="string">'false'</span>], check=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  ERROR: Command <span class="string">'['</span>false<span class="string">']'</span> returned non-zero exit status <span class="number">1.</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="encoding-输入、输出、错误编码方式"><a href="#encoding-输入、输出、错误编码方式" class="headerlink" title="encoding-输入、输出、错误编码方式"></a>encoding-输入、输出、错误编码方式</h4><p><code>encoding</code>：如果<strong>指定了该参数</strong>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>可以接收或输出<strong>字符串</strong>数据，并以该编码方式编码，<strong>否则只接收或输出bytes类</strong>型的数据:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子进程创建新的管道</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要输出子进程的返回值</span></span><br><span class="line"><span class="comment"># 同样是通过获取属性的值</span></span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 可以看到返回的结果是byte类型的</span></span><br><span class="line">  <span class="comment"># 这是以为我们没有设置encoding参数</span></span><br><span class="line">  <span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用utf-8进行解码</span></span><br><span class="line">completed.stdout.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接设置encoding参数就不用进行decode操作</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 直接返回字符串，不用进行decode操作</span></span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="CompletedProcess类"><a href="#CompletedProcess类" class="headerlink" title="CompletedProcess类"></a>CompletedProcess类</h3><p><code>run()</code>方法的返回值，表示<strong>一个进程结束了</strong>，<code>CompletedProcess</code>类有下面这些属性：</p><table><tr><th width="20%">属性</th><th width="80%">说明</th></tr><tr><td><code>args</code></td><td>进程运行的命令，通常是个字符串列表或字符串</td></tr><tr><td><code>returncode</code></td><td>进程结束状态返回码，0表示命令成功状态，非0表示不成功</td></tr><tr><td><code>stdout</code></td><td>获取子进程的stdout，通常为bytes类型序列(可以通过<code>ecoding</code>参数调整)，None表示没有捕获值。如果在调用run()方法时，设置了参数<code>stderr=subprocess.STDOUT</code>，则错误信息会和stdout一起输出，此时stderr的值是None</td></tr><tr><td><code>stderr</code></td><td>获取子进程的错误信息，通常为bytes类型序列，None表示没有捕获值</td></tr><tr><td><code>check_returncode()</code></td><td>用于检查返回码。如果返回状态码不为零，弹出<code>CalledProcessError</code>异常</td></tr></table><hr><h3 id="subprocess-DEVNULL-抑制输出"><a href="#subprocess-DEVNULL-抑制输出" class="headerlink" title="subprocess.DEVNULL-抑制输出"></a>subprocess.DEVNULL-抑制输出</h3><p>某些情况下，<strong>输出不应该被展示和捕获</strong>，使用 <code>subprocess.DEVNULL</code> 抑制输出流(Linux下的/dev/null)：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span></span><br><span class="line"><span class="comment"># 上述命令会有一个错误输出to stderr</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    completed = subprocess.run(</span><br><span class="line">        <span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>,</span><br><span class="line">        shell=<span class="keyword">True</span>,</span><br><span class="line">        stdout=subprocess.DEVNULL,</span><br><span class="line">        stderr=subprocess.DEVNULL,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'returncode:'</span>, completed.returncode)</span><br><span class="line">    print(<span class="string">'stdout is &#123;!r&#125;'</span>.format(completed.stdout))</span><br><span class="line">    print(<span class="string">'stderr is &#123;!r&#125;'</span>.format(completed.stderr))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行结果不会输出到控制台，应为设置了stdout和stderr</span></span><br><span class="line"><span class="comment"># 同时也不会被捕获，因为设置的值为subprocess.DEVNULL，相当于是无底洞</span></span><br><span class="line">returncode: <span class="number">1</span></span><br><span class="line">stdout <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line">stderr <span class="keyword">is</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="subprocess-STDOUT-合并标准错误和输出"><a href="#subprocess-STDOUT-合并标准错误和输出" class="headerlink" title="subprocess.STDOUT-合并标准错误和输出"></a>subprocess.STDOUT-合并标准错误和输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    completed = subprocess.run(</span><br><span class="line">        <span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>,</span><br><span class="line">        shell=<span class="keyword">True</span>,</span><br><span class="line">        stdout=subprocess.PIPE,</span><br><span class="line">        stderr=subprocess.STDOUT,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'returncode:'</span>, completed.returncode)</span><br><span class="line">    print(<span class="string">'stdout is &#123;!r&#125;'</span>.format(completed.stdout))</span><br><span class="line">    print(<span class="string">'stderr is &#123;!r&#125;'</span>.format(completed.stderr))</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CompletedProcess类</span></span><br><span class="line">CompletedProcess(args=<span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>, returncode=<span class="number">1</span>, stdout=<span class="string">b'to stdout\nto stderr\n'</span>)</span><br><span class="line"></span><br><span class="line">returncode: <span class="number">1</span></span><br><span class="line"><span class="comment"># stdout合并了stderr的输出</span></span><br><span class="line">stdout <span class="keyword">is</span> <span class="string">b'to stdout\nto stderr\n'</span></span><br><span class="line"><span class="comment"># 输出在了stdout中，所以这里就成了空值</span></span><br><span class="line">stderr <span class="keyword">is</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：错误输出合并输出在了<code>stdout</code>中之后，<code>CompletedProcess</code>实例中的 <strong><code>stderr</code>属性就成了空值</strong></p></div><hr><p><br></p><h2 id="更高级的使用场景-subprocess-Popen"><a href="#更高级的使用场景-subprocess-Popen" class="headerlink" title="更高级的使用场景-subprocess.Popen()"></a>更高级的使用场景-subprocess.Popen()</h2><h3 id="命令形式-1"><a href="#命令形式-1" class="headerlink" title="命令形式"></a>命令形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.Popen(args, bufsize=<span class="number">-1</span>, executable=<span class="keyword">None</span>, \</span><br><span class="line">                 stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, preexec_fn=<span class="keyword">None</span>, \</span><br><span class="line">                 close_fds=<span class="keyword">True</span>, shell=<span class="keyword">False</span>, cwd=<span class="keyword">None</span>, env=<span class="keyword">None</span>, \</span><br><span class="line">                 universal_newlines=<span class="keyword">None</span>, startupinfo=<span class="keyword">None</span>, \</span><br><span class="line">                 creationflags=<span class="number">0</span>, restore_signals=<span class="keyword">True</span>, \</span><br><span class="line">                 start_new_session=<span class="keyword">False</span>, pass_fds=(), *, \</span><br><span class="line">                 encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, text=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>功能与<code>run()</code>方法基本类同，但是它的<strong>返回值是一个<code>Popen</code>实例</strong>，而<strong>不是<code>CompletedProcess</code>实例</strong></p><hr><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><p>大部分的参数都和<code>subprocess.run()</code>中的用法相同，这里列出几个这里特有的参数：</p><ul><li><code>cwd</code>： 如果该参数值<strong>不是None</strong>，则该函数将会在执行这个子进程之前<strong>改变当前工作目录</strong></li><li><code>env</code>： 用于<strong>指定子进程的环境变量</strong>，如果<code>env=None</code>，那么子进程的环境变量将<strong>从父进程中继承</strong>；如果<code>env!=None</code>，它的值必须是一个<strong>映射对象</strong></li></ul><hr><h3 id="可调用方法"><a href="#可调用方法" class="headerlink" title="可调用方法"></a>可调用方法</h3><table><tr><th width="30%">方法</th><th width="70%">描述</th></tr><tr><td><code>Popen.poll()</code></td><td>用于检查子进程（命令）是否已经执行结束，没结束返回None，结束后返回状态码</td></tr><tr><td><code>Popen.wait(timeout=None)</code></td><td>等待子进程结束，并返回状态码；如果在timeout指定的秒数之后进程还没有结束，将会抛出一个TimeoutExpired异常</td></tr><tr><td><code>Popen.communicate(input=None, timeout=None)</code></td><td>该方法可用来与进程进行交互，比如发送数据到stdin，从stdout和stderr读取数据，直到到达文件末尾</td></tr><tr><td><code>Popen.send_signal(signal)</code></td><td>发送指定的信号给这个子进程</td></tr><tr><td><code>Popen.terminate()</code></td><td>停止该子进程</td></tr><tr><td><code>Popen.kill()</code></td><td>杀死该子进程</td></tr></table><div class="note info"><p>关于<code>Popen.communicate()</code>方法的说明：</p><ul><li>该方法中的可选参数 <code>input</code> 应该是将<strong>被发送给子进程的数据</strong>，或者如没有数据发送给子进程，该参数应该是None。<code>input</code>参数的数据类型必须是<strong>字节串</strong>，如果<code>universal_newlines</code>参数值为<code>True</code>(或者<strong>设置<code>encoding</code>参数</strong>)，则<code>input</code>参数的数据类型<strong>必须是字符串</strong></li><li>该方法返回一个<code>元组(stdout_data, stderr_data)</code>，这些数据将会是<strong>字节串或字符串(如果<code>universal_newlines</code>的值为<code>True</code>,或者设置<code>encoding</code>参数)</strong></li><li>如果在<code>timeout</code>指定的秒数后该进程还没有结束，将会抛出一个<code>TimeoutExpired</code>异常，<strong>捕获这个异常</strong>，然后<strong>重新尝试通信不会丢失任何输出的数据</strong>，但是超时之后子进程并没有被杀死，为了合理的清除相应的内容，一个好的应用应该手动杀死这个子进程来结束通信</li><li>需要注意的是，这里读取的数据是<strong>缓冲在内存中</strong>的，所以，如果<strong>数据大小非常大或者是无限的，就不应该使用这个方法</strong></li></ul></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="获取命令结果"><a href="#获取命令结果" class="headerlink" title="获取命令结果"></a>获取命令结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p = subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">"ls"</span>,<span class="string">"-l"</span>], stdout=subprocess.PIPE)</span><br><span class="line"><span class="comment"># 返回的p和前面的不同</span></span><br><span class="line">p</span><br><span class="line">  &lt;subprocess.Popen object at <span class="number">0x7fcddff8a710</span>&gt;</span><br><span class="line"><span class="comment"># 使用属性的read方法获取结果</span></span><br><span class="line"><span class="comment"># read()只能读取一次，再读取一次结果就为空(读取一遍后文件指针到最后了)</span></span><br><span class="line">p.stdout.read()</span><br><span class="line">  <span class="string">b'total 4\n-rw-rw-r-- 1 user user 23 Apr  4 15:26 cmd.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test1.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test2.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test3.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test4.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用decode将输出的字节串解码为utf-8，并输出结果</span></span><br><span class="line">print(p.stdout.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">  total <span class="number">4</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">23</span> Apr  <span class="number">4</span> <span class="number">15</span>:<span class="number">26</span> cmd.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br></pre></td></tr></table></figure><hr><h4 id="修改工作目录"><a href="#修改工作目录" class="headerlink" title="修改工作目录"></a>修改工作目录</h4><p><code>cwd</code>： 如果该参数值<strong>不是None</strong>，则该函数将会在执行这个子进程之前<strong>改变当前工作目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>,cwd=<span class="string">"./test"</span>)</span><br><span class="line"><span class="comment"># 使用decode将输出的字节串解码为utf-8，并输出结果</span></span><br><span class="line">print(p.stdout.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">46</span> cwd1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">46</span> cwd2.txt</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="Popen-communicate-使用"><a href="#Popen-communicate-使用" class="headerlink" title="Popen.communicate()使用"></a>Popen.communicate()使用</h4><ul><li>该方法返回一个<code>元组(stdout_data, stderr_data)</code>，这些数据将会是<strong>字节串或字符串(如果<code>universal_newlines</code>的值为<code>True</code>,或者设置<code>encoding</code>参数)</strong></li></ul><p><strong>与进程交互实例一</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj.stdin.write(<span class="string">'print(1)'</span>)</span><br><span class="line">  <span class="comment"># 直接输入字符会报错</span></span><br><span class="line">  <span class="comment"># 只能输入字节串</span></span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  TypeError: a bytes-like object <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="string">'str'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用encoding或者universal_newlines</span></span><br><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,\</span><br><span class="line">                        encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                       stdout=subprocess.PIPE, stderr=subprocess.PIPE,\</span><br><span class="line">                       universal_newlines=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用obj.stdin.write来传递命令</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(1)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(2)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(3)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取返回的输出值和错误</span></span><br><span class="line">out,err = obj.communicate()</span><br><span class="line">out</span><br><span class="line">  <span class="string">'1\n2\n'</span></span><br><span class="line">err</span><br><span class="line">  <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用obj.communicate()的input参数来传递命令</span></span><br><span class="line">out,err = obj.communicate(input=<span class="string">'print(1)'</span>)</span><br><span class="line">out</span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  <span class="string">'1\n'</span></span><br><span class="line">err</span><br><span class="line">  <span class="string">''</span></span><br></pre></td></tr></table></figure><p></p><p><strong>与进程交互实例二</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'cat -; echo "to stderr" 1&gt;&amp;2'</span></span><br><span class="line"><span class="comment"># 获取标准输入</span></span><br><span class="line"><span class="comment"># 并且得到标准错误输出</span></span><br><span class="line">proc = subprocess.Popen(</span><br><span class="line">    <span class="string">'cat -; echo "to stderr" 1&gt;&amp;2'</span>,</span><br><span class="line">    shell=<span class="keyword">True</span>,</span><br><span class="line">    stdin=subprocess.PIPE,</span><br><span class="line">    stdout=subprocess.PIPE,</span><br><span class="line">    stderr=subprocess.PIPE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前面没有设置encoding参数以及universal_newlines参数</span></span><br><span class="line"><span class="comment"># 这使用encode来将字符串编码为字节串</span></span><br><span class="line">msg = <span class="string">'through stdin to stdout'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">stdout_value, stderr_value = proc.communicate(msg)</span><br><span class="line"><span class="comment"># 使用decode来将字节串解码为字符串</span></span><br><span class="line">print(<span class="string">'pass through:'</span>, repr(stdout_value.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">  <span class="comment"># 输出标准输出，cat -的运行结果</span></span><br><span class="line">  <span class="keyword">pass</span> through: <span class="string">'through stdin to stdout'</span></span><br><span class="line">print(<span class="string">'stderr      :'</span>, repr(stderr_value.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">  <span class="comment"># 输出标准错误，echo "to stderr" 1&gt;&amp;2的运行结果</span></span><br><span class="line">  <span class="comment"># 1&gt;&amp;2将标准输出重定向到标准错误输出</span></span><br><span class="line">  stderr      : <span class="string">'to stderr\n'</span></span><br></pre></td></tr></table></figure><p></p><p><strong>实现shell中管道符的实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">p1 = subprocess.Popen([<span class="string">'ls'</span>, <span class="string">'-l'</span>], stdout=subprocess.PIPE)</span><br><span class="line"><span class="comment"># 这里设置p2的输入为p1的输出</span></span><br><span class="line">p2 = subprocess.Popen([<span class="string">'grep'</span>, <span class="string">'cmd'</span>], stdin=p1.stdout, stdout=subprocess.PIPE)</span><br><span class="line">out,err = p2.communicate()</span><br><span class="line">out</span><br><span class="line">  <span class="string">b'-rw-rw-r-- 1 user user 23 Apr  4 15:26 cmd.txt\n'</span></span><br><span class="line">err</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果<strong>不想将结果输出在控制台上</strong>，可以设置<code>stdout</code>和<code>stderr</code>来<strong>捕获输出</strong></li><li>如果希望命令的运行不成功(退出状态码不为0)就爆出异常，可以设置<code>check=True</code>以及异常捕获</li><li>在使用<strong>字符串与进程通信</strong>以及<strong>输出结果</strong>的时候，需要注意设置<code>encoding</code>以及<code>universal_newlines</code>参数，不然<strong>命令会报错</strong>或者<strong>输出得到的是字节串</strong></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" target="_blank" rel="noopener">subprocess — Subprocess management</a></li><li><a href="http://www.liujiangblog.com/course/python/55" target="_blank" rel="noopener">subprocess</a></li><li><a href="https://www.cnblogs.com/yyds/p/7288916.html#4179829" target="_blank" rel="noopener">Python之系统交互（subprocess）</a></li><li><a href="https://learnku.com/docs/pymotw/subprocess-spawning-additional-processes/3419" target="_blank" rel="noopener">11.2. subprocess — 生成多余进程</a></li><li><a href="https://www.cnblogs.com/vamei/archive/2012/09/23/2698014.html" target="_blank" rel="noopener">Python标准库06 子进程 (subprocess包)</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python常用模块&lt;code&gt;subprocess&lt;/code&gt;，这是一个&lt;strong&gt;子进程管理的模块&lt;/strong&gt;，用来&lt;strong&gt;在Python代码中执行操作系统级别的命令&lt;/strong&gt;(如linux下的命令行命令)；主要学习了其中的两大API：&lt;code&gt;subprocess.run()&lt;/code&gt;和&lt;code&gt;subprocess.Popen()&lt;/code&gt;，学习了如何&lt;strong&gt;传递要执行的命令&lt;/strong&gt;、如何&lt;strong&gt;获取命令的退出状态码(returncode)&lt;/strong&gt;、&lt;strong&gt;输出(stdout)&lt;/strong&gt;、&lt;strong&gt;错误(stderr)&lt;/strong&gt;以及&lt;strong&gt;如何与进程交互&lt;/strong&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之字符串与字符编码(转载)</title>
    <link href="http://showteeth.tech/posts/59082.html"/>
    <id>http://showteeth.tech/posts/59082.html</id>
    <published>2019-04-03T01:11:24.000Z</published>
    <updated>2019-04-04T01:22:39.997Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，围绕Python中的字符串与字符编码<strong>比较了Python2和Python3在字节与字符串默认行为上的不同</strong>、<strong>结合Python源代码执行过程讲解了设置字符编码的作用</strong>以及<strong>不同字符编码之间的转换</strong>，是一篇非常实用和重要的文章。</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>Python中的字符编码是个老生常谈的话题，同行们都写过很多这方面的文章。有的人云亦云，也有的写得很深入。近日看到某知名培训机构的教学视频中再次谈及此问题，讲解的还是不尽人意，所以才想写这篇文字。一方面，梳理一下相关知识，另一方面，希望给其他人些许帮助。</p><blockquote><p><code>Python2</code>的 <strong><em>默认编码</em></strong> 是<code>ASCII</code>，<strong>不能识别中文字符</strong>，<strong>需要显式指定字符编码</strong>；<code>Python3</code>的 <strong><em>默认编码</em></strong> 为<code>Unicode</code>，<strong>可以识别中文字符</strong>。</p></blockquote><p>相信大家在很多文章中都看到过类似上面这样“对Python中中文处理”的解释，也相信大家在最初看到这样的解释的时候确实觉得明白了。可是时间久了之后，再重复遇到相关问题就会觉得貌似理解的又不是那么清楚了。如果我们了解上面说的默认编码的作用是什么，我们就会更清晰的明白那句话的含义。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><hr><h3 id="字符与字节"><a href="#字符与字节" class="headerlink" title="字符与字节"></a>字符与字节</h3><p><strong>一个字符不等价于一个字节</strong>，字符是人类能够识别的符号，而这些符号要保存到计算的存储中就需要用计算机能够识别的字节来表示。一个字符往往有多种表示方法，不同的表示方法会使用不同的字节数。这里所说的不同的表示方法就是指字符编码，比如字母<code>A-Z</code>都可以用<code>ASCII</code>码表示（占用一个字节），也可以用<code>UNICODE</code>表示（占两个字节），还可以用<code>UTF-8</code>表示（占用一个字节）。<strong>字符编码的作用就是将人类可识别的字符转换为机器可识别的字节码，以及反向过程</strong>。</p><p><strong><em>UNICDOE才是真正的字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串</em></strong> 。关于这点，我们可以在Python的官方文档中经常可以看到这样的描述<code>&quot;Unicode string&quot; , &quot; translating a Unicode string into a sequence of bytes&quot;</code></p><p>我们写代码是写在文件中的，而字符是以字节形式保存在文件中的，因此当我们在文件中定义个字符串时被当做字节串也是可以理解的。但是，我们需要的是字符串，而不是字节串。一个优秀的编程语言，应该严格区分两者的关系并提供巧妙的完美的支持。JAVA语言就很好，以至于了解Python和PHP之前我从来没有考虑过这些不应该由程序员来处理的问题。遗憾的是，很多编程语言试图混淆“字符串”和“字节串”，他们把字节串当做字符串来使用，PHP和Python2都属于这种编程语言。最能说明这个问题的操作就是取一个包含中文字符的字符串的长度：</p><ul><li>对字符串取长度，结果应该是所有字符的个数，无论中文还是英文</li><li>对字符串对应的字节串取长度，就跟编码(encode)过程使用的字符编码有关了(比如：UTF-8编码，一个中文字符需要用3个字节来表示；GBK编码，一个中文字符需要2个字节来表示)</li></ul><p><strong>注意</strong>：<code>Windows</code>的cmd终端字符编码默认为<code>GBK</code>，因此在cmd输入的中文字符需要用两个字节表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'Hello,中国'</span>  <span class="comment"># 字节串，长度为字节个数 = len('Hello,')+len('中国') = 6+2*2 = 10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">u'Hello,中国'</span>  <span class="comment"># 字符串，长度为字符个数 = len('Hello,')+len('中国') = 6+2 = 8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = unicode(a, <span class="string">'gbk'</span>)  <span class="comment"># 其实b的定义方式是c定义方式的简写，都是将一个GBK编码的字节串解码（decode）为一个Uniocde字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(a), len(a))</span><br><span class="line">(&lt;type <span class="string">'str'</span>&gt;, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(b), len(b))</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(c), len(c))</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">8</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>Python3中对字符串的支持做了很大的改动，具体内容会在下面介绍。</p><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>先做下科普：UNICODE字符编码，也是一张字符与数字的映射，但是这里的数字被称为<code>代码点(code point)</code>, <strong>实际上就是十六进制的数字</strong>。</p><p>Python官方文档中对Unicode字符串、字节串与编码之间的关系有这样一段描述：</p><blockquote><p>Unicode字符串是一个代码点（code point）序列，代码点取值范围为0到0x10FFFF（对应的十进制为1114111）。这个代码点序列在存储（包括内存和物理磁盘）中需要被表示为一组字节(0到255之间的值)，而将<strong>Unicode字符串转换为字节序列的规则称为编码</strong>。</p></blockquote><p>这里说的编码不是指字符编码，而是指编码的过程以及这个过程中所使用到的 <strong><em>Unicode字符的代码点与字节的映射规则</em></strong> 。这个映射不必是简单的一对一映射，因此编码过程也不必处理每个可能的Unicode字符，例如：</p><p><strong>将<code>Unicode字符串</code>转换为<code>ASCII编码</code></strong>的规则很简单–对于每个代码点：</p><ul><li>如果代码点数值&lt;128，则每个字节与代码点的值相同</li><li>如果代码点数值&gt;=128，则Unicode字符串无法在此编码中进行表示（这种情况下，Python会引发一个UnicodeEncodeError异常）</li></ul><p><strong>将<code>Unicode字符串</code>转换为<code>UTF-8编码</code></strong>使用以下规则：</p><ul><li>如果代码点数值&lt;128，则由相应的字节值表示（与Unicode转ASCII字节一样）</li><li>如果代码点数值&gt;=128，则将其转换为一个2个字节，3个字节或4个字节的序列，该序列中的每个字节都在128到255之间。</li></ul><div class="note info"><p>简单总结：</p><ul><li><strong><em>编码(encode)</em></strong> ：将Unicode<strong>字符串</strong>（中的代码点)<strong>转换</strong>特定字符编码对应的<strong>字节串</strong>的过程和规则</li><li><strong><em>解码(decode)</em></strong> ：将特定字符编码的<strong>字节串转换</strong>为对应的Unicode<strong>字符串</strong>(中的代码点)的过程和规则</li></ul></div><p>可见，无论是编码还是解码，都需要一个重要因素，就是 <strong><em>特定的字符编码</em></strong> 。因为一个字符用不同的字符编码进行编码后的字节值以及字节个数大部分情况下是不同的，反之亦然。</p><h2 id="Python中的默认编码"><a href="#Python中的默认编码" class="headerlink" title="Python中的默认编码"></a>Python中的默认编码</h2><hr><h3 id="Python源代码文件的执行过程"><a href="#Python源代码文件的执行过程" class="headerlink" title="Python源代码文件的执行过程"></a>Python源代码文件的执行过程</h3><p>我们都知道，<strong>磁盘上的文件都是以二进制格式存放的</strong>，其中<strong>文本文件都是以某种特定编码的字节形式存放的</strong>。对于<strong>程序源代码文件的字符编码是由<code>编辑器指定</code>的</strong>，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为<code>UTF-8</code>，那么Python代码被保存到磁盘时就会被转换为<code>UTF-8</code>编码对应的字节（<strong>encode过程</strong>）后写入磁盘。当<strong>执行Python代码</strong>文件中的代码时，<strong>Python解释器</strong>在读取Python代码文件中的字节串之后，需要<strong>将其转换为UNICODE字符串</strong>（<strong>decode过程</strong>）之后才执行后续操作。</p><p>上面已经解释过，这个<strong>转换过程（decode，解码）需要我们指定文件中保存的字节使用的字符编码是什么</strong>，才能知道这些字节在UNICODE这张万国码和统一码中找到其对应的代码点是什么。这里指定字符编码的方式大家都很熟悉，如下所示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用来指示Python解释器使用什么字符编码来将读取的字节串如何转化为字符串</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python字符编码过程_1.png" alt="Python字符编码过程_1.png"></p><h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><p>那么，如果我们<strong>没有在代码文件开始的部分指定字符编码</strong>，Python解释器就会使用哪种字符编码把从代码文件中读取到的字节转换为UNICODE代码点呢？就像我们配置某些软件时，有很多默认选项一样，需要在<strong>Python解释器内部设置默认的字符编码来解决这个问题</strong>，这就是文章开头所说的“默认编码”。因此大家所说的Python中文字符问题就可以总结为一句话： <strong><em>当无法通过默认的字符编码对字节进行转换时，就会出现解码错误(UnicodeEncodeError)</em></strong> 。</p><p><code>Python2</code>和<code>Python3</code>的解释器使用的<strong>默认编码是不一样</strong>的，我们可以通过<code>sys.getdefaultencoding()</code>来获取默认编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">'ascii'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><p>因此，对于<code>Python2</code>来讲，<strong>Python解释器</strong>在读取到中文字符的字节码尝试解码操作时，会<strong>先查看当前代码文件头部</strong>是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果<strong>没有指定则使用默认字符编码<code>&quot;ASCII&quot;</code>进行解码</strong>导致解码<strong>失败，导致如下错误</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p></p><p>对于<code>Python3</code>来讲，<strong>执行过程是一样的</strong>，只是Python3的<strong>解释器以<code>&quot;UTF-8&quot;</code>作为默认编码</strong>，但是这<strong>并不表示可以完全兼容中文问题</strong>。比如我们<strong>在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的</strong>。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，导致如下错误：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>创建一个工程之后<strong>先确认该工程的字符编码是否已经设置为UTF-8(编辑器设置中设置)</strong> —&gt;<strong>用于指示代码会使用什么字符编码方式保存为字节串</strong></li><li>为了兼容Python2和Python3，在<strong>代码头部声明字符编码：<code>-*- coding:utf-8 -*-</code></strong> —&gt;<strong>用于指示Python解释器使用什么字符编码将读取的字节串转化为字符串</strong></li><li>另外地，在<strong>读写文件内容的时候也需要指定正确的文件字符的编码方式</strong>，这部分在<a href="http://showteeth.tech/posts/57951.html">Python系列之文件读写(转载)</a>中有所讲解。</li></ul><h2 id="Python2与Python3中对字符串的支持"><a href="#Python2与Python3中对字符串的支持" class="headerlink" title="Python2与Python3中对字符串的支持"></a>Python2与Python3中对字符串的支持</h2><hr><p>其实Python3中对字符串支持的改进，不仅仅是更改了默认编码，而是重新进行了字符串的实现，而且它已经实现了对UNICODE的内置支持，从这方面来讲Python已经和JAVA一样优秀。下面我们来看下 <strong><code>Python2</code>与<code>Python3</code>中对字符串的支持有什么区别</strong>：</p><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><p><code>Python2</code>中对字符串的支持由以下三个类提供:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">str</span><span class="params">(basestring)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">unicode</span><span class="params">(basestring)</span></span></span><br></pre></td></tr></table></figure><p></p><p>执行<code>help(str)</code>和<code>help(bytes)</code>会发现结果<strong>都是str类的定义</strong>，这也说明<code>Python2</code>中 <strong><code>str</code>就是字节串</strong>，而后来的 <strong><code>unicode</code>对象对应才是真正的字符串</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'你好'</span></span><br><span class="line">b = <span class="string">u'你好'</span></span><br><span class="line"></span><br><span class="line">print(type(a), len(a))</span><br><span class="line">print(type(b), len(b))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;type <span class="string">'str'</span>&gt;, <span class="number">6</span>)</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><p><code>Python3</code>中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可以认为<code>Python3</code>中的<code>str</code>和<code>unicode</code><strong>合二为一</strong>了。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(object)</span></span></span><br></pre></td></tr></table></figure><p></p><p>实际上，Python3中已经意识到之前的错误，开始明确的区分字符串与字节。因此<code>Python3</code>中的 <strong><code>str</code>已经是真正的字符串</strong>，而<strong>字节是用单独的<code>bytes</code>类来表示</strong>。也就是说，<strong><code>Python3</code>默认定义的就是字符串，实现了对<code>UNICODE</code>的内置支持</strong>，减轻了程序员对字符串处理的负担。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'你好'</span></span><br><span class="line">b = <span class="string">u'你好'</span></span><br><span class="line">c = <span class="string">'你好'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line"></span><br><span class="line">print(type(a), len(a))</span><br><span class="line">print(type(b), len(b))</span><br><span class="line">print(type(c), len(c))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt; 2</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt; 4</span></span><br></pre></td></tr></table></figure><p></p><h2 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h2><hr><p>上面提到，<strong>UNICODE<code>字符串</code></strong>可以与<strong>任意字符编码的<code>字节</code></strong>进行<strong>相互转换</strong>，如图：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python字符串与字节的转换.png" alt="Python字符串与字节的转换.png"></p><p>那么大家很容易想到一个问题，就是不同的字符编码的字节可以通过Unicode相互转换吗？答案是肯定的。</p><h3 id="Python2中的字符串进行字符编码转换"><a href="#Python2中的字符串进行字符编码转换" class="headerlink" title="Python2中的字符串进行字符编码转换"></a>Python2中的字符串进行字符编码转换</h3><p><strong>转换过程</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节串--&gt;decode('原来的字符编码')--&gt;Unicode字符串--&gt;encode('新的字符编码')--&gt;字节串</span><br></pre></td></tr></table></figure><p></p><p><strong>转换实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python2中的utf_8_a为字节串</span></span><br><span class="line">utf_8_a = <span class="string">'我爱中国'</span></span><br><span class="line"><span class="comment"># 先将字节串decode为字符串，然后再将字符串encode为字节串</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gbk'</span>)</span><br><span class="line"><span class="comment"># 再使用decode转化为字符串输出</span></span><br><span class="line">print(gbk_a.decode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我爱中国</span><br></pre></td></tr></table></figure><h3 id="Python3中的字符串进行字符编码转换"><a href="#Python3中的字符串进行字符编码转换" class="headerlink" title="Python3中的字符串进行字符编码转换"></a>Python3中的字符串进行字符编码转换</h3><p>因为Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码，其过程为：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串--&gt;encode('新的字符编码')--&gt;字节串</span><br></pre></td></tr></table></figure><p></p><p><strong>转换实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">utf_8_a = <span class="string">'我爱中国'</span></span><br><span class="line">gbk_a = utf_8_a.encode(<span class="string">'gbk'</span>)</span><br><span class="line">print(gbk_a.decode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我爱中国</span><br></pre></td></tr></table></figure><p></p><p><strong>最后需要说明的是</strong>，<strong>Unicode不是有道词典</strong>，也不是google翻译器，它<strong>并不能把一个中文翻译成一个英文</strong>。正确的字符编码的转换过程只是把<strong>同一个字符的字节表现形式改变</strong>了，而<strong>字符本身的符号是不应该发生变化</strong>的，因此并不是所有的字符编码之间的转换都是有意义的。怎么理解这句话呢？比如GBK编码的“中国”转成UTF-8字符编码后，仅仅是由4个字节变成了6个字节来表示，但其字符表现形式还应该是“中国”，而不应该变成“你好”或者“China”。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">Python中的字符串与字符编码</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，围绕Python中的字符串与字符编码&lt;strong&gt;比较了Python2和Python3在字节与字符串默认行为上的不同&lt;/strong&gt;、&lt;strong&gt;结合Python源代码执行过程讲解了设置字符编码的作用&lt;/strong&gt;以及&lt;strong&gt;不同字符编码之间的转换&lt;/strong&gt;，是一篇非常实用和重要的文章。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之覆盖之前输出的内容</title>
    <link href="http://showteeth.tech/posts/38536.html"/>
    <id>http://showteeth.tech/posts/38536.html</id>
    <published>2019-04-02T15:32:20.000Z</published>
    <updated>2019-04-02T15:55:22.332Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用Python输出时进行<strong>覆盖输出(覆盖上一次的运行结果)</strong>，关键点在于：<strong>在要输出的字符前加上<code>carriage return symbol &#39;\r&#39;</code></strong>、<strong>写入操作的时候不能有换行操作</strong>、<strong>字符串后增加一定的空格字符</strong>。</p></div><a id="more"></a><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>在学习<a href="http://showteeth.tech/posts/38877.html"><code>sys</code>模块</a>中的<code>sys.stdout.write()</code>方法时，看别人的博客提供了一个实现百分比进度条的程序，其实现如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>结果输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果在输出的时候后面的输出会覆盖之前的输出</span></span><br><span class="line"><span class="comment"># 而不是重新一行显示</span></span><br><span class="line">[====================================================================================================]<span class="number">100</span>%</span><br></pre></td></tr></table></figure><p></p><p>而当我使用print()进行输出时：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    print(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现没有进行覆盖，虽然功能差不多，但是这样很占空间</span></span><br><span class="line">[                                                                                                    ]<span class="number">0</span>%</span><br><span class="line">[=                                                                                                   ]<span class="number">1</span>%</span><br></pre></td></tr></table></figure><p></p><p>鉴于上述两种输出模式的差别，我就想知道<strong>是什么控制了这种覆盖的输出</strong>。</p><hr><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>问题的原因在于：</p><ul><li><code>r = &#39;\r[%s%s]%d%%&#39; % (&quot;=&quot;*num, &quot; &quot;*(100-num), rate_num, )</code>中的<code>\r</code></li><li>写入操作的时候没有换行：<code>sys.stdout.write(r)</code>最后没有<code>+&#39;\n&#39;</code></li><li><strong>字符串后增加一定的空格字符</strong></li></ul><p><strong>解释</strong>：<br><strong>Prefix</strong> your output with <strong>carriage return symbol ‘\r’</strong> and <strong>do not end it with line feed symbol ‘\n’</strong>. This will place cursor at the beginning of the current line, so output will overwrite previous its content. <strong>Pad it with some trailing blank space to guarantee overwrite</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.stdout.write(<span class="string">'\r'</span> + str(hpi) + <span class="string">' '</span> * <span class="number">20</span>)</span><br><span class="line">sys.stdout.flush() <span class="comment"># important</span></span><br></pre></td></tr></table></figure><p></p><p>所以我上面直接使用<code>print(r)</code>的<strong>错误在于写入操作的时候有了换行操作</strong>，这是 <strong><code>print()</code>的默认行为</strong>，关于print()请参考这篇文章</p><p><strong>正确写法</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    <span class="comment"># sys.stdout.write(r)</span></span><br><span class="line">    <span class="comment"># 或者使用</span></span><br><span class="line">    print(r,end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/9860680/python-overwrite-previous-line" target="_blank" rel="noopener">python overwrite previous line</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了使用Python输出时进行&lt;strong&gt;覆盖输出(覆盖上一次的运行结果)&lt;/strong&gt;，关键点在于：&lt;strong&gt;在要输出的字符前加上&lt;code&gt;carriage return symbol &amp;#39;\r&amp;#39;&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;写入操作的时候不能有换行操作&lt;/strong&gt;、&lt;strong&gt;字符串后增加一定的空格字符&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Python3的sys.stdout.write()返回字符长度</title>
    <link href="http://showteeth.tech/posts/23402.html"/>
    <id>http://showteeth.tech/posts/23402.html</id>
    <published>2019-04-02T14:54:34.000Z</published>
    <updated>2019-04-02T15:58:48.723Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了自己在<code>Python3</code>中使用<code>sys.stdout.write()</code>时<strong>发现会返回写入的字符长度</strong>，进而了解到<code>Python3</code>中<strong>文件对象的写入操作File.write()</strong>都会<strong>返回写入的字符长度</strong>，同时针对这种问题提出了自己的<strong>解决方法</strong>，<strong>将字符长度赋值给另一个变量</strong>，不让其输出即可。</p></div><a id="more"></a><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>在学习<a href="http://showteeth.tech/posts/38877.html"><code>sys</code>模块</a>中的<code>sys.stdout.write()</code>方法时，看别人的博客提供了一个实现百分比进度条的程序，其实现如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># \r会影响flush()</span></span><br><span class="line">    <span class="comment"># 不加的话输出结果不会显示在同一行，也不会对齐</span></span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    <span class="comment"># 这里使用的是sys.stdout.write(r)</span></span><br><span class="line">    <span class="comment"># 也可以使用print(i,end='')</span></span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>) </span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[====================================================================================================]<span class="number">100</span>%</span><br></pre></td></tr></table></figure><p></p><p>我觉得有些复杂，想将其改为不使用函数的形式，具体如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), num)</span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><p></p><p>结果输出如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=                                                                                                   ]<span class="number">1</span>%<span class="number">105</span></span><br></pre></td></tr></table></figure><p></p><p>发现后面多了一个105，想了半天，发现这个原来就是输出的字符的长度：100 + 4 + 1(<code>\r</code>)，关于这个<code>\r</code>的作用在<a href="http://showteeth.tech/posts/38536.html">另一篇文章</a>中有所讲解。</p><p><strong>也就是说我在输出我想打印的字符时还显示了这个字符的长度！</strong></p><hr><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>后来发现这是<code>Python3</code>的<code>sys.stdout.write()</code>以及<code>sys.stderr.write()</code>的(<strong>准确的说是File.write()</strong>)新功能，<strong>可以返回写入的字符数目</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'./test.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello world!'</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="comment"># 上面就返回了写入的字符的数目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sys.stdout.write()和sys.stderr.write()也是一样的效果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">"foo"</span>)</span><br><span class="line">foo3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">"bar"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：Python2中<code>File.write()</code>的返回值是<code>None</code></p></div><hr><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>找到问题的原因之后解决起来就非常简单了，只需要<strong>将返回的值赋值给另一个变量，不让它直接输出</strong>即可：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), num)</span><br><span class="line">    test=sys.stdout.write(r)</span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[==============                                                                                      ]<span class="number">14</span>%</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/27311509/strange-behavior-in-python-3-using-the-sys-module" target="_blank" rel="noopener">Strange behavior in Python 3 using the sys module</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要记录了自己在&lt;code&gt;Python3&lt;/code&gt;中使用&lt;code&gt;sys.stdout.write()&lt;/code&gt;时&lt;strong&gt;发现会返回写入的字符长度&lt;/strong&gt;，进而了解到&lt;code&gt;Python3&lt;/code&gt;中&lt;strong&gt;文件对象的写入操作File.write()&lt;/strong&gt;都会&lt;strong&gt;返回写入的字符长度&lt;/strong&gt;，同时针对这种问题提出了自己的&lt;strong&gt;解决方法&lt;/strong&gt;，&lt;strong&gt;将字符长度赋值给另一个变量&lt;/strong&gt;，不让其输出即可。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之文件读写(转载)</title>
    <link href="http://showteeth.tech/posts/57951.html"/>
    <id>http://showteeth.tech/posts/57951.html</id>
    <published>2019-04-02T01:11:24.000Z</published>
    <updated>2019-04-03T02:20:37.839Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要包括<code>I/O操作概述</code>、<code>文件读写实现原理与操作步骤</code>、<strong><code>文件打开模式及其区别</code></strong>、<code>Python文件操作步骤示例</code>、<code>Python文件读取相关方法</code>以及 <strong><code>文件读写与字符编码</code></strong>。</p></div><a id="more"></a><h2 id="I-O操作概述"><a href="#I-O操作概述" class="headerlink" title="I/O操作概述"></a>I/O操作概述</h2><hr><p>I/O在计算机中是指Input/Output，也就是Stream(流)的输入和输出。这里的输入和输出是相对于内存来说的，Input Stream(输入流)是指数据从外(磁盘、网络)流进内存，Output Stream是数据从内存流出到外面(磁盘、网络)。程序运行时，数据都是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方(通常是磁盘、网络操作)就需要IO接口。</p><p><strong><em>那么这个IO接口是由谁提供呢？高级编程语言中的IO操作是如何实现的呢？</em></strong></p><p>操作系统是个通用的软件程序，其通用目的如下：</p><ul><li>硬件驱动</li><li>进程管理</li><li>内存管理</li><li>网络管理</li><li>安全管理</li><li>I/O管理</li></ul><p>操作系统屏蔽了底层硬件，向上提供通用接口。因此，操作I/O的能力是由操作系统的提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来供开发者使用，Python也不例外。</p><h2 id="文件读写实现原理与操作步骤"><a href="#文件读写实现原理与操作步骤" class="headerlink" title="文件读写实现原理与操作步骤"></a>文件读写实现原理与操作步骤</h2><hr><h3 id="文件读写实现原理"><a href="#文件读写实现原理" class="headerlink" title="文件读写实现原理"></a>文件读写实现原理</h3><p>文件读写就是一种常见的IO操作。那么根据上面的描述，可以推断python也应该封装操作系统的底层接口，直接提供了文件读写相关的操作方法。事实上，也确实如此，而且Java、PHP等其他语言也是。</p><p><strong><em>那么我们要操作的对象是什么呢？我们又如何获取要操作的对象呢？</em></strong></p><p>由于操作I/O的能力是由操作系统提供的，且现代操作系统不允许普通程序直接操作磁盘，所以读写文件时需要请求操作系统打开一个对象(通常被称为文件描述符–<code>file descriptor</code>, 简称<code>fd</code>)，这就是我们在程序中要操作的文件对象。</p><p>通常高级编程语言中会提供一个内置的函数，通过接收”文件路径”以及“文件打开模式”等参数来打开一个文件对象，并返回该文件对象的文件描述符。因此通过这个函数我们就可以获取要操作的文件对象了。这个内置函数在Python中叫<code>open()</code>, 在PHP中叫<code>fopen()</code>,</p><h3 id="文件读写操作步骤"><a href="#文件读写操作步骤" class="headerlink" title="文件读写操作步骤"></a>文件读写操作步骤</h3><p>不同的编程语言读写文件的操作步骤大体都是一样的，都分为以下几个步骤：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)打开文件，获取文件描述符</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)操作文件描述符--读/写</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)关闭文件</span><br></pre></td></tr></table></figure><p></p><p>只是不同的编程语言提供的读写文件的api是不一样的，有些提供的功能比较丰富，有些比较简陋。</p><div class="note info"><p>需要注意的是： <strong><em>文件读写操作完成后，应该及时关闭</em></strong> 。一方面，<strong>文件对象会占用操作系统的资源</strong>；另外一方面，<strong>操作系统对同一时间能打开的文件描述符的数量是有限制的</strong>，在Linux操作系统上可以通过<code>ulimit -n</code> 来查看这个显示数量。如果<strong>不及时关闭文件，还可能会造成数据丢失</strong>。因为我将数据写入文件时，操作系统<strong>不会立刻把数据写入磁盘</strong>，而是先把数据放到内存缓冲区异步写入磁盘。当调用close方法时，操作系统会保证把没有写入磁盘的数据全部写到磁盘上，否则可能会丢失数据。</p></div><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><hr><p>我们先来看下在Python、PHP和C语言中打开文件的函数定义</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource fopen ( string $filename , string $mode [, bool $use_include_path = <span class="keyword">false</span> [, resource $context ]] )</span><br></pre></td></tr></table></figure><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>会发现以上3种编程语言内置的打开文件的方法接收的参数中，除了都包含一个“文件路径名称”，还会包含一个mode参数(C语言的open函数中的flags参数作用相似)。这么mode参数定义的是打开文件时的模式，常见的文件打开模式有：只读、只写、可读可写、只追加。不同的编程语言中对文件打开模式的定义有些微小的差别，我们来看下Python中的文件打开模式有哪些。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>文件打开模式</th><th>描述</th></tr></thead><tbody><tr><td><code>r</code></td><td>以<strong>只读模式</strong>打开文件，并将<strong>文件指针指向文件头</strong>；如果<strong>文件不存在会报错</strong></td></tr><tr><td><code>w</code></td><td>以<strong>只写模式</strong>打开文件，并将<strong>文件指针指向文件头</strong>；如果<strong>文件存在则将其内容清空</strong>，如果文件<strong>不存在则创建</strong></td></tr><tr><td><code>a</code></td><td>以<strong>只追加可写模式</strong>打开文件，并将<strong>文件指针指向文件尾部</strong>；如果<strong>文件不存在则创建</strong></td></tr><tr><td><code>r+</code></td><td>在<code>r</code>的基础上增加了可写功能</td></tr><tr><td><code>w+</code></td><td>在<code>w</code>的基础上增加了可读功能</td></tr><tr><td><code>a+</code></td><td>在<code>a</code>的基础上增加了可读功能</td></tr><tr><td><code>b</code></td><td><strong>读写二进制文件(默认是t，表示文本)</strong>，需要与上面几种模式搭配使用，如<code>ab</code>，<code>wb</code>, <code>ab</code>, <code>ab+</code>(POSIX系统，包括Linux都会忽略该字符)</td></tr></tbody></table><div class="note info"><p><strong><em>思考1：</em></strong> <code>r+</code>、<code>w+</code>和<code>a+</code>都可以实现对文件的读写，那么他们有什么区别呢？</p><ul><li><code>r+</code>会<strong>覆盖当前文件指针所在位置的字符</strong>，如原来文件内容是”<code>Hello，World</code>“，打开文件后写入”<code>hi</code>“则文件内容会变成”<code>hillo, World</code>“(因为 <strong><code>r</code>模式打开文件时文件指针指向文件头</strong>)</li><li><code>w+</code>与<code>r+</code>的不同是，<code>w+</code>在打开文件时就会<strong>先将文件内容清空</strong>，不知道它有什么用(<strong>感觉和单独的使用<code>w</code>模式没什么差别</strong>)</li><li><code>a+</code>与<code>r+</code>的不同是，<strong><code>a+</code>只能写到文件末尾</strong>(无论当前文件指针在哪里)</li></ul><p><br></p><p><strong><em>思考2：</em></strong> 为什么要定义这些模式呢？为什么不能像我们用word打开一篇文档一样既可以读，又可以写，还可修改呢？<br>关于这个问题，我查了很多资料，也没找到很权威的说明。在跟同行朋友交流过程中，发现大家主要有两种观点：</p><ul><li><strong>跟安全有关</strong> ，有这种观点的大部分是做运维的朋友，他们认为这就像linux上的rwx(读、写、执行)权限。</li><li><strong>跟操作系统内核管理I/O的机制有关</strong> ，有这种观点的大部分是做C开发的，特别是与内核相关的开发人员。为了提高读写速度，要写入磁盘的数据会先放进内存缓冲区，之后再回写。由于可能会同时打开很多文件，当要回写数据时，需要遍历以打开的文件判断是否需要回写。他们认为如果打开文件时指定了读写模式，那么需要回写时，只要去查找以“可写模式”打开的文件就可以了。</li></ul></div><h2 id="Python文件操作步骤示例"><a href="#Python文件操作步骤示例" class="headerlink" title="Python文件操作步骤示例"></a>Python文件操作步骤示例</h2><hr><p>我们来读取这样一个文本文件：song.txt，该文件的字符编码为<code>utf-8</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br></pre></td></tr></table></figure><h3 id="菜鸟实现-只是实现功能"><a href="#菜鸟实现-只是实现功能" class="headerlink" title="菜鸟实现(只是实现功能)"></a>菜鸟实现(只是实现功能)</h3><p>Python3实现：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：(以只读模式)打开文件</span></span><br><span class="line">f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：读取文件内容</span></span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p></p><p>这里说下Python2的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：(以只读模式)打开文件</span></span><br><span class="line">f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：读取文件内容</span></span><br><span class="line">print(f.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>Python3中已经内置对Unicode的支持，字符串str已经是真正的Unicode字符串。也就是说Python3中的文件读取方法已经自动完成了解码处理，因此无需再手动进行解码，可以直接将读取的文件中的内容进行打印；Python2中的字符串str是字节串，读取文件得到的也是字节串，在打印之前应该手动将其解码成Unicode字符串。关于这部分的说明，可以参考之前这篇文章<a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">&lt;&gt;</a>。</p><h3 id="中级实现"><a href="#中级实现" class="headerlink" title="中级实现"></a>中级实现</h3><p>在实现基本功能的前提下，考虑一些可能的意外因素。因为文件读写时都有可能产生IO错误(IOError)，一旦出错，后面包括<code>f.close()</code>在内的所有代码都不会执行了。因此我们要保证文件无论如何都能被关闭。那么可以用<code>try...finally</code>来实现，这实际上就是<code>try...except..finally</code>的简化版(我们只用Python3来进行示例演示)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">''</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;finally'</span>)</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;<span class="keyword">finally</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>输出结果说明，尽管with代码块中出现了异常，但是”&gt;&gt;&gt;&gt;&gt;&gt;finally“ 信息还是被打印了，说明finally代码块被执行，即文件关闭操作被执行。但是结果中错误信息还是被输出了，因此还是建议用一个完成的<code>try...except...finally</code>语句对异常信息进行捕获和处理。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免忘记或者为了避免每次都要手动关闭文件，我们可以使用<code>with</code>语句(一种语法糖，语法糖语句通常是为了简化某些操作而设计的)。with语句会在其代码块执行完毕之后自动关闭文件。因此我们可以这样来改写上面的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line">print(f.closed)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>是不是变得简介多了，代码结构也比较清晰了。<code>with</code>之后打印的<code>f.closed</code>属性值为<code>True</code>，说明文件确实被关闭了。</p><blockquote><p><strong>思考:</strong><br><strong>with语句会帮我们自动处理异常信息吗</strong>？</p></blockquote><p>要回答这个问题就要提到“上下文管理器” 和 with语句的工作流程。</p><p>with语句不仅仅可以用于文件操作，它实际上是一个很通用的结构，允许使用所谓的上下文管理器(context manager)。上下文管理器是一种支持<code>__enter__()</code>和<code>__exit__()</code>这两个方法的对象。<code>__enter__()</code>方法不带任何参数，它在进入with语句块的时候被调用，该方法的返回值会被赋值给as关键字之后的变量。<code>__exit__()</code>方法带有3个参数：<code>type(异常类型)</code>, <code>value(异常信息)</code>, <code>trace(异常栈)</code>，当<code>with</code>语句的代码块执行完毕或执行过程中因为异常而被终止都会调用<code>__exit__()</code>方法。正常退出时该方法的3个参数都为None，异常退出时该方法的3个参数会被分别赋值。如果<code>__exit__()</code>方法返回值(真值测试结果)为True则表示异常已经被处理，命令执行结果中就不会抛出异常信息了；反之，如果<code>__exit__()</code>方法返回值(真值测试结果)为False，则表示异常没有被处理并且会向外抛出该异常。</p><p>现在我们应该明白了，异常信息会不会被处理是由with后的语句返回对象的<code>__exit__()</code>方法决定的。文件可以被用作上下文管理器。它的<code>__enter__</code>方法返回文件对象本身，<code>__exit__</code>方法会关闭文件并返回None。我们看下file类中关于这两个方法的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">""" __enter__() -&gt; self. """</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *excinfo)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">""" __exit__(*excinfo) -&gt; None.  Closes the file. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可见，file类的<code>__exit__()</code>方法的返回值为None，None的真值测试结果为False，因此用于文件读写的with语句代码块中的异常信息还是会被抛出来，需要我们自己去捕获并处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面所说的<code>__exit__()</code>方法返回值(真值测试结果)为True则表示异常已经被处理，指的是<code>with</code>代码块中出现的异常。它对于<code>with</code>关键字之后的代码中出现的异常是不起作用的，因为还没有进入上下文管理器就已经发生异常了。<strong>因此，无论如何，还是建议在必要的时候在with语句外面套上一层<code>try...except</code>来捕获和处理异常</strong>。</p><p>有关“上下文管理器”这个强大且高级的特性的更多信息，请参看Python参考手册中的上下文管理器部分。或者可以在Python库参考中查看上下文管理器和contextlib部分。</p><h2 id="Python文件读取相关方法"><a href="#Python文件读取相关方法" class="headerlink" title="Python文件读取相关方法"></a>Python文件读取相关方法</h2><hr><p>我们知道，对文件的读取操作需要将文件中的数据加载到内存中，而上面所用到的read()方法会一次性把文件中所有的内容全部加载到内存中。这明显是不合理的，当遇到一个几个G的的文件时，必然会耗光机器的内存。这里我们来介绍下Python中读取文件的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>read()</code></td><td><strong>一次读取文件所有内容</strong>，返回一个<strong>str</strong></td></tr><tr><td><code>read(size)</code></td><td>每次最多读取指定长度的内容，返回一个<strong>str</strong>；在Python2中size指定的是字节长度，在Python3中size指定的是字符长度</td></tr><tr><td><code>readlines()</code></td><td>一次读取文件<strong>所有内容</strong>，按行返回一个<strong>list</strong></td></tr><tr><td><code>readline()</code></td><td>每次<strong>只读取一行</strong>内容</td></tr></tbody></table><p>此外，还要两个与<strong>文件指针位置相关的方法</strong>:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>seek(n)</code></td><td>将文件指针移动到指定字节的位置</td></tr><tr><td><code>tell()</code></td><td>获取当前文件指针所在字节位置</td></tr></tbody></table><p>下面来看下操作实例</p><h3 id="读取指定长度的内容"><a href="#读取指定长度的内容" class="headerlink" title="读取指定长度的内容"></a>读取指定长度的内容</h3><p><strong>Python2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">12</span>).decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年</span><br></pre></td></tr></table></figure><blockquote><p>结果说明：Python2中<code>read(size)</code>方法的size参数指定的要读取的字节数，而song.txt文件是<code>UTF-8</code>编码的内容，一个汉字占3个字节，因此12个字节刚好是4个汉字。</p></blockquote><p><strong>Python3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说</span><br></pre></td></tr></table></figure><blockquote><p>结果说明：Python3中read(size)方法的size参数指定的要读取的字符数，这与文件的字符编码无关，就是返回12个字符。</p></blockquote><h3 id="读取文件中的一行内容"><a href="#读取文件中的一行内容" class="headerlink" title="读取文件中的一行内容"></a>读取文件中的一行内容</h3><p><strong>Python2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readline())</span><br></pre></td></tr></table></figure><p><strong>Python3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readline().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>输出结果都一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br></pre></td></tr></table></figure><h3 id="遍历打印一个文件中的每一行"><a href="#遍历打印一个文件中的每一行" class="headerlink" title="遍历打印一个文件中的每一行"></a>遍历打印一个文件中的每一行</h3><p>这里我们只以Python3来进行实例操作，Python2仅仅是需要在读取到内容后进行手动解码而已，上面已经有示例。</p><p><strong>方式一：先一次性读取所有行到内存，然后再遍历打印</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line"></span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line"></span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line"></span><br><span class="line">只有等别人兑现</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这种方式的缺点与read()方法是一样的，都是会消耗大量的内存空间。</span><br><span class="line"></span><br><span class="line">**方式二：通过迭代器一行一行的读取并打印**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line"></span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line"></span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line"></span><br><span class="line">只有等别人兑现</span><br></pre></td></tr></table></figure><p>另外，发现上面的输出结果中行与行之间多了一个空行。这是因为文件每一行的默认都有换行符，而print()方法也会输出换行，因此就多了一个空行。去掉空行也比较简单：可以用<code>line.rstrip()</code>去除字符串右边的换行符，也可以通过print(line, end=’’)避免print方法造成的换行。</p><h3 id="将缓存区数据立刻写入文件-flush"><a href="#将缓存区数据立刻写入文件-flush" class="headerlink" title="将缓存区数据立刻写入文件-flush()"></a>将缓存区数据立刻写入文件-flush()</h3><p><code>flush()</code>方法的<strong>主要作用</strong>是刷新缓冲区数据，将<strong>缓冲区</strong>中的数据<strong>立刻写入</strong>文件或控制台；在我们平常当调用<code>write()</code>进行文件写入操作时，<strong>默认情况下，并没有立即将信息写入文件</strong>，而是<strong>先写入了缓冲区</strong>，当<strong>缓冲区满了以后才会写到文件中</strong>(<strong>这样可以保护磁盘</strong>，如果每次执行write就直接对磁盘进行操作，会缩短磁盘的寿命)，这就<strong>涉及到一个问题</strong>就是如果<strong>缓冲区没写满</strong>那存在缓冲区的数据怎么办？一种方法是直接调用<code>flush()</code>方法，将缓冲区的数据写入磁盘；另一种方法是执行文件的<code>close()</code>操作(前面的文件操作步骤也有提及)，这样可以把没有写入磁盘的数据全部写到磁盘上，这种方法实质上也是调用了<code>flush()</code>刷新缓存区数据。</p><p>接下来结合<code>print()</code>实例来对<code>flush()</code>进行进一步的学习，在学习之前还需要介绍一下Python的<code>print()</code>函数：</p><ul><li>其完整形式是<code>print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code></li><li>其中的<code>end</code>参数表示在字符串末尾增加的字符，默认情况下使用的是<code>&#39;\n&#39;</code>，也就是换行<br><strong>* 默认的输出位置</strong>是<code>sys.stdout</code>也就是控制台，<strong>可以将其设置为文件对象，那就是将结果输出到文件对象</strong></li><li><strong>默认情况下是不刷新缓存区数据的</strong>，即<code>flush=False</code></li></ul><p>所以实际上，在Python中使用<code>print()</code>输出到控制台实际上就是使用了<code>sys.stdout.write(str+&#39;\n&#39;)</code>(注意这里的<code>+&#39;\n&#39;</code>是和print的end是一致参数的)，其中也使用了<code>write()</code>方法，这也就说明其也涉及到了缓冲区(事实上<code>print()</code>还专门有flush参数).</p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 实时刷新，因为print输出的字符串以\n结束</span></span><br><span class="line">    <span class="comment"># sys.stdout检测到缓冲区内容以换行符结尾，它就会直接将缓冲区内容输出</span></span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>理想情况</strong>下，上述实例开始并不会输出任何内容，而在程序运行完成之后会<strong>一次性输出0、1、2、3、4(程序正常结束，刷新缓冲区)</strong>，但是实际上在程序运行过程中就会刷新，这是因为<code>sys.stdout</code>检测到缓冲区内容<strong>以换行符结尾，它就会直接将缓冲区内容输出</strong>，不需要显式调用<code>sys.stdout.flush()</code>方法；接下来我们将print的end设置为空或者其他字符：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 设置字符串在结尾为不添加换行符</span></span><br><span class="line">    <span class="comment"># 防止自动刷新缓冲区</span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">''</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p>这次和预想的一样，在程序运行完成之后才会刷新缓冲区，<strong>一次性输出0、1、2、3、4</strong>，接下来设置<code>sys.stdout.flush()</code>进行强制的刷新缓冲区：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># 强制刷新缓冲区</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p>这此和预期的结果也是相同的，随着程序的运行，一步一步的输出0、1、2、3、4.</p><div class="note success"><p><strong>总结一下缓冲区刷新的方式</strong>：</p><ul><li><code>flush()</code>强制刷新缓存区</li><li><strong>缓冲区满</strong>时，自动刷新</li><li><strong>文件关闭</strong>或者是<strong>程序结束</strong>自动刷新</li><li><strong>缓冲区中遇到换行符(<code>\n</code>)</strong>也会刷新</li></ul></div><hr><h3 id="file类的其他方法"><a href="#file类的其他方法" class="headerlink" title="file类的其他方法"></a>file类的其他方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>flush()</code></td><td>刷新缓冲区数据，将<strong>缓冲区</strong>中的数据<strong>立刻写入</strong>文件</td></tr><tr><td><code>next()</code></td><td>返回文件下一行，这个方法也是file对象实例可以被当做迭代器使用的原因</td></tr><tr><td><code>truncate([size])</code></td><td>截取文件中指定字节数的内容，并覆盖保存到文件中，如果不指定size参数则文件将被清空; Python2无返回值，Python3返回新文件的内容字节数</td></tr><tr><td><code>write(str)</code></td><td>将<strong>字符串写入文件</strong>，没有返回值</td></tr><tr><td><code>writelines(sequence)</code></td><td>向文件<strong>写入一个字符串</strong>或<strong>一个字符串列表</strong>，如果字符串列表中的元素需要换行要自己加入换行符</td></tr><tr><td><code>fileno()</code></td><td>返回一个整型的文件描述符，可以用于一些底层IO操作上(如，os模块的read方法)</td></tr><tr><td><code>isatty()</code></td><td>判断文件是否被连接到一个虚拟终端，是则返回True，否则返回False</td></tr></tbody></table><h2 id="文件读写与字符编码"><a href="#文件读写与字符编码" class="headerlink" title="文件读写与字符编码"></a>文件读写与字符编码</h2><hr><p>前面已经写过一篇介绍Python中字符编码的相关文件<a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">&lt;&gt;</a> 里面花了很大的篇幅介绍Python中字符串与字符编码的关系以及转换过程。其中谈到过两个指定的字符编码的地方，及其作用：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python两个指定编码位置.png" alt="Python两个指定编码位置.png"></p><ul><li><strong><em>PyCharm等IDE开发工具指定的项目工程和文件的字符编码：</em></strong> 它的主要作用是告诉Pycharm等IDE开发工具保存文件时应该将字符转换为怎样的字节表示形式，以及打开并展示文件内容时应该以什么字符编码将字节码转换为人类可识别的字符。</li><li><strong><em>Python源代码文件头部指定的字符编码，如<code>*-* coding:utf-8 -*-</code>：</em></strong> 它的主要作用是告诉Python解释器当前python代码文件保存时所使用的字符编码，Python解释器在执行代码之前，需要先从磁盘读取该代码文件中的字节然后通过这里指定的字符编码将其解码为unicode字符。Python解释器执行Python代码的过程与IDE开发工具是没有什么关联性的。</li></ul><p><strong>那么这里为什么又要谈起字符编码的问题呢？</strong></p><p>或者换个问法，既然从上面已经指定了字符编码，为什么对文件进行读写时还要指定字符编码呢？从前面的描述可以看出：上面两个地方指定的是Python代码文件的字符编码，是给Python解释器和Pycharm等程序软件用的；而<strong>被读写文件的字符编码与Python代码文件的字符编码没有必然联系，读写文件时指定的字符编码是给我们写的程序软件用的</strong>。这是不同的主体和过程，希望我说明白了。</p><p><strong>读写文件时怎样指定字符编码呢？</strong></p><p>上面解释了读写文件为什么要指定字符编码，这里要说下怎样指定字符编码(其实这里主要讨论是读取外部数据时的情形)。这个问题其实在上面的文件读取示例中已经使用过了，这里我们再详细的说一下。</p><p>首先，再次看一下Python2和Python3中open函数的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>可以看到，Python3的open函数中多了几个参数，其中包括一个encoding参数。是的，这个encoding就是用来指定被操作文件的字符编码的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.write(<span class="string">'你好'</span>))</span><br></pre></td></tr></table></figure><p>那么Python2中怎样指定呢？<strong>Python2中的对文件的read和write操作都是字节</strong>，也就说Python2中文件的read相关方法读取的是字节串(如果包含中文字符，会发现len()方法的结果不等于读取到的字符个数，而是字节数)。<strong>如果我们要得到正确的字符串</strong>，需要手动将读取到的结果<code>decode(解码)</code>为字符串；相反，要以特定的字符编码保存要写入的数据时，需要手动<code>encode(编码)</code>为字节串。这个<code>encode()</code>和<code>decode()</code>函数可以接收一个字符编码参数。<strong>Python3中read和write操作的都是字符串</strong>，实际上是Python解释器帮我们自动完成了写入时的<code>encode(编码)</code>和读取时的<code>decode(解码)</code>操作，因此我们只需要在打开文件(open函数)时指定字符编码就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song2.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># f.write(u'你好'.encode('utf-8'))</span></span><br><span class="line">    <span class="comment"># f.write('你好'.decode('utf-8').encode('utf-8'))</span></span><br><span class="line">    f.write(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure><p><strong>文件读写时有没有默认编码呢？</strong></p><p>Python3中<code>open</code>函数的<code>encoding</code>参数显然是可以不指定的，这时候就会用一个“默认字符编码”。<br>看下Python3中open函数文档对<code>encoding</code>参数的说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoding <span class="keyword">is</span> the name of the encoding used to decode <span class="keyword">or</span> encode the</span><br><span class="line">file. This should only be used <span class="keyword">in</span> text mode. The default encoding <span class="keyword">is</span></span><br><span class="line">platform dependent, but any encoding supported by Python can be</span><br><span class="line">passed.  See the codecs module <span class="keyword">for</span> the list of supported encodings.</span><br></pre></td></tr></table></figure><p>也就是说，<code>encoding</code>参数的默认值是与平台有关的，比如<code>Window</code>上默认字符编码为<code>GBK</code>，<code>Linux</code>上默认字符编码为<code>UTF-8</code>。</p><p>而对于Python2来说，在进行文件写操作时，字节会被直接保存；在进行文件读操作时，如果不手动进行来<code>decode</code>操作自然也就用不着默认字符编码了。但是这时候在不同的字符终端打印的时候，会用当前平台的字符编码自动将字节解码为字符，此时可能会出现乱码。如song.txt文件时<code>UTF-8</code>编码的，在<code>windows(字符编码为GBK)</code>的命令行终端进行如下操作就会出现乱码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    print(f.read())</span><br><span class="line">...</span><br><span class="line">鍖嗗寙閭ｅ勾鎴戜滑 绌剁珶璇翠簡鍑犻亶 鍐嶈涔嬪悗鍐嶆嫋寤?</span><br><span class="line">鍙儨璋佹湁娌℃湁 鐖辫繃涓嶆槸涓€鍦?涓冩儏涓婇潰鐨勯泟杈?</span><br><span class="line">鍖嗗寙閭ｅ勾鎴戜滑 涓€鏃跺寙蹇欐拏涓?闅句互鎵垮彈鐨勮瑷€</span><br><span class="line">鍙湁绛夊埆浜哄厬鐜</span><br></pre></td></tr></table></figure><p>我们应该尽可能的获取被操作文件的字符编码，并明确指定<code>encoding</code>参数的值。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a href="https://www.cnblogs.com/yyds/p/6186621.html" target="_blank" rel="noopener">Python之文件读写</a></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇转载的文章，主要包括&lt;code&gt;I/O操作概述&lt;/code&gt;、&lt;code&gt;文件读写实现原理与操作步骤&lt;/code&gt;、&lt;strong&gt;&lt;code&gt;文件打开模式及其区别&lt;/code&gt;&lt;/strong&gt;、&lt;code&gt;Python文件操作步骤示例&lt;/code&gt;、&lt;code&gt;Python文件读取相关方法&lt;/code&gt;以及 &lt;strong&gt;&lt;code&gt;文件读写与字符编码&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之sys-程序与python解释器的交互</title>
    <link href="http://showteeth.tech/posts/38877.html"/>
    <id>http://showteeth.tech/posts/38877.html</id>
    <published>2019-04-01T16:21:21.000Z</published>
    <updated>2019-04-03T01:55:17.561Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python的sys模块，其作用是<strong>程序与python解释器</strong>的交互；主要学习了其中的sys.argv、sys.modules、sys.path、sys.platform、sys.stdin、sys.stdout(附带一个实现百分比进度条的实例)以及sys.exit()</p></div><a id="more"></a><h2 id="sys模块简介"><a href="#sys模块简介" class="headerlink" title="sys模块简介"></a>sys模块简介</h2><p>sys模块主要是针对<strong>与Python解释器相关的变量和方法</strong>，<strong>不是主机操作系统(与os模块不同)</strong>。</p><hr><h2 id="主要属性和方法"><a href="#主要属性和方法" class="headerlink" title="主要属性和方法"></a>主要属性和方法</h2><table><thead><tr><th width="30%">属性及方法</th><th width="70%">使用说明</th></tr></thead><tbody><tr><td><code>sys.argv</code></td><td>获取命令行参数列表，第一个元素是程序本身</td></tr><tr><td><code>sys.exit(n)</code></td><td>退出Python程序，<strong>exit(0)表示正常退出</strong>。当参数非0时，会引发一个<code>SystemExit</code>异常，可以在程序中捕获该异常</td></tr><tr><td><code>sys.version</code></td><td>获取Python解释程器的版本信息</td></tr><tr><td><code>sys.maxsize</code></td><td>最大的Int值，64位平台是<code>2**63 - 1</code></td></tr><tr><td><code>sys.path</code></td><td>返回<strong>模块的搜索路径</strong>，初始化时使用PYTHONPATH环境变量的值</td></tr><tr><td><code>sys.platform</code></td><td>返回操作系统平台名称</td></tr><tr><td><code>sys.stdin</code></td><td>输入相关</td></tr><tr><td><code>sys.stdout</code></td><td>输出相关</td></tr><tr><td><code>sys.stderr</code></td><td>错误相关</td></tr><tr><td><code>sys.exc_info()</code></td><td>返回异常信息三元元组</td></tr><tr><td><code>sys.getdefaultencoding()</code></td><td><strong>获取系统当前编码，默认为utf-8</strong></td></tr><tr><td><code>sys.setdefaultencoding()</code></td><td><strong>设置系统的默认编码</strong></td></tr><tr><td><code>sys.getfilesystemencoding()</code></td><td><strong>获取文件系统使用编码方式，默认是utf-8</strong></td></tr><tr><td><code>sys.modules</code></td><td><strong>以字典的形式返回所有当前Python环境中已经导入的模块</strong></td></tr><tr><td><code>sys.builtin_module_names</code></td><td>返回一个列表，包含所有已经编译到Python解释器里的模块的名字</td></tr><tr><td><code>sys.copyright</code></td><td>当前Python的版权信息</td></tr><tr><td><code>sys.flags</code></td><td>命令行标识状态信息列表。只读。</td></tr><tr><td><code>sys.getrefcount(object)</code></td><td>返回对象的引用数量</td></tr><tr><td><code>sys.getrecursionlimit()</code></td><td>返回Python最大递归深度，默认1000</td></tr><tr><td><code>sys.getsizeof(object[, default])</code></td><td>返回对象的大小</td></tr><tr><td><code>sys.getswitchinterval()</code></td><td>返回线程切换时间间隔，默认0.005秒</td></tr><tr><td><code>sys.setswitchinterval(interval)</code></td><td>设置线程切换的时间间隔，单位秒</td></tr><tr><td><code>sys.getwindowsversion()</code></td><td>返回当前windwos系统的版本信息</td></tr><tr><td><code>sys.hash_info</code></td><td>返回Python默认的哈希方法的参数</td></tr><tr><td><code>sys.implementation</code></td><td>当前正在运行的Python解释器的具体实现，比如CPython</td></tr><tr><td><code>sys.thread_info</code></td><td>当前线程信息</td></tr></tbody></table><hr><p><br></p><h2 id="常用属性和方法实例"><a href="#常用属性和方法实例" class="headerlink" title="常用属性和方法实例"></a>常用属性和方法实例</h2><h3 id="脚本参数-sys-argv"><a href="#脚本参数-sys-argv" class="headerlink" title="脚本参数-sys.argv"></a>脚本参数-sys.argv</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,arg <span class="keyword">in</span> enumerate(sys.argv):</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"第%d个参数是：%s"</span> %(index,arg))</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python argv.py <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">  第<span class="number">0</span>个参数是：argv.py</span><br><span class="line">  第<span class="number">1</span>个参数是：<span class="number">1</span></span><br><span class="line">  第<span class="number">2</span>个参数是：<span class="number">2</span></span><br><span class="line">  第<span class="number">3</span>个参数是：<span class="number">3</span></span><br><span class="line">  第<span class="number">4</span>个参数是：<span class="number">4</span></span><br><span class="line">  第<span class="number">5</span>个参数是：<span class="number">5</span></span><br><span class="line">  第<span class="number">6</span>个参数是：<span class="number">6</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>该方法已经被<code>argparse</code>方法替换，<code>argparse</code>更加强大和简单易用，关于<code>argparse</code>可以参考<a href="http://showteeth.tech/posts/19941.html">这篇文章</a></li><li>不过这个<strong>获取任意数目参数的方法也还挺实用的</strong>，在<code>argparse</code>中可以使用<code>nargs=argparse.REMAINDER</code>将剩余的参数利用列表收集起来</li></ul></div><hr><h3 id="查看已经导入的模块-sys-modules"><a href="#查看已经导入的模块-sys-modules" class="headerlink" title="查看已经导入的模块-sys.modules"></a>查看已经导入的模块-sys.modules</h3><p><code>sys.modules</code><strong>保存有当前Python环境中已经导入的模块记录，这是一个全局字典，当Python启动后就加载在内存中</strong>。每当导入新的模块，<code>sys.modules</code>将自动记录该模块，当第二次试图再次导入该模块时，Python会先到这个字典中查找是否曾经导入过该模块，是则忽略，否则导入，从而<strong>加快了程序运行的速度</strong>。同时，它<strong>拥有字典的基本方法</strong>，例如<code>sys.modules.keys()</code><strong>查看字典的所有键</strong>，<code>sys.modules.values()</code>查看<strong>字典的所有值</strong>，<code>sys.modules[&#39;sys&#39;]</code><strong>查看sys键对应的值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有已经导入的模块</span></span><br><span class="line">sys.modules</span><br><span class="line">  <span class="comment"># 输出结果中会有很多模块，但是我只导入了sys模块</span></span><br><span class="line">  <span class="comment"># 可能是在python启动时就已经默认导入了很多必须的模块</span></span><br><span class="line">  &#123;<span class="string">'builtins'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'sys'</span>: &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'_frozen_importlib'</span>: &lt;module <span class="string">'_frozen_importlib'</span> (frozen)&gt;, ....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有的模块名</span></span><br><span class="line">sys.modules.keys()</span><br><span class="line">  <span class="comment"># 输出模块名</span></span><br><span class="line">  dict_keys([<span class="string">'builtins'</span>, <span class="string">'sys'</span>, <span class="string">'_frozen_importlib'</span>, <span class="string">'_imp'</span>, <span class="string">'_warnings'</span>, <span class="string">'_thread'</span>, <span class="string">'_weakref'</span>, <span class="string">'_frozen_importlib_external'</span>, <span class="string">'_io'</span>, <span class="string">'marshal'</span>, <span class="string">'posix'</span>, <span class="string">'zipimport'</span>, <span class="string">'encodings'</span>, <span class="string">'codecs'</span>, <span class="string">'_codecs'</span>...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有模块信息</span></span><br><span class="line">sys.modules.values()</span><br><span class="line">  <span class="comment"># 返回所有的模块信息</span></span><br><span class="line">  dict_values([&lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'_frozen_importlib'</span> (frozen)&gt;, &lt;module <span class="string">'_imp'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'_warnings'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'_thread'</span> (built-<span class="keyword">in</span>)&gt;, ...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  得到具体某个模块的信息</span></span><br><span class="line">sys.modules[<span class="string">'sys'</span>]</span><br><span class="line">  <span class="comment"># 查看sys模块的信息 </span></span><br><span class="line">  &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="模块搜索路径-sys-path"><a href="#模块搜索路径-sys-path" class="headerlink" title="模块搜索路径-sys.path"></a>模块搜索路径-sys.path</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path</span><br><span class="line">  <span class="comment"># 得到模块搜索路径 </span></span><br><span class="line">  [<span class="string">''</span>, <span class="string">'/home/user/miniconda3/lib/python36.zip'</span>, <span class="string">'/home/user/miniconda3/lib/python3.6'</span>, <span class="string">'/home/user/miniconda3/lib/python3.6/lib-dynload'</span>, <span class="string">'/home/user/miniconda3/lib/python3.6/site-packages'</span>]</span><br></pre></td></tr></table></figure><div class="note info"><p><code>sys.path</code>本质上是一个列表，可以进行<code>append</code>、<code>insert</code>、<code>pop</code>、<code>remove</code>等各种列表相关的操作，但<strong>通常都进行<code>append</code>操作，添加自己想要的查找路径</strong>.</p></div><hr><h3 id="操作系统平台名称-sys-platform"><a href="#操作系统平台名称-sys-platform" class="headerlink" title="操作系统平台名称-sys.platform"></a>操作系统平台名称-sys.platform</h3><table><thead><tr><th width="20%">操作系统</th><th width="80%">返回值</th></tr></thead><tbody><tr><td>Linux</td><td>'linux'</td></tr><tr><td>Windows</td><td>'win32'</td></tr><tr><td>Windows/Cygwin</td><td>'cygwin'</td></tr><tr><td>Mac OS X</td><td>'darwin'</td></tr></tbody></table><hr><h3 id="交互式输入-sys-stdin"><a href="#交互式输入-sys-stdin" class="headerlink" title="交互式输入-sys.stdin"></a>交互式输入-sys.stdin</h3><p><code>sys.stdin</code>返回一个”文件类型”对象，支持<code>read()</code>、<code>readline()</code>和<code>readlines()</code>等与文件读取相关的操作，就像使用<code>open()</code>打开的文件对象一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ctrl + d结束输入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=sys.stdin.read()</span><br><span class="line">asdfa</span><br><span class="line">asdfasd</span><br><span class="line">af</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'asdfa\nasdfasd\naf\n\n\n'</span></span><br></pre></td></tr></table></figure><p><strong><code>sys.stdin</code> 与 <code>input()</code></strong>：<br>当我们用<code>input(&#39;Please input something！&#39;)</code>时，事实上是<strong>先输出提示信息</strong>，<strong>然后捕获输入</strong>。 <strong>以下两组等价</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用input</span></span><br><span class="line">s = input(<span class="string">'Please input something！'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sys.stdin</span></span><br><span class="line">print(<span class="string">'Please input something！'</span>) </span><br><span class="line"><span class="comment"># -1 可以抛弃输入流中的'\n' 换行符</span></span><br><span class="line"><span class="comment"># 默认</span></span><br><span class="line">s = sys.stdin.readline()[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="打印输出-sys-stdout"><a href="#打印输出-sys-stdout" class="headerlink" title="打印输出-sys.stdout"></a>打印输出-sys.stdout</h3><p><strong><code>sys.stdout</code> 与 <code>print()</code></strong>:当我们<code>print(obj)</code>的时候，事实上是调用了<code>sys.stdout.write(obj+&#39;\n&#39;)</code>，将内容打印到控制台（默认是显示器），然后<strong>追加一个换行符</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两种方式等价的</span></span><br><span class="line">sys.stdout.write(<span class="string">'hello'</span>+<span class="string">'\n'</span>) </span><br><span class="line">print(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>从控制台重定向到文件</strong>：<strong>默认情况下<code>sys.stdout</code>指向控制台</strong>，如果把<strong>文件对象赋值给<code>sys.stdout</code></strong>，那么 <strong><code>print ()</code>调用的就是文件对象的<code>write()</code>方法</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件对象</span></span><br><span class="line">f_handler = open(<span class="string">'out.log'</span>, <span class="string">'w'</span>) </span><br><span class="line"><span class="comment"># 将文件对象赋值给sys.stdout</span></span><br><span class="line">sys.stdout = f_handler </span><br><span class="line"><span class="comment"># 调用print()实际上就是sys.stdout.write('hello'+'\n') </span></span><br><span class="line"><span class="comment"># 从而直接写入了文件中</span></span><br><span class="line">print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你无法在屏幕上看到hello</span></span><br><span class="line"><span class="comment"># 因为它被写到out.log文件里了</span></span><br></pre></td></tr></table></figure><p></p><p>如果你还想<strong>同时在控制台打印</strong>的话，最好<strong>先将原始的控制台对象引用保存下来</strong>，向<strong>文件中打印之后再恢复 <code>sys.stdout</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__console__ = sys.stdout    <span class="comment"># 保存控制台</span></span><br><span class="line"><span class="comment"># redirection start #       # 去干点别的，比如写到文件里</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="comment"># redirection end           # 干完别的了，恢复原来的控制台</span></span><br><span class="line">sys.stdout = __console__</span><br></pre></td></tr></table></figure><p></p><h3 id="利用sys-stdout实现百分比进度条"><a href="#利用sys-stdout实现百分比进度条" class="headerlink" title="利用sys.stdout实现百分比进度条"></a>利用sys.stdout实现百分比进度条</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># \r会影响flush()</span></span><br><span class="line">    <span class="comment"># 不加的话输出结果不会显示在同一行，也不会对齐</span></span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    <span class="comment"># 这里使用的是sys.stdout.write(r)</span></span><br><span class="line">    <span class="comment"># 也可以使用print(r,end='')</span></span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sys.stdout.write(r)</span></span><br><span class="line"><span class="comment"># 或者print(i,end='')</span></span><br><span class="line">[====================================================================================================]<span class="number">100</span>%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用print(i)</span></span><br><span class="line"><span class="comment"># sys.stdout.write(i+'\n') </span></span><br><span class="line">[                                                                                                    ]<span class="number">0</span>%</span><br><span class="line">[=                                                                                                   ]<span class="number">1</span>%</span><br><span class="line">[==                                                                                                  ]<span class="number">2</span>%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述两种输出结果的区别是换行和不换行的问题，print会默认打印换行，也就是end='\n'</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>这里涉及到了一个<code>flush()</code>的用法，具体讲解参考<a href="http://showteeth.tech/posts/57951.html">这篇文章</a></li><li>还涉及到<a href="http://showteeth.tech/posts/23402.html">Python3的<code>sys.stdout.write()</code>返回字符长度问题</a></li><li>也涉及到了<a href="http://showteeth.tech/posts/38536.html">Python覆盖之前输出的内容的问题</a></li></ul></div><hr><h3 id="程序退出状态-sys-exit-n"><a href="#程序退出状态-sys-exit-n" class="headerlink" title="程序退出状态-sys.exit(n)"></a>程序退出状态-sys.exit(n)</h3><ul><li><code>sys.exit(0)</code>：表示<strong>程序正常退出</strong></li><li><code>sys.exit(n)</code>：<strong>其中n不等于0</strong>表示<strong>程序非正常退出</strong></li><li>大部分的系统都要求n的取值范围是0-127</li></ul><p><strong>执行到主程序末尾，解释器自动退出(正常退出<code>sys.exit(0)</code>)</strong>；但是如果<strong>遇到异常</strong>需要<strong>中途退出程序</strong>，可以调用<code>sys.exit(n)</code>函数(其中的n不为0)，比如在运行之前先进行检查参数，如果不满足要求直接<code>sys.exit(1)</code>退出程序；如果<strong>不是遇到异常</strong>，而是普通的终止程序，可以使用<code>sys.exit(0)</code>正常退出程序。</p><p><strong>注意</strong>：可以传递给<code>sys.exit()</code>不仅仅是数字，<code>None</code>可以对应于上面的<code>0</code>，而其他可以<strong>输出内容</strong>或者<strong>标准错误输出</strong>的都可以对应于上面的<code>1</code>，例如 <code>sys.exit(&quot;some error message&quot;)</code>。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/54" target="_blank" rel="noopener">sys</a></li><li><a href="https://www.cnblogs.com/Archie-s/p/6860301.html" target="_blank" rel="noopener">python之sys模块详解</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python的sys模块，其作用是&lt;strong&gt;程序与python解释器&lt;/strong&gt;的交互；主要学习了其中的sys.argv、sys.modules、sys.path、sys.platform、sys.stdin、sys.stdout(附带一个实现百分比进度条的实例)以及sys.exit()&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之glob-文件名规则匹配</title>
    <link href="http://showteeth.tech/posts/24468.html"/>
    <id>http://showteeth.tech/posts/24468.html</id>
    <published>2019-04-01T16:14:52.000Z</published>
    <updated>2019-04-02T08:46:24.738Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Python中的常用模块<code>glob</code>，其作用是<strong>查找特定目录中符合匹配规则的文件(或目录)</strong>，主要包括三个函数：<code>glob.glob()</code>、<code>glob.iglob()</code>和<code>glob.escape()</code>，其中最主要的函数是<code>glob.glob()</code>，<code>glob.iglob()</code>和<code>glob.glob()</code>功能相似，但是<strong>返回的不再是列表而是迭代器对象</strong>，而<code>glob.escape()</code>主要是<strong>用来生成特殊字符匹配的pattern</strong>；在使用中<strong>需要注意通配符和正则表达式的区别</strong>。</p></div><a id="more"></a><h2 id="glob模块简介"><a href="#glob模块简介" class="headerlink" title="glob模块简介"></a>glob模块简介</h2><p><code>glob</code>模块是使用 <code>Unix shell</code> 规则去<strong>查找匹配模式的文件</strong>，<strong>返回的结果是无序的</strong>；在进行匹配时使用的是shell的通配符而不是正则表达式，关于正则表达式与通配符的区别，之前有过<a href="http://showteeth.tech/posts/37480.html">一篇文章</a>，如果忘记的话可以查看一下。</p><p><code>glob</code>模块其实也可以看做是<code>os</code>模块的补充，<code>os</code>模块中的<code>os.listdir()</code>可以列出某个目录下所有的文件和目录，但是这种列出是没有筛选性的，这在某些情况下并不是很适用，比如我想挑选出符合某个命名规则的文件，而<code>glob</code>模块就可以达到这个目的。</p><hr><h2 id="通配符规则"><a href="#通配符规则" class="headerlink" title="通配符规则"></a>通配符规则</h2><p>这里列出了glob模块支持的通配符规则(和shell的通配符规则有细微差别)：</p><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td><code>?</code></td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td><code>[char]</code></td><td>匹配<strong>原始字符char，相当于转义操作</strong></td><td>a[?]b：a与b之间<strong>只有一个字符且为<code>?</code></strong>,此时的<code>?</code>已经不再具有匹配任意一个字符的功能 如: a?b.txt</td></tr><tr><td><code>[list]</code></td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td><code>[!list]</code></td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr></tbody></table><hr><h2 id="返回所有匹配文件名-glob-glob"><a href="#返回所有匹配文件名-glob-glob" class="headerlink" title="返回所有匹配文件名-glob.glob()"></a>返回所有匹配文件名-glob.glob()</h2><p><strong>命令</strong>：<code>glob.glob(pathname, *, recursive=False)</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>pathname</code></strong>：绝对路径或者相对路径，可以包含通配符</li><li><strong><code>recursive</code></strong>：如果<code>recursive</code>是True，<strong>模式`</strong><code>会匹配任何文件以及0个或多个目录和子目录**；如果模式是</code>os.sep`，只有目录和子目录会被匹配；<strong>可以用于递归匹配目录和子目录的内容</strong></li></ul><h3 id="与os模块对比使用"><a href="#与os模块对比使用" class="headerlink" title="与os模块对比使用"></a>与os模块对比使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用os模块列出所有的文件</span></span><br><span class="line">os.listdir(<span class="string">'full_path'</span>)</span><br><span class="line">  [<span class="string">'a?c.txt'</span>, <span class="string">'abc.txt'</span>, <span class="string">'acc.txt'</span>, <span class="string">'adc.txt'</span>, <span class="string">'a[*]c.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用glob模块列出所有的文件</span></span><br><span class="line">glob.glob(<span class="string">'full_path/'</span>)</span><br><span class="line">  <span class="comment"># 没得到正确结果</span></span><br><span class="line">  [<span class="string">'full_path/'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'full_path/*'</span>)</span><br><span class="line">  [<span class="string">'full_path/a?c.txt'</span>, <span class="string">'full_path/abc.txt'</span>, \</span><br><span class="line">    <span class="string">'full_path/acc.txt'</span>, <span class="string">'full_path/adc.txt'</span>, <span class="string">'full_path/a[*]c.txt'</span>]</span><br></pre></td></tr></table></figure><div class="note info"><p>通过上面的示例我们可以看出<code>glob.glob()</code>和<code>os.listdir()</code>在使用和返回结果的区别：</p><ul><li><strong>使用方面</strong>：<code>os.listdir()</code>更为简单，<strong>只需要列出路径</strong>即可；而<code>glob.glob()</code>还<strong>需要设置通配符</strong>来达到匹配的目的</li><li><strong>返回结果方面</strong>：<code>os.listdir()</code>返回<strong>文件名称(不带路径)</strong>，而<code>glob.glob()</code>会返回<strong>文件名称+路径</strong>(和指定的路径相同模式，指定时使用绝对路径，返回结果前也是绝对路径，指定时使用相对路径，返回结果前也是相对路径)</li></ul></div><hr><h3 id="匹配任意一个或多个字符"><a href="#匹配任意一个或多个字符" class="headerlink" title="*-匹配任意一个或多个字符"></a>*-匹配任意一个或多个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配任意一个或多个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a*c.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回只要是以a开头、以c结尾的文件名，具体中间字符的数量没有限制</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abbc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配任意单个字符"><a href="#匹配任意单个字符" class="headerlink" title="?-匹配任意单个字符"></a>?-匹配任意单个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配任意单个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 如果不想输出以a开头、以c结尾并且中间包含两个以上字符的文件名，可以使用?</span></span><br><span class="line">  <span class="comment"># 表示中间只有任意一个字符，abbc.txt就不符合条件了</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="[]-匹配特殊字符"></a>[]-匹配特殊字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配单个特殊字符</span></span><br><span class="line">glob.glob(<span class="string">'./a[?]c.txt'</span>)</span><br><span class="line"> <span class="comment"># 如果文件名中含有特殊字符，比如这里的?</span></span><br><span class="line"> <span class="comment"># 对其进行匹配可以使用[] </span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'./a\?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 不同于shell可以使用\进行转义，这里转义后不能正确匹配</span></span><br><span class="line">  []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里是单个字符，不能匹配得到多个的情况</span></span><br><span class="line"><span class="comment"># 如果需要匹配多个，可以重复使用</span></span><br><span class="line">glob.glob(<span class="string">'./a[?][?]c.txt'</span>)</span><br><span class="line">  [<span class="string">'./a??c.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配得到单个和多个特殊字符的</span></span><br><span class="line">glob.glob(<span class="string">'./a[?]*c.txt'</span>)</span><br><span class="line">  <span class="comment"># 注意这的*不是任意多个前一个字符(正则表达式中的定义)</span></span><br><span class="line">  <span class="comment"># 因为*可以匹配任意字符，?也不例外，前面使用了[?]作为限制</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./a??c.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配字符范围"><a href="#匹配字符范围" class="headerlink" title="[]-匹配字符范围"></a>[]-匹配字符范围</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配字符范围，同样是单个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a[b-d]c.txt'</span>)</span><br><span class="line">  <span class="comment"># a和c之间存在一个字符，且该字符的范围是b-d</span></span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不能表示为范围，可以单独列出字符的范围</span></span><br><span class="line">glob.glob(<span class="string">'./a[bcd]c.txt'</span>)</span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="char-排除字符"><a href="#char-排除字符" class="headerlink" title="[!char]-排除字符"></a>[!char]-排除字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配中间字符不为b的文件</span></span><br><span class="line">glob.glob(<span class="string">'./a[!b]c.txt'</span>)</span><br><span class="line">  <span class="comment"># 排除了abc.txt</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="递归匹配子目录内容"><a href="#递归匹配子目录内容" class="headerlink" title="递归匹配子目录内容"></a>递归匹配子目录内容</h3><p>上述方法都是常用的匹配当前目录文件名的方法，如果<strong>还想要匹配子目录的内容</strong>，上述方法是显然不行的：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建子目录sub_dir，包含如下几个文件</span></span><br><span class="line">abbc.txt  abc.txt  acc.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果也想匹配出上面列出的文件</span></span><br><span class="line"><span class="comment"># 单纯的使用如下命令是不行的</span></span><br><span class="line">glob.glob(<span class="string">'./*'</span>)</span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abcd.txt'</span>, <span class="string">'./wre.txt'</span>, <span class="string">'./abbc.txt'</span>, <span class="string">'./a??c.txt'</span>, <span class="string">'./sub_dir'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样使用如下命令也不行</span></span><br><span class="line">glob.glob(<span class="string">'./*/*'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 只会得到子目录下的文件</span></span><br><span class="line">  [<span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>, <span class="string">'./sub_dir/abbc.txt'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是真正的做法就需要使用前面提到的recursive参数</span></span><br><span class="line">glob.glob(<span class="string">'./**'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"> <span class="comment"># 得到当前目录和子目录下所有文件</span></span><br><span class="line">  [<span class="string">'./'</span>, <span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abcd.txt'</span>, <span class="string">'./wre.txt'</span>, <span class="string">'./abbc.txt'</span>, <span class="string">'./a??c.txt'</span>, <span class="string">'./sub_dir'</span>, <span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>, <span class="string">'./sub_dir/abbc.txt'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'./**/a[b-d]c.txt'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 得到当前目录和子目录下所有符合pattern的文件</span></span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有的目录和子目录</span></span><br><span class="line">glob.glob(<span class="string">'./**/'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  [<span class="string">'./'</span>, <span class="string">'./sub_dir/'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="开头文件的匹配"><a href="#开头文件的匹配" class="headerlink" title=".开头文件的匹配"></a>.开头文件的匹配</h3><p><strong>如果目录中包含以<code>.</code>开头的文件，默认情况下不会对其进行匹配(使用<code>*</code>也达不到目的)，如果想要匹配需要显式指定<code>.</code></strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">  <span class="comment"># 不会匹配出.开头的 </span></span><br><span class="line">  [<span class="string">'card.gif'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'.c*'</span>)</span><br><span class="line">  <span class="comment"># 显式指定.，匹配出以.开头的文件</span></span><br><span class="line">  [<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="返回所有匹配文件名的迭代器-glob-iglob"><a href="#返回所有匹配文件名的迭代器-glob-iglob" class="headerlink" title="返回所有匹配文件名的迭代器-glob.iglob()"></a>返回所有匹配文件名的迭代器-glob.iglob()</h2><p><strong>命令</strong>：glob.iglob(pathname, *, recursive=False)</p><p><strong>参数</strong>：和前面的glob.glob()相同</p><p><strong>使用实例</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和glob的用法相同，只是会返回一个迭代器</span></span><br><span class="line">glob.iglob(<span class="string">'./*.txt'</span>)</span><br><span class="line">  <span class="comment"># 输出一个迭代器对象</span></span><br><span class="line">  &lt;generator object _iglob at <span class="number">0x7fa8dd9022b0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到具体的结果可以使用循环</span></span><br><span class="line">f=glob.iglob(<span class="string">'./*.txt'</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">   <span class="comment"># 遍历这个迭代器对象</span></span><br><span class="line">   <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  ./a?c.txt</span><br><span class="line">  ./abc.txt</span><br><span class="line">  ./acc.txt</span><br><span class="line">  ./adc.txt</span><br><span class="line">  ./abcd.txt</span><br><span class="line">  ./wre.txt</span><br><span class="line">  ./abbc.txt</span><br><span class="line">  ./a??c.txt</span><br></pre></td></tr></table></figure><p></p><p>其他用法参考<code>glob.glob()</code>。</p><hr><p><br></p><h2 id="转义元字符-glob-escape"><a href="#转义元字符-glob-escape" class="headerlink" title="转义元字符-glob.escape()"></a>转义元字符-glob.escape()</h2><p>前面提到了如果想要<strong>匹配一些特殊字符</strong>，如<code>?</code>可以<strong>使用<code>[]</code>将其括起来的方式表示原始字符</strong>，不进行通配，这里glob还专门提供了一个方法<code>glob.escape()</code>来达到上述的目的，其<strong>返回的是一个构造好的pattern，其中的特殊字符都会被<code>[]</code>括起来</strong>。</p><p>特殊的字符主要包括三个：<code>?</code>、<code>*</code>和<code>[</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回构造好的pattern</span></span><br><span class="line">glob.escape(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 和自己加[]效果是一样的 </span></span><br><span class="line">  <span class="string">'./a[?]c.txt'</span></span><br><span class="line"></span><br><span class="line">pattern=glob.escape(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">glob.glob(pattern)</span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/glob.html" target="_blank" rel="noopener">glob — Unix style pathname pattern expansion</a></li><li><a href="https://learnku.com/docs/pymotw/glob-file-name-rule-matching/3393" target="_blank" rel="noopener">7.4. glob — 文件名规则匹配</a></li><li><a href="https://www.jianshu.com/p/542e55b29324" target="_blank" rel="noopener">[Python] glob 模块(查找文件路径)</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Python中的常用模块&lt;code&gt;glob&lt;/code&gt;，其作用是&lt;strong&gt;查找特定目录中符合匹配规则的文件(或目录)&lt;/strong&gt;，主要包括三个函数：&lt;code&gt;glob.glob()&lt;/code&gt;、&lt;code&gt;glob.iglob()&lt;/code&gt;和&lt;code&gt;glob.escape()&lt;/code&gt;，其中最主要的函数是&lt;code&gt;glob.glob()&lt;/code&gt;，&lt;code&gt;glob.iglob()&lt;/code&gt;和&lt;code&gt;glob.glob()&lt;/code&gt;功能相似，但是&lt;strong&gt;返回的不再是列表而是迭代器对象&lt;/strong&gt;，而&lt;code&gt;glob.escape()&lt;/code&gt;主要是&lt;strong&gt;用来生成特殊字符匹配的pattern&lt;/strong&gt;；在使用中&lt;strong&gt;需要注意通配符和正则表达式的区别&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title> Python系列之shutil-高级文件操作</title>
    <link href="http://showteeth.tech/posts/51574.html"/>
    <id>http://showteeth.tech/posts/51574.html</id>
    <published>2019-04-01T00:11:24.000Z</published>
    <updated>2019-04-03T00:41:21.674Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python中用来进行<strong>高级文件操作</strong>的模块<code>shutil</code>，其主要包括文件或者目录的<strong>赋值</strong>、<strong>删除</strong>、<strong>剪切</strong>以及<strong>压缩和解压缩操作</strong>，是对上一个学习的<a href="http://showteeth.tech/posts/24368.html">os模块</a>功能的补充。</p></div><a id="more"></a><h2 id="shutil简介"><a href="#shutil简介" class="headerlink" title="shutil简介"></a>shutil简介</h2><p>前面已经学习了<strong>os模块中的常用目录及文件操作</strong>，虽然其中有很多非常强大的功能，但是<strong>其中也有一些需要补足的地方</strong>，比如<strong>删除非空文件夹(这个是os模块不能直接做到的)、文件复制</strong>等，基于上述的补足，这里学习一下Python中高级文件操作的模块shutil，注意高级文件操作是Python官方给的名称，不是我直接编出来的，所以可见这个模块的强大。从主要功能上来看<strong>shutil模块是对os模块的补充</strong>，主要针对文件的<code>拷贝</code>、<code>删除</code>、<code>移动</code>、<code>压缩</code>和<code>解压</code>操作。</p><hr><h2 id="高级文件目录管理"><a href="#高级文件目录管理" class="headerlink" title="高级文件目录管理"></a>高级文件目录管理</h2><h3 id="复制文件内容到另一个文件"><a href="#复制文件内容到另一个文件" class="headerlink" title="复制文件内容到另一个文件"></a>复制文件内容到另一个文件</h3><p><strong>命令</strong>：<code>shutil.copyfileobj(fsrc, fdst[, length=16*1024])</code>，其中的<code>fsrc</code>和<code>fdst</code>都是<code>file-like object</code>(使用<code>open()</code>方法打开后的文件对象)。</p><p><strong>功能</strong>：copy文件内容(部分或全部)到另一个文件(<strong>从fsrc复制到fdst中</strong>)，<strong>可以copy指定大小的内容</strong>，默认的大小为<code>16*1024</code>；<strong>如果length设置为负值</strong>，则会<strong>读取整个文件内容</strong>，而不是以块的方式进行迭代读取；<mark>fdst文件是清空重写还是追加写入需要开文件的打开模式</mark></p><p><strong>程序的源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyfileobj</span><span class="params">(fsrc, fdst, length=<span class="number">16</span>*<span class="number">1024</span>)</span>:</span></span><br><span class="line">    <span class="string">"""copy data from file-like object fsrc to file-like object fdst"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 程序的核心是这个read()</span></span><br><span class="line">        buf = fsrc.read(length)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buf:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        fdst.write(buf)</span><br></pre></td></tr></table></figure><p></p><p>看了上述源码，发现很多问题就很简单了，包括从什么写入什么，read()参数的理解等等，所以说<strong>看源码才是王道啊</strong>！</p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source文件内容</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"><span class="comment"># destination文件内容</span></span><br><span class="line">this <span class="keyword">is</span> destination file!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># source文件使用mode r读取打开</span></span><br><span class="line">s =open(<span class="string">'source.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># destination文件使用mode w写入打开</span></span><br><span class="line"><span class="comment"># w模式打开会清空文件内容</span></span><br><span class="line"><span class="comment"># 如果需要写入文件，可以使用a模式打开</span></span><br><span class="line">d=open(<span class="string">'target.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，从source文件复制到destination文件</span></span><br><span class="line">shutil.copyfileobj(s,d,length=<span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 由于前面使用了w模式打开文件，所以文件内容被清空了</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用追加模式打开destination文件</span></span><br><span class="line">d=open(<span class="string">'target.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line">shutil.copyfileobj(s,d,length=<span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 由于前面使用了a模式打开文件，所以source文件内容是追加在后面</span></span><br><span class="line">this <span class="keyword">is</span> target file!</span><br><span class="line">this <span class="keyword">is</span> source file!</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>部分或者全部复制</strong>：Note that if the <strong>current file position of the fsrc object is not 0</strong>, <strong>only the contents from the current file position to the end of the file will be copied</strong>.</li><li><code>fdst</code>文件是<strong>清空重写(w模式)</strong>还是<strong>追加写入(a模式)</strong>需要开文件的打开模式</li></ul></div><hr><h3 id="复制整个文件内容到另一个文件"><a href="#复制整个文件内容到另一个文件" class="headerlink" title="复制整个文件内容到另一个文件"></a>复制整个文件内容到另一个文件</h3><p><strong>命令</strong>：<code>shutil.copyfile(src, dst)</code>，和上一个命令比较相似，<strong>不同于上一个命令的是src和dst是字符串形式的文件路径而不是文件对象</strong>，也就是说使用之前不用open()。</p><p><strong>功能</strong>：拷贝整个文件(src)内容到另一个文件(dst)；如果source文件和destination<strong>文件是相同</strong>的，则会<strong>产生错误</strong>，同时<strong>destination文件必须是可写</strong>的，<strong>不然也会报错</strong>；同时<mark>需要注意如果目标文件destination中有内容，执行操作后会覆盖</mark>。</p><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyfile</span><span class="params">(src, dst, *, follow_symlinks=True)</span>:</span></span><br><span class="line">    <span class="string">"""Copy data from src to dst.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If follow_symlinks is not set and src is a symbolic link, a new</span></span><br><span class="line"><span class="string">    symlink will be created instead of copying the file it points to.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断文件是否相同，如果相同就报错</span></span><br><span class="line">    <span class="keyword">if</span> _samefile(src, dst):</span><br><span class="line">        <span class="keyword">raise</span> SameFileError(<span class="string">"&#123;!r&#125; and &#123;!r&#125; are the same file"</span>.format(src, dst))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> [src, dst]:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            st = os.stat(fn)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="comment"># File most likely does not exist</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># XXX What about other special files? (sockets, devices...)</span></span><br><span class="line">            <span class="keyword">if</span> stat.S_ISFIFO(st.st_mode):</span><br><span class="line">                <span class="keyword">raise</span> SpecialFileError(<span class="string">"`%s` is a named pipe"</span> % fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks <span class="keyword">and</span> os.path.islink(src):</span><br><span class="line">        os.symlink(os.readlink(src), dst)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(src, <span class="string">'rb'</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">            <span class="comment"># 这里的打开模式需要注意，会清空原始的target的文件内容</span></span><br><span class="line">            <span class="keyword">with</span> open(dst, <span class="string">'wb'</span>) <span class="keyword">as</span> fdst:</span><br><span class="line">                <span class="comment"># 调用了前面提到的shutil.copyfileobj</span></span><br><span class="line">                copyfileobj(fsrc, fdst)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source文件内容</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"><span class="comment"># destination文件内容</span></span><br><span class="line">this <span class="keyword">is</span> destination file!</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 先修改工作目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，从source文件复制到destination文件</span></span><br><span class="line">shutil.copyfile(<span class="string">'source.txt'</span>,<span class="string">'target.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 可见原始的文件内容被清空了</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>全部复制</strong>，<strong>目标文件的原有内容会被清空</strong>，可以从源码中文件的打开模式看出</li><li><strong>传递的是表示文件地址的字符串</strong>，而不是像前面的<code>shutil.copyfileobj(fsrc, fdst[, length=16*1024])</code>传递的是文件对象</li></ul></div><hr><h3 id="仅复制权限"><a href="#仅复制权限" class="headerlink" title="仅复制权限"></a>仅复制权限</h3><p><strong>命令</strong>：<code>shutil.copymode(src, dst)</code>：<strong>仅拷贝权限</strong>，内容、组、用户均不变；<strong>src和dst是字符串形式的文件路径而不是文件对象</strong></p><hr><h3 id="仅复制状态信息"><a href="#仅复制状态信息" class="headerlink" title="仅复制状态信息"></a>仅复制状态信息</h3><p><strong>命令</strong>：<code>shutil.copystat(src, dst)</code>：<strong>仅复制所有的状态信息，包括权限，组，用户，修改时间等</strong>；<strong>src和dst是字符串形式的文件路径而不是文件对象</strong></p><h3 id="复制文件内容和权限"><a href="#复制文件内容和权限" class="headerlink" title="复制文件内容和权限"></a>复制文件内容和权限</h3><p><strong>命令</strong>：<code>shutil.copy(src,dst)</code>：</p><ul><li><strong>同时复制文件的内容以及权限</strong></li><li><strong>相当于先copyfile()然后copymode()</strong></li><li>如果<strong>dst是一个目录</strong>，一个和src文件的basename相同的文件会被创建(或重写)；</li><li><strong>src和dst是字符串形式的文件路径而不是文件对象</strong></li></ul><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(src, dst, *, follow_symlinks=True)</span>:</span></span><br><span class="line">    <span class="string">"""Copy data and mode bits ("cp src dst"). Return the file's destination.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The destination may be a directory.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If follow_symlinks is false, symlinks won't be followed. This</span></span><br><span class="line"><span class="string">    resembles GNU's "cp -P src dst".</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If source and destination are the same file, a SameFileError will be</span></span><br><span class="line"><span class="string">    raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断，如果dst是一个目录，就使用src的basename创建文件</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(dst):</span><br><span class="line">        dst = os.path.join(dst, os.path.basename(src))</span><br><span class="line">    copyfile(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">    copymode(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 先修改工作目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，其中的dst为目录</span></span><br><span class="line">shutil.copy(<span class="string">'source.txt'</span>,<span class="string">'old_name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在old_name目录下生成了source.txt文件，和src名称相同，而且内容也相同</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="复制文件内容和状态"><a href="#复制文件内容和状态" class="headerlink" title="复制文件内容和状态"></a>复制文件内容和状态</h3><p><strong>命令</strong>：<code>shutil.copy2(src, dst)</code>：与copy函数功能大部分一致，<strong>只是会把所有的文件元数据()都复制(copymode-&gt;copystat)</strong>；同时<strong>复制文件的内容</strong>以及<strong>文件的所有状态信息</strong>；相当于先<code>copyfile()</code>后<code>copystat()</code>；元数据的复制是通过<code>shutil.copystat(src, dst)</code>来完成；</p><p><strong>补充(元数据的定义)</strong>：主要是<strong>描述数据属性(property)的信息</strong>，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能，<strong>是一种数据的数据</strong>，更多关于元数据可以看<a href="https://www.cnblogs.com/XWShuai/p/5936531.html" target="_blank" rel="noopener">这篇文章</a>。</p><hr><h3 id="排除指定的文件"><a href="#排除指定的文件" class="headerlink" title="排除指定的文件"></a>排除指定的文件</h3><p><strong>命令</strong>：<code>shutil.ignore_patterns(*patterns)</code>：接收<strong>一个或多个通配符字符串</strong>，然后<strong>创建</strong>一个可以被<strong>传递给shutil.copytree()方法的’ignore’参数</strong>的<strong>函数</strong>；当文件名与指定的通配符匹配时，则不会被赋值，也就是<strong>排除指定的文件</strong>。</p><hr><h3 id="递归复制目录和子目录"><a href="#递归复制目录和子目录" class="headerlink" title="递归复制目录和子目录"></a>递归复制目录和子目录</h3><p><strong>命令</strong>：<code>shutil.copytree(src, dst, symlinks=False, ignore=None)</code>：</p><ul><li><strong>递归</strong>地复制<strong>src目录及其子目录</strong>的<strong>文件</strong>和<strong>状态信息</strong>到目标<strong>目录dst</strong></li><li><strong>目标目录dst必须是不存在的</strong></li><li>如果目标目录的<strong>父目录不存在</strong>，则会<strong>一同创建</strong></li><li>目录的<strong>权限和时间</strong>通过<code>shutil.copystat()</code>来拷贝，<strong>单个文件</strong>通过<code>shutil.copy2()</code>来拷贝</li></ul><p><strong>参数</strong>：</p><ul><li><strong><code>symlinks</code>参数</strong>：指定是否复制软链接(小心陷入死循环)，<strong>如果为true</strong>，则以链接的形式进行复制；<strong>如果为false或者默认情况下</strong>，则会将链接文件的内容进行复制</li><li><strong><code>ignore</code>参数</strong>：指定<strong>不参与复制的文件</strong>，其值应该是一个<code>ignore_patterns()</code>方法；也是<strong>递归的ignore</strong>，每个目录下的符合ignore的都会被忽略，因为这个参数是传递给<code>copytree</code>的，而<code>copytree</code>是递归调用的</li></ul><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False, ignore=None, copy_function=copy2,</span></span></span><br><span class="line"><span class="function"><span class="params">             ignore_dangling_symlinks=False)</span>:</span></span><br><span class="line">    <span class="string">"""Recursively copy a directory tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The destination directory must not already exist.</span></span><br><span class="line"><span class="string">    If exception(s) occur, an Error is raised with a list of reasons.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the optional symlinks flag is true, symbolic links in the</span></span><br><span class="line"><span class="string">    source tree result in symbolic links in the destination tree; if</span></span><br><span class="line"><span class="string">    it is false, the contents of the files pointed to by symbolic</span></span><br><span class="line"><span class="string">    links are copied. If the file pointed by the symlink doesn't</span></span><br><span class="line"><span class="string">    exist, an exception will be added in the list of errors raised in</span></span><br><span class="line"><span class="string">    an Error exception at the end of the copy process.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can set the optional ignore_dangling_symlinks flag to true if you</span></span><br><span class="line"><span class="string">    want to silence this exception. Notice that this has no effect on</span></span><br><span class="line"><span class="string">    platforms that don't support os.symlink.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The optional ignore argument is a callable. If given, it</span></span><br><span class="line"><span class="string">    is called with the `src` parameter, which is the directory</span></span><br><span class="line"><span class="string">    being visited by copytree(), and `names` which is the list of</span></span><br><span class="line"><span class="string">    `src` contents, as returned by os.listdir():</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        callable(src, names) -&gt; ignored_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Since copytree() is called recursively, the callable will be</span></span><br><span class="line"><span class="string">    called once for each directory that is copied. It returns a</span></span><br><span class="line"><span class="string">    list of names relative to the `src` directory that should</span></span><br><span class="line"><span class="string">    not be copied.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The optional copy_function argument is a callable that will be used</span></span><br><span class="line"><span class="string">    to copy each file. It will be called with the source path and the</span></span><br><span class="line"><span class="string">    destination path as arguments. By default, copy2() is used, but any</span></span><br><span class="line"><span class="string">    function that supports the same signature (like copy()) can be used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># names中存储了目录所有文件的列表---不能区分文件或者目录</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    <span class="keyword">if</span> ignore <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        ignored_names = ignore(src, names)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ignored_names = set()</span><br><span class="line">    <span class="comment"># 这里是os.makedirs，所以是递归创建目录的，也就是可以创建父目录</span></span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="comment"># 判断是不是复制ignore的条件，符合就直接进行下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> ignored_names:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                <span class="comment"># 函数传递的参数</span></span><br><span class="line">                <span class="keyword">if</span> symlinks:</span><br><span class="line">                    <span class="comment"># We can't just leave it to `copy_function` because legacy</span></span><br><span class="line">                    <span class="comment"># code with a custom `copy_function` may rely on copytree</span></span><br><span class="line">                    <span class="comment"># doing the right thing.</span></span><br><span class="line">                    os.symlink(linkto, dstname)</span><br><span class="line">                    copystat(srcname, dstname, follow_symlinks=<span class="keyword">not</span> symlinks)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># ignore dangling symlink if the flag is on</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(linkto) <span class="keyword">and</span> ignore_dangling_symlinks:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># otherwise let the copy occurs. copy2 will raise an error</span></span><br><span class="line">                    <span class="keyword">if</span> os.path.isdir(srcname):</span><br><span class="line">                        <span class="comment"># 这部分是递归复制</span></span><br><span class="line">                        copytree(srcname, dstname, symlinks, ignore,</span><br><span class="line">                                 copy_function)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        copy_function(srcname, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks, ignore, copy_function)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Will raise a SpecialFileError for unsupported file types</span></span><br><span class="line">                copy_function(srcname, dstname)</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># Copying file access times may fail on Windows</span></span><br><span class="line">        <span class="keyword">if</span> getattr(why, <span class="string">'winerror'</span>, <span class="keyword">None</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            errors.append((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略pyc文件和tmp文件</span></span><br><span class="line"><span class="comment"># 注意destination肯定是不存在的</span></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br><span class="line">copytree(<span class="string">'folder1'</span>, <span class="string">'folder2'</span>, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制链接，不是复制链接指向文件的内容</span></span><br><span class="line">copytree(<span class="string">'f1'</span>, <span class="string">'f2'</span>, symlinks=<span class="keyword">True</span>, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="递归删除"><a href="#递归删除" class="headerlink" title="递归删除"></a>递归删除</h3><p><strong>命令</strong>：<code>shutil.rmtree(path[, ignore_errors[, onerror]])</code>，<strong>递归地删除目录(path，不能为链接目录)及子目录内的文件</strong>。注意！该方法不会询问yes或no，被删除的文件也不会出现在回收站里，<strong>请务必小心</strong>！</p><p><strong>参数</strong>：</p><ul><li><strong><code>path</code></strong>：指定目录，但不能是链接指向的目录，传递的是<strong>字符串形式的文件路径而不是文件对象</strong></li><li><strong><code>ignore_errors</code></strong>：设置为true，删除过程中的出错不会被抛出，会被忽略；如果为false或者忽略这个参数，删除过程中的错误会调用onerror中的错误处理方式进行处理，如果<code>onerror</code>中没有定义处理方式，就会抛出错误。</li><li><strong>onerror</strong>：一旦提供这个参数，就必须有三个参数<code>function</code>、<code>path</code>和<code>excinfo</code>.<ul><li><code>function</code>：抛出异常的函数，是<code>os.path.islink()</code>、<code>os.listdir()</code>、 <code>os.remove()</code>或者<code>os.rmdir()</code></li><li><code>path</code>：传递给function参数的path名</li><li><code>excinfo</code>：<code>sys.exc_info()</code>返回的异常信息</li><li><code>onerror</code>的异常不会被捕获</li></ul></li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="comment"># 去除文件的只读属性，尝试再次删除</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    <span class="comment"># 这里的func是针对前面抛出异常的操作</span></span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>需要注意的方面</strong>：<br><strong>删除路径的最后一个目录，而不是整个路径</strong>，例如<code>shutil.rmtree(&#39;user/tester/noob&#39;)</code>只会删除最后的<code>noob</code>目录的所有内容，而不会将整个路径<code>&#39;user/tester/noob&#39;</code>包含的文件夹都删除，参考<a href="https://stackoverflow.com/questions/10873364/shutil-rmtree-clarification" target="_blank" rel="noopener">这个链接</a>。</p></div><hr><h3 id="剪切目录"><a href="#剪切目录" class="headerlink" title="剪切目录"></a>剪切目录</h3><p><strong>命令</strong>：<code>shutil.move(src, dst)</code>，递归地移动文件或者目录，类似<code>mv</code>命令；如果destination是一个已经存在的目录，src会直接移动到这个目录中；如果destination已经存在但不是一个目录，destination将会被重写；如果是同一个文件或者目录，重命名。</p><hr><h3 id="查找文件路径"><a href="#查找文件路径" class="headerlink" title="查找文件路径"></a>查找文件路径</h3><p><strong>命令</strong>：<code>which(cmd, mode=os.F_OK | os.X_OK, path=None)</code>，返回文件路径，类似Linux的<code>which</code>命令</p><p><strong>参数讲解</strong>：</p><ul><li><strong><code>cmd</code></strong>：需要查找的内容-字符串形式</li><li><strong><code>mode</code></strong>：查找内容的权限，默认情况<code>os.F_OK</code>：path是否存在以及<code>os.X_OK</code>：path是否可执行</li><li><strong><code>path</code></strong>：在指定路径中查找</li></ul><p><strong>使用场景</strong>：典型的使用场景是在环境变量 <code>PATH</code> 定义的路径中查找<strong>可执行程序</strong>的位置，如果<strong>没有找到文件</strong>，<code>which()</code> 返回 <code>None</code></p><hr><p><br></p><h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><h3 id="查看支持的压缩文件格式"><a href="#查看支持的压缩文件格式" class="headerlink" title="查看支持的压缩文件格式"></a>查看支持的压缩文件格式</h3><p><strong>命令</strong>：<code>shutil.get_archive_formats()</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> format, description <span class="keyword">in</span> shutil.get_archive_formats():</span><br><span class="line">    print(<span class="string">'&#123;:&lt;5&#125;: &#123;&#125;'</span>.format(format, description))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    bztar: bzip2<span class="string">'ed tar-file</span></span><br><span class="line"><span class="string">    gztar: gzip'</span>ed tar-file</span><br><span class="line">    tar  : uncompressed tar file</span><br><span class="line">    xztar: xz<span class="string">'ed tar-file</span></span><br><span class="line"><span class="string">    zip  : ZIP file</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建归档或压缩文件"><a href="#创建归档或压缩文件" class="headerlink" title="创建归档或压缩文件"></a>创建归档或压缩文件</h3><p><strong>命令</strong>：<code>shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>base_name</code></strong>：<strong>压缩后的文件名(不包含拓展名)</strong>；如果不指定绝对路径，则压缩文件保存在当前目录下；<strong>这个参数必须指定</strong></li><li><strong><code>format</code></strong>：<strong>压缩格式</strong>，可以是<code>zip</code>、<code>tar</code>、<code>bztar(tar.bz2)</code>、<code>gztar(tar.gz)</code>、<code>xztar</code>中的一种；<strong>这个参数也必须指定</strong></li><li><strong><code>root_dir</code></strong>：<strong>设置压缩包里的根目录</strong>，即在创建归档之前先切换到它指定的目录，一般使用默认值，不特别指定</li><li><strong><code>base_dir</code></strong>：要<strong>进行压缩的源文件或目录</strong>，如果<strong>没有提供</strong>则<strong>对root_dir目录下的所有文件进行归档压缩</strong></li><li><strong><code>dry_run</code></strong>：如果值为Ture表示不会创建归档，但是操作输出会被记录到logger中，<strong>可用于测试</strong></li><li><strong><code>owner</code></strong>：<strong>用户</strong>，默认当前用户</li><li><strong><code>group</code></strong>：<strong>组</strong>，默认当前组</li><li><strong><code>logger</code></strong>：用于<strong>记录日志</strong>，通常是logging.Logger对象</li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供base_dir</span></span><br><span class="line">shutil.make_archive(base_name=<span class="string">"test"</span>, format=<span class="string">"gztar"</span>,  base_dir=<span class="string">"./cat"</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    <span class="string">'test.tar.gz'</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 注意文件中显示的路径，如果前面设置的是全路径，会创建全路径的文件夹</span></span><br><span class="line">    drwxrwxr-x user/user     <span class="number">0</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./cat/</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">13</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">28</span> ./cat/test1.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">7</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./cat/test2.txt</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">20</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./cat/test3.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">14</span> ./cat/filename</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./cat/test4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只提供root_dir</span></span><br><span class="line">shutil.make_archive(base_name=<span class="string">"test2"</span>, format=<span class="string">"gztar"</span>,  root_dir=<span class="string">"./cat"</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    <span class="string">'absolute_path/test2.tar.gz'</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    drwxrwxr-x user/user     <span class="number">0</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">13</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">28</span> ./test1.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">7</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./test2.txt</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">20</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./test3.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">14</span> ./filename</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./test4.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>设置<code>base_dir</code>之后</strong>会在压缩的文件中会出现设置的<code>base_dir</code>路径(<strong>保留了原始路径信息</strong>)，这个需要特别注意，如果设置的是全路径指向某一个文件，解压的结果中也会包含那个全路径；<strong>如果设置的是<code>root_dir</code>，不设置<code>base_dir</code></strong>，默认对<code>root_dir</code>中的进行压缩，则不会有上述麻烦，生成的文件解压后直接可以看到内容，<strong>不会出现全路径</strong>。</p></div><hr><h3 id="解压缩后缀与格式的对应"><a href="#解压缩后缀与格式的对应" class="headerlink" title="解压缩后缀与格式的对应"></a>解压缩后缀与格式的对应</h3><p><strong>命令</strong>：<code>shutil.get_unpack_formats()</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> format, exts, description <span class="keyword">in</span> shutil.get_unpack_formats():</span><br><span class="line">    print(<span class="string">'&#123;:&lt;5&#125;: &#123;&#125;, names ending in &#123;&#125;'</span>.format(</span><br><span class="line">        format, description, exts))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">    bztar: bzip2<span class="string">'ed tar-file, names ending in ['</span>.tar.bz2<span class="string">', '</span>.tbz2<span class="string">']</span></span><br><span class="line"><span class="string">    gztar: gzip'</span>ed tar-file, names ending <span class="keyword">in</span> [<span class="string">'.tar.gz'</span>, <span class="string">'.tgz'</span>]</span><br><span class="line">    tar  : uncompressed tar file, names ending <span class="keyword">in</span> [<span class="string">'.tar'</span>]</span><br><span class="line">    xztar: xz<span class="string">'ed tar-file, names ending in ['</span>.tar.xz<span class="string">', '</span>.txz<span class="string">']</span></span><br><span class="line"><span class="string">    zip  : ZIP file, names ending in ['</span>.zip<span class="string">']</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="解压缩或解包源文件"><a href="#解压缩或解包源文件" class="headerlink" title="解压缩或解包源文件"></a>解压缩或解包源文件</h3><p><strong>命令</strong>：<code>shutil.unpack_archive(filename[, extract_dir[, format]])</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>filename</code></strong>：是压缩文档的<strong>完整路径</strong></li><li><strong><code>extract_dir</code></strong>：是<strong>解压缩路径</strong>，默认为当前目录</li><li><strong><code>format</code></strong>：是<strong>压缩格式</strong>，<strong>默认使用文件后缀名代码的压缩格式</strong>，可以是<code>zip</code>、<code>tar</code>、<code>bztar(tar.bz2)</code>、<code>gztar(tar.gz)</code>、<code>xztar</code>中的一种；如果<strong>不提供这个参数</strong>，程序会<strong>根据filename的后缀名</strong>来自动选择方法。</li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># filename是全路径</span></span><br><span class="line">shutil.unpack_archive(<span class="string">"full_path/test.tar.gz"</span>, <span class="string">"./test"</span>, <span class="string">'gztar'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/61" target="_blank" rel="noopener">shutil</a></li><li><a href="https://www.cnblogs.com/yyds/p/6427349.html" target="_blank" rel="noopener">Python之文件与目录操作（os、zipfile、tarfile、shutil）</a></li><li><a href="https://docs.python.org/3/library/shutil.html" target="_blank" rel="noopener">shutil — High-level file operations</a></li><li><a href="https://learnku.com/docs/pymotw/shutil-high-order-file-operation/3397" target="_blank" rel="noopener">实例教程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python中用来进行&lt;strong&gt;高级文件操作&lt;/strong&gt;的模块&lt;code&gt;shutil&lt;/code&gt;，其主要包括文件或者目录的&lt;strong&gt;赋值&lt;/strong&gt;、&lt;strong&gt;删除&lt;/strong&gt;、&lt;strong&gt;剪切&lt;/strong&gt;以及&lt;strong&gt;压缩和解压缩操作&lt;/strong&gt;，是对上一个学习的&lt;a href=&quot;http://showteeth.tech/posts/24368.html&quot;&gt;os模块&lt;/a&gt;功能的补充。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之os-使用操作系统相关功能</title>
    <link href="http://showteeth.tech/posts/24368.html"/>
    <id>http://showteeth.tech/posts/24368.html</id>
    <published>2019-03-31T03:08:21.000Z</published>
    <updated>2019-04-01T10:08:08.177Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python使用操作系统相关功能的os模块，其主要功能包括：<strong>系统相关</strong>、<strong>目录及文件操作</strong>、<strong>执行命令和管理进程</strong>，这里主要学习了<strong>常用的目录及文件操作</strong>，其中涉及到的功能非常多，需要时可以查看使用，最后还学习了<strong>系统相关中的查看和新增环境变量操作</strong>，较为实用。</p></div><a id="more"></a><h2 id="os模块简介"><a href="#os模块简介" class="headerlink" title="os模块简介"></a>os模块简介</h2><ul><li><code>os</code>模块是Python标准库中的一个用于<strong>访问操作系统相关功能</strong>的模块，<code>os</code>模块提供了一种<strong>可移植</strong>的使用操作系统功能的方法</li><li>使用<code>os</code>模块中提供的接口，可以<strong>实现跨平台访问</strong>，但是，<strong>并不是所有的</strong><code>os</code>模块中的接口在全平台都通用，<strong>有些接口的实现是依赖特定平台</strong>的，比如linux相关的文件权限管理和进程管理</li><li><code>os</code>模块的<strong>主要功能</strong>：<strong>系统相关</strong>、<strong>目录及文件操作</strong>、<strong>执行命令和管理进程</strong></li><li>在使用<code>os</code>模块的时候，如果出现了问题，会抛出<code>OSError</code>异常，表明<strong>无效的路径名或文件名</strong>，<strong>或者路径名(文件名)无法访问</strong>，<strong>或者当前操作系统不支持该操作</strong></li></ul><hr><h2 id="目录及文件操作"><a href="#目录及文件操作" class="headerlink" title="目录及文件操作"></a>目录及文件操作</h2><p>因为平常使用<code>os</code>模块一般也就是文件以及目录操作，所以这里先学习文件及目录相关操作的命令。<br><code>os</code>模块中包含了一系列文件操作相关的函数，<strong>其中有一部分是Linux平台专用方法</strong>(Linux是用C写的，底层的<code>libc</code>库和系统调用的接口都是<code>C API</code>，Python的<code>os</code>模块中包括了对这些接口的Python实现，通过Python的<code>os</code>模块，可以调用Linux系统的一些底层功能，进行系统编程，关于Linux的相关方法，内容较为复杂，可根据需要自行查阅官方文档），这里只介绍一些<strong>常用的，各平台通用</strong>的方法(包括了<code>os</code>模块和<code>os.path</code>模块):</p><table><thead><tr><th width="30%">方法和变量</th><th width="70%">用途</th></tr></thead><tbody><tr><td><code>os.getcwd()</code></td><td>获取当前工作目录，即当前python脚本工作的目录路径</td></tr><tr><td><code>os.chdir("dirname")</code></td><td>改变当前脚本工作目录；相当于shell下cd</td></tr><tr><td><code>os.curdir</code></td><td>返回当前目录: ('.')</td></tr><tr><td><code>os.pardir</code></td><td>获取当前目录的父目录字符串名：('..')</td></tr><tr><td><code>os.makedirs('dir1/dir2')</code></td><td>可生成<strong>多层递归目录</strong></td></tr><tr><td><code>os.removedirs(‘dirname1’)</code></td><td><strong>递归删除空</strong>目录（要小心）</td></tr><tr><td><code>os.mkdir('dirname')</code></td><td>生成<strong>单级</strong>目录</td></tr><tr><td><code>os.rmdir('dirname')</code></td><td><strong>删除单级空</strong>目录，若目录不为空则无法删除并报错</td></tr><tr><td><code>os.listdir('dirname')</code></td><td>列出指定目录下的所有文件和子目录，<strong>包括隐藏文件</strong></td></tr><tr><td><code>os.scandir('dirname')</code></td><td>更详细地列出所有文件和子目录，相当于<code>os.listdir('dirname')</code>的升级版</td></tr><tr><td><code>os.remove('filename')</code></td><td>删除一个文件</td></tr><tr><td><code>os.rename("oldname","new")</code></td><td>重命名文件/目录</td></tr><tr><td><code>os.stat('path/filename')</code></td><td>获取文件/目录信息</td></tr><tr><td><code>os.access(path, mode)</code></td><td>检测文件或目录的访问权限</td></tr><tr><td><code>os.chmod(path, mode)</code></td><td>修改文件权限</td></tr><tr><td><code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code></td><td>遍历整个目录结构，对每一个目录都返回一个三元元组(dirpath, dirnames, filenames)</td></tr><tr><td><code>os.path.abspath(path)</code></td><td>返回path规范化的<strong>绝对路径</strong></td></tr><tr><td><code>os.path.split(path)</code></td><td>将path分割成<strong>目录和文件名二元组返回</strong></td></tr><tr><td><code>os.path.splitext(path)</code></td><td>分割路径为后缀名(eg:.txt)和之前部分</td></tr><tr><td><code>os.path.dirname(path)</code></td><td>返回path的目录。其实就是<code>os.path.split(path)</code>的第一个元素</td></tr><tr><td><code>os.path.basename(path)</code></td><td>返回path最后的文件名。如果path以<code>／</code>或<code>\</code>结尾，那么就会返回空值。</td></tr><tr><td><code>os.path.exists(path或者file)</code></td><td>如果path存在，返回True；如果path不存在，返回False</td></tr><tr><td><code>os.path.isabs(path)</code></td><td>如果path是绝对路径，返回True</td></tr><tr><td><code>os.path.isfile(path)</code></td><td>如果path是一个存在的文件，返回True。否则返回False</td></tr><tr><td><code>os.path.isdir(path)</code></td><td>如果path是一个存在的目录，则返回True。否则返回False</td></tr><tr><td><code>os.path.join(path1[, path2[, ...]])</code></td><td>将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</td></tr><tr><td><code>os.path.getatime(path)</code></td><td>返回path所指向的文件或者目录的最后存取时间</td></tr><tr><td><code>os.path.getmtime(path)</code></td><td>返回path所指向的文件或者目录的最后修改时间</td></tr><tr><td><code>os.path.relpath(path, start)</code></td><td>返回path<strong>相对于start(比如os.curdir)的相对路径,start默认为根目录</strong></td></tr><tr><td><code>os.path.realpath(path)</code></td><td>获取path的真实、绝对路径(<strong>可用于获取软链接文件指向的文件路径</strong>)</td></tr><tr><td><code>os.path.samefile(path1, path2)</code></td><td>判断path1和path2是否为同一个文件</td></tr><tr><td><code>os.path.getsize(filename)</code></td><td>返回文件包含的字符数量</td></tr></tbody></table><h3 id="获取当前工作目录-os-getcwd"><a href="#获取当前工作目录-os-getcwd" class="headerlink" title="获取当前工作目录-os.getcwd()"></a>获取当前工作目录-os.getcwd()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回当前工作目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python文件地址：</span></span><br><span class="line"><span class="comment"># "c:\FastFolder\learn_test\os_learn.py"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出工作目录而不是python文件所在的目录</span></span><br><span class="line"><span class="comment"># 如果需要得到文件所在目录，后续有专门的命令</span></span><br><span class="line">c:\FastFolder</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="改变当前工作目录-os-chdir"><a href="#改变当前工作目录-os-chdir" class="headerlink" title="改变当前工作目录-os.chdir()"></a>改变当前工作目录-os.chdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变工作目录</span></span><br><span class="line"><span class="comment"># 将工作目录改变到py文件所在的目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变工作目录之后输出当前工作目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现此时的工作目录已经改变</span></span><br><span class="line">c:\FastFolder\learn_test</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建单层目录-os-mkdir"><a href="#创建单层目录-os-mkdir" class="headerlink" title="创建单层目录-os.mkdir()"></a>创建单层目录-os.mkdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先返回当前目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层目录-相对路径</span></span><br><span class="line">mk_dir=<span class="string">'test_single_dir'</span></span><br><span class="line">os.mkdir(mk_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层目录-绝对路径</span></span><br><span class="line">mk_dir=<span class="string">r'c:\FastFolder\learn_test\python_test\test_single_dir'</span></span><br><span class="line">os.mkdir(mk_dir)</span><br></pre></td></tr></table></figure><div class="note info"><p>os.mkdir()还可以设置创建的目录的mode权限，具体参考<a href="https://docs.python.org/3/library/os.html#os.mkdir" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="删除单层空目录-os-rmdir"><a href="#删除单层空目录-os-rmdir" class="headerlink" title="删除单层空目录-os.rmdir()"></a>删除单层空目录-os.rmdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除单层目录，相对路径和绝对路径均可</span></span><br><span class="line">os.rmdir(mk_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录非空会报错</span></span><br><span class="line"><span class="comment"># OSError: [WinError 145] 目录不是空的。</span></span><br><span class="line">os.rmdir(mk_dir)</span><br></pre></td></tr></table></figure><hr><h3 id="递归创建目录-os-makedirs"><a href="#递归创建目录-os-makedirs" class="headerlink" title="递归创建目录-os.makedirs()"></a>递归创建目录-os.makedirs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先返回当前目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录-相对路径</span></span><br><span class="line">mk_dirs=<span class="string">'test_dir/test'</span></span><br><span class="line">os.makedirs(mk_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录-绝对路径</span></span><br><span class="line">mk_dirs=<span class="string">r'c:\FastFolder\learn_test\python_test\test_dir\test'</span></span><br><span class="line">os.makedirs(mk_dirs)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line"><span class="string">'c:\FastFolder'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录创建了test_dir/test目录</span></span><br><span class="line"><span class="comment"># 在指定的绝对路径下创建了test_dir/test目录</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>os.makedirs()还可以设置创建的目录的mode权限，具体参考<a href="https://docs.python.org/3/library/os.html#os.makedirs" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="递归删除多级空目录-os-removedirs"><a href="#递归删除多级空目录-os-removedirs" class="headerlink" title="递归删除多级空目录-os.removedirs()"></a>递归删除多级空目录-os.removedirs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归删除多级目录-绝对或者相对路径均可</span></span><br><span class="line">os.removedirs(mk_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除也需要</span></span><br><span class="line"><span class="comment"># 如果目录非空会报错：</span></span><br><span class="line"><span class="comment"># OSError: [WinError 145] 目录不是空的。: 'test_dir'</span></span><br><span class="line">os.removedirs(<span class="string">'test_dir'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>关于创建和删除单层、多层目录：</p><ul><li>创建单层和删除单层可以使用：<code>os.mkdir()</code>、<code>os.rmdir()</code></li><li>创建多层和删除多层可以使用：<code>os.makedirs()</code>、<code>os.removedirs()</code></li><li>两者之间不仅仅是<code>dirs</code>和<code>dir</code>的区别，还有<code>make</code>和<code>mk</code>、<code>remove</code>和<code>rm</code>的区别<br><br><br>Python删除目录os.removedirs()的过程：If the <strong>leaf directory is succesfully removed</strong>, removedirs <strong>tries to successively remove every parent directory displayed in path</strong>.</li></ul></div><hr><h3 id="列出所有文件和子目录-os-listdir"><a href="#列出所有文件和子目录-os-listdir" class="headerlink" title="列出所有文件和子目录-os.listdir()"></a>列出所有文件和子目录-os.listdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下的所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># 不会显示子目录内容</span></span><br><span class="line">os.listdir(<span class="string">'.'</span>)</span><br><span class="line">os.listdir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定目录下的所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># 这里使用了相对路径，使用绝对路径也是可以的</span></span><br><span class="line">os.listdir(<span class="string">'./python_test'</span>)</span><br><span class="line">os.listdir(<span class="string">'python_test'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># python_test为目录，os_learn.py为文件</span></span><br><span class="line">[<span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">'all.log'</span>, <span class="string">'argparse_parent_with_group.py'</span>, <span class="string">'argparse_test.py'</span>, <span class="string">'error.log'</span>, <span class="string">'log.txt'</span>, <span class="string">'logging_learn.py'</span>, <span class="string">'main'</span>, <span class="string">'my.log'</span>, <span class="string">'myapp.log'</span>, <span class="string">'test_dir'</span>, <span class="string">'__pycache__'</span>]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>os.listdir()</code>的缺点在于返回值为字符串组成的列表，<strong>不能从返回值中分辨它们是文件、目录还是符号连接</strong></p></div><hr><h3 id="更详细地列出所有文件和子目录-os-scandir"><a href="#更详细地列出所有文件和子目录-os-scandir" class="headerlink" title="更详细地列出所有文件和子目录-os.scandir()"></a>更详细地列出所有文件和子目录-os.scandir()</h3><p>针对上面<code>os.listdir()</code>不能从返回值中分辨它们是文件、目录还是符号连接，使用<code>os.scandir()</code>扫描目录时，返回目录中每一个项目 <code>DirEntry</code> 实例的序列，这种对象有<strong>几种属性和方法(是否为目录、文件或者链接)</strong>，可以用于访问文件的元数据：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir():</span><br><span class="line">    <span class="comment"># 判断是否为目录</span></span><br><span class="line">    <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">        typ = <span class="string">'dir'</span></span><br><span class="line">    <span class="comment"># 判断是否为文件</span></span><br><span class="line">    <span class="keyword">elif</span> entry.is_file():</span><br><span class="line">        typ = <span class="string">'file'</span></span><br><span class="line">      <span class="comment"># 判断是否为链接</span></span><br><span class="line">    <span class="keyword">elif</span> entry.is_symlink():</span><br><span class="line">        typ = <span class="string">'link'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        typ = <span class="string">'unknown'</span></span><br><span class="line">    print(<span class="string">'&#123;name&#125; &#123;typ&#125;'</span>.format(</span><br><span class="line">        name=entry.name,</span><br><span class="line">        typ=typ,</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_name.txt file</span><br><span class="line">old_name dir</span><br><span class="line">os_learn.py file</span><br><span class="line">python_test dir</span><br><span class="line">tempCodeRunnerFile.py file</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="删除文件-os-remove"><a href="#删除文件-os-remove" class="headerlink" title="删除文件-os.remove()"></a>删除文件-os.remove()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下的文件</span></span><br><span class="line">os.remove(<span class="string">'to_remove.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定目录下的文件</span></span><br><span class="line">os.remove(<span class="string">r"c:\FastFolder\learn_test\to_remove.txt"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="重命名文件或目录-os-rename"><a href="#重命名文件或目录-os-rename" class="headerlink" title="重命名文件或目录-os.rename()"></a>重命名文件或目录-os.rename()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录所有文件</span></span><br><span class="line">os.listdir()</span><br><span class="line">  <span class="comment"># old_name为文件夹，old_name.txt为文件</span></span><br><span class="line">  [<span class="string">'old_name'</span>, <span class="string">'old_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名目录</span></span><br><span class="line">os.rename(<span class="string">'old_name'</span>,<span class="string">'new_name'</span>)</span><br><span class="line">  <span class="comment"># 不管目录是否为空，都可以正常重命名</span></span><br><span class="line">  [<span class="string">'new_name'</span>, <span class="string">'old_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命令文件</span></span><br><span class="line">os.rename(<span class="string">'old_name.txt'</span>,<span class="string">'new_name.txt'</span>)</span><br><span class="line">  [<span class="string">'new_name'</span>, <span class="string">'new_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="获取文件或目录信息-os-stat"><a href="#获取文件或目录信息-os-stat" class="headerlink" title="获取文件或目录信息-os.stat()"></a>获取文件或目录信息-os.stat()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与os.listdir()不同，必须要指定目录</span></span><br><span class="line">os.stat(<span class="string">'.'</span>)</span><br><span class="line">  os.stat_result(st_mode=<span class="number">16895</span>, st_ino=<span class="number">1688849860706458</span>, st_dev=<span class="number">3422898436</span>, st_nlink=<span class="number">1</span>, st_uid=<span class="number">0</span>, st_gid=<span class="number">0</span>, st_size=<span class="number">0</span>, st_atime=<span class="number">1554014658</span>, st_mtime=<span class="number">1554014658</span>, st_ctime=<span class="number">1553005707</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="检测文件或目录的访问权限-os-access-path-mode"><a href="#检测文件或目录的访问权限-os-access-path-mode" class="headerlink" title="检测文件或目录的访问权限-os.access(path, mode)"></a>检测文件或目录的访问权限-os.access(path, mode)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#  __file__：当前脚本的路径</span></span><br><span class="line">print(<span class="string">'Testing:'</span>, __file__)</span><br><span class="line">print(<span class="string">'Exists:'</span>, os.access(__file__, os.F_OK))</span><br><span class="line">print(<span class="string">'Readable:'</span>, os.access(__file__, os.R_OK))</span><br><span class="line">print(<span class="string">'Writable:'</span>, os.access(__file__, os.W_OK))</span><br><span class="line">print(<span class="string">'Executable:'</span>, os.access(__file__, os.X_OK))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为True或者False</span></span><br></pre></td></tr></table></figure><div class="note info"><p>mode包含<code>F_OK</code>、<code>R_OK</code>、<code>W_OK</code>和<code>X_OK</code>：</p><ul><li><code>os.F_OK</code>：作为access()的mode参数，测试<strong>path是否存在</strong></li><li><code>os.R_OK</code>：包含在access()的mode参数中 ， 测试<strong>path是否可读</strong></li><li><code>os.W_OK</code>：包含在access()的mode参数中 ， 测试<strong>path是否可写</strong></li><li><code>os.X_OK</code>：包含在access()的mode参数中 ，测试<strong>path是否可执行</strong></li></ul></div><hr><h3 id="修改文件权限-os-chmod-path-mode"><a href="#修改文件权限-os-chmod-path-mode" class="headerlink" title="修改文件权限-os.chmod(path, mode)"></a>修改文件权限-os.chmod(path, mode)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> stat</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'os_stat_chmod_example.txt'</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(filename):</span><br><span class="line">    os.unlink(filename)</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'contents'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 函数判断文件当前的权限</span></span><br><span class="line"><span class="comment"># stat.S_IMODE：返回文件权限的chmod格式</span></span><br><span class="line">existing_permissions = stat.S_IMODE(os.stat(filename).st_mode)</span><br><span class="line"><span class="comment"># 得到的是类似438这种的code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.access(filename, os.X_OK):</span><br><span class="line">    print(<span class="string">'Adding execute permission'</span>)</span><br><span class="line">    <span class="comment"># stat.S_IXUSR：拥有者具有执行权限</span></span><br><span class="line">    new_permissions = existing_permissions | stat.S_IXUSR</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Removing execute permission'</span>)</span><br><span class="line">    <span class="comment"># 使用 xor 异或清除用户的执行权限</span></span><br><span class="line">    <span class="comment"># 异或操作：属于A或B，但不属于A交B---&gt;(A-B)∪(B-A)</span></span><br><span class="line">    new_permissions = existing_permissions ^ stat.S_IXUSR</span><br><span class="line"></span><br><span class="line">os.chmod(filename, new_permissions)</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>权限分组(分为三组)</strong>：</p><ul><li><strong>第一组</strong>：文件或目录所有者的权限</li><li><strong>第二组</strong>：与文件或目录所有者同一组的用户的权限</li><li><strong>第三组</strong>：不与文件或目录所有者同组的其他用户(系统中其他用户)的权限</li></ul><p><strong>使用Python的<code>os.chmod</code>修改权限时需要注意进制转换</strong>：<br>如果像在Linux中修改权限为<strong>664(八进制)</strong>，在Python中需要为<strong>0664</strong>，原因：If you’re wondering why that leading zero is important, it’s because <strong>permissions are set as an octal integer(八进制整数)</strong>, and <strong>Python automagically treats any integer with a leading zero as octal(Python会将带0的视为八进制数)</strong>. So <strong>os.chmod(“file”, 436) (in decimal-十进制)</strong>would give the same result.</p><p>进制转换参考<a href="https://stackoverflow.com/questions/15607903/python-module-os-chmodfile-664-does-not-change-the-permission-to-rw-rw-r-bu" target="_blank" rel="noopener">这个链接</a></p><p>关于<code>stat</code>模块和<code>os.stat()</code>参考<a href="https://www.cnblogs.com/maseng/p/3386140.html" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="返回绝对路径-os-path-abspath"><a href="#返回绝对路径-os-path-abspath" class="headerlink" title="返回绝对路径-os.path.abspath()"></a>返回绝对路径-os.path.abspath()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回绝对路径</span></span><br><span class="line"><span class="comment"># 注意和os.stat()相同，必须要指定目录</span></span><br><span class="line">os.path.abspath(<span class="string">'.'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回文件的绝对路径</span></span><br><span class="line">os.path.abspath(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割路径为目录和文件名-os-path-split"><a href="#分割路径为目录和文件名-os-path-split" class="headerlink" title="分割路径为目录和文件名-os.path.split()"></a>分割路径为目录和文件名-os.path.split()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果指定的path是相对路径，目录则会返回相对路径</span></span><br><span class="line">os.path.split(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回元组，第一个元素为目录，第二个元素为文件名</span></span><br><span class="line">  (<span class="string">'.'</span>, <span class="string">'new_name.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最后是以/结尾，返回的文件名为空</span></span><br><span class="line">os.path.split(<span class="string">'./'</span>) )</span><br><span class="line">  (<span class="string">'.'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定的路径为绝对路径，返回绝对路径的目录和文件名</span></span><br><span class="line">os.path.split(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回元组，第一个元素为目录，第二个元素为文件名</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test'</span>, <span class="string">'new_name.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最后是以/结尾，返回的文件名为空</span></span><br><span class="line">os.path.split(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 感觉应该就是直接从最后一个/号进行了分割，前面的返回目录，后面的作为文件名</span></span><br><span class="line"><span class="comment"># 如果path中没有/，则目录会为空，文件名不为空</span></span><br><span class="line">os.path.split(<span class="string">'test.sh'</span>)</span><br><span class="line">  (<span class="string">''</span>, <span class="string">'test.sh'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>感觉应该就是直接<strong>从最后一个<code>/</code>号进行了分割</strong>，<strong>前面的返回目录</strong>，<strong>后面的作为文件名</strong></li><li>如果最后<strong>是以<code>/</code>结尾</strong>，返回的<strong>文件名为空</strong></li><li>如果path中<strong>没有<code>/</code></strong>，则<strong>目录会为空</strong>，<strong>文件名不为空</strong></li></ul></div><hr><h3 id="分割路径为后缀名-eg-txt-和之前部分-os-path-splitext"><a href="#分割路径为后缀名-eg-txt-和之前部分-os-path-splitext" class="headerlink" title="分割路径为后缀名(eg:.txt)和之前部分-os.path.splitext()"></a>分割路径为后缀名(eg:.txt)和之前部分-os.path.splitext()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本和上面的os.path.split()差不多</span></span><br><span class="line"><span class="comment"># 唯一的区别是返回的二元组是后缀名和前部分</span></span><br><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">os.path.splitext(<span class="string">"./new_name.txt"</span>)</span><br><span class="line">  <span class="comment"># 返回的元组是后缀名和前部分</span></span><br><span class="line">  (<span class="string">'./new_name'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">os.path.splitext(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回的元组是后缀名和前部分</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有后缀名，返回空字符</span></span><br><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">os.path.splitext(<span class="string">"./new_name"</span>)</span><br><span class="line">  <span class="comment"># 没有后缀，返回的是空字符</span></span><br><span class="line">  (<span class="string">'./new_name'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">os.path.splitext(<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>)</span><br><span class="line">  <span class="comment"># 没有后缀，返回的是空字符</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不含\也和上面相同</span></span><br><span class="line">os.path.splitext(<span class="string">'test.sh'</span>)</span><br><span class="line">  (<span class="string">'test'</span>, <span class="string">'.sh'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="得到路径的目录-os-path-dirname"><a href="#得到路径的目录-os-path-dirname" class="headerlink" title="得到路径的目录-os.path.dirname()"></a>得到路径的目录-os.path.dirname()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径得到的也是相对路径</span></span><br><span class="line">os.path.dirname(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径得到的也是绝对路径</span></span><br><span class="line">os.path.dirname(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第一个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="返回文件名-os-path-basename"><a href="#返回文件名-os-path-basename" class="headerlink" title="返回文件名-os.path.basename()"></a>返回文件名-os.path.basename()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第二个元素</span></span><br><span class="line">os.path.basename(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'new_name.txt'</span></span><br><span class="line">  </span><br><span class="line">os.path.basename(<span class="string">'./'</span>)</span><br><span class="line">  <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第二个元素</span></span><br><span class="line">os.path.basename(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="string">'new_name.txt'</span></span><br><span class="line"></span><br><span class="line">os.path.basename(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="string">''</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断文件和目录是否存在-os-path-exists"><a href="#判断文件和目录是否存在-os-path-exists" class="headerlink" title="判断文件和目录是否存在-os.path.exists()"></a>判断文件和目录是否存在-os.path.exists()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line">os.path.exists(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">os.path.exists(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断目录是否存在</span></span><br><span class="line">os.path.exists(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为绝对路径-os-path-isabs"><a href="#判断是否为绝对路径-os-path-isabs" class="headerlink" title="判断是否为绝对路径-os.path.isabs()"></a>判断是否为绝对路径-os.path.isabs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径返回false</span></span><br><span class="line">os.path.isabs(<span class="string">'./'</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line">os.path.isabs(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径返回true</span></span><br><span class="line">os.path.isabs(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line">os.path.isabs(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为存在的文件-os-path-isfile"><a href="#判断是否为存在的文件-os-path-isfile" class="headerlink" title="判断是否为存在的文件-os.path.isfile()"></a>判断是否为存在的文件-os.path.isfile()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在的文件返回true</span></span><br><span class="line">os.path.isfile(<span class="string">"./new_name.txt"</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不存在的文件返回false</span></span><br><span class="line">os.path.isfile(<span class="string">"./new_namdsfae.txt"</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为存在的目录-os-path-isdir"><a href="#判断是否为存在的目录-os-path-isdir" class="headerlink" title="判断是否为存在的目录-os.path.isdir()"></a>判断是否为存在的目录-os.path.isdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.path.isdir(<span class="string">"c:\\FastFolder\\learn_test"</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path.isfile()和os.path.isdir()感觉可以使用os.path.exists()替换</span></span><br><span class="line"><span class="comment"># 特殊情况，比如通过判断是文件和目录来进行选择性的删除所有的文件，保留目录</span></span><br></pre></td></tr></table></figure><hr><h3 id="连接目录与文件名或目录-os-path-join"><a href="#连接目录与文件名或目录-os-path-join" class="headerlink" title="连接目录与文件名或目录-os.path.join()"></a>连接目录与文件名或目录-os.path.join()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将若干个目录或文件连接起来</span></span><br><span class="line"><span class="comment"># 不管目录或文件存不存在</span></span><br><span class="line">os.path.join(<span class="string">'c:\\FastFolder\\learn_test'</span>,<span class="string">'test'</span>,<span class="string">'test2'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test\\test\\test2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果根目录在第二个或者更后面，之前的路径将会忽略掉</span></span><br><span class="line">os.path.join(<span class="string">'/root'</span>, <span class="string">'/usr/local'</span>, <span class="string">'test.sh'</span>)</span><br><span class="line">  <span class="comment"># 因为第二个参数'/usr/local'是从根目录开始，第一个/root会被忽略</span></span><br><span class="line">  <span class="string">'/usr/local/test.sh'</span></span><br><span class="line"><span class="comment"># 作为对比</span></span><br><span class="line">os.path.join(<span class="string">'/root'</span>, <span class="string">'usr/local'</span>, <span class="string">'test.sh'</span>)</span><br><span class="line">  <span class="comment">#作为对比，第二个参数'usr/local'没有从根目录开始</span></span><br><span class="line">  <span class="comment"># 最后的结果中会包含第一个参数的内容，不管第一个参数是不是从根目录开始</span></span><br><span class="line"> <span class="string">'/root/usr/local/test.sh'</span></span><br></pre></td></tr></table></figure><hr><h3 id="遍历整个文件结构-os-walk"><a href="#遍历整个文件结构-os-walk" class="headerlink" title="遍历整个文件结构-os.walk()"></a>遍历整个文件结构-os.walk()</h3><p>walk方法是os模块中非常重要和强大的一个方法(<code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code>)。可以帮助我们非常便捷地以<strong>递归方式**</strong>自顶向下<strong>或者</strong>自底向上的方式遍历目录树<strong>，对</strong>每一个目录都返回一个三元元组<code>(dirpath, dirnames, filenames)</code>**:</p><ul><li><code>dirpath</code>：遍历所在目录树的位置，是一个<strong>字符串对象</strong></li><li><code>dirnames</code>：目录树中的<strong>子目录</strong>组成的<strong>列表</strong>，不包括(“.”和”..”)</li><li><code>filenames</code>：目录树中的<strong>文件</strong>组成的<strong>列表</strong></li></ul><p>如果可选参数t<code>opdown = True</code>或者<strong>没有指定</strong>，则采用<strong>自顶向下</strong>的方式进行目录遍历，也就是<strong>从父目录向子目录逐步深入遍历</strong>，如果<code>topdown = False</code>，则采用<strong>自底向上</strong>的方式遍历目录，也就是<strong>先打印子目录再打印父目录</strong>的方式。</p><p>如果可选参数<code>onerror</code>被指定，则<code>onerror</code>必须是一个<strong>函数</strong>，该函数有一个OSError实例的参数，这样可以允许在运行的时候即使出现错误的时候不会打断os.walk()的执行，或者抛出一个异常并终止os.walk()的运行。通俗的讲，<strong>就是定义这个参数用于指定当发生了错误时的处理方法</strong>。</p><p><strong>默认情况下</strong>，<code>os.walk()</code>遍历的时候<strong>不会进入符号链接</strong>，如果设置了可选参数<code>followlinks = True</code>，<strong>则会进入符号链接</strong>。注意，这<strong>可能会出现遍历死循环</strong>，因为符号链接可能会出现自己链接自己的情况，而os.walk()没有那么高的智商，无法发现这一点。</p><p><strong>只遍历输出根目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">r"./"</span>):</span><br><span class="line">        print(root)</span><br><span class="line">        <span class="comment"># for directory in dirs:</span></span><br><span class="line">        <span class="comment">#     print( directory)</span></span><br><span class="line">        <span class="comment"># for file in files:</span></span><br><span class="line">        <span class="comment">#     print(file)</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在遍历过程中，所有的目录都可能成为根目录</span></span><br><span class="line">./</span><br><span class="line">./old_name</span><br><span class="line">./python_test</span><br><span class="line">./python_test\main</span><br><span class="line">./python_test\main\__pycache__</span><br><span class="line">./python_test\__pycache__</span><br></pre></td></tr></table></figure><p></p><p><strong>遍历输出根目录及其下面的目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">r"./"</span>):</span><br><span class="line">        print(root)</span><br><span class="line">        <span class="keyword">for</span> directory <span class="keyword">in</span> dirs:</span><br><span class="line">            print( directory)</span><br><span class="line">        <span class="comment"># for file in files:</span></span><br><span class="line">        <span class="comment">#     print(file)</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">old_name</span><br><span class="line">python_test</span><br><span class="line">./old_name</span><br><span class="line">./python_test</span><br><span class="line">main</span><br><span class="line">__pycache__</span><br><span class="line">./python_test\main</span><br><span class="line">__pycache__</span><br><span class="line">./python_test\main\__pycache__</span><br><span class="line">./python_test\__pycache__</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="总结以及注意事项"><a href="#总结以及注意事项" class="headerlink" title="总结以及注意事项"></a>总结以及注意事项</h3><div class="note info"><ul><li>除了<code>os.listdir()和os.scandir()</code>可以<strong>不指定path表示当前目录</strong>之外，<strong>基本所有的都必须要指定path</strong>，即使是当前目录，也要用类似<code>&#39;.&#39;</code>的方法指定，<strong>如果不指定会报错</strong>，所以<strong>保险起见，还是都指定path吧，以免出错</strong>。<br><br></li><li>使用windows的文件路径时一定要小心，比如你要引用d盘下的1.txt文件，那么路径要以字符串的形式写成<code>&#39;d:\\1.txt&#39;</code>或者<code>r&#39;d:\1.txt‘</code>。前面的方式是使用windwos的<strong>双斜杠</strong>作为路径分隔符，后者是使用<strong>原生字符串</strong>的形式，以r开始的字符串都被认为是原始字符串，表示字符串里所有的特殊符号都以本色出演，<strong>不进行转义</strong>，此时可以使用普通windows下的路径表示方式。<strong>这两种方法使用哪种都可以，但不可混用</strong>。<br><br></li><li><code>os.path.exists()</code>可以<strong>判断文件或者目录是否存在</strong>，而具体的<code>os.path.isfile()</code>和<code>os.path.isdir()</code>可以<strong>分别判断文件和目录是否存在</strong>，从而进行单独的操作，如删除所有目录中的文件，保留目录。<br><br></li><li><code>os.rmdir()</code>、<code>os.removedirs()</code>都<mark>只能删除空的目录</mark>，而<code>os.remove()</code>只能<strong>删除单个的文件</strong>，所以如果<mark>需要删除一个带文件的目录需要结合os.listdir() os.remove() os.rmdir()等，比较麻烦</mark>。<br><br></li><li>Python删除目录os.removedirs()的过程：If the <strong>leaf directory is succesfully removed</strong>, removedirs <strong>tries to successively remove every parent directory displayed in path</strong>.</li></ul></div><hr><p><br></p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p>系统相关的一系列命令在实际使用中用的比较少，所以这里只是列出，便于在后面使用时查询，并不进行深入的学习，后续需要时再学习。<br>os模块提供了一些操作系统相关的变量，可以在跨平台的时候提供支持，<strong>便于编写移植性高，可用性好的代码</strong>。所以在<strong>涉及操作系统相关的操作</strong>时，请<strong>尽量使用本模块提供的方法</strong>，而<strong>不要使用当前平台特定的用法或格式</strong>，否则一旦移植到其他平台，可能会造成难以解决的困扰。</p><table><thead><tr><th width="20%">方法和变量</th><th width="80%">用途</th></tr></thead><tbody><tr><td><code>os.name</code></td><td>查看当前操作系统的名称。windows平台下返回‘nt’，Linux则返回‘posix’。</td></tr><tr><td><code>os.environ</code></td><td>获取系统环境变量</td></tr><tr><td><code>os.sep</code></td><td>当前平台的路径分隔符。在windows下，为‘\’，在POSIX系统中，为‘/’。</td></tr><tr><td><code>os.altsep</code></td><td>可替代的路径分隔符，在Windows中为‘/’。</td></tr><tr><td><code>os.extsep</code></td><td>文件名和文件扩展名之间分隔的符号，在Windows下为‘.’。</td></tr><tr><td><code>os.pathsep</code></td><td>PATH环境变量中的分隔符，在POSIX系统中为‘:’，在Windows中为‘;’。</td></tr><tr><td><code>os.linesep</code></td><td>行结束符。在不同的系统中行尾的结束符是不同的，例如在Windows下为‘\r\n’。</td></tr><tr><td><code>os.devnull</code></td><td>在不同的系统上null设备的路径，在Windows下为‘nul’，在POSIX下为‘/dev/null’。</td></tr><tr><td><code>os.defpath</code></td><td>当使用exec函数族的时候，如果没有指定PATH环境变量，则默认会查找os.defpath中的值作为子进程PATH的值。</td></tr></tbody></table><h3 id="环境变量-os-environ"><a href="#环境变量-os-environ" class="headerlink" title="环境变量-os.environ()"></a>环境变量-os.environ()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到目前的环境变量</span></span><br><span class="line"><span class="comment"># 返回类似字典的具有映射关系的对象</span></span><br><span class="line">print(os.environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查HOME是不是在环境变量中</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'HOME'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    print(<span class="string">'HOME environment variable is already defined. Value ='</span>, os.environ[<span class="string">'HOME'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'HOME environment variable is not defined.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，和操作字典类似</span></span><br><span class="line"><span class="comment"># 注意环境变量的值必须要是字符串，不能为数字或其他</span></span><br><span class="line">os.environ[<span class="string">'MYSQL_VERSION'</span>] = <span class="string">'5.7.18'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取环境变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用常规的这种字典操作的方式</span></span><br><span class="line"><span class="comment"># 这种方式存在的问题是如果环境变量中不存在这个MYSQL_VERSION，则会报错，显示KeyError</span></span><br><span class="line">os.environ[<span class="string">'MYSQL_VERSION'</span>]</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"C:\Users\14910\Anaconda3\lib\os.py"</span>, line <span class="number">678</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">      <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="keyword">None</span></span><br><span class="line">  KeyError: <span class="string">'MYSQL_VERSION'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用另一种方式get()</span></span><br><span class="line"><span class="keyword">print</span> (os.environ.get(<span class="string">'DATA'</span>))</span><br><span class="line">  <span class="comment"># 环境变量不存在，返回None </span></span><br><span class="line">  <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 还可以设置环境变量不存在时候的默认值</span></span><br><span class="line">print(os.environ.get(<span class="string">'DATA'</span>, <span class="string">'TXT'</span>))</span><br><span class="line"> <span class="comment"># 环境变量不存在，返回默认值</span></span><br><span class="line">  TXT</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="执行命令和管理进程"><a href="#执行命令和管理进程" class="headerlink" title="执行命令和管理进程"></a>执行命令和管理进程</h2><p>在早期的Python版本中，通常使用<code>os</code>模块的<code>system</code>或者<code>popen</code>等方法执行操作系统的命令。但是，最近Python官方逐渐弃用了这些命令，而是改用内置的<code>subprocess</code>模块执行操作系统相关命令。鉴于上述原因，这里就不对这个方面进行更深入的学习，以后详细学习<code>subprocess</code>模块。</p><p><strong>该部分主要包括两个命令</strong>：</p><ul><li><code>os.system(command)</code>：运行操作系统命令，<strong>直接显示结果</strong>；但<strong>返回值是0或-1</strong>，<strong>不能获得显示在屏幕上的数据</strong>；command是要执行的命令字符串；除非显式在后台运行该命令，否则 <code>system()</code> 的调用将阻塞，直到它完成.</li><li><code>os.popen(command, [mode, [bufsize]])</code>：该方法<strong>返回一个文件对象，可以对这个文件对象进行读或写</strong>，取决于<strong>参数mode</strong>，如果mode指定了只读，那么只能对文件对象进行读，如果mode参数指定了只写，那么只能对文件对象进行写操作。简而言之，<strong><code>popen</code>也可以运行操作系统命令</strong>，并<strong>通过<code>read()</code>方法将命令的结果返回</strong>，<strong>不像system只能看不能存，这个能存</strong>！</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/53" target="_blank" rel="noopener">很详细的教程</a></li><li><a href="https://learnku.com/docs/pymotw/os-portable-access-to-operating-system-specific-features/3481" target="_blank" rel="noopener">使用实例教程</a></li><li><a href="https://www.cnblogs.com/yyds/p/6427349.html" target="_blank" rel="noopener">Python之文件与目录操作（os、zipfile、tarfile、shutil）</a></li><li><a href="https://docs.python.org/3/library/os.html#module-os" target="_blank" rel="noopener">os — Miscellaneous operating system interfaces</a></li><li><a href="https://www.cnblogs.com/maseng/p/3386140.html" target="_blank" rel="noopener">python os.stat() 和 stat模块详解</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了Python使用操作系统相关功能的os模块，其主要功能包括：&lt;strong&gt;系统相关&lt;/strong&gt;、&lt;strong&gt;目录及文件操作&lt;/strong&gt;、&lt;strong&gt;执行命令和管理进程&lt;/strong&gt;，这里主要学习了&lt;strong&gt;常用的目录及文件操作&lt;/strong&gt;，其中涉及到的功能非常多，需要时可以查看使用，最后还学习了&lt;strong&gt;系统相关中的查看和新增环境变量操作&lt;/strong&gt;，较为实用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的解压缩命令</title>
    <link href="http://showteeth.tech/posts/29022.html"/>
    <id>http://showteeth.tech/posts/29022.html</id>
    <published>2019-03-30T09:28:22.000Z</published>
    <updated>2019-03-30T15:32:38.963Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习和总结了Linux中常用的解压缩命令，主要针对<code>tar.gz</code>、<code>tar.bz2</code>、<code>gz</code>、<code>bz2</code>和<code>zip</code>文件格式进行解压，分别学习了<code>tar命令(打包命令)</code>、<code>gzip命令</code>、<code>bzip2命令</code>以及<code>zip命令</code>和<code>对应的解压命令</code>来完成对上述文件格式的解压。</p></div><a id="more"></a><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p><strong><code>tar</code>命令是打包命令而不是解压命令</strong>，所谓的打包是指可以把<strong>一大堆的文件和目录</strong>全部打包<strong>成一个文件</strong>，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。我们在<strong>平常使用时都是使用<code>tar</code>结合相应参数对文件进行解压，但实际上其并不是解压缩命令，其实现解压需要结合特定的参数</strong>。</p><p><strong>这里我们很有必要了解一下打包和解压的区别</strong>：</p><ul><li><strong>打包</strong>是指将<strong>一大堆文件或目录</strong>变成一个<strong>总的文件</strong></li><li><strong>压缩</strong>则是将<strong>一个大的文件</strong>通过一些压缩算法变成一个<strong>小文件</strong></li></ul><p>我们平常解压时面对的文件名大多是<code>tar.gz</code>格式文件，其产生过程和原因是：Linux中<strong>很多压缩程序只能针对一个文件进行压缩</strong>，这样当你想要<strong>压缩一大堆文件时</strong>，你得先<strong>将这一大堆文件先打成一个包</strong>（<code>tar命令</code>），然后<strong>再用压缩程序进行压缩</strong>（<code>gzip、bzip2命令</code>）。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在学习如何解压<code>tar.gz</code>格式文件之前，先学习使用tar命令进行打包并进行压缩，知道来源再去学习针对性的解压命令.</p><p><strong>命令格式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 输入文件可以有多个，将其统一打包成输出文件</span></span><br><span class="line">  tar option out_file in_file in_file_2</span><br></pre></td></tr></table></figure><p></p><p><strong>相关参数说明</strong>：</p><ul><li><code>-c</code>：建立新的打包文件</li><li><code>-v</code>：显示指令执行过程</li><li><code>-r</code>：向已经打包的文件中<strong>追加**</strong>文件<strong>(</strong>不能向已经压缩的<code>bz2</code>、<code>gz</code>文件中添加<strong>，</strong>需要和<code>-f</code>参数一同使用**)</li><li><code>-u</code>：<strong>更新</strong>已经打包的文件中的<strong>文件</strong>(<strong>不能向已经压缩的<code>bz2</code>、<code>gz</code>文件中添加</strong>，<strong>需要和<code>-f</code>参数一同使用</strong>)</li><li><code>-A</code>：将<strong>tar文件中的文件**</strong>追加到已经打包的文件(tar文件)中**，相当于是文件的追加，而不是将整个tar文件追加进去</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li></ul><p><strong>打包实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅打包，不压缩</span></span><br><span class="line">tar -cvf Homo_sapiens.GRCh38.95.chr.gff3.tar Homo_sapiens.GRCh38.95.chr.gff3 test.txt </span><br><span class="line">  <span class="comment"># 生成tar格式文件，tar格式文件比原始文件大</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中添加test2.txt文件</span></span><br><span class="line">tar -rvf Homo_sapiens.GRCh38.95.chr.gff3.tar test2.txt</span><br><span class="line">  <span class="comment"># 生成的还是原来的tar文件，只是其中多了test2.txt</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中更新test2.txt文件</span></span><br><span class="line">tar -uvf Homo_sapiens.GRCh38.95.chr.gff3.tar test2.txt</span><br><span class="line">  <span class="comment"># tar文件中的test2.txt已经更新了</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中添加tar打包文件</span></span><br><span class="line">tar -Avf Homo_sapiens.GRCh38.95.chr.gff3.tar Homo_sapiens.GRCh38.95.chr.gff3_2.tar</span><br><span class="line">  <span class="comment"># 生成的还是原来的tar文件，只是将tar中的文件追加到前面的tar文件中</span></span><br><span class="line">  <span class="comment"># 不是将整个tar文件追加进去，如果使用-r选项就是将整个tar文件追加进去</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包后，以 gzip 压缩 </span></span><br><span class="line">tar -zcvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz Homo_sapiens.GRCh38.95.chr.gff3 test.txt</span><br><span class="line">  <span class="comment"># 生成tar.gz格式文件</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包后，以 bzip2 压缩(这个花费时间较长) </span></span><br><span class="line">tar -jcvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2  Homo_sapiens.GRCh38.95.chr.gff3 test.txt</span><br><span class="line">  <span class="comment"># 生成tar.bz2格式文件</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>打包参数是<code>-cvf</code></li><li><code>bz2</code>格式的文件对应的参数就是<code>j</code>，<strong>打包所需时间长，压缩包的大小比较小，压缩比高</strong></li><li><code>gz</code>格式的文件对应的参数就是<code>z</code>，<strong>打包所需时间较短，压缩包的大小比较大，压缩比低</strong></li><li><strong>tar格式文件比原始文件大</strong></li></ul><p><strong>上述的文件格式和参数的对应关系很关键，在接下来的所有命令中，只要是针对这两种不同格式的包都需要加上对应的参数</strong>。</p></div><hr><h3 id="查看包的内容"><a href="#查看包的内容" class="headerlink" title="查看包的内容"></a>查看包的内容</h3><p><strong>相关参数说明</strong>：</p><ul><li><code>-t</code>：列出打包文件内容</li><li><code>-v</code>：显示指令执行过程</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li></ul><p><strong>查看包的内容实例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看打包文件</span></span><br><span class="line">tar -tvf Homo_sapiens.GRCh38.95.chr.gff3.tar</span><br><span class="line">  <span class="comment"># 输出包的内容 </span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tar.gz格式文件内容</span></span><br><span class="line">tar -ztvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line">  <span class="comment"># 输出tar.gz格式文件内容 </span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tar.bz2格式文件内容</span></span><br><span class="line">tar -jtvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br><span class="line">  <span class="comment"># 输出tar.bz2格式文件内容</span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>查看包的基础参数是<code>-tvf</code></li><li><code>bz2</code>格式的文件对应的参数就是<code>j</code></li><li><code>gz</code>格式的文件对应的参数就是<code>z</code></li></ul></div><hr><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><strong>相关参数说明</strong>：</p><ul><li><code>-x</code>：提取(解压)打包文件内容</li><li><code>-v</code>：显示指令执行过程</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li><li><code>-C</code>：<strong>指定解压文件的输出目录</strong></li></ul><h4 id="解压整个文件"><a href="#解压整个文件" class="headerlink" title="解压整个文件"></a>解压整个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取tar格式文件内容</span></span><br><span class="line">tar -xvf Homo_sapiens.GRCh38.95.chr.gff3.tar</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.gz格式文件内容</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar.gz格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.bz2格式文件内容</span></span><br><span class="line">tar -jxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar.bz2格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定解压的输出文件夹</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz -C <span class="built_in">test</span></span><br><span class="line">  <span class="comment"># 解压的文件输出在test目录中</span></span><br><span class="line">  <span class="comment"># test目录必须存在，不然会报错</span></span><br></pre></td></tr></table></figure><hr><h4 id="解压部分文件"><a href="#解压部分文件" class="headerlink" title="解压部分文件"></a>解压部分文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取tar.gz格式文件中的test.txt文件</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.bz2格式文件中的test.txt文件</span></span><br><span class="line">tar -jxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定解压的输出文件夹</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz test.txt -C <span class="built_in">test</span></span><br><span class="line">  <span class="comment"># 解压的文件输出在test目录中</span></span><br><span class="line">  <span class="comment"># test目录必须存在，不然会报错</span></span><br></pre></td></tr></table></figure><div class="note info"><ul><li><strong>tar可解压压缩文件的部分内容</strong>，所以可以先通过<code>-t</code>来<strong>查看</strong>压缩包内容，然后<strong>选取自己需要</strong>的进行<strong>解压</strong>，或者直接解压整个包。</li><li><strong>可以使用<code>-C</code>参数指定解压文件的输出目录</strong></li></ul></div><hr><h2 id="gz文件"><a href="#gz文件" class="headerlink" title="gz文件"></a>gz文件</h2><p>这个没啥可以说的，就是使用gzip命令压缩得到的文件(<strong>默认情况下压缩后会使原文件消失</strong>)，对于这个命令的解压可以使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看压缩文件信息</span></span><br><span class="line"><span class="comment"># -l：list compressed file contents</span></span><br><span class="line">gzip -l Homo_sapiens.GRCh38.95.chr.gff3.gz </span><br><span class="line">  compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">    38793139           430456714  91.0% Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip -d解压</span></span><br><span class="line"><span class="comment"># -d：decompress</span></span><br><span class="line">gzip -d Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">  <span class="comment"># 解压缩后原始的gz格式文件将不会存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip解压</span></span><br><span class="line">gunzip Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">  <span class="comment"># 解压缩后原始的gz格式文件将不会存在</span></span><br></pre></td></tr></table></figure><p></p><p>如果想<strong>保留原始文件</strong>就需要使用<code>-c</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c：--stdout  write on standard output, keep original files unchanged</span></span><br><span class="line"><span class="comment"># -c：将文件输出到标准输出，并且保留原始gz格式文件不变</span></span><br><span class="line"><span class="comment"># 输出到标准输出，然后进行重定向到文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩过程如果想保留原始文件也可以使用-c参数</span></span><br><span class="line">gzip -c Homo_sapiens.GRCh38.95.chr.gff3 &gt;Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip进行解压缩并保留原始文件</span></span><br><span class="line">gunzip -c Homo_sapiens.GRCh38.95.chr.gff3.gz &gt;Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip -d解压并保留原始文件</span></span><br><span class="line">gzip -d -c Homo_sapiens.GRCh38.95.chr.gff3.gz &gt;Homo_sapiens.GRCh38.95.chr.gff3</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="bz2文件"><a href="#bz2文件" class="headerlink" title="bz2文件"></a>bz2文件</h2><p>bz2是由bzip2命令压缩得到的文件，<strong>默认情况下和<code>gzip</code>相同<code>bzip2</code>也不会保留解压缩前的原始文件</strong>，对这种格式的文件进行解压缩可以使用如下命令:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和gzip不同，bzip2命令没有能够列出压缩文件内容的选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip2 -d进行解压</span></span><br><span class="line"><span class="comment"># -d：--decompress  force decompression</span></span><br><span class="line">bzip2 -d Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br><span class="line">  <span class="comment"># 解压缩后原始的bz2格式文件将不会存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2解压</span></span><br><span class="line">bunzip2 Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br><span class="line">  <span class="comment"># 解压缩后原始的bz2格式文件将不会存在</span></span><br></pre></td></tr></table></figure><p></p><p>如果想<strong>保留原始文件</strong>就需要使用<code>-k</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -k：--keep   keep (don't delete) input files</span></span><br><span class="line"><span class="comment"># -k：保留原始的输入文件</span></span><br><span class="line"><span class="comment"># 这里bzip2也有-c选项，但是也专门提供了-k选项来保留原始文件，所以就不需要进行-c然后重定向</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩时保留原始文件</span></span><br><span class="line">bzip2 -k Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2解压并保留原始文件</span></span><br><span class="line">bunzip2 -k Homo_sapiens.GRCh38.95.chr.gff3.bz2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip2 -d进行解压并保留原始文件</span></span><br><span class="line">bzip2 -d -k Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="zip格式文件"><a href="#zip格式文件" class="headerlink" title="zip格式文件"></a>zip格式文件</h2><p>zip格式文件是通过zip命令压缩得到的文件，对其的解压使用unzip命令即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用zip命令进行压缩，与前面两个gzip和bzip2不同的是可以保留原始文件</span></span><br><span class="line"><span class="comment"># 需要自定义输出文件名</span></span><br><span class="line">zip Homo_sapiens.GRCh38.95.chr.gff3.zip Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新zip文件中的问价，使用-u参数</span></span><br><span class="line">zip -u Homo_sapiens.GRCh38.95.chr.gff3.zip test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件添加到zip文件中，使用-m参数</span></span><br><span class="line">zip -m Homo_sapiens.GRCh38.95.chr.gff3.zip  test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用unzip进行解压</span></span><br><span class="line"><span class="comment"># 解压也和前面的gzip和bzip2不同，能够保留原始文件</span></span><br><span class="line">unzip Homo_sapiens.GRCh38.95.chr.gff3.zip</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关于tar命令"><a href="#关于tar命令" class="headerlink" title="关于tar命令"></a>关于tar命令</h3><ul><li><strong>tar可解压压缩文件的部分内容</strong>，所以可以先通过<code>-t</code>来<strong>查看</strong>压缩包内容，然后<strong>选取自己需要</strong>的进行<strong>解压</strong>，或者直接解压整个包。</li><li><strong>可以使用<code>-C</code>参数指定解压文件的输出目录</strong></li><li><strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li></ul><hr><h3 id="关于压缩比"><a href="#关于压缩比" class="headerlink" title="关于压缩比"></a>关于压缩比</h3><p><strong><code>bzip2</code>的压缩比最高、其次是<code>gzip</code>、接着是<code>zip</code>、最后是打包<code>tar</code></strong>，可以看看这个示例：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/压缩比.png" alt="压缩比.png"></p><hr><h3 id="原始文件"><a href="#原始文件" class="headerlink" title="原始文件"></a>原始文件</h3><ul><li><strong><code>tar</code>和<code>zip</code>都会保留原始文件</strong></li><li><strong><code>bzip2</code>和<code>gzip</code>都不会保留原始文件</strong><ul><li><code>gzip</code>需要使用<code>-c</code>参数将结果<strong>输出到标准输出</strong>，然后<strong>重定向</strong>来保留文件(解压或者压缩)</li><li><code>bzip2</code>可以使用<code>-k</code>参数来<strong>直接保留</strong>原始文件(解压或者压缩)，也可以使用上面的<code>-c</code>参数</li></ul></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>tar</code>和<code>zip</code>进行压缩或者打包时都是先跟着输出文件(tar、zip格式文件)，再跟着输入的需要打包和压缩的文件，这个需要注意一下</li><li><code>bzip2</code>和<code>gzip</code>直接跟着需要压缩的文件即可<br><br></li><li><code>bzip2</code>和<code>gzip</code>只能针对文件，不能针对目录</li><li><code>tar</code>可以<strong>支持对目录和文件的打包</strong></li><li><code>zip</code>命令<strong>需要使用<code>-r</code>参数</strong>来支持对目录的压缩</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/tar" target="_blank" rel="noopener">tar命令</a></li><li><a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip命令</a></li><li><a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2命令</a></li><li><a href="http://man.linuxde.net/zip" target="_blank" rel="noopener">zip命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习和总结了Linux中常用的解压缩命令，主要针对&lt;code&gt;tar.gz&lt;/code&gt;、&lt;code&gt;tar.bz2&lt;/code&gt;、&lt;code&gt;gz&lt;/code&gt;、&lt;code&gt;bz2&lt;/code&gt;和&lt;code&gt;zip&lt;/code&gt;文件格式进行解压，分别学习了&lt;code&gt;tar命令(打包命令)&lt;/code&gt;、&lt;code&gt;gzip命令&lt;/code&gt;、&lt;code&gt;bzip2命令&lt;/code&gt;以及&lt;code&gt;zip命令&lt;/code&gt;和&lt;code&gt;对应的解压命令&lt;/code&gt;来完成对上述文件格式的解压。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
