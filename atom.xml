<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-08-25T07:24:24.189Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>R系列之向量、矩阵、数组、数据框和列表</title>
    <link href="http://showteeth.tech/posts/30224.html"/>
    <id>http://showteeth.tech/posts/30224.html</id>
    <published>2019-08-25T03:17:31.000Z</published>
    <updated>2019-08-25T07:24:24.189Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是基于<a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">这篇文章</a>学习了R中几种常见的数据结构，包括<code>向量</code>、<code>矩阵</code>、<code>数组</code>、<code>数据框</code>以及<code>列表</code>，主要围绕这些数据结构的<code>构成</code>、<code>创建</code>、<code>获取元素</code>进行了学习，后续使用中可以查询和补充。</p></div><a id="more"></a><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量的创建"><a href="#向量的创建" class="headerlink" title="向量的创建"></a>向量的创建</h3><p>向量是用于存储<code>数值型</code>、<code>字符型</code>或<code>逻辑型</code>数据的一维数组。执行组合功能的函数<code>c()</code>可用来<strong>创建向量</strong>。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为数值：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向量创建使用示例</span></span><br><span class="line">&gt; a &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">4</span>)   <span class="comment">#数值型向量</span></span><br><span class="line">&gt; a</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span> -<span class="number">2</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt; b &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)  <span class="comment">#字符型向量</span></span><br><span class="line">&gt; b</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">&gt; c &lt;- c(<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>)  <span class="comment">#逻辑型向量</span></span><br><span class="line">&gt; c</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure><p></p><p>特别地，对于整数型向量，可以使用<code>seq</code>函数进行创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始值（from），结束值（to），步长（by）</span></span><br><span class="line">seq(from = <span class="number">1</span>, to = <span class="number">1</span>, by=step)</span><br><span class="line"><span class="comment"># 创建从1开始到5(包括)截止，步长为1的整数向量</span></span><br><span class="line">seq(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用这种方式创建步长为1的整数向量</span></span><br><span class="line"><span class="number">1</span>:<span class="number">5</span></span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h3><p>通过<code>is.*</code> 函数检查变量的类型，通过<code>as.*</code>函数转换变量的类型：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; vc &lt;- c(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>)</span><br><span class="line"><span class="comment"># 判断vc是不是字符型向量</span></span><br><span class="line">&gt; is.character(vc)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 将vc转换为整数型向量</span></span><br><span class="line">&gt; vi &lt;- as.integer(vc)</span><br><span class="line">&gt; is.integer(vi)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问向量中的元素"><a href="#访问向量中的元素" class="headerlink" title="访问向量中的元素"></a>访问向量中的元素</h3><p>通过索引的方式可以访问向量中的元素，注意<strong>R中是索引开始于1</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取索引为1的元素</span></span><br><span class="line">&gt; a[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line"><span class="comment"># 获取索引为1、5的元素</span></span><br><span class="line">&gt; a[c(<span class="number">1</span>,<span class="number">3</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 切片操作，获取1-3的元素</span></span><br><span class="line">&gt; b[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>获取逻辑判断为TRUE的元素</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过判断语句得到逻辑向量</span></span><br><span class="line">&gt; v&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; class(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"logical"</span></span><br><span class="line"><span class="comment"># 得到逻辑向量为TRUE的索引位置</span></span><br><span class="line">&gt; which(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[which(v&gt;<span class="number">2</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[v&gt;<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="向量的排序"><a href="#向量的排序" class="headerlink" title="向量的排序"></a>向量的排序</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># sort返回排序之后的向量</span></span><br><span class="line">&gt; sort(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># order返回排序后的向量元素在原始向量中的索引位置</span></span><br><span class="line">&gt; order(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 通过索引位置获取排序后的向量</span></span><br><span class="line">&gt; v[order(v)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="补充知识-NULL和NA"><a href="#补充知识-NULL和NA" class="headerlink" title="补充知识-NULL和NA"></a>补充知识-NULL和NA</h3><p><code>NULL</code>是个特殊值，表示未知值，<code>NA</code>表示缺失值，<code>NULL</code>和<code>NA</code>之间<strong>最大的区别是</strong>：<code>NA</code>是一个标量值，<code>长度为1</code>，而<code>NULL</code>不会占用任何空间，<strong>长度为零</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出长度</span></span><br><span class="line">&gt; length(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; length(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断null、na</span></span><br><span class="line">&gt; is.null(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; is.na(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h3><p>矩阵是一个二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通 过函数matrix创建矩阵。一般使用格式为：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mymatrix &lt;- matrix(vector,nrow=number_of_rows,ncol=number_of_columns,   </span><br><span class="line">    + byrow=logical_value,dimnames=list(   </span><br><span class="line">    + char_vector_rowname,char_vector_colnames))</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了矩阵的元素，</li><li><code>nrow</code>和<code>ncol</code>用以指定行和列的维数，</li><li><code>dimnames</code>包含了可选的、以字符型向量表示的行名和列名</li><li>选项<code>byrow</code>则表明矩阵应当按行填充（<code>byrow=TRUE</code>）还是按列填充（<code>byrow=FALSE</code>），默认情况下按列填充。简单示例如下：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个5*4的矩阵</span></span><br><span class="line">&gt; y &lt;- matrix(<span class="number">1</span>:<span class="number">20</span>,nrow=<span class="number">5</span>,ncol=<span class="number">4</span>)     </span><br><span class="line">&gt; y</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span>   <span class="number">11</span>   <span class="number">16</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span>   <span class="number">12</span>   <span class="number">17</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span>   <span class="number">13</span>   <span class="number">18</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span>   <span class="number">14</span>   <span class="number">19</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span>   <span class="number">15</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按行填充的2*2矩阵</span></span><br><span class="line">&gt; cells &lt;- c(<span class="number">1</span>,<span class="number">26</span>,<span class="number">24</span>,<span class="number">68</span>)</span><br><span class="line">&gt; rnames &lt;- c(<span class="string">"R1"</span>,<span class="string">"R2"</span>)</span><br><span class="line">&gt; cname &lt;- c(<span class="string">"C1"</span>,<span class="string">"C2"</span>)</span><br><span class="line">&gt; &gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">TRUE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">26</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按列填充的2*2矩阵</span></span><br><span class="line">&gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">FALSE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">24</span></span><br><span class="line">R2 <span class="number">26</span> <span class="number">68</span></span><br></pre></td></tr></table></figure><hr><h3 id="矩阵元素的获取"><a href="#矩阵元素的获取" class="headerlink" title="矩阵元素的获取"></a>矩阵元素的获取</h3><p>我们可以使用索引的方式来选择矩阵中的行、列或元素。<code>X[i,]</code>指矩阵X中的第i行，<code>X[,j]</code>指第j列，<code>X[i, j]</code>指第i行第j个元素。选择<strong>多行或多列</strong>时，下标i和j可为数值型向量，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">2</span>)</span><br><span class="line">&gt; x</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">7</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span>    <span class="number">8</span>   <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二行的元素</span></span><br><span class="line">&gt; x[<span class="number">2</span>,]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二列的元素</span></span><br><span class="line">&gt; x[,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取第一行第4列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取第一行第4列、第五列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,c(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p></p><p>矩阵都是二维的，和向量类似，<strong>矩阵中也仅能包含一种数据类型</strong>；当<strong>维度超过2时，不妨使用数组</strong>；当有<strong>多种模式的数据时，不妨使用数据框</strong>。</p><hr><p><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p>数组（array）与矩阵类似，但是维度可以大于2。数组可通过array函数创建，形式如下：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray &lt;- array(vector,dimensions,dimnames)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了数组中的数据；</li><li><code>dimensions</code>是一个数值型向量，给出了各个维度下标的最大值；</li><li><code>dimnames</code>是可选的、各维度名称标签的列表。</li></ul><p>创建三维 （2×3×4）数值型数组:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; z &lt;- array(<span class="number">1</span>:<span class="number">24</span>, c(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&gt; z</span><br><span class="line">, , <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span></span><br><span class="line">A2  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">7</span>  <span class="number">9</span> <span class="number">11</span></span><br><span class="line">A2  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">13</span> <span class="number">15</span> <span class="number">17</span></span><br><span class="line">A2 <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">19</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line">A2 <span class="number">20</span> <span class="number">22</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p></p><p>如你所见，数组是矩阵的一个自然推广；它们在编写新的统计方法时可能很有用。</p><p>像矩阵一样，<strong>数组中的数据也只能拥有一种模式</strong>。</p><hr><h3 id="数组元素的获取"><a href="#数组元素的获取" class="headerlink" title="数组元素的获取"></a>数组元素的获取</h3><p>从数组中选取元素的方式与矩阵类似：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">15</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">3</span>  <span class="number">9</span> <span class="number">15</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>由于<strong>不同的列可以包含不同模式（数值型、字符型等）的数据，但每一列的数据类型必须唯一</strong>，数据框的用途更为广泛。</p><h3 id="数据框的创建"><a href="#数据框的创建" class="headerlink" title="数据框的创建"></a>数据框的创建</h3><p>数据框可通过函数<code>data.frame()</code>创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydata &lt;- data.frame(col1,col2,col3,…)</span><br></pre></td></tr></table></figure><p></p><ul><li>列向量<code>col1</code>, <code>col2</code>, <code>col3</code>,… 可为任何类型（如字符型、数值型或逻辑型）</li><li>每一列的名称可由函数<code>names</code>指定</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientID &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt; age &lt;- c(<span class="number">25</span>,<span class="number">34</span>,<span class="number">28</span>,<span class="number">52</span>)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID,age,diabetes,status)</span><br><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br></pre></td></tr></table></figure><p></p><p>每一列数据的模式必须唯一，不过你却可以将多个模式的不同列放到一起组成数据框。</p><h3 id="数据框元素的获取"><a href="#数据框元素的获取" class="headerlink" title="数据框元素的获取"></a>数据框元素的获取</h3><p>选取数据框中元素的方式有若干种，你可以使用索引，亦可直接指定列名。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br><span class="line"><span class="comment"># 通过索引</span></span><br><span class="line">&gt; patientdata[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">  patientID age</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span></span><br><span class="line"><span class="comment"># 直接指定列名</span></span><br><span class="line">&gt; patientdata[c(<span class="string">"diabetes"</span>,<span class="string">"status"</span>)]</span><br><span class="line">  diabetes    status</span><br><span class="line"><span class="number">1</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>    Type1      Poor</span><br><span class="line">&gt; patientdata[c(<span class="string">"age"</span>)]</span><br><span class="line">  age</span><br><span class="line"><span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>  <span class="number">52</span></span><br><span class="line">&gt; class(patientdata[c(<span class="string">"age"</span>)])</span><br><span class="line">[<span class="number">1</span>] <span class="string">"data.frame"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某列的值，并得到向量</span></span><br><span class="line">&gt; patientdata$age</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">&gt; class(patientdata$age)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br></pre></td></tr></table></figure><p></p><p>第三个例子中的记号<code>$</code>是新出现的，它被用来<strong>选取一个给定数据框中的某个特定变量，并且返回向量形式</strong>。例如，如果你想生成糖尿病类型变量diabetes和病情变量status的列联表，使用以下代码即可：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; table(patientdata$diabetes,patientdata$status)</span><br><span class="line"></span><br><span class="line">        Excellent Improved Poor</span><br><span class="line">  Type1         <span class="number">1</span>        <span class="number">0</span>    <span class="number">2</span></span><br><span class="line">  Type2         <span class="number">0</span>        <span class="number">1</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>在每个变量名前都键入一次<code>patientdata$</code>可能会让人生厌，所以不妨走一些捷径。可以联合使用函数<code>attach()</code>和<code>detach()</code>或单独使用函数<code>with()</code>来简化代码.</p><p><code>attach()</code>函数可<strong>将数据框添加到R的搜索路径中</strong>，R在遇到一个变量名以后，将检查搜索路径中的数据框，以定位到这个变量：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;summary(mtcars$mpg)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line">&gt;plot(mtcars$mpg,mtcars$disp)</span><br><span class="line">&gt; <span class="comment">#也可写成：</span></span><br><span class="line"><span class="comment"># 将数据框添加到R的搜索路径中</span></span><br><span class="line">&gt;<span class="keyword">attach</span>(mtcars)</span><br><span class="line">&gt;plot(mpg,disp)</span><br><span class="line"><span class="comment"># 将数据框从搜索路径中移除</span></span><br><span class="line">&gt;<span class="keyword">detach</span>(mtcars)</span><br></pre></td></tr></table></figure><p>当<strong>名称相同的对象不止一个时</strong>，这种方法的局限性就很明显了。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; mpg &lt;- c(<span class="number">25</span>,<span class="number">36</span>,<span class="number">47</span>)</span><br><span class="line">&gt; <span class="keyword">attach</span>(mtcars)</span><br><span class="line">The following object is masked _by_ .GlobalEnv:  mpg</span><br><span class="line"><span class="comment"># mtcars中也有mpg变量</span></span><br><span class="line">&gt; plot(mpg,wt)</span><br><span class="line">Error <span class="keyword">in</span> xy.coords(x, y, xlabel, ylabel, log) : </span><br><span class="line">  <span class="string">'x'</span> and <span class="string">'y'</span> lengths differ</span><br><span class="line">&gt; mpg</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">36</span> <span class="number">47</span></span><br><span class="line"><span class="comment"># 指定mpg来源</span></span><br><span class="line">&gt; plot(mtcars$mpg,wt)</span><br></pre></td></tr></table></figure><p></p><p>这里，在数据框mtcars被绑定（attach）之前，我们的环境中已经有了一个名为mpg的对象。 在这种情况下，原始对象将取得优先权，故而报错，这个时候想使用mpg时，便要像最后一段代码示例那般指定变量来源。</p><p>除此之外，另一种方式是使用函数<code>with()</code>，你可以这样重写上例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ plot(mpg,disp)</span><br><span class="line">+ &#125;)</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，<strong>大括号{}之间的语句都针对数据框mtcars执行</strong>，这样就无须担心名称冲突了；如果<strong>仅有一条语句（例如summary(mpg)），那么大括号{}可以省略</strong>；<strong>函数<code>with()</code>的局限性在于，赋值仅在此函数的括号内生效</strong>，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;stats &lt;-summary(mpg)</span><br><span class="line">+ stats</span><br><span class="line">+ &#125;)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line"><span class="comment"># 在with的&#123;&#125;之外</span></span><br><span class="line">&gt; stats</span><br><span class="line">错误: 找不到对象<span class="string">'stats'</span></span><br></pre></td></tr></table></figure><p></p><p>如果你需要创建在<code>with()</code>结构以外存在的对象，使用<code>特殊赋值符&lt;&lt;-</code>替代<code>标准赋值符&lt;-</code>即可，它可将对象保存到<code>with()</code>之外的全局环境中。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ nokeepstats &lt;- summary(mpg)</span><br><span class="line">+ keepstats &lt;&lt;- summary(mpg)</span><br><span class="line">+ &#125;)</span><br><span class="line">&gt; nokeepstats</span><br><span class="line">错误: 找不到对象<span class="string">'nokeepstats'</span></span><br><span class="line">&gt; keepstats</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>如你所见，变量可归结为名义型、有序型或连续型变量。名义型变量是没有顺序之分的类别变量，糖尿病类型Diabetes（Type1、Type2）是名义型变量的一例，即使在数据中Type1编码为1而Type2编码为2，这也并不意味着二者是有序的。有序型变量表示一种顺序关系，而非数量关系，病情Status（poor、improved、excellent）是顺序型变量的一个上佳示例。我们明白， 病情为poor（较差）病人的状态不如improved（病情好转）的病人，但并不知道相差多少。连续型变量可以呈现为某个范围内的任意值，并同时表示了顺序和数量，年龄Age就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值，我们很清楚，15岁的人比14岁的人年长一岁。</p><p><strong>类别（名义型）变量</strong>和<strong>有序类别（有序型）变量</strong>在R中称为<strong>因子（factor）</strong>。因子在R中非常重要，因为它决定了<strong>数据的分析方式</strong>以及<strong>如何进行视觉呈现</strong>，你将在本书中通篇看到这样的例子。函数<code>factor()</code>以一个整数向量的形式存储类别值，整数的取值范围是<code>[1… k]</code>（其中<code>k</code>是名义型变量中<strong>唯一值</strong>的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</p><p>举例来说，假设有向量：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; diabetes &lt;- c( <span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; diabetes &lt;- factor(diabetes)</span><br><span class="line">&gt; diabetes</span><br><span class="line">[<span class="number">1</span>] Type1 Type2 Type1 Type1</span><br><span class="line">Levels: Type1 Type2</span><br></pre></td></tr></table></figure><p></p><p>语句<code>diabetes &lt;- factor(diabetes)</code>将此向量存储为<code>(1, 2, 1, 1)</code>，并在内部将其关联为<code>1=Type1</code>和<code>2=Type2</code>（具体赋值根据字母顺序而定）。针对向量diabetes进行的任何分析都会<strong>将其作为名义型变量对待</strong>，并<strong>自动选择适合这一测量尺度的统计方法</strong>。要表示<strong>有序型变量</strong>，需要为函数<code>factor()</code>指定参数<code>ordered=TRUE</code>。给定向量:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br></pre></td></tr></table></figure><p></p><p>语句<code>status &lt;- factor(status, ordered=TRUE)</code>会将向量编码为<code>(3, 2, 1, 3)</code>，并在内部将这些值关联为<code>1=Excellent</code>、<code>2=Improved</code>以及<code>3=Poor</code>.对于<strong>字符型向量</strong>，因子的水平<strong>默认依字母顺序创建</strong>，这对于因子status是有意义的，因为 <code>Excellent</code>、<code>Improved</code>、<code>Poor</code>的排序方式恰好与逻辑顺序相一致，如果<code>Poor</code>被编码为<code>Ailing</code>，会有问题，因为顺序将为<code>Ailing</code>、<code>Excellent</code>、<code>Improved</code>。如果理想中的顺序是<code>Poor</code>、<code>Improved</code>、<code>Excellent</code>，则会出现类似的问题：按默认的字母顺序排序的因子很少能够让人满意，你可以通过指定<code>levels</code>选项来覆盖默认排序。例如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是按照字母顺序创建</span></span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现Ailing会破坏顺序</span></span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>,<span class="string">"Ailing"</span>)</span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor      Ailing   </span><br><span class="line">Levels: Ailing &lt; Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用levels指定顺序</span></span><br><span class="line">&gt; status &lt;- factor(status,ordered=<span class="literal">TRUE</span>,</span><br><span class="line">+ levels=c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>)</span><br><span class="line">+ )</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Poor &lt; Improved &lt; Excellent</span><br></pre></td></tr></table></figure><p></p><p>因子的使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建dataframe</span></span><br><span class="line">&gt; patientdata &lt;-data.frame(patientID,age,diabetes,status)</span><br><span class="line"><span class="comment"># 查看各列数据的类型</span></span><br><span class="line">&gt; str(patientdata)</span><br><span class="line"><span class="string">'data.frame'</span>:   <span class="number">4</span> obs. of  <span class="number">4</span> variables:</span><br><span class="line">  $ patientID: num  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">  $ age      : num  <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">  $ diabetes : Factor w/ <span class="number">2</span> levels <span class="string">"Type1"</span>,<span class="string">"Type2"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  $ status   : Ord.factor w/ <span class="number">3</span> levels <span class="string">"Poor"</span>&lt;<span class="string">"Improved"</span>&lt;..: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 显示基本统计信息</span></span><br><span class="line">&gt; summary(patientdata)</span><br><span class="line">    patientID         age         diabetes       status </span><br><span class="line">  Min.   :<span class="number">1.00</span>   Min.   :<span class="number">25.00</span>   Type1:<span class="number">3</span>   Poor     :<span class="number">2</span>  </span><br><span class="line">  1st Qu.:<span class="number">1.75</span>   1st Qu.:<span class="number">27.25</span>   Type2:<span class="number">1</span>   Improved :<span class="number">1</span>  </span><br><span class="line">  Median :<span class="number">2.50</span>   Median :<span class="number">31.00</span>             Excellent:<span class="number">1</span>  </span><br><span class="line">  Mean   :<span class="number">2.50</span>   Mean   :<span class="number">34.75</span>                          </span><br><span class="line">  3rd Qu.:<span class="number">3.25</span>   3rd Qu.:<span class="number">38.50</span>                          </span><br><span class="line">  Max.   :<span class="number">4.00</span>   Max.   :<span class="number">52.00</span></span><br></pre></td></tr></table></figure><p></p><p><code>str(patientdata)</code>清楚地显示<code>diabetes</code>是一个<strong>因子</strong>，而<code>status</code>是一个<strong>有序型因子</strong>，以及此数据框在<strong>内部是如何进行编码的</strong>。注意，函数<code>summary()</code>会<strong>区别对待各个变量</strong>，它显示了连续型变量age的最小值、最大值、均值和各四分位数，并显示了类别型变量diabetes和status（各水平）的频数值。</p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）是R的数据类型中为复杂的一种，一般来说，列表就是一些对象（或成分， component）的有序集合，列表允许你整合若干（可能无关的）对象到单个对象名下。例如，某个列表中可能是若干<strong>向量</strong>、<strong>矩阵</strong>、<strong>数据框</strong>，甚至<strong>其他列表</strong>的组合。</p><p>可以使用函数<code>list()</code>创建列表:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;- list(object1,object2,…)</span><br></pre></td></tr></table></figure><p></p><p>其中的对象可以是目前为止讲到的任何结构。你还可以为列表中的对象命名：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;`- list(name1=object1,name2=object2,…)</span><br></pre></td></tr></table></figure><p>具体使用示例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; g &lt;- <span class="string">"My First List"</span></span><br><span class="line">&gt; h &lt;- c(<span class="number">25</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">39</span>)</span><br><span class="line">&gt; j &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">5</span>)</span><br><span class="line">&gt; k &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)</span><br><span class="line">&gt; mylist &lt;- list(title=g,ages=h,j,k)</span><br><span class="line">&gt; mylist</span><br><span class="line">$title</span><br><span class="line">[<span class="number">1</span>] <span class="string">"My First List"</span></span><br><span class="line"></span><br><span class="line">$ages</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">26</span> <span class="number">18</span> <span class="number">39</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p>本例创建了一个列表，其中有四个成分：一个字符串、一个数值型向量、一个矩阵以及一个字符型向量。</p><p>在访问列表中元素时，可以通过在<strong>双重方括号</strong>中<strong>指明代表某个成分的数字</strong>或<strong>名称</strong>来访问列表中的元素。此例 中，<code>mylist[[2]]</code>和<code>mylist[[“ages”]]</code>均指那个含有四个元素的向量。</p><p>由于两个原因，列表成为了R中的重要数据结构:</p><ul><li>首先，列表允许以一种简单的方式组织和重新调用不相干的信息；</li><li>其次，许多R函数的运行结果都是以列表的形式返回的，需要取出其中哪些成分由分析人员决定。</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">R语言入门之创建数据集——向量、矩阵、数组、数据框和列表</a></li><li><a href="https://www.cnblogs.com/ljhdo/p/5173674.html" target="_blank" rel="noopener">R语言学习 第一篇：变量和向量</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要是基于&lt;a href=&quot;https://blog.csdn.net/qq_28945021/article/details/52100765&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;学习了R中几种常见的数据结构，包括&lt;code&gt;向量&lt;/code&gt;、&lt;code&gt;矩阵&lt;/code&gt;、&lt;code&gt;数组&lt;/code&gt;、&lt;code&gt;数据框&lt;/code&gt;以及&lt;code&gt;列表&lt;/code&gt;，主要围绕这些数据结构的&lt;code&gt;构成&lt;/code&gt;、&lt;code&gt;创建&lt;/code&gt;、&lt;code&gt;获取元素&lt;/code&gt;进行了学习，后续使用中可以查询和补充。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之字符串处理</title>
    <link href="http://showteeth.tech/posts/28337.html"/>
    <id>http://showteeth.tech/posts/28337.html</id>
    <published>2019-08-24T13:43:57.000Z</published>
    <updated>2019-08-25T03:05:25.756Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<strong>R中的字符向量处理函数</strong>，主要包括<strong>字符数统计和字符翻译</strong>、<strong>字符串连接</strong>、<strong>字符串拆分</strong>、<strong>字符串查询</strong>、<strong>字符串替换</strong>、<strong>字符串提取</strong>、<strong>字符串显示控制</strong>等。</p></div><a id="more"></a><h2 id="字符数统计和字符翻译"><a href="#字符数统计和字符翻译" class="headerlink" title="字符数统计和字符翻译"></a>字符数统计和字符翻译</h2><h3 id="nchar和length"><a href="#nchar和length" class="headerlink" title="nchar和length"></a>nchar和length</h3><p><code>nchar</code>这个函数简单，统计<strong>向量中每个元素的字符个数</strong>，注意<strong>这个函数和<code>length</code>函数的差别</strong>：</p><ul><li><code>nchar</code>是<strong>向量元素的字符个数</strong>;</li><li>而<code>length</code>是<strong>向量长度（向量元素的个数）</strong>.</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"Hellow"</span>, <span class="string">"World"</span>, <span class="string">"!"</span>)</span><br><span class="line"><span class="comment"># 向量中每个元素的长度</span></span><br><span class="line">nchar(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">6</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量的长度</span></span><br><span class="line">length(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h3 id="tolower、toupper和chartr"><a href="#tolower、toupper和chartr" class="headerlink" title="tolower、toupper和chartr"></a>tolower、toupper和chartr</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DNA &lt;- <span class="string">"AtGCtttACC"</span></span><br><span class="line"><span class="comment"># 将上述字符转换为小写</span></span><br><span class="line">tolower(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"atgctttacc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述字符转换为大写</span></span><br><span class="line">toupper(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"ATGCTTTACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;u</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"Uu"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AuGCuuuACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;U</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"UU"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AUGCUUUACC"</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><h3 id="paste函数"><a href="#paste函数" class="headerlink" title="paste函数"></a>paste函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义分隔符</span></span><br><span class="line">paste (<span class="keyword">...</span>, sep = <span class="string">" "</span>, collapse = <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment"># 默认没有分隔符</span></span><br><span class="line">paste0(<span class="keyword">...</span>, collapse = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短的向量CK会被循环使用</span></span><br><span class="line">paste(<span class="string">"CK"</span>, <span class="number">1</span>:<span class="number">6</span>, sep = <span class="string">"|"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"CK|1"</span> <span class="string">"CK|2"</span> <span class="string">"CK|3"</span> <span class="string">"CK|4"</span> <span class="string">"CK|5"</span> <span class="string">"CK|6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短的向量会被循环使用</span></span><br><span class="line">x = c(a = <span class="string">"aaa"</span>, b = <span class="string">"bbb"</span>, c = <span class="string">"ccc"</span>)</span><br><span class="line">y = c(d = <span class="number">1</span>, e = <span class="number">2</span>)</span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>) </span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span> <span class="string">"bbb-2"</span> <span class="string">"ccc-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述操作返回的都是一个向量</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>)[<span class="number">1</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想将所有的连接成一个字符串</span></span><br><span class="line"><span class="comment"># 使用collapse参数</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>,collapse = <span class="string">";"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1;bbb-2;ccc-1"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><h3 id="strsplit函数"><a href="#strsplit函数" class="headerlink" title="strsplit函数"></a>strsplit函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strsplit(x, split, fixed = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>参数<code>x</code>为字串向量，<strong>每个元素都将单独进行拆分</strong>;</li><li>参数<code>split</code>为拆分位置的字串向量，默认<code>fixed=FALSE</code>为<strong>正则表达式匹配</strong>。如果你没接触过正则表达式，设置<code>fixed=TRUE</code>，表示使用<strong>普通文本匹配或正则表达式的精确匹配</strong>；普通文本的运算速度快;</li><li><code>perl=TRUE/FALSE</code>的设置和perl语言版本有关，如果正则表达式很长，正确设置表达式并且使用perl=TRUE可以提高运算速度;</li><li>参数<code>useBytes</code>设置<strong>是否逐个字节进行匹配</strong>，默认为FALSE，即按字符而不是字节进行匹配。</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- <span class="string">"Hello Adam!\nHello Ava!"</span></span><br><span class="line"><span class="comment"># 将上述字符按空格分隔</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span>        <span class="string">"Adam!\nHello"</span> <span class="string">"Ava!"</span> </span><br><span class="line"><span class="comment"># 返回的是一个列表</span></span><br><span class="line">class(strsplit(text, <span class="string">" "</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line"><span class="comment"># 输出分割后的第一个字符</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)[[<span class="number">1</span>]][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式进行分割</span></span><br><span class="line"><span class="comment"># 按空白分隔：空格、制表符、换行符等</span></span><br><span class="line">strsplit(text, <span class="string">"\\s"</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span> <span class="string">"Adam!"</span> <span class="string">"Hello"</span> <span class="string">"Ava!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到单个字符</span></span><br><span class="line">strsplit(text, <span class="string">""</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"d"</span>  <span class="string">"a"</span>  <span class="string">"m"</span>  <span class="string">"!"</span>  <span class="string">"\n"</span> <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"v"</span>  <span class="string">"a"</span>  <span class="string">"!"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h2><h3 id="grep和grepl函数"><a href="#grep和grepl函数" class="headerlink" title="grep和grepl函数"></a>grep和grepl函数</h3><p>这两个函数返回向量水平的匹配结果(向量中每个元素可以不可以匹配上)，不涉及匹配字符串的详细位置信息(在每个元素的什么索引位置匹配上).</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, value = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>, invert = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">grepl(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">      fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下所有的文件</span></span><br><span class="line">files &lt;- list.files(<span class="string">"./"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找以gz结尾的文件</span></span><br><span class="line"><span class="comment"># 返回的是可以匹配上的元素在整个向量中的索引位置</span></span><br><span class="line">grep(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的是向量元素中的每一个是不是可以匹配上</span></span><br><span class="line">grepl(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者虽然在输出表现上有所差异，但是在提取向量子集时结果相同</span></span><br><span class="line">files[grep(<span class="string">"\\.gz$"</span>, files)]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="regexpr、gregexpr和regexec"><a href="#regexpr、gregexpr和regexec" class="headerlink" title="regexpr、gregexpr和regexec"></a>regexpr、gregexpr和regexec</h3><p>这三个函数返回的结果包含了<strong>匹配的具体位置</strong>和<strong>匹配上的字符串长度信息</strong>，可以用于字符串的提取操作.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gregexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">         fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">regexec(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>三个函数的区别：</p><ul><li><code>regexpr</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>数字向量</strong></li><li><code>gregexpr</code>返回的是向量中每个元素<strong>所有出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li><li><code>regexec</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- c(<span class="string">"Hellow, Adam!Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素第一次出现Adam的位置</span></span><br><span class="line">class(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"integer"</span></span><br><span class="line">regexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  <span class="comment"># 匹配上的第一个字符位置 </span></span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span>  <span class="number">5</span> <span class="number">14</span></span><br><span class="line">  <span class="comment"># 匹配上的部分长度</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 获取上述结果中的match.length</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  $match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  $index.type</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line"></span><br><span class="line">  $useBytes</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 得到向量</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))$match.length</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素所有出现Adam的位置</span></span><br><span class="line">class(gregexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">gregexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span> <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 这个也是一样的方法</span></span><br><span class="line">attributes(gregexpr(<span class="string">"Adam"</span>, text)[[<span class="number">1</span>]])$match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素首次出现Adam的位置</span></span><br><span class="line">class(regexec(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">regexec(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">9</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="sub和gsub函数"><a href="#sub和gsub函数" class="headerlink" title="sub和gsub函数"></a>sub和gsub函数</h3><p>虽然<code>sub</code>和<code>gsub</code>是用于字符串替换的函数，但严格地说R语言没有字符串替换的函数，因为<strong>R语言不管什么操作对参数都是传值不传址(原始变量不会被修改)</strong>.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">    fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gsub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sub</span></span><br><span class="line"><span class="comment"># 将每个元素中的Adam替换为world</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始的text的内容还是没有发生改变</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, Adam!"</span>      <span class="string">"Hi, Adam!"</span>          <span class="string">"How are you, Adam."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gsub</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取表达式</span></span><br><span class="line"><span class="comment"># 使用转义字符+数字表示分组</span></span><br><span class="line">sub(pattern = <span class="string">".*(Adam).*"</span>, replacement = <span class="string">"\\1"</span>, text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Adam"</span> <span class="string">"Adam"</span> <span class="string">"Adam"</span></span><br></pre></td></tr></table></figure><p></p><p><code>sub</code>和<code>gsub</code>的区别：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改text内容</span></span><br><span class="line">text &lt;- c(<span class="string">"Hellow, Adam! Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub只会替换第一次出现的</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! Adam"</span> <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而gsub会将所有的都进行替换</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! world"</span> <span class="string">"Hi, world!"</span>           <span class="string">"How are you, world."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串提取"><a href="#字符串提取" class="headerlink" title="字符串提取"></a>字符串提取</h2><h3 id="substr和substring函数"><a href="#substr和substring函数" class="headerlink" title="substr和substring函数"></a>substr和substring函数</h3><p><code>substr</code>和<code>substring</code>函数<strong>通过位置进行字符串拆分或提取</strong>，它们<strong>本身并不使用正则表达式</strong>，但是结合正则表达式函数<code>regexpr</code>、<code>gregexpr</code>或<code>regexec</code>使用可以非常方便地从大量文本中提取所需信息。两者的参数设置基本相同：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substr(x, start, <span class="keyword">stop</span>)</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>)</span><br><span class="line">substr(x, start, <span class="keyword">stop</span>) &lt;- value</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>) &lt;- value</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>均为要拆分的字串向量</li><li><code>start/first</code> 为截取的起始位置向量</li><li><code>stop/last</code> 为截取字串的终止位置向量</li></ul><p>两个函数在返回值上存在差异：</p><ul><li>substr返回的字串个数等于第一个参数(要拆分的字串向量)的长度</li><li>substring返回字串个数等于三个参数中最长向量长度(要拆分的字串向量、起始位置向量、终止位置向量)，短向量循环使用</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">"123456789"</span></span><br><span class="line"><span class="comment"># 截取的区间是2-4、4-5、2-8(单向量循环使用)</span></span><br><span class="line"><span class="comment"># 因为x的长度为1，所以只会输出第一个2-4的结果</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># substring使用是输出最长向量长度的子串</span></span><br><span class="line">substring(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"45"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>关于短向量循环使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"123456789"</span>, <span class="string">"abcdefghijklmnopq"</span>)</span><br><span class="line"><span class="comment"># 因为x的长度为2，所以输出了两个</span></span><br><span class="line"><span class="comment"># 另外，x向量也会循环使用，2-4切数字、4-5切字母</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span> <span class="string">"de"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于x也可以循环可以看看substring</span></span><br><span class="line"><span class="comment"># 2-4切数字、4-5切字母、2-8切数字</span></span><br><span class="line">substring(x,c(<span class="number">2</span>,<span class="number">4</span>),c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"de"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>用<code>substring</code>函数可以很方便地把<code>DNA/RNA</code>序列进行<strong>三联拆分（用于蛋白质翻译）</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到随机序列</span></span><br><span class="line">bases = c(<span class="string">"A"</span>, <span class="string">"T"</span>, <span class="string">"G"</span>, <span class="string">"C"</span>)</span><br><span class="line">DNA = paste(sample(bases, <span class="number">12</span>, replace = <span class="literal">T</span>), collapse = <span class="string">""</span>)</span><br><span class="line">DNA</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCTGTCGGCTGC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三联拆分</span></span><br><span class="line">substring(DNA, seq(<span class="number">1</span>, <span class="number">10</span>, by = <span class="number">3</span>), seq(<span class="number">3</span>, <span class="number">12</span>, by = <span class="number">3</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCT"</span> <span class="string">"GTC"</span> <span class="string">"GGC"</span> <span class="string">"TGC"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串显示控制"><a href="#字符串显示控制" class="headerlink" title="字符串显示控制"></a>字符串显示控制</h2><h3 id="显示宽度-strtrim函数"><a href="#显示宽度-strtrim函数" class="headerlink" title="显示宽度-strtrim函数"></a>显示宽度-strtrim函数</h3><p>用于将字符串修剪到特定的显示宽度，其用法为<code>strtrim(x, width)</code>，<strong>返回字符串向量的长度等于x的长度</strong>。因为是“修剪”，所以<strong>只能去掉多余的字符不能增加其他额外的字符(这就感觉很鸡肋了。。。。)</strong>; 如果<strong>字符串本身的长度小于width，得到的是原字符串</strong>，别指望它会用空格或其他什么字符补齐：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大于width的字符部分会被去除</span></span><br><span class="line">strtrim(c(<span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>), c(<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"a"</span>      <span class="string">"abcde"</span>  <span class="string">"abcdef"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不足width的字符会输出原字符串</span></span><br><span class="line">strtrim(c(<span class="number">1</span>, <span class="number">123</span>, <span class="number">1234567</span>), <span class="number">4</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"1"</span>    <span class="string">"123"</span>  <span class="string">"1234"</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串段落化-strwrap函数"><a href="#字符串段落化-strwrap函数" class="headerlink" title="字符串段落化-strwrap函数"></a>字符串段落化-strwrap函数</h3><p>strwrap函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串，其帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strwrap(x, width = <span class="number">0.9</span> * getOption(<span class="string">"width"</span>), indent = <span class="number">0</span>,</span><br><span class="line">        exdent = <span class="number">0</span>, prefix = <span class="string">""</span>, simplify = <span class="literal">TRUE</span>, initial = prefix)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>表示待处理的字符向量</li><li><code>width</code>表示每行的宽度</li><li><code>indent</code>表示首行缩进</li><li><code>exdent</code>表示除首行外的其他行的缩进</li><li><code>simplify</code>表示结果的显示形式，<code>TRUE</code>表示返回向量，<code>FALSE</code>表示返回列表</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"Each character string in the input is first split into paragraphs\n(or lines containing whitespace only).  The paragraphs are then\nformatted by breaking lines at word boundaries.  The target\ncolumns for wrapping lines and the indentation of the first and\nall subsequent lines of a paragraph can be controlled\nindependently."</span></span><br><span class="line">str2 = rep(str1, <span class="number">2</span>)</span><br><span class="line">strwrap(str2, width = <span class="number">80</span>, indent = <span class="number">2</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">2</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">3</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">4</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">5</span>] <span class="string">"controlled independently."</span>                                                    </span><br><span class="line">  [<span class="number">6</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">7</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">9</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">10</span>] <span class="string">"controlled independently."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><p>##参考链接</p><ul><li><a href="https://blog.csdn.net/duqi_yc/article/details/9817243" target="_blank" rel="noopener">R字符串处理-grep/grepl/sub/gsub等等</a></li><li><a href="https://likan.info/cn/post/pattern-matching-and-replacement/" target="_blank" rel="noopener">R 中字符串的查找和替换</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了&lt;strong&gt;R中的字符向量处理函数&lt;/strong&gt;，主要包括&lt;strong&gt;字符数统计和字符翻译&lt;/strong&gt;、&lt;strong&gt;字符串连接&lt;/strong&gt;、&lt;strong&gt;字符串拆分&lt;/strong&gt;、&lt;strong&gt;字符串查询&lt;/strong&gt;、&lt;strong&gt;字符串替换&lt;/strong&gt;、&lt;strong&gt;字符串提取&lt;/strong&gt;、&lt;strong&gt;字符串显示控制&lt;/strong&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python中常用的snippets</title>
    <link href="http://showteeth.tech/posts/21065.html"/>
    <id>http://showteeth.tech/posts/21065.html</id>
    <published>2019-08-24T09:05:46.000Z</published>
    <updated>2019-08-24T16:03:33.988Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。</p></div><a id="more"></a><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> qgrid</span><br><span class="line"><span class="comment"># qgrid.show_grid(df, show_toolbar=True)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"><span class="comment"># ignore warning info</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># sns.set_style("white")</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.style.use('ggplot')</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># interactive visualization</span></span><br><span class="line"><span class="keyword">from</span> bokeh.palettes <span class="keyword">import</span> Spectral11</span><br><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_notebook, show</span><br><span class="line"><span class="keyword">from</span> bokeh.models <span class="keyword">import</span> LinearAxis, Range1d</span><br><span class="line">output_notebook()</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse, sys, os, errno</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,format=<span class="string">"%(levelname)s-%(filename)s:[%(lineno)d]-%(message)s"</span>)</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之正则表达式系统梳理</title>
    <link href="http://showteeth.tech/posts/28940.html"/>
    <id>http://showteeth.tech/posts/28940.html</id>
    <published>2019-08-23T03:15:01.000Z</published>
    <updated>2019-08-24T16:03:33.983Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://aandds.com/blog/lang-regex.html" target="_blank" rel="noopener">Regular Expressions</a></li><li><a href="https://juejin.im/post/5b4a9539f265da0f521de210" target="_blank" rel="noopener">正则中关于环视（lookaround）的小例子</a></li><li><a href="https://zhuanlan.zhihu.com/p/50789818" target="_blank" rel="noopener">正则表达式中 Lookaround</a></li><li><a href="http://www.ayqy.net/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">正则表达式学习笔记</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之grep进阶</title>
    <link href="http://showteeth.tech/posts/5793.html"/>
    <id>http://showteeth.tech/posts/5793.html</id>
    <published>2019-08-22T12:52:16.000Z</published>
    <updated>2019-08-22T15:41:40.762Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对学习中经常遇到的几种情况：<strong>允许mismatch的grep</strong>、<strong>加速grep</strong>、<strong>管道grep高亮</strong>等问题，探索了一些解决方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>针对以下需求：</p><ul><li><code>grep</code>仅支持<strong>完全的匹配</strong>，如果想要进行<strong>支持mismatch的操作</strong>，该怎么办？</li><li>常规的<code>grep</code>在进行大文件的查找时很慢，如果<strong>加速这种查找</strong>？</li><li><code>grep</code>加入管道之后，查找出来的<strong>字符就不高亮</strong>了，如何解决？</li></ul><hr><h2 id="允许mismatch的grep"><a href="#允许mismatch的grep" class="headerlink" title="允许mismatch的grep"></a>允许mismatch的grep</h2><h3 id="agrep工具"><a href="#agrep工具" class="headerlink" title="agrep工具"></a>agrep工具</h3><p><code>agrep</code>命令简介：</p><blockquote><p>AGREP is a powerful tool for <strong>fast searching</strong> a file or many files for a <strong>string or regular expression</strong>, with <strong>approximate matching</strong> capabilities and <strong>user-definable records</strong>. AGREP is similar to egrep (or grep or fgrep), but it is <strong>much more general</strong> and usually <strong>faster</strong>. Approximate matching allows finding records that <strong>contain the pattern</strong> with several errors including <strong>substitutions</strong>, <strong>insertions</strong>, and <strong>deletions</strong>.</p></blockquote><h4 id="agrep安装"><a href="#agrep安装" class="headerlink" title="agrep安装"></a>agrep安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget ftp://ftp.cs.arizona.edu/agrep/agrep-2.04.tar</span><br><span class="line"><span class="comment"># 提取文件</span></span><br><span class="line">tar -xvf  agrep-2.04.tar</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 写入环境变量</span></span><br></pre></td></tr></table></figure><hr><h4 id="agrep命令格式及相关参数"><a href="#agrep命令格式及相关参数" class="headerlink" title="agrep命令格式及相关参数"></a>agrep命令格式及相关参数</h4><p>命令格式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agrep [ -<span class="comment">#cdehiklnpstvwxBDGIS ] pattern [ -f patternfile ] [ filename... ]</span></span><br></pre></td></tr></table></figure><p></p><p>相关参数：</p><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td>-#</td><td>find matches with at most # errors</td></tr><tr><td>-c</td><td>output the number of matched records</td></tr><tr><td>-d</td><td>define record delimiter</td></tr><tr><td>-h</td><td>do not output file names</td></tr><tr><td>-i</td><td>case-insensitive search, e.g., 'a' = 'A'</td></tr><tr><td>-l</td><td>output the names of files that contain a match</td></tr><tr><td>-n</td><td>output record prefixed by record number</td></tr><tr><td>-v</td><td>output those records containing no matches</td></tr><tr><td>-w</td><td>pattern has to match as a word, e.g., 'win' will not match 'wind'</td></tr><tr><td>-B</td><td>best match mode. find the closest matches to the pattern</td></tr><tr><td>-G</td><td>output the files that contain a match</td></tr><tr><td>-D<span style="font-style:italic">k</span></td><td>Set the cost of a deletion to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr><tr><td>-I<span style="font-style:italic">k</span></td><td>Set the cost of an insertion to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr><tr><td>-S<span style="font-style:italic">k</span></td><td>Set the cost of a substitution to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr></table><hr><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><hr><h4 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h4><p>近似匹配直接使用<code>-num</code>开启，其中<code>num</code>表示<code>mismatch</code>的个数，最终输出的结果是<code>mismatch&lt;=num</code>的行。</p><p>允许<strong>一个</strong>mimatch：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'ABCDEFG'</span> test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>允许<strong>两个</strong>mimatch：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">agrep -2 <span class="string">'ABCDEFG'</span> test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="设置罚分"><a href="#设置罚分" class="headerlink" title="设置罚分"></a>设置罚分</h4><p>测试文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p><strong>不设置</strong>罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>设置<strong>增加deletion</strong>的罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deletiond 的罚分增加到2</span></span><br><span class="line"><span class="comment"># 这样将会去除deletion的匹配</span></span><br><span class="line">agrep -1 -D2 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>设置<strong>增加deletion、insertion</strong>的罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deletiond、insertion的罚分增加到2</span></span><br><span class="line"><span class="comment"># 这样将会去除deletion、insertion的匹配</span></span><br><span class="line">agrep -1 -D2 -I2 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="结合正则表达式"><a href="#结合正则表达式" class="headerlink" title="结合正则表达式"></a>结合正则表达式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'abc[0-9](de|fg)*[x-z]'</span> foo</span><br></pre></td></tr></table></figure><p>Outputs the lines containing, <strong>within up to one error</strong>, the string that starts with “abc” followed by one digit, followed by zero or more repetitions of either “de” or “fg”, followed by either “x”, “y”, or “z”.</p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.biostars.org/p/4346/" target="_blank" rel="noopener">Question: Matching Strings With Mismatches</a></li><li><a href="https://github.com/Wikinaut/agrep" target="_blank" rel="noopener">github链接</a></li><li><a href="https://linux.die.net/man/1/agrep" target="_blank" rel="noopener">agrep(1) - Linux man page</a></li><li><a href="https://www.computerhope.com/unix/agrep.htm" target="_blank" rel="noopener">Linux agrep command-使用实例</a></li></ul><hr><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul><li><a href="https://github.com/laurikari/tre" target="_blank" rel="noopener">tre-The approximate regex matching library and agrep command line tool.</a></li><li><a href="https://metacpan.org/release/LIMAONE/Bio-Grep-v0.10.6" target="_blank" rel="noopener">Bio::Grep-perl module</a></li></ul><hr><p><br></p><h2 id="加速grep操作"><a href="#加速grep操作" class="headerlink" title="加速grep操作"></a>加速grep操作</h2><h3 id="parallel命令"><a href="#parallel命令" class="headerlink" title="parallel命令"></a>parallel命令</h3><p>结合之前学习了<a href="http://showteeth.tech/posts/25074.html">parallel命令</a>的<code>--pipe</code>模式对<code>grep</code>进行加速：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未进行优化的grep</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz | grep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line"></span><br><span class="line">  real    2m3.063s</span><br><span class="line">  user    2m14.375s</span><br><span class="line">  sys     0m10.078s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用parallel命令</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |parallel --pipe --block 1M --roundrobin --<span class="built_in">jobs</span> 10 grep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line">  real    2m53.983s</span><br><span class="line">  user    2m57.954s</span><br><span class="line">  sys     0m24.801s</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="优化grep"><a href="#优化grep" class="headerlink" title="优化grep"></a>优化grep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化后的grep</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz | LC_ALL=C fgrep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line"></span><br><span class="line">  real    2m12.462s</span><br><span class="line">  user    2m24.124s</span><br><span class="line">  sys     0m11.276s</span><br></pre></td></tr></table></figure><ul><li>Prefix your grep command with <code>LC_ALL=C</code> to use the <code>C locale</code> instead of <code>UTF-8</code>.</li><li>Use <code>fgrep</code> because you’re searching for a <code>fixed string</code>, not a regular expression.</li></ul><hr><h3 id="使用ripgrep"><a href="#使用ripgrep" class="headerlink" title="使用ripgrep"></a>使用ripgrep</h3><p>安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/BurntSushi/ripgrep/releases/download/11.0.2/ripgrep-11.0.2-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf  ripgrep-11.0.2-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ripgrep-11.0.2-x86_64-unknown-linux-musl</span><br><span class="line"></span><br><span class="line">./rg --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |/Share2/home/wangjb/songyabing/software/ripgrep-11.0.2-x86_64-unknown-linux-musl/rg <span class="string">"GTGAGATAGGAA"</span> dev/null</span><br><span class="line">  real    2m12.286s</span><br><span class="line">  user    2m26.400s</span><br><span class="line">  sys     0m12.404s</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用agrep"><a href="#使用agrep" class="headerlink" title="使用agrep"></a>使用agrep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |/Share2/home/wangjb/songyabing/software/agrep-2.04/agrep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line">  real    2m12.551s</span><br><span class="line">  user    2m26.266s</span><br><span class="line">  sys     0m10.803s</span><br></pre></td></tr></table></figure><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/9066609/fastest-possible-grep/9067042" target="_blank" rel="noopener">Fastest possible grep</a></li><li><a href="https://stackoverflow.com/questions/13913014/grepping-a-huge-file-80gb-any-way-to-speed-it-up" target="_blank" rel="noopener">Grepping a huge file (80GB) any way to speed it up?</a></li><li><a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">ripgrep recursively searches directories for a regex pattern</a></li><li><a href="https://github.com/chinanf-boy/ripgrep-zh#%E6%9B%B4%E6%96%B0-" target="_blank" rel="noopener">ripgrep 是一个面向行的搜索工具</a></li></ul><div class="note info"><p>虽然大部分的网站都给出了上述几种加速的方法，但是<strong>实际测试之后发现效果并不是很好</strong>，难道是不适用我这种情况？后续再看看吧。</p></div><hr><p><br></p><h2 id="管道grep高亮"><a href="#管道grep高亮" class="headerlink" title="管道grep高亮"></a>管道grep高亮</h2><p>使用<code>--color=always</code>参数可以使grep的结果<strong>一直保持高亮</strong>，不管处于管道的什么位置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat test2.txt|grep --color=always <span class="string">"ABCD"</span> |more </span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章针对学习中经常遇到的几种情况：&lt;strong&gt;允许mismatch的grep&lt;/strong&gt;、&lt;strong&gt;加速grep&lt;/strong&gt;、&lt;strong&gt;管道grep高亮&lt;/strong&gt;等问题，探索了一些解决方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之parallel-并行化工具</title>
    <link href="http://showteeth.tech/posts/25074.html"/>
    <id>http://showteeth.tech/posts/25074.html</id>
    <published>2019-08-18T09:36:41.000Z</published>
    <updated>2019-08-24T08:06:53.438Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中强大的并行工具<code>parallel</code>，其主要有<strong>两种工作模式</strong>：给<strong>命令传递参数</strong>以及<strong>管道模式(<code>--pipe</code>参数)</strong>，在实际使用中其主要作用在于<strong>改写for循环、减少重复性的操作</strong>。</p></div><a id="more"></a><h2 id="parallel介绍"><a href="#parallel介绍" class="headerlink" title="parallel介绍"></a>parallel介绍</h2><p><a href="https://www.gnu.org/software/parallel/" target="_blank" rel="noopener">官网介绍</a>：</p><blockquote><p>GNU parallel is a shell tool for <strong>executing jobs in parallel using one or more computers</strong>. A job can be a <strong>single command</strong> or <strong>a small script</strong> that has to be <strong>run for each of the lines in the input</strong>. The typical input is <strong>a list of files</strong>, <strong>a list of hosts</strong>, <strong>a list of users</strong>, <strong>a list of URLs</strong>, or <strong>a list of tables</strong>. A job can also be a command that <strong>reads from a pipe</strong>. GNU parallel can then <strong>split the input and pipe it into commands in parallel</strong>.</p><p>If you use <strong>xargs</strong> and tee today you will find GNU parallel very easy to use as GNU parallel is written to <strong>have the same options as xargs</strong>. If you write <strong>loops in shell</strong>, you will find GNU parallel may be able to <strong>replace most of the loops and make them run faster</strong> by running several jobs in parallel.</p><p>GNU parallel makes sure output from the commands is the same output as you would get had you run the commands sequentially. This makes it possible to use output from GNU parallel as input for other programs.</p><p>For each line of input GNU parallel will execute command with the line as arguments. If no command is given, the line of input is executed. Several lines will be run in parallel. <strong>GNU parallel can often be used as a substitute for xargs or cat | bash.</strong></p></blockquote><hr><p><br></p><h2 id="安装parallel"><a href="#安装parallel" class="headerlink" title="安装parallel"></a>安装parallel</h2><p>parallel并不是系统自带的命令，所以需要先下载安装才可以正常使用，这里是<strong>非root</strong>下的下载安装过程，root下要简单很多，具体的<a href="https://ftp.gnu.org/gnu/parallel/" target="_blank" rel="noopener">下载地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/parallel/parallel-20190722.tar.bz2</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -jxvf parallel-20190722.tar.bz2</span><br><span class="line"><span class="comment"># 为编译做准备</span></span><br><span class="line">./configure --prefix=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 测试安装是否成功</span></span><br><span class="line"><span class="built_in">cd</span> bin </span><br><span class="line">./parallel --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑环境变量</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="parallel命令格式"><a href="#parallel命令格式" class="headerlink" title="parallel命令格式"></a>parallel命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"><span class="comment"># 模式一：传递参数给command</span></span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] &lt; list_of_arguments</span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] (::: arguments|:::: argfile(s))...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式二：pipe模式，给command传递stdin</span></span><br><span class="line">cat ... | parallel --pipe [options] [<span class="built_in">command</span> [arguments]]</span><br></pre></td></tr></table></figure><h2 id="parallel使用示例"><a href="#parallel使用示例" class="headerlink" title="parallel使用示例"></a>parallel使用示例</h2><h3 id="参数输入方式"><a href="#参数输入方式" class="headerlink" title="参数输入方式"></a>参数输入方式</h3><h4 id="命令行输入"><a href="#命令行输入" class="headerlink" title="命令行输入"></a>命令行输入</h4><p><code>tee命令</code>：<code>Linux tee</code>命令将<strong>数据重定向到文件</strong>，<strong>另一方面</strong>还可以提供一份重定向数据的副本<strong>作为后续命令的stdin</strong>。简单的说就是<strong>把数据重定向到给定文件和屏幕上。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个输入源</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: a b c d e |tee test.txt</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p>第一次使用还会输出引用的提示：</p><blockquote><p>Academic tradition requires you to cite works you base your article on.<br>If you use programs that use GNU Parallel to process data for an article in a<br>scientific publication, please cite:</p><p>O. Tange (2018): GNU Parallel 2018, Mar 2018, ISBN 9781387509881,<br>DOI <a href="https://doi.org/10.5281/zenodo.1146014" target="_blank" rel="noopener">https://doi.org/10.5281/zenodo.1146014</a></p><p>This helps funding further development; AND IT WON’T COST YOU A CENT.<br>If you pay 10000 EUR you should feel free to use GNU Parallel without citing.</p><p>More about funding GNU Parallel and the citation notice:<br><a href="https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice" target="_blank" rel="noopener">https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice</a></p><p>To silence this citation notice: run ‘parallel –citation’ once.</p></blockquote><hr><h4 id="管道输入"><a href="#管道输入" class="headerlink" title="管道输入"></a>管道输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt |parallel <span class="built_in">echo</span></span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><hr><h4 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用重定向符号进行文件输入</span></span><br><span class="line">parallel <span class="built_in">echo</span> &lt; test.txt </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::输入文件</span></span><br><span class="line">parallel <span class="built_in">echo</span> :::: test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="组合输入的信息"><a href="#组合输入的信息" class="headerlink" title="组合输入的信息"></a>组合输入的信息</h3><p>将输入的信息进行组合，需要指定<strong>多个输入源</strong>，指定多个输入源的方法主要包括：</p><ul><li><strong>多个命令行形式</strong>的输入源</li><li><strong>多个文件形式(-a参数或者::::)</strong>的输入源</li><li><strong>命令行、管道和文件形式的输入源组合</strong></li></ul><h4 id="命令行输入-1"><a href="#命令行输入-1" class="headerlink" title="命令行输入"></a>命令行输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parallel <span class="built_in">echo</span> ::: a b c ::: a b c</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  c a</span><br><span class="line">  c b</span><br><span class="line">  c c</span><br></pre></td></tr></table></figure><hr><h4 id="文件输入-1"><a href="#文件输入-1" class="headerlink" title="文件输入"></a>文件输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意下面两种方法的echo位置</span></span><br><span class="line">parallel -a test.txt -a test2.txt  <span class="built_in">echo</span></span><br><span class="line">parallel <span class="built_in">echo</span> :::: test.txt test2.txt</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  a d</span><br><span class="line">  a e</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><div class="note info"><p>当使用<code>-a</code>传递文件作为参数的时候，<code>-a</code>作为<code>parallel</code>的<strong>参数</strong>在<code>echo</code>命令<strong>前面</strong>；而直接使用<code>::::</code>传递文件作为输入的时候，文件作为<code>arguments</code>在<code>command</code>的<strong>后面</strong>。</p></div><hr><h4 id="混合输入"><a href="#混合输入" class="headerlink" title="混合输入"></a>混合输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a指定文件和管道的组合</span></span><br><span class="line">cat test.txt |parallel -a - -a test2.txt <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::指定文件和管道的组合</span></span><br><span class="line">cat test.txt |parallel <span class="built_in">echo</span> ::::  - test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::指定文件和:::指定命令行的组合</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: a b :::: test.txt</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  a d</span><br><span class="line">  a e</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  b d</span><br><span class="line">  b e</span><br></pre></td></tr></table></figure><hr><h3 id="取消输入的组合"><a href="#取消输入的组合" class="headerlink" title="取消输入的组合"></a>取消输入的组合</h3><p>如果<strong>不想在进行多个输入源的输入时出现的组合现象</strong>，可以使用<code>--xapply</code>指定从<strong>每个输入源中获取一个参数(或一行)</strong>，<strong>较短的输入源会进行重复直到较长的输入源全部输出</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个输入源长度相同</span></span><br><span class="line">parallel --xapply <span class="built_in">echo</span> ::: a b c ::: d e f </span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个输入源长度不同，较短的重复至较长的输出完</span></span><br><span class="line">parallel --xapply <span class="built_in">echo</span> ::: a b c ::: d e f g h</span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line">  a g</span><br><span class="line">  b h</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数分隔符"><a href="#指定参数分隔符" class="headerlink" title="指定参数分隔符"></a>指定参数分隔符</h3><p>在进行命令行参数输入时，如果遇到<code>:::</code>或<code>::::</code>被占用时，可以使用<code>--arg-sep</code>和<code>--arg-file-sep</code>分别指定命令行和文件的参数分隔符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定命令行的参数分隔符</span></span><br><span class="line">parallel --xapply --arg-sep ,,, <span class="built_in">echo</span> ,,, a b c ,,, d e f g h</span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line">  a g</span><br><span class="line">  b h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件的参数分隔符</span></span><br><span class="line">parallel --arg-file-sep ,,, <span class="built_in">echo</span> ,,, test.txt </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数定界符"><a href="#指定参数定界符" class="headerlink" title="指定参数定界符"></a>指定参数定界符</h3><p>默认的参数定界符为<code>\n</code>，也就是把<strong>每一行当做一个参数</strong>，可以通过参数<code>-d</code>来<strong>改变参数定界符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变参数定界符为\t</span></span><br><span class="line">paste test.txt  test2.txt |parallel -d <span class="string">"\t"</span> <span class="built_in">echo</span> :::: - </span><br><span class="line">  a</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数结束值"><a href="#指定参数结束值" class="headerlink" title="指定参数结束值"></a>指定参数结束值</h3><p><code>Parallel</code>支持通过<code>-E</code>参数<strong>指定一个值做为结束标志</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parallel -E stop <span class="built_in">echo</span> ::: A B stop C D</span><br><span class="line">  A</span><br><span class="line">  B</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="跳过空行"><a href="#跳过空行" class="headerlink" title="跳过空行"></a>跳过空行</h3><p><code>Parallel</code>使用 <code>--no-run-if-empty</code> 来跳过空行:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> 1; <span class="built_in">echo</span>; <span class="built_in">echo</span> 2) | parallel --no-run-if-empty <span class="built_in">echo</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对输入参数进行替换"><a href="#对输入参数进行替换" class="headerlink" title="对输入参数进行替换"></a>对输入参数进行替换</h3><p>Parallel支持多种方式来对输入的参数进行字符串替换，默认使用的是符号是 <code>{}</code>，也就是<strong>输出原始输入，没有任何替换(占位符)</strong>。其<strong>最常见的字符串替换</strong>如下：</p><ul><li><code>{.}</code>: 去掉<strong>扩展名</strong>；</li><li><code>{/}</code>: <strong>去掉路径</strong>，只<strong>保留文件名</strong>；</li><li><code>{//}</code>: 只<strong>保留路径</strong>；</li><li><code>{/.}</code>: <strong>同时去掉路径和扩展名</strong>；</li><li><code></code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入是A目录下存在B.C这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数-I来改变默认的占位符符号&#123;&#125;</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: A/B.C ; parallel <span class="built_in">echo</span> &#123;&#125; ::: A/B.C ; parallel -I ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉输出参数中包括的拓展名信息</span></span><br><span class="line"><span class="comment"># 将默认的&#123;.&#125;替换为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;.&#125; ::: A/B.C ; parallel --extensionreplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  A/B</span><br><span class="line">  A/B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中包括的文件名信息，和basename命令作用相同</span></span><br><span class="line"><span class="comment"># 将默认的&#123;/&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;/&#125; ::: A/B.C ; parallel --basenamereplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  B.C</span><br><span class="line">  B.C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中包括的路径信息</span></span><br><span class="line"><span class="comment"># 将默认的&#123;//&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;//&#125; ::: A/B.C ; parallel --dirnamereplace ,, <span class="built_in">echo</span> ,, ::: A/B.C </span><br><span class="line">  A</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中的文件名信息(不包括后缀)</span></span><br><span class="line"><span class="comment"># 将默认的&#123;/.&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;/.&#125; ::: A/B.C ; parallel --basenameextensionreplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  B</span><br><span class="line">  B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入并行的任务编号</span></span><br><span class="line"><span class="comment"># 将默认的&#123;#&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;<span class="comment">#&#125; ::: A B C ; parallel --seqreplace ,, echo ,, ::: A B C</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><hr><h3 id="指定输入源输出顺序"><a href="#指定输入源输出顺序" class="headerlink" title="指定输入源输出顺序"></a>指定输入源输出顺序</h3><p>如果有多个输入源时，可以通过 <code>{编号}</code> <strong>代指某一个输入源的参数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;1&#125;表示输入源1中的内容，&#123;2&#125;表示输入源2中的内容</span></span><br><span class="line">parallel --xapply  <span class="built_in">echo</span> &#123;1&#125; and &#123;2&#125; ::: A B ::: C D;parallel --xapply  <span class="built_in">echo</span> &#123;2&#125; and &#123;1&#125; ::: A B ::: C D</span><br><span class="line">  A and C</span><br><span class="line">  B and D</span><br><span class="line">  C and A</span><br><span class="line">  D and B</span><br></pre></td></tr></table></figure><p></p><p>输入源也可以使用<strong>负数指定，表示倒着数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parallel <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; -1=&#123;-1&#125; -2=&#123;-2&#125; ::: A B ::: C D</span><br><span class="line">  1=A 2=C -1=C -2=A</span><br><span class="line">  1=A 2=D -1=D -2=A</span><br><span class="line">  1=B 2=C -1=C -2=B</span><br><span class="line">  1=B 2=D -1=D -2=B</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数名和参数"><a href="#指定参数名和参数" class="headerlink" title="指定参数名和参数"></a>指定参数名和参数</h3><p>使用 <code>--header</code>指定每一行输入中的第一个值做为参数名:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parallel --xapply --header : <span class="built_in">echo</span> f1=&#123;f1&#125; f2=&#123;f2&#125; ::: f1 A B ::: f2 C D | tee d.txt</span><br><span class="line">  f1=A f2=C</span><br><span class="line">  f1=B f2=D</span><br></pre></td></tr></table></figure><p></p><p>使用 <code>--colsep</code> 指定列分隔符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'printf "f1\tf2\nA\tB\nC\tD\n"'</span> &gt; tsv-file.tsv</span><br><span class="line">parallel --header : --colsep <span class="string">'\t'</span> <span class="built_in">echo</span> f1=&#123;f1&#125; f2=&#123;f2&#125; :::: tsv-file.tsv </span><br><span class="line">  f1=A f2=B</span><br><span class="line">  f1=C f2=D</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="背景文本"><a href="#背景文本" class="headerlink" title="背景文本"></a>背景文本</h3><p>占位符<code>{}</code>可以是<strong>输出字符的一部分</strong>，使用<code>-m</code>参数表示<strong>每个jobs不重复输出背景文本(除去替换字符串之外的字符内容)</strong>，而<code>-X</code>参数与<code>-m</code>参数<strong>功能相反</strong>，会在<strong>每个jobs中都输出背景文本</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下是会输出背景文本的</span></span><br><span class="line"><span class="comment"># 并且每个参数输出一行</span></span><br><span class="line">parallel  --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A-post</span><br><span class="line">  pre-B-post</span><br><span class="line">  pre-C-post</span><br><span class="line">  pre-D-post</span><br><span class="line">  pre-E-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-m参数取消在每个jobs中输出背景文本</span></span><br><span class="line"><span class="comment"># 并且同一个jobs中的参数在同一行输出</span></span><br><span class="line">parallel -m --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A B-post</span><br><span class="line">  pre-C D-post</span><br><span class="line">  pre-E-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-X参数指定在每个jobs中输出背景文本</span></span><br><span class="line"><span class="comment"># 并且同一个jobs中的参数在同一行输出</span></span><br><span class="line">parallel -X --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A-post pre-B-post</span><br><span class="line">  pre-C-post pre-D-post</span><br><span class="line">  pre-E-post</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="限制每次读取的参数个数"><a href="#限制每次读取的参数个数" class="headerlink" title="限制每次读取的参数个数"></a>限制每次读取的参数个数</h3><p><code>parallel</code>使用 <code>-N</code> 限制每次参数的个数，其中<code>-N0</code>表示一次<strong>只读取一个参数，且不输入这个参数（作为计数器来使用）</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次读取四个参数，并将所有读取的参数输出</span></span><br><span class="line"><span class="comment"># 相当于依次把数据分成了四个源，然后进行不带组合的输出</span></span><br><span class="line">parallel -N 4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125; 4=&#123;4&#125; ::: A B C D E F G H</span><br><span class="line">  1=A 2=B 3=C 4=D</span><br><span class="line">  1=E 2=F 3=G 4=H</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次读取四个参数，只输出其中的一部分参数</span></span><br><span class="line">parallel -N 4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125;  ::: A B C D E F G H</span><br><span class="line">  1=A 2=B 3=C</span><br><span class="line">  1=E 2=F 3=G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当做计数器使用，不会输出后续的参数</span></span><br><span class="line">parallel -N 0 <span class="built_in">echo</span> &#123;&#125;_foo ::: A B C</span><br><span class="line">  _foo</span><br><span class="line">  _foo</span><br><span class="line">  _foo</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="去除输入参数的空格"><a href="#去除输入参数的空格" class="headerlink" title="去除输入参数的空格"></a>去除输入参数的空格</h3><p><code>parallel</code>使用<code>--trim</code>去除参数两头的空格，其有三种模式，去除左边的空格(<code>--trim l</code>)、右边的空格(<code>--trim r</code>)、左右的空格(<code>--trim lr</code>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除右边的空格</span></span><br><span class="line">parallel --trim r <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre- A-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除左边的空格</span></span><br><span class="line">parallel --trim l <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre-A -post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除左右两边的空格</span></span><br><span class="line">parallel --trim lr <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre-A-post</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="添加输出前缀"><a href="#添加输出前缀" class="headerlink" title="添加输出前缀"></a>添加输出前缀</h3><p><code>parallel</code>允许使用<code>--tag</code>参数来指定<strong>以参数作为输出字符的前缀</strong>，使用<code>--tagstring</code>来<strong>自定义输出前缀</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --tag：输入参数作为输出前缀</span></span><br><span class="line">parallel --tag <span class="built_in">echo</span> foo_&#123;&#125; ::: A B C</span><br><span class="line">  A       foo_A</span><br><span class="line">  B       foo_B</span><br><span class="line">  C       foo_C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改输出前缀</span></span><br><span class="line">parallel --tagstring &#123;&#125;_foo <span class="built_in">echo</span> foo_&#123;&#125; ::: A B C</span><br><span class="line">  A_foo   foo_A</span><br><span class="line">  B_foo   foo_B</span><br><span class="line">  C_foo   foo_C</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="运行之前打印命令"><a href="#运行之前打印命令" class="headerlink" title="运行之前打印命令"></a>运行之前打印命令</h3><p><code>parallel</code>使用<code>--verbose</code>参数来指定在运行命令之前先打印命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parallel --verbose <span class="built_in">echo</span> &#123;&#125; ::: A B C</span><br><span class="line">  <span class="built_in">echo</span> A</span><br><span class="line">  <span class="built_in">echo</span> B</span><br><span class="line">  <span class="built_in">echo</span> C</span><br><span class="line">  A</span><br><span class="line">  B</span><br><span class="line">  C</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="任务运行日志"><a href="#任务运行日志" class="headerlink" title="任务运行日志"></a>任务运行日志</h3><p>使用<code>--joblog</code>参数能够<strong>生成各个任务的日志文件</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parallel的运行日志为/tmp/log</span></span><br><span class="line">parallel --joblog /tmp/<span class="built_in">log</span> <span class="built_in">exit</span>  ::: 1 2 3 0</span><br><span class="line">cat /tmp/<span class="built_in">log</span> </span><br><span class="line">  Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">  1   :   1523950890.344       0.018  0   0   1   0   <span class="built_in">exit</span> 1</span><br><span class="line">  2   :   1523950890.350       0.014  0   0   2   0   <span class="built_in">exit</span> 2</span><br><span class="line">  3   :   1523950890.357       0.006  0   0   3   0   <span class="built_in">exit</span> 3</span><br><span class="line">  4   :   1523950890.363       0.006  0   0   0   0   <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p><strong>运行失败任务</strong>处理：</p><ul><li>通过<code>--resume-failed</code>参数可以重新运行失败的任务;</li><li><code>--retry-failed</code>的作用与<code>--resume-failed</code>类似，只是<code>--resume-failed</code>从<strong>命令行</strong>读取失败任务，而<code>--retry-failed</code>则是从<strong>日志文件</strong>中读取失败任务：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从命令行读取失败任务</span></span><br><span class="line"><span class="comment"># 所以需要加载最开始的运行命令中</span></span><br><span class="line">parallel --resume-failed --joblog /tmp/<span class="built_in">log</span> <span class="built_in">exit</span>  ::: 1 2 3 0 0 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从日志文件读取失败任务</span></span><br><span class="line"><span class="comment"># 只用指定日志文件即可</span></span><br><span class="line">parallel --retry-failed --joblog /tmp/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><hr><h3 id="终止任务"><a href="#终止任务" class="headerlink" title="终止任务"></a>终止任务</h3><p><code>parallel</code>支持<strong>在某一情况下</strong>（如第一个失败或成功时，或者20%任务失败时）终止任务，终止任务又有<strong>两种类型</strong>:</p><ul><li>其一为<strong>立即终止（通过<code>--halt now</code>指定）</strong>，<strong>杀死所有正在运行</strong>的任务并停止生成新的任务;</li><li>其二为<strong>稍后终止（通过<code>--halt soon</code>指定）</strong>，停止生成新任务并<strong>等待正在运行任务完成</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在遇到一个失败任务之后待正在运行的任务完成就终止</span></span><br><span class="line">parallel -j2 --halt soon,fail=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在遇到一个失败任务之后立即终止</span></span><br><span class="line">parallel -j2 --halt now,fail=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在失败任务数达到20%之后待正在运行的任务完成就终止</span></span><br><span class="line">parallel -j2 --halt soon,fail=20% <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 1 2 3 4 5 6 7 8 9  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在成功的任务数达到1之后立即终止</span></span><br><span class="line">parallel -j2 --halt now,success=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 1 2 3 0 4 5 6</span><br></pre></td></tr></table></figure><hr><h3 id="管道模式–pipe"><a href="#管道模式–pipe" class="headerlink" title="管道模式–pipe"></a>管道模式–pipe</h3><p>前面学习的所有内容基本都是<strong>传参数模式</strong>，也就是不管是从文件还是命令行获取输入，都会作为命令的参数；而使用<code>--pipe</code>模式之后则会将<strong>管道前面的内容作为标准输入传给后面的命令</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_large_log   |parallel --pipe grep pattern</span><br></pre></td></tr></table></figure><p></p><p>如果不加 <code>--pipe</code> ，相当于 <code>my_large_log</code>中的<strong>每一行</strong>都变成 <code>grep pattern line</code>的命令展开了；而加入了<code>--pipe</code>，则和 <code>cat my_large_log | grep pattern</code> 没有区别，只是分配到各个核上去执行了。</p><p>具体的，<code>--pipe</code>参数会<strong>将输入(stdin)分为多个block</strong>，然后<strong>分配给多个核运行</strong>，具体的过程：</p><blockquote><p>command_A | command_B. By default GNU parallel will start an instance of command_B, read a chunk of 1 MB, and pass that to the instance. Then start another instance, read another chunk, and pass that to the second instance.</p></blockquote><p>可以使用<code>--block</code>参数可以指定每块的大小，<strong>默认为1M(The size of the chunk is not exactly 1 MB because GNU parallel only passes full lines - never half a line, thus the blocksize is only 1 MB on average.)</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并行计算文件行数</span></span><br><span class="line">cat num30000 | parallel --pipe wc -l</span><br><span class="line">  30000 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置block大小为100k</span></span><br><span class="line">cat num30000 | parallel --block 100k  --pipe wc -l </span><br><span class="line">  18517</span><br><span class="line">  11483</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用原始方法计算</span></span><br><span class="line">wc -l num30000</span><br><span class="line">  30000 num30000</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>输出结果的顺序不重要</strong>，可以使用<code>--roundrobin</code>参数，并且结合<code>--jobs</code>参数指定任务，那么所有的block就会在指定的任务数中执行，某个提前运行完了就会接着运行下一个(或者一部分)，这样更加均衡；如果不加<code>--roundrobin</code>参数，每个block都会开启一个任务，不会管均衡不均衡。</p><hr><p><br></p><h2 id="parallel相关实战"><a href="#parallel相关实战" class="headerlink" title="parallel相关实战"></a>parallel相关实战</h2><h3 id="改写for循环"><a href="#改写for循环" class="headerlink" title="改写for循环"></a>改写for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始的for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *jpeg</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  convert <span class="variable">$i</span> <span class="variable">$i</span>.png </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改写后的命令行</span></span><br><span class="line"><span class="comment"># --max-args表示每次读取的参数个数，使用-N2也是一样的效果</span></span><br><span class="line"><span class="comment"># -I修改了占位符</span></span><br><span class="line">find . -name <span class="string">"*jpeg"</span> | parallel -I % --max-args 1 convert % %.png</span><br></pre></td></tr></table></figure><h3 id="一次传入多个参数"><a href="#一次传入多个参数" class="headerlink" title="一次传入多个参数"></a>一次传入多个参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意需要将&gt;使用引号括起来，不然得到的结果是所有的文件保存到了&#123;1&#125;_&#123;2&#125;.person中</span></span><br><span class="line">ls -1 | parallel --max-args=2 cat &#123;1&#125; &#123;2&#125; <span class="string">"&gt;"</span> &#123;1&#125;_&#123;2&#125;.person</span><br><span class="line"><span class="comment"># 使用-N2也是一样的效果</span></span><br><span class="line">ls -1 | parallel -N2 cat &#123;1&#125; &#123;2&#125; <span class="string">"&gt;"</span> &#123;1&#125;_&#123;2&#125;.png</span><br></pre></td></tr></table></figure><hr><h3 id="负载管理"><a href="#负载管理" class="headerlink" title="负载管理"></a>负载管理</h3><p>关于<a href="https://www.cnblogs.com/muahao/p/6492665.html" target="_blank" rel="noopener">cpu负载</a>：</p><blockquote><p>单核单CPU：如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。<br>单核多CPU：2个CPU，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍；所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。<br>多CPU多核：在系统负荷方面，多核CPU与多CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过1.0，就表明电脑正常运行。</p></blockquote><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parallel --eta -j 2 --load 80% --noswap \</span><br><span class="line">  <span class="string">'blastp -db pdb_blast_db_example/pdb_seqres.txt -query &#123;&#125; \</span></span><br><span class="line"><span class="string">  -out blastp_outfiles/&#123;.&#125;.out -evalue 0.0001 -word_size 7 -outfmt "6 std stitle staxids sscinames" \</span></span><br><span class="line"><span class="string">  -max_target_seqs 10 -num_threads 1'</span> \</span><br><span class="line">  ::: test_seq*.fas</span><br></pre></td></tr></table></figure><p></p><p>其中：</p><ul><li><code>--eta</code>：显示任务完成的预计剩余时间；</li><li><code>-j 2</code>或<code>-jobs 2</code>：同时运行的命令数，在本例中设置为2；</li><li><code>--load 80%</code>：<strong>最大cpu负载</strong>；在上面的命令中，我们指定最多可以运行80％的CPU</li><li><code>--noswap</code>：如果服务器处于大量<strong>内存负载</strong>下，则<strong>不会启动新作业</strong>，以便在存储新信息之前从内存中删除信息。</li></ul><p>其他：</p><ul><li><code>--memfree 1G</code>：内存只有内存满足时才启动任务，Additionally, GNU parallel will kill off the <strong>youngest job if the memory free falls below 50% of the size</strong>. The killed job will put back on the queue and retried later.</li></ul><hr><h3 id="对脚本进行parallel"><a href="#对脚本进行parallel" class="headerlink" title="对脚本进行parallel"></a>对脚本进行parallel</h3><p>创建<code>python</code>脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"the input num of arguments is \t:%s"</span> %str(len(sys.argv)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br></pre></td></tr></table></figure><p></p><p>运行<code>parallel</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">parallel python parallel.py ::: a b c d e</span><br><span class="line">  <span class="comment"># 发现每次输出的参数格式都是2，说明是并行运行的，不是串行的</span></span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  d</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  a</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  b</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  c</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接运行python</span></span><br><span class="line">python parallel.py a b c d e</span><br><span class="line">  the input num of arguments is   :6</span><br><span class="line">  parallel.py</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.gnu.org/software/parallel/parallel_tutorial.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.youtube.com/watch?v=OpaiGYxkSuQ&amp;list=PL284C9FF2488BC6D1" target="_blank" rel="noopener">官方操作视频</a></li><li><a href="https://linux.cn/article-9718-1.html" target="_blank" rel="noopener">使用 GNU Parallel 提高 Linux 命令行执行效率</a></li><li><a href="http://blog.sciencenet.cn/blog-3353749-1130387.html" target="_blank" rel="noopener">强大的并行工具 GNU Parallel</a></li><li><a href="https://www.jianshu.com/p/cc54a72616a1" target="_blank" rel="noopener">Linux下的并行神器——parallel</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中强大的并行工具&lt;code&gt;parallel&lt;/code&gt;，其主要有&lt;strong&gt;两种工作模式&lt;/strong&gt;：给&lt;strong&gt;命令传递参数&lt;/strong&gt;以及&lt;strong&gt;管道模式(&lt;code&gt;--pipe&lt;/code&gt;参数)&lt;/strong&gt;，在实际使用中其主要作用在于&lt;strong&gt;改写for循环、减少重复性的操作&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用基本命令" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Mac远程连接Windows</title>
    <link href="http://showteeth.tech/posts/11103.html"/>
    <id>http://showteeth.tech/posts/11103.html</id>
    <published>2019-08-17T06:29:26.000Z</published>
    <updated>2019-08-24T16:02:19.970Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了<strong>在mac上远程连接windows</strong>进行的设置。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近新购置了一台mac笔记本，但是因为之前使用的windows，并且很多资料都在windows上，所以迁移可能会花一点时间，所以就想先用mac，在遇到资料的时候直接远程windows获取资料即可。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里使用的工具是<code>Windows</code>官方为<code>Mac OS X</code>系统打造的远程连接<code>Windows</code>的软件，名字叫做<code>Microsoft Remote Desktop</code>，<a href="https://rink.hockeyapp.net/apps/5e0c144289a51fca2d3bfa39ce7f2b06/" target="_blank" rel="noopener">下载地址</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先是安装软件，这一步没啥问题直接跳过。</p><hr><h3 id="设置windows"><a href="#设置windows" class="headerlink" title="设置windows"></a>设置windows</h3><p>此电脑—&gt;属性—&gt;远程设置—&gt;远程—&gt;允许远程连接到此计算机。</p><hr><h3 id="添加windows"><a href="#添加windows" class="headerlink" title="添加windows"></a>添加windows</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_1.png" alt="Remote_Desktop_1.png"></p><p>其中的<code>PC name</code>是<strong>远程windows的IP地址</strong>，具体可以通过如下方式查看：</p><ul><li>打开<code>cmd</code></li><li>输入<code>ipconfig</code></li><li><code>IPv4 地址</code>即为这里需要填写的<code>PC name</code>信息</li></ul><p>其中的<code>friendly name</code>就是<code>Microsoft Remote Desktop</code>显示的远程桌面名称。</p><hr><h3 id="连接远程windows"><a href="#连接远程windows" class="headerlink" title="连接远程windows"></a>连接远程windows</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_2.png" alt="Remote_Desktop_2.png"></p><p>正确输入windows的用户名和密码之后就可以完成连接；<strong>第一次连接会有点慢和卡顿</strong>，这是正常的，后续连接几次就正常了。</p><p>需要注意的是：<strong>一旦mac远程连接了windows，那么windows就会回到锁屏界面，如果在windows上打开锁屏界面，回到桌面，那么mac就会出现如下报错</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_3.png" alt="Remote_Desktop_3.png"></p><hr><h2 id="使用中的问题"><a href="#使用中的问题" class="headerlink" title="使用中的问题"></a>使用中的问题</h2><h3 id="mac和windows连接不同的网络报错"><a href="#mac和windows连接不同的网络报错" class="headerlink" title="mac和windows连接不同的网络报错"></a>mac和windows连接不同的网络报错</h3><p>在上述操作完成之后，如果windows和mac在同一网络下是可以正常使用的，但一旦两者连接的网络不同，就会报错：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_4.png" alt="Remote_Desktop_4.png"></p><p>上述的<a href="#%e8%ae%be%e7%bd%aewindows">设置windows</a>步骤中只是打开了服务</p><p>解决方法：<br>看着好像都需要购买域名。。。。弃！</p><hr><h3 id="添加共享目录"><a href="#添加共享目录" class="headerlink" title="添加共享目录"></a>添加共享目录</h3><p>进行如下设置：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_5.png" alt="Remote_Desktop_5.png"></p><p>得到的效果：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_6.png" alt="Remote_Desktop_6.png"></p><p>上述操作完成后就可以在mac和windows之间共享文件了，只要放在这个目录下即可。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.hudongdong.com/skill/259.html" target="_blank" rel="noopener">mac远程控制windows</a></li><li><a href="https://www.jianshu.com/p/be9d825fc4a3" target="_blank" rel="noopener">Mac如何远程控制Windows</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了&lt;strong&gt;在mac上远程连接windows&lt;/strong&gt;进行的设置。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="远程连接" scheme="http://showteeth.tech/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之添加动态链接库地址</title>
    <link href="http://showteeth.tech/posts/10801.html"/>
    <id>http://showteeth.tech/posts/10801.html</id>
    <published>2019-08-14T03:59:15.000Z</published>
    <updated>2019-08-17T01:07:16.096Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对<strong>安装Python包没有出错但是在调用的时候却出错</strong>而发现的<strong>动态链接库地址不完整</strong>的问题，通过<strong>在环境变量(<code>~/.bashrc</code>)</strong>中添加<code>LD_LIBRARY_PATH</code>地址来解决；同时也学习了使用<code>locate</code>命令来直接查找文件。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在<strong>安装Python包的时候一直很顺利</strong>，并没有出现任何错误，但是在<strong>导入包的时候却报错</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libhdf5.so<span class="number">.101</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p></p><p>错误提示是找不到动态链接库<code>libhdf5.so.101</code>，但使用<code>find ~ -name &quot;libhdf5.so.101&quot;</code>是可以找到的。。。</p><h2 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h2><p>之前一直使用的是<code>find ~ -name &quot;libhdf5.so.101&quot;</code>来查找文件，虽说已经可以满足需求，但是毕竟需要输入这么长的命令，感觉有些麻烦，刚好发现了<code>locate</code>命令可以<strong>直接搜索文件名</strong>，所以这里就使用这个进行查找文件。</p><h3 id="安装locate"><a href="#安装locate" class="headerlink" title="安装locate"></a>安装locate</h3><p>使用<code>locate</code>的时候发现集群没有安装这个命令，所以需要先安装才能使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用yum查找一下</span></span><br><span class="line">yum search locate</span><br><span class="line">  mlocate.x86_64 : An utility <span class="keyword">for</span> finding files by name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装mlocate</span></span><br><span class="line">yum  install mlocate</span><br></pre></td></tr></table></figure><p></p><p>安装<code>mlocate</code>之后，使用<code>locate</code>命令的时候提示：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate: can not <span class="built_in">stat</span> () `/var/lib/mlocate/mlocate.db<span class="string">': No such file or directory</span></span><br></pre></td></tr></table></figure><p></p><p>解决方法是使用<code>updatedb</code>命令：</p><blockquote><p>This manual page documents the GNU version of updatedb, which <strong>updates</strong><br><strong>file name databases used by GNU locate</strong>. The file name databases<br>contain lists of files that were in particular directory trees when<br>the databases <strong>were last updated</strong>. The file name of the default<br>database is determined when locate and updatedb are configured and<br>installed. <strong>The frequency with which the databases are updated and</strong><br><strong>the directories for which they contain entries depend on how often</strong><br><strong>updatedb is run, and with which arguments.</strong></p></blockquote><p>因为是第一次运行<code>updatedb</code>，所以运行的时间很长，虽然后续运行也会很久。。。</p><h3 id="使用locate命令"><a href="#使用locate命令" class="headerlink" title="使用locate命令"></a>使用locate命令</h3><p><code>updatedb</code>命令运行完成之后就可以顺利使用<code>locate</code>命令了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">locate libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hba1933b_1/lib/libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hba1933b_1/lib/libhdf5.so.101.1.0</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hc401514_3/lib/libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hc401514_3/lib/libhdf5.so.101.1.0</span><br></pre></td></tr></table></figure><p></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>回到最开始的找不到动态链接库<code>libhdf5.so.101</code>上，首先剖析出现这个问题的过程：</p><ul><li>安装的时候没有报错，说明编译是没有问题的，可以找到动态链接库<code>libhdf5.so.101</code></li><li>调用的时候报错了，说明是在程序加载过程中没有找到动态链接库<code>libhdf5.so.101</code></li></ul><p>既然是调用过程中没有找到，那么可能就是安装包的过程中没有将这个动态链接库放在<code>LD_LIBRARY_PATH</code>中(<code>LD_LIBRARY_PATH</code>环境变量用于在<strong>程序加载运行期间</strong>查找动态链接库时指定的除了系统默认路径之外的其他路径).</p><p>接下来就是查看<code>LD_LIBRARY_PATH</code>以及确认<code>libhdf5.so.101</code>不在这个路径中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span> </span><br><span class="line">  /usr/<span class="built_in">local</span>/lib:</span><br><span class="line"></span><br><span class="line">ls /usr/<span class="built_in">local</span>/lib</span><br><span class="line">  <span class="comment"># 没有出现libhdf5.so.101</span></span><br></pre></td></tr></table></figure><p></p><p>上述结果表明<code>LD_LIBRARY_PATH</code>确实是没有动态链接库<code>libhdf5.so.101</code>，那么最直接的方法就是将<code>libhdf5.so.101</code>放在<code>/usr/local/lib</code>中，但是显然不是没有人都有权限修改这个文件夹的内容的，那么就只能修改<code>LD_LIBRARY_PATH</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一劳永逸的方法是修改环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/your/custom/path/</span><br><span class="line"><span class="comment"># 使修改生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p></p><p>经过以上过程之后再次导入包发现解决了问题。</p><div class="note info"><p><a href="https://www.cnblogs.com/panfeng412/archive/2011/10/20/library_path-and-ld_library_path.html" target="_blank" rel="noopener">补充说明</a>：</p><ul><li><code>LIBRARY_PATH</code>环境变量用于在程序<strong>编译期间</strong>查找动态链接库时指定查找共享库的路径，例如，指定gcc编译需要用到的动态链接库的目录</li></ul></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/11581898/hdf5-h5py-importerror-libhdf5-so-7" target="_blank" rel="noopener">hdf5 / h5py ImportError: libhdf5.so.7</a></li><li><a href="https://stackoverflow.com/questions/13428910/how-to-set-the-environmental-variable-ld-library-path-in-linux" target="_blank" rel="noopener">How to set the environmental variable LD_LIBRARY_PATH in linux</a></li><li><a href="https://my.oschina.net/shootercn/blog/94498" target="_blank" rel="noopener">设置 Linux 的 LD_LIBRARY_PATH 变量</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章针对&lt;strong&gt;安装Python包没有出错但是在调用的时候却出错&lt;/strong&gt;而发现的&lt;strong&gt;动态链接库地址不完整&lt;/strong&gt;的问题，通过&lt;strong&gt;在环境变量(&lt;code&gt;~/.bashrc&lt;/code&gt;)&lt;/strong&gt;中添加&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;地址来解决；同时也学习了使用&lt;code&gt;locate&lt;/code&gt;命令来直接查找文件。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之查看package源代码</title>
    <link href="http://showteeth.tech/posts/33992.html"/>
    <id>http://showteeth.tech/posts/33992.html</id>
    <published>2019-08-14T03:26:05.000Z</published>
    <updated>2019-08-17T01:07:16.117Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了查看R语言中源代码的方法：首先直接<strong>输出函数名</strong>或者使用<code>page</code>函数、<code>edit</code>函数查看，一般的函数可以直接显示源代码；如果出现<code>UseMethod(&quot;mean&quot;)</code>表明是使用S3对象进行面向对象封装，此时结合<code>methods</code>函数以及<code>getAnywhere()</code>、<code>package:::function</code>查看源代码；如果出现<code>standardGeneric(&quot;chol2inv&quot;)</code>就是表明使用的<strong>S4对象进行面向对象封装</strong>，此时结合<code>showMethods</code>函数以及<code>getMethod</code>查看源代码。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做项目过程中需要使用到R(虽然之前学过R，但是很久没用，所以已经有些生疏了)，想要看某个package中函数的源代码。</p><hr><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>直接输入函数名就可以得到相应的源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lm</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="page函数"><a href="#page函数" class="headerlink" title="page函数"></a>page函数</h3><p><code>page</code>函数会<strong>打开新窗口</strong>显示源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page(lm)</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><p>edit函数会<strong>弹出新窗口</strong>显示源代码，<strong>修改完成之后可以直接保存修改</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page(lm)</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对于S3对象系统"><a href="#对于S3对象系统" class="headerlink" title="对于S3对象系统"></a>对于S3对象系统</h3><p>在<a href="http://blog.fens.me/r-class-s3/" target="_blank" rel="noopener">R的面向对象编程</a>中，有<strong>3种底层对象类型</strong>，一种是<code>S3类型</code>，一种是<code>S4类型</code>，还有一种是<code>RC类型</code>:</p><ul><li><code>S3对象</code>简单、具有动态性、结构化特征不明显；</li><li><code>S4对象</code>结构化、功能强大；</li><li><code>RC对象</code>是2.12版本后使用的新类型，用于解决S3,S4很难实现的对象。</li></ul><h4 id="S3对象特征"><a href="#S3对象特征" class="headerlink" title="S3对象特征"></a>S3对象特征</h4><p><code>S3对象</code>的特征：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mean</span><br><span class="line">  standardGeneric <span class="keyword">for</span> <span class="string">"mean"</span> defined from package <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  standardGeneric(<span class="string">"mean"</span>)</span><br><span class="line">  &lt;environment: <span class="number">0x92ef470</span>&gt;</span><br><span class="line">  Methods may be defined <span class="keyword">for</span> arguments: x</span><br><span class="line">  Use  showMethods(<span class="string">"mean"</span>)  <span class="keyword">for</span> currently available ones.</span><br></pre></td></tr></table></figure><p></p><p>出现<code>UseMethod(&quot;mean&quot;)</code>的情况就是表明使用的<strong>S3对象进行面向对象封装</strong>。</p><hr><h4 id="查看内部行为函数-methods"><a href="#查看内部行为函数-methods" class="headerlink" title="查看内部行为函数-methods"></a>查看内部行为函数-methods</h4><p>对于S3对象进行面向对象封装的函数可以使用<code>methods</code>函数<strong>查看S3对象中的定义的内部行为函数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods(mean)</span><br><span class="line">  [<span class="number">1</span>] mean,ANY-method          mean,Matrix-method       mean,sparseMatrix-method mean,sparseVector-method</span><br><span class="line">  [<span class="number">5</span>] mean.Date                mean.default             mean.difftime            mean.IDate*</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是<strong>带星号的表示the function is not exported from its package’s namespace.</strong></p><p>这里列出来的<strong>不同的mean</strong>可能是<strong>针对不同的数据类型进行不同的计算方式</strong>，比如求一个向量的平均值和求一个数据框的平均值就有所差异，就要<strong>编写多个mean函数，然后“封”起来，以一个统一的mean出现，方便使用</strong>。</p><hr><h4 id="查看源代码-getAnywhere"><a href="#查看源代码-getAnywhere" class="headerlink" title="查看源代码-getAnywhere()"></a>查看源代码-getAnywhere()</h4><p>使用<code>getAnywhere()</code> 查看源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getAnywhere(mean.default)</span><br><span class="line">  A single object matching ‘mean.default’ was found</span><br><span class="line">  It was found <span class="keyword">in</span> the following places</span><br><span class="line">    package:base</span><br><span class="line">    registered S3 method <span class="keyword">for</span> mean from namespace base</span><br><span class="line">    namespace:base</span><br><span class="line">  with value</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, trim = <span class="number">0</span>, na.rm = <span class="literal">FALSE</span>, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) &#123;</span><br><span class="line">          <span class="keyword">warning</span>(<span class="string">"argument is not numeric or logical: returning NA"</span>)</span><br><span class="line">          <span class="keyword">return</span>(<span class="literal">NA_real_</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>使用<code>getAnywhere()</code>不仅能查看<strong>不带星号的函数的源代码</strong>，还能查看<strong>带星号的函数的源代码</strong></li><li>同时使用<code>getAnywhere()</code>查看函数的源代码可以<strong>不用指定函数的来源</strong>，这个后面的使用<code>package:::function</code>查看方式不同</li></ul></div><hr><h4 id="查看源代码-package-function"><a href="#查看源代码-package-function" class="headerlink" title="查看源代码-package:::function"></a>查看源代码-package:::function</h4><p>也可以使用<code>package:::function</code>查看：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base::mean.default</span><br><span class="line">  <span class="keyword">function</span> (x, trim = <span class="number">0</span>, na.rm = <span class="literal">FALSE</span>, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) &#123;</span><br><span class="line">          <span class="keyword">warning</span>(<span class="string">"argument is not numeric or logical: returning NA"</span>)</span><br><span class="line">          <span class="keyword">return</span>(<span class="literal">NA_real_</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p></p><p>但使用<code>package:::function</code><strong>不能查看带星号的函数的源代码</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base::mean.IDate</span><br><span class="line">  Error <span class="keyword">in</span> get(name, envir = ns, inherits = <span class="literal">FALSE</span>) : </span><br><span class="line">    object <span class="string">'mean.IDate'</span> not found</span><br><span class="line"></span><br><span class="line">stats::predict.ar</span><br><span class="line">  Error: <span class="string">'predict.ar'</span> is not an exported object from <span class="string">'namespace:stats'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对于S4对象系统"><a href="#对于S4对象系统" class="headerlink" title="对于S4对象系统"></a>对于S4对象系统</h3><h4 id="S4对象特征"><a href="#S4对象特征" class="headerlink" title="S4对象特征"></a>S4对象特征</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chol2inv</span><br><span class="line">  standardGeneric <span class="keyword">for</span> <span class="string">"chol2inv"</span> defined from package <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  standardGeneric(<span class="string">"chol2inv"</span>)</span><br><span class="line">  &lt;bytecode: <span class="number">0x7907390</span>&gt;</span><br><span class="line">  &lt;environment: <span class="number">0x78fbfc0</span>&gt;</span><br><span class="line">  Methods may be defined <span class="keyword">for</span> arguments: x</span><br><span class="line">  Use  showMethods(<span class="string">"chol2inv"</span>)  <span class="keyword">for</span> currently available ones.</span><br></pre></td></tr></table></figure><p>出现<code>standardGeneric(&quot;chol2inv&quot;)</code>就是表明使用的<strong>S4对象进行面向对象封装</strong>.</p><hr><h4 id="查看内部行为函数-showMethods"><a href="#查看内部行为函数-showMethods" class="headerlink" title="查看内部行为函数-showMethods"></a>查看内部行为函数-showMethods</h4><p>对于S4对象进行面向对象封装的函数可以使用<code>showMethods</code>函数<strong>查看S4对象中的定义的内部行为函数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showMethods(chol2inv)</span><br><span class="line">  Function: chol2inv (package base)</span><br><span class="line">  x=<span class="string">"ANY"</span></span><br><span class="line">  x=<span class="string">"CHMfactor"</span></span><br><span class="line">  x=<span class="string">"denseMatrix"</span></span><br><span class="line">  x=<span class="string">"diagonalMatrix"</span></span><br><span class="line">  x=<span class="string">"dtrMatrix"</span></span><br><span class="line">  x=<span class="string">"sparseMatrix"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看源代码-getMethod"><a href="#查看源代码-getMethod" class="headerlink" title="查看源代码-getMethod"></a>查看源代码-getMethod</h4><p>使用<code>getMethod</code>查看源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getMethod (<span class="string">"chol2inv"</span>, <span class="string">"diagonalMatrix"</span>)</span><br><span class="line">  Method Definition:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      chk.s(<span class="keyword">...</span>, which.call = -<span class="number">2</span>)</span><br><span class="line">      tcrossprod(solve(x))</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;bytecode: <span class="number">0x50dac48</span>&gt;</span><br><span class="line">  &lt;environment: namespace:Matrix&gt;</span><br><span class="line"></span><br><span class="line">  Signatures:</span><br><span class="line">          x               </span><br><span class="line">  target  <span class="string">"diagonalMatrix"</span></span><br><span class="line">  defined <span class="string">"diagonalMatrix"</span></span><br></pre></td></tr></table></figure><p></p><p></p><hr><br><br><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://rfaqs.com/source-code-of-r-method" target="_blank" rel="noopener">How to View Source Code of R Method/ Function?</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了查看R语言中源代码的方法：首先直接&lt;strong&gt;输出函数名&lt;/strong&gt;或者使用&lt;code&gt;page&lt;/code&gt;函数、&lt;code&gt;edit&lt;/code&gt;函数查看，一般的函数可以直接显示源代码；如果出现&lt;code&gt;UseMethod(&amp;quot;mean&amp;quot;)&lt;/code&gt;表明是使用S3对象进行面向对象封装，此时结合&lt;code&gt;methods&lt;/code&gt;函数以及&lt;code&gt;getAnywhere()&lt;/code&gt;、&lt;code&gt;package:::function&lt;/code&gt;查看源代码；如果出现&lt;code&gt;standardGeneric(&amp;quot;chol2inv&amp;quot;)&lt;/code&gt;就是表明使用的&lt;strong&gt;S4对象进行面向对象封装&lt;/strong&gt;，此时结合&lt;code&gt;showMethods&lt;/code&gt;函数以及&lt;code&gt;getMethod&lt;/code&gt;查看源代码。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之集群之间不输入密码传输数据</title>
    <link href="http://showteeth.tech/posts/17109.html"/>
    <id>http://showteeth.tech/posts/17109.html</id>
    <published>2019-08-14T01:15:50.000Z</published>
    <updated>2019-08-17T01:07:16.100Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在多个集群之间设置免密传输数据的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做项目的过程中经常会遇到将<strong>数据在多个集群中移动</strong>的步骤，但是<strong>每个集群的密码都不一样</strong>，记住密码比较麻烦，同时<strong>需要输入密码的行为也不适合写成脚本</strong>来运行，所以这里就想对各个集群进行设置，使其可以免密传输。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>之前学习过<a href="http://showteeth.tech/posts/51573.html">使用ssh key来将本地项目免密传输到远程的github以及coding pages</a>，这里也是使用ssh key来进行类似的设置。</p><h3 id="server1配置"><a href="#server1配置" class="headerlink" title="server1配置"></a>server1配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">  <span class="comment"># 输出如下内容，期间内容之间按enter即可</span></span><br><span class="line">  ssh-keygen -t rsa</span><br><span class="line">  Generating public/private rsa key pair.</span><br><span class="line">  Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Share2/home/wangjb//.ssh/id_rsa): </span><br><span class="line">  Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">  Enter same passphrase again: </span><br><span class="line">  Your identification has been saved <span class="keyword">in</span> /Share2/home/wangjb//.ssh/id_rsa.</span><br><span class="line">  Your public key has been saved <span class="keyword">in</span> /Share2/home/wangjb//.ssh/id_rsa.pub.</span><br><span class="line">  The key fingerprint is:</span><br><span class="line">  11:65:05:8c:ac:93:6b:40:4d:9d:91:c4:65:6c:68:fb wangjb@loginview02</span><br><span class="line">  The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">  +--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">  |     o.=+@*o.    |</span></span><br><span class="line"><span class="string">  |    . . X++      |</span></span><br><span class="line"><span class="string">  |   .   +.o       |</span></span><br><span class="line"><span class="string">  |    . + ..       |</span></span><br><span class="line"><span class="string">  |     . oS.       |</span></span><br><span class="line"><span class="string">  |      o   E      |</span></span><br><span class="line"><span class="string">  |     .           |</span></span><br><span class="line"><span class="string">  |                 |</span></span><br><span class="line"><span class="string">  |                 |</span></span><br><span class="line"><span class="string">  +-----------------+</span></span><br></pre></td></tr></table></figure><p>上述步骤会在<code>~/.ssh</code>生成<code>id_rsa</code>、<code>id_rsa.pub</code>，其中的<code>id_rsa</code>是私钥，<strong>不能泄露出去</strong>，<code>id_rsa.pub</code>是公钥，可以用于与其他远程平台的交互。</p><h3 id="server2配置"><a href="#server2配置" class="headerlink" title="server2配置"></a>server2配置</h3><p>将上述得到的公钥(以<code>pub</code>结尾的文件)内容复制到<code>server2</code>的<code>~/.ssh</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;authorized_keys</span><br></pre></td></tr></table></figure><p></p><p>执行上述步骤之后进行scp测试，发现<strong>还是不能免密传输</strong>，这时需要修改<code>server2</code>的<code>authorized_keys</code>权限为<code>600</code>，同时设置<code>~/.ssh</code>文件夹权限为<code>700</code>，<strong>保证同组或其他用户不能对这个进行修改</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p></p><p>完成权限设置之后就可以在<strong>从server1到server2进行免密传输了</strong>，但是<strong>server2到server1之间还是不能进行免密传输</strong>，如果想要在server2到server1上进行免密传输还需要反过来设置一次。</p><h3 id="多个authorized-keys"><a href="#多个authorized-keys" class="headerlink" title="多个authorized_keys"></a>多个authorized_keys</h3><p>如果存在<code>3个以上</code>的集群之间免密，就需要在每个集群上的<code>authorized_keys</code>中加入多个集群的<code>id_rsa.pub</code>内容，添加的方式是<strong>直接追加<code>&gt;&gt;</code>即可</strong>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/182483/scp-without-password-prompt-using-different-username" target="_blank" rel="noopener">SCP without password prompt using different username</a></li><li><a href="https://blogs.oracle.com/jkini/how-to-scp,-ssh-and-rsync-without-prompting-for-password" target="_blank" rel="noopener">How To scp, ssh and rsync without prompting for password</a></li><li><a href="https://stackoverflow.com/questions/1462284/how-to-respond-to-password-prompt-when-using-scp-in-a-shell-script" target="_blank" rel="noopener">How to respond to password prompt when using SCP in a shell script?</a></li><li><a href="https://stackoverflow.com/questions/6377009/adding-public-key-to-ssh-authorized-keys-does-not-log-me-in-automatically" target="_blank" rel="noopener">Adding public key to ~/.ssh/authorized_keys does not log me in automatically</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在多个集群之间设置免密传输数据的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之导入python文件</title>
    <link href="http://showteeth.tech/posts/14806.html"/>
    <id>http://showteeth.tech/posts/14806.html</id>
    <published>2019-08-13T11:45:32.000Z</published>
    <updated>2019-08-17T01:07:16.110Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了将不同目录下的文件导入到另一个文件的方法，主要有两种：将<strong>文件路径加到package的搜索路径</strong>以及<strong>在需要导入的文件目录中加入<code>__init__.py</code>文件使其变成一个可以直接导入的包</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在画韦恩图的时候遇到一个<a href="https://github.com/tctianchi/pyvenn" target="_blank" rel="noopener">画图的脚本</a>不错，但是这个没有形成一个package，想要使用的话只能直接导入python文件，从而使用其中的绘图函数。</p><h2 id="导入python文件"><a href="#导入python文件" class="headerlink" title="导入python文件"></a>导入python文件</h2><p>这里有两种方法可以导入python文件从而使用其中的函数：</p><ul><li>将文件夹添加到<strong>系统路径(python package的安装和搜索路径)</strong></li><li>在需要导入的文件夹中添加<code>__init__.py</code>文件</li></ul><h3 id="添加到搜索路径"><a href="#添加到搜索路径" class="headerlink" title="添加到搜索路径"></a>添加到搜索路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_file.py</span></span><br><span class="line">import sys</span><br><span class="line"><span class="comment"># insert at 1, 0 is the script path (or '' in REPL)</span></span><br><span class="line">sys.path.insert(1, <span class="string">'/path/to/application/app/folder'</span>)</span><br><span class="line"></span><br><span class="line">import file</span><br></pre></td></tr></table></figure><hr><h3 id="添加init-py文件"><a href="#添加init-py文件" class="headerlink" title="添加init.py文件"></a>添加<strong>init</strong>.py文件</h3><p><code>__init__.py</code>文件的作用：<strong>It can be an empty file. Its very existence tells Python to treat the directory as a package.</strong></p><p>添加<code>__init__.py</code>文件之后，如果需要导入的文件的路径：<code>application/app/folder/file.py</code>，可以通过如下命令导入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from application.app.folder.file import func_name</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder" target="_blank" rel="noopener">Importing files from different folder</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了将不同目录下的文件导入到另一个文件的方法，主要有两种：将&lt;strong&gt;文件路径加到package的搜索路径&lt;/strong&gt;以及&lt;strong&gt;在需要导入的文件目录中加入&lt;code&gt;__init__.py&lt;/code&gt;文件使其变成一个可以直接导入的包&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之用户、用户组和权限管理</title>
    <link href="http://showteeth.tech/posts/61241.html"/>
    <id>http://showteeth.tech/posts/61241.html</id>
    <published>2019-08-13T05:29:19.000Z</published>
    <updated>2019-08-13T07:14:28.338Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>Linux</code>中<strong>用户、用户组和权限管理</strong>的相关知识。<strong>用户管理</strong>中，首先使用<code>adduser</code><strong>创建账号</strong>，然后使用<code>passwd</code>给创建的账号<strong>设置密码</strong>；在<strong>分组管理</strong>中，首先使用<code>groups</code>和<code>id</code>命令<strong>查看了用户的分组</strong>信息，然后使用<code>usermod</code><strong>更改了用户主分组</strong>；在<strong>权限管理</strong>中，首先介绍了文件(夹)的权限信息，然后使用<code>chmod</code><strong>修改文(夹)权限</strong>，最后使用<code>chown</code> 和 <code>chgrp</code> 命令来分别<strong>修改文件(夹)的所属用户和组</strong></p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室新来了几个同学，需要给他们创建账号使用集群，刚好实验室之前的集群用户和用户组非常混乱，这里就统一学习和管理一下。</p><hr><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>首先需要创建新账户，创建账户有两个命令：<code>useradd</code>和<code>adduser</code>，关于<a href="https://askubuntu.com/questions/345974/what-is-the-difference-between-adduser-and-useradd" target="_blank" rel="noopener">两者的区别</a>：</p><blockquote><p>adduser and addgroup add users and groups to the system according to command line options and configuration information in <strong>/etc/adduser.conf</strong>. They are <strong>friendlier front ends</strong> to the low level tools like useradd, groupadd and usermod programs, by default choosing Debian policy conformant UID and GID values, creating a home directory with skeletal configuration, running a custom script, and other features.</p></blockquote><blockquote><p>useradd is a <strong>low level utility</strong> for adding users. On Debian, administrators should usually use adduser(8) instead.</p></blockquote><p>另外使用<code>useradd</code>命令不会自动创建<code>/home/username</code>目录(可以通过添加<code>-m</code>参数指定创建)，而使用<code>adduser</code>会自动创建<code>/home/username</code>目录，两个命令创建的用户家目录都可以通过<code>-d</code>参数指定。</p><p>这里我使用的命令是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户名为zhengshuang，家目录在/workstation/zhengshuang的用户</span></span><br><span class="line">adduser -d /workstation/zhengshuang zhengshuang</span><br><span class="line"></span><br><span class="line">  drwx------.  2 zhengshuang zhengshuang 4.0K Aug 13 02:17 zhengshuang</span><br><span class="line">  drwxr-xr--.  6 root        root        4.0K Aug  8 11:55 softwares</span><br></pre></td></tr></table></figure><p></p><p>发现创建完成之后会自动创建一个与用户名同名的分组，这种情况下如果创建多个账号，每个人都是不同的分组，以后不方便管理，所以这里需要对其分组进行更改。</p><hr><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">passwd zhengshuang</span><br><span class="line">  Changing password <span class="keyword">for</span> user zhengshuang.</span><br><span class="line">  New password: </span><br><span class="line">  Retype new password: </span><br><span class="line">  passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><hr><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除账号以及家目录</span></span><br><span class="line"><span class="comment"># -r, --remove：remove home directory and mail spool</span></span><br><span class="line">userdel -r username</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h2><h3 id="查看分组信息"><a href="#查看分组信息" class="headerlink" title="查看分组信息"></a>查看分组信息</h3><p>可以先看看所有的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分组信息</span></span><br><span class="line">getent group</span><br><span class="line"><span class="comment"># 查看所有分组信息</span></span><br><span class="line">cut -d<span class="string">':'</span> -f 1 /etc/group</span><br><span class="line"><span class="comment"># 也可以顺便查看所有的用户信息</span></span><br><span class="line">cut -d<span class="string">':'</span> -f 1 /etc/passwd</span><br></pre></td></tr></table></figure><p></p><p>使用<code>groups</code>命令查看某个用户的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看zhengshuang的分组信息</span></span><br><span class="line">groups zhengshuang</span><br><span class="line">  zhengshuang : zhengshuang</span><br></pre></td></tr></table></figure><p></p><p>使用<code>id</code>命令查看某个用户的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id zhengshuang</span><br><span class="line">  uid=1027(zhengshuang) gid=1029(zhengshuang) groups=1029(zhengshuang)</span><br></pre></td></tr></table></figure><p></p><p>可以发现这个结果比前面使用<code>groups</code>的输出更加复杂一些：这里有一个 <code>gid</code>，表示<strong>主工作组(primary group)</strong>，后面还有个 <code>groups</code>，它列出了用户<strong>所在的所有组</strong>；<strong>主工作组只有一个，而后者(secondary groups)的数量则不限</strong>。总的来说，可以使用<code>id</code>命令看到用户组的结果和使用 <code>groups</code> 命令看到的结果是一致的。</p><hr><p>###添加组</p><p>为了解决创建用户步骤遗留下来的问题，首先需要添加组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加lab分组</span></span><br><span class="line">groupadd lab</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="更改用户主分组"><a href="#更改用户主分组" class="headerlink" title="更改用户主分组"></a>更改用户主分组</h3><p>更改用户主分组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g:force use GROUP as new primary group</span></span><br><span class="line">usermod -g lab zhengshuang</span><br><span class="line">  drwx------.  2 zhengshuang lab         4.0K Aug 13 02:17 zhengshuang</span><br><span class="line">  drwxr-xr--.  6 root        root        4.0K Aug  8 11:55 softwares</span><br></pre></td></tr></table></figure><p></p><p>这里使用了<code>-g</code>来改变用户的主用户组，也就是前面<code>gid</code>显示组别，也是<code>ll</code>显示的组别，而如果不想改变主用户组，而是添加用户组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a:append the user to the supplemental GROUPS </span></span><br><span class="line"><span class="comment">#    mentioned by the -G option without removing him/her from other groups</span></span><br><span class="line"><span class="comment"># -G:new list of supplementary GROUPS</span></span><br><span class="line">usermod -a -G examplegroup exampleusername1,exampleusername2,exampleusername3...</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建用户并指定分组"><a href="#创建用户并指定分组" class="headerlink" title="创建用户并指定分组"></a>创建用户并指定分组</h3><p>在使用adduser创建用户的同时也可以指定分组信息：</p><ul><li><code>-g</code>：name or ID of the primary group of the new account</li><li><code>-G</code>：list of supplementary groups of the new account</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser -d /workstation/zhengshuang zhengshuang -g lab</span><br></pre></td></tr></table></figure><hr><h3 id="删除分组"><a href="#删除分组" class="headerlink" title="删除分组"></a>删除分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认创建用户时的分组</span></span><br><span class="line">groupdel zhengshuang</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><div class="note info"><p>这部分参考了<a href="https://cuiqingcai.com/6284.html" target="_blank" rel="noopener">这篇博客文章</a>，讲解非常细致。</p></div><h3 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ls -l  /etc/nginx </span><br><span class="line">  total 80</span><br><span class="line">  drwxr-xr-x   7 root root  4096 Jun 21 22:16 ./</span><br><span class="line">  drwxr-xr-x 103 root root  4096 Sep  4 18:04 ../</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jul 12  2017 conf.d/</span><br><span class="line">  -rw-r--r--   1 root root  1077 Feb 12  2017 fastcgi.conf</span><br><span class="line">  -rw-r--r--   1 root root  1007 Feb 12  2017 fastcgi_params</span><br><span class="line">  -rw-r--r--   1 root root  2837 Feb 12  2017 koi-utf</span><br><span class="line">  -rw-r--r--   1 root root  2223 Feb 12  2017 koi-win</span><br><span class="line">  -rw-r--r--   1 root root  3957 Feb 12  2017 mime.types</span><br><span class="line">  -rw-r--r--   1 root root  1505 Jun 21 20:24 nginx.conf</span><br><span class="line">  -rw-r--r--   1 root root 12288 Jun 21 20:44 .nginx.conf.swp</span><br><span class="line">  -rw-r--r--   1 root root   180 Feb 12  2017 proxy_params</span><br><span class="line">  -rw-r--r--   1 root root   636 Feb 12  2017 scgi_params</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 22:42 sites-available/</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 19:08 sites-enabled/</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 19:08 snippets/</span><br><span class="line">  -rw-r--r--   1 root root   664 Feb 12  2017 uwsgi_params</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 22 02:44 vhosts/</span><br><span class="line">  -rw-r--r--   1 root root  3071 Feb 12  2017 win-utf</span><br></pre></td></tr></table></figure><p>可以发现每一行都是一个文件或文件夹的信息，一共包括七列：</p><ul><li>第一列是文件的<strong>权限信息</strong></li><li>第二列表示该文件夹<strong>连接的文件数(？？)</strong></li><li>第三列表示文件<strong>所属用户</strong></li><li>第四列表示文件<strong>所属用户组</strong></li><li>第五列表示<strong>文件大小（字节）</strong></li><li>第六列表示<strong>最后修改日期</strong></li><li>第七列表示<strong>文件名</strong></li></ul><p>其中<strong>第一列</strong>的文件<strong>权限信息</strong>是非常重要的，它由十个字符组成：</p><ul><li>第一个字符代表文件的类型，有三种，<code>-</code> 代表这是一个文件，<code>d</code> 代表这是一个文件夹，<code>l</code> 代表这是一个链接。</li><li>第 <code>2-4</code> 个字符代表文件<strong>所有者</strong>对该文件的权限，<ul><li><code>r</code> 就是读</li><li><code>w</code> 就是写</li><li><code>x</code> 就是执行，如果是<strong>文件夹</strong>的话，<strong>执行就意味着查看文件夹下的内容</strong>，例如 <code>rw-</code> 就代表文件所有者可以对该文件进行读取和写入。</li></ul></li><li>第 <code>5-7</code> 个字符代表文件<strong>所属组</strong>对该文件的权限，含义是一样的，如 <code>r-x</code>就代表该文件<strong>所属组内的所有用户</strong>对该文件有读取和执行的权限。</li><li>第 <code>8-10</code> 个字符代表是<strong>其他用户</strong>对该文件的权限，含义也是一样的，如 <code>r–</code> 就代表<strong>非所有者、非用户组的用户</strong>只拥有对该文件的读取权限。</li></ul><hr><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>可以使用<code>chmod</code>命令来修改文件的权限，其中<strong>权限的表示</strong>有两种：</p><ul><li>一种是<strong>数字权限命名</strong>，<code>rwx</code> 对应一个<strong>二进制数字</strong>，如 <code>101</code> 就代表拥有<strong>读取和执行</strong>的权限，而转为十进制的话，<code>r</code> 就代表 <code>4</code>，<code>w</code>就代表 <code>2</code>，<code>x</code> 就代表 <code>1</code>，然后<strong>三个数字加起来就和二进制数字对应起来了</strong>。如 <code>7=4+2+1</code>，这就对应着 <code>rwx</code>；<code>5=4+1</code>，这就对应着 <code>r-x</code>。所以，相应地 <code>777</code> 就代表了 <code>rwxrwxrwx</code>，即<strong>所有者、所属用户组、其他用户对该文件都拥有读取、写入、执行的权限，这是相当危险的</strong>！</li><li>也可以使用<strong>代号来赋予权限</strong>，代号有 <code>u</code>、<code>g</code>、<code>o</code>、<code>a</code> 四中，分别代表<strong>所有者权限</strong>，<strong>用户组权限</strong>，<strong>其他用户权限</strong>和<strong>所有用户权限</strong>，这些代号后面通过 <code>+</code> 和 <code>–</code> 符号来<strong>控制权限的添加和移除</strong>，再后面跟上权限类型就好。例如：<code>u-x</code>就是给所有者移除 <code>x</code> 权限，也就是执行权限.</li></ul><p>如果是需要修改<strong>文件夹</strong>的权限，可以对文件夹进行<strong>递归赋权限</strong>操作：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 share 文件夹和其内所有内容都赋予 777 权限</span></span><br><span class="line">chmod -R 777 share</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="修改文件所有者和组"><a href="#修改文件所有者和组" class="headerlink" title="修改文件所有者和组"></a>修改文件所有者和组</h3><p>通过上面的<code>chmod</code>命令可以给文件(夹)针对不同的用户和组添加不同的权限，但是前提是要确定文件(夹)所属的用户和组具体。这里可以使用<code>chown</code> 和 <code>chgrp</code> 命令来分别<strong>修改文件(夹)的所属用户和组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件的所属用户</span></span><br><span class="line">chown &lt;username&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 修改文件的所属组</span></span><br><span class="line">chgrp &lt;group&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件夹的所属用户</span></span><br><span class="line">chown -R &lt;username&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 修改文件夹的所属组</span></span><br><span class="line">chgrp -R &lt;group&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p></p><p>实践：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 root root 4.0K Aug 13 03:46 Mouseproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件的所属用户</span></span><br><span class="line">chown -R zhengshuang Mouseproject</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 zhengshuang root 4.0K Aug 13 03:46 Mouseproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件的所属组</span></span><br><span class="line">chgrp lab -R Mouseproject</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 zhengshuang lab 4.0K Aug 13 03:46 Mouseproject</span><br></pre></td></tr></table></figure><p></p><p>通过上述修改(没有修改文件权限，默认的权限即可满足需求)，Mouseproject文件夹中的数据就可以被<code>zhengshuang</code>用户<code>rwx</code>，被<code>lab</code>组的其他用户<code>r-x</code>，被<code>非lab组</code>的其他用户<code>r-x</code>了。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/" target="_blank" rel="noopener">Create a New User and Assign a Group in One Command</a></li><li><a href="https://cuiqingcai.com/6284.html" target="_blank" rel="noopener">详解 Linux 下的用户管理、用户组管理和权限管理</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;code&gt;Linux&lt;/code&gt;中&lt;strong&gt;用户、用户组和权限管理&lt;/strong&gt;的相关知识。&lt;strong&gt;用户管理&lt;/strong&gt;中，首先使用&lt;code&gt;adduser&lt;/code&gt;&lt;strong&gt;创建账号&lt;/strong&gt;，然后使用&lt;code&gt;passwd&lt;/code&gt;给创建的账号&lt;strong&gt;设置密码&lt;/strong&gt;；在&lt;strong&gt;分组管理&lt;/strong&gt;中，首先使用&lt;code&gt;groups&lt;/code&gt;和&lt;code&gt;id&lt;/code&gt;命令&lt;strong&gt;查看了用户的分组&lt;/strong&gt;信息，然后使用&lt;code&gt;usermod&lt;/code&gt;&lt;strong&gt;更改了用户主分组&lt;/strong&gt;；在&lt;strong&gt;权限管理&lt;/strong&gt;中，首先介绍了文件(夹)的权限信息，然后使用&lt;code&gt;chmod&lt;/code&gt;&lt;strong&gt;修改文(夹)权限&lt;/strong&gt;，最后使用&lt;code&gt;chown&lt;/code&gt; 和 &lt;code&gt;chgrp&lt;/code&gt; 命令来分别&lt;strong&gt;修改文件(夹)的所属用户和组&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell系列之eval、printf和组合数</title>
    <link href="http://showteeth.tech/posts/13990.html"/>
    <id>http://showteeth.tech/posts/13990.html</id>
    <published>2019-08-12T13:09:39.000Z</published>
    <updated>2019-08-13T12:23:09.105Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>使用shell得到组合数</strong>，其中用到了三个方面的trick：<code>特殊符号{}</code>、<code>printf中的{,}</code>，<code>eval命令</code>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在学习过程中遇到一个步骤需要得到组合数，之前也学习过使用使用python的<a href="http://showteeth.tech/posts/49907.html">itertools库(itertools.combinations)</a>得到组合数，但是这里是在shell中某一步需要得到组合数，再使用Python非常不划算，就想着直接使用shell得到组合数，在shell中得到组合数可以使用特殊符号<code>{}</code>，这个<a href="http://showteeth.tech/posts/55603.html">之前</a>也学习过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单纯的数字的组合数</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;0..1&#125;</span><br><span class="line">  00 01 10 11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字结合字母的组合数</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;a..b&#125;</span><br><span class="line">  0a 0b 1a 1b</span><br></pre></td></tr></table></figure><p>这里主要是遇到了两个trick进行命令行的简化。</p><h2 id="命令行的简化"><a href="#命令行的简化" class="headerlink" title="命令行的简化"></a>命令行的简化</h2><p>先给出简化的命令行形式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line">  000 001 010 011 100 101 110 111</span><br></pre></td></tr></table></figure><p></p><p>上述命令涉及到两个小trick：</p><ul><li><code>printf的{,}</code></li><li><code>eval命令</code></li></ul><h3 id="printf的"><a href="#printf的" class="headerlink" title="printf的{,}"></a>printf的{,}</h3><p>分解上述命令为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line">  &#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现printf应该是将<code>&#39;{0..1}&#39;</code>作为字符串打印了三遍，这是为什么呢？其中的<code>{,,}</code>是干什么的呢？</p><p>再次将上述命令分解为常见的形式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>)</span><br><span class="line">  &#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现，这里只打印出了一遍<code>{0..1}</code>，相较于存在<code>{,,}</code>的情形少打印了两遍，也就是说，存在<code>{,,}</code>会打印三遍<code>{0..1}</code>，两个逗号打印三遍，刚好两个逗号将3个字符(串)分开，那么如果如果存在一个逗号，是不是就是打印两遍呢？：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,&#125; )</span><br><span class="line">  &#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里确实是打印了两遍，联想之前学习的<a href="http://showteeth.tech/posts/47162.html">printf的用法</a>，猜测{,}是重复之前的字符，并且其中的,是重复的次数-1：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'abc'</span>&#123;,&#125;)</span><br><span class="line">  abcabc</span><br></pre></td></tr></table></figure><p></p><h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>在搞清楚上面<code>printf</code>的trick之后，再来看看<code>eval</code>命令，关于<code>eval</code>命令，大部分的介绍都是：当将命令行放入<code>eval</code>命令中后，shell在执行命令行之前扫描它两次，第一次会进行变量替换或运算，第二次是执行替换之后的命令(将<code>eval</code>之后的命令当成一个命令执行)；其<a href="https://www.tutorialspoint.com/unix_commands/eval" target="_blank" rel="noopener">英文说明</a>：</p><blockquote><p>eval is a built in linux or unix command. The eval command is used to <strong>execute the arguments as a shell command on unix or linux system</strong>. Eval command comes in handy <strong>when you have a unix or linux command stored in a variable</strong> and you <strong>want to execute that command stored in the string</strong>. The eval command <strong>first evaluates the argument</strong> and then <strong>runs the command stored in the argument</strong>.</p></blockquote><p>使用示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COMMAND=<span class="string">"ls -lrt"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="variable">$&#123;COMMAND&#125;</span></span><br><span class="line">  total 702</span><br><span class="line">  -rw-rw-r-- 1 user user 3595660 Aug 12 12:02 H12881_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user 3447580 Aug 12 12:02 H892.2_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user    7803 Aug 12 12:03 H892.2_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  -rw-rw-r-- 1 user user    7799 Aug 12 12:03 H12881_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  -rw-rw-r-- 1 user user 3621459 Aug 12 12:19 H892_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user    7816 Aug 12 12:19 H892_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  drwxrwxr-x 2 user user    4096 Aug 12 20:15 dir</span><br><span class="line">  -rw-rw-r-- 1 user user 4653958 Aug 12 20:35 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>具体到这次的命令行中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：</span></span><br><span class="line">将$(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )替换为&#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于<code>eval</code>命令的更多用法，在后续学习中慢慢补充吧。</p><ul><li><strong>eval变量替换、执行结果替换、指定命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=5</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">printf</span> <span class="string">',%.0s'</span> &#123;1..$(expr <span class="variable">$&#123;num&#125;</span> - 1)&#125;</span><br><span class="line">  ,,,,</span><br></pre></td></tr></table></figure></li></ul><p><strong>eval嵌套</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=4</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">eval</span> <span class="built_in">printf</span> <span class="string">"'&#123;0..1&#125;'%.0s"</span> &#123;1..<span class="variable">$&#123;num&#125;</span>&#125;)</span><br><span class="line">  0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/204069/all-possible-combinations-of-characters-and-numbers" target="_blank" rel="noopener">All possible combinations of characters and numbers</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;使用shell得到组合数&lt;/strong&gt;，其中用到了三个方面的trick：&lt;code&gt;特殊符号{}&lt;/code&gt;、&lt;code&gt;printf中的{,}&lt;/code&gt;，&lt;code&gt;eval命令&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell系列之cp和mv的进阶用法</title>
    <link href="http://showteeth.tech/posts/15765.html"/>
    <id>http://showteeth.tech/posts/15765.html</id>
    <published>2019-08-10T13:45:12.000Z</published>
    <updated>2019-08-13T07:14:28.345Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>cp</code>和<code>mv</code>命令将<strong>多个文件(夹)复制或者剪切到同一个目录</strong>中的方法以及<strong>将一(多)个文件拷贝到多个目录</strong>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>linux</code>下使用<code>cp</code>和<code>mv</code>命令时，经常会遇到需要<strong>将多个文件复制或者剪切到同一个目录</strong>下以及<strong>将一(多)个文件复制到多个目录中</strong>，这种时候使用简单的<code>cp</code>和<code>mv</code>就很难达到目的。</p><hr><h2 id="将多个文件复制到同一个目录"><a href="#将多个文件复制到同一个目录" class="headerlink" title="将多个文件复制到同一个目录"></a>将多个文件复制到同一个目录</h2><p><code>cp</code>命令使用较多的是<code>-r</code>和<code>-f</code>参数，但是这两个参数并不能解决目前的问题，这里需要使用另一个参数：<code>-t</code>-<strong>将所有的原文件(夹)复制到目标文件夹(copy all SOURCE arguments into DIRECTORY)</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个目录复制到同一个目录</span></span><br><span class="line">cp -r dir1 dir2 dir3 -t target_dir</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将一-多-个文件拷贝到多个目录"><a href="#将一-多-个文件拷贝到多个目录" class="headerlink" title="将一(多)个文件拷贝到多个目录"></a>将一(多)个文件拷贝到多个目录</h2><p>在这种情况下单凭<code>cp</code>命令是不能完成这个任务的，因为<code>cp</code>命令的介绍：<code>Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</code>并没有提到过可以将一(多)个文件复制到多个目录，这种情况下就需要借助之前学习的命令<a href="http://showteeth.tech/posts/30003.html">xargs</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xargs -n：指定一次处理的参数个数</span></span><br><span class="line"><span class="comment"># 每次只传递给cp一个目录</span></span><br><span class="line"><span class="built_in">echo</span> dir1 dir2 dir3 | xargs -n 1 cp file1 file2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意<code>xargs</code>一定要加<code>-n 1</code>，不然会将<code>dir1</code>、<code>dir2</code>、<code>file1</code>、<code>file2</code>全部复制到<code>dir3</code></p></div><hr><h2 id="将多个文件剪切到同一个目录"><a href="#将多个文件剪切到同一个目录" class="headerlink" title="将多个文件剪切到同一个目录"></a>将多个文件剪切到同一个目录</h2><p>和<code>cp</code>命令类似，<code>mv</code>命令也有一个<code>-t</code>参数，可以将多个文件(夹)剪切到同一个目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 dir2 dir3 -t target_dir1</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/195655/how-to-copy-a-file-to-multiple-directories-using-the-gnu-cp-command" target="_blank" rel="noopener">How to copy a file to multiple directories using the gnu cp command</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了使用&lt;code&gt;cp&lt;/code&gt;和&lt;code&gt;mv&lt;/code&gt;命令将&lt;strong&gt;多个文件(夹)复制或者剪切到同一个目录&lt;/strong&gt;中的方法以及&lt;strong&gt;将一(多)个文件拷贝到多个目录&lt;/strong&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell-同时给多个变量赋值</title>
    <link href="http://showteeth.tech/posts/60071.html"/>
    <id>http://showteeth.tech/posts/60071.html</id>
    <published>2019-08-09T13:56:41.000Z</published>
    <updated>2019-08-10T02:58:51.060Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>如何将程序的输出结果同时赋值给多个变量</strong>，主要有两种方法：<strong><code>read</code>命令结合<code>&lt;&lt;&lt;</code></strong>、使用<strong>数组存储</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天写了一个<code>bash shell</code>小程序，有多个输出，想要将这多个输出同时传递给多个变量。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法主要有两种：使用reads命令、使用数组。</p><h3 id="使用read命令"><a href="#使用read命令" class="headerlink" title="使用read命令"></a>使用read命令</h3><p>之前也学习过<a href="http://showteeth.tech/posts/59492.html">read命令</a>，其可以<strong>从键盘或文件中获取输入</strong>，这里需要的是使用read从<strong>命令行</strong>读入变量，就需要结合之前的重定向符号<code>&lt;&lt;&lt;</code>，这里需要回顾一下<code>&lt;</code>、<code>&lt;&lt;</code>、<code>&lt;&lt;&lt;</code>三者的区别，之前在<a href="http://showteeth.tech/posts/55603.html">这篇文章</a>中也学习过：</p><ul><li><code>&lt;</code>：从<strong>文件</strong>获取读入</li><li><code>&lt;&lt; text</code>：从<strong>命令行</strong>读取输入，直到一个与<strong>text字符相同的行结束</strong></li><li><code>&lt;&lt;&lt;</code>：将<strong>word(字符)</strong>，注意不是上面的file读入。</li></ul><p>具体的使用如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接存储变量</span></span><br><span class="line"><span class="built_in">read</span> a b c &lt;&lt;&lt;$(<span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span>)</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"<span class="variable">$a</span>\t<span class="variable">$b</span>\t<span class="variable">$c</span>"</span></span><br><span class="line">  1       2       3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数组存储变量</span></span><br><span class="line"><span class="built_in">read</span> -a array &lt;&lt;&lt;$(<span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line"><span class="comment"># 使用的数组下标</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line">  0 1 2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array2=($(<span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array2[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/1952404/linux-bash-multiple-variable-assignment" target="_blank" rel="noopener">Linux bash: Multiple variable assignment</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;如何将程序的输出结果同时赋值给多个变量&lt;/strong&gt;，主要有两种方法：&lt;strong&gt;&lt;code&gt;read&lt;/code&gt;命令结合&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/strong&gt;、使用&lt;strong&gt;数组存储&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之没有root安装packages</title>
    <link href="http://showteeth.tech/posts/9464.html"/>
    <id>http://showteeth.tech/posts/9464.html</id>
    <published>2019-08-09T03:06:05.000Z</published>
    <updated>2019-08-10T02:58:51.054Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在没有<code>root</code>权限的条件下给系统(<code>centos</code>)自带的<code>python</code>安装<code>packages</code>的方法，主要是使用<code>pip install --user package</code>，安装的路径在<code>~/.local/</code></p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为课题的需要，今天打算另一个集群2.7的python中安装<code>pybedtools</code>包，但是安装却发现如下报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOError: [Errno 13] Permission denied: <span class="string">'/usr/lib/python2.7/site-packages/six.py'</span></span><br></pre></td></tr></table></figure><p></p><p>这一看就是没有访问权限的问题，毕竟是别人的集群，没有root权限想要安装package到自带的python中就不能使用上述方法。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用如下方法进行安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user pybedtools</span><br></pre></td></tr></table></figure><p></p><p>这种包默认的安装路径是在<code>~/.local/</code></p><p>如果上述方法不奏效，可以参考<a href="https://stackoverflow.com/questions/7465445/how-to-install-python-modules-without-root-access" target="_blank" rel="noopener">How to install python modules without root access?</a>中的其他方法。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/7465445/how-to-install-python-modules-without-root-access" target="_blank" rel="noopener">How to install python modules without root access?</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在没有&lt;code&gt;root&lt;/code&gt;权限的条件下给系统(&lt;code&gt;centos&lt;/code&gt;)自带的&lt;code&gt;python&lt;/code&gt;安装&lt;code&gt;packages&lt;/code&gt;的方法，主要是使用&lt;code&gt;pip install --user package&lt;/code&gt;，安装的路径在&lt;code&gt;~/.local/&lt;/code&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="tricks" scheme="http://showteeth.tech/categories/Python/tricks/"/>
    
    
      <category term="tricks" scheme="http://showteeth.tech/tags/tricks/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之加速Python小tips</title>
    <link href="http://showteeth.tech/posts/47268.html"/>
    <id>http://showteeth.tech/posts/47268.html</id>
    <published>2019-07-27T09:43:31.000Z</published>
    <updated>2019-07-27T10:02:53.103Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>Python中加速计算的一些小tips</strong>，其中有很多方法只是<strong>略有提及</strong>，并没有做深入地学习，目前只是大致了解一些针对不同情形可以使用什么加速方法，<strong>后续使用的时候再有针对性地学习</strong>。</p></div><a id="more"></a><h2 id="分析代码运行时间"><a href="#分析代码运行时间" class="headerlink" title="分析代码运行时间"></a>分析代码运行时间</h2><p>总结：</p><ul><li>测试代码<strong>单次运行时间</strong>：<code>time.time()</code>之差，或者使用<code>%%time</code>，如果是单行，可以使用<code>%time</code>；</li><li><strong>平均</strong>用时：<code>timeit</code>模块或者<code>%%timeit</code></li><li>按<strong>函数</strong>分析运行时间：<code>profile</code>模块或者<code>%prun</code></li><li>按<strong>行</strong>分析代码运行时间：<code>line_profiler</code>或者<code>%lprun</code></li></ul><h3 id="测试代码的运行时间"><a href="#测试代码的运行时间" class="headerlink" title="测试代码的运行时间"></a>测试代码的运行时间</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 记录开始时间</span></span><br><span class="line">tic=time.time()</span><br><span class="line"><span class="comment"># 运行陈程序</span></span><br><span class="line">much_job=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 记录结束时间</span></span><br><span class="line">toc=time.time()</span><br><span class="line"><span class="comment"># 小数点后保留5位小数</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'used &#123;:.5&#125;s'</span>.format(toc-tic))</span><br></pre></td></tr></table></figure><pre><code>used 0.13954s</code></pre><h4 id="jupyter中的方法"><a href="#jupyter中的方法" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">much_job=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 135 ms, sys: 7.1 ms, total: 142 msWall time: 140 ms</code></pre><h3 id="测试代码平均用时"><a href="#测试代码平均用时" class="headerlink" title="测试代码平均用时"></a>测试代码平均用时</h3><h4 id="通用方法-1"><a href="#通用方法-1" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line">g=<span class="keyword">lambda</span> x:x**<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (g(<span class="number">2</span>)**<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">timeit(<span class="string">'main()'</span>,globals=&#123;<span class="string">'main'</span>:main&#125;,number=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>2.5913002900779247e-05</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(timeit)</span><br></pre></td></tr></table></figure><pre><code>Help on function timeit in module timeit:timeit(stmt=&apos;pass&apos;, setup=&apos;pass&apos;, timer=&lt;built-in function perf_counter&gt;, number=1000000, globals=None)    Convenience function to create Timer object and call timeit method.</code></pre><h4 id="jupyter中的方法-1"><a href="#jupyter中的方法-1" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%timeit -n <span class="number">10</span></span><br><span class="line">g=<span class="keyword">lambda</span> x:x**<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (g(<span class="number">2</span>)**<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><pre><code>2.34 µs ± 211 ns per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre><h3 id="分析函数运行时间"><a href="#分析函数运行时间" class="headerlink" title="分析函数运行时间"></a>分析函数运行时间</h3><h4 id="通用方法-2"><a href="#通用方法-2" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(x <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result=[relu(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-100000</span>,<span class="number">100000</span>,<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> (result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> profile</span><br><span class="line">profile.run(<span class="string">'main()'</span>)</span><br></pre></td></tr></table></figure><pre><code>      200006 function calls in 0.672 secondsOrdered by: standard namencalls  tottime  percall  cumtime  percall filename:lineno(function)     1    0.000    0.000    0.672    0.672 :0(exec)     1    0.000    0.000    0.000    0.000 :0(setprofile)200000    0.322    0.000    0.322    0.000 &lt;ipython-input-9-aae7666d2db5&gt;:1(relu)     1    0.000    0.000    0.671    0.671 &lt;ipython-input-9-aae7666d2db5&gt;:4(main)     1    0.348    0.348    0.671    0.671 &lt;ipython-input-9-aae7666d2db5&gt;:5(&lt;listcomp&gt;)     1    0.001    0.001    0.672    0.672 &lt;string&gt;:1(&lt;module&gt;)     1    0.000    0.000    0.672    0.672 profile:0(main())     0    0.000             0.000          profile:0(profiler)</code></pre><h4 id="jupyter中的方法-2"><a href="#jupyter中的方法-2" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><p>和前面的结果相同，但是是以弹框的形式展示的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun main()</span><br></pre></td></tr></table></figure><h3 id="按行分析代码运行时间"><a href="#按行分析代码运行时间" class="headerlink" title="按行分析代码运行时间"></a>按行分析代码运行时间</h3><p><code>%lprun</code>命令如果不能得到正确的输出，可以参考：<a href="https://stackoverflow.com/questions/19942653/interactive-python-cannot-get-lprun-to-work-although-line-profiler-is-impor" target="_blank" rel="noopener">Interactive Python: cannot get <code>%lprun</code> to work, although line_profiler is imported properly</a></p><h4 id="通用方法-3"><a href="#通用方法-3" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(x <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result=[relu(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-100000</span>,<span class="number">100000</span>,<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> (result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> line_profiler <span class="keyword">import</span> LineProfiler</span><br><span class="line">lprofile = LineProfiler(main,relu)</span><br><span class="line">lprofile.run(<span class="string">'main()'</span>)</span><br><span class="line">lprofile.print_stats()</span><br></pre></td></tr></table></figure><pre><code>Timer unit: 1e-06 sTotal time: 0.077296 sFile: &lt;ipython-input-72-aae7666d2db5&gt;Function: relu at line 1Line #      Hits         Time  Per Hit   % Time  Line Contents==============================================================     1                                           def relu(x):     2    200000      77296.0      0.4    100.0      return(x if x&gt;0 else 0)Total time: 0.259755 sFile: &lt;ipython-input-72-aae7666d2db5&gt;Function: main at line 4Line #      Hits         Time  Per Hit   % Time  Line Contents==============================================================     4                                           def main():     5         1     259754.0 259754.0    100.0      result=[relu(x) for x in range(-100000,100000,1)]     6         1          1.0      1.0      0.0      return (result)</code></pre><h4 id="jupyter中的方法-3"><a href="#jupyter中的方法-3" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><p>如果报错：UsageError: Line magic function <code>%lprun</code> not found.<br><a href="https://stackoverflow.com/questions/19942653/interactive-python-cannot-get-lprun-to-work-although-line-profiler-is-impor" target="_blank" rel="noopener">解决方法</a>：</p><ul><li>暂时的解决方法：<code>%load_ext line_profiler</code></li><li>永久的解决方法：在<code>~/.ipython/profile_default/ipython_config.py</code>(如果没有这个文件，可以使用<code>ipython profile create</code>创建)文件中添加<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.TerminalIPythonApp.extensions = [</span><br><span class="line">    <span class="string">'line_profiler'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load_ext line_profiler</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%lprun -f main -f relu main()</span><br></pre></td></tr></table></figure><h2 id="加速查找"><a href="#加速查找" class="headerlink" title="加速查找"></a>加速查找</h2><p>总结：</p><ul><li>在<strong>单个列表</strong>中查找某个元素：使用<code>set</code>比使用<code>list</code>快</li><li><strong>两个列表联合</strong>查找：使用<code>dict</code>比使用两个<code>list</code>要快</li></ul><h3 id="使用set而不是list进行查找"><a href="#使用set而不是list进行查找" class="headerlink" title="使用set而不是list进行查找"></a>使用set而不是list进行查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=(i**<span class="number">2</span> + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>) )</span><br></pre></td></tr></table></figure><h4 id="低速方法-list"><a href="#低速方法-list" class="headerlink" title="低速方法-list"></a>低速方法-list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_data=list(data)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="number">1098987</span> <span class="keyword">in</span> list_data</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 25.4 ms, sys: 0 ns, total: 25.4 msWall time: 25.1 msFalse</code></pre><h4 id="高速方法-set"><a href="#高速方法-set" class="headerlink" title="高速方法-set"></a>高速方法-set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_data=set(data)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="number">1098987</span> <span class="keyword">in</span> set_data</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 7 µs, sys: 0 ns, total: 7 µsWall time: 12.9 µsFalse</code></pre><h3 id="使用dict而非两个list进行匹配查找"><a href="#使用dict而非两个list进行匹配查找" class="headerlink" title="使用dict而非两个list进行匹配查找"></a>使用dict而非两个list进行匹配查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_a=[<span class="number">2</span>*i<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)]</span><br><span class="line">list_b=[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> list_a]</span><br></pre></td></tr></table></figure><h4 id="低速方法-两个list"><a href="#低速方法-两个list" class="headerlink" title="低速方法-两个list"></a>低速方法-两个list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">print</span> (list_b[list_a.index(<span class="number">876567</span>)])</span><br></pre></td></tr></table></figure><pre><code>768369705489CPU times: user 12 ms, sys: 0 ns, total: 12 msWall time: 11.9 ms</code></pre><h4 id="高速方法-dict"><a href="#高速方法-dict" class="headerlink" title="高速方法-dict"></a>高速方法-dict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b=[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">dict(zip(a,b))</span><br></pre></td></tr></table></figure><pre><code>{1: 3, 2: 4}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_ab=dict(zip(list_a,list_b))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">print</span> (dict_ab.get(<span class="number">876567</span>))</span><br></pre></td></tr></table></figure><pre><code>768369705489CPU times: user 179 µs, sys: 12 µs, total: 191 µsWall time: 109 µs</code></pre><h2 id="加速循环"><a href="#加速循环" class="headerlink" title="加速循环"></a>加速循环</h2><p>总结：</p><ul><li>使用<code>for</code>循环比使用<code>while</code>循环更加快</li><li><strong>避免在循环中重复计算</strong></li></ul><h3 id="优先使用for循环而不是while循环"><a href="#优先使用for循环而不是while循环" class="headerlink" title="优先使用for循环而不是while循环"></a>优先使用for循环而不是while循环</h3><h4 id="低速方法-while"><a href="#低速方法-while" class="headerlink" title="低速方法-while"></a>低速方法-while</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">s,i=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10000</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    s += i</span><br><span class="line"><span class="keyword">print</span> (s)</span><br></pre></td></tr></table></figure><pre><code>50005000CPU times: user 4.14 ms, sys: 7 µs, total: 4.15 msWall time: 4 ms</code></pre><h4 id="高速方法-for"><a href="#高速方法-for" class="headerlink" title="高速方法-for"></a>高速方法-for</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10001</span>):</span><br><span class="line">    s += i</span><br><span class="line"><span class="keyword">print</span> (s)</span><br></pre></td></tr></table></figure><pre><code>50005000CPU times: user 3.05 ms, sys: 2 µs, total: 3.06 msWall time: 2.91 ms</code></pre><h3 id="在循环体中避免重复计算"><a href="#在循环体中避免重复计算" class="headerlink" title="在循环体中避免重复计算"></a>在循环体中避免重复计算</h3><h4 id="低速方法"><a href="#低速方法" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[i**<span class="number">2</span>+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="comment"># sum重复计算</span></span><br><span class="line">b=[i/sum(a) <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 54.7 ms, sys: 76 µs, total: 54.8 msWall time: 53.6 ms</code></pre><h4 id="高速方法"><a href="#高速方法" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time </span><br><span class="line">sum_a=sum(a)</span><br><span class="line">b=[i/sum_a <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 360 µs, sys: 0 ns, total: 360 µsWall time: 367 µs</code></pre><h2 id="加速函数"><a href="#加速函数" class="headerlink" title="加速函数"></a>加速函数</h2><p>总结：</p><ul><li>使用<strong>循环代替递归</strong>，递归速度更慢一些</li><li>使用<code>lru_cache</code>的<strong>缓存机制</strong>加速递归</li><li>使用<code>numba</code>加速函数</li></ul><h3 id="使用循环代替递归"><a href="#使用循环代替递归" class="headerlink" title="使用循环代替递归"></a>使用循环代替递归</h3><h4 id="低速方法-递归"><a href="#低速方法-递归" class="headerlink" title="低速方法-递归"></a>低速方法-递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">else</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>))</span><br><span class="line"><span class="keyword">print</span> (fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 273 ms, sys: 2.78 ms, total: 275 msWall time: 274 ms</code></pre><h4 id="高速方法-循环"><a href="#高速方法-循环" class="headerlink" title="高速方法-循环"></a>高速方法-循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>)</span><br><span class="line">    a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">    <span class="keyword">return</span> (b)</span><br><span class="line">print(fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 195 µs, sys: 13 µs, total: 208 µsWall time: 149 µs</code></pre><h3 id="缓存机制加速递归函数"><a href="#缓存机制加速递归函数" class="headerlink" title="缓存机制加速递归函数"></a>缓存机制加速递归函数</h3><h4 id="低速方法-递归-1"><a href="#低速方法-递归-1" class="headerlink" title="低速方法-递归"></a>低速方法-递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">else</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>))</span><br><span class="line"><span class="keyword">print</span> (fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 275 ms, sys: 2.79 ms, total: 277 msWall time: 275 ms</code></pre><h4 id="高速方法-缓存"><a href="#高速方法-缓存" class="headerlink" title="高速方法-缓存"></a>高速方法-缓存</h4><p><a href="http://kuanghy.github.io/2016/04/20/python-cache" target="_blank" rel="noopener">lru_cache参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多缓存100个函数运行的结果</span></span><br><span class="line"><span class="comment"># 如果为None，则无限制，设置为2n时，性能最佳</span></span><br><span class="line"><span class="meta">@lru_cache(100)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">else</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>))</span><br><span class="line"><span class="keyword">print</span> (fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 293 µs, sys: 19 µs, total: 312 µsWall time: 227 µs</code></pre><h3 id="使用numba加速Python函数"><a href="#使用numba加速Python函数" class="headerlink" title="使用numba加速Python函数"></a>使用numba加速Python函数</h3><h4 id="低速方法-1"><a href="#低速方法-1" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power_sum</span><span class="params">(n)</span>:</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        s=s+my_power(i)</span><br><span class="line">    <span class="keyword">return</span> (s)</span><br><span class="line"></span><br><span class="line">print(my_power_sum(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><pre><code>333333833333500000CPU times: user 456 ms, sys: 1.81 ms, total: 458 msWall time: 456 ms</code></pre><h4 id="高速方法-numba"><a href="#高速方法-numba" class="headerlink" title="高速方法-numba"></a>高速方法-numba</h4><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/27152060" target="_blank" rel="noopener">Python · numba 的基本应用</a></li><li><a href="https://www.jianshu.com/p/69d9d7e37bc5" target="_blank" rel="noopener">加速python运行-numba</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power_sum</span><span class="params">(n)</span>:</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        s=s+my_power(i)</span><br><span class="line">    <span class="keyword">return</span> (s)</span><br><span class="line"></span><br><span class="line">print(my_power_sum(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><pre><code>333333833333500000CPU times: user 100 ms, sys: 1.11 ms, total: 101 msWall time: 100 ms</code></pre><h2 id="使用标准库函数进行加速"><a href="#使用标准库函数进行加速" class="headerlink" title="使用标准库函数进行加速"></a>使用标准库函数进行加速</h2><p>总结：</p><ul><li>使用<code>collections.Counter</code>加速计数</li><li>使用<code>collections.ChainMap</code>加速字典合并</li></ul><h3 id="使用collections-Counter加速计数"><a href="#使用collections-Counter加速计数" class="headerlink" title="使用collections.Counter加速计数"></a>使用collections.Counter加速计数</h3><h4 id="低速方法-2"><a href="#低速方法-2" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=[x**<span class="number">2</span>%<span class="number">1989</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2000000</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">values_count=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    i_cnt=values_count.get(i,<span class="number">0</span>)</span><br><span class="line">    values_count[i]=i_cnt + <span class="number">1</span></span><br><span class="line">print(values_count.get(<span class="number">4</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>8044CPU times: user 682 ms, sys: 440 µs, total: 682 msWall time: 680 ms</code></pre><p>函数的使用:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.get(key, default=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>key</code> – 字典中要查找的键。</li><li><code>default</code> – 如果指定键的值不存在时，返回该默认值值</li></ul><h4 id="高速方法-collections"><a href="#高速方法-collections" class="headerlink" title="高速方法-collections"></a>高速方法-collections</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">values_count=Counter(data)</span><br><span class="line">print(values_count.get(<span class="number">4</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>8044CPU times: user 234 ms, sys: 0 ns, total: 234 msWall time: 233 ms</code></pre><h3 id="使用collections-ChainMap加速字典合并"><a href="#使用collections-ChainMap加速字典合并" class="headerlink" title="使用collections.ChainMap加速字典合并"></a>使用collections.ChainMap加速字典合并</h3><h4 id="低速方法-3"><a href="#低速方法-3" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_a=&#123;i:i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">2</span>)&#125;</span><br><span class="line">dict_b=&#123;i:<span class="number">2</span>*i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)&#125;</span><br><span class="line">dict_c=&#123;i:<span class="number">3</span>*i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">5</span>)&#125;</span><br><span class="line">dict_d=&#123;i:<span class="number">4</span>*i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">7</span>)&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">result=dict_a.copy()</span><br><span class="line">result.update(dict_b)</span><br><span class="line">result.update(dict_c)</span><br><span class="line">result.update(dict_d)</span><br><span class="line">print(result.get(<span class="number">9999</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>10000CPU times: user 79.9 ms, sys: 33.6 ms, total: 113 msWall time: 112 ms</code></pre><h4 id="高速方法-1"><a href="#高速方法-1" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">chain=ChainMap(dict_a,dict_b,dict_c,dict_d)</span><br><span class="line">print(result.get(<span class="number">9999</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>10000CPU times: user 186 µs, sys: 18 µs, total: 204 µsWall time: 150 µs</code></pre><h2 id="使用numpy向量化代替list"><a href="#使用numpy向量化代替list" class="headerlink" title="使用numpy向量化代替list"></a>使用numpy向量化代替list</h2><p>总结：</p><ul><li>使用<code>array</code>代替<code>list</code>进行运算</li><li>使用<code>np.ufunc</code>代替<code>math.func</code></li><li>使用<code>np.where</code>代替<code>if</code></li></ul><h3 id="使用array代替list"><a href="#使用array代替list" class="headerlink" title="使用array代替list"></a>使用array代替list</h3><h4 id="低速方法-list-1"><a href="#低速方法-list-1" class="headerlink" title="低速方法-list"></a>低速方法-list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">a=range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">b=range(<span class="number">1000000</span>,<span class="number">1</span>,<span class="number">-3</span>)</span><br><span class="line">c=[<span class="number">3</span>*a[i] - <span class="number">2</span>*b[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(a))]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 176 ms, sys: 7.75 ms, total: 184 msWall time: 181 ms</code></pre><h4 id="高速方法-2"><a href="#高速方法-2" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_a=np.arange(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">array_b=np.arange(<span class="number">1000000</span>,<span class="number">1</span>,<span class="number">-3</span>)</span><br><span class="line">array_c=<span class="number">3</span>*array_a - <span class="number">2</span>*array_b</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.18 ms, sys: 935 µs, total: 5.12 msWall time: 3.65 ms</code></pre><h3 id="使用np-ufunc代替math-func"><a href="#使用np-ufunc代替math-func" class="headerlink" title="使用np.ufunc代替math.func"></a>使用np.ufunc代替math.func</h3><h4 id="低速方法-math-func"><a href="#低速方法-math-func" class="headerlink" title="低速方法-math.func"></a>低速方法-math.func</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">a=range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">b=[math.log(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 117 ms, sys: 1.88 ms, total: 119 msWall time: 116 ms</code></pre><h4 id="高速方法-np-ufunc"><a href="#高速方法-np-ufunc" class="headerlink" title="高速方法-np.ufunc"></a>高速方法-np.ufunc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_a=np.arange(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">array_b=np.log(array_a)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 20.8 ms, sys: 1.98 ms, total: 22.8 msWall time: 21.3 ms</code></pre><h3 id="使用np-where代替if"><a href="#使用np-where代替if" class="headerlink" title="使用np.where代替if"></a>使用np.where代替if</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_a=np.arange(<span class="number">-100000</span>,<span class="number">1000000</span>)</span><br></pre></td></tr></table></figure><h4 id="低速方法-4"><a href="#低速方法-4" class="headerlink" title="低速方法"></a>低速方法</h4><p><code>np.vectorize</code>可以将普通函数转换为支持向量化的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">relu=np.vectorize(<span class="keyword">lambda</span> x:x <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">array_b=relu(array_a)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 241 ms, sys: 29.1 ms, total: 270 msWall time: 325 ms</code></pre><h4 id="高速方法-3"><a href="#高速方法-3" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">relu=<span class="keyword">lambda</span> x:np.where(x&gt;<span class="number">0</span>,x,<span class="number">0</span>)</span><br><span class="line">array_b=relu(array_a)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.86 ms, sys: 1e+03 µs, total: 5.86 msWall time: 4.36 ms</code></pre><h2 id="加速pandas"><a href="#加速pandas" class="headerlink" title="加速pandas"></a>加速pandas</h2><p>总结：</p><ul><li>运算时：使用<code>np.ufunc</code>函数代替<code>applymap</code></li><li>初始化dataframe时：使用<strong>预分配存储</strong>代替<strong>动态扩容</strong></li><li>读写文件时：使用<code>csv</code>文件代替<code>excel</code>文件读写</li><li>使用pandas多进程工具<code>pandarallel</code></li></ul><h3 id="使用np-ufunc函数代替applymap"><a href="#使用np-ufunc函数代替applymap" class="headerlink" title="使用np.ufunc函数代替applymap"></a>使用np.ufunc函数代替applymap</h3><h4 id="低速方法-使用applymap"><a href="#低速方法-使用applymap" class="headerlink" title="低速方法-使用applymap"></a>低速方法-使用applymap</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame(np.random.randint(<span class="number">-10</span>,<span class="number">11</span>,size=(<span class="number">100000</span>,<span class="number">26</span>)),</span><br><span class="line">               columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>...</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><th>0</th><td>-1</td><td>10</td><td>-6</td><td>7</td><td>1</td><td>8</td><td>3</td><td>0</td><td>4</td><td>-8</td><td>...</td><td>8</td><td>-7</td><td>-5</td><td>8</td><td>-8</td><td>-6</td><td>8</td><td>4</td><td>6</td><td>-4</td></tr><tr><th>1</th><td>7</td><td>-4</td><td>3</td><td>-9</td><td>0</td><td>-7</td><td>-10</td><td>3</td><td>-6</td><td>6</td><td>...</td><td>5</td><td>4</td><td>-5</td><td>10</td><td>2</td><td>-7</td><td>-1</td><td>-10</td><td>-7</td><td>0</td></tr><tr><th>2</th><td>-7</td><td>10</td><td>3</td><td>5</td><td>4</td><td>4</td><td>6</td><td>0</td><td>-8</td><td>-5</td><td>...</td><td>1</td><td>-1</td><td>0</td><td>2</td><td>4</td><td>-5</td><td>0</td><td>6</td><td>2</td><td>0</td></tr><tr><th>3</th><td>-8</td><td>10</td><td>-4</td><td>4</td><td>8</td><td>-9</td><td>-10</td><td>-10</td><td>2</td><td>-6</td><td>...</td><td>10</td><td>8</td><td>9</td><td>10</td><td>3</td><td>7</td><td>-1</td><td>2</td><td>0</td><td>5</td></tr><tr><th>4</th><td>4</td><td>3</td><td>3</td><td>9</td><td>-5</td><td>-1</td><td>4</td><td>1</td><td>3</td><td>-6</td><td>...</td><td>3</td><td>-1</td><td>-2</td><td>6</td><td>9</td><td>-1</td><td>0</td><td>2</td><td>-1</td><td>6</td></tr></tbody></table><br><p>5 rows × 26 columns</p><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time dfresult=df.applymap(<span class="keyword">lambda</span> x:np.sin(x)+np.cos(x))</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 9.28 s, sys: 72 ms, total: 9.36 sWall time: 9.35 s</code></pre><h4 id="高速方法-np-ufunc-1"><a href="#高速方法-np-ufunc-1" class="headerlink" title="高速方法-np.ufunc"></a>高速方法-np.ufunc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">dfresult=np.sin(df) + np.cos(df)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 256 ms, sys: 41.3 ms, total: 298 msWall time: 325 ms</code></pre><h3 id="使用预分配存储代替动态扩容"><a href="#使用预分配存储代替动态扩容" class="headerlink" title="使用预分配存储代替动态扩容"></a>使用预分配存储代替动态扩容</h3><h4 id="低速方法-动态扩容"><a href="#低速方法-动态扩容" class="headerlink" title="低速方法-动态扩容"></a>低速方法-动态扩容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df=pd.DataFrame(columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    df.loc[i,:]=range(i,i+<span class="number">26</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 12.5 s, sys: 0 ns, total: 12.5 sWall time: 12.5 s</code></pre><h4 id="高速方法-预分配存储"><a href="#高速方法-预分配存储" class="headerlink" title="高速方法-预分配存储"></a>高速方法-预分配存储</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df=pd.DataFrame(np.zeros((<span class="number">10000</span>,<span class="number">26</span>)),</span><br><span class="line">                columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    df.loc[i,:]=range(i,i+<span class="number">26</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 3.06 s, sys: 16.4 ms, total: 3.07 sWall time: 3 s</code></pre><h3 id="使用csv文件代替excel文件读写"><a href="#使用csv文件代替excel文件读写" class="headerlink" title="使用csv文件代替excel文件读写"></a>使用csv文件代替excel文件读写</h3><h4 id="低速方法-写入excel文件"><a href="#低速方法-写入excel文件" class="headerlink" title="低速方法-写入excel文件"></a>低速方法-写入excel文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df.to_excel(<span class="string">'data.xlsx'</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.64 s, sys: 37.4 ms, total: 4.68 sWall time: 4.86 s</code></pre><h4 id="高速方法-写入csv文件"><a href="#高速方法-写入csv文件" class="headerlink" title="高速方法-写入csv文件"></a>高速方法-写入csv文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df.to_csv(<span class="string">'data.csv'</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 300 ms, sys: 1.9 ms, total: 302 msWall time: 300 ms</code></pre><h3 id="使用pandas多进程工具pandarallel"><a href="#使用pandas多进程工具pandarallel" class="headerlink" title="使用pandas多进程工具pandarallel"></a>使用pandas多进程工具pandarallel</h3><h4 id="低速方法-5"><a href="#低速方法-5" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame(np.random.randint(<span class="number">-10</span>,<span class="number">11</span>,size=(<span class="number">100000</span>,<span class="number">26</span>)),</span><br><span class="line">               columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>...</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><th>0</th><td>-2</td><td>6</td><td>10</td><td>10</td><td>-1</td><td>6</td><td>-9</td><td>7</td><td>-3</td><td>1</td><td>...</td><td>-10</td><td>-8</td><td>5</td><td>8</td><td>-4</td><td>7</td><td>-3</td><td>9</td><td>9</td><td>4</td></tr><tr><th>1</th><td>4</td><td>1</td><td>-6</td><td>-1</td><td>-2</td><td>-5</td><td>-1</td><td>7</td><td>1</td><td>3</td><td>...</td><td>-10</td><td>10</td><td>7</td><td>3</td><td>0</td><td>3</td><td>1</td><td>-2</td><td>8</td><td>0</td></tr><tr><th>2</th><td>0</td><td>1</td><td>-2</td><td>-3</td><td>2</td><td>4</td><td>2</td><td>-7</td><td>8</td><td>3</td><td>...</td><td>4</td><td>10</td><td>-1</td><td>2</td><td>-7</td><td>-6</td><td>10</td><td>4</td><td>-4</td><td>-9</td></tr><tr><th>3</th><td>-4</td><td>5</td><td>-9</td><td>-8</td><td>-2</td><td>-7</td><td>-1</td><td>3</td><td>-2</td><td>-4</td><td>...</td><td>10</td><td>-9</td><td>-3</td><td>-8</td><td>-4</td><td>-3</td><td>-5</td><td>-3</td><td>-1</td><td>-2</td></tr><tr><th>4</th><td>8</td><td>3</td><td>-7</td><td>2</td><td>3</td><td>9</td><td>-10</td><td>0</td><td>0</td><td>-2</td><td>...</td><td>4</td><td>3</td><td>9</td><td>3</td><td>5</td><td>-2</td><td>-9</td><td>-5</td><td>-10</td><td>-4</td></tr></tbody></table><br><p>5 rows × 26 columns</p><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">result=df.apply(np.sum,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 11.1 s, sys: 0 ns, total: 11.1 sWall time: 11.1 s</code></pre><h4 id="高速方法-pandarallel"><a href="#高速方法-pandarallel" class="headerlink" title="高速方法-pandarallel"></a>高速方法-pandarallel</h4><p>参考链接：</p><ul><li>pandarallel的<a href="https://github.com/nalepae/pandarallel" target="_blank" rel="noopener">github</a></li><li><a href="https://nbviewer.jupyter.org/github/nalepae/pandarallel/blob/master/docs/examples.ipynb" target="_blank" rel="noopener">使用示例</a></li><li><a href="https://zhuanlan.zhihu.com/p/61746020" target="_blank" rel="noopener">用法的中文翻译</a></li></ul><p>支持的相关方法：</p><table><thead><tr><th>Without parallelisation</th><th>With parallelisation</th></tr></thead><tbody><tr><td><code>df.apply(func)</code></td><td><code>df.parallel_apply(func)</code></td></tr><tr><td><code>df.applymap(func)</code></td><td><code>df.parallel_applymap(func)</code></td></tr><tr><td><code>df.groupby(args).apply(func)</code></td><td><code>df.groupby(args).parallel_apply(func)</code></td></tr><tr><td><code>df.groupby(args1).col_name.rolling(args2).apply(func)</code></td><td><code>df.groupby(args1).col_name.rolling(args2).parallel_apply(func)</code></td></tr><tr><td><code>series.map(func)</code></td><td><code>series.parallel_map(func)</code></td></tr><tr><td><code>series.apply(func)</code></td><td><code>series.parallel_apply(func)</code></td></tr><tr><td><code>series.rolling(args).apply(func)</code></td><td><code>series.rolling(args).parallel_apply(func)</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> pandarallel <span class="keyword">import</span> pandarallel</span><br><span class="line">pandarallel.initialize(nb_workers=<span class="number">4</span>)</span><br><span class="line">result=df.parallel_apply(np.sum,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>New pandarallel memory created - Size: 2000 MBPandarallel will run on 4 workersCPU times: user 38.8 ms, sys: 58.8 ms, total: 97.6 msWall time: 3.3 s</code></pre><h2 id="使用dask进行加速"><a href="#使用dask进行加速" class="headerlink" title="使用dask进行加速"></a>使用dask进行加速</h2><p><a href="https://docs.dask.org/en/latest/why.html" target="_blank" rel="noopener">dask简介</a>：</p><blockquote><p>Dask provides ways to scale <code>Pandas</code>, <code>Scikit-Learn</code>, and <code>Numpy</code> workflows with minimal rewriting. It integrates well with these tools so that it copies most of their API and uses their data structures internally. Moreover, Dask is co-developed with these libraries to ensure that they evolve consistently, minimizing friction caused from transitioning from workloads on a local laptop, to a multi-core workstation, and to a distributed cluster. Analysts familiar with Pandas/Scikit-Learn/Numpy will be immediately familiar with their Dask equivalents, and have much of their intuition carry over to a scalable context.</p></blockquote><p><br></p><p><a href="https://docs.dask.org/en/latest/use-cases.html" target="_blank" rel="noopener">适用情形</a>：<br>Dask use cases can be roughly divided in the following two categories:</p><ul><li>Large <code>NumPy/Pandas/Lists</code> with <code>dask.array</code>, <code>dask.dataframe</code>, <code>dask.bag</code> to analyze large datasets with familiar techniques. This is similar to Databases, Spark, or big array libraries</li><li>Custom task scheduling. You submit a graph of functions that depend on each other for custom workloads. This is similar to Luigi, Airflow, Celery, or Makefiles</li></ul><p>学习教程:</p><ul><li><a href="https://cloud.tencent.com/developer/article/1010999" target="_blank" rel="noopener">python︱大规模数据存储与读取、并行计算：Dask库简述</a></li><li><a href="https://juejin.im/post/5c1feeaf5188257f9242b65c" target="_blank" rel="noopener">译|在 Python 中，如何运用 Dask 数据进行并行数据分析</a></li></ul><h3 id="使用dask加速dataframe"><a href="#使用dask加速dataframe" class="headerlink" title="使用dask加速dataframe"></a>使用dask加速dataframe</h3><h4 id="低速方法-6"><a href="#低速方法-6" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df=pd.DataFrame(np.random.randint(<span class="number">0</span>,<span class="number">6</span>,size=(<span class="number">100000000</span>,<span class="number">5</span>)),</span><br><span class="line">               columns=list(<span class="string">'abcde'</span>))</span><br><span class="line">%time df.groupby(<span class="string">'a'</span>).mean()</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.13 s, sys: 3.72 s, total: 7.85 sWall time: 8.03 s</code></pre><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>b</th><th>c</th><th>d</th><th>e</th></tr><tr><th>a</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>0</th><td>2.500325</td><td>2.499488</td><td>2.500634</td><td>2.500346</td></tr><tr><th>1</th><td>2.499725</td><td>2.499342</td><td>2.499707</td><td>2.500463</td></tr><tr><th>2</th><td>2.499565</td><td>2.499577</td><td>2.500171</td><td>2.499852</td></tr><tr><th>3</th><td>2.499790</td><td>2.499861</td><td>2.499205</td><td>2.500443</td></tr><tr><th>4</th><td>2.500874</td><td>2.499877</td><td>2.499486</td><td>2.499790</td></tr><tr><th>5</th><td>2.499937</td><td>2.499493</td><td>2.500126</td><td>2.500856</td></tr></tbody></table><br></div><h4 id="高速方法-dask"><a href="#高速方法-dask" class="headerlink" title="高速方法-dask"></a>高速方法-dask</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line">df_dask=dd.from_pandas(df,npartitions=<span class="number">40</span>)</span><br><span class="line">%time df_dask.groupby(<span class="string">'a'</span>).mean().compute()</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 12 s, sys: 6.58 s, total: 18.6 sWall time: 8.44 s</code></pre><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>b</th><th>c</th><th>d</th><th>e</th></tr><tr><th>a</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>0</th><td>2.500325</td><td>2.499488</td><td>2.500634</td><td>2.500346</td></tr><tr><th>1</th><td>2.499725</td><td>2.499342</td><td>2.499707</td><td>2.500463</td></tr><tr><th>2</th><td>2.499565</td><td>2.499577</td><td>2.500171</td><td>2.499852</td></tr><tr><th>3</th><td>2.499790</td><td>2.499861</td><td>2.499205</td><td>2.500443</td></tr><tr><th>4</th><td>2.500874</td><td>2.499877</td><td>2.499486</td><td>2.499790</td></tr><tr><th>5</th><td>2.499937</td><td>2.499493</td><td>2.500126</td><td>2.500856</td></tr></tbody></table><br></div><h3 id="使用dask-delayed进行加速"><a href="#使用dask-delayed进行加速" class="headerlink" title="使用dask.delayed进行加速"></a>使用dask.delayed进行加速</h3><h4 id="低速方法-7"><a href="#低速方法-7" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">muchjob</span><span class="params">(x)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">result = [muchjob(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">result</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 22 ms, sys: 15.4 ms, total: 37.4 msWall time: 25 s[0, 1, 4, 9, 16]</code></pre><h4 id="高速方法-4"><a href="#高速方法-4" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> dask <span class="keyword">import</span> delayed,compute</span><br><span class="line"><span class="keyword">from</span> dask <span class="keyword">import</span> threaded,multiprocessing</span><br><span class="line">values=[delayed(muchjob)(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">result=compute(*values,schediler=<span class="string">'multiprocessing'</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 10.2 ms, sys: 2.93 ms, total: 13.1 msWall time: 5.01 s</code></pre><h2 id="应用多线程多进程加速"><a href="#应用多线程多进程加速" class="headerlink" title="应用多线程多进程加速"></a>应用多线程多进程加速</h2><p>总结：</p><ul><li>针对<code>IO密集型</code>任务：应用<code>多线程</code>加速</li><li>针对<code>CPU密集型</code>任务：应用<code>多进程</code>加速</li></ul><h3 id="应用多线程加速IO密集型任务"><a href="#应用多线程加速IO密集型任务" class="headerlink" title="应用多线程加速IO密集型任务"></a>应用多线程加速IO密集型任务</h3><h4 id="低速方法-串行"><a href="#低速方法-串行" class="headerlink" title="低速方法-串行"></a>低速方法-串行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(str(i)+ <span class="string">'.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s=(<span class="string">'hello %d'</span> %i)*<span class="number">10000000</span></span><br><span class="line">        f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 串行任务</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    writefile(i)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 441 ms, sys: 971 ms, total: 1.41 sWall time: 1.4 s</code></pre><h4 id="高速方法-多线程"><a href="#高速方法-多线程" class="headerlink" title="高速方法-多线程"></a>高速方法-多线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(str(i)+ <span class="string">'.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s=(<span class="string">'hello %d'</span> %i)*<span class="number">10000000</span></span><br><span class="line">        f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程任务</span></span><br><span class="line">thread_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t=threading.Thread(target=writefile,args=(i,))</span><br><span class="line">    <span class="comment"># 设置守护线程</span></span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    thread_list.append(t)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">    <span class="comment"># 等待子线程结束</span></span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 527 ms, sys: 1.51 s, total: 2.04 sWall time: 3.97 s</code></pre><h3 id="应用多进程加速CPU密集型任务"><a href="#应用多进程加速CPU密集型任务" class="headerlink" title="应用多进程加速CPU密集型任务"></a>应用多进程加速CPU密集型任务</h3><h4 id="低速方法-8"><a href="#低速方法-8" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">muchjob</span><span class="params">(x)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 串行任务</span></span><br><span class="line">ans=[muchjob(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 4, 9, 16, 25, 36, 49]CPU times: user 38.3 ms, sys: 20.4 ms, total: 58.8 msWall time: 40 s</code></pre><h4 id="高速方法-多进程"><a href="#高速方法-多进程" class="headerlink" title="高速方法-多进程"></a>高速方法-多进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">data=range(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">muchjob</span><span class="params">(x)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程任务</span></span><br><span class="line">pool=multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">result=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    result.append(pool.apply_async(muchjob,(i,)))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line">ans=[res.get() <span class="keyword">for</span> res <span class="keyword">in</span> result]</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 4, 9, 16, 25, 36, 49]CPU times: user 18.5 ms, sys: 523 ms, total: 541 msWall time: 10.8 s</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTQzNTU2OA==&amp;mid=2247484946&amp;idx=1&amp;sn=b569829e5fef81be667847146ce65dfe&amp;chksm=fd676b4dca10e25bcaa96e3cf1244aaf290e195215136b5d34a6be0a7d1b951c1b7601ae9696&amp;token=647482703&amp;lang=zh_CN#rd" target="_blank" rel="noopener">24式加速你的Python</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;Python中加速计算的一些小tips&lt;/strong&gt;，其中有很多方法只是&lt;strong&gt;略有提及&lt;/strong&gt;，并没有做深入地学习，目前只是大致了解一些针对不同情形可以使用什么加速方法，&lt;strong&gt;后续使用的时候再有针对性地学习&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>解决conda的依赖冲突问题</title>
    <link href="http://showteeth.tech/posts/52735.html"/>
    <id>http://showteeth.tech/posts/52735.html</id>
    <published>2019-07-25T13:56:19.000Z</published>
    <updated>2019-07-27T09:47:53.901Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文记录了在conda升级到<code>4.7.10</code>版本后出现的<code>Solving environment: failed</code>问题以及解决方案。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在将实验室的conda版本升级到<code>4.7.10</code>之后就一直出现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collecting package metadata (current_repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed with current_repodata.json, will retry with next repodata <span class="built_in">source</span>.</span><br><span class="line">Collecting package metadata (repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed</span><br><span class="line">Initial quick solve with frozen env failed.  Unfreezing env and trying again.</span><br><span class="line">Solving environment: failed</span><br></pre></td></tr></table></figure><p></p><p>在网上找了很多，发现有很多和我相同的情况，比如<code>Stack Overflow</code>上的<a href="https://stackoverflow.com/questions/57117855/conda-4-7-7-4-6-collecting-package-metadata-current-repodata-json-chann" target="_blank" rel="noopener">这个问题</a>、<code>conda</code>中的这个<a href="https://github.com/conda/conda/issues/8967" target="_blank" rel="noopener">issue</a>，大部分的解决方案都是降低<code>conda</code>的版本，但是使用这种方法并没有解决我的问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="降低conda"><a href="#降低conda" class="headerlink" title="降低conda"></a>降低conda</h3><p>这个方法被证明在我的问题上是错误的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">conda update conda -c bioconda</span><br><span class="line">Collecting package metadata (current_repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed with current_repodata.json, will retry with next repodata <span class="built_in">source</span>.</span><br><span class="line">Collecting package metadata (repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed</span><br><span class="line">Initial quick solve with frozen env failed.  Unfreezing env and trying again.</span><br><span class="line">Solving environment: failed</span><br><span class="line"></span><br><span class="line">UnsatisfiableError: The following specifications were found to be incompatible with each other:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Package libssh2 conflicts <span class="keyword">for</span>:</span><br><span class="line">r=3.5.1 -&gt; mro-basics=3.5.1 -&gt; r-revoioq[version=<span class="string">'&gt;=10.0.0,&lt;10.0.1.0a0,&gt;=8.0.9,&lt;8.0.10.0a0'</span>] -&gt; r-runit[version=<span class="string">'&gt;=0.4.26'</span>] -&gt; mro-base[version=<span class="string">'3.4.3.*,3.5.0.*,3.5.1.*'</span>] -&gt; mro-base_impl==3.5.1=h9a62091_0 -&gt; curl[version=<span class="string">'&gt;=7.58.0'</span>] -&gt; libcurl==7.61.1=hbdb9355_2 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">jupyterhub -&gt; pycurl -&gt; libcurl[version=<span class="string">'&gt;=7.60.0,&lt;8.0a0,&gt;=7.63.0,&lt;8.0a0,&gt;=7.64.1,&lt;8.0a0'</span>] -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">git -&gt; curl[version=<span class="string">'&gt;=7.44.0,&lt;8,&gt;=7.59.0,&lt;8.0a0,&gt;=7.64.0,&lt;8.0a0'</span>] -&gt; libcurl==7.65.2=h20c2e04_0 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">rpy2 -&gt; r-dbplyr -&gt; r-dplyr[version=<span class="string">'&gt;=0.5.0.9004,&gt;=0.7.4,&gt;=0.8.0'</span>] -&gt; r-tidyselect[version=<span class="string">'&gt;=0.2.3,&gt;=0.2.5'</span>] -&gt; r-purrr -&gt; r-tibble -&gt; r-pillar[version=<span class="string">'&gt;=1.1.0,&gt;=1.3.1'</span>] -&gt; r-utf8[version=<span class="string">'&gt;=1.1.0,&gt;=1.1.3'</span>] -&gt; mro-base[version=<span class="string">'&gt;=3.4.3,&lt;3.5.0a0,&gt;=3.5.0,&lt;3.5.1.0a0,&gt;=3.5.1,&lt;3.5.2.0a0'</span>] -&gt; mro-base_impl==3.5.1=h9a62091_0 -&gt; curl[version=<span class="string">'&gt;=7.58.0'</span>] -&gt; libcurl==7.61.1=h20c2e04_0 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">rpy2 -&gt; r-dbplyr -&gt; r-dplyr[version=<span class="string">'&gt;=0.5.0.9004,&gt;=0.7.4,&gt;=0.8.0'</span>] -&gt; r-tidyselect[version=<span class="string">'&gt;=0.2.3,&gt;=0.2.5'</span>] -&gt; r-purrr -&gt; r-tibble -&gt; r-pillar[version=<span class="string">'&gt;=1.1.0,&gt;=1.3.1'</span>] -&gt; r-utf8[version=<span class="string">'&gt;=1.1.0,&gt;=1.1.3'</span>] -&gt; mro-base[version=<span class="string">'&gt;=3.4.3,&lt;3.5.0a0,&gt;=3.5.0,&lt;3.5.1.0a0,&gt;=3.5.1,&lt;3.5.2.0a0'</span>] -&gt; mro-base_impl==3.5.1=h9a62091_0 -&gt; curl[version=<span class="string">'&gt;=7.58.0'</span>] -&gt; libcurl==7.65.2=h20c2e04_0 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br></pre></td></tr></table></figure><p></p><p>虽然我发现使用不同的<code>channels</code>可以得到不同的依赖问题，给我了一种使用某个<code>channel</code>可以这个问题的错觉，但在尝试了诸如<code>bioconda</code>、<code>conda-canary</code>和<code>conda-forge</code>等几大常用的<code>channels</code>之后放弃了这种方法。</p><hr><h3 id="Unfreezing-env"><a href="#Unfreezing-env" class="headerlink" title="Unfreezing env"></a>Unfreezing env</h3><p>按照上面出现的错误提示：<code>Initial quick solve with frozen env failed. Unfreezing env and trying again.</code>，之前没见过这个<code>frozen env</code>，然后我就查找了<a href="https://github.com/conda/conda/issues/4864" target="_blank" rel="noopener">相关资料</a>：</p><blockquote><p>I have a new feature in mind for conda env: The ability to (temporarily) canonically disallow changing installed packages in an environment. The main use case I have in mind is when working in a shared user account that gets accessed by different people of potentially strongly varying degrees of conda-fu. The main goal is to avoid that people accidentally break background processing tasks because messing with supposed to be stable python anaconda environments.</p></blockquote><p>上面说可以使用如下命令进行<code>freeze</code>和<code>unfreeze env</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env freeze [name_of_environment]</span><br><span class="line">conda env unfreeze [name_of_environment]</span><br></pre></td></tr></table></figure><p></p><p>但是实际操作：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: conda-env [-h] &#123;create,<span class="built_in">export</span>,list,remove,update&#125; ...</span><br><span class="line">conda-env: error: invalid choice: <span class="string">'freeze'</span> (choose from <span class="string">'create'</span>, <span class="string">'export'</span>, <span class="string">'list'</span>, <span class="string">'remove'</span>, <span class="string">'update'</span>)</span><br></pre></td></tr></table></figure><p></p><p>遂作罢。</p><hr><h3 id="升级anaconda"><a href="#升级anaconda" class="headerlink" title="升级anaconda"></a>升级anaconda</h3><p>这个方法是<strong>偶然</strong>的方法，本来都准备将所有有冲突的包卸载掉进行重新安装，但是想着反正都要尝试，那就试试这个吧，结果没想到一下子<strong>成功</strong>了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure><p></p><p>虽然问题是解决了，但是<strong>想知道是怎么成功的</strong>，<strong>为什么需要升级anaconda？</strong>、<strong>升级conda和升级anaconda的区别是什么？</strong></p><p><a href="https://stackoverflow.com/questions/30034840/what-are-the-differences-between-conda-and-anaconda" target="_blank" rel="noopener">简单的解释</a>：</p><blockquote><p><code>conda</code> is the package manager. <code>Anaconda</code> is a set of about a hundred packages including <code>conda</code>, <code>numpy</code>, <code>scipy</code>, <code>ipython notebook</code>, and so on.</p></blockquote><p><a href="https://stackoverflow.com/questions/45421163/anaconda-vs-miniconda/45421527#45421527" target="_blank" rel="noopener">更官方的解释</a>：</p><blockquote><p>Note that <code>Conda</code> is the <strong>package manager</strong> (e.g. conda list displays all installed packages in the environment), whereas <code>Anaconda</code> and <code>Miniconda</code> are <strong>distributions</strong>. A <strong>software distribution</strong> is a collection of <code>packages</code>, <code>pre-built</code> and <code>pre-configured</code>, that can be installed and used on a system. A <strong>package manager</strong> is a <code>tool</code> that automates the process of <code>installing</code>, <code>updating</code>, and <code>removing</code> packages.</p></blockquote><p>上述两个说法很好地解释了conda和anaconda的区别，但是至于<strong>为什么需要升级anaconda？</strong>还没有想到或者找到比较合理的解释，先留个坑吧。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文记录了在conda升级到&lt;code&gt;4.7.10&lt;/code&gt;版本后出现的&lt;code&gt;Solving environment: failed&lt;/code&gt;问题以及解决方案。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Python/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装R出现的问题汇总</title>
    <link href="http://showteeth.tech/posts/27971.html"/>
    <id>http://showteeth.tech/posts/27971.html</id>
    <published>2019-07-25T07:35:06.000Z</published>
    <updated>2019-07-27T09:47:53.887Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux(centos)</code>下从<strong>源码</strong>安装<code>R</code>以及安装<code>R package</code>出现的一些问题。</p></div><a id="more"></a><h2 id="–with-readline-yes"><a href="#–with-readline-yes" class="headerlink" title="–with-readline=yes"></a>–with-readline=yes</h2><p><strong>错误表现</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: --with-readline=yes (default) and headers/libs are not available</span><br></pre></td></tr></table></figure><p></p><p>在网上找了很多关于这个问题的解决方法，主要包括：</p><ul><li><code>--with-readline=no</code>：这个方法是最傻的办法，使用之后R代码可能不能补全以及鼠标不能左右移动，极大了降低了开发速度</li><li><code>yum install readline-devel</code>：因为我的系统是centos，所以很多都说需要这样安装一下就可以了，但是这并不能解决我的问题，系统提示我已经安装了这个package并且已经是最新版本了。</li></ul><p><strong>我的解决办法</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对已经安装了readline以及readline-devel</span></span><br><span class="line"><span class="comment"># 在config.site文件中指定CPPFLAGS、LDFLAGS</span></span><br><span class="line"><span class="comment"># 这两个目录包括了readline的相关文件</span></span><br><span class="line">CPPFLAGS=<span class="string">'-I/usr/include'</span></span><br><span class="line">LDFLAGS=<span class="string">'-L/usr/lib64'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在configure中加上LDFLAGS="-lncurses"接口</span></span><br><span class="line">./configure --prefix=`<span class="built_in">pwd</span>` --with-x=no --<span class="built_in">enable</span>-R-shlib=yes LDFLAGS=<span class="string">"-lncurses"</span></span><br></pre></td></tr></table></figure><p></p><p>关于<code>CPPFLAGS</code>、<code>LDFLAGS</code>可以查阅<a href="http://showteeth.tech/posts/62231.html">这篇文章</a>.</p><hr><h2 id="conda中R找不到zlib"><a href="#conda中R找不到zlib" class="headerlink" title="conda中R找不到zlib"></a>conda中R找不到zlib</h2><p>在安装<code>Rhdf5lib</code> package出现如下问题：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: either specify a valid zlib installation with --with-zlib=DIR or <span class="built_in">disable</span> zlib usage with --without-zlib</span><br></pre></td></tr></table></figure><p></p><p>和前面的<code>readline</code>相同，都是已经安装了相应的库，但仍然提示找不到，不过这个好像是<code>conda</code>中<code>R</code>的一个普遍问题：<a href="https://github.com/grimbough/Rhdf5lib/issues/21" target="_blank" rel="noopener">issue</a></p><p><strong>我的解决方法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 治标不治本，只能解决这次安装的需求</span></span><br><span class="line"><span class="comment"># step 1：下载源码文件</span></span><br><span class="line">wget https://bioconductor.org/packages/release/bioc/src/contrib/Rhdf5lib_1.6.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2：指定LDFLAGS</span></span><br><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-L/home/softwares/anaconda3/envs/r351/lib/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3：在命令行下安装</span></span><br><span class="line">/home/softwares/anaconda3/envs/r351/bin/R CMD INSTALL  Rhdf5lib_1.6.0.tar.gz</span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Linux(centos)&lt;/code&gt;下从&lt;strong&gt;源码&lt;/strong&gt;安装&lt;code&gt;R&lt;/code&gt;以及安装&lt;code&gt;R package&lt;/code&gt;出现的一些问题。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Linux/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装软件报错：version ZLIB_1.2.9 not found</title>
    <link href="http://showteeth.tech/posts/741.html"/>
    <id>http://showteeth.tech/posts/741.html</id>
    <published>2019-07-24T07:22:17.000Z</published>
    <updated>2019-07-25T07:22:30.756Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了由<code>/lib64/libz.so.1: version &#39;ZLIB_1.2.9&#39; not found</code>问题导致Rstudio中报错<code>Error in RStudioGD()</code>的解决方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>rstudio server</code>的时候忽然出现如下报错，并且<code>R</code>不能继续画图(R的优势所在，对我而言)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> RStudioGD() : </span><br><span class="line">  Shadow graphics device error: r error 4 (R code execution error)</span><br><span class="line">In addition: There were 50 or more warnings (use warnings() to see the first 50)</span><br></pre></td></tr></table></figure><p></p><p>在网上查了很多资料，大部分都说需要重装<code>R</code>语言，但是我觉得很不可思议啊，我啥也没做，为啥会需要重装R呢，这不科学，所以我还是先按照提示的信息使用<code>warnings()</code>查看了一下报错信息，前几个报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1: In grDevices:::png(<span class="string">"/tmp/Rtmp1WZiNp/1150e349a3c44bcfbf9fd2adc0969720.png"</span>,  ... :</span><br><span class="line">  unable to load shared object <span class="string">'/home/softwares/anaconda3/envs/r351/lib/R/library/grDevices/libs//cairo.so'</span>:</span><br><span class="line">  /lib64/libz.so.1: version `ZLIB_1.2.9<span class="string">' not found (required by /home/softwares/anaconda3/envs/r351/lib/R/library/grDevices/libs//../../../../libpng16.so.16)</span></span><br></pre></td></tr></table></figure><p>看到这个拨错信息我先松了一口气，<code>/lib64/libz.so.1: version &#39;ZLIB_1.2.9&#39; not found</code>这个错误不是常见的错误嘛，可能是这个导致的。</p><p><br></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>报错提示表明在<code>/lib64/libz.so.1</code>中缺少<code>ZLIB_1.2.9</code>或更高版本，具体包含哪些版本可以使用如下命令查看：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libz.so.1 |grep <span class="string">"ZLIB*"</span></span><br><span class="line">  ZLIB_1.2.0</span><br><span class="line">  ZLIB_1.2.0.2</span><br><span class="line">  ZLIB_1.2.0.8</span><br><span class="line">  ZLIB_1.2.2</span><br><span class="line">  ZLIB_1.2.2.3</span><br><span class="line">  ZLIB_1.2.2.4</span><br><span class="line">  ZLIB_1.2.3.3</span><br><span class="line">  ZLIB_1.2.3.4</span><br><span class="line">  ZLIB_1.2.3.5</span><br><span class="line">  ZLIB_1.2.5.1</span><br><span class="line">  ZLIB_1.2.5.2</span><br></pre></td></tr></table></figure><p></p><p>通过输出结果发现缺少是没有相应的版本。</p><p>解决这个问题的方法非常简单，总的来说就是查找和替换，使用带有<code>ZLIB_1.2.9</code>或更高版本替换<code>/lib64/libz.so.1</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找</span></span><br><span class="line">find / -name <span class="string">"libz.so.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认其中的某一个libz.so.1含有ZLIB_1.2.9</span></span><br><span class="line">strings /home/softwares/anaconda3/lib/libz.so.1 |grep <span class="string">"ZLIB*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">rm /usr/lib64/libz.so.1</span><br><span class="line"><span class="comment"># 也可以使用ln -s来创建软连接</span></span><br><span class="line">cp /home/softwares/anaconda3/lib/libz.so.1 /usr/lib64/</span><br></pre></td></tr></table></figure><p></p><p>在解决这个问题之后，发现再次使用<code>R</code>，之前出现的问题也再没有出现，所以说<strong>还是要提前查看报错信息</strong>，<strong>不要一股脑地相信搜到的解决方案</strong>，对我的这个问题，即使重装R(很麻烦)也是不会得到解决的！</p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在管理实验室集群过程中经常遇到这个问题，在安装一些软件或者更新一些系统文件的时候某些包含低版本函数的共享库(<code>so</code>后缀的文件)会自动替换之前设置好的包含高版本函数的共享库，比较常见的除了这里出现的<code>ZLIB_1.2.9</code>还有<code>GLIBCXX_3.4.15</code>等，所有这些问题的解决方法都是和上述类似的，查找-替换。</p><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了由&lt;code&gt;/lib64/libz.so.1: version &amp;#39;ZLIB_1.2.9&amp;#39; not found&lt;/code&gt;问题导致Rstudio中报错&lt;code&gt;Error in RStudioGD()&lt;/code&gt;的解决方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/Linux/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
