<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-10-19T15:48:11.607Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设置Github项目徽章</title>
    <link href="http://showteeth.tech/posts/19563.html"/>
    <id>http://showteeth.tech/posts/19563.html</id>
    <published>2019-10-19T14:55:21.000Z</published>
    <updated>2019-10-19T15:48:11.607Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了为自己的<a href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener">项目</a><strong>增加徽章</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>Github</code>上我们经常能看到一些项目的小徽章(<code>Badge</code>)，这些小徽章可以很简洁明了地介绍项目信息，比如下面<code>pandas</code>的项目徽章：</p><table><tr><td>Latest Release</td><td><a href="https://pypi.org/project/pandas/" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/v/pandas.svg" alt="latest release"></a></td></tr><td></td><td><a href="https://anaconda.org/anaconda/pandas/" target="_blank" rel="noopener"><img src="https://anaconda.org/conda-forge/pandas/badges/version.svg" alt="latest release"></a></td><tr><td>Package Status</td><td><a href="https://pypi.org/project/pandas/" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/status/pandas.svg" alt="status"></a></td></tr><tr><td>License</td><td><a href="https://github.com/pandas-dev/pandas/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/l/pandas.svg" alt="license"></a></td></tr><tr><td>Build Status</td><td><a href="https://travis-ci.org/pandas-dev/pandas" target="_blank" rel="noopener"><img src="https://travis-ci.org/pandas-dev/pandas.svg?branch=master" alt="travis build status"></a></td></tr><tr><td></td><td><a href="https://dev.azure.com/pandas-dev/pandas/_build/latest?definitionId=1&branch=master" target="_blank" rel="noopener"><img src="https://dev.azure.com/pandas-dev/pandas/_apis/build/status/pandas-dev.pandas?branch=master" alt="Azure Pipelines build status"></a></td></tr><tr><td>Coverage</td><td><a href="https://codecov.io/gh/pandas-dev/pandas" target="_blank" rel="noopener"><img src="https://codecov.io/github/pandas-dev/pandas/coverage.svg?branch=master" alt="coverage"></a></td></tr><tr><td>Downloads</td><td><a href="https://pandas.pydata.org" target="_blank" rel="noopener"><img src="https://anaconda.org/conda-forge/pandas/badges/downloads.svg" alt="conda-forge downloads"></a></td></tr><tr><td>Gitter</td><td><a href="https://gitter.im/pydata/pandas" target="_blank" rel="noopener"><img src="https://badges.gitter.im/Join%20Chat.svg"></a></td></tr></table><p>这篇文章将会学习如何给自己的项目加上一些项目徽章。</p><h2 id="徽章生成网站"><a href="#徽章生成网站" class="headerlink" title="徽章生成网站"></a>徽章生成网站</h2><p>GitHub 项目的徽章可以使用<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>来生成。使用该网站生成徽章主要有两种方法：</p><ul><li><a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>自动推荐。这种方法只需要你提供<code>Github</code>项目的<code>url</code>链接，<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>会依据你的项目项目信息进行推荐，一般会包括<code>Github issues</code>、<code>Github forks</code>、<code>Github stars</code>、<code>Github license</code>、<code>Twitter</code>。</li><li><strong>生成自定义的徽章标签</strong>。如果想要自己修改徽章的文字和颜色，<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>也支持自定义的方式来进行设置。</li></ul><h2 id="自动推荐徽章"><a href="#自动推荐徽章" class="headerlink" title="自动推荐徽章"></a>自动推荐徽章</h2><h3 id="得到徽章"><a href="#得到徽章" class="headerlink" title="得到徽章"></a>得到徽章</h3><p>打开<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>，输入<code>Github</code>项目链接，点击<code>Suggest badges</code>即可，具体效果如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章.png" alt="Github项目徽章.png"></p><h3 id="设置徽章"><a href="#设置徽章" class="headerlink" title="设置徽章"></a>设置徽章</h3><p>点击图标或者链接，即可进入设置页，设置图标的颜色、样式等属性，最后选择你想要的 <code>markdown</code> 或者 <code>URL</code> 代码到 <code>README.md</code> 或者项目的文档页面即可:<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_2.png" alt="Github项目徽章_2.png"></p><p>效果图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_3.png" alt="Github项目徽章_3.png"></p><h2 id="自定义徽章"><a href="#自定义徽章" class="headerlink" title="自定义徽章"></a>自定义徽章</h2><p>打开<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>，找到<code>Your Badge</code>，输入<code>label</code>、<code>message</code>和<code>color</code>，<code>Make Badge</code>即可：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_4.png" alt="Github项目徽章_4.png"></p><p>最后将得到的信息加入到项目的<code>README.md</code>中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置了超链接</span></span><br><span class="line">[![blog__reprint](https://img.shields.io/badge/showteeth-blog__reprint-yellow)](https://github.com/showteeth/blog_reprint)</span><br><span class="line">[![GitHub forks](https://img.shields.io/github/forks/showteeth/blog_reprint)](https://github.com/showteeth/blog_reprint/network)</span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果图</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_5.png" alt="Github项目徽章_5.png"></p><div class="note info"><p>总结：</p><ul><li>实际上徽章就是<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>帮助我们<strong>生成的一些小图片</strong>，得到这些图片后我们可以将其以<code>markdown</code>的语法加载<code>.md</code>文件中；</li><li><strong>徽章是静态的</strong>，不会根据项目内容的改变而做出自动的调整，所以<strong>如果项目更改了和徽章相关的信息就需要手动对其进行修改</strong>。</li></ul></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了为自己的&lt;a href=&quot;https://github.com/showteeth/blog_reprint&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目&lt;/a&gt;&lt;strong&gt;增加徽章&lt;/strong&gt;的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-两种绘图接口的统一</title>
    <link href="http://showteeth.tech/posts/22997.html"/>
    <id>http://showteeth.tech/posts/22997.html</id>
    <published>2019-10-19T14:15:42.000Z</published>
    <updated>2019-10-19T14:52:06.570Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>plt.gca()</code>将<code>Matplotlib</code>的<code>state-based interface</code>转化为<code>object-oriented interface</code>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>文章中提到过<code>Matplotlib</code>有两种让初学者非常难受的地方，其中之一就是其有<strong>两种绘图接口(两种绘图的语法)</strong>，这意味着使用<code>Matplotlib</code>绘图需要记住两种截然不同的绘图语法规则，这是非常痛苦的，尤其是在需要对图片进行自定义地调整的时候。基于这种情况，如果能够找到一种方法将两种绘图接口统一起来，那就极大减少<code>Matplotlib</code>的使用难度。这里发现了一种可以将两种绘图接口结合起来的方法：使用<code>plt.gca()</code>将<code>state-based interface</code>转化为<code>object-oriented interface</code>，下面将会仔细了解一下。</p><hr><h2 id="plt-gca"><a href="#plt-gca" class="headerlink" title="plt.gca()"></a>plt.gca()</h2><p><code>plt.gca()</code>的作用是得到<strong>当前图片的<code>Axes</code>实例</strong>，如果<code>Axes</code>不存在，那就创建一个。</p><blockquote><p>Get the <strong>current Axes instance</strong> on the current figure matching the given keyword args, or create one. If the current axes doesn’t exist, or isn’t a polar one, the appropriate axes will be created and then returned.</p></blockquote><hr><h2 id="两种接口转化"><a href="#两种接口转化" class="headerlink" title="两种接口转化"></a>两种接口转化</h2><p>以隐藏<code>tick label</code>为例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用state-based interface的方法</span></span><br><span class="line">plt.plot(range(<span class="number">10</span>))</span><br><span class="line">plt.tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用object-oriented interface的方法</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(range(<span class="number">10</span>))</span><br><span class="line">ax.tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用plt.gca()将state-based interface转换为object-oriented interface语法</span></span><br><span class="line">plt.gca().tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.gca.html" target="_blank" rel="noopener">matplotlib.pyplot.gca</a></li><li><a href="https://stackoverflow.com/questions/45381589/how-does-plt-gca-work-internally" target="_blank" rel="noopener">How does plt.gca work internally</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了使用&lt;code&gt;plt.gca()&lt;/code&gt;将&lt;code&gt;Matplotlib&lt;/code&gt;的&lt;code&gt;state-based interface&lt;/code&gt;转化为&lt;code&gt;object-oriented interface&lt;/code&gt;的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-速查表</title>
    <link href="http://showteeth.tech/posts/12679.html"/>
    <id>http://showteeth.tech/posts/12679.html</id>
    <published>2019-10-18T15:31:30.000Z</published>
    <updated>2019-10-19T13:49:34.788Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是一个<code>Matplotlib</code>绘图的速查表，便于日后使用<code>Matplotlib</code>绘图查询使用，内容源于<a href="https://github.com/rougier/matplotlib-cheatsheet/blob/master/README.md" target="_blank" rel="noopener">matplotlib-cheatsheet</a>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在系统学习<code>Matplotlib</code>绘图，恰巧看到知乎上一篇文章讲的是<code>Matplotlib</code>速查表，我大致看了一看，感觉整理地确实很详细，所以在这里学习和记录一下，以便以后查阅。</p><hr><h2 id="线条类型和常用颜色"><a href="#线条类型和常用颜色" class="headerlink" title="线条类型和常用颜色"></a>线条类型和常用颜色</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_1.png" alt="matplotlib速查_1.png"></p><p>相关名词：</p><ul><li><a href="https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/joinstyle.html" target="_blank" rel="noopener">Cap styles</a>: Cap styles define how the the end of a line is drawn</li><li><a href="https://stackoverflow.com/questions/8750203/what-is-antialiased-in-matplotlib-collections-and-how-do-you-set-the-paramet" target="_blank" rel="noopener">Antialias</a>:<ul><li>The antialiased keyword argument controls <strong>whether or not a particular matplotlib artist (e.g. line, polygon, etc) is drawn with antialising or not</strong>. <mark>Non-antialiased plotting will be faster, so if you’re plotting a large amount of data, it can be worthwhile to turn it off.</mark></li><li>简单理解就是matplotlib在画图时会对呈现的图像进行处理来使图像更加光滑，不至于出现那种锯齿状的像素块形状(混叠效应)。</li></ul></li></ul><hr><h2 id="marker的种类和颜色"><a href="#marker的种类和颜色" class="headerlink" title="marker的种类和颜色"></a>marker的种类和颜色</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_2.png" alt="matplotlib速查_2.png"></p><ul><li><a href="https://matplotlib.org/examples/pylab_examples/markevery_demo.html" target="_blank" rel="noopener">Marker spacing</a>：控制绘制marker的频率，如<ul><li><code>markevery=5</code>表示隔五个数据点画一个marker</li><li><code>markevery=[0, -1]</code>表示只在第一个数据点和最后一个数据点画marker</li></ul></li></ul><hr><h2 id="多边形集合"><a href="#多边形集合" class="headerlink" title="多边形集合"></a>多边形集合</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_3.png" alt="matplotlib速查_3.png"></p><hr><h2 id="常用图形"><a href="#常用图形" class="headerlink" title="常用图形"></a>常用图形</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_4.png" alt="matplotlib速查_4.png"></p><hr><h2 id="刻度控制"><a href="#刻度控制" class="headerlink" title="刻度控制"></a>刻度控制</h2><p><a href="https://matplotlib.org/3.1.1/gallery/ticks_and_spines/tick-locators.html" target="_blank" rel="noopener">官网链接</a><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_5.png" alt="matplotlib速查_5.png"></p><hr><h2 id="图片布局调整"><a href="#图片布局调整" class="headerlink" title="图片布局调整"></a>图片布局调整</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_6.png" alt="matplotlib速查_6.png"></p><hr><h2 id="legend控制"><a href="#legend控制" class="headerlink" title="legend控制"></a>legend控制</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_7.png" alt="matplotlib速查_7.png"></p><hr><h2 id="坐标轴类型-线性和对数"><a href="#坐标轴类型-线性和对数" class="headerlink" title="坐标轴类型-线性和对数"></a>坐标轴类型-线性和对数</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_8.png" alt="matplotlib速查_8.png"></p><hr><h2 id="常用colormap名称"><a href="#常用colormap名称" class="headerlink" title="常用colormap名称"></a>常用colormap名称</h2><p><a href="https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html" target="_blank" rel="noopener">官方教程</a><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_9.png" alt="matplotlib速查_9.png"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/rougier/matplotlib-cheatsheet/blob/master/matplotlib-cheatsheet.pdf" target="_blank" rel="noopener">pdf的Github地址</a></li><li><a href="https://zhuanlan.zhihu.com/p/77782561?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=680025552107343872" target="_blank" rel="noopener">Matplotlib速查表——画图时候一定要放手边的表</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是一个&lt;code&gt;Matplotlib&lt;/code&gt;绘图的速查表，便于日后使用&lt;code&gt;Matplotlib&lt;/code&gt;绘图查询使用，内容源于&lt;a href=&quot;https://github.com/rougier/matplotlib-cheatsheet/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matplotlib-cheatsheet&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>R系列之包的相关操作汇总</title>
    <link href="http://showteeth.tech/posts/28413.html"/>
    <id>http://showteeth.tech/posts/28413.html</id>
    <published>2019-10-17T01:24:59.000Z</published>
    <updated>2019-10-17T02:25:44.136Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了对<code>R</code>包的一些常用操作，包括<strong>安装<code>R</code>包的各种方法</strong>、<strong>查看已加载的包</strong>、<strong>卸除加载包</strong>、<strong>卸载R包</strong>、<strong>查看包提供的函数</strong>以及<strong>查看包的版本</strong>。</p></div><a id="more"></a><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><h3 id="install-packages安装"><a href="#install-packages安装" class="headerlink" title="install.packages安装"></a>install.packages安装</h3><p>这个是安装<code>R</code>包最常用也是最简单的方法，关键在于镜像的选择(有时候安装不成功，换个镜像说不定就成功了)：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定使用清华的镜像</span></span><br><span class="line">install.packages(<span class="string">"getopt"</span>, repos=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/CRAN"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用官方镜像</span></span><br><span class="line">install.packages(<span class="string">'ggplot2'</span>, dependencies=<span class="literal">TRUE</span>, repos=<span class="string">'http://cran.rstudio.com/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用如下方法一次指定</span></span><br><span class="line"><span class="comment"># Allow the user to set and examine a variety of global options </span></span><br><span class="line"><span class="comment"># which affect the way in which R computes and displays its results.</span></span><br><span class="line">options(repos=structure(c(CRAN=<span class="string">"http://cran.rstudio.com/"</span>)))</span><br><span class="line">install.packages(<span class="string">"ggplot2"</span>, dependencies = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="从github直接安装"><a href="#从github直接安装" class="headerlink" title="从github直接安装"></a>从github直接安装</h3><p>有些包如果没有发布在<code>CRAN(Comprehensive R Archive Network)</code>或者使用前面的安装方法不成功上可以直接从<code>github</code>上安装：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Github安装</span></span><br><span class="line"><span class="comment"># 先安装devtools，然后在利用devtools中的install_github进行安装</span></span><br><span class="line">install.packages(<span class="string">"devtools"</span>, repo=<span class="string">"http://cran.rstudio.com/"</span>)</span><br><span class="line"><span class="keyword">library</span>(devtools)</span><br><span class="line">install_github(<span class="string">"kassambara/ggpubr"</span>)</span><br></pre></td></tr></table></figure><p></p><p><code>github</code>安装<code>R</code>包还可以使用<code>githubinstall</code>包，其<strong>功能更加完善一些</strong>，可以<strong>搜索某个用户</strong>的所有包、<strong>关键词搜索R包**</strong>、显示指定<code>R</code>函数的源代码**等，不过我觉得有一个就可以了，后续如果需要再看吧。</p><hr><h3 id="Bioconductor安装"><a href="#Bioconductor安装" class="headerlink" title="Bioconductor安装"></a>Bioconductor安装</h3><p><code>Bioconductor</code>中主要包含的是进行生信分析所需要的包，如果不是生信行业从业者，这个方法可能不是很适用，不过也有可能自己需要的包包含在了<code>Bioconductor</code>中：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source一下源码</span></span><br><span class="line"><span class="comment"># 如果源码被黑存在病毒，那就gg</span></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">biocLite(<span class="string">"org.Dr.eg.db"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在R3.5.1之后，推出了BiocManager包Bioconductor包的安装</span></span><br><span class="line"><span class="comment"># 先安装BiocManager</span></span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">"BiocManager"</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">"BiocManager"</span>)</span><br><span class="line"><span class="comment"># BiocManager::install()</span></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">BiocManager::install(c(<span class="string">"GenomicFeatures"</span>, <span class="string">"AnnotationDbi"</span>))</span><br></pre></td></tr></table></figure><p></p><p>安装包的自动化脚本：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要安装的包的名称</span></span><br><span class="line">package_list &lt;- c(<span class="string">"clusterProfiler"</span>,<span class="string">"getopt"</span>,<span class="string">"org.Hs.eg.db"</span>,<span class="string">"org.Mm.eg.db"</span>,<span class="string">"topGO"</span>,<span class="string">"pathview"</span>,<span class="string">"Rgraphviz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> package_list)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!suppressWarnings(suppressMessages(<span class="keyword">require</span>(p, character.only = <span class="literal">TRUE</span>, quietly = <span class="literal">TRUE</span>, warn.conflicts = <span class="literal">FALSE</span>))))&#123;</span><br><span class="line">    <span class="comment"># Bioconductor安装</span></span><br><span class="line">    <span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">    biocLite(p)</span><br><span class="line">    suppressWarnings(suppressMessages(<span class="keyword">library</span>(p, character.only = <span class="literal">TRUE</span>, quietly = <span class="literal">TRUE</span>, warn.conflicts = <span class="literal">FALSE</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><mark>require和library加载包的区别</mark>：</p><ul><li><strong>包不存在时</strong>：使用<code>library</code>加载包会<strong>直接报错停止</strong>；而使用<code>require</code>加载则只会出现<code>Warning message</code>，<strong>不会停止执行</strong>，并且<code>require</code>命令会返回<code>FALSE</code>，所以可以<strong>利用这个特性进行检测环境是不是安装了某个包，并进行自动化安装</strong>；</li><li><strong>包存在时</strong>：都是加载包</li></ul></div><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/tandelin/article/details/87601729" target="_blank" rel="noopener">从Github上获取R包/安装</a></li><li><a href="https://www.bioconductor.org/install/" target="_blank" rel="noopener">Using Bioconductor</a></li><li><a href="https://stackoverflow.com/questions/5595512/what-is-the-difference-between-require-and-library" target="_blank" rel="noopener">What is the difference between require() and library()?</a></li></ul><hr><h2 id="查看已加载的包"><a href="#查看已加载的包" class="headerlink" title="查看已加载的包"></a>查看已加载的包</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意外面的括号和前面的点不能省</span></span><br><span class="line">(.packages())</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"htmlwidgets"</span> <span class="string">"recharts"</span>    <span class="string">"stats"</span>       <span class="string">"graphics"</span>    <span class="string">"grDevices"</span>   <span class="string">"utils"</span>       <span class="string">"datasets"</span>   </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"methods"</span></span><br></pre></td></tr></table></figure><hr><h2 id="卸除加载包"><a href="#卸除加载包" class="headerlink" title="卸除加载包"></a>卸除加载包</h2><p>注意<strong>是卸除，不是卸载</strong>，也就是说不是把包从R运行环境中彻底删除，只是<strong>不希望该包被加载使用</strong>；在<strong>包使用函数冲突</strong>，<strong>检验函数依赖</strong>时比较有用。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">detach</span>(<span class="string">"package:htmlwidgets"</span>)</span><br><span class="line">(.packages())</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"recharts"</span>  <span class="string">"stats"</span>     <span class="string">"graphics"</span>  <span class="string">"grDevices"</span> <span class="string">"utils"</span>     <span class="string">"datasets"</span>  <span class="string">"methods"</span>   <span class="string">"base"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="卸载R包"><a href="#卸载R包" class="headerlink" title="卸载R包"></a>卸载R包</h2><p><strong>彻底删除</strong>已安装的包：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># "pkg1","pkg2"表示包名，即一次可以卸载多个包；</span></span><br><span class="line">remove. packages(c(<span class="string">"pkg1"</span>,<span class="string">"pkg2"</span>) , lib = file .path(<span class="string">"path"</span>, <span class="string">"to"</span>, <span class="string">"library"</span>))</span><br><span class="line"><span class="comment"># "path", "to", "library"表示R的库路径，字符向量，通常情况下只输一个路径即可。</span></span><br><span class="line"><span class="comment"># 使用命令.libPaths()可以查看库路径。示例：</span></span><br><span class="line">&gt; .libPaths()</span><br><span class="line">[<span class="number">1</span>] <span class="string">"D:/R-3.5.1/library"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="查看某个包提供的函数"><a href="#查看某个包提供的函数" class="headerlink" title="查看某个包提供的函数"></a>查看某个包提供的函数</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(package=<span class="string">'ggplot2'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="查看包的版本"><a href="#查看包的版本" class="headerlink" title="查看包的版本"></a>查看包的版本</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packageVersion(<span class="string">"ggplot2"</span>)</span><br><span class="line">  [<span class="number">1</span>] ‘<span class="number">3.2</span><span class="number">.0</span>’</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了对&lt;code&gt;R&lt;/code&gt;包的一些常用操作，包括&lt;strong&gt;安装&lt;code&gt;R&lt;/code&gt;包的各种方法&lt;/strong&gt;、&lt;strong&gt;查看已加载的包&lt;/strong&gt;、&lt;strong&gt;卸除加载包&lt;/strong&gt;、&lt;strong&gt;卸载R包&lt;/strong&gt;、&lt;strong&gt;查看包提供的函数&lt;/strong&gt;以及&lt;strong&gt;查看包的版本&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之SGE出现Command Not Found, Undefined Variable</title>
    <link href="http://showteeth.tech/posts/35609.html"/>
    <id>http://showteeth.tech/posts/35609.html</id>
    <published>2019-10-14T14:19:53.000Z</published>
    <updated>2019-10-15T04:56:49.561Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>SGE</code>集群任务管理系统提交任务时出现的<code>Command Not Found, Undefined Variable</code>错误的<strong>原因</strong>以及<strong>解决方法</strong>，同时也列出了<strong>常用的参数</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>SGE(Sun Grid Engine)</code>集群任务管理系统提交任务时莫名出现了错误<code>Command Not Found, Undefined Variable</code>，具体就是使用<code>a=path; cd ${a}</code>，结果发现<code>a=path: Command not found; a: Undefined variable.</code>，这个错误让我很纳闷，平常在另一个机器上使用<code>SGE</code>使用同样的脚本并不会出错啊，但是为啥现在就不行了呢？这篇文章就记录了出现这个问题的原因以及可行的解决办法。</p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现上述问题的原因总的来说就是<mark>当前机器上<code>SGE</code>默认的<code>shell</code>不是<code>bash</code>，而是<code>csh</code>，而<code>csh</code>在对(局部)变量进行赋值操作时需要使用<code>set a=path</code>，而不是<code>bash</code>中常用的<code>a=path</code></mark>。</p><p>查看<code>SGE</code>集群节点的默认<code>shell</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看queue列表</span></span><br><span class="line">qconf -sql</span><br><span class="line">  all.q</span><br><span class="line">  bnode.q</span><br><span class="line">  guo.q</span><br><span class="line">  little.q</span><br><span class="line">  login04.q</span><br><span class="line">  lu.q</span><br><span class="line">  qlogin.q</span><br><span class="line">  yang.q</span><br><span class="line">  zhong.q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看自己所属队列的情况</span></span><br><span class="line">qconf -sq all.q</span><br><span class="line">  qname                 all.q</span><br><span class="line">  <span class="comment"># 主机列表，也就是这个队列可以使用的节点名称</span></span><br><span class="line">  hostlist              hpbnode-0-1.local hpbnode-0-2.local node-0-1.local \</span><br><span class="line">                        node-0-13.local node-0-14.local node-0-15.local \</span><br><span class="line">                        node-0-16.local.hpc.org node-0-18.local node-0-19.local \</span><br><span class="line">                        node-0-2.local node-0-20.local node-0-3.local \</span><br><span class="line">                        node-0-4.local node-0-5.local node-0-6.local \</span><br><span class="line">                        node-0-7.local</span><br><span class="line">  seq_no                0</span><br><span class="line">  load_thresholds       np_load_avg=1.5</span><br><span class="line">  suspend_thresholds    NONE</span><br><span class="line">  nsuspend              1</span><br><span class="line">  suspend_interval      00:05:00</span><br><span class="line">  priority              0</span><br><span class="line">  min_cpu_interval      00:05:00</span><br><span class="line">  processors            UNDEFINED</span><br><span class="line">  qtype                 BATCH INTERACTIVE</span><br><span class="line">  ckpt_list             NONE</span><br><span class="line">  pe_list               make mpi mpich openmp orte smp</span><br><span class="line">  rerun                 FALSE</span><br><span class="line">  slots                 16,[bnode02.local=32],[C-login01.local=32], \</span><br><span class="line">                        [C-login02.local=32],[C-login03.local=32], \</span><br><span class="line">                        [C-login04.local=56],[hpbnode-0-2.local=24]</span><br><span class="line">  tmpdir                /tmp</span><br><span class="line">  <span class="comment"># 默认的shell就是csh，而不是bash</span></span><br><span class="line">  <span class="comment"># 这个就是问题的关键</span></span><br><span class="line">  shell                 /bin/csh</span><br><span class="line">  prolog                NONE</span><br><span class="line">  epilog                NONE</span><br><span class="line">  shell_start_mode      posix_compliant</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>既然<code>SGE</code>默认的<code>shell</code>不是<code>bash</code>，而我们大部分对<code>bash</code>比较熟悉，所以<strong>最简单直接</strong>的办法就是将<code>SGE</code>默认的<code>shell</code>修改为<code>bash</code>，这个是一劳永逸的方法，具体的可以参考<a href="https://stackoverflow.com/questions/2020957/how-to-change-the-default-shell-for-the-sun-grid-engine" target="_blank" rel="noopener">这个</a>，因为使用的是学校的集群，所以自己不敢轻举妄动，或许也没有轻举妄动的权利，有兴趣的可以自行尝试。</p><p><strong>另一种方法，也是最推荐的方法</strong>就是在任务提交脚本中指明<code>SGE</code>使用的<code>shell</code>，使用语句：<code>#$ -S /bin/bash</code>，这样就可以直接使用熟悉的<code>bash</code>语法进行脚本的编写了。</p><p><strong>最后一种方法也是个人最不推荐的方法</strong>就是使用<code>csh</code>的语法进行脚本的编写，如上述需求可以使用：<code>set a=path</code>来解决，这种方法对于我来说不方便，有些复杂，还需要去了解<code>csh</code>的语法。</p><hr><h2 id="sge任务提交脚本示例"><a href="#sge任务提交脚本示例" class="headerlink" title="sge任务提交脚本示例"></a>sge任务提交脚本示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh This script is interpreted by the Bourne shell, sh.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The name of my job:</span></span><br><span class="line"><span class="comment">#$ -N glxspheres</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The interpreter SGE must use:</span></span><br><span class="line"><span class="comment">#$ -S /bin/shSun Grid Engine always uses sh to interpret this script.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Join stdout and stderr:</span></span><br><span class="line"><span class="comment">#$ -j y</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This job needs a graphics device:</span></span><br><span class="line"><span class="comment">#$ -l gfx=1 # Allocate a graphics resource to this job.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify that these environment variables are to be sent to SGE with the job:</span></span><br><span class="line"><span class="comment">#$ -v DISPLAY</span></span><br><span class="line"><span class="comment">#$ -v VGL_CLIENT</span></span><br><span class="line"><span class="comment">#$ -v VGL_GAMMA</span></span><br><span class="line"><span class="comment">#$ -v VGL_GLLIB</span></span><br><span class="line"><span class="comment">#$ -v VGL_SPOIL</span></span><br><span class="line"><span class="comment">#$ -v VGL_X11LIB</span></span><br><span class="line"><span class="comment">#$ -v SSH_CLIENT</span></span><br><span class="line"><span class="comment"># If these variables are not set before qsub/qrsh is invoked,</span></span><br><span class="line"><span class="comment"># then the job will find these variables set, but with a null string value ("").</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Script can run on what systems?</span></span><br><span class="line"><span class="comment"># Solaris (SPARC or x86, 32-bit or 64-bit) and Linux systems (32- or 64-bit),</span></span><br><span class="line"><span class="comment"># provided glxspheres is installed on the target system in one of the paths below.</span></span><br><span class="line"><span class="comment">#$ -l arch=sol-sparc|sol-sparc64|sol-x86|sol-amd64|lx24-x86|lx24-amd64</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># If VGL_DISPLAY is set by SGE, then run program with vglrun. Otherwise don't.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;VGL_DISPLAY+set&#125;</span>"</span> ]; <span class="keyword">then</span> If VGL_DISPLAY is <span class="built_in">set</span> (even <span class="keyword">if</span> null)...</span><br><span class="line"></span><br><span class="line">VGLRUN=/opt/VirtualGL/bin/vglrun Then the script will use vglrun to launch application.</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -x <span class="variable">$VGLRUN</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> 1&gt;&amp;2 <span class="string">"vglrun not found on host <span class="variable">$&#123;HOSTNAME:=‘hostname‘&#125;</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    VGLRUN=<span class="string">""</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>  [ -x /opt/VirtualGL/bin/glxspheres ]; <span class="keyword">then</span></span><br><span class="line">    path=/opt/VirtualGL/bin/glxspheres</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 1&gt;&amp;2 <span class="string">"glxspheres not found on host <span class="variable">$&#123;HOSTNAME&#125;</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Sun Grid Engine job starts vglrun which starts glxspheres</span></span><br><span class="line"><span class="comment"># with any arguments passed to this script.  If VGL_DISPLAY is not set,</span></span><br><span class="line"><span class="comment"># $VGLRUN will be the empty string, and vglrun won't be invoked.</span></span><br><span class="line"><span class="variable">$VGLRUN</span> <span class="string">"<span class="variable">$path</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="其他实用参数"><a href="#其他实用参数" class="headerlink" title="其他实用参数"></a>其他实用参数</h2><ul><li><code>-V</code>： 将<strong>当前的环境变量传递到执行命令的节点中</strong>，<code>Specifies that all environment variables active within the qsub utility be exported to the context of the job</code>.</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://talby.rcs.manchester.ac.uk/~ri/_linux_and_hpc_lib/sge_intro.html#jobshellsect" target="_blank" rel="noopener">An Intro to SGE</a></li><li><a href="https://stackoverflow.com/questions/17271931/sge-command-not-found-undefined-variable" target="_blank" rel="noopener">SGE Command Not Found, Undefined Variable</a></li><li><a href="https://docs.oracle.com/cd/E19279-01/820-3257-12/n1ge.html#50577430_84220" target="_blank" rel="noopener">Sun Grid Engine Reference</a></li><li><a href="http://gridscheduler.sourceforge.net/htmlman/htmlman1/qsub.html" target="_blank" rel="noopener">qsub的帮助文档，查看参数</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了使用&lt;code&gt;SGE&lt;/code&gt;集群任务管理系统提交任务时出现的&lt;code&gt;Command Not Found, Undefined Variable&lt;/code&gt;错误的&lt;strong&gt;原因&lt;/strong&gt;以及&lt;strong&gt;解决方法&lt;/strong&gt;，同时也列出了&lt;strong&gt;常用的参数&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib-基础</title>
    <link href="http://showteeth.tech/posts/4719.html"/>
    <id>http://showteeth.tech/posts/4719.html</id>
    <published>2019-10-13T09:34:57.000Z</published>
    <updated>2019-10-19T14:24:39.016Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章是<strong>系统</strong>学习<code>Matplotlib</code>包的开始，主要包括<strong>对<code>Matplotlib</code>的介绍</strong>、<strong>其他常用的绘图包</strong>、<strong><code>Matplotlib</code>中的两种绘图接口</strong>、<strong><code>Matplotlib</code>所接受的输入数据类型</strong>以及<strong><code>Matplotlib</code>中一些常用术语和模块关系</strong>，为以后的深入学习打下基础。</p></div><a id="more"></a><h2 id="Matplotlib简介"><a href="#Matplotlib简介" class="headerlink" title="Matplotlib简介"></a>Matplotlib简介</h2><p>在<code>Python</code>中只要是使用常规的绘图功能(交互式绘图除外)，<code>Matplotlib</code>是你必然会使用的一个<code>package</code>。有时候你的使用是<strong>显式的</strong>，有时候你的使用是<strong>隐式的</strong>，说隐式的原因是<code>Python</code>中常用的绘图包都是基于<code>Matplotlib</code>进行二次开发的，比如<code>Seaborn</code>、<code>pandas</code>(内置的一些绘图方法)、<code>plotnine</code>(类似<code>R</code>中的<code>ggplot2</code>)、<code>ggplot</code>(类似R中的<code>ggplot2</code>)。所以学习使用<code>Matplotlib</code>是使用<code>Python</code>进行绘图不可避免的一个环节。</p><p>但是<code>Matplotlib</code>也有一些很让<strong>初学者难受</strong>的地方：</p><ul><li><strong>两种绘图接口</strong>。一种是基于<code>MATLAB</code>的<code>state-based interface</code>，一种是<code>object-oriented interface</code>(这两种接口在后续会进行进一步地介绍)，因为存在两种绘图接口，也就是说<strong>可以使用两套代码来完成同一个图</strong>，在实际使用过程中可能会<strong>带来混乱</strong>——当你使用一种<code>interface</code>绘图遇到错误去搜索的时候，发现大部分的答案是基于另一种<code>interface</code>的，直接把这种代码拷贝过来发现并不能得到别人所说的效果；</li><li><strong>基于Matplotlib的工具太多，这些工具既相似又存在很大差异</strong>。在<code>Python</code>中绘图，有时候发现<code>pandas</code>可以直接实现，有时候发现<code>Seaborn</code>也可以绘图，并且用的人也很多，但是使用的时候发现自己的需求单纯使用<code>pandas</code>、<code>Seaborn</code>可能不能解决，同时这两者绘图中的大部分语句又和<code>Matplotlib</code>类似，导致的结果就是想去学习绘图，但是又不知道从哪个<code>package</code>开始学习，最终的结果就是啥也没学会。</li></ul><p>虽然<code>Matplotlib</code>存在一些让初学者很难受的地方(我这么晚才开始系统学习<code>Matplotlib</code>的原因)，但是这些问题在初学者对<code>Matplotlib</code>有基本的学习和了解之后就可以很轻松的解决(<strong>个人的真实感受</strong>)。</p><p><br></p><h2 id="其他绘图包"><a href="#其他绘图包" class="headerlink" title="其他绘图包"></a>其他绘图包</h2><p>在具体了解<code>Matplotlib</code>之前，先详细了解一下其他目前<code>Python</code>中<strong>常用的绘图包以及其适用场景</strong>：</p><ul><li><code>Seaborn</code>：<code>Seaborn</code> 是一个基于 <code>Matplotlib</code> 的高级可视化效果库， <strong>偏向于统计作图</strong>。因此，<strong>针对的点主要是数据挖掘和机器学习中的变量特征选取</strong>。相比 <code>Matplotlib</code> ，它<strong>语法相对简化些</strong>，绘制出来的图不需要花很多功夫去修饰。但是它<strong>绘图方式比较局限，不过灵活</strong>。</li><li><code>Bokeh</code>：<code>Bokeh</code> 是基于 <code>javascript</code> 来实现<strong>交互可视化库</strong>，它可以在<code>WEB</code>浏览器中实现美观的视觉效果。但是它也有明显的<strong>缺点</strong>:其一是<strong>版本时常更新</strong>，最重要的是有时<strong>语法还不向下兼容</strong>；其二是<strong>语法晦涩</strong>。</li><li><code>Plotly</code>：<code>Plotly</code> 也是一个<strong>交互可视化库</strong>。它不仅支持 <code>Python</code> 还支持 <code>R</code> 语言。<code>Plotly</code> 的<strong>优点</strong>是能提供 <code>WEB</code> 在线交互，配色也真心好看。如果你是一名数据分析师，<code>Plotly</code> 强大的交互功能能助你一臂之力完成展示。</li><li><code>ggplot</code>：<code>ggplot</code> 是 <code>yhat</code> 大神基于 <code>R</code> 语言的 <code>ggplot2</code>制作的 <code>python</code> 版本库。 如果你使用 <code>R</code> 语言的话，<code>ggplot2</code> 可以算是必不可少的工具。所以，很多人都推荐使用该库，不过可惜的是，<code>yhat</code> 大神已<strong>经停止维护该库</strong>了(<a href="https://github.com/yhat/ggpy" target="_blank" rel="noopener">github</a>上最近一次更新还是3年之前了)。</li><li><code>plotnine</code>：<code>plotnine</code>也是一个为了在<code>Python</code>中实现<code>ggplot2</code>语法进行绘图的<code>package</code>，相比对长时间没有维护的<code>ggplot</code>，这个<code>package</code>目前仍然活跃，<a href="https://github.com/has2k1/plotnine" target="_blank" rel="noopener">github</a>上最近一次更新是2个月前，而且其<a href="https://plotnine.readthedocs.io/en/stable/" target="_blank" rel="noopener">文档</a>也比<code>ggplot</code>做得好很多，便于学习和使用。</li></ul><p><a href="https://pbpython.com/python-vis-flowchart.html" target="_blank" rel="noopener">最后附上绘图package的选择</a>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib_packages.png" alt="matplotlib_packages.png"></p><p><br></p><h2 id="关于Matplotlib中的两种绘图接口"><a href="#关于Matplotlib中的两种绘图接口" class="headerlink" title="关于Matplotlib中的两种绘图接口"></a>关于Matplotlib中的两种绘图接口</h2><h3 id="state-based-interface"><a href="#state-based-interface" class="headerlink" title="state-based interface"></a>state-based interface</h3><p>这种<code>interface</code>是基于<code>MATLAB</code>，其在创建<strong>简单图形</strong>的时候比较好用(可以使用<code>plt.XXX</code>来绘制图形的各个部分)，但是允许的<strong>对图形的控制不是很多</strong>。使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># 使用plt完成所有的绘图操作</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.title(<span class="string">'Test figure'</span>)        </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="object-oriented-interface"><a href="#object-oriented-interface" class="headerlink" title="object-oriented interface"></a>object-oriented interface</h3><p>这种方法<strong>较为复杂</strong>，但是可以<strong>对图形进行完整的控制</strong>。使用这种<code>interface</code>进行绘图的<strong>主要思想</strong>是：</p><ul><li>创建一个<code>&quot;figure&quot;</code>对象(可以将其视为可视化的边界框)</li><li>然后创建一个或多个<code>&quot;axes&quot;</code>对象(作为可视化的子图)，主要这里的<code>&quot;axes&quot;</code>需要和<code>&quot;axis&quot;</code>进行区分，<code>&quot;axes&quot;</code>是指子图，而<code>&quot;axis&quot;</code>指的是一个图形的<code>x/y</code>轴</li><li>最后可以使用<code>&quot;axes&quot;</code>对象的方法来控制子图。</li></ul><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 创建"figure"对象以及一个"axes"对象</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 使用"axes"对象的方法来控制子图</span></span><br><span class="line">ax.bar(x=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>], height=[<span class="number">3.1</span>,<span class="number">7</span>,<span class="number">4.2</span>], color=<span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(xlabel=<span class="string">'X title'</span>, size=<span class="number">20</span>)</span><br><span class="line">ax.set_ylabel(ylabel=<span class="string">'Y title'</span> , color=<span class="string">'b'</span>, size=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意事项：</p><ul><li>通常情况下，尽量使用<code>object-oriented interface</code>，而不是<code>state-based(Pyplot) interface</code>.</li><li>在<code>object-oriented interface</code>中也会用到<code>state-based(Pyplot) interface</code>，不过用到的功能很少，包括<strong>用来创建和显示图片</strong>。</li></ul></div><p><br></p><h2 id="学习和使用步骤"><a href="#学习和使用步骤" class="headerlink" title="学习和使用步骤"></a>学习和使用步骤</h2><p>在这篇文章中提到了学习和使用<code>Matplotlib</code>的步骤，我觉得不错，这里直接对其进行翻译：</p><ul><li>学习<code>Matplotlib</code>中常用的术语，尤其是什么是<code>Figure</code>以及<code>Axes</code>；</li><li>使用<code>object-oriented interface</code>，在开始分析之前就养成这种习惯；</li><li>从基本的<code>pandas</code>绘图开始进行可视化操作；</li><li>使用<code>Seaborn</code>进行<strong>更加复杂的统计可视化</strong>；</li><li>使用<code>Matplotlib</code>来对<code>pandas</code>和<code>Seaborn</code>做的图进行<strong>自定义</strong>；</li><li>有了<code>Matplotlib</code>基础再根据需求学习其他的绘图<code>package</code>，比如<code>plotly</code>等.</li></ul><p><br></p><h2 id="图形的组件"><a href="#图形的组件" class="headerlink" title="图形的组件"></a>图形的组件</h2><p><code>Matplotlib Usage</code>中对图形的<strong>每个部分</strong>有个很好的图示说明：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_element.png" alt="figure_element.png"></p><p><strong>了解图形组件的意义</strong>：</p><blockquote><p>Once you understand what these are and how to access them through the object oriented API, the rest of the process starts to fall into place.</p></blockquote><blockquote><p>The other benefit of this knowledge is that you <strong>have a starting point when you see things on the web</strong>. If you take the time to understand this point, <strong>the rest of the matplotlib API will start to make sense</strong>. Also, many of the advanced python packages like seaborn and ggplot rely on matplotlib so understanding the basics will <strong>make those more powerful frameworks much easier to learn</strong>.</p></blockquote><h3 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h3><p><code>Figure</code>涵盖了<strong>整个图片的内容</strong>，包括所有的<code>Axes</code>、a smattering of ‘special’ artists (<code>titles</code>, <code>figure legends</code>, etc)以及<code>canvas</code>(很重要的一个组成成分，是实际绘图和获取图像的部分，但是<strong>对于user来说是不可见的</strong>)。</p><p><code>Figure</code>可以包含任意数目的<code>Axes</code>，但要有用，最少要包含一个，也就是说常规的(<code>object-oriented interface</code>)，<strong>一个<code>Figure</code>可以包括一个或多个<code>Axes</code></strong>。</p><p>创建<code>Figure</code>最简单的方法是使用<code>pyplot</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># an empty figure with no axes</span></span><br><span class="line"><span class="comment"># 适用于state-based(Pyplot) interface</span></span><br><span class="line">fig = plt.figure()  </span><br><span class="line"><span class="comment"># a figure with a 2x2 grid of Axes</span></span><br><span class="line">fig, ax_lst = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a>Axes</h3><p><code>Axes</code>就是<strong>所谓的(子)图的概念</strong>，它是具有数据空间的图像区域。<strong>一个给定的<code>Figure</code>可以包含多个<code>Axes</code>，但是一个给定的<code>Axes</code>只能是某一个<code>Figure</code>的一部分</strong>。</p><p>一个<code>Axes</code>包括两个或三个<code>Axis</code>对象(注意区分<code>Axes</code>和<code>Axis</code>，前者是图，后者是图片的<code>X/Y</code>轴)；每个<code>Axes</code>包括一个<code>title</code>、<code>x-label</code>、<code>y-label</code>。</p><p><strong>打个比方：<code>Figure</code>类似于一整A4纸(画布)，然后我们将这个A4纸对折得到两个隔区，这每个隔区可以用来写字(画图)，这里的每个隔区就类似于<code>Axes</code></strong>。</p><hr><h3 id="Axis"><a href="#Axis" class="headerlink" title="Axis"></a>Axis</h3><p><code>Axis</code>是<code>number-line-like objects</code>，主要是用来设置图形的<code>(x、y)limits</code>以及产生<code>ticks</code>(凸起的小刻度线)和<code>ticklabels</code>(小刻度线对应的数值)。<code>ticks</code>的位置是由<a href="https://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Locator" target="_blank" rel="noopener">Locator</a>对象决定的，<code>ticklabel</code>是由<a href="https://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Formatter" target="_blank" rel="noopener">Formatter</a>对象决定的，正确使用这两个对象可以很好地控制<code>ticks</code>以及<code>ticklabels</code>。</p><p><strong><code>Figure</code>、<code>Axes</code>以及<code>Axis</code>关系的图示</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Figure_Axes_Axis.png" alt="Figure_Axes_Axis.png"></p><hr><h3 id="Artist"><a href="#Artist" class="headerlink" title="Artist"></a>Artist</h3><p>在<strong>图中所有可以看见的部分基本上都是artist(甚至包括前面提到的<code>Figure</code>、<code>Axes</code>和<code>Axis</code>)</strong>，其主要包括：<code>Text</code>对象、<code>Line2D</code>对象、<code>collection</code>对象以及<code>Patch</code>对象等。在绘制图形时，所有的<code>artists</code>都会画在<code>canvas</code>(用户不可见)上。大部分的<code>artists</code>都绑定在<code>Axes</code>上，<strong>因此<code>artists</code>不能被共享或者进行移动</strong>。</p><h2 id="画图所需的数据类型"><a href="#画图所需的数据类型" class="headerlink" title="画图所需的数据类型"></a>画图所需的数据类型</h2><p><strong>所有的绘图函数都以<code>np.array</code>或者<code>np.ma.masked_array</code>作为输入</strong>，其他的<code>array-like</code>对象<strong>如<code>pandas</code>的数据对象以及<code>np.matrix</code>可能不会很好的<code>work</code></strong>，最好能将这些数据对象在绘图之前转为<code>np.array</code>对象。</p><p>当然<code>pandas</code>中的数据对象可以直接使用<code>pandas</code>内置的画图方法，也是基于<code>Matplotlib</code>的。</p><p><br></p><h2 id="Matplotlib、pyplot、pylab之间的关系"><a href="#Matplotlib、pyplot、pylab之间的关系" class="headerlink" title="Matplotlib、pyplot、pylab之间的关系"></a>Matplotlib、pyplot、pylab之间的关系</h2><p><code>Matplotlib</code>是整个<code>package</code>的名称，而<code>matplotlib.pyplot</code>是<code>Matplotlib</code>中的一个<code>module</code>，而<code>pylab</code>是在伴随着<code>matplotlib</code>一块安装的<code>module</code>。</p><p><code>Pyplot</code>为基础的<code>object-oriented interface</code>提供了<code>state-based interface</code>(前面提到了<code>object-oriented interface</code>中也会用到<code>state-based interface</code>中创建和保存图片的功能)。<code>state-based interface</code>会<strong>显式或者隐式地创建<code>Figure</code>和<code>Axes</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 隐式创建</span></span><br><span class="line"><span class="comment"># 第一次调用plt.plot会自动创建figure和axes</span></span><br><span class="line">plt.plot(x, x, label=<span class="string">'linear'</span>)</span><br><span class="line"><span class="comment"># 后续的plt.plot会使用当前的axes，直接添加一条线</span></span><br><span class="line">plt.plot(x, x**<span class="number">2</span>, label=<span class="string">'quadratic'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">3</span>, label=<span class="string">'cubic'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置title、legend以及axis labels也会使用当前的axes</span></span><br><span class="line">plt.xlabel(<span class="string">'x label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y label'</span>)</span><br><span class="line">plt.title(<span class="string">"Simple Plot"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><p><code>pylab</code> is a convenience module that <strong><code>bulk imports</code> <code>matplotlib.pyplot</code> (for plotting) and <code>numpy</code> (for mathematics and working with arrays) in a single name space.</strong> Although many examples use pylab, <strong>it is no longer recommended</strong>.</p><p><mark>对于非交互式绘图，推荐使用pyplot来创建图片，然后使用object-oriented interface进行绘图</mark></p><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://matplotlib.org/faq/usage_faq.html" target="_blank" rel="noopener">Matplotlib Usage</a></li><li><a href="https://matplotlib.org/tutorials/introductory/lifecycle.html" target="_blank" rel="noopener">The Lifecycle of a Plot</a></li><li><a href="https://pbpython.com/effective-matplotlib.html" target="_blank" rel="noopener">Effectively Using Matplotlib</a></li><li><a href="https://www.jianshu.com/p/ebe721199d72" target="_blank" rel="noopener">Python 绘图，我只用 Matplotlib（一）</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章是&lt;strong&gt;系统&lt;/strong&gt;学习&lt;code&gt;Matplotlib&lt;/code&gt;包的开始，主要包括&lt;strong&gt;对&lt;code&gt;Matplotlib&lt;/code&gt;的介绍&lt;/strong&gt;、&lt;strong&gt;其他常用的绘图包&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;Matplotlib&lt;/code&gt;中的两种绘图接口&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;Matplotlib&lt;/code&gt;所接受的输入数据类型&lt;/strong&gt;以及&lt;strong&gt;&lt;code&gt;Matplotlib&lt;/code&gt;中一些常用术语和模块关系&lt;/strong&gt;，为以后的深入学习打下基础。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="常用模块" scheme="http://showteeth.tech/categories/Python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="常用模块" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Matplotlib中文显示</title>
    <link href="http://showteeth.tech/posts/60218.html"/>
    <id>http://showteeth.tech/posts/60218.html</id>
    <published>2019-10-12T13:13:51.000Z</published>
    <updated>2019-10-12T14:47:31.982Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux</code>下如何让<code>matplotlib</code>可以<strong>正确地显示中文</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习使用<code>matplotlib</code>画图过程中<strong>遇到了中文显示的问题</strong>，在<code>google</code>上搜索了很多结果，按照这些结果都不能正确显示(<strong>大部分的博客都是互相抄的，没有经过自己的实验验证，这也坚定了我自己写blog的决心</strong>)，所以这里自己记录一下。</p><hr><h2 id="查找matplotlib字体文件夹"><a href="#查找matplotlib字体文件夹" class="headerlink" title="查找matplotlib字体文件夹"></a>查找matplotlib字体文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找matplotlib配置文件的位置</span></span><br><span class="line">import matplotlib</span><br><span class="line">matplotlib.matplotlib_fname()</span><br><span class="line">  /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体文件夹和这个文件在同一目录</span></span><br><span class="line">ll /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data</span><br><span class="line">  drwxr-xr-x. 2 root root 4.0K Aug  8 22:27 stylelib</span><br><span class="line">  drwxr-xr-x. 2 root root 4.0K Aug  8 22:27 images</span><br><span class="line">  -rw-rw-r--. 2 root root  33K Jul 24 13:42 matplotlibrc</span><br><span class="line">  drwxr-xr-x. 5 root root   61 Apr 11  2019 fonts</span><br></pre></td></tr></table></figure><hr><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><p>这个具体的操作参考<a href="http://showteeth.tech/posts/358.html">Linux系列之添加中文字体</a></p><hr><h2 id="查找和更新matplotlib中文缓存"><a href="#查找和更新matplotlib中文缓存" class="headerlink" title="查找和更新matplotlib中文缓存"></a>查找和更新matplotlib中文缓存</h2><h3 id="查找字体缓存地址"><a href="#查找字体缓存地址" class="headerlink" title="查找字体缓存地址"></a>查找字体缓存地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字体缓存地址</span></span><br><span class="line"><span class="comment"># 最好是直接输出这个目录的绝对路径</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.get_cachedir()</span><br><span class="line">  <span class="comment"># /home/user/.cache/matplotlib</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除字体缓存"><a href="#删除字体缓存" class="headerlink" title="删除字体缓存"></a>删除字体缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到字体缓存地址后，可以将其中的缓存信息全部删除</span></span><br><span class="line">rm -rf /home/user/.cache/matplotlib/*</span><br></pre></td></tr></table></figure><hr><h3 id="直接更新字体缓存"><a href="#直接更新字体缓存" class="headerlink" title="直接更新字体缓存"></a>直接更新字体缓存</h3><p>除了上面的<strong>手动删除字体缓存</strong>之外，可以<strong>直接使用python语句更新字体缓存</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> _rebuild</span><br><span class="line">_rebuild()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用中文字体"><a href="#使用中文字体" class="headerlink" title="使用中文字体"></a>使用中文字体</h2><p><strong>上述更新完缓存之后，如果是<code>jupyter</code>，一定要重启一次，切记，不然不会生效</strong>。</p><h3 id="暂时使用中文字体"><a href="#暂时使用中文字体" class="headerlink" title="暂时使用中文字体"></a>暂时使用中文字体</h3><p><strong>在<code>Python</code>中指明使用的中文字体</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>]= <span class="string">'SimHei'</span> <span class="comment"># 指定字体，实际上相当于修改 matplotlibrc 文件　只不过这样做是暂时的　下次失效</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment"># 正确显示负号，防止变成方框</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用如下命令也行</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>] <span class="comment">#用来正常显示中文标签 </span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment">#用来正常显示负号</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y,label=<span class="string">"$sin(x)$"</span>,color=<span class="string">"red"</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">"t轴"</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y轴'</span>)</span><br><span class="line">plt.title(<span class="string">'中文'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="永久使用中文字体"><a href="#永久使用中文字体" class="headerlink" title="永久使用中文字体"></a>永久使用中文字体</h3><p>如果想要一次修改永久使用，可以直接修改<code>matplotlibrc</code>文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件地址在第一步就已经得到了</span></span><br><span class="line">vim /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改如下内容：</span></span><br><span class="line"><span class="comment">## SimHei必须写在font.sans-serif的第一位，不然不会生效</span></span><br><span class="line">font.family         : sans-serif        </span><br><span class="line">font.sans-serif     : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif <span class="comment"># 在其中添加中文字体名</span></span><br><span class="line">axes.unicode_minus  :False，<span class="comment">#作用就是解决负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zsxh.github.io/blog/2018/05/28/matplotlib%20%E5%9C%A8%20Linux%20Deepin%20%E4%B8%8B%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/" target="_blank" rel="noopener">matplotlib 在 Linux Deepin 下中文显示</a></li><li><a href="https://zodiac911.github.io/blog/matplotlib-chinese.html" target="_blank" rel="noopener">让Matplotlib正确显示中文</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Linux&lt;/code&gt;下如何让&lt;code&gt;matplotlib&lt;/code&gt;可以&lt;strong&gt;正确地显示中文&lt;/strong&gt;的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之添加中文字体</title>
    <link href="http://showteeth.tech/posts/358.html"/>
    <id>http://showteeth.tech/posts/358.html</id>
    <published>2019-10-12T12:45:02.000Z</published>
    <updated>2019-10-12T14:47:11.732Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux(centos)</code>下<strong>安装(中文)字体</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>Python</code>画图的时候发现中文乱码，想要进行中文的显示就需要系统有中文字体，但是<code>centos</code>默认是没有中文字体的，所以就需要下载，这里记录一下下载安装过程。</p><hr><h2 id="查看已安装字体"><a href="#查看已安装字体" class="headerlink" title="查看已安装字体"></a>查看已安装字体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装字体配置相关库</span></span><br><span class="line">yum install -y fontconfig mkfontscale</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装的字体</span></span><br><span class="line"><span class="built_in">fc</span>-list</span><br><span class="line">  /usr/share/fonts/default/Type1/c059016l.pfb: Century Schoolbook L:style=Bold</span><br><span class="line">  /usr/share/fonts/default/Type1/c059033l.pfb: Century Schoolbook L:style=Italic</span><br><span class="line">  /usr/share/fonts/default/Type1/p052024l.pfb: URW Palladio L:style=Bold Italic</span><br><span class="line">  /usr/share/fonts/default/Type1/d050000l.pfb: Dingbats:style=Regular</span><br><span class="line">  /usr/share/fonts/default/Type1/s050000l.pfb: Standard Symbols L:style=Regular</span><br><span class="line">  /usr/share/fonts/liberation/LiberationMono-Bold.ttf: Liberation Mono:style=Bold</span><br><span class="line">  /usr/share/fonts/default/Type1/n021003l.pfb: Nimbus Roman No9 L:style=Regular</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装了的中文字体</span></span><br><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line">  <span class="comment"># 没有结果输出，说明没有安装到中文字体</span></span><br></pre></td></tr></table></figure><hr><h2 id="部分中文字体的英文名"><a href="#部分中文字体的英文名" class="headerlink" title="部分中文字体的英文名"></a>部分中文字体的英文名</h2><table><tr><th width="25%">中文字体</th><th width="25%">英文名</th><th width="25%">中文字体</th><th width="25%">英文名</th></tr><tr><td>宋体</td><td>SimSun</td><td>华文细黑</td><td>STXihei</td></tr><tr><td>黑体</td><td>SimHei</td><td>华文楷体</td><td>STKaiti</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>华文宋体</td><td>STSong</td></tr><tr><td>微软正黑体</td><td>Microsoft JhengHei</td><td>华文中宋</td><td>STZhongsong</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>华文仿宋</td><td>STFangsong</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>方正舒体</td><td>FZShuTi</td></tr><tr><td>细明体</td><td>MingLiU</td><td>方正姚体</td><td>FZYaoti</td></tr><tr><td>标楷体</td><td>DFKai-SB</td><td>华文彩云</td><td>STCaiyun</td></tr><tr><td>仿宋</td><td>FangSong</td><td>华文琥珀</td><td>STHupo</td></tr><tr><td>楷体</td><td>KaiTi</td><td>华文隶书</td><td>STLiti</td></tr><tr><td>隶书</td><td>LiSu</td><td>华文行楷</td><td>STXingkai</td></tr><tr><td>幼圆</td><td>YouYuan</td><td>华文新魏</td><td>STXinwei</td></tr></table><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><ul><li><strong>创建字体目录</strong>：在<code>linux</code>下的<code>/usr/share/fonts</code>目录中创建目录：<code>mkdir chinese</code></li><li><strong>复制字体</strong>：在<code>windows</code>下的<code>C:\Windows\Fonts</code>目录中选择自己想要的字体移动到刚刚在<code>linux</code>上创建的<code>chinese</code>目录</li><li><strong>下载字体</strong>：从<a href="https://github.com/tracyone/program_font" target="_blank" rel="noopener">github</a>上下载字体</li><li><strong>安装字体</strong>：建立字体索引信息，更新字体缓存。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里一共有三个字体：宋体、微软雅黑、中易黑体</span></span><br><span class="line">-rw-r--r--. 1 root root 9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">-rw-r--r--. 1 root root 18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">-rw-r--r--. 1 root root 19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改目录权限，可选操作</span></span><br><span class="line">chmod -R 755 /usr/share/fonts/chinese</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立字体索引信息，更新字体缓存</span></span><br><span class="line">mkfontscale</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line">mkfontdir</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.dir</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line"><span class="built_in">fc</span>-cache</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.dir</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br></pre></td></tr></table></figure><hr><h2 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line">  <span class="comment"># 相比于第一次运行没有结果输出，这里出现了字体添加的中文字体</span></span><br><span class="line">  /usr/share/fonts/chinese/MSYH.TTC: Microsoft YaHei:style=Normal</span><br><span class="line">  /usr/share/fonts/chinese/SIMSUN.TTC: SimSun,宋体:style=Regular,常规</span><br><span class="line">  /usr/share/fonts/chinese/MSYH.TTC: Microsoft YaHei UI:style=Normal</span><br><span class="line">  /usr/share/fonts/chinese/SIMSUN.TTC: NSimSun,新宋体:style=Regular,常规</span><br><span class="line">  /usr/share/fonts/chinese/simhei.ttf: SimHei:style=Regular,Normal</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ilanni.com/?p=11746" target="_blank" rel="noopener">linux安装中文字体</a></li><li><a href="https://www.cnblogs.com/cuishuai/p/8441132.html" target="_blank" rel="noopener">Centos7 安装字体库&amp;中文字体</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Linux(centos)&lt;/code&gt;下&lt;strong&gt;安装(中文)字体&lt;/strong&gt;的过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python系列之Linux安装scipy</title>
    <link href="http://showteeth.tech/posts/34795.html"/>
    <id>http://showteeth.tech/posts/34795.html</id>
    <published>2019-10-08T13:10:53.000Z</published>
    <updated>2019-10-10T15:57:55.978Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Python2.7</code>环境下安装<code>scipy</code>过程中遇到的一些问题以及爬坑过程(解决方案).</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近实验室的师姐在分析数据的时候需要用到一个软件，该软件依赖于<code>Python2.7</code>以及<code>scipy</code>、<code>numpy</code>包的，但师姐在安装scipy中遇到了一些问题，我在解决的时候也发现了<strong>很多陷阱</strong>，这里记录一下。</p><hr><h2 id="安装之路"><a href="#安装之路" class="headerlink" title="安装之路"></a>安装之路</h2><h3 id="直接pip安装默认scipy"><a href="#直接pip安装默认scipy" class="headerlink" title="直接pip安装默认scipy"></a>直接pip安装默认scipy</h3><p>安装<code>python</code>包最简单粗暴的方法就是直接上<code>pip</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pip之前先更新一波</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接pip安装scipy</span></span><br><span class="line">pip install scipy</span><br></pre></td></tr></table></figure><p></p><p><strong>直接报错，报错信息如下</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Python version &gt;= 3.5 required.</span><br></pre></td></tr></table></figure><p></p><p>上述报错提示需要<code>Python</code>版本<code>&gt;=3.5</code>才可以安装，但是我用的是<code>python2</code>的<code>pip</code>啊，为什么不能直接安装<code>python2</code>对应的<code>scipy</code>版本呢？</p><p><strong>原因猜测</strong>：在<a href="https://github.com/scipy/scipy/releases" target="_blank" rel="noopener">scipy的github</a>上可以发现现在的<strong>scipy会有两个不同的更新</strong>，一个是<code>1.3.x</code>的还有一个就是<code>1.2.x</code>的更新，仔细看两种版本的更新可以发现：<code>1.3.x</code>支持的是<code>Python 3.5+</code>的版本，没有提供<code>Python 2.x</code>版本的安装信息；而与之对应的<code>1.2.x</code>版本的就有提供<code>Python 2.x</code>版本的安装文件。基于上述判断，<strong>直接使用<code>pip</code>安装可能会默认安装<code>scipy 1.3.x</code>，也就是<code>Python 3.5+</code>的版本，所以可以尝试使用<code>pip</code>安装指定的版本。</strong></p><hr><h3 id="使用whl文件安装指定版本scipy"><a href="#使用whl文件安装指定版本scipy" class="headerlink" title="使用whl文件安装指定版本scipy"></a>使用whl文件安装指定版本scipy</h3><p>从<a href="https://github.com/scipy/scipy/releases" target="_blank" rel="noopener">github上scipy的release处</a>下载<code>1.2.2</code>版本的<code>scipy</code>的<code>whl</code>文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中的cp27就是python2.7的意思</span></span><br><span class="line">wget https://github.com/scipy/scipy/releases/download/v1.2.2/scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完成之后使用pip安装</span></span><br><span class="line">pip install scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl</span><br></pre></td></tr></table></figure><p></p><p><strong>再次出现报错</strong>，报错信息如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 报错信息</span></span><br><span class="line">scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br><span class="line">Storing debug <span class="built_in">log</span> <span class="keyword">for</span> failure <span class="keyword">in</span> /root/.pip/pip.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># log文件内容：</span></span><br><span class="line">cat /root/.pip/pip.log</span><br><span class="line">  ------------------------------------------------------------</span><br><span class="line">  /usr/bin/pip run on Tue Oct  8 09:03:00 2019</span><br><span class="line">  scipy-1.2.2-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br><span class="line">  Exception information:</span><br><span class="line">  Traceback (most recent call last):<span class="comment">#   File "/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/basecommand.py", line 122, in main</span></span><br><span class="line">      status = self.run(options, args)</span><br><span class="line">    File <span class="string">"/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/commands/install.py"</span>, line 257, <span class="keyword">in</span> run</span><br><span class="line">      InstallRequirement.from_line(name, None))</span><br><span class="line">    File <span class="string">"/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/req.py"</span>, line 167, <span class="keyword">in</span> from_line</span><br><span class="line">      raise UnsupportedWheel(<span class="string">"%s is not a supported wheel on this platform."</span> % wheel.filename)</span><br><span class="line">  UnsupportedWheel: scipy-1.2.2-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br></pre></td></tr></table></figure><p></p><p>报错信息提示说该whl文件不是一个目前系统支持的文件，然后我查看了该系统支持的文件信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统可以支持的版本</span></span><br><span class="line">&gt;&gt;&gt; import pip; <span class="built_in">print</span>(pip.pep425tags.get_supported())</span><br><span class="line">[(<span class="string">'cp27'</span>, <span class="string">'none'</span>, <span class="string">'linux_x86_64'</span>), (<span class="string">'cp27'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp2'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp26'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp25'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp24'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp23'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp22'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp21'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp20'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py27'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py2'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py26'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py25'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py24'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py23'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py22'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py21'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py20'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>)]</span><br></pre></td></tr></table></figure><p></p><p>通过前面命令发现下载的文件确实<strong>不是系统支持的</strong>，但是在<code>scipy</code>官网上也<strong>没找到完全符合上面信息的文件</strong>，但是<a href="https://stackoverflow.com/questions/28568070/filename-whl-is-not-supported-wheel-on-this-platform" target="_blank" rel="noopener">从这里</a>发现可以<strong>直接修改文件名称</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改名</span></span><br><span class="line">mv scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl scipy-1.2.2-cp27-none-linux_x86_64.whl</span><br><span class="line">pip install scipy-1.2.2-cp27-none-linux_x86_64.whl</span><br><span class="line"><span class="comment"># 还是报错：RuntimeError: Python version &gt;= 3.5 required.</span></span><br></pre></td></tr></table></figure><p></p><p>因为<strong>改名字在我看来确实不是一个很科学的做法</strong>，加上<strong>后续又报错了</strong>，所以就<strong>放弃了这个做法</strong>，转而使用下一个方法安装指定版本的scipy。</p><div class="note info"><p>关于<code>whl</code>文件：</p><ul><li>A Distribution format <strong>containing files and metadata that only need to be moved to the correct location on the target system, to be installed</strong>. Wheel is such a format, whereas distutil’s Source Distribution is not, in that it requires a build step before it can be installed. <strong>This format does not imply that Python files have to be precompiled (Wheel intentionally does not include compiled Python files)</strong>. <a href="https://packaging.python.org/glossary/#term-built-distribution" target="_blank" rel="noopener">参考链接</a></li><li><a href="https://fileinfo.com/extension/whl" target="_blank" rel="noopener">There are three types of WHL files</a>:<ul><li><code>Universal Wheel</code> - It <strong>only contains Python files</strong>, <strong>no compiled extensions</strong>, and <strong>natively supports Python 2 and 3</strong>.</li><li><code>Pure Python Wheel</code> - It <strong>only contains Python files and no compiled extensions</strong>, but does <strong>not natively support Python 2 and 3</strong>.</li><li><code>Platform Wheel</code> - It <strong>contains Python files and compiled extensions</strong> but does <strong>not natively support Python 2 and 3</strong>. This type of wheel is <strong>specific to a platform</strong>, such as Windows or macOS, because it contains compiled extensions.</li></ul></li></ul></div><hr><h3 id="使用pip安装指定版本的scipy"><a href="#使用pip安装指定版本的scipy" class="headerlink" title="使用pip安装指定版本的scipy"></a>使用pip安装指定版本的scipy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接安装指定版本的scipy</span></span><br><span class="line">pip install scipy==1.2.2</span><br><span class="line"><span class="comment"># 出现如下报错信息</span></span><br><span class="line">  Collecting numpy&gt;=1.8.2 (from scipy==1.2.2)</span><br><span class="line">  ERROR: multicoretsne 0.1 requires cffi, <span class="built_in">which</span> is not installed.</span><br><span class="line">  Installing collected packages: numpy, scipy</span><br><span class="line">    Found existing installation: numpy 1.7.1</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p>上述报错有两个方面，一是缺少<code>cffi</code>包，二是发现已经安装了<code>numpy</code>，并且版本是<code>1.7.1</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装cffi</span></span><br><span class="line">pip install cffi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行</span></span><br><span class="line">pip install scipy==1.2.2</span><br><span class="line"><span class="comment"># cffi的报错解决，numpy的问题依旧存在</span></span><br><span class="line">  Collecting numpy&gt;=1.8.2 (from scipy==1.2.2)</span><br><span class="line">  Installing collected packages: numpy, scipy</span><br><span class="line">    Found existing installation: numpy 1.7.1</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p></p><p>查看<code>numpy</code>版本以及更新或者卸载<code>numpy</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看numpy版本</span></span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt; numpy.__version__</span><br><span class="line"><span class="string">'1.7.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载numpy</span></span><br><span class="line">pip uninstall numpy</span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级numpy</span></span><br><span class="line">pip install --upgrade numpy</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p></p><p>上面尝试升级或者删除<code>numpy</code>包均报错，提示numpy是<code>distutils installed project</code>，所以不能进行卸载。</p><p>随后在<a href="https://stackoverflow.com/questions/50421287/pip-cannot-uninstall-ipython-it-is-a-distutils-installed-project-and-thus-w" target="_blank" rel="noopener">这篇文章</a>中发现，可以添加参数来忽略已经安装的numpy，从而进行下一版本的安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略已安装的版本</span></span><br><span class="line">pip install --ignore-installed -U numpy</span><br><span class="line"><span class="comment"># 可以安装numpy和scipy，但是在python中导入numpy模块的时候报错</span></span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/numpy/__init__.py"</span>, line 142, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from . import core</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/numpy/core/__init__.py"</span>, line 91, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raise ImportError(msg.format(path))</span><br><span class="line">ImportError: Something is wrong with the numpy installation. While importing we detected an older version of numpy <span class="keyword">in</span> [<span class="string">'/usr/lib64/python2.7/site-packages/numpy'</span>]. One method of fixing this is to repeatedly uninstall numpy until none is found, <span class="keyword">then</span> reinstall this version.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line"><span class="comment">## 进入安装目录：/usr/lib64/python2.7/site-packages</span></span><br><span class="line"><span class="comment">## 再次尝试导入numpy即可</span></span><br><span class="line">rm numpy-1.7.1-py2.7.egg-info</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>问题虽然解决了，但是仍然<strong>有一些疑惑需要解答</strong>：什么是<code>distutils installed project</code>，为什么不能通过<strong>pip升级和卸载</strong>？</p><blockquote><p>This error means that <strong>this package’s metadata doesn’t include a list of files that belong to it</strong>. Most probably, you have installed this package <code>via your OS&#39; package manager(比如apt、yum)</code>, so you need to use that <code>rather than pip to update or remove it, too</code>. <a href="https://stackoverflow.com/questions/53807511/pip-cannot-uninstall-package-it-is-a-distutils-installed-project" target="_blank" rel="noopener">参考链接</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了在&lt;code&gt;Python2.7&lt;/code&gt;环境下安装&lt;code&gt;scipy&lt;/code&gt;过程中遇到的一些问题以及爬坑过程(解决方案).&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="tricks" scheme="http://showteeth.tech/categories/Python/tricks/"/>
    
    
      <category term="tricks" scheme="http://showteeth.tech/tags/tricks/"/>
    
  </entry>
  
  <entry>
    <title>Python-实现字母和数字的混合排序</title>
    <link href="http://showteeth.tech/posts/10477.html"/>
    <id>http://showteeth.tech/posts/10477.html</id>
    <published>2019-09-28T04:03:37.000Z</published>
    <updated>2019-10-10T15:57:55.971Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>Python</code>对<strong>字母和数字混合的字符串</strong>进行排序的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际工作中经常会遇到需要将带有字母和数字的字符串进行混合排序，在linux中可以使用<a href="http://showteeth.tech/posts/61024.html">sort加上-V参数</a>轻松实现，但是在Python中并没有这种类似的参数，所以需要自己进行设置。</p><hr><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>Python脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将可以转化为数字的转化为数字</span></span><br><span class="line"><span class="comment"># 不可以转化的保留原始类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryint</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> int(s)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="comment"># 也可以使用</span></span><br><span class="line">    <span class="comment"># return int(s) if s.isdigit() else s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字母和数字分开</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alphanum_key</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">""" Turn a string into a list of string and number chunks.</span></span><br><span class="line"><span class="string">        "z23a" -&gt; ["z", 23, "a"]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> [ tryint(c) <span class="keyword">for</span> c <span class="keyword">in</span> re.split(<span class="string">'([0-9]+)'</span>, s) ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_nicely</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="string">""" Sort the given list in the way that humans expect.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 使用alphanum_key作为key进行排序</span></span><br><span class="line">    l.sort(key=alphanum_key)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alist=[</span><br><span class="line">    <span class="string">"something1"</span>,</span><br><span class="line">    <span class="string">"something12"</span>,</span><br><span class="line">    <span class="string">"something17"</span>,</span><br><span class="line">    <span class="string">"something2"</span>,</span><br><span class="line">    <span class="string">"something25"</span>,</span><br><span class="line">    <span class="string">"somethingM"</span>]</span><br><span class="line">alist.sort(key=alphanum_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">[<span class="string">'something1'</span>,</span><br><span class="line"> <span class="string">'something2'</span>,</span><br><span class="line"> <span class="string">'something12'</span>,</span><br><span class="line"> <span class="string">'something17'</span>,</span><br><span class="line"> <span class="string">'something25'</span>,</span><br><span class="line"> <span class="string">'somethingM'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://nedbatchelder.com/blog/200712/human_sorting.html" target="_blank" rel="noopener">Human sorting</a></li><li><a href="https://stackoverflow.com/questions/4836710/does-python-have-a-built-in-function-for-string-natural-sort" target="_blank" rel="noopener">Does Python have a built in function for string natural sort?</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录了使用&lt;code&gt;Python&lt;/code&gt;对&lt;strong&gt;字母和数字混合的字符串&lt;/strong&gt;进行排序的方法。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="tricks" scheme="http://showteeth.tech/categories/Python/tricks/"/>
    
    
      <category term="tricks" scheme="http://showteeth.tech/tags/tricks/"/>
    
      <category term="字符串" scheme="http://showteeth.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>YAML语言学习</title>
    <link href="http://showteeth.tech/posts/64657.html"/>
    <id>http://showteeth.tech/posts/64657.html</id>
    <published>2019-09-20T15:09:44.000Z</published>
    <updated>2019-09-28T02:40:26.563Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文依据<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a>结合<strong>python中对yaml的调用</strong>对<code>yaml</code>语言进行了学习，主要包括其<strong>语法</strong>和<strong>数据结构</strong>，为以后<strong>使用<code>yaml</code>编写配置文件</strong>打下基础。</p></div><a id="more"></a><h2 id="yaml简介"><a href="#yaml简介" class="headerlink" title="yaml简介"></a>yaml简介</h2><p>编程免不了要<strong>写配置文件</strong>，怎么写配置也是一门学问。<code>YAML</code> 是<strong>专门用来写配置文件的语言，非常简洁和强大</strong>，远比 <code>JSON</code> 格式方便。</p><p><code>YAML</code> 语言（发音 <code>/ˈjæməl/</code> ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p><p><code>YAML</code>的基本语法和规则如下：</p><ul><li><strong>大小写敏感</strong></li><li>使用<strong>缩进表示层级关系</strong></li><li><mark>缩进时不允许使用Tab键，只允许使用空格</mark></li><li>缩进的<strong>空格数目不重要</strong>，只要<strong>相同层级的元素左侧对齐即可</strong></li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p><code>YAML</code>支持的数据结构：</p><ul><li><code>对象</code>：<strong>键值对的集合</strong>，又称为<code>映射（mapping）</code>/ <code>哈希（hashes）</code> / <code>字典（dictionary）</code></li><li><code>数组</code>：一组按次序排列的值，又称为<code>序列（sequence）</code> / <code>列表（list）</code></li><li><code>纯量（scalars）</code>：单个的、不可再分的值</li></ul><p>以下分别介绍这三种数据结构。</p><hr><p><br></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="单层字典"><a href="#单层字典" class="headerlink" title="单层字典"></a>单层字典</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure><p>使用python进行解析：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.yaml'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = yaml.load(f)</span><br><span class="line"><span class="keyword">print</span> (data)</span><br></pre></td></tr></table></figure><p></p><p>解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典的形式</span></span><br><span class="line">&#123;<span class="string">'animal'</span>: <span class="string">'pets'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="嵌套字典"><a href="#嵌套字典" class="headerlink" title="嵌套字典"></a>嵌套字典</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">Steve</span></span><br><span class="line"><span class="attr">  foo:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套的字典</span></span><br><span class="line">&#123;<span class="string">'hash'</span>: &#123;<span class="string">'name'</span>: <span class="string">'Steve'</span>, <span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p></p><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">Steve,</span> <span class="attr">foo:</span> <span class="string">bar</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'hash'</span>: &#123;<span class="string">'name'</span>: <span class="string">'Steve'</span>, <span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>一组短横线开头的行，构成一个列表。</p><h3 id="单层列表"><a href="#单层列表" class="headerlink" title="单层列表"></a>单层列表</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析之后得到列表</span></span><br><span class="line">[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>短横线开头(不需要加任何标识)，然后空格缩进之后再添加短横线就可以得到嵌套列表：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Goldfish</span></span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p></p><p>python解析：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析得到嵌套列表</span></span><br><span class="line">[[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>], [<span class="string">'test'</span>]]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字典-列表"><a href="#字典-列表" class="headerlink" title="字典+列表"></a>字典+列表</h3><p>可以将字典和列表进行组合，达到以列表作为键值的字典的目的：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">[</span> <span class="string">'Cat'</span><span class="string">,</span> <span class="string">'Dog'</span> <span class="string">]</span> </span><br><span class="line"><span class="attr">fruit:</span> <span class="string">'apple'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析得到以列表作为键值的字典</span></span><br><span class="line">&#123;<span class="string">'animal'</span>: [<span class="string">'Cat'</span>, <span class="string">'Dog'</span>], <span class="string">'fruit'</span>: <span class="string">'apple'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line"><span class="attr"> Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span> </span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure><p>python解析的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'languages'</span>: [<span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span>], </span><br><span class="line">  <span class="string">'websites'</span>: &#123;<span class="string">'YAML'</span>: <span class="string">'yaml.org'</span>, <span class="string">'Ruby'</span>: <span class="string">'ruby-lang.org'</span>, <span class="string">'Python'</span>: <span class="string">'python.org'</span>, <span class="string">'Perl'</span>: <span class="string">'use.perl.org'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于python的纯量：</p><ul><li><strong>字符串</strong>：使用引号或者双引号</li><li><strong>布尔值</strong>：<code>true</code>、<code>false</code></li><li><strong>整数</strong></li><li><strong>浮点数</strong></li><li><strong>Null</strong>：使用<code>~</code>表示</li><li><strong>时间</strong></li><li><strong>日期</strong></li><li><strong>强制类型转换</strong>：使用<code>!!</code>加上需要转换的类型进行强制类型转换</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">b:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">c:</span> <span class="string">~</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">1976</span><span class="bullet">-07</span><span class="bullet">-31</span></span><br><span class="line"><span class="attr">e:</span> <span class="type">!!str</span> <span class="number">123</span></span><br><span class="line"><span class="attr">f:</span> <span class="type">!!str</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">g:</span> <span class="string">"g"</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'a'</span>: 0, </span><br><span class="line">  <span class="string">'b'</span>: True, </span><br><span class="line">  <span class="string">'c'</span>: None, </span><br><span class="line">  <span class="string">'date'</span>: datetime.date(1976, 7, 31), </span><br><span class="line">  <span class="string">'e'</span>: <span class="string">'123'</span>, </span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'true'</span>, </span><br><span class="line">  <span class="string">'g'</span>: <span class="string">'g'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是最常见，也是最复杂的一种数据类型，不使用引号、使用单引号、使用双引号都可以表示字符串。</p><h3 id="不使用引号"><a href="#不使用引号" class="headerlink" title="不使用引号"></a>不使用引号</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">num:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动识别数据类型</span></span><br><span class="line"><span class="comment"># 字符串解析为字符串</span></span><br><span class="line"><span class="comment"># 数字解析为数字</span></span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="string">'string'</span>, <span class="string">'num'</span>: 10&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用单引号"><a href="#使用单引号" class="headerlink" title="使用单引号"></a>使用单引号</h3><p>如果字符串之中包含空格或特殊字符，需要放在引号之中:<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="attr">a:b</span></span><br><span class="line"><span class="attr">s2:</span> <span class="string">'a:b'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然解析结果没有差异，但是添加引号更保险一些</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a:b'</span>, <span class="string">'s2'</span>: <span class="string">'a:b'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>使用单引号会对字符中的特殊符号进行转义</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号</span></span><br><span class="line"><span class="attr">s1:</span> <span class="string">'a\nb'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对字符中的\n进行了转义</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a\\nb'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用双引号"><a href="#使用双引号" class="headerlink" title="使用双引号"></a>使用双引号</h3><p>双引号和单引号的作用相同，但是与单引号相比，双引号不会对字符串中的特殊字符进行转义：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="string">'a\nb'</span></span><br><span class="line"><span class="attr">s2:</span> <span class="string">"a\nb"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号会对特殊字符进行转义</span></span><br><span class="line"><span class="comment"># 双引号会对特殊字符进行转义</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a\\nb'</span>, <span class="string">'s2'</span>: <span class="string">'a\nb'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="引号嵌套"><a href="#引号嵌套" class="headerlink" title="引号嵌套"></a>引号嵌套</h3><p>单引号中嵌套单引号，必须连续使用两个单引号转义：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号连用进行转义</span></span><br><span class="line"><span class="attr">str1:</span> <span class="string">'labor'</span><span class="string">'s day'</span></span><br><span class="line"><span class="comment"># 直接使用双引号包含单引号</span></span><br><span class="line"><span class="attr">str2:</span> <span class="string">"labor's day"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号转义和使用双引号包围解析的结果是相同的</span></span><br><span class="line">&#123;<span class="string">'str1'</span>: <span class="string">"labor's day"</span>, <span class="string">'str2'</span>: <span class="string">"labor's day"</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串换行"><a href="#字符串换行" class="headerlink" title="字符串换行"></a>字符串换行</h3><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进，<strong>换行符(<code>\n</code>)会被转为空格</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">longsting:</span> <span class="string">"this is long</span></span><br><span class="line"><span class="string"> string"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># long和string之间会出现一个换行符</span></span><br><span class="line">&#123;<span class="string">'longsting'</span>: <span class="string">'this is long string'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="保留和折叠换行符"><a href="#保留和折叠换行符" class="headerlink" title="保留和折叠换行符"></a>保留和折叠换行符</h3><p>多行字符串可以<strong>使用<code>|</code>保留换行符(<code>\n</code>)</strong>，也可以<strong>使用<code>&gt;</code>折叠换行符</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br><span class="line"><span class="string"># 折叠换行符</span></span><br><span class="line"><span class="string"></span><span class="attr">that:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留换行符和折叠换行符</span></span><br><span class="line">&#123;<span class="string">'this'</span>: <span class="string">'Foo\nBar\n'</span>, <span class="string">'that'</span>: <span class="string">'Foo Bar'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果遇到重复内容需要多次书写，可以使用引用的方式，具体做法是借助锚点&amp;和别名*:<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp;用来建立锚点（defaults）</span></span><br><span class="line"><span class="comment"># &lt;&lt;表示合并到当前数据</span></span><br><span class="line"><span class="comment"># *用来引用锚点</span></span><br><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'defaults'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>&#125;, </span><br><span class="line">  <span class="string">'development'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'database'</span>: <span class="string">'myapp_development'</span>&#125;, </span><br><span class="line">  <span class="string">'test'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'database'</span>: <span class="string">'myapp_test'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>列表中的示例</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="meta">&amp;showell</span> <span class="string">Steve</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Clark</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Brian</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Oren</span> </span><br><span class="line"><span class="bullet">-</span> <span class="meta">*showell</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span>]</span><br></pre></td></tr></table></figure><p></p><p>引用实现过程：</p><ul><li>先使用<code>&amp;</code>用来建立锚点，<code>&amp;+锚点名称</code></li><li>使用<code>*+锚点名称</code>用来引用锚点</li><li><code>&lt;&lt;</code>表示合并到当前数据</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文依据&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/07/yaml.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YAML 语言教程&lt;/a&gt;结合&lt;strong&gt;python中对yaml的调用&lt;/strong&gt;对&lt;code&gt;yaml&lt;/code&gt;语言进行了学习，主要包括其&lt;strong&gt;语法&lt;/strong&gt;和&lt;strong&gt;数据结构&lt;/strong&gt;，为以后&lt;strong&gt;使用&lt;code&gt;yaml&lt;/code&gt;编写配置文件&lt;/strong&gt;打下基础。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="YAML" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/YAML/"/>
    
    
      <category term="YAML" scheme="http://showteeth.tech/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之文件的MD5校验</title>
    <link href="http://showteeth.tech/posts/60644.html"/>
    <id>http://showteeth.tech/posts/60644.html</id>
    <published>2019-09-06T13:28:43.000Z</published>
    <updated>2019-09-06T15:48:45.497Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中对文件完整性进行验证的命令<code>md5sum</code>，该命令可以<strong>对指定的文件生成MD5值</strong>，也可以<strong>根据已有的MD5值对文件进行完整性校验</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在学习和研究过程中，经常会从公司拿到很多数据，连同数据一起的还有md5文件；在数据传输和下载过程中，难免会遇到数据缺失的情况，所以得到数据后对数据进行校验非常重要。</p><h2 id="md5sum命令"><a href="#md5sum命令" class="headerlink" title="md5sum命令"></a>md5sum命令</h2><p><code>md5sum</code>命令用于<strong>生成文件的md5数字摘要</strong>，并<strong>可以验证文件内容是否发生了改变</strong>，间接地还可以检验两个文件内容是否完全相同。因为<code>md5sum</code>是读取文件内容来计算校验码的，因此<strong>只能验证文件内容，而无法验证文件属性</strong>，所以只要文件内容没有发生变化，<code>md5sum</code>命令都会将其判定为相同的文件。</p><h3 id="生成md5值"><a href="#生成md5值" class="headerlink" title="生成md5值"></a>生成md5值</h3><p>需要注意的是，如果<code>md5sum</code>命令后的文件使用的是<strong>相对路径</strong>，那么生成的<strong>md5值中的文件信息就是相对路径</strong>，而如果文件使用的是<strong>绝对路径</strong>，<strong>生成的md5值中的文件信息就是绝对路径</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum后的文件路径是相对路径</span></span><br><span class="line">md5sum test.sh</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  test.sh</span><br><span class="line"><span class="comment"># md5sum后的文件路径是绝对路径</span></span><br><span class="line">md5sum /home/user/learn/linux_learn/variable/test.sh</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  /home/user/learn/linux_learn/variable/test.sh</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看文件是否修改"><a href="#查看文件是否修改" class="headerlink" title="查看文件是否修改"></a>查看文件是否修改</h3><p>可以<strong>使用<code>md5sum -c</code>结合md5信息文件来判断文件是否完整</strong>，注意：<strong>这个检查是内容上的，权限和属性等的改变不会影响md5值，所以不会检测出问题</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c test.md5</span><br><span class="line">  test.sh: OK</span><br></pre></td></tr></table></figure><p></p><p><strong>md5文件中存储的文件路径必须要是正确</strong>的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 储存的md5值以及文件相对路径</span></span><br><span class="line">cat test.md5</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件相对路径发生变化，或者名称被修改</span></span><br><span class="line">mv test.sh test_old.sh</span><br><span class="line"></span><br><span class="line">md5sum -c test.md5</span><br><span class="line">  md5sum: test.sh: No such file or directory</span><br><span class="line">  test.sh: FAILED open or <span class="built_in">read</span></span><br><span class="line">  md5sum: WARNING: 1 listed file could not be <span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件内容被修改</span></span><br><span class="line">md5sum -c test.md5</span><br><span class="line">  test.sh: FAILED</span><br><span class="line">  md5sum: WARNING: 1 computed checksum did NOT match</span><br></pre></td></tr></table></figure><p></p><p>当使用了<code>-c</code>选项时，还支持以下选项：</p><ul><li><code>--quiet</code>：<strong>不显示验证结果为OK的记录</strong>；</li><li><code>--status</code>：<strong>完全不显示任何信息</strong>，只能通过命令的退出状态码判断验证结果是否有failed；<strong>只要有一条failed记录，则状态码为1，否则为0。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5sum --status -c test.md5</span><br><span class="line"><span class="comment"># 使用$?来获取最后运行的命令的结束代码</span></span><br><span class="line"><span class="comment"># 正常运行的命令结束代码为0，出错或者出现异常结束代码不为0</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7430264.html" target="_blank" rel="noopener">Linux中文件MD5校验</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中对文件完整性进行验证的命令&lt;code&gt;md5sum&lt;/code&gt;，该命令可以&lt;strong&gt;对指定的文件生成MD5值&lt;/strong&gt;，也可以&lt;strong&gt;根据已有的MD5值对文件进行完整性校验&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之Shell子进程以及何时进入子Shell</title>
    <link href="http://showteeth.tech/posts/36597.html"/>
    <id>http://showteeth.tech/posts/36597.html</id>
    <published>2019-09-06T07:56:49.000Z</published>
    <updated>2019-09-06T13:23:52.277Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章基于<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">子shell以及什么时候进入子shell</a>进行了学习和整理，学习了<strong>Shell的子进程</strong>以及列举了几种<strong>不产生</strong>和<strong>产生Shell子进程</strong>的场景。同时，这篇文章也是对<a href="http://showteeth.tech/posts/16586.html">关于Linux中脚本执行方式</a>以及<a href="http://showteeth.tech/posts/52906.html">全局变量、局部变量和环境变量</a>两篇文章的内容的补充和参考。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前学习的<a href="http://showteeth.tech/posts/16586.html">关于Linux中脚本执行方式</a>以及<a href="http://showteeth.tech/posts/52906.html">全局变量、局部变量和环境变量</a>中都有提到Shell进程以及如何进入Shell子进程，但是了解不够全面，恰巧读到<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">这篇文章</a>，发现讲解非常详细，所以这里主要是基于<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">这篇文章</a>的学习笔记，大部分都是与原封不动copy下来的。</p><hr><h2 id="子Shell简介"><a href="#子Shell简介" class="headerlink" title="子Shell简介"></a>子Shell简介</h2><p>子shell的概念贯穿整个shell，写shell脚本时更是不可不知。所谓<strong>子shell</strong>，即<strong>从当前shell环境新开一个shell环境</strong>，这个新开的shell环境就称为子shell(subshell)，而<strong>开启子shell的环境称为该子shell的父shell</strong>。子shell和父shell的关系其实就是子进程和父进程的关系，只不过子shell和父shell所关联的进程是bash进程。</p><p>子shell会从父shell中<strong>继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等</strong>，但<strong>子shell有很多种类型，不同类型的子shell继承的环境不相同</strong>。可以使用<code>$BASH_SUBSHELL</code>变量来<strong>查看从当前进程开始的子shell层数</strong>，<code>$BASHPID</code>查看<strong>当前所处BASH的PID</strong>，<mark>这不同于特殊变量<code>$$</code>值，因为<code>$$</code>在大多数情况下都会从父shell中继承</mark>。</p><hr><h2 id="何时产生子Shell"><a href="#何时产生子Shell" class="headerlink" title="何时产生子Shell"></a>何时产生子Shell</h2><p>要解释清楚子shell以及产生何种类型的子shell，需要搞清楚Linux中如何产生子进程。Linux上<strong>创建子进程的方式有三种</strong>：</p><ul><li>一种是<code>fork</code>出来的进程。它会复制当前进程的副本(不考虑写时复制的模式)，以适当的方式将这些资源交给子进程；所以<strong>子进程掌握的资源和父进程是一样的，包括内存中的内容，所以也包括环境变量和变量</strong>；但父子进程是完全独立的，它们是一个程序的两个实例。</li><li>一种是<code>exec</code>出来的进程。<code>exec</code>是加载另一个应用程序，替代当前运行的进程，也就是说在不创建新进程的情况下加载一个新程序；<code>exec</code>还有一个动作：在进程执行完毕后，退出<code>exec</code>所在的shell环境。</li><li>一种是<code>clone</code>出来的进程。此处无需关心<code>clone</code>，因为它用来实现Linux中的线程。</li></ul><p>所以为了保证进程安全，若要形成新的且独立的子进程，都会先<code>fork</code>一份当前进程，然后在<code>fork</code>出来的子进程上调用<code>exec</code>来加载新程序替代该子进程。例如<strong>在bash下执行cp命令，会先fork出一个bash，然后再exec加载cp程序覆盖子bash进程变成cp进程。</strong></p><p>再来说明子shell的问题。一般<code>fork</code>出来的子进程，内容和父进程是一样的(包括变量)，例如执行<code>cp</code>命令时也能获取到父进程的变量；但是<code>cp</code>命令在哪里执行呢？执行<code>cp</code>命令敲入回车后，当前的bash进程<code>fork</code>出一个<strong>子bash</strong>，然后<strong>子bash</strong>通过<code>exec</code>加载<code>cp</code>程序<strong>替代子bash</strong>。这算是进入了<strong>子shell</strong>吗？更通用的问题是：<strong>什么情况下会进入子shell环境，什么时候不进入子shel环境呢？</strong></p><p>判断是否进入了子shell的方式非常简单，执行<code>echo $BASHPID</code>，如果该值和父bash进程的pid值不同，则表示进入了子shell。</p><h3 id="不产生子Shell"><a href="#不产生子Shell" class="headerlink" title="不产生子Shell"></a>不产生子Shell</h3><h4 id="执行bash内置命令"><a href="#执行bash内置命令" class="headerlink" title="执行bash内置命令"></a>执行bash内置命令</h4><p>bash内置命令是非常特殊的，<strong>父进程不会创建子进程来执行这些命令</strong>，而是直接<strong>在当前bash环境中执行</strong>。但如果<strong>将内置命令放在管道后，就会创建子shell</strong>。关于Linux中的内置命令，可以查看<a href="#%e8%a1%a5%e5%85%85-linux%e5%86%85%e7%bd%ae%e5%91%bd%e4%bb%a4">这部分</a>。</p><p>内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span>   </span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># let命令为bash内置命令，不进入子shell</span></span><br><span class="line"><span class="built_in">let</span> a=<span class="variable">$BASHPID</span>   </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">  65230</span><br></pre></td></tr></table></figure><p></p><p>管道结合内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 增加管道后看看ID</span></span><br><span class="line"><span class="comment"># 发现这里虽然使用了内置命令，但是依然创建了子Shell</span></span><br><span class="line">ls |<span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  28580</span><br></pre></td></tr></table></figure><p></p><p>这时候的<strong>子shell的作用</strong>是为bash内置命令提供执行环境。</p><hr><h4 id="执行shell函数"><a href="#执行shell函数" class="headerlink" title="执行shell函数"></a>执行shell函数</h4><p>其实shell函数就是命令，它和bash内置命令的情况一样，直接执行时不会进入子shell，但放在管道后会进入子shell：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数，输出ID</span></span><br><span class="line"><span class="function"><span class="title">fun_test</span></span> ()&#123; <span class="built_in">echo</span> <span class="variable">$BASHPID</span>; &#125;</span><br><span class="line"><span class="comment"># 输出当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 执行函数，输出Shell的ID</span></span><br><span class="line">fun_test </span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 加入管道</span></span><br><span class="line">ls |fun_test </span><br><span class="line">  30637</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="产生子Shell"><a href="#产生子Shell" class="headerlink" title="产生子Shell"></a>产生子Shell</h3><h4 id="执行bash命令本身"><a href="#执行bash命令本身" class="headerlink" title="执行bash命令本身"></a>执行bash命令本身</h4><p>显然它<strong>会进入子shell环境</strong>，它的<strong>绝大多数环境都是新配置的</strong>，因为<strong>会加载一些环境配置文件</strong>。<mark>事实上<code>fork</code>出来的bash子进程内容完全继承父shell，但因<strong>重新加载了环境配置项</strong>，所以<strong>子shell没有继承普通变量</strong>，更准确的说是<strong>覆盖</strong>了从父shell中继承的变量</mark>。不妨试试在<code>/etc/bashrc</code>文件中定义一个变量，再在父shell中<code>export</code>名称相同值却不同的环境变量，然后到子shell中看看该变量的值为何？<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"var=55"</span> &gt;&gt;/etc/bashrc</span><br><span class="line"><span class="built_in">export</span> var=66</span><br><span class="line"><span class="comment"># 进入子Shell</span></span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">  55</span><br></pre></td></tr></table></figure><p></p><p>由结果55可知，执行bash时加载的<code>/etc/bashrc</code>中的变量<strong>覆盖</strong>了父bash中的导出的环境变量值66。</p><p>使用<code>exit</code>命令退出当前子Shell：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 执行bash命令</span></span><br><span class="line">bash</span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  29075</span><br><span class="line"><span class="comment"># 使用exit退出当前子Shell</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>变量<code>$$</code>不会被继承：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 使用bash进入子Shell</span></span><br><span class="line">bash</span><br><span class="line"><span class="comment"># 查看bash进入的子Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  32310</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="执行Shell脚本"><a href="#执行Shell脚本" class="headerlink" title="执行Shell脚本"></a>执行Shell脚本</h4><p>这里的执行Shell脚本是<a href="http://showteeth.tech/posts/16586.html">这篇文章</a>中<strong>作为可执行程序</strong>、<strong>作为解释器参数</strong>进行的执行，而不是<strong>source方式执行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  29479</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> </span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>可以发现：执行shell脚本相比于直接执行bash命令，还多了一个动作——<strong>脚本执行完毕后自动退出子shell</strong>。</p><p>变量<code>$$</code>不会被继承：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line">cat test_run.sh</span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  32477</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="执行非bash内置命令"><a href="#执行非bash内置命令" class="headerlink" title="执行非bash内置命令"></a>执行非bash内置命令</h4><p>例如执行<code>cp</code>命令、<code>grep</code>命令等，它们直接<code>fork</code>一份bash进程，然后使用<code>exec</code>加载程序替代该子bash。此类子进程<strong>会继承所有父bash的环境</strong>。但<strong>严格地说，这已经不是子shell</strong>，因为<code>exec</code>加载的程序已经把子bash进程替换掉了，这意味着丢失了很多bash环境。在bash文档中，直接<strong>称呼这种环境为”单独的环境”，和子shell的概念类似。</strong></p><hr><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p><strong>当命令行中包含了命令替换部分时，将开启一个子shell先执行这部分内容，再将执行结果返回给当前命令</strong>。因为这次的子shell<strong>不是通过bash命令</strong>进入的子shell，所以它<strong>会继承父shell的所有变量内容</strong>。这也就解释了<code>echo $(echo $$)</code>中<code>$$</code>的结果是当前bash(父Shell)的pid号，而不是子shell的pid号，但<code>echo $(echo $BASHPID)</code>却和父bash进程的pid不同，因为它不是使用bash命令进入的子shell:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$$查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$BASHPID查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令替换，使用$BASHPID查看命令替换得到的子Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  31157</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令替换，使用$$测试命令替换是不是继承了父Shell的$$变量</span></span><br><span class="line"><span class="comment"># 发现使用命令替换会继承父Shell的$$变量</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过bash命令进入子Shell</span></span><br><span class="line"><span class="comment"># 发现并没有继承父Shell的$$变量</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  31232</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="使用括号-组合一系列命令"><a href="#使用括号-组合一系列命令" class="headerlink" title="使用括号()组合一系列命令"></a>使用括号()组合一系列命令</h4><p>例如<code>(ls;date;echo haha)</code>，独立的括号将会<strong>开启一个子shell来执行括号内的命令</strong>，这种情况等同于上述<a href="#%e6%89%a7%e8%a1%8c%e9%9d%9ebash%e5%86%85%e7%bd%ae%e5%91%bd%e4%bb%a4%e6%97%b6">执行非bash内置命令</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看括号组合的命令的Shell ID </span></span><br><span class="line">(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  31804</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line">(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="放入后台的任务"><a href="#放入后台的任务" class="headerlink" title="放入后台的任务"></a>放入后台的任务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 查看放入后台命令运行的Shell ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> &amp;</span><br><span class="line">  [1] 32030</span><br><span class="line">  32030</span><br></pre></td></tr></table></figure><p>变量<code>$$</code>会被继承:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line"><span class="built_in">echo</span> $$ &amp;</span><br><span class="line">  [1] 316</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>既然是新进程了，当然进入子shell执行，例如<code>cat &lt;(echo haha)</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 进程替换，进入子Shell</span></span><br><span class="line">cat &lt;(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  32181</span><br></pre></td></tr></table></figure><p></p><p>变量<code>$$</code>会被继承:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line">cat &lt;(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>关于<code>$$</code>变量的继承：除了<strong>直接执行bash命令</strong>和<strong>shell脚本这两种子shell</strong>，<strong>其他进入子shell的情况都会继承父shell的值</strong>。前面也已经说了，其实shell脚本和直接执行bash命令开启子shell的方式是一样的，它们<strong>都不会继承<code>$$</code>值</strong>，上面对应的部分已经做过了验证。</li><li>子shell的环境设置不会粘滞到父shell环境，无论是使用<code>export</code>还是<code>source</code>，环境设置都只能从父shell到子shell，不是也不会是从子shell到父shell。也就是说<strong>子shell的变量等不会影响父shell</strong>。</li></ul><hr><p><br></p><h2 id="补充-Linux内置命令"><a href="#补充-Linux内置命令" class="headerlink" title="补充-Linux内置命令"></a>补充-Linux内置命令</h2><p>通常来说，<strong>内置命令会比外部命令执行得更快</strong>，执行外部命令时不但会<strong>触发磁盘 I/O</strong>，还需要 <code>fork</code> 出一个单独的进程来执行，执行完成后再退出。而<strong>执行内建命令相当于调用当前 Shell 进程的一个函数。</strong></p><h3 id="判断命令是不是内置命令"><a href="#判断命令是不是内置命令" class="headerlink" title="判断命令是不是内置命令"></a>判断命令是不是内置命令</h3><p>type命令可以判断命令是不是内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd命令是内置命令</span></span><br><span class="line"><span class="comment"># 返回为builtin</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span></span><br><span class="line">  <span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp不是内置命令</span></span><br><span class="line"><span class="comment"># cp不是内置命令，其路径为/usr/bin/cp</span></span><br><span class="line"><span class="built_in">type</span> cp</span><br><span class="line">  cp is /usr/bin/cp</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看内置命令帮助"><a href="#查看内置命令帮助" class="headerlink" title="查看内置命令帮助"></a>查看内置命令帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> | less</span><br><span class="line">  GNU bash, version 4.2.46(2)-release (x86_64-redhat-linux-gnu)</span><br><span class="line">  These shell commands are defined internally.  Type `<span class="built_in">help</span><span class="string">' to see this list.</span></span><br><span class="line"><span class="string">  Type `help name'</span> to find out more about the <span class="keyword">function</span> `name<span class="string">'.</span></span><br><span class="line"><span class="string">  Use `info bash'</span> to find out more about the shell <span class="keyword">in</span> general.</span><br><span class="line">  Use `man -k<span class="string">' or `info'</span> to find out more about commands not <span class="keyword">in</span> this list.</span><br><span class="line"></span><br><span class="line">  A star (*) next to a name means that the <span class="built_in">command</span> is disabled.</span><br><span class="line"></span><br><span class="line">  job_spec [&amp;]                                                 <span class="built_in">history</span> [-c] [-d offset] [n] or <span class="built_in">history</span> -anrw [filename] &gt;</span><br><span class="line">  (( expression ))                                             <span class="keyword">if</span> COMMANDS; <span class="keyword">then</span> COMMANDS; [ <span class="keyword">elif</span> COMMANDS; <span class="keyword">then</span> COMMAND&gt;</span><br><span class="line">  . filename [arguments]                                       <span class="built_in">jobs</span> [-lnprs] [jobspec ...] or <span class="built_in">jobs</span> -x <span class="built_in">command</span> [args]</span><br><span class="line">  :                                                            <span class="built_in">kill</span> [-s sigspec | -n signum | -sigspec] pid | jobspec ..&gt;</span><br><span class="line">  [ arg... ]                                                   <span class="built_in">let</span> arg [arg ...]</span><br></pre></td></tr></table></figure><hr><h3 id="内置命令列表"><a href="#内置命令列表" class="headerlink" title="内置命令列表"></a>内置命令列表</h3><table><caption>Bash Shell 内建命令</caption><tbody><tr><th width="10%">命令</th><th width="90%">说明</th></tr><tr><td>:</td><td>扩展参数列表，执行重定向操作</td></tr><tr><td>.</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>alias</td><td>为指定命令定义一个别名</td></tr><tr><td>bg</td><td>将作业以后台模式运行</td></tr><tr><td>bind</td><td>将键盘序列绑定到一个 readline 函数或宏</td></tr><tr><td>break</td><td>退出 for、while、select 或 until 循环</td></tr><tr><td>builtin</td><td>执行指定的 shell 内建命令</td></tr><tr><td>caller</td><td>返回活动子函数调用的上下文</td></tr><tr><td>cd</td><td>将当前目录切换为指定的目录</td></tr><tr><td>command</td><td>执行指定的命令，无需进行通常的 shell 查找</td></tr><tr><td>compgen</td><td>为指定单词生成可能的补全匹配</td></tr><tr><td>complete</td><td>显示指定的单词是如何补全的</td></tr><tr><td>compopt</td><td>修改指定单词的补全选项</td></tr><tr><td>continue</td><td>继续执行 for、while、select 或 until 循环的下一次迭代</td></tr><tr><td>declare</td><td>声明一个变量或变量类型。</td></tr><tr><td>dirs</td><td>显示当前存储目录的列表</td></tr><tr><td>disown</td><td>从进程作业表中刪除指定的作业</td></tr><tr><td>echo</td><td>将指定字符串输出到 STDOUT</td></tr><tr><td>enable</td><td>启用或禁用指定的内建shell命令</td></tr><tr><td>eval</td><td>将指定的参数拼接成一个命令，然后执行该命令</td></tr><tr><td>exec</td><td>用指定命令替换 shell 进程</td></tr><tr><td>exit</td><td>强制 shell 以指定的退出状态码退出</td></tr><tr><td>export</td><td>设置子 shell 进程可用的变量</td></tr><tr><td>fc</td><td>从历史记录中选择命令列表</td></tr><tr><td>fg</td><td>将作业以前台模式运行</td></tr><tr><td>getopts</td><td>分析指定的位置参数</td></tr><tr><td>hash</td><td>查找并记住指定命令的全路径名</td></tr><tr><td>help</td><td>显示帮助文件</td></tr><tr><td>history</td><td>显示命令历史记录</td></tr><tr><td>jobs</td><td>列出活动作业</td></tr><tr><td>kill</td><td>向指定的进程 ID(PID) 发送一个系统信号</td></tr><tr><td>let</td><td>计算一个数学表达式中的每个参数</td></tr><tr><td>local</td><td>在函数中创建一个作用域受限的变量</td></tr><tr><td>logout</td><td>退出登录 shell</td></tr><tr><td>mapfile</td><td>从 STDIN 读取数据行，并将其加入索引数组</td></tr><tr><td>popd</td><td>从目录栈中删除记录</td></tr><tr><td>printf</td><td>使用格式化字符串显示文本</td></tr><tr><td>pushd</td><td>向目录栈添加一个目录</td></tr><tr><td>pwd</td><td>显示当前工作目录的路径名</td></tr><tr><td>read</td><td>从 STDIN 读取一行数据并将其赋给一个变量</td></tr><tr><td>readarray</td><td>从 STDIN 读取数据行并将其放入索引数组</td></tr><tr><td>readonly</td><td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td></tr><tr><td>return</td><td>强制函数以某个值退出，这个值可以被调用脚本提取</td></tr><tr><td>set</td><td>设置并显示环境变量的值和 shell 属性</td></tr><tr><td>shift</td><td>将位置参数依次向下降一个位置</td></tr><tr><td>shopt</td><td>打开/关闭控制 shell 可选行为的变量值</td></tr><tr><td>source</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>suspend</td><td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td></tr><tr><td>test</td><td>基于指定条件返回退出状态码 0 或 1</td></tr><tr><td>times</td><td>显示累计的用户和系统时间</td></tr><tr><td>trap</td><td>如果收到了指定的系统信号，执行指定的命令</td></tr><tr><td>type</td><td>显示指定的单词如果作为命令将会如何被解释</td></tr><tr><td>typeset</td><td>声明一个变量或变量类型。</td></tr><tr><td>ulimit</td><td>为系统用户设置指定的资源的上限</td></tr><tr><td>umask</td><td>为新建的文件和目录设置默认权限</td></tr><tr><td>unalias</td><td>刪除指定的别名</td></tr><tr><td>unset</td><td>刪除指定的环境变量或 shell 属性</td></tr><tr><td>wait</td><td>等待指定的进程完成，并返回退出状态码</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">子shell以及什么时候进入子shell</a></li><li><a href="https://linux.cn/article-9343-1.html" target="_blank" rel="noopener">如何列出所有的 Bash Shell 内置命令</a></li><li><a href="http://c.biancheng.net/view/1136.html" target="_blank" rel="noopener">Shell内建命令（内置命令）</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章基于&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7446194.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子shell以及什么时候进入子shell&lt;/a&gt;进行了学习和整理，学习了&lt;strong&gt;Shell的子进程&lt;/strong&gt;以及列举了几种&lt;strong&gt;不产生&lt;/strong&gt;和&lt;strong&gt;产生Shell子进程&lt;/strong&gt;的场景。同时，这篇文章也是对&lt;a href=&quot;http://showteeth.tech/posts/16586.html&quot;&gt;关于Linux中脚本执行方式&lt;/a&gt;以及&lt;a href=&quot;http://showteeth.tech/posts/52906.html&quot;&gt;全局变量、局部变量和环境变量&lt;/a&gt;两篇文章的内容的补充和参考。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之文件目录操作</title>
    <link href="http://showteeth.tech/posts/49759.html"/>
    <id>http://showteeth.tech/posts/49759.html</id>
    <published>2019-09-05T13:26:13.000Z</published>
    <updated>2019-09-05T16:00:01.634Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>R中文件目录相关操作</strong>，主要包括：<code>查看和设置工作路径</code>、<code>查看文件或目录是否存在</code>、<code>列出目录下文件或目录</code>、<code>新建文件或目录</code>、<code>复制文件或目录</code>、<code>删除文件或目录</code>、<code>重命名文件或目录</code>。</p></div><a id="more"></a><h2 id="工作路径"><a href="#工作路径" class="headerlink" title="工作路径"></a>工作路径</h2><p>设置工作路径：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置工作路径为path/to/your/workdir</span></span><br><span class="line">setwd(<span class="string">'path/to/your/workdir'</span>)</span><br></pre></td></tr></table></figure><p></p><p>得到当前工作路径：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到当前的工作路径</span></span><br><span class="line">getwd()</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="查看文件-目录-是否存在"><a href="#查看文件-目录-是否存在" class="headerlink" title="查看文件(目录)是否存在"></a>查看文件(目录)是否存在</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个函数都可以用于查看文件(目录)是否存在</span></span><br><span class="line">dir.exists(paths)</span><br><span class="line">file.exists(paths)</span><br></pre></td></tr></table></figure><p>参数<code>paths</code>可以是<code>vector</code>，即可以<strong>批量查看文件（目录）是否存在</strong></p><hr><p><br></p><h2 id="列出目录下文件-目录"><a href="#列出目录下文件-目录" class="headerlink" title="列出目录下文件(目录)"></a>列出目录下文件(目录)</h2><ul><li>函数<code>list.files</code>和<code>dir</code>用法<strong>完全一样</strong>，可以<strong>列出路径下所有文件（包括目录）</strong>；</li><li>函数<code>list.dirs</code>只列出路径下<strong>所有目录</strong></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录下所有文件和目录</span></span><br><span class="line">list.files(path = <span class="string">"."</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">       dir(path = <span class="string">"."</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目录下的所有目录</span></span><br><span class="line">list.dirs(path = <span class="string">"."</span>, full.names = <span class="literal">TRUE</span>, recursive = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>path</code>：路径，如不填则<strong>默认为当前工作路径</strong>，即<code>getwd()</code>得到的路径；</li><li><code>pattern</code>：<strong>正则表达式</strong>，若pattern不为NULL，返回文件（目录）名满足该正则表达式的文件（目录）；</li><li><code>all.files</code>：若为<code>FALSE</code>则<strong>不显示隐藏文件（目录）</strong>，若为<code>TRUE</code>则返回所有文件（目录）；</li><li><code>full.names</code>：若为<code>FALSE</code>则<strong>只返回文件（目录）名</strong>，若为<code>TRUE</code>则返回<strong>文件（目录）路径</strong>；</li><li><code>recursive</code>：若为<code>FALSE</code>则<strong>只返回该路径的子级文件（目录）</strong>，若为<code>TRUE</code>则返回<strong>所有子、孙文件（目录）</strong>；</li><li><code>ignore.case</code>：若为<code>TRUE</code>则在匹配pattern时<strong>不区分大小写</strong>；</li><li><code>include.dirs</code>：在<code>recursive</code>为<code>TURE</code>，即显示所有子、孙文件时，若<code>include.dirs</code>为<code>FALSE</code>则只列出最终端的文件名，而不列出中间层级的目录名；</li><li><code>no..</code>：若为<code>TRUE</code>，则不显示<code>.</code>和<code>..</code>。</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; list.files(recursive=<span class="literal">TRUE</span>,include.dirs=<span class="literal">FALSE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"filtered_feature_bc_matrix/barcodes.tsv.gz"</span> <span class="string">"filtered_feature_bc_matrix/features.tsv.gz"</span></span><br><span class="line">[<span class="number">3</span>] <span class="string">"filtered_feature_bc_matrix/matrix.mtx.gz"</span>   <span class="string">"npas4l.pdf"</span>                                </span><br><span class="line">[<span class="number">5</span>] <span class="string">"top_zebrafish_cluster_markers.csv"</span>          <span class="string">"zebrafish_cluster_markers.csv"</span>             </span><br><span class="line">[<span class="number">7</span>] <span class="string">"zebrafish_first.rds"</span>                  </span><br><span class="line"></span><br><span class="line"><span class="comment"># include.dirs=TRUE时多出"filtered_feature_bc_matrix" 中间文件夹</span></span><br><span class="line">&gt; list.files(recursive=<span class="literal">TRUE</span>,include.dirs=<span class="literal">TRUE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"filtered_feature_bc_matrix"</span>                 <span class="string">"filtered_feature_bc_matrix/barcodes.tsv.gz"</span></span><br><span class="line">[<span class="number">3</span>] <span class="string">"filtered_feature_bc_matrix/features.tsv.gz"</span> <span class="string">"filtered_feature_bc_matrix/matrix.mtx.gz"</span>  </span><br><span class="line">[<span class="number">5</span>] <span class="string">"npas4l.pdf"</span>                                 <span class="string">"top_zebrafish_cluster_markers.csv"</span>         </span><br><span class="line">[<span class="number">7</span>] <span class="string">"zebrafish_cluster_markers.csv"</span>              <span class="string">"zebrafish_first.rds"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="新建文件-目录"><a href="#新建文件-目录" class="headerlink" title="新建文件(目录)"></a>新建文件(目录)</h2><p>函数<code>file.create</code>用于新建文件，<code>dir.create</code>用于新建目录：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">file.create(<span class="keyword">...</span>, showWarnings = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment"># 新建目录</span></span><br><span class="line">dir.create(path, showWarnings = <span class="literal">TRUE</span>, recursive = <span class="literal">FALSE</span>,mode = <span class="string">"0777"</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>函数默认<code>recursive</code>为<code>FALSE</code>，即<strong>只新建path中的第一级子目录</strong>，而当<code>recursive</code>为<code>TRUE</code>时可以<strong>新建多级子目录</strong>；</li><li>当目录<strong>已存在时不会新建目录覆盖原先的目录</strong>，此时如果<code>showWarnings</code>为<code>TRUE</code>，则会<strong>提醒</strong>该目录已存在，为<code>FALSE</code>时不会提醒；</li></ul><hr><p><br></p><h2 id="复制文件-目录"><a href="#复制文件-目录" class="headerlink" title="复制文件(目录)"></a>复制文件(目录)</h2><p>函数<code>file.copy</code>用于复制文件(目录)：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.copy(from, to, overwrite = recursive, recursive = <span class="literal">FALSE</span>,copy.mode = <span class="literal">TRUE</span>, copy.date = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>from</code>是<strong>原始文件（目录）名</strong>，<code>to</code>是<strong>新文件（目录）名</strong>，二者可以是vector，但是长度需相同；</li><li><code>overwrite</code> 若为<code>TRUE</code>，则<strong>文件被覆盖</strong>；</li><li><code>recursive</code> <strong>复制目录时recursive需为TRUE</strong>；</li><li><code>copy.mode</code>若为<code>TRUE</code>，<code>permission bits</code>一并复制过来；</li><li><code>copy.date</code>若为<code>TRUE</code>，文件<strong>日期一并复制过来</strong>。</li></ul><hr><p><br></p><h2 id="删除文件-目录"><a href="#删除文件-目录" class="headerlink" title="删除文件(目录)"></a>删除文件(目录)</h2><p>函数<code>unlink</code>可以用来删除<strong>文件或目录</strong>，函数<code>file.remove</code>可以用来删除<strong>文件</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(x, recursive = <span class="literal">FALSE</span>, force = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>x</code>是要删除的文件或目录，可以是<code>vector（即批量删除）</code>；</li><li>当<strong>删除目录</strong>时，<code>recursive</code>应为<code>TRUE</code>，表示目录内文件一并删除。</li></ul><hr><p><br></p><h2 id="重命名文件-目录"><a href="#重命名文件-目录" class="headerlink" title="重命名文件(目录)"></a>重命名文件(目录)</h2><p>函数<code>file.rename</code>用于重命名：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.rename(from, to)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>from</code>是<strong>原始文件（目录）名</strong>，<code>to</code>是<strong>新文件（目录）名</strong>，二者可以是<code>vector</code>，但是<code>长度需相同</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.omicsclass.com/article/338" target="_blank" rel="noopener">R语言文件目录操作</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了&lt;strong&gt;R中文件目录相关操作&lt;/strong&gt;，主要包括：&lt;code&gt;查看和设置工作路径&lt;/code&gt;、&lt;code&gt;查看文件或目录是否存在&lt;/code&gt;、&lt;code&gt;列出目录下文件或目录&lt;/code&gt;、&lt;code&gt;新建文件或目录&lt;/code&gt;、&lt;code&gt;复制文件或目录&lt;/code&gt;、&lt;code&gt;删除文件或目录&lt;/code&gt;、&lt;code&gt;重命名文件或目录&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell系列之局部变量、全局变量和环境变量</title>
    <link href="http://showteeth.tech/posts/52906.html"/>
    <id>http://showteeth.tech/posts/52906.html</id>
    <published>2019-08-26T08:57:43.000Z</published>
    <updated>2019-09-16T09:25:48.029Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章重点学习了Shell中<strong>变量的作用域</strong>，主要包括了<strong>局部变量</strong>、<strong>全局变量</strong>以及<strong>环境变量</strong>。其中在学习环境变量时又学习了使用<code>export</code>命令导出的<strong>临时环境变量</strong>以及<strong>在Shell进程启动时自动加载永久环境变量的过程</strong>。</p></div><a id="more"></a><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><code>Shell</code> 变量的<strong>作用域（Scope）</strong>，就是 <strong>Shell 变量的有效范围（可以使用的范围）</strong>。在<strong>不同的作用域</strong>中，同名的变量<strong>不会相互干涉</strong>；但是在<strong>相同的作用域中</strong>，同名的变量就会<strong>互相干扰</strong>，这也是为什么需要对变量作用域进行学习的原因。</p><p><code>Shell</code> 变量的作用域可以<strong>分为三种</strong>：</p><ul><li>有的变量只能在<strong>函数内部使用</strong>，这叫做<code>局部变量（local variable）</code>；</li><li>有的变量可以在<strong>当前 Shell 进程</strong>中使用，这叫做<code>全局变量（global variable）</code>；</li><li>而有的变量还可以在<strong>子进程</strong>中使用，这叫做<code>环境变量（environment variable）</code>。</li></ul><hr><p><br></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p><code>Shell</code> 也支持自定义函数，但是 <code>Shell</code> 函数和其他编程语言(如Python)函数的一个不同点就是：在 <strong>Shell 函数中定义的变量默认也是全局变量</strong>，它和在函数外部定义变量拥有一样的效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p></p><p>最后输出的结果是：99，是a的值。a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。</p><p>如果想要定义<strong>只在函数内部起作用的变量</strong>，需要在<strong>声明变量</strong>或者<strong>赋值之前</strong>加上<code>local</code>命令，这样就使得变量成为了<strong>局部变量</strong>，只在函数内部起作用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">local</span> a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p><hr><p><br></p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>所谓全局变量，就是指变量在<strong>当前的整个 Shell 进程中都有效</strong>；<strong>每个 Shell 进程(可以理解为在终端中打开的两个窗口)都有自己的作用域，彼此之间互不影响(在终端的一个窗口中定义的变量在另一个窗口中并不能调用)</strong>；<strong>在 Shell 中定义的变量，默认就是全局变量</strong>。</p><p>需要强调的是，全局变量的作用范围是<strong>当前的 Shell 进程</strong>，而<strong>不是当前的 Shell 脚本文件</strong>，它们是不同的概念；打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID；在一个 Shell 进程中可以使用 <code>source</code> 命令执行多个 Shell 脚本文件，此时<strong>全局变量在这些脚本文件中都有效</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  a.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">b=200</span><br><span class="line"></span><br><span class="line"><span class="comment">## b.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p></p><p>在打开的终端窗口中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前窗口的全局变量</span></span><br><span class="line">a=99</span><br><span class="line"></span><br><span class="line"><span class="comment"># source执行a脚本</span></span><br><span class="line">. ./a.sh</span><br><span class="line">  <span class="comment"># 输出99，也就是当前窗口的全局变量a的值</span></span><br><span class="line">  99</span><br><span class="line"></span><br><span class="line"><span class="comment"># source执行b脚本</span></span><br><span class="line">. ./b.sh</span><br><span class="line">  <span class="comment"># 输出a脚本中引入的全局变量</span></span><br><span class="line">  200</span><br></pre></td></tr></table></figure><p></p><p>这三条命令都是在<strong>一个进程</strong>中执行的，从输出结果可以发现，在 <code>Shell</code> 窗口中以命令行的形式定义的变量 <code>a</code>，在 <code>a.sh</code> 中有效；在 <code>a.sh</code>中定义的变量 <code>b</code>，在 <code>b.sh</code> 中也有效，变量 <code>b</code> 的作用范围已经超越了 <code>a.sh</code>。</p><div class="note info"><p>注意：这里是使用<code>source</code>的方式执行的脚本，效果是<strong>在当前进程下执行</strong>，而如果使用<code>bash a.sh</code>这种方式执行脚本就不会有上述结果，因为这种方式执行脚本是<strong>在子进程下执行的</strong>，具体执行方式的区别参考<a href="http://showteeth.tech/posts/16586.html">这篇文章</a>。</p></div><h3 id="全局变量冲突实例"><a href="#全局变量冲突实例" class="headerlink" title="全局变量冲突实例"></a>全局变量冲突实例</h3><p>最近在写shell脚本的时候恰巧遇到了全局变量导致程序出错的实例，这里记录一下：</p><ul><li>写了一个函数脚本，名为<code>qc.sh</code></li><li>在另一个脚本<code>run.sh</code>中对<code>qc.sh</code>进行了<code>source</code>执行</li></ul><p><code>qc.sh</code>截取：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func one</span></span><br><span class="line"><span class="function"><span class="title">func_1</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$&#123;local_variable&#125;</span>/*_test.zip)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    mv <span class="variable">$&#123;i&#125;</span> something</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># func two</span></span><br><span class="line"><span class="function"><span class="title">func_2</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$&#123;local_variable_2&#125;</span>/*_test.zip)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    mv <span class="variable">$&#123;i&#125;</span> something_2</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>run.sh</code>截取：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"190915_data"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  func_1  <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/qc</span><br><span class="line">  func_2  <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/trim <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/trim</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>最后程序在执行<code>func_2</code>时报错，而<code>func_1</code>正常执行，检查日志发现<code>func_2</code>传递的参数有误，其中的<code>${i}</code>部分变成了<code>func_1</code>中<code>for循环</code>最终停止的<code>i</code>，已经不是目标的<code>190915_data</code>，回顾之前学习的<a href="http://showteeth.tech/posts/16586.html">Linux系列之各种执行脚本方式的区别</a>，<code>source</code>方式执行脚本会打通全局变量，所以<code>func_1</code>执行之后由于其中的<code>i</code>变量<strong>不是局部变量，所以其作用域是整个脚本，并且会对之前的变量i的值进行覆盖</strong>，从而导致其值变为了<code>func_1</code>中<code>for循环</code>最终停止的<code>i</code>，并将其传递给了第二个函数<code>func_2</code>，最终导致出错。</p><p><strong>解决方法</strong>就是将<code>func_1</code>、<code>func_2</code>中的<code>i</code>声明为局部变量<code>local i</code></p><hr><p><br></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>全局变量</strong>只在<strong>当前 Shell 进程中有效</strong>，在<strong>其它 Shell 进程和子进程中都无效</strong>；如果想要使变量在Shell子进程甚至是所有的Shell进程中都有效，可以使用环境变量，环境变量又分为<strong>临时的环境变量</strong>和<strong>永久的环境变量</strong>：</p><ul><li>如果是使用<code>export</code>命令<strong>将全局变量导出</strong>，那么它就在所有的<strong>子进程</strong>中也有效了，这种变量被称为<strong>临时的环境变量</strong>；</li><li>而<strong>永久的环境变量</strong>是在shell启动时加载的，在<strong>所有的Shell进程中都有效的变量</strong>，如写在<code>~/.bashrc</code>中的变量。</li></ul><h3 id="临时的环境变量"><a href="#临时的环境变量" class="headerlink" title="临时的环境变量"></a>临时的环境变量</h3><p><strong>环境变量被创建(使用<code>export</code>命令)时所处的 Shell 进程称为父进程</strong>，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 <strong>Shell 子进程</strong>；当 Shell 子进程产生时，它会<strong>继承父进程的环境变量</strong>为自己所用，所以说环境变量可从父进程传给子进程；不难理解，环境变量还可以传递给孙进程。</p><p>注意，两个<strong>没有父子关系的 Shell 进程是不能传递使用<code>export</code>创建的环境变量的</strong>，并且这种环境变量<strong>只能向下传递而不能向上传递，即“传子不传父”</strong>。</p><p><strong>创建Shell子进程</strong>最简单的方法就是<code>bash</code>命令，退出Shell子进程的方法是<code>exit</code>命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前所处BASH的PID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  9512</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bash命令创建Shell子进程</span></span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看所处BASH的PID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  9963</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所处BASH的PID</span></span><br><span class="line"><span class="comment"># 发现回到了最开始的Shell进程</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> </span><br><span class="line">  9512</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个全局变量</span></span><br><span class="line">a=22       </span><br><span class="line"><span class="comment">#在当前Shell中输出a，成功</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line">  22</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入Shell子进程</span></span><br><span class="line">bash       </span><br><span class="line"><span class="comment">#在子进程中输出a，失败，输出为空</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#退出Shell子进程，返回上一级Shell</span></span><br><span class="line"><span class="built_in">exit</span>       </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将a导出为环境变量</span></span><br><span class="line"><span class="built_in">export</span> a   </span><br><span class="line"><span class="comment">#重新进入Shell子进程</span></span><br><span class="line">bash      </span><br><span class="line"><span class="comment">#在子进程中再次输出a，成功 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line">  22</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span>       </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出父进程，结束整个Shell会话</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现，<strong>默认情况下</strong>，<strong>a (父进程定义的变量)在 Shell 子进程中是无效的</strong>；使用 <code>export</code> 将 a <strong>导出为环境变量</strong>后，在子进程中就可以使用了；<code>export a</code>这种形式是在<strong>定义变量 a 以后</strong>再将它导出为环境变量，如果想在<strong>定义的同时导出为环境变量</strong>，可以写作<code>export a=22</code>。</p><div class="note info"><p>需要注意的是：</p><ul><li><strong>使用export导入的环境变量是临时的</strong>，这种环境变量只会在当前Shell进程及其Shell子进程(使用bash命令进入的Shell子进程)中起效，而不会在其他Shell进程(不同的终端窗口)中起效。</li><li>这种情况比较常见的是安装软件之后，没有将其写入环境变量，而是直接<code>export</code>，这种情况下，在该Shell进程以及其子Shell中都可以正常使用该软件，但是一旦切换终端窗口(其他Shell进程)就不能使用；另一种比较常见的就是编译、安装软件过程中通过<code>export</code>指定的依赖包的地址了。</li></ul></div><hr><h3 id="永久的环境变量"><a href="#永久的环境变量" class="headerlink" title="永久的环境变量"></a>永久的环境变量</h3><p>永久的环境变量主要是写在bash的<strong>环境配置文件</strong>中的变量，这些变量是在shell进程启动时<strong>自动加载</strong>的，在<strong>所有的Shell进程中都有效</strong>；bash的环境配置文件主要有<code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>、<code>/etc/bashrc</code>和<code>/etc/profile.d/*.sh</code>，其中的<code>~/.bashrc</code>文件就是平常使用中用来添加环境变量的文件；常规登录shell(交互式登录shell)之后会先读取<code>/etc/profile</code>，再依次搜索<code>~/.bash_profile</code>、<code>~/.bash_login</code>和<code>~/.profile</code>，并仅<strong>加载第一个搜索到且可读的文件(前面三个文件中的某一个)</strong>。当<strong>退出</strong>时，将执行<code>~/.bash_logout</code>中的命令。</p><p>配置文件的读取顺序中并没有包括提到的<code>/etc/profile</code>、<code>~/.bashrc</code>等常见的配置文件，主要是因为<strong>这些配置文件会被读取顺序中的文件所执行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/profile文件会以source的方式执行/etc/profile.d/*.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;-#*i&#125;</span>"</span> != <span class="string">"$-"</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile.d/*.sh包括</span></span><br><span class="line">vim.csh  vim.sh  256term.csh  256term.sh  </span><br><span class="line">lang.csh  lang.sh  csh.local  sh.local  colorls.csh  </span><br><span class="line">colorls.sh  colorgrep.csh  colorgrep.sh  </span><br><span class="line">less.csh  less.sh  which2.csh  which2.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bash_profile文件也会以source方式执行~/.bashrc</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在~/.bashrc也会以source的方式执行/etc/bashrc</span></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/bashrc其实也有以source方式执行/etc/profile.d/*.sh的语句</span></span><br><span class="line"><span class="comment"># 但是前提是非登录式shell时才会执行</span></span><br><span class="line"><span class="comment"># 这里不对shell的登录方式进行学习，只了解最简单的交互式登录</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">shopt</span> -q login_shell ; <span class="keyword">then</span>   <span class="comment"># We're not a login shell</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">"<span class="variable">$PS1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">                . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>具体的加载过程可以使用下图表示(图中的X表示在交互式登录shell中不会执行，<a href="https://www.cnblogs.com/f-ck-need-u/p/7417651.html" target="_blank" rel="noopener">图片来源</a>)：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/shell_load.png" alt="shell_load.png"></p><p>使用示例这里就不在进行列举了，感兴趣的可以自行尝试。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/view/773.html" target="_blank" rel="noopener">Shell变量的作用域：Shell全局变量、环境变量和局部变量</a></li><li><a href="https://blog.51cto.com/lspgyy/1542930" target="_blank" rel="noopener">shell函数的局部变量，全局变量</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7417651.html" target="_blank" rel="noopener">bash启动时加载配置文件过程</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章重点学习了Shell中&lt;strong&gt;变量的作用域&lt;/strong&gt;，主要包括了&lt;strong&gt;局部变量&lt;/strong&gt;、&lt;strong&gt;全局变量&lt;/strong&gt;以及&lt;strong&gt;环境变量&lt;/strong&gt;。其中在学习环境变量时又学习了使用&lt;code&gt;export&lt;/code&gt;命令导出的&lt;strong&gt;临时环境变量&lt;/strong&gt;以及&lt;strong&gt;在Shell进程启动时自动加载永久环境变量的过程&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之各种执行脚本方式的区别</title>
    <link href="http://showteeth.tech/posts/16586.html"/>
    <id>http://showteeth.tech/posts/16586.html</id>
    <published>2019-08-26T08:52:56.000Z</published>
    <updated>2019-09-06T12:45:28.577Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中执行shell脚本的三种方式：<strong>作为可执行程序</strong>、<strong>作为解释器参数</strong>、<strong>source方式执行</strong>，了解了这三种方式在<strong>指定脚本解释器</strong>、<strong>变量共用性</strong>方面的区别和联系。</p></div><a id="more"></a><h2 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h2><p>在学习shell脚本执行方式之前，先学习一下脚本解释器。脚本解释器简单来说就是告诉脚本使用什么语言来执行(目前我的理解)，Linux下常用的shell脚本解释器有：</p><ul><li><code>sh</code>：即<code>Bourne shell</code>，<code>POSIX</code>（Portable Operating System Interface）标准的<strong>shell解释器</strong>，它的二进制文件路径通常是<code>/bin/sh</code>；</li><li><code>bash</code>：Bash是<code>Bourne shell</code>的替代品，属<code>GNU Project</code>，二进制文件路径通常是<code>/bin/bash</code>；</li></ul><p>在<code>centos</code>下，<code>/bin/sh</code>是一个指向<code>/bin/bash</code>的链接：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx. 1 root root      4 Jul 16 01:21 /bin/sh -&gt; bash</span><br><span class="line">-rwxr-xr-x. 1 root root 964608 Oct 30  2018 /bin/bash</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="shell脚本执行方式"><a href="#shell脚本执行方式" class="headerlink" title="shell脚本执行方式"></a>shell脚本执行方式</h2><p>shell脚本共有<strong>三种</strong>执行方式：</p><ul><li><strong>作为可执行程序</strong></li><li><strong>作为解释器参数</strong></li><li><strong>source方式执行</strong></li></ul><h2 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建脚本</span></span><br><span class="line">cat test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予权限</span></span><br><span class="line"><span class="comment"># 赋予脚本可执行的权限</span></span><br><span class="line">chmod +x test_run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>#!/bin/bash</code>：<strong>指定脚本解释器</strong>，这里是指定使用<code>/bin/bash</code>做解释器的，其中的<code>#!</code>是一个<strong>约定的标记</strong>，它<strong>告诉系统这个脚本需要什么解释器来执行</strong>。使用这种方式执行脚本，这一句话一定要正确，<strong>要和脚本使用的语言是一致的</strong>，如果脚本是使用Python编写，那么这句话加就要指定Python的解释器，指定其他的解释器可能会出错；如果编写的是<code>bash shell</code>脚本，可以省略第一行的<code>#!/bin/bash</code>，这样依旧是可以执行的。</li><li><code>./test_run.sh</code>需要<strong>具有可执行</strong>的权限；</li><li><code>./test_run.sh</code>：这句话一定要加上<code>./</code>，不然也不能正确执行；如果直接写上<code>test_run.sh</code>，linux就会在系统的环境变量(PATH)中去查找有没有<code>test_run.sh</code>这个脚本，如果有就ok，会执行这个脚本，但是如果没有将<code>test_run.sh</code>加入到环境变量，那么就会显示<code>command not found</code>；使用<code>./test_run.sh</code>的含义是告诉linux在当前目录下寻找<code>test_run.sh</code>脚本，从而使其能被找到并执行。</li></ul><div class="note info"><p>一种常见地执行脚本解释器的写法是：<code>#!/usr/bin/env python</code>，这里的<strong>env表示的是环境变量中指定的Python</strong>，而不是<code>/bin/python</code>这种默认的Python。</p></div><hr><h2 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h2><p>这种运行方式是，<strong>直接运行解释器，其参数就是shell脚本的文件名</strong>，如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定解释器的全路径</span></span><br><span class="line">/bin/bash test_run.sh</span><br><span class="line"><span class="comment"># 因为在环境变量中，所以可以直接使用bash</span></span><br><span class="line">bash test_run.sh</span><br></pre></td></tr></table></figure><p></p><p>这种方式运行的脚本，<strong>不需要在第一行指定解释器信息</strong>，写了也没用，同时也<strong>不需要脚本具有可执行权限</strong>。</p><hr><h2 id="Shell子进程"><a href="#Shell子进程" class="headerlink" title="Shell子进程"></a>Shell子进程</h2><p>上述两种执行方式都是在<strong>当前Shell进程的子进程中</strong>进行的，查看Shell当前进程的方式是使用内置的<code>$$</code>、<code>$BASHPID</code>变量查看进程ID，两种用法的区别可以参考<a href="http://showteeth.tech/posts/36597.html">这篇文章</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前shell进程</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看shell脚本执行时的进程ID</span></span><br><span class="line">cat  test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序执行</span></span><br><span class="line"><span class="comment"># shell子进程ID不同</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  23163</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释器变量执行</span></span><br><span class="line"><span class="comment"># shell子进程ID不同</span></span><br><span class="line">bash test_run.sh </span><br><span class="line">  10</span><br><span class="line">  23194</span><br></pre></td></tr></table></figure><p></p><p>既然是在不同的Shell进程中执行的命令，所以某个shell进程中的全局(局部)变量在另一个Shell进程中是无法使用的，如果想要使用可以使用环境环境变量，具体可以查看<a href="http://showteeth.tech/posts/52906.html">这篇文章</a>。</p><hr><h3 id="source方式执行"><a href="#source方式执行" class="headerlink" title="source方式执行"></a>source方式执行</h3><p><code>source</code>方式执行的脚本不同于上述两种执行方式，其是<strong>在当前Shell进程下执行的</strong>；<code>source</code>执行脚本有<strong>两种写法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两种写法都是使用source执行脚本</span></span><br><span class="line">. test_run.sh</span><br><span class="line"><span class="built_in">source</span> test_run.sh</span><br></pre></td></tr></table></figure><p></p><p>具体示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用source命令执行程序</span></span><br><span class="line"><span class="comment"># 并输出程序执行的Shell进程ID</span></span><br><span class="line"><span class="built_in">source</span> test_run.sh </span><br><span class="line">  10</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line">. test_run.sh </span><br><span class="line">  10</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell进程ID</span></span><br><span class="line"><span class="comment"># 发现和source执行脚本的进程ID相同</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>因为<code>source</code>执行的脚本是在<strong>当前Shell进程</strong>中进行的，所以<strong>当前Shell进程的全局变量以及脚本中的全局变量是共通的</strong>，两者之间可以相互使用。</p><p>其他<code>source</code>命令注意事项：</p><ul><li><code>source</code> 命令<strong>不需要脚本具有可执行权限</strong>；</li><li><code>source</code> 命令可以<strong>强行让一个脚本去立即影响当前的环境</strong>；</li><li><code>source</code> 命令通常用于<strong>重新执行刚修改的初始化文件，使修改生效</strong>，如<code>~/.bashrc</code>；</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li></li><li><a href="https://www.centos.bz/2017/12/%E8%AF%A6%E8%A7%A3shell%E4%B8%ADsource%E3%80%81sh%E3%80%81bash%E3%80%81-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">详解shell中source、sh、bash、./执行脚本的区别</a></li><li><a href="https://blog.51cto.com/xoyabc/1673249" target="_blank" rel="noopener">shell中的点命令与source命令</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了Linux中执行shell脚本的三种方式：&lt;strong&gt;作为可执行程序&lt;/strong&gt;、&lt;strong&gt;作为解释器参数&lt;/strong&gt;、&lt;strong&gt;source方式执行&lt;/strong&gt;，了解了这三种方式在&lt;strong&gt;指定脚本解释器&lt;/strong&gt;、&lt;strong&gt;变量共用性&lt;/strong&gt;方面的区别和联系。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之向量、矩阵、数组、数据框和列表</title>
    <link href="http://showteeth.tech/posts/30224.html"/>
    <id>http://showteeth.tech/posts/30224.html</id>
    <published>2019-08-25T03:17:31.000Z</published>
    <updated>2019-08-25T07:25:15.573Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是基于<a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">这篇文章</a>学习了R中几种常见的数据结构，包括<code>向量</code>、<code>矩阵</code>、<code>数组</code>、<code>数据框</code>以及<code>列表</code>，主要围绕这些数据结构的<code>构成</code>、<code>创建</code>、<code>获取元素</code>进行了学习，后续使用中可以查询和补充。</p></div><a id="more"></a><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量的创建"><a href="#向量的创建" class="headerlink" title="向量的创建"></a>向量的创建</h3><p>向量是用于存储<code>数值型</code>、<code>字符型</code>或<code>逻辑型</code>数据的一维数组。执行组合功能的函数<code>c()</code>可用来<strong>创建向量</strong>。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为数值：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向量创建使用示例</span></span><br><span class="line">&gt; a &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">4</span>)   <span class="comment">#数值型向量</span></span><br><span class="line">&gt; a</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span> -<span class="number">2</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt; b &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)  <span class="comment">#字符型向量</span></span><br><span class="line">&gt; b</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">&gt; c &lt;- c(<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>)  <span class="comment">#逻辑型向量</span></span><br><span class="line">&gt; c</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure><p></p><p>特别地，对于整数型向量，可以使用<code>seq</code>函数进行创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始值（from），结束值（to），步长（by）</span></span><br><span class="line">seq(from = <span class="number">1</span>, to = <span class="number">1</span>, by=step)</span><br><span class="line"><span class="comment"># 创建从1开始到5(包括)截止，步长为1的整数向量</span></span><br><span class="line">seq(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用这种方式创建步长为1的整数向量</span></span><br><span class="line"><span class="number">1</span>:<span class="number">5</span></span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h3><p>通过<code>is.*</code> 函数检查变量的类型，通过<code>as.*</code>函数转换变量的类型：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; vc &lt;- c(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>)</span><br><span class="line"><span class="comment"># 判断vc是不是字符型向量</span></span><br><span class="line">&gt; is.character(vc)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 将vc转换为整数型向量</span></span><br><span class="line">&gt; vi &lt;- as.integer(vc)</span><br><span class="line">&gt; is.integer(vi)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问向量中的元素"><a href="#访问向量中的元素" class="headerlink" title="访问向量中的元素"></a>访问向量中的元素</h3><p>通过索引的方式可以访问向量中的元素，注意<strong>R中是索引开始于1</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取索引为1的元素</span></span><br><span class="line">&gt; a[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line"><span class="comment"># 获取索引为1、5的元素</span></span><br><span class="line">&gt; a[c(<span class="number">1</span>,<span class="number">3</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 切片操作，获取1-3的元素</span></span><br><span class="line">&gt; b[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>获取逻辑判断为TRUE的元素</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过判断语句得到逻辑向量</span></span><br><span class="line">&gt; v&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; class(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"logical"</span></span><br><span class="line"><span class="comment"># 得到逻辑向量为TRUE的索引位置</span></span><br><span class="line">&gt; which(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[which(v&gt;<span class="number">2</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[v&gt;<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="向量的排序"><a href="#向量的排序" class="headerlink" title="向量的排序"></a>向量的排序</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># sort返回排序之后的向量</span></span><br><span class="line">&gt; sort(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># order返回排序后的向量元素在原始向量中的索引位置</span></span><br><span class="line">&gt; order(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 通过索引位置获取排序后的向量</span></span><br><span class="line">&gt; v[order(v)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="补充知识-NULL和NA"><a href="#补充知识-NULL和NA" class="headerlink" title="补充知识-NULL和NA"></a>补充知识-NULL和NA</h3><p><code>NULL</code>是个特殊值，表示未知值，<code>NA</code>表示缺失值，<code>NULL</code>和<code>NA</code>之间<strong>最大的区别是</strong>：<code>NA</code>是一个标量值，<code>长度为1</code>，而<code>NULL</code>不会占用任何空间，<strong>长度为零</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出长度</span></span><br><span class="line">&gt; length(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; length(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断null、na</span></span><br><span class="line">&gt; is.null(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; is.na(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h3><p>矩阵是一个二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通 过函数matrix创建矩阵。一般使用格式为：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mymatrix &lt;- matrix(vector,nrow=number_of_rows,ncol=number_of_columns,   </span><br><span class="line">    + byrow=logical_value,dimnames=list(   </span><br><span class="line">    + char_vector_rowname,char_vector_colnames))</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了矩阵的元素，</li><li><code>nrow</code>和<code>ncol</code>用以指定行和列的维数，</li><li><code>dimnames</code>包含了可选的、以字符型向量表示的行名和列名</li><li>选项<code>byrow</code>则表明矩阵应当按行填充（<code>byrow=TRUE</code>）还是按列填充（<code>byrow=FALSE</code>），默认情况下按列填充。简单示例如下：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个5*4的矩阵</span></span><br><span class="line">&gt; y &lt;- matrix(<span class="number">1</span>:<span class="number">20</span>,nrow=<span class="number">5</span>,ncol=<span class="number">4</span>)     </span><br><span class="line">&gt; y</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span>   <span class="number">11</span>   <span class="number">16</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span>   <span class="number">12</span>   <span class="number">17</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span>   <span class="number">13</span>   <span class="number">18</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span>   <span class="number">14</span>   <span class="number">19</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span>   <span class="number">15</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按行填充的2*2矩阵</span></span><br><span class="line">&gt; cells &lt;- c(<span class="number">1</span>,<span class="number">26</span>,<span class="number">24</span>,<span class="number">68</span>)</span><br><span class="line">&gt; rnames &lt;- c(<span class="string">"R1"</span>,<span class="string">"R2"</span>)</span><br><span class="line">&gt; cname &lt;- c(<span class="string">"C1"</span>,<span class="string">"C2"</span>)</span><br><span class="line">&gt; &gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">TRUE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">26</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按列填充的2*2矩阵</span></span><br><span class="line">&gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">FALSE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">24</span></span><br><span class="line">R2 <span class="number">26</span> <span class="number">68</span></span><br></pre></td></tr></table></figure><hr><h3 id="矩阵元素的获取"><a href="#矩阵元素的获取" class="headerlink" title="矩阵元素的获取"></a>矩阵元素的获取</h3><p>我们可以使用索引的方式来选择矩阵中的行、列或元素。<code>X[i,]</code>指矩阵X中的第i行，<code>X[,j]</code>指第j列，<code>X[i, j]</code>指第i行第j个元素。选择<strong>多行或多列</strong>时，下标i和j可为数值型向量，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">2</span>)</span><br><span class="line">&gt; x</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">7</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span>    <span class="number">8</span>   <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二行的元素</span></span><br><span class="line">&gt; x[<span class="number">2</span>,]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二列的元素</span></span><br><span class="line">&gt; x[,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取第一行第4列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取第一行第4列、第五列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,c(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p></p><p>矩阵都是二维的，和向量类似，<strong>矩阵中也仅能包含一种数据类型</strong>；当<strong>维度超过2时，不妨使用数组</strong>；当有<strong>多种模式的数据时，不妨使用数据框</strong>。</p><hr><p><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p>数组（array）与矩阵类似，但是维度可以大于2。数组可通过array函数创建，形式如下：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray &lt;- array(vector,dimensions,dimnames)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了数组中的数据；</li><li><code>dimensions</code>是一个数值型向量，给出了各个维度下标的最大值；</li><li><code>dimnames</code>是可选的、各维度名称标签的列表。</li></ul><p>创建三维 （2×3×4）数值型数组:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; z &lt;- array(<span class="number">1</span>:<span class="number">24</span>, c(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&gt; z</span><br><span class="line">, , <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span></span><br><span class="line">A2  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">7</span>  <span class="number">9</span> <span class="number">11</span></span><br><span class="line">A2  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">13</span> <span class="number">15</span> <span class="number">17</span></span><br><span class="line">A2 <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">19</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line">A2 <span class="number">20</span> <span class="number">22</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p></p><p>如你所见，数组是矩阵的一个自然推广；它们在编写新的统计方法时可能很有用。</p><p>像矩阵一样，<strong>数组中的数据也只能拥有一种模式</strong>。</p><hr><h3 id="数组元素的获取"><a href="#数组元素的获取" class="headerlink" title="数组元素的获取"></a>数组元素的获取</h3><p>从数组中选取元素的方式与矩阵类似：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">15</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">3</span>  <span class="number">9</span> <span class="number">15</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>由于<strong>不同的列可以包含不同模式（数值型、字符型等）的数据，但每一列的数据类型必须唯一</strong>，数据框的用途更为广泛。</p><h3 id="数据框的创建"><a href="#数据框的创建" class="headerlink" title="数据框的创建"></a>数据框的创建</h3><p>数据框可通过函数<code>data.frame()</code>创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydata &lt;- data.frame(col1,col2,col3,…)</span><br></pre></td></tr></table></figure><p></p><ul><li>列向量<code>col1</code>, <code>col2</code>, <code>col3</code>,… 可为任何类型（如字符型、数值型或逻辑型）</li><li>每一列的名称可由函数<code>names</code>指定</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientID &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt; age &lt;- c(<span class="number">25</span>,<span class="number">34</span>,<span class="number">28</span>,<span class="number">52</span>)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID,age,diabetes,status)</span><br><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br></pre></td></tr></table></figure><p></p><p>每一列数据的模式必须唯一，不过你却可以将多个模式的不同列放到一起组成数据框。</p><h3 id="数据框元素的获取"><a href="#数据框元素的获取" class="headerlink" title="数据框元素的获取"></a>数据框元素的获取</h3><p>选取数据框中元素的方式有若干种，你可以使用索引，亦可直接指定列名。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br><span class="line"><span class="comment"># 通过索引</span></span><br><span class="line">&gt; patientdata[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">  patientID age</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span></span><br><span class="line"><span class="comment"># 直接指定列名</span></span><br><span class="line">&gt; patientdata[c(<span class="string">"diabetes"</span>,<span class="string">"status"</span>)]</span><br><span class="line">  diabetes    status</span><br><span class="line"><span class="number">1</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>    Type1      Poor</span><br><span class="line">&gt; patientdata[c(<span class="string">"age"</span>)]</span><br><span class="line">  age</span><br><span class="line"><span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>  <span class="number">52</span></span><br><span class="line">&gt; class(patientdata[c(<span class="string">"age"</span>)])</span><br><span class="line">[<span class="number">1</span>] <span class="string">"data.frame"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某列的值，并得到向量</span></span><br><span class="line">&gt; patientdata$age</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">&gt; class(patientdata$age)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br></pre></td></tr></table></figure><p></p><p>第三个例子中的记号<code>$</code>是新出现的，它被用来<strong>选取一个给定数据框中的某个特定变量，并且返回向量形式</strong>。例如，如果你想生成糖尿病类型变量diabetes和病情变量status的列联表，使用以下代码即可：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; table(patientdata$diabetes,patientdata$status)</span><br><span class="line"></span><br><span class="line">        Excellent Improved Poor</span><br><span class="line">  Type1         <span class="number">1</span>        <span class="number">0</span>    <span class="number">2</span></span><br><span class="line">  Type2         <span class="number">0</span>        <span class="number">1</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>在每个变量名前都键入一次<code>patientdata$</code>可能会让人生厌，所以不妨走一些捷径。可以联合使用函数<code>attach()</code>和<code>detach()</code>或单独使用函数<code>with()</code>来简化代码.</p><p><code>attach()</code>函数可<strong>将数据框添加到R的搜索路径中</strong>，R在遇到一个变量名以后，将检查搜索路径中的数据框，以定位到这个变量：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;summary(mtcars$mpg)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line">&gt;plot(mtcars$mpg,mtcars$disp)</span><br><span class="line">&gt; <span class="comment">#也可写成：</span></span><br><span class="line"><span class="comment"># 将数据框添加到R的搜索路径中</span></span><br><span class="line">&gt;<span class="keyword">attach</span>(mtcars)</span><br><span class="line">&gt;plot(mpg,disp)</span><br><span class="line"><span class="comment"># 将数据框从搜索路径中移除</span></span><br><span class="line">&gt;<span class="keyword">detach</span>(mtcars)</span><br></pre></td></tr></table></figure><p>当<strong>名称相同的对象不止一个时</strong>，这种方法的局限性就很明显了。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; mpg &lt;- c(<span class="number">25</span>,<span class="number">36</span>,<span class="number">47</span>)</span><br><span class="line">&gt; <span class="keyword">attach</span>(mtcars)</span><br><span class="line">The following object is masked _by_ .GlobalEnv:  mpg</span><br><span class="line"><span class="comment"># mtcars中也有mpg变量</span></span><br><span class="line">&gt; plot(mpg,wt)</span><br><span class="line">Error <span class="keyword">in</span> xy.coords(x, y, xlabel, ylabel, log) : </span><br><span class="line">  <span class="string">'x'</span> and <span class="string">'y'</span> lengths differ</span><br><span class="line">&gt; mpg</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">36</span> <span class="number">47</span></span><br><span class="line"><span class="comment"># 指定mpg来源</span></span><br><span class="line">&gt; plot(mtcars$mpg,wt)</span><br></pre></td></tr></table></figure><p></p><p>这里，在数据框mtcars被绑定（attach）之前，我们的环境中已经有了一个名为mpg的对象。 在这种情况下，原始对象将取得优先权，故而报错，这个时候想使用mpg时，便要像最后一段代码示例那般指定变量来源。</p><p>除此之外，另一种方式是使用函数<code>with()</code>，你可以这样重写上例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ plot(mpg,disp)</span><br><span class="line">+ &#125;)</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，<strong>大括号{}之间的语句都针对数据框mtcars执行</strong>，这样就无须担心名称冲突了；如果<strong>仅有一条语句（例如summary(mpg)），那么大括号{}可以省略</strong>；<strong>函数<code>with()</code>的局限性在于，赋值仅在此函数的括号内生效</strong>，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;stats &lt;-summary(mpg)</span><br><span class="line">+ stats</span><br><span class="line">+ &#125;)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line"><span class="comment"># 在with的&#123;&#125;之外</span></span><br><span class="line">&gt; stats</span><br><span class="line">错误: 找不到对象<span class="string">'stats'</span></span><br></pre></td></tr></table></figure><p></p><p>如果你需要创建在<code>with()</code>结构以外存在的对象，使用<code>特殊赋值符&lt;&lt;-</code>替代<code>标准赋值符&lt;-</code>即可，它可将对象保存到<code>with()</code>之外的全局环境中。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ nokeepstats &lt;- summary(mpg)</span><br><span class="line">+ keepstats &lt;&lt;- summary(mpg)</span><br><span class="line">+ &#125;)</span><br><span class="line">&gt; nokeepstats</span><br><span class="line">错误: 找不到对象<span class="string">'nokeepstats'</span></span><br><span class="line">&gt; keepstats</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>如你所见，变量可归结为名义型、有序型或连续型变量。名义型变量是没有顺序之分的类别变量，糖尿病类型Diabetes（Type1、Type2）是名义型变量的一例，即使在数据中Type1编码为1而Type2编码为2，这也并不意味着二者是有序的。有序型变量表示一种顺序关系，而非数量关系，病情Status（poor、improved、excellent）是顺序型变量的一个上佳示例。我们明白， 病情为poor（较差）病人的状态不如improved（病情好转）的病人，但并不知道相差多少。连续型变量可以呈现为某个范围内的任意值，并同时表示了顺序和数量，年龄Age就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值，我们很清楚，15岁的人比14岁的人年长一岁。</p><p><strong>类别（名义型）变量</strong>和<strong>有序类别（有序型）变量</strong>在R中称为<strong>因子（factor）</strong>。因子在R中非常重要，因为它决定了<strong>数据的分析方式</strong>以及<strong>如何进行视觉呈现</strong>，你将在本书中通篇看到这样的例子。函数<code>factor()</code>以一个整数向量的形式存储类别值，整数的取值范围是<code>[1… k]</code>（其中<code>k</code>是名义型变量中<strong>唯一值</strong>的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</p><p>举例来说，假设有向量：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; diabetes &lt;- c( <span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; diabetes &lt;- factor(diabetes)</span><br><span class="line">&gt; diabetes</span><br><span class="line">[<span class="number">1</span>] Type1 Type2 Type1 Type1</span><br><span class="line">Levels: Type1 Type2</span><br></pre></td></tr></table></figure><p></p><p>语句<code>diabetes &lt;- factor(diabetes)</code>将此向量存储为<code>(1, 2, 1, 1)</code>，并在内部将其关联为<code>1=Type1</code>和<code>2=Type2</code>（具体赋值根据字母顺序而定）。针对向量diabetes进行的任何分析都会<strong>将其作为名义型变量对待</strong>，并<strong>自动选择适合这一测量尺度的统计方法</strong>。要表示<strong>有序型变量</strong>，需要为函数<code>factor()</code>指定参数<code>ordered=TRUE</code>。给定向量:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br></pre></td></tr></table></figure><p></p><p>语句<code>status &lt;- factor(status, ordered=TRUE)</code>会将向量编码为<code>(3, 2, 1, 3)</code>，并在内部将这些值关联为<code>1=Excellent</code>、<code>2=Improved</code>以及<code>3=Poor</code>.对于<strong>字符型向量</strong>，因子的水平<strong>默认依字母顺序创建</strong>，这对于因子status是有意义的，因为 <code>Excellent</code>、<code>Improved</code>、<code>Poor</code>的排序方式恰好与逻辑顺序相一致，如果<code>Poor</code>被编码为<code>Ailing</code>，会有问题，因为顺序将为<code>Ailing</code>、<code>Excellent</code>、<code>Improved</code>。如果理想中的顺序是<code>Poor</code>、<code>Improved</code>、<code>Excellent</code>，则会出现类似的问题：按默认的字母顺序排序的因子很少能够让人满意，你可以通过指定<code>levels</code>选项来覆盖默认排序。例如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是按照字母顺序创建</span></span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现Ailing会破坏顺序</span></span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>,<span class="string">"Ailing"</span>)</span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor      Ailing   </span><br><span class="line">Levels: Ailing &lt; Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用levels指定顺序</span></span><br><span class="line">&gt; status &lt;- factor(status,ordered=<span class="literal">TRUE</span>,</span><br><span class="line">+ levels=c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>)</span><br><span class="line">+ )</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Poor &lt; Improved &lt; Excellent</span><br></pre></td></tr></table></figure><p></p><p>因子的使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建dataframe</span></span><br><span class="line">&gt; patientdata &lt;-data.frame(patientID,age,diabetes,status)</span><br><span class="line"><span class="comment"># 查看各列数据的类型</span></span><br><span class="line">&gt; str(patientdata)</span><br><span class="line"><span class="string">'data.frame'</span>:   <span class="number">4</span> obs. of  <span class="number">4</span> variables:</span><br><span class="line">  $ patientID: num  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">  $ age      : num  <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">  $ diabetes : Factor w/ <span class="number">2</span> levels <span class="string">"Type1"</span>,<span class="string">"Type2"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  $ status   : Ord.factor w/ <span class="number">3</span> levels <span class="string">"Poor"</span>&lt;<span class="string">"Improved"</span>&lt;..: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 显示基本统计信息</span></span><br><span class="line">&gt; summary(patientdata)</span><br><span class="line">    patientID         age         diabetes       status </span><br><span class="line">  Min.   :<span class="number">1.00</span>   Min.   :<span class="number">25.00</span>   Type1:<span class="number">3</span>   Poor     :<span class="number">2</span>  </span><br><span class="line">  1st Qu.:<span class="number">1.75</span>   1st Qu.:<span class="number">27.25</span>   Type2:<span class="number">1</span>   Improved :<span class="number">1</span>  </span><br><span class="line">  Median :<span class="number">2.50</span>   Median :<span class="number">31.00</span>             Excellent:<span class="number">1</span>  </span><br><span class="line">  Mean   :<span class="number">2.50</span>   Mean   :<span class="number">34.75</span>                          </span><br><span class="line">  3rd Qu.:<span class="number">3.25</span>   3rd Qu.:<span class="number">38.50</span>                          </span><br><span class="line">  Max.   :<span class="number">4.00</span>   Max.   :<span class="number">52.00</span></span><br></pre></td></tr></table></figure><p></p><p><code>str(patientdata)</code>清楚地显示<code>diabetes</code>是一个<strong>因子</strong>，而<code>status</code>是一个<strong>有序型因子</strong>，以及此数据框在<strong>内部是如何进行编码的</strong>。注意，函数<code>summary()</code>会<strong>区别对待各个变量</strong>，它显示了连续型变量age的最小值、最大值、均值和各四分位数，并显示了类别型变量diabetes和status（各水平）的频数值。</p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）是R的数据类型中为复杂的一种，一般来说，列表就是一些对象（或成分， component）的有序集合，列表允许你整合若干（可能无关的）对象到单个对象名下。例如，某个列表中可能是若干<strong>向量</strong>、<strong>矩阵</strong>、<strong>数据框</strong>，甚至<strong>其他列表</strong>的组合。</p><p>可以使用函数<code>list()</code>创建列表:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;- list(object1,object2,…)</span><br></pre></td></tr></table></figure><p></p><p>其中的对象可以是目前为止讲到的任何结构。你还可以为列表中的对象命名：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;`- list(name1=object1,name2=object2,…)</span><br></pre></td></tr></table></figure><p>具体使用示例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; g &lt;- <span class="string">"My First List"</span></span><br><span class="line">&gt; h &lt;- c(<span class="number">25</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">39</span>)</span><br><span class="line">&gt; j &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">5</span>)</span><br><span class="line">&gt; k &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)</span><br><span class="line">&gt; mylist &lt;- list(title=g,ages=h,j,k)</span><br><span class="line">&gt; mylist</span><br><span class="line">$title</span><br><span class="line">[<span class="number">1</span>] <span class="string">"My First List"</span></span><br><span class="line"></span><br><span class="line">$ages</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">26</span> <span class="number">18</span> <span class="number">39</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p>本例创建了一个列表，其中有四个成分：一个字符串、一个数值型向量、一个矩阵以及一个字符型向量。</p><p>在访问列表中元素时，可以通过在<strong>双重方括号</strong>中<strong>指明代表某个成分的数字</strong>或<strong>名称</strong>来访问列表中的元素。此例 中，<code>mylist[[2]]</code>和<code>mylist[[“ages”]]</code>均指那个含有四个元素的向量。</p><p>由于两个原因，列表成为了R中的重要数据结构:</p><ul><li>首先，列表允许以一种简单的方式组织和重新调用不相干的信息；</li><li>其次，许多R函数的运行结果都是以列表的形式返回的，需要取出其中哪些成分由分析人员决定。</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">R语言入门之创建数据集——向量、矩阵、数组、数据框和列表</a></li><li><a href="https://www.cnblogs.com/ljhdo/p/5173674.html" target="_blank" rel="noopener">R语言学习 第一篇：变量和向量</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要是基于&lt;a href=&quot;https://blog.csdn.net/qq_28945021/article/details/52100765&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;学习了R中几种常见的数据结构，包括&lt;code&gt;向量&lt;/code&gt;、&lt;code&gt;矩阵&lt;/code&gt;、&lt;code&gt;数组&lt;/code&gt;、&lt;code&gt;数据框&lt;/code&gt;以及&lt;code&gt;列表&lt;/code&gt;，主要围绕这些数据结构的&lt;code&gt;构成&lt;/code&gt;、&lt;code&gt;创建&lt;/code&gt;、&lt;code&gt;获取元素&lt;/code&gt;进行了学习，后续使用中可以查询和补充。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>R系列之字符串处理</title>
    <link href="http://showteeth.tech/posts/28337.html"/>
    <id>http://showteeth.tech/posts/28337.html</id>
    <published>2019-08-24T13:43:57.000Z</published>
    <updated>2019-08-25T03:05:25.756Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<strong>R中的字符向量处理函数</strong>，主要包括<strong>字符数统计和字符翻译</strong>、<strong>字符串连接</strong>、<strong>字符串拆分</strong>、<strong>字符串查询</strong>、<strong>字符串替换</strong>、<strong>字符串提取</strong>、<strong>字符串显示控制</strong>等。</p></div><a id="more"></a><h2 id="字符数统计和字符翻译"><a href="#字符数统计和字符翻译" class="headerlink" title="字符数统计和字符翻译"></a>字符数统计和字符翻译</h2><h3 id="nchar和length"><a href="#nchar和length" class="headerlink" title="nchar和length"></a>nchar和length</h3><p><code>nchar</code>这个函数简单，统计<strong>向量中每个元素的字符个数</strong>，注意<strong>这个函数和<code>length</code>函数的差别</strong>：</p><ul><li><code>nchar</code>是<strong>向量元素的字符个数</strong>;</li><li>而<code>length</code>是<strong>向量长度（向量元素的个数）</strong>.</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"Hellow"</span>, <span class="string">"World"</span>, <span class="string">"!"</span>)</span><br><span class="line"><span class="comment"># 向量中每个元素的长度</span></span><br><span class="line">nchar(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">6</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量的长度</span></span><br><span class="line">length(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h3 id="tolower、toupper和chartr"><a href="#tolower、toupper和chartr" class="headerlink" title="tolower、toupper和chartr"></a>tolower、toupper和chartr</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DNA &lt;- <span class="string">"AtGCtttACC"</span></span><br><span class="line"><span class="comment"># 将上述字符转换为小写</span></span><br><span class="line">tolower(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"atgctttacc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述字符转换为大写</span></span><br><span class="line">toupper(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"ATGCTTTACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;u</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"Uu"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AuGCuuuACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;U</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"UU"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AUGCUUUACC"</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><h3 id="paste函数"><a href="#paste函数" class="headerlink" title="paste函数"></a>paste函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义分隔符</span></span><br><span class="line">paste (<span class="keyword">...</span>, sep = <span class="string">" "</span>, collapse = <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment"># 默认没有分隔符</span></span><br><span class="line">paste0(<span class="keyword">...</span>, collapse = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短的向量CK会被循环使用</span></span><br><span class="line">paste(<span class="string">"CK"</span>, <span class="number">1</span>:<span class="number">6</span>, sep = <span class="string">"|"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"CK|1"</span> <span class="string">"CK|2"</span> <span class="string">"CK|3"</span> <span class="string">"CK|4"</span> <span class="string">"CK|5"</span> <span class="string">"CK|6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短的向量会被循环使用</span></span><br><span class="line">x = c(a = <span class="string">"aaa"</span>, b = <span class="string">"bbb"</span>, c = <span class="string">"ccc"</span>)</span><br><span class="line">y = c(d = <span class="number">1</span>, e = <span class="number">2</span>)</span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>) </span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span> <span class="string">"bbb-2"</span> <span class="string">"ccc-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述操作返回的都是一个向量</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>)[<span class="number">1</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想将所有的连接成一个字符串</span></span><br><span class="line"><span class="comment"># 使用collapse参数</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>,collapse = <span class="string">";"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1;bbb-2;ccc-1"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><h3 id="strsplit函数"><a href="#strsplit函数" class="headerlink" title="strsplit函数"></a>strsplit函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strsplit(x, split, fixed = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>参数<code>x</code>为字串向量，<strong>每个元素都将单独进行拆分</strong>;</li><li>参数<code>split</code>为拆分位置的字串向量，默认<code>fixed=FALSE</code>为<strong>正则表达式匹配</strong>。如果你没接触过正则表达式，设置<code>fixed=TRUE</code>，表示使用<strong>普通文本匹配或正则表达式的精确匹配</strong>；普通文本的运算速度快;</li><li><code>perl=TRUE/FALSE</code>的设置和perl语言版本有关，如果正则表达式很长，正确设置表达式并且使用perl=TRUE可以提高运算速度;</li><li>参数<code>useBytes</code>设置<strong>是否逐个字节进行匹配</strong>，默认为FALSE，即按字符而不是字节进行匹配。</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- <span class="string">"Hello Adam!\nHello Ava!"</span></span><br><span class="line"><span class="comment"># 将上述字符按空格分隔</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span>        <span class="string">"Adam!\nHello"</span> <span class="string">"Ava!"</span> </span><br><span class="line"><span class="comment"># 返回的是一个列表</span></span><br><span class="line">class(strsplit(text, <span class="string">" "</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line"><span class="comment"># 输出分割后的第一个字符</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)[[<span class="number">1</span>]][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式进行分割</span></span><br><span class="line"><span class="comment"># 按空白分隔：空格、制表符、换行符等</span></span><br><span class="line">strsplit(text, <span class="string">"\\s"</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span> <span class="string">"Adam!"</span> <span class="string">"Hello"</span> <span class="string">"Ava!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到单个字符</span></span><br><span class="line">strsplit(text, <span class="string">""</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"d"</span>  <span class="string">"a"</span>  <span class="string">"m"</span>  <span class="string">"!"</span>  <span class="string">"\n"</span> <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"v"</span>  <span class="string">"a"</span>  <span class="string">"!"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h2><h3 id="grep和grepl函数"><a href="#grep和grepl函数" class="headerlink" title="grep和grepl函数"></a>grep和grepl函数</h3><p>这两个函数返回向量水平的匹配结果(向量中每个元素可以不可以匹配上)，不涉及匹配字符串的详细位置信息(在每个元素的什么索引位置匹配上).</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, value = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>, invert = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">grepl(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">      fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下所有的文件</span></span><br><span class="line">files &lt;- list.files(<span class="string">"./"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找以gz结尾的文件</span></span><br><span class="line"><span class="comment"># 返回的是可以匹配上的元素在整个向量中的索引位置</span></span><br><span class="line">grep(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的是向量元素中的每一个是不是可以匹配上</span></span><br><span class="line">grepl(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者虽然在输出表现上有所差异，但是在提取向量子集时结果相同</span></span><br><span class="line">files[grep(<span class="string">"\\.gz$"</span>, files)]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="regexpr、gregexpr和regexec"><a href="#regexpr、gregexpr和regexec" class="headerlink" title="regexpr、gregexpr和regexec"></a>regexpr、gregexpr和regexec</h3><p>这三个函数返回的结果包含了<strong>匹配的具体位置</strong>和<strong>匹配上的字符串长度信息</strong>，可以用于字符串的提取操作.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gregexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">         fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">regexec(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>三个函数的区别：</p><ul><li><code>regexpr</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>数字向量</strong></li><li><code>gregexpr</code>返回的是向量中每个元素<strong>所有出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li><li><code>regexec</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- c(<span class="string">"Hellow, Adam!Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素第一次出现Adam的位置</span></span><br><span class="line">class(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"integer"</span></span><br><span class="line">regexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  <span class="comment"># 匹配上的第一个字符位置 </span></span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span>  <span class="number">5</span> <span class="number">14</span></span><br><span class="line">  <span class="comment"># 匹配上的部分长度</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 获取上述结果中的match.length</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  $match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  $index.type</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line"></span><br><span class="line">  $useBytes</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 得到向量</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))$match.length</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素所有出现Adam的位置</span></span><br><span class="line">class(gregexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">gregexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span> <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 这个也是一样的方法</span></span><br><span class="line">attributes(gregexpr(<span class="string">"Adam"</span>, text)[[<span class="number">1</span>]])$match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素首次出现Adam的位置</span></span><br><span class="line">class(regexec(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">regexec(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">9</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="sub和gsub函数"><a href="#sub和gsub函数" class="headerlink" title="sub和gsub函数"></a>sub和gsub函数</h3><p>虽然<code>sub</code>和<code>gsub</code>是用于字符串替换的函数，但严格地说R语言没有字符串替换的函数，因为<strong>R语言不管什么操作对参数都是传值不传址(原始变量不会被修改)</strong>.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">    fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gsub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sub</span></span><br><span class="line"><span class="comment"># 将每个元素中的Adam替换为world</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始的text的内容还是没有发生改变</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, Adam!"</span>      <span class="string">"Hi, Adam!"</span>          <span class="string">"How are you, Adam."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gsub</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取表达式</span></span><br><span class="line"><span class="comment"># 使用转义字符+数字表示分组</span></span><br><span class="line">sub(pattern = <span class="string">".*(Adam).*"</span>, replacement = <span class="string">"\\1"</span>, text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Adam"</span> <span class="string">"Adam"</span> <span class="string">"Adam"</span></span><br></pre></td></tr></table></figure><p></p><p><code>sub</code>和<code>gsub</code>的区别：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改text内容</span></span><br><span class="line">text &lt;- c(<span class="string">"Hellow, Adam! Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub只会替换第一次出现的</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! Adam"</span> <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而gsub会将所有的都进行替换</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! world"</span> <span class="string">"Hi, world!"</span>           <span class="string">"How are you, world."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串提取"><a href="#字符串提取" class="headerlink" title="字符串提取"></a>字符串提取</h2><h3 id="substr和substring函数"><a href="#substr和substring函数" class="headerlink" title="substr和substring函数"></a>substr和substring函数</h3><p><code>substr</code>和<code>substring</code>函数<strong>通过位置进行字符串拆分或提取</strong>，它们<strong>本身并不使用正则表达式</strong>，但是结合正则表达式函数<code>regexpr</code>、<code>gregexpr</code>或<code>regexec</code>使用可以非常方便地从大量文本中提取所需信息。两者的参数设置基本相同：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substr(x, start, <span class="keyword">stop</span>)</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>)</span><br><span class="line">substr(x, start, <span class="keyword">stop</span>) &lt;- value</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>) &lt;- value</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>均为要拆分的字串向量</li><li><code>start/first</code> 为截取的起始位置向量</li><li><code>stop/last</code> 为截取字串的终止位置向量</li></ul><p>两个函数在返回值上存在差异：</p><ul><li>substr返回的字串个数等于第一个参数(要拆分的字串向量)的长度</li><li>substring返回字串个数等于三个参数中最长向量长度(要拆分的字串向量、起始位置向量、终止位置向量)，短向量循环使用</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">"123456789"</span></span><br><span class="line"><span class="comment"># 截取的区间是2-4、4-5、2-8(单向量循环使用)</span></span><br><span class="line"><span class="comment"># 因为x的长度为1，所以只会输出第一个2-4的结果</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># substring使用是输出最长向量长度的子串</span></span><br><span class="line">substring(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"45"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>关于短向量循环使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"123456789"</span>, <span class="string">"abcdefghijklmnopq"</span>)</span><br><span class="line"><span class="comment"># 因为x的长度为2，所以输出了两个</span></span><br><span class="line"><span class="comment"># 另外，x向量也会循环使用，2-4切数字、4-5切字母</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span> <span class="string">"de"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于x也可以循环可以看看substring</span></span><br><span class="line"><span class="comment"># 2-4切数字、4-5切字母、2-8切数字</span></span><br><span class="line">substring(x,c(<span class="number">2</span>,<span class="number">4</span>),c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"de"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>用<code>substring</code>函数可以很方便地把<code>DNA/RNA</code>序列进行<strong>三联拆分（用于蛋白质翻译）</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到随机序列</span></span><br><span class="line">bases = c(<span class="string">"A"</span>, <span class="string">"T"</span>, <span class="string">"G"</span>, <span class="string">"C"</span>)</span><br><span class="line">DNA = paste(sample(bases, <span class="number">12</span>, replace = <span class="literal">T</span>), collapse = <span class="string">""</span>)</span><br><span class="line">DNA</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCTGTCGGCTGC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三联拆分</span></span><br><span class="line">substring(DNA, seq(<span class="number">1</span>, <span class="number">10</span>, by = <span class="number">3</span>), seq(<span class="number">3</span>, <span class="number">12</span>, by = <span class="number">3</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCT"</span> <span class="string">"GTC"</span> <span class="string">"GGC"</span> <span class="string">"TGC"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串显示控制"><a href="#字符串显示控制" class="headerlink" title="字符串显示控制"></a>字符串显示控制</h2><h3 id="显示宽度-strtrim函数"><a href="#显示宽度-strtrim函数" class="headerlink" title="显示宽度-strtrim函数"></a>显示宽度-strtrim函数</h3><p>用于将字符串修剪到特定的显示宽度，其用法为<code>strtrim(x, width)</code>，<strong>返回字符串向量的长度等于x的长度</strong>。因为是“修剪”，所以<strong>只能去掉多余的字符不能增加其他额外的字符(这就感觉很鸡肋了。。。。)</strong>; 如果<strong>字符串本身的长度小于width，得到的是原字符串</strong>，别指望它会用空格或其他什么字符补齐：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大于width的字符部分会被去除</span></span><br><span class="line">strtrim(c(<span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>), c(<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"a"</span>      <span class="string">"abcde"</span>  <span class="string">"abcdef"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不足width的字符会输出原字符串</span></span><br><span class="line">strtrim(c(<span class="number">1</span>, <span class="number">123</span>, <span class="number">1234567</span>), <span class="number">4</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"1"</span>    <span class="string">"123"</span>  <span class="string">"1234"</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串段落化-strwrap函数"><a href="#字符串段落化-strwrap函数" class="headerlink" title="字符串段落化-strwrap函数"></a>字符串段落化-strwrap函数</h3><p>strwrap函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串，其帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strwrap(x, width = <span class="number">0.9</span> * getOption(<span class="string">"width"</span>), indent = <span class="number">0</span>,</span><br><span class="line">        exdent = <span class="number">0</span>, prefix = <span class="string">""</span>, simplify = <span class="literal">TRUE</span>, initial = prefix)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>表示待处理的字符向量</li><li><code>width</code>表示每行的宽度</li><li><code>indent</code>表示首行缩进</li><li><code>exdent</code>表示除首行外的其他行的缩进</li><li><code>simplify</code>表示结果的显示形式，<code>TRUE</code>表示返回向量，<code>FALSE</code>表示返回列表</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"Each character string in the input is first split into paragraphs\n(or lines containing whitespace only).  The paragraphs are then\nformatted by breaking lines at word boundaries.  The target\ncolumns for wrapping lines and the indentation of the first and\nall subsequent lines of a paragraph can be controlled\nindependently."</span></span><br><span class="line">str2 = rep(str1, <span class="number">2</span>)</span><br><span class="line">strwrap(str2, width = <span class="number">80</span>, indent = <span class="number">2</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">2</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">3</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">4</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">5</span>] <span class="string">"controlled independently."</span>                                                    </span><br><span class="line">  [<span class="number">6</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">7</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">9</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">10</span>] <span class="string">"controlled independently."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><p>##参考链接</p><ul><li><a href="https://blog.csdn.net/duqi_yc/article/details/9817243" target="_blank" rel="noopener">R字符串处理-grep/grepl/sub/gsub等等</a></li><li><a href="https://likan.info/cn/post/pattern-matching-and-replacement/" target="_blank" rel="noopener">R 中字符串的查找和替换</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了&lt;strong&gt;R中的字符向量处理函数&lt;/strong&gt;，主要包括&lt;strong&gt;字符数统计和字符翻译&lt;/strong&gt;、&lt;strong&gt;字符串连接&lt;/strong&gt;、&lt;strong&gt;字符串拆分&lt;/strong&gt;、&lt;strong&gt;字符串查询&lt;/strong&gt;、&lt;strong&gt;字符串替换&lt;/strong&gt;、&lt;strong&gt;字符串提取&lt;/strong&gt;、&lt;strong&gt;字符串显示控制&lt;/strong&gt;等。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="R" scheme="http://showteeth.tech/categories/R/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/R/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python中常用的snippets</title>
    <link href="http://showteeth.tech/posts/21065.html"/>
    <id>http://showteeth.tech/posts/21065.html</id>
    <published>2019-08-24T09:05:46.000Z</published>
    <updated>2019-08-24T16:03:33.988Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。</p></div><a id="more"></a><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> qgrid</span><br><span class="line"><span class="comment"># qgrid.show_grid(df, show_toolbar=True)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"><span class="comment"># ignore warning info</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># sns.set_style("white")</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.style.use('ggplot')</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># interactive visualization</span></span><br><span class="line"><span class="keyword">from</span> bokeh.palettes <span class="keyword">import</span> Spectral11</span><br><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_notebook, show</span><br><span class="line"><span class="keyword">from</span> bokeh.models <span class="keyword">import</span> LinearAxis, Range1d</span><br><span class="line">output_notebook()</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse, sys, os, errno</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,format=<span class="string">"%(levelname)s-%(filename)s:[%(lineno)d]-%(message)s"</span>)</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/categories/Python/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
    
      <category term="其他技巧整理" scheme="http://showteeth.tech/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系列之正则表达式系统梳理</title>
    <link href="http://showteeth.tech/posts/28940.html"/>
    <id>http://showteeth.tech/posts/28940.html</id>
    <published>2019-08-23T03:15:01.000Z</published>
    <updated>2019-10-17T05:19:45.231Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">正则表达式学习</a></li><li><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">正则表达式在线练习</a></li><li><a href="http://aandds.com/blog/lang-regex.html" target="_blank" rel="noopener">Regular Expressions</a></li><li><a href="https://juejin.im/post/5b4a9539f265da0f521de210" target="_blank" rel="noopener">正则中关于环视（lookaround）的小例子</a></li><li><a href="https://zhuanlan.zhihu.com/p/50789818" target="_blank" rel="noopener">正则表达式中 Lookaround</a></li><li><a href="http://www.ayqy.net/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">正则表达式学习笔记</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
      <category term="常用内容总结" scheme="http://showteeth.tech/categories/Linux/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
