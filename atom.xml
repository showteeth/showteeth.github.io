<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>showteeth&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://showteeth.tech/"/>
  <updated>2019-03-15T13:47:27.295Z</updated>
  <id>http://showteeth.tech/</id>
  
  <author>
    <name>showteeth</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell解析命令行过程以及eval命令</title>
    <link href="http://showteeth.tech/posts/29719.html"/>
    <id>http://showteeth.tech/posts/29719.html</id>
    <published>2019-03-15T13:46:10.000Z</published>
    <updated>2019-03-15T13:47:27.295Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的过程以及eval命令</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="基础" scheme="http://showteeth.tech/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML常用字符实体</title>
    <link href="http://showteeth.tech/posts/45689.html"/>
    <id>http://showteeth.tech/posts/45689.html</id>
    <published>2019-03-15T10:33:39.000Z</published>
    <updated>2019-03-15T13:17:01.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括<code>特色字符实体</code>、<code>常用字符实体</code>、<code>货币类字符实体</code>、<code>数字类字符实体</code>、<code>方向类字符实体</code>以及<code>其他字符实体</code>，以供需要时查阅</p></div><a id="more"></a><h2 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h2><p>一些字符在 HTML 中拥有特殊的含义，比如小于号<code>&lt;</code>用于定义 HTML 标签的开始，在这种情况下如果我们<strong>希望浏览器正确地显示这些字符</strong>，我们必须在 HTML 源码中<strong>插入字符实体</strong>来使HTML不将其当做具有特殊含义的字符，例如，要在 HTML 文档中显示小于号，我们需要这样写：<code>&amp;lt;</code> 或者 <code>&amp;#60;</code>。</p><p><strong>字符实体有三部分：</strong></p><ul><li>一个和号<code>&amp;</code></li><li>一个实体名称，或者 <code>#</code> 和一个实体编号</li><li>以及一个分号 <code>;</code></li></ul><p>使用<strong>实体名称</strong>而<strong>不是实体编号</strong>的<strong>好处</strong>在于，名称相对来说更容易记忆；而这么做的<strong>坏处</strong>是，并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。</p><p><strong>注意：实体对大小写敏感。</strong></p><hr><h2 id="特色HTML字符实体"><a href="#特色HTML字符实体" class="headerlink" title="特色HTML字符实体"></a>特色HTML字符实体</h2><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:40%}</style><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线，常用作菜单或导航中的分隔符</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>圆点，有时被用来作为菜单分隔符</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头，常用作网页“返回页面顶部”标识</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元标识</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2，数学中的平方，在数字处理中常用到，例如：<strong>1000²</strong></td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>心型，用来表达你的心</td></tr></tbody></table><hr><h2 id="常用HTML字符实体"><a href="#常用HTML字符实体" class="headerlink" title="常用HTML字符实体"></a>常用HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&nbsp;</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td>空格</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td>&amp;#38;</td><td>and符号，与</td></tr><tr><td>"</td><td>&amp;quot;</td><td>&amp;#34;</td><td>引号</td></tr><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>®</td><td>&amp;reg;</td><td>&amp;#187;</td><td>注册标志</td></tr><tr><td>™</td><td>&amp;trade;</td><td>&amp;#153;</td><td>商标标志</td></tr><tr><td>“</td><td>&amp;ldquo;</td><td>&amp;#147;</td><td>左双引号</td></tr><tr><td>”</td><td>&amp;rdquo;</td><td>&amp;#148;</td><td>右双引号</td></tr><tr><td>‘</td><td>&amp;lsquo;</td><td>&amp;#145;</td><td>做单引号</td></tr><tr><td>’</td><td>&amp;rsquo;</td><td>&amp;#146;</td><td>右单引号</td></tr><tr><td>«</td><td>&amp;laquo;</td><td>&amp;#171;</td><td>左三角双引号</td></tr><tr><td>»</td><td>&amp;raquo;</td><td>&amp;#187;</td><td>右三角双引号</td></tr><tr><td>‹</td><td>&amp;lsaquo;</td><td>&amp;#8249;</td><td>左三角单引号</td></tr><tr><td>›</td><td>&amp;rsaquo;</td><td>&amp;#8250;</td><td>右三角单引号</td></tr><tr><td>§</td><td>&amp;sect;</td><td>&amp;#167;</td><td>章节标志</td></tr><tr><td>¶</td><td>&amp;para;</td><td>&amp;#182;</td><td>段落标志</td></tr><tr><td>•</td><td>&amp;bull;</td><td>&amp;#149;</td><td>列表圆点（大）</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>列表圆点（中）</td></tr><tr><td>…</td><td>&amp;hellip;</td><td>&amp;#8230;</td><td>省略号</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线</td></tr><tr><td>¦</td><td>&amp;brvbar;</td><td>&amp;#166;</td><td>断的竖线</td></tr><tr><td>–</td><td>&amp;ndash;</td><td>&amp;#150;</td><td>短破折号</td></tr><tr><td>—</td><td>&amp;mdash;</td><td>&amp;#151;</td><td>长破折号</td></tr></tbody></table><hr><h2 id="货币类HTML字符实体"><a href="#货币类HTML字符实体" class="headerlink" title="货币类HTML字符实体"></a>货币类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>¤</td><td>&amp;curren;</td><td>&amp;#164;</td><td>一般货币符号</td></tr><tr><td>$</td><td>&nbsp;</td><td>&amp;#36;</td><td>美元符号</td></tr><tr><td>¢</td><td>&amp;cent;</td><td>&amp;#162;</td><td>分</td></tr><tr><td>£</td><td>&amp;pound;</td><td>&amp;#163;</td><td>英镑</td></tr><tr><td>¥</td><td>&amp;yen;</td><td>&amp;#165;</td><td>日元</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元</td></tr></tbody></table><hr><h2 id="数字类HTML字符实体"><a href="#数字类HTML字符实体" class="headerlink" title="数字类HTML字符实体"></a>数字类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&amp;#60;</td><td>小于号</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&amp;#62;</td><td>大于号</td></tr><tr><td>≤</td><td>&amp;le;</td><td>&amp;#8804;</td><td>小于等于号</td></tr><tr><td>≥</td><td>&amp;ge;</td><td>&amp;#8805;</td><td>大于等于号</td></tr><tr><td>×</td><td>&amp;times;</td><td>&amp;#215;</td><td>乘号</td></tr><tr><td>÷</td><td>&amp;divide;</td><td>&amp;#247;</td><td>除号</td></tr><tr><td>−</td><td>&amp;minus;</td><td>&amp;#8722;</td><td>减号</td></tr><tr><td>±</td><td>&amp;plusmn;</td><td>&amp;#177;</td><td>加/减 号</td></tr><tr><td>≠</td><td>&amp;ne;</td><td>&amp;#8800;</td><td>不等于号</td></tr><tr><td>¹</td><td>&amp;sup1;</td><td>&amp;#185;</td><td>上标1</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2</td></tr><tr><td>³</td><td>&amp;sup3;</td><td>&amp;#179;</td><td>上标3</td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>¼</td><td>&amp;frac14;</td><td>&amp;#188;</td><td>四分之一</td></tr><tr><td>¾</td><td>&amp;frac34;</td><td>&amp;#190;</td><td>四分之三</td></tr><tr><td>‰</td><td>&amp;permil;</td><td>&amp;#8240;</td><td>千分率</td></tr><tr><td>°</td><td>&amp;deg;</td><td>&amp;#176;</td><td>度</td></tr><tr><td>√</td><td>&amp;radic;</td><td>&amp;#8730;</td><td>平方根</td></tr><tr><td>∞</td><td>&amp;infin;</td><td>&amp;#8734;</td><td>无限大</td></tr></tbody></table><hr><h2 id="方向类HTML字符实体"><a href="#方向类HTML字符实体" class="headerlink" title="方向类HTML字符实体"></a>方向类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>←</td><td>&amp;larr;</td><td>&amp;#8592;</td><td>左箭头</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头</td></tr><tr><td>→</td><td>&amp;rarr;</td><td>&amp;#8594;</td><td>右箭头</td></tr><tr><td>↓</td><td>&amp;darr;</td><td>&amp;#8595;</td><td>下箭头</td></tr><tr><td>↔</td><td>&amp;harr;</td><td>&amp;#8596;</td><td>左右箭头</td></tr><tr><td>↵</td><td>&amp;crarr;</td><td>&amp;#8629;</td><td>回车箭头</td></tr><tr><td>⌈</td><td>&amp;lceil;</td><td>&amp;#8968;</td><td>左上限</td></tr><tr><td><strong>⌉</strong></td><td>&amp;rceil;</td><td>&amp;#8969;</td><td>右上限</td></tr><tr><td><strong>⌊</strong></td><td>&amp;lfloor;</td><td>&amp;#8970;</td><td>左下限</td></tr><tr><td><strong>⌋</strong></td><td>&amp;rfloor;</td><td>&amp;#8971;</td><td>右下限</td></tr></tbody></table><hr><h2 id="其他HTML字符实体"><a href="#其他HTML字符实体" class="headerlink" title="其他HTML字符实体"></a>其他HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>♠</td><td>&amp;spades;</td><td>&amp;#9824;</td><td>黑桃</td></tr><tr><td>♣</td><td>&amp;clubs;</td><td>&amp;#9827;</td><td>梅花</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>红桃，心</td></tr><tr><td>♦</td><td>&amp;diams;</td><td>&amp;#9830;</td><td>方块牌</td></tr><tr><td>◊</td><td>&amp;loz;</td><td>&amp;#9674;</td><td>菱形</td></tr><tr><td>†</td><td>&amp;dagger;</td><td>&amp;#8224;</td><td>匕首</td></tr><tr><td>‡</td><td>&amp;Dagger;</td><td>&amp;#8225;</td><td>双剑号</td></tr><tr><td>¡</td><td>&amp;iexcl;</td><td>&amp;#161;</td><td>反向感叹号</td></tr><tr><td>¿</td><td>&amp;iquest;</td><td>&amp;#191;</td><td>反向问号</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/cutdragonhit/p/9785350.html" target="_blank" rel="noopener">HTML实体符号</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/4159374.html" target="_blank" rel="noopener">网页中常用HTML字符实体</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括&lt;code&gt;特色字符实体&lt;/code&gt;、&lt;code&gt;常用字符实体&lt;/code&gt;、&lt;code&gt;货币类字符实体&lt;/code&gt;、&lt;code&gt;数字类字符实体&lt;/code&gt;、&lt;code&gt;方向类字符实体&lt;/code&gt;以及&lt;code&gt;其他字符实体&lt;/code&gt;，以供需要时查阅&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="http://showteeth.tech/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://showteeth.tech/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux通配符和正则表达式及其区别</title>
    <link href="http://showteeth.tech/posts/37480.html"/>
    <id>http://showteeth.tech/posts/37480.html</id>
    <published>2019-03-15T07:42:47.000Z</published>
    <updated>2019-03-15T13:45:03.705Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像<code>awk</code>、<code>sed</code>、<code>grep</code>使用正则表达式、像<code>find</code>、<code>ls</code>、<code>cp</code>使用通配符。</p></div><a id="more"></a><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls <span class="built_in">test</span>*.txt</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls d*.txt</span><br><span class="line">  ls: cannot access d*.txt: No such file or directory</span><br></pre></td></tr></table></figure><hr><h3 id="通配符的作用方式"><a href="#通配符的作用方式" class="headerlink" title="通配符的作用方式"></a>通配符的作用方式</h3><p><strong>通配符是由<code>shell</code>处理的</strong>(不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍), 它只会出现在命令的<strong>参数</strong>里(它不用在命令名称里， 也不用在操作符上)。<strong>当shell在参数中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个<u>普通字符传递给命令</u>，然后再由命令进行处理</strong>。总之，<strong>通配符实际上就是一种shell实现的路径扩展功能</strong>。在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。</p><p>我们回过头分析上面命令：</p><ul><li>在第2个命令中，<strong>test*.txt 实际shell搜索文件,找到了符合条件的文件，命令会变成</strong>：<code>ls test2.txt test3.txt test.txt</code> ,实际在执行<code>ls</code>时候传给它的<strong>参数</strong>是test2.txt test3.txt test.txt。</li><li>而命令3，<code>d*.txt</code> 由于当前目录下面没有这样的文件或目录，直接将<code>d*.txt</code>作为普通字符传给<code>ls</code>作为参数。这个时候<code>*</code>只是一个普通的 <code>ls</code>参数而已，已经<strong>失去了它通配意义</strong>。由于找不到文件，所以会出现：无法访问提示！</li></ul><p>了解了shell通配符，我们现在看下，shell常见通配符有哪些了。</p><hr><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>*</td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td>?</td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td>[list]</td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td>[!list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[^list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[^0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[c1-c2]</td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)<strong>其一字符串</strong></td><td>a{abc,xyz,123}b：a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><div class="note info"><p>需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种</p></div><hr><h3 id="通配符示例"><a href="#通配符示例" class="headerlink" title="通配符示例"></a>通配符示例</h3><p><code>[!list]</code> 和<code>[^list]</code>：</p><blockquote><p><code>ls test[^1-2].txt</code><br>test3.txt</p></blockquote><blockquote><p><code>ls test[!1-2].txt</code><br>test3.txt</p></blockquote><p>注意不会出现test.txt，因为test和.txt之间必须要有一个字符，而test.txt不具备这个条件</p><hr><p><br></p><h2 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>^word</td><td>待搜寻的字串(word)在<strong>行首</strong></td><td>grep -n ‘^#’ regular_express.txt：搜寻行首为 # 开始的那一行，并列出行号</td></tr><tr><td>word$</td><td>待搜寻的字串(word)在<strong>行尾</strong></td><td>grep -n ‘!$’ regular_express.txt：将行尾为 ! 的那一行打印出来，并列出行号</td></tr><tr><td>.</td><td>代表<strong>一定有一个任意字符</strong>的字符</td><td>grep -n ‘e.e’ regular_express.txt：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定<strong>仅有一个字符，而空白字符也是字符！</strong></td></tr><tr><td>\</td><td>转义字符，将特殊符号的特殊意义去除</td><td>grep -n \’ regular_express.txt：搜寻含有单引号 ‘ 的那一行</td></tr><tr><td>*</td><td>重复<strong>零个到无穷多个的前一个字符</strong></td><td>grep -n ‘ess*’ regular_express.txt：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字串。另外，之前也可以紧接着一个 RE 字符，例如任意字符则为 “.”</td></tr><tr><td>[list]</td><td>字符集合，匹配list 中的任意单个字符</td><td>grep -n ‘g[ld]’ regular_express.txt：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思</td></tr><tr><td>[n1-n2]</td><td>字符范围，匹配n1-n2中的任意单个字符</td><td>grep -n ‘[A-Z]’ regular_express.txt：搜寻含有大写字母的那一行。需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关。</td></tr><tr><td>[^list]</td><td>字符集合，匹配 除list 中的任意单一字符(一定要有一个)</td><td>不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字</td></tr><tr><td>{n,m}</td><td>连续 n 到 m 个的前一个字符；若为 {n} 则是连续 n 个的前一个字符；若是 {n,} 则是连续 n 个以上的前一个字符</td><td>grep -n ‘go{2,3}g’ regular_express.txt：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)</td></tr></tbody></table><hr><h3 id="延伸正则表达式字符"><a href="#延伸正则表达式字符" class="headerlink" title="延伸正则表达式字符"></a>延伸正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>重复<strong>一个或一个以上的前一个字符</strong></td><td>egrep -n ‘go+d’ regular_express.txt：搜寻 (god) (good) (goood)… 等等的字串，那个 o+ 代表一个以上的 o</td></tr><tr><td>?</td><td><strong>零个或一个的前一个字符</strong></td><td>egrep -n ‘go?d’ regular_express.txt：搜寻 (gd) (god) 这两个字串，那个 o? 代表空的或 1 个 o</td></tr><tr><td>&#124;</td><td>用<strong>或( or )的方式找出数个字串</strong></td><td>egrep -n ‘gd&#124;good’ regular_express.txt：搜寻 gd 或 good 这两个字串</td></tr><tr><td>()</td><td>找出<strong>群组字串</strong></td><td>egrep -n ‘g(la&#124;oo)d’ regular_express.txt：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来</td></tr><tr><td>()+</td><td><strong>多个重复群组的判别</strong></td><td>echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’</td></tr></tbody></table><div class="note info"><p><code>grep</code> <strong>默认仅支持基础正则表达式</strong>，如果要<strong>使用延伸型正则表达式</strong>，你可以使用 <code>grep -E</code> ， 不过更建议直接使用 <code>egrep</code>！直接区分指令比较好记忆！其实 <code>egrep</code> 与 <code>grep -E</code> 是类似命令别名的关系啦！</p></div><h2 id="通配符和正则表达式关系"><a href="#通配符和正则表达式关系" class="headerlink" title="通配符和正则表达式关系"></a>通配符和正则表达式关系</h2><ul><li>在<strong>文本过滤工具里，都是用正则表达式</strong>，比如像<code>awk</code>、<code>sed</code>、<code>grep</code>等，是针对文件的内容的；而<strong>通配符多用在文件名</strong>上，比如<code>find</code>、<code>ls</code>、<code>cp</code>等等</li><li>正则表达式中有部分与通配符是相近的含义，如<code>[list]</code>、<code>[n1-n2]</code>、<code>[^list]</code>，但也有一些差异非常大，如<code>*</code> <strong>在通配符中表示匹配0或多个</strong>字符(可以独立使用)，但<strong>在正则表达式中表示重复零个到无穷多个的<u>前一个字符</u></strong>(不能独立使用)</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://blog.csdn.net/swjtuwyp/article/details/51817472" target="_blank" rel="noopener">linux通配符和正则表达式</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;使用正则表达式、像&lt;code&gt;find&lt;/code&gt;、&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;cp&lt;/code&gt;使用通配符。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用内容总结" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell-循环结构</title>
    <link href="http://showteeth.tech/posts/16486.html"/>
    <id>http://showteeth.tech/posts/16486.html</id>
    <published>2019-03-15T03:04:40.000Z</published>
    <updated>2019-03-15T16:03:01.477Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环适用于<strong>已经知道需要进行多少次的循环</strong>，所以for循环也叫<strong>固定循环</strong>。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      程序段</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p>为了防止可能的字符分割(变量存在空格)问题，con1 con2 con3都需要被引用(使用双引号括起来)，关于字符分割的示例可以查看<a href="http://showteeth.tech/posts/58105.html">shell-if条件测试</a></p></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用变量进行循环"><a href="#使用变量进行循环" class="headerlink" title="使用变量进行循环"></a>使用变量进行循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line">field1=$(cut -d <span class="string">' '</span> -f 1 test.txt)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;field1&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>this<br>that<br>there<br>those</p></blockquote><blockquote><p><code>name=&quot;my name is test&quot;</code><br><code>for i in ${name};do echo $i;done</code></p></blockquote><p><strong>输出</strong>：</p><blockquote><p>my<br>name<br>is<br>test</p></blockquote><hr><h4 id="使用seq命令进行循环"><a href="#使用seq命令进行循环" class="headerlink" title="使用seq命令进行循环"></a>使用seq命令进行循环</h4><p><strong>seq命令的用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line"></span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -f, --format=FORMAT      use <span class="built_in">printf</span> style floating-point FORMAT</span><br><span class="line">  -s, --separator=STRING   use STRING to separate numbers (default: \n)</span><br><span class="line">  -w, --equal-width        equalize width by padding with leading zeroes</span><br></pre></td></tr></table></figure><p></p><p><strong>默认用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>设置步长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 2 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>1<br>3<br>5</p></blockquote><p><strong>-w设置输出等长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w 1 2 12`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>01<br>03<br>05<br>07<br>09<br>11</p></blockquote><hr><h4 id="使用特殊符号-进行循环"><a href="#使用特殊符号-进行循环" class="headerlink" title="使用特殊符号{}进行循环"></a>使用特殊符号{}进行循环</h4><p>对<strong>数字</strong>循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>对<strong>字母</strong>循环：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a&#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..2&#125;&#123;a..d&#125;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>a<br>b<br>c<br>d</p></blockquote><blockquote><p>aa<br>ab<br>ac<br>ad</p></blockquote><blockquote><p>1a<br>1b<br>1c<br>1d<br>2a<br>2b<br>2c<br>2d</p></blockquote><p>特殊符号<code>{}</code>中的<strong>两个小数点来代表连续出现的意思</strong>，更多关于特殊符号<code>{}</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用特殊符号-进行循环-1"><a href="#使用特殊符号-进行循环-1" class="headerlink" title="使用特殊符号(())进行循环"></a>使用特殊符号(())进行循环</h4><p><strong>使用形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> （（ 初始值; 限制值; 执行步阶 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i=i+2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i+=2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>特殊符号<code>(())</code>表示<strong>执行计算</strong>，和linux <code>let</code>命令相似，更多关于特殊符号<code>(())</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用通配符进行循环"><a href="#使用通配符进行循环" class="headerlink" title="使用通配符进行循环"></a>使用通配符进行循环</h4><p>通配符主要有星号(<code>*</code>)和问号(<code>?</code>)，用来<strong>模糊搜索文件</strong>。关于shell中常见的通配符以及通配符和正则表达式的区别请参考<a href="http://showteeth.tech/posts/37480.html">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">test</span>*.txt</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  test2.txt  </span><br><span class="line">  test3.txt  </span><br><span class="line">  test.txt  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="comment">#           ^  Bash 在检测到通配表达式时，</span></span><br><span class="line"><span class="comment">#+             会进行文件名扩展。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ls -l <span class="string">"<span class="variable">$file</span>"</span>  <span class="comment"># 列出 $PWD（当前工作目录）下的所有文件。</span></span><br><span class="line">  <span class="comment">#  回忆一下，通配符 "*" 会匹配所有的文件名，</span></span><br><span class="line">  <span class="comment">#+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  如果没有匹配到文件，那么它将会扩展为它自身。</span></span><br><span class="line">  <span class="comment">#  为了防止出现这种情况，需要设置 nullglob 选项。</span></span><br><span class="line">  <span class="comment">#+    (shopt -s nullglob)。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> [jx]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="variable">$file</span>    <span class="comment"># 删除当前目录下所有以 "j" 或 "x" 开头的文件。</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Removed file \"<span class="variable">$file</span>\""</span>.</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="每个元素多个参数"><a href="#每个元素多个参数" class="headerlink" title="每个元素多个参数"></a>每个元素多个参数</h4><p>用于循环的每个参数可以继续分解为多个参数，这里使用 <code>set</code> 命令<strong>强制解析循环内容中的每一个元素</strong>，并将元素的每一个部分分配给位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个行星与其到太阳的距离放在一起。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> planet <span class="keyword">in</span> <span class="string">"Mercury 36"</span> <span class="string">"Venus 67"</span> <span class="string">"Earth 93"</span> <span class="string">"Mars 142"</span> <span class="string">"Jupiter 483"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">set</span> -- <span class="variable">$planet</span>  <span class="comment">#  解析变量 "planet"</span></span><br><span class="line">                  <span class="comment">#+ 并将其每个部分赋值给位置参数。</span></span><br><span class="line">  <span class="comment"># "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。</span></span><br><span class="line">  <span class="comment"># 你可以使用数组来保存</span></span><br><span class="line">  <span class="comment">#         original_params=("$@")</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>        <span class="variable">$2</span>,000,000 miles from the sum"</span></span><br><span class="line">  <span class="comment">#-------两个制表符---将后面的一系列 0 连到参数 $2 上。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>Mercury 36,000,000 miles from the sum<br>Venus 67,000,000 miles from the sum<br>Earth 93,000,000 miles from the sum<br>Mars 142,000,000 miles from the sum<br>Jupiter 483,000,000 miles from the sum</p></blockquote><p>示例来源于<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part3/11_1_loops.html" target="_blank" rel="noopener">这本书</a></p><hr><h4 id="集成管道符"><a href="#集成管道符" class="headerlink" title="集成管道符"></a>集成管道符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$( find $directory -type 1 )</span>"</span>   <span class="comment"># -type 1 = 符号链接</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span> | sort</span><br></pre></td></tr></table></figure><blockquote><p><code>for i in test*.txt;do echo $i;done |wc -l</code></p></blockquote><blockquote><p>3</p></blockquote><hr><p><br></p><h2 id="while-until循环"><a href="#while-until循环" class="headerlink" title="while/until循环"></a>while/until循环</h2><p><code>while/until</code>循环适用于条件判断，<strong>条件成立则进行循环，具体多少次的循环不知道</strong>，只要条件成立即可，所以<code>while/until</code>循环也叫<strong>不定循环</strong>。<code>while</code>和<code>until</code>循环在进行条件判断时执行的是完全相反的操作，<code>while</code>是条件成立则进行循环，而<code>until</code>这是条件成立终止循环，是完全相反的，所以后续的学习主要集中于使用较多的<code>while</code>循环，<code>until</code>循环一样的道理，只是将条件判断改变即可。</p><h3 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止</span></span><br><span class="line"><span class="keyword">while</span> [ condition ]  <span class="comment"># 括号内的状态就是判断式</span></span><br><span class="line"><span class="keyword">do</span>                   <span class="comment"># do 是循环的开始！</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span>                 <span class="comment"># done 是循环的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 condition 条件成立时，就终止循环， 否则就持续进行循环的程序段(和while循环相反)</span></span><br><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>while</code>和<code>until</code>循环中当<strong>使用条件测试进行循环时和前面在if条件测试分支结构中使用的条件测试是相同的</strong>，具体的各种测试形式这里就不在列出，后续可以查看<a href="http://showteeth.tech/posts/58105.html">这篇文章</a></p></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用条件测试进行循环"><a href="#使用条件测试进行循环" class="headerlink" title="使用条件测试进行循环"></a>使用条件测试进行循环</h4><p>和 <code>if</code> 一样， 使用条件测试进行循环时 <code>while</code> 会计算一系列命令的退出状态。只要<strong>退出状态为零(条件测试执行成功)，它就执行循环内的命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=0  <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0  <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]   <span class="comment"># 变量使用双引号在进行变量替换的同时防止字符分割</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+1))   <span class="comment"># 每次 i 都会增加 1 </span></span><br><span class="line">    s=$((<span class="variable">$s</span>+<span class="variable">$i</span>))  <span class="comment"># 每次都会加总一次！</span></span><br><span class="line">                  <span class="comment"># 使用了特殊符号$(())来执行计算</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is  <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p><mark>如果一个 while 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止，这个也和if命令相同:</mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环，输出this is true</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">false</span>;<span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="循环读取文件"><a href="#循环读取文件" class="headerlink" title="循环读取文件"></a>循环读取文件</h4><p>使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this is a test<br>that is a test<br>there is a test<br>those are tests</p></blockquote><p>也可以<strong>按字段读取文件的每行内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 field3 field4 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field3</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field4</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this<br>is a test<br>that<br>is a test<br>there<br>is a test<br>those<br>are tests</p></blockquote><blockquote><p>this<br>is<br>a<br>test<br>that<br>is<br>a<br>test<br>there<br>is<br>a<br>test<br>those<br>are<br>tests<br><em>这是空行</em></p></blockquote><div class="note info"><ul><li>为了重定向文件到循环中，可以将重定向操作符放置到 <code>done</code> 语句之后。循环使用 <code>read</code> 从重定向文件中读取字段；<strong>这个 <code>read</code> 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾，这时候它的退出状态为非零数值，因此终止循环</strong>。</li><li><strong>指定字段数小于每行字段数</strong>：第一个字段为第一个空格之前的内容，剩下的所有字段为第二个字段(这里只指定了两个字段来读取每一行)</li><li><strong>指定字段数大于每行字段数</strong>：不足的字段使用空格填补</li></ul></div><hr><h4 id="集成管道符-1"><a href="#集成管道符-1" class="headerlink" title="集成管道符"></a>集成管道符</h4><p>上面使用使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件的操作也可以使用管道符实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt|<span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>因为管道将会在<strong>子 shell</strong> 中执行循环，<strong>当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失</strong>，记住这一点很重要(这个还没测试过，先mark一下)</p></div><hr><p><br></p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break-终止循环"><a href="#break-终止循环" class="headerlink" title="break-终止循环"></a>break-终止循环</h3><p><code>break</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳出当前所在的循环体(终止循环)，执行循环体之后的语句</strong>。</p><h4 id="终止单层循环"><a href="#终止单层循环" class="headerlink" title="终止单层循环"></a>终止单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"></span><br><span class="line">  <span class="built_in">break</span>---------+</span><br><span class="line">                |</span><br><span class="line">  commands      |</span><br><span class="line">  commands      | 跳出(终止)循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">                |</span><br><span class="line"><span class="keyword">done</span>            |</span><br><span class="line">                |</span><br><span class="line">commands&lt;-------+</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; <span class="built_in">break</span>  <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>在循环中一旦发现目录，则立即停止循环并退出</p><hr><h4 id="终止多层循环"><a href="#终止多层循环" class="headerlink" title="终止多层循环"></a>终止多层循环</h4><p><mark><code>break</code> 命令可以接受一个参数，普通的 <code>break</code> 命令<strong>仅仅跳出其所在的那层循环</strong>，而 <code>break N</code> 命令则可以<strong>跳出其上 N 层的循环</strong></mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outerloop</span>:   "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> innerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$innerloop</span> "</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$innerloop</span>"</span> -eq 3 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">break</span> 2 <span class="comment"># 尝试一下 break 2 看看会发生什么。</span></span><br><span class="line">             <span class="comment"># （它同时中止了内层和外层循环。）</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>直接使用<code>break</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3<br>Group 2: 1 2 3<br>Group 3: 1 2 3<br>Group 4: 1 2 3<br>Group 5: 1 2 3</p></blockquote><p>使用了<code>break 2</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3</p></blockquote><p>可以发现使用<code>break 2</code>不仅跳出了本层循环，还跳出了本层循环的外层循环，也就是跳出了2层循环</p><hr><h3 id="continue-进行下一次循环"><a href="#continue-进行下一次循环" class="headerlink" title="continue-进行下一次循环"></a>continue-进行下一次循环</h3><p><code>continue</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</strong>。</p><h4 id="影响单层循环"><a href="#影响单层循环" class="headerlink" title="影响单层循环"></a>影响单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]&lt;-------+</span><br><span class="line"><span class="keyword">do</span>                         |</span><br><span class="line">                           |</span><br><span class="line">  commands                 | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">  commands                 |</span><br><span class="line">                           |</span><br><span class="line">  <span class="built_in">continue</span> ----------------+</span><br><span class="line"></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">commands</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -d <span class="string">"<span class="variable">$f</span>"</span> ] || <span class="built_in">continue</span>    <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line">    chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>如果是目录，添加权限；如果不是，跳过当前循环，continue 后面代码不再执行，而是直接执行下次循环。</p><hr><h4 id="影响多层循环"><a href="#影响多层循环" class="headerlink" title="影响多层循环"></a>影响多层循环</h4><p><mark>与 <code>break</code> 类似，<code>continue</code> 也可以接受一个参数，普通的 <code>continue</code> 命令<strong>仅仅影响其所在的那层循环</strong>，而 <code>continue N</code> 命令则可以<strong>影响其上 N 层的循环</strong></mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outer <span class="keyword">in</span> I II III IV V           <span class="comment"># 外层循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span>; <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outer</span>: "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> inner <span class="keyword">in</span> 1 2 3 4 5 6 7 8 9 10  <span class="comment"># 内层循环</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$inner</span>"</span> -eq 7 &amp;&amp; <span class="string">"<span class="variable">$outer</span>"</span> = <span class="string">"III"</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">continue</span> 2  <span class="comment"># 影响两层循环，包括“外层循环”。</span></span><br><span class="line">                  <span class="comment"># 将其替换为普通的 "continue"，那么只会影响内层循环。</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$inner</span> "</span>  <span class="comment"># 7 8 9 10 将不会出现在 "Group III."中。</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>直接使用<code>continue</code>的输出结果(只有第三组少了数字7)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6 8 9 10<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><p>使用了<code>continue 2</code>的输出结果(第三组7以后的数字全消失了)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><div class="note warning"><p><code>continue N</code> 结构<strong>不易理解并且可能在一些情况下有歧义，因此不建议使用</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>shell-if条件测试</title>
    <link href="http://showteeth.tech/posts/58105.html"/>
    <id>http://showteeth.tech/posts/58105.html</id>
    <published>2019-03-14T15:35:59.000Z</published>
    <updated>2019-03-15T15:34:21.814Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了shell中的条件测试命令，包括<code>test</code>命令、<code>[ ]</code>、<code>[[ ]]</code>、<code>(( ))</code>，主要介绍了前三个，其中<code>[ ]</code>和<code>[[ ]]</code>可以用在<strong>if条件测试分支结构</strong>中，两者之间的优缺点在文中也有讲解；也学习了<strong>if条件测试分支结构</strong>在多种情形下的多种形式以及<code>exit</code>命令设定程序退出状态</p></div><a id="more"></a><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>本来打算直接学习if判断分支结构，但是在阅读相关资料后发现if判断分支中的条件判断其实就是shell条件测试，所以这里先对shell的条件测试进行学习。shell的条件测试可以使用<code>test</code>命令、<code>[ ]</code>判断式、<code>[[ ]]</code>判断式以及<code>(( ))</code>判断式，其中<code>[ ]</code>和<code>[[ ]]</code>是if判断分支结构中主要使用的。</p><h3 id="test命令测试"><a href="#test命令测试" class="headerlink" title="test命令测试"></a>test命令测试</h3><p>test命令是 shell 环境中用于测试条件表达式的工具，当条件成立时，命令执行后的返回值为0，否则为其他数值。</p><h4 id="test命令结构"><a href="#test命令结构" class="headerlink" title="test命令结构"></a>test命令结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> ! EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -a EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -o EXPRESSION</span><br></pre></td></tr></table></figure><p><mark><strong>test EXPRESSION</strong>执行结果并<strong>不会显示任何信息</strong>，如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</mark></p><p><strong>使用<code>$?</code></strong>：</p><blockquote><p><code>test -f test1.txt</code> # 不输出结果<br><code>echo $?</code> # $?返回最后运行的命令的结束代码</p></blockquote><blockquote><p>0 # 正常运行的命令结束代码为0，也就是条件成立</p></blockquote><blockquote><p><code>test -f test2.txt</code><br><code>echo $?</code></p></blockquote><blockquote><p>1 # 出错或者异常结束代码为非0，也就是条件不成立</p></blockquote><p><strong>使用<code>&amp;&amp;</code>和<code>||</code>的组合</strong>：</p><blockquote><p><code>test -f test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><p><strong>注意<code>&amp;&amp;</code>和<code>||</code>的顺序不能随意，如果上面的顺序调换</strong>：</p><blockquote><p><code>test -f test2.txt || echo &quot;Not exist&quot; &amp;&amp; echo &quot;exist&quot;</code><br>Not exist<br>exist</p></blockquote><p>上面的判断是按顺序执行的，具体<code>&amp;&amp;</code>和<code>||</code>前后命令的执行规则参考<a href="http://showteeth.tech/posts/55603.html">这篇博客</a></p><hr><h4 id="文件是否存在测试"><a href="#文件是否存在测试" class="headerlink" title="文件是否存在测试"></a>文件是否存在测试</h4><p>使用示例：<strong>test -e filename</strong></p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-e</strong></td><td>该“文件名”<strong>是否存在</strong>（常用）</td></tr><tr><td><strong>-f</strong></td><td>该“文件名”是否存在且为<strong>文件</strong>（file）（常用）</td></tr><tr><td><strong>-d</strong></td><td>该“文件名”是否存在且为<strong>目录</strong>（directory）（常用）</td></tr><tr><td><strong>-s</strong></td><td>侦测该文件名是否存在且为“非空白文件”(<strong>文件大小不为0</strong>) （常用）</td></tr><tr><td>-b</td><td>该“文件名”是否存在且为一个 block device 设备</td></tr><tr><td>-c</td><td>该“文件名”是否存在且为一个 character device 设备</td></tr><tr><td>-S</td><td>该“文件名”是否存在且为一个 Socket 文件</td></tr><tr><td>-p</td><td>该“文件名”是否存在且为一个 FIFO （pipe） 文件</td></tr><tr><td>-L</td><td>该“文件名”是否存在且为一个<strong>链接文件</strong></td></tr></tbody></table><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -e test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -d test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="权限测试"><a href="#权限测试" class="headerlink" title="权限测试"></a>权限测试</h4><p>使用示例：<strong>test -r filename</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>侦测该文件名是否存在且<strong>具有“可读”的权限</strong></td></tr><tr><td>-w</td><td>侦测该文件名是否存在且<strong>具有“可写”的权限</strong></td></tr><tr><td>-x</td><td>侦测该文件名是否存在且<strong>具有“可执行”的权限</strong></td></tr><tr><td>-u</td><td>侦测该文件名是否存在且具有“SUID”的属性</td></tr><tr><td>-g</td><td>侦测该文件名是否存在且具有“SGID”的属性</td></tr><tr><td>-k</td><td>侦测该文件名是否存在且具有“Sticky bit”的属性</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt</p></blockquote><blockquote><p><code>test -r test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -w test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -x test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="文件之间的测试"><a href="#文件之间的测试" class="headerlink" title="文件之间的测试"></a>文件之间的测试</h4><p>使用示例：<strong>test file1 -nt file2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-nt</td><td>（<strong>newer than</strong>）判断 file1 是否比 file2 新</td></tr><tr><td>-ot</td><td>（<strong>older than</strong>）判断 file1 是否比 file2 旧</td></tr><tr><td>-ef</td><td>判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上（通过硬链接两个文件名指向相同的文件）</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt<br>-rw-rw-r– 1 user user 0 Mar 14 21:20 test2.txt</p></blockquote><blockquote><p><code>test test1.txt -nt test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test test1.txt -ot test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><hr><h4 id="整数之间的测试"><a href="#整数之间的测试" class="headerlink" title="整数之间的测试"></a>整数之间的测试</h4><p>使用示例：<strong>test n1 -eq n2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>两数值相等 （<strong>equal</strong>）</td></tr><tr><td>-ne</td><td>两数值不等 （<strong>not equal</strong>）</td></tr><tr><td>-gt</td><td>n1 大于 n2 （<strong>greater than</strong>）</td></tr><tr><td>-lt</td><td>n1 小于 n2 （<strong>less tha</strong>n）</td></tr><tr><td>-ge</td><td>n1 大于等于 n2 （<strong>greater than or equal</strong>）</td></tr><tr><td>-le</td><td>n1 小于等于 n2 （<strong>less than or equal</strong>）</td></tr></tbody></table><blockquote><p><code>test 2 -eq 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist<br><code>test 2 -ne 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="字符串的测试"><a href="#字符串的测试" class="headerlink" title="字符串的测试"></a>字符串的测试</h4><p>使用示例：<strong>test str1 == str2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>test -z string</td><td>判定字串是否为 0 ，若 string <strong>为空字串(空格不为空)，则为 true</strong></td></tr><tr><td>test -n string</td><td>判定字串是否非为 0 ，若 string <strong>为空字串，则为 false</strong>。 -n 亦可省略</td></tr><tr><td>test str1 == str2</td><td>判定 str1 <strong>是否等于</strong> str2 ，若相等，则回传 true</td></tr><tr><td>test str1 != str2</td><td>判定 str1 <strong>是否不等于</strong> str2 ，若相等，则回传 false</td></tr></tbody></table><p>注意：<code>==</code>前后需要空格隔开，不用空格隔开可能会出问题</p><hr><h4 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h4><p>使用示例：<strong>test -r file -a -x file</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>（<strong>and</strong>）两状况同时成立！例如 <em>test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true</em>。</td></tr><tr><td>-o</td><td>（<strong>or</strong>）两状况任何一个成立！例如 <em>test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true</em>。</td></tr><tr><td>!</td><td>反向状态，如 <em>test ! -x file ，当 file 不具有 x 时，回传 true</em></td></tr></tbody></table><hr><div class="note info"><p><code>test</code>命令最需要注意的是：单纯的<code>test</code>命令不会返回任何信息，所以如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</p></div><hr><h3 id="判断式"><a href="#判断式" class="headerlink" title="[]判断式"></a>[]判断式</h3><div class="note info"><ul><li>条件测试会使用一个特殊的命令 <code>[</code>，等同于 <code>test</code> 命令，它是一个<strong>内建命令</strong>，写法更加简洁高效。该命令<strong>将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）</strong></li><li>Bash 在 2.02 版本中引入了扩展测试命令 <code>[[ ]]</code>，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， <code>[[</code> 是一个<strong>关键字 而非一个命令</strong>，Bash 将 <code>[[ $a -lt $b ]]</code> 视为一整条语句，执行并返回退出状态</li><li><code>[]</code>有<a href="http://showteeth.tech/posts/55603.html">几种不同的功能</a>，如果想要用来作为条件测试必须要注意<strong>中括号的两端以及判断符前后需要有空白字符来分隔</strong>，如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code></li></ul><ul><li>中括号和test命令的各种测试是相同的，<code>[ ]</code>判断式和test命令可以相互转换，比如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code>可以转换为test “$HOME” == “$MAIL”，所以上面提到的各种测试都可以在中括号中使用</li><li>在中括号 <code>[ ]</code> 内的<strong>每个元件都需要有空白键来分隔</strong></li><li>在中括号内的<strong>变量</strong>，最好都<strong>以双引号括号起来</strong></li><li>在中括号内的<strong>常数</strong>，最好都<strong>以单或双引号括号起来</strong></li><li><code>[ ]</code>以及<code>test</code>命令中所有的表达式和操作符都被 shell 看作是命令参数，对于 bash 有特殊含义的字符，比如说 <code>(</code>、 <code>)</code>、<code>&gt;</code>、<code>&lt;</code><strong>必须引起来或者是转义</strong></li></ul><ul><li>在复合测试中，仅仅引用字符串可能还不够，比如表达式<code>[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</code> 在<strong>某些 Bash 版本</strong>下，如果 <code>$string</code> 为空可能会出错。更加安全的方式是，<strong>对于可能为空的字符串，添加一个额外的字符</strong>，例如 <code>[ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]</code>（其中的 x 互相抵消）</li></ul></div><p><strong>[]判断式需要注意的问题-字符分割</strong>：</p><blockquote><p>test=”my name”<br>[ ${test} == “my” ]</p></blockquote><blockquote><p>bash: [: too many arguments</p></blockquote><p>上面的出错显示判断式中存在太多参数，但是明明就只有test一个参数，为什么会出现这个问题呢？因为 <code>${test}</code> 如果<strong>没有使用双引号括起来</strong>，那么上面的判定式会变成：</p><blockquote><p>[ my name == “my” ]</p></blockquote><p>如果写成这个样子就会发现问题，因为一个判断式仅能有两个数据的比对，上面 my 与 name 还有 “my” 就有三个数据！所以会出错，而我们需要的是：</p><blockquote><p>[ “my name” == “my” ]</p></blockquote><p>所以这就说明了(如果字符串中带有空格，以防万一都带上吧)需要<strong>使用双引号括起来，不用单引号</strong>的原因是单引号会<a href="http://showteeth.tech/posts/55603.html">防止任何变量替换</a></p><hr><h3 id="判断式-1"><a href="#判断式-1" class="headerlink" title="[[]]判断式"></a>[[]]判断式</h3><p>在 <strong>Bash(限制条件)</strong> 里，<code>[[ ]]</code> 是比 <code>[ ]</code> 更加通用的写法，使用 <code>[[ ]]</code> 代替<code>[ ]</code>可以避免很多逻辑错误。比如可以在 <code>[[ ]]</code> 中使用 <code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code> 和 <code>&gt;</code> 操作符，而在 <code>[ ]</code> 中使用则会报错</p><p>下面列出<code>[[ ]]</code> 比 <code>[ ]</code>更好用的几点：</p><h4 id="使用正则匹配"><a href="#使用正则匹配" class="headerlink" title="使用正则匹配"></a>使用正则匹配</h4><p>增加了一个重要的新的字符串表达式来使用正则匹配</p><blockquote><p><strong>string1 =~ regex</strong></p></blockquote><h4 id="不需要使用双引号"><a href="#不需要使用双引号" class="headerlink" title="不需要使用双引号"></a>不需要使用双引号</h4><p><code>[[ ]]</code>判断式<strong>不需要</strong>对其中的变量和常数使用<strong>双引号</strong>括起来：</p><blockquote><p><code>[[ ${test} == &quot;my&quot; ]] &amp;&amp; echo &quot;right&quot; || echo &quot;wrong&quot;</code><br>wrong</p></blockquote><h4 id="操作符支持模式匹配"><a href="#操作符支持模式匹配" class="headerlink" title="==操作符支持模式匹配:"></a>==操作符支持模式匹配:</h4><blockquote><p>FILE=foo.bar<br>if [[ $FILE == foo.* ]]; then<br>> echo “$FILE matches pattern ‘foo.*‘“<br>> fi</p></blockquote><blockquote><p>foo.bar matches pattern ‘foo.*’</p></blockquote><p>使<code>[[ ]]</code>有助于计算文件和路径名，如果<code>foo.*</code>外加了双引号就没有正则匹配的意思，单纯的字符相等的意思</p><h4 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h4><blockquote><p><code>[[ condition1 &amp;&amp; condition2 ]]</code> <code>[[ condition1 || condition2 ]]</code></p></blockquote><h4 id="对不同进制的数直接进行比较"><a href="#对不同进制的数直接进行比较" class="headerlink" title="对不同进制的数直接进行比较"></a>对不同进制的数直接进行比较</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">decimal=15</span><br><span class="line">octal=017   <span class="comment"># = 15 (十进制)</span></span><br><span class="line">hex=0x0f    <span class="comment"># = 15 (十进制)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span>       <span class="comment"># 15 不等于 017</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在单括号 [ ] 之间不会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span>                <span class="comment"># 15 等于 017</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在双括号 [[ ]] 之间会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$hex</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$hex</span>"</span>                  <span class="comment"># 15 等于 0x0f</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$hex</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 十六进制也可以进行转换。</span></span><br></pre></td></tr></table></figure><hr><h3 id="数值判断"><a href="#数值判断" class="headerlink" title="(())数值判断"></a>(())数值判断</h3><p>使用<strong>小于</strong>和<strong>大于</strong>符号，以及<code>==</code>用来测试是否相等，专为整数设计</p><p>不仔细讲解，因为这些也可以使用上面提到的<code>[ ]</code>和<code>[[ ]]</code>进行较好的替代，后续想学习可以参考：<a href="https://www.kancloud.cn/thinkphp/linux-command-line/39459" target="_blank" rel="noopener">文章一</a>、<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part2/07_1_test_constructs.html" target="_blank" rel="noopener">文章二</a>。</p><hr><p><br></p><h2 id="if条件测试分支结构"><a href="#if条件测试分支结构" class="headerlink" title="if条件测试分支结构"></a>if条件测试分支结构</h2><p>在学习<code>test</code>命令以及<code>[ ]</code>判断式过程中我们发现条件测试默认是不会返回任何信息的，如果想要进行操作或者返回信息就要使用<code>&amp;&amp;</code>或者<code>||</code>，这些其实和这里的if条件测试分支结构的作用的相同的，只是if条件测试分支结构可以支持的命令更加多和复杂，有利于大程序的编写。</p><p><strong>if条件测试分支结构工作原理</strong>：通过<strong>判断条件测试的退出状态</strong>，如果<strong>执行成功(命令退出状态为0)</strong>则执行<code>then</code>中的命令，<strong>否则(命令退出状态为非0)</strong>终止判断语句或者执行<code>else</code>或者执行下一层判断等。</p><h3 id="单层、简单条件判断式"><a href="#单层、简单条件判断式" class="headerlink" title="单层、简单条件判断式"></a>单层、简单条件判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  这里的条件判断式就是前面条件测试中使用的[]判断式</span><br></pre></td></tr></table></figure><hr><h3 id="多个表达式、多重判别"><a href="#多个表达式、多重判别" class="headerlink" title="多个表达式、多重判别"></a>多个表达式、多重判别</h3><p>前面在test命令中讲过关于使用多个表达式、多重判断的情况，在多个表达式之间<strong>使用-a表示and、-o表示or</strong>，示例如下：</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; -o &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p>如果想要使用<strong>多个括号将不同的表达式隔开</strong>可以使用<code>&amp;&amp;</code>和<code>||</code>:</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; ] || [ &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p><mark>上面的多重判别实际是写成了一个判断式的形式，而如果 if 之后跟随一系列命令(使用<code>;</code>隔开)，则将计算列表中的<strong>最后一个命令</strong>：</mark></p><blockquote><p><code>if false; true; then echo &quot;It&#39;s true.&quot;; fi</code> 因为true在后，所以得到退出状态为0，输出结果<br>It’s true.</p></blockquote><blockquote><p><code>if true; false; then echo &quot;It&#39;s true.&quot;; fi</code> 因为false在后，所以得到退出状态为非0，不输出结果</p></blockquote><hr><h3 id="双层判断式"><a href="#双层判断式" class="headerlink" title="双层判断式"></a>双层判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 一个条件判断，分成功进行与失败进行 （else）</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><hr><h3 id="多层、复杂判断式"><a href="#多层、复杂判断式" class="headerlink" title="多层、复杂判断式"></a>多层、复杂判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 多个条件判断 （if ... elif ... elif ... else） 分多种不同情况执行</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式一 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式一成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">elif</span> [ 条件判断式二 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式二成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式一与二均不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>if</code>、<code>elif</code>后面需要使用<code>then</code>，而<code>else</code>后面就不用使用<code>then</code>，因为<code>elif</code> 也是个判断式，因此出现 <code>elif</code> 后面都要接 <code>then</code> 来处理！但是 <code>else</code> 已经是最后的没有成立的结果了， 所以 <code>else</code> 后面并没有 <code>then</code></p></div><hr><h3 id="exit程序退出状态"><a href="#exit程序退出状态" class="headerlink" title="exit程序退出状态"></a>exit程序退出状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &lt;name&gt;"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>在运行此脚本时，如果没有输入参数，则提示正确的使用方法，<strong>非正常退出(exit 1)</strong>；否则，打印输入的参数，<strong>程序正常退出(exit 0)</strong>。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文主要学习了shell中的条件测试命令，包括&lt;code&gt;test&lt;/code&gt;命令、&lt;code&gt;[ ]&lt;/code&gt;、&lt;code&gt;[[ ]]&lt;/code&gt;、&lt;code&gt;(( ))&lt;/code&gt;，主要介绍了前三个，其中&lt;code&gt;[ ]&lt;/code&gt;和&lt;code&gt;[[ ]]&lt;/code&gt;可以用在&lt;strong&gt;if条件测试分支结构&lt;/strong&gt;中，两者之间的优缺点在文中也有讲解；也学习了&lt;strong&gt;if条件测试分支结构&lt;/strong&gt;在多种情形下的多种形式以及&lt;code&gt;exit&lt;/code&gt;命令设定程序退出状态&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pv-命令执行的进度信息</title>
    <link href="http://showteeth.tech/posts/6225.html"/>
    <id>http://showteeth.tech/posts/6225.html</id>
    <published>2019-03-13T15:27:07.000Z</published>
    <updated>2019-03-13T16:01:16.514Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这个需要安装pv，需要root权限，后面在有root权限的机器上执行这个操作</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/pv" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.poftut.com/linux-pv-command-tutorial-examples-monitor-progress-copybackupcompress/" target="_blank" rel="noopener">很好的英文示例讲解博客</a></li><li><a href="https://www.tecmint.com/monitor-copy-backup-tar-progress-in-linux-using-pv-command/" target="_blank" rel="noopener">英文示例博客</a></li><li><a href="https://wangchujiang.com/linux-command/c/pv.html" target="_blank" rel="noopener">中文讲解博客</a></li><li><a href="https://ywnz.com/linux/pv/" target="_blank" rel="noopener">中文讲解博客</a></li><li><a href="https://linux.cn/article-6734-1.html?pr" target="_blank" rel="noopener">中文讲解博客</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这个需要安装pv，需要root权限，后面在有root权限的机器上执行这个操作&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTML块级标签和行内标签</title>
    <link href="http://showteeth.tech/posts/8829.html"/>
    <id>http://showteeth.tech/posts/8829.html</id>
    <published>2019-03-13T14:16:09.000Z</published>
    <updated>2019-03-15T10:24:43.436Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这是一篇<a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">转载</a>的文章，主要记录了HTML的块级标签和行内标签各自包括的内容</p></div><a id="more"></a><h2 id="块级标签"><a href="#块级标签" class="headerlink" title="块级标签"></a>块级标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;address&gt;</td><td style="text-align:left">定义地址</td></tr><tr class="even"><td style="text-align:left">&lt;article&gt;</td><td style="text-align:left">定义文章</td></tr><tr class="odd"><td style="text-align:left">&lt;aside&gt;</td><td style="text-align:left">定义页面内容之外的内容</td></tr><tr class="even"><td style="text-align:left">&lt;audio&gt;</td><td style="text-align:left">定义声音内容</td></tr><tr class="odd"><td style="text-align:left">&lt;blockquote&gt;</td><td style="text-align:left">定义长的引用</td></tr><tr class="even"><td style="text-align:left">&lt;canvas&gt;</td><td style="text-align:left">定义图形</td></tr><tr class="odd"><td style="text-align:left">&lt;caption&gt;</td><td style="text-align:left">定义表格标题</td></tr><tr class="even"><td style="text-align:left">&lt;dd&gt;</td><td style="text-align:left">定义定义列表中项目的描述</td></tr><tr class="odd"><td style="text-align:left">&lt;div&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;dl&gt;</td><td style="text-align:left">定义定义列表</td></tr><tr class="odd"><td style="text-align:left">&lt;dt&gt;</td><td style="text-align:left">定义定义列表中的项目</td></tr><tr class="even"><td style="text-align:left">&lt;details&gt;</td><td style="text-align:left">定义元素的细节</td></tr><tr class="odd"><td style="text-align:left">&lt;fieldset&gt;</td><td style="text-align:left">定义围绕表单中元素的边框</td></tr><tr class="even"><td style="text-align:left">&lt;figcaption&gt;</td><td style="text-align:left">定义 figure 元素的标题</td></tr><tr class="odd"><td style="text-align:left">&lt;figure&gt;</td><td style="text-align:left">定义媒介内容的分组，以及它们的标题</td></tr><tr class="even"><td style="text-align:left">&lt;footer&gt;</td><td style="text-align:left">定义 section 或 page 的页脚</td></tr><tr class="odd"><td style="text-align:left">&lt;form&gt;</td><td style="text-align:left">定义供用户输入的 HTML 表单</td></tr><tr class="even"><td style="text-align:left">&lt;h1&gt; to &lt;h6&gt;</td><td style="text-align:left">定义 HTML 标题</td></tr><tr class="odd"><td style="text-align:left">&lt;header&gt;</td><td style="text-align:left">定义 section 或 page 的页眉</td></tr><tr class="even"><td style="text-align:left">&lt;hr&gt;</td><td style="text-align:left">定义水平线</td></tr><tr class="odd"><td style="text-align:left">&lt;legend&gt;</td><td style="text-align:left">定义 fieldset 元素的标题</td></tr><tr class="even"><td style="text-align:left">&lt;li&gt;</td><td style="text-align:left">定义列表的项目</td></tr><tr class="odd"><td style="text-align:left">&lt;menu&gt;</td><td style="text-align:left">定义命令的列表或菜单</td></tr><tr class="even"><td style="text-align:left">&lt;meter&gt;</td><td style="text-align:left">定义预定义范围内的度量</td></tr><tr class="odd"><td style="text-align:left">&lt;nav&gt;</td><td style="text-align:left">定义导航链接</td></tr><tr class="even"><td style="text-align:left">&lt;noframes&gt;</td><td style="text-align:left">定义针对不支持框架的用户的替代内容</td></tr><tr class="odd"><td style="text-align:left">&lt;noscript&gt;</td><td style="text-align:left">定义针对不支持客户端脚本的用户的替代内容</td></tr><tr class="even"><td style="text-align:left">&lt;ol&gt;</td><td style="text-align:left">定义有序列表</td></tr><tr class="odd"><td style="text-align:left">&lt;output&gt;</td><td style="text-align:left">定义输出的一些类型</td></tr><tr class="even"><td style="text-align:left">&lt;p&gt;</td><td style="text-align:left">定义段落</td></tr><tr class="odd"><td style="text-align:left">&lt;pre&gt;</td><td style="text-align:left">定义预格式文本</td></tr><tr class="even"><td style="text-align:left">&lt;section&gt;</td><td style="text-align:left">定义 section</td></tr><tr class="odd"><td style="text-align:left">&lt;table&gt;</td><td style="text-align:left">定义表格</td></tr><tr class="even"><td style="text-align:left">&lt;tbody&gt;</td><td style="text-align:left">定义表格中的主体内容</td></tr><tr class="odd"><td style="text-align:left">&lt;td&gt;</td><td style="text-align:left">定义表格中的单元</td></tr><tr class="even"><td style="text-align:left">&lt;tfoot&gt;</td><td style="text-align:left">定义表格中的表注内容（脚注）</td></tr><tr class="odd"><td style="text-align:left">&lt;th&gt;</td><td style="text-align:left">定义表格中的表头单元格</td></tr><tr class="even"><td style="text-align:left">&lt;thead&gt;</td><td style="text-align:left">定义表格中的表头内容</td></tr><tr class="odd"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="even"><td style="text-align:left">&lt;tr&gt;</td><td style="text-align:left">定义表格中的行</td></tr><tr class="odd"><td style="text-align:left">&lt;ul&gt;</td><td style="text-align:left">定义无序列表</td></tr></tbody></table><hr><p><br></p><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;a&gt;</td><td style="text-align:left">定义锚</td></tr><tr class="even"><td style="text-align:left">&lt;abbr&gt;</td><td style="text-align:left">定义缩写</td></tr><tr class="odd"><td style="text-align:left">&lt;acronym&gt;</td><td style="text-align:left">定义只取首字母的缩写</td></tr><tr class="even"><td style="text-align:left">&lt;b&gt;</td><td style="text-align:left">定义粗体字</td></tr><tr class="odd"><td style="text-align:left">&lt;bdo&gt;</td><td style="text-align:left">定义文字方向</td></tr><tr class="even"><td style="text-align:left">&lt;big&gt;</td><td style="text-align:left">定义大号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;br&gt;</td><td style="text-align:left">定义简单的折行</td></tr><tr class="even"><td style="text-align:left">&lt;button&gt;</td><td style="text-align:left">定义按钮 (push button)</td></tr><tr class="odd"><td style="text-align:left">&lt;cite&gt;</td><td style="text-align:left">定义引用(citation)</td></tr><tr class="even"><td style="text-align:left">&lt;code&gt;</td><td style="text-align:left">定义计算机代码文本</td></tr><tr class="odd"><td style="text-align:left">&lt;command&gt;</td><td style="text-align:left">定义命令按钮</td></tr><tr class="even"><td style="text-align:left">&lt;dfn&gt;</td><td style="text-align:left">定义定义项目</td></tr><tr class="odd"><td style="text-align:left">&lt;del&gt;</td><td style="text-align:left">定义被删除文本</td></tr><tr class="even"><td style="text-align:left">&lt;em&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;embed&gt;</td><td style="text-align:left">定义外部交互内容或插件</td></tr><tr class="even"><td style="text-align:left">&lt;i&gt;</td><td style="text-align:left">定义斜体字</td></tr><tr class="odd"><td style="text-align:left">&lt;img&gt;</td><td style="text-align:left">定义图像</td></tr><tr class="even"><td style="text-align:left">&lt;input&gt;</td><td style="text-align:left">定义输入控件</td></tr><tr class="odd"><td style="text-align:left">&lt;kbd&gt;</td><td style="text-align:left">定义键盘文本</td></tr><tr class="even"><td style="text-align:left">&lt;label&gt;</td><td style="text-align:left">定义 input 元素的标注</td></tr><tr class="odd"><td style="text-align:left">&lt;map&gt;</td><td style="text-align:left">定义图像映射</td></tr><tr class="even"><td style="text-align:left">&lt;mark&gt;</td><td style="text-align:left">定义有记号的文本</td></tr><tr class="odd"><td style="text-align:left">&lt;objec&gt;</td><td style="text-align:left">定义内嵌对象</td></tr><tr class="even"><td style="text-align:left">&lt;progress&gt;</td><td style="text-align:left">定义任何类型的任务的进度</td></tr><tr class="odd"><td style="text-align:left">&lt;q&gt;</td><td style="text-align:left">定义短的引用</td></tr><tr class="even"><td style="text-align:left">&lt;samp&gt;</td><td style="text-align:left">定义计算机代码样本</td></tr><tr class="odd"><td style="text-align:left">&lt;select&gt;</td><td style="text-align:left">定义选择列表（下拉列表）</td></tr><tr class="even"><td style="text-align:left">&lt;small&gt;</td><td style="text-align:left">定义小号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;span&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;strong&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;sub&gt;</td><td style="text-align:left">定义下标文本</td></tr><tr class="even"><td style="text-align:left">&lt;sup&gt;</td><td style="text-align:left">定义上标文本</td></tr><tr class="odd"><td style="text-align:left">&lt;textarea&gt;</td><td style="text-align:left">定义多行的文本输入控件</td></tr><tr class="even"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="odd"><td style="text-align:left">&lt;tt&gt;</td><td style="text-align:left">定义打字机文本</td></tr><tr class="even"><td style="text-align:left">&lt;var&gt;</td><td style="text-align:left">定义文本的变量部分</td></tr><tr class="odd"><td style="text-align:left">&lt;video&gt;</td><td style="text-align:left">定义视频</td></tr><tr class="even"><td style="text-align:left">&lt;wbr&gt;</td><td style="text-align:left">定义可能的换行符</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/d69878549d92" target="_blank" rel="noopener">关于两者之间的转换</a></li><li><a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">HTML中块级元素和行内元素的总结和区分，本文内容摘自此文章</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这是一篇&lt;a href=&quot;https://www.cnblogs.com/yanqiu/p/8987126.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载&lt;/a&gt;的文章，主要记录了HTML的块级标签和行内标签各自包括的内容&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="http://showteeth.tech/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://showteeth.tech/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>转载其他博主博客</title>
    <link href="http://showteeth.tech/posts/52283.html"/>
    <id>http://showteeth.tech/posts/52283.html</id>
    <published>2019-03-13T12:40:50.000Z</published>
    <updated>2019-03-13T15:03:24.867Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载<strong>CSDN博客</strong>、<strong>博客园博客</strong>、<strong>简书</strong>以及<strong>其他自建博客</strong>等</p></div><a id="more"></a><h2 id="转载CSDN博客"><a href="#转载CSDN博客" class="headerlink" title="转载CSDN博客"></a>转载CSDN博客</h2><div id="article_content" class="article_content csdn-tracking-statistics tracking-click"><div class="markdown_views"><h3 id="检查"><a name="t2"></a><a target="_blank"></a>博客页面右键，点击【检查】</h3><img src="https://img-blog.csdn.net/20180205164141852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> 点击检查后，页面右侧出现<strong>html</strong>代码，如下图： <img src="https://img-blog.csdn.net/20180205164538679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="找内容"><a name="t3"></a><a target="_blank"></a>找到article_content内容</h3><img src="https://img-blog.csdn.net/20180205164709557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="复制"><a name="t4"></a><a target="_blank"></a>复制article_content内容</h3>在选中html的article_content代码处右键，点击<strong>【Copy】</strong>,再点击<strong>【Copy outerHTML】</strong>即可，至此，博客内容的html代码复制完成 <img src="https://img-blog.csdn.net/20180205164702137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="新建"><a name="t5"></a><a target="_blank"></a>新建markdown博客</h3><ul><li>如果是<strong>转载到CSDN博客</strong>需要注意：<strong>使用markdown编辑器</strong>，CSDN博客默认的是<a href="https://www.baidu.com/s?wd=html%E7%BC%96%E8%BE%91%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank"><strong>html编辑器</strong></a>，在博客设置中<strong>修改成markdown编辑器</strong>，在html编辑器中是无法将html代码转换成相应博客内容</li><li>如果是<strong>转载到自己搭建的博客</strong>，比如我的这个博客，需要注意：按照上述方法会得到<mark>很多的空格</mark>，这是因为直接使用html来编写markdown，只要存在换行(如标签换行)都会在最终生成的页面中得到一个空格，为了解决这个问题可以在整个<code>article_content</code>标签外加上<code>escape</code>标签即可，这个和<a href="http://showteeth.tech/posts/65136.html" target="_blank"><strong>插入html表格</strong></a>的处理是一样的</li><li>HTML <mark>区块标签间的 Markdown 格式语法将不会被处理</mark>，但 Markdown 语法在 HTML <mark>行内标签间是有效的</mark>，具体的行内标签和区块标签包含的内容见<mark><a href="http://showteeth.tech/posts/8829.html" target="_blank">这篇博客</a></mark></li><li>在手动更改html内容时需要注意：每个标题的<code>id</code>是<mark>不可以相同</mark>的，不然<strong>生成的目录会出问题</strong>，点击不能到达相应的标题(目录是根据<code>id</code>生成的)</li><li>最后特别要注意的是，我们发表转载文章的时候一定要标注<strong>转载</strong>，尊重原创！！</li></ul></div></div><hr><h2 id="转载博客园博客"><a href="#转载博客园博客" class="headerlink" title="转载博客园博客"></a>转载博客园博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>data-note-content</code>即可</p><hr><h2 id="转载简书博客"><a href="#转载简书博客" class="headerlink" title="转载简书博客"></a>转载简书博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>cnblogs_post_body</code>即可</p><hr><h2 id="转载其他自建博客"><a href="#转载其他自建博客" class="headerlink" title="转载其他自建博客"></a>转载其他自建博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>post-body</code>即可</p><p>其他博客依据上述规律<strong>找到对应的文章主体内容</strong>，然后按照转载CSDN博客的方法进行处理即可</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/zhongjianblackberry/article/details/79456338" target="_blank" rel="noopener">CSDN怎么转载别人的博客</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载&lt;strong&gt;CSDN博客&lt;/strong&gt;、&lt;strong&gt;博客园博客&lt;/strong&gt;、&lt;strong&gt;简书&lt;/strong&gt;以及&lt;strong&gt;其他自建博客&lt;/strong&gt;等&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>shell-数组</title>
    <link href="http://showteeth.tech/posts/46714.html"/>
    <id>http://showteeth.tech/posts/46714.html</id>
    <published>2019-03-06T15:36:25.000Z</published>
    <updated>2019-03-07T07:54:28.654Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://baijiahao.baidu.com/s?id=1608244941950314734&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/hanframe/p/3564313.html" target="_blank" rel="noopener">shell编程中使用数组进行操作</a></li><li><a href="http://www.runoob.com/linux/linux-shell-array.html" target="_blank" rel="noopener">Shell 数组</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/chapter4/46.html" target="_blank" rel="noopener">shell-guide</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="shell编程" scheme="http://showteeth.tech/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>diff-比较文件差异</title>
    <link href="http://showteeth.tech/posts/56778.html"/>
    <id>http://showteeth.tech/posts/56778.html</id>
    <published>2019-03-06T12:14:22.000Z</published>
    <updated>2019-03-15T03:03:41.490Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用<code>diff</code>命令对<strong>文件和目录</strong>进行比较，对文件比较时采用的是<strong>逐行进行比较</strong>；包括的参数有<code>-r</code>、<code>-q</code>、<code>-i</code>、<code>-s</code>、<code>-b</code>、<code>-y</code>、<code>-W</code>、<code>-c</code>、<code>-C</code>、<code>-u</code>和<code>-U</code>。</p></div><a id="more"></a><h2 id="diff简介"><a href="#diff简介" class="headerlink" title="diff简介"></a>diff简介</h2><p><code>diff</code>命令能<strong>比较(单个)文件或者目录</strong>内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，并<strong>以逐行的方式</strong>，比较文本文件的异同；如果指定<strong>比较的是目录</strong>，diff 命令会比较两个目录下名字相同但内容不同的文本文件，列出公共子目录和只在一个目录出现的文件和目录。</p><p><mark>这个和前面讲到的<code>comm</code>命令和<code>cmp</code>命令的不同之处在于</mark>：<code>diff</code>和<code>comm</code>命令都是以逐行的方式进行比较，而<code>cmp</code>是<strong>Compare two files byte by byte</strong>；同时<code>diff</code>命令可以比较<strong>单个文件</strong>，而<code>comm</code>和<code>cmp</code>都是针对的两个文件的比较，其中<code>comm</code>还需要文件是排过序的；<code>diff</code>命令还能用来对目录进行排序；感觉<code>diff</code>在比较两个文件或目录时是将两个文件当成了同一个文件修改前后的不同版本，通过<code>diff</code>可以知道新文件是在旧文件上进行了哪些操作得到的，得到的结果也更复杂。</p><p>总结一下三个命令的适用情形：<br></p><div class="note info"><ul><li>comm适合简单的比较，需要<strong>排序</strong>，<strong>逐行</strong>比较，用于比较的文件不是同一个文件的不同版本(新旧文件)，得到的结果<strong>简单清晰</strong>(文件求交、并、补等)，便于提取分析</li><li>cmp可以应用于对两个文件<strong>逐字节</strong>的比较，可以<strong>跳过一定的字节</strong>(个人感觉这个实用性不是很强，不同系统编码方式字节也有所不同)</li><li>diff适合<strong>逐行</strong>比较<strong>文件修改前后</strong>的区别(类似版本控制，新文件是旧文件经过什么操作得到的)，也可以<strong>对目录进行比较</strong>，但是输出<strong>结果较为复杂</strong>，还可以输出<strong>上下文</strong>关系的信息</li></ul></div><p></p><hr><h2 id="diff命令用法"><a href="#diff命令用法" class="headerlink" title="diff命令用法"></a>diff命令用法</h2><h3 id="diff命令格式"><a href="#diff命令格式" class="headerlink" title="diff命令格式"></a>diff命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  diff [OPTION]... FILES</span><br></pre></td></tr></table></figure><p><strong>Compare files line by line</strong></p><hr><h3 id="diff-options说明"><a href="#diff-options说明" class="headerlink" title="diff options说明"></a>diff options说明</h3><p>由于diff命令的参数较多，这里就不一一列举，详细请查看帮助文档，比较常用的请看用法实例。</p><hr><p><br></p><h2 id="diff用法实例"><a href="#diff用法实例" class="headerlink" title="diff用法实例"></a>diff用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Hi,<br>Hello,<br>How are you?<br>I am fine,<br>Thank you.</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Hello,<br>Hi,<br>How are you?<br>I am fine.</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><h4 id="比较两个文件"><a href="#比较两个文件" class="headerlink" title="比较两个文件"></a>比较两个文件</h4><blockquote><p><code>diff test1.txt test2.txt</code><br>1d0<br>&lt; Hi,<br>2a2<br>> Hi,<br>4,5c4<br>&lt; I am fine,<br>&lt; Thank you.<br>-–<br>> I am fine.</p></blockquote><p><strong>结果解读：</strong></p><ul><li>可以将test1.txt当做旧文件，test2.txt当做新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li><code>1d0</code>这一行意味着旧文件的第一行应该被<strong>删除(d)</strong>以使两个文件的第一行同步，<strong>旧文件中需要被删除的行</strong>以<code>&lt;</code>标记</li><li><code>2a2</code>行意味着<strong>新文件中的第二行应该加到旧文件的第二行后</strong>，要<strong>添加的行显示在输出的下一行</strong>用<code>&gt;</code>标记</li><li><code>4,5c4</code>这一行意味着在<strong>旧文件中的4到5行现在已被改变并且需要用新文件中的第4行代替</strong>，代替和删除的行分别用<code>&gt;</code>和<code>&lt;</code>表示，<code>---</code>用于隔开先后进行的不同操作，如先删除旧文件中的4到5行，然后再用新文件中的第4行代替，这两步之间使用<code>---</code>分割</li></ul><div class="note info"><ul><li><code>diff</code>命令的第一个参数被视为旧文件而第二个参数被视为新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li>像<code>1d0</code>、<code>2a2</code>、<code>4,5c4</code>这种表达式可以用语法解码为 <strong>[旧文件的行号或者行的范围][行为][新文件的行号或者行的范围]</strong>，这里的<strong>行为</strong>可以是追加(<code>a，代表addition</code>)、删除(<code>d，代表deletion</code>)或者改变替换(<code>c，代表change</code>)</li><li><code>&lt;</code>代表删除的行，而<code>&gt;</code>代表添加的行，<code>---</code>用于改变替换(<code>c，代表change</code>)中分割先后的操作</li></ul></div><hr><h4 id="比较两个目录"><a href="#比较两个目录" class="headerlink" title="比较两个目录"></a>比较两个目录</h4><blockquote><p><code>ls new_dir/</code><br>comm_dir new_new_dir test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls new_dir/new_new_dir/</code> and <code>ls new_dir/comm_dir/</code><br>test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls orig_dir/</code><br>comm_dir orig_orig_dir test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>ls orig_dir/orig_orig_dir/</code> and <code>ls orig_dir/comm_dir/</code><br>test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>diff orig_dir/ new_dir/</code><br>Common subdirectories: new_dir/comm_dir and orig_dir/comm_dir # 两个目录共有的子目录，不会比较子目录中的文件信息<br>Only in new_dir/: new_new_dir # 只出现在new_dir中的目录，不会比较子目录中的文件信息<br>Only in orig_dir/: orig_orig_dir # 只出现在orig_dir中的目录，不会比较子目录中的文件信息<br>diff orig_dir/test1.txt new_dir/test1.txt # new_dir和orig_dir共有的同名文件内容的差异<br>0a1 # 具体的差异信息<br>> asdfaf # 具体的差异信息<br>Only in new_dir/: test3.txt # 只出现在new_dir中的文件<br>Only in orig_dir/: test4.txt # 只出现在orig_dir中的文件</p></blockquote><p><strong>比较两个目录可以找到每个目录共有的、独有的文件和目录信息；对于共有的子目录，不会继续比较子目录中的信息；对于共有的文件，会得出文件的差异信息</strong></p><hr><h3 id="r-比较子目录中的文件"><a href="#r-比较子目录中的文件" class="headerlink" title="-r-比较子目录中的文件"></a>-r-比较子目录中的文件</h3><p>上述对目录进行比较时默认不会比较子目录中的文件信息，使用-r参数可以对这些文件进行比较：</p><blockquote><p><code>diff -r orig_dir/ new_dir/</code><br>diff -r orig_dir/comm_dir/test1.txt new_dir/comm_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/comm_dir: test3.txt<br>Only in orig_dir/comm_dir: test4.txt<br>Only in new_dir/: new_new_dir<br>Only in orig_dir/: orig_orig_dir<br>diff -r orig_dir/test1.txt new_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/: test3.txt<br>Only in orig_dir/: test4.txt</p></blockquote><hr><h3 id="q-只显示有无差异"><a href="#q-只显示有无差异" class="headerlink" title="-q-只显示有无差异"></a>-q-只显示有无差异</h3><p>默认情况下如果文件存在差异会显示差异信息，使用<code>-q</code>参数只会显示有无差异不会显示具体的差异信息:</p><blockquote><p><code>diff -q test1.txt test2.txt</code><br>Files test1.txt and test2.txt differ</p></blockquote><hr><h3 id="i-忽略文件中文本大小写"><a href="#i-忽略文件中文本大小写" class="headerlink" title="-i-忽略文件中文本大小写"></a>-i-忽略文件中文本大小写</h3><blockquote><p><code>diff file1.txt file2.txt</code><br>1c1<br>&lt; hi<br>-–<br>> HI</p></blockquote><p>默认情况下是会区分文件中文本信息大小写的</p><blockquote><p><code>diff -i file1.txt file2.txt</code></p></blockquote><p>使用了<code>-i</code>参数没有输出内容，因为忽略大小写之后文件中文本信息是相同的</p><hr><h3 id="s-在文件内容相同条件下报告信息"><a href="#s-在文件内容相同条件下报告信息" class="headerlink" title="-s-在文件内容相同条件下报告信息"></a>-s-在文件内容相同条件下报告信息</h3><p>上面使用了<code>-i</code>参数得到了文件内容是相同的，这时默认就不会输出信息，如果想要在文件内容相同时报告文件内容是相同的，需要使用<code>-s</code>参数</p><blockquote><p><code>diff -is file1.txt file2.txt</code><br>Files file1.txt and file2.txt are identical</p></blockquote><hr><h3 id="b-忽略文本中的空格"><a href="#b-忽略文本中的空格" class="headerlink" title="-b-忽略文本中的空格"></a>-b-忽略文本中的空格</h3><blockquote><p><code>cat file1</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>cat file2</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>diff file1 file2</code><br>1c1<br>&lt; Hi, how are you?<br>-–<br>> Hi, how are you?</p></blockquote><p>上述文件中的区别仅仅是file2多了一个空格，但是使用<code>diff</code>命令后仍然会输出不同，而常规情形下，这应该被认为是相同的，这时就可以使用<code>-b</code>参数</p><blockquote><p><code>diff -bs file1 file2</code><br>Files file1 and file2 are identical</p></blockquote><hr><h3 id="y-以并列的方式显示文件的异同之处"><a href="#y-以并列的方式显示文件的异同之处" class="headerlink" title="-y-以并列的方式显示文件的异同之处"></a>-y-以并列的方式显示文件的异同之处</h3><blockquote><p><code>diff -y test1.txt test2.txt</code><br>Hi, &lt;<br>Hello, Hello,<br>&gt; Hi,<br>How are you? How are you?<br>I am fine, | I am fine.<br>Thank you. &lt;</p></blockquote><ul><li><code>|</code>：表示前后2个文件内容存在差异</li><li><code>&gt;</code>：表示第一个文件删除的行</li><li><code>&lt;</code>：表示第二个文件增加的行</li></ul><hr><h3 id="W-在使用-y参数时，指定栏宽"><a href="#W-在使用-y参数时，指定栏宽" class="headerlink" title="-W-在使用-y参数时，指定栏宽"></a>-W-在使用-y参数时，指定栏宽</h3><p>如果指定的栏宽太窄，会显示每行的部分信息：</p><blockquote><p><code>diff -y -W 10 test1.txt test2.txt</code><br>Hi &lt;<br>He He<br>> Hi<br>Ho Ho<br>I | I<br>Th &lt;</p></blockquote><hr><h3 id="c-上下文格式输出"><a href="#c-上下文格式输出" class="headerlink" title="-c-上下文格式输出"></a>-c-上下文格式输出</h3><p>显示不同行的信息时一同显示上下文信息，默认是存在不同的上下3行：</p><blockquote><p><code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><ul><li><code>***</code>表示变动前的文件，<code>---</code>表示变动后的文件</li><li><code>*** 1,5 ****</code>表示变动前文件的1到5行，<code>--- 1,4 ----</code>表示变动后文件的1到4行</li><li>文件内容的每一行最前面，还有一个标记位<ul><li>如果为<code>空</code>，表示该行无变化</li><li>如果是感叹号（<code>!</code>），表示该行有改动</li><li>如果是减号（<code>-</code>），表示该行被删除</li><li>如果是加号（<code>+</code>），表示该行为新增</li></ul></li></ul><hr><h3 id="C-NUM-指定具体是上下文行数"><a href="#C-NUM-指定具体是上下文行数" class="headerlink" title="-C NUM-指定具体是上下文行数"></a>-C NUM-指定具体是上下文行数</h3><p>这个功能和上面的<code>-c</code>是相同的，只是<code>-c</code>只能是默认的上下3行，而<code>-C num</code>可以指定具体的上下文行数</p><blockquote><p><code>diff -C 3 test1.txt test2.txt</code> 等同于 <code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><hr><h3 id="u-合并格式输出"><a href="#u-合并格式输出" class="headerlink" title="-u-合并格式输出"></a>-u-合并格式输出</h3><p>如果两个文件<strong>相似度很高</strong>，那么<strong>上下文格式的<code>diff</code>，将显示大量重复的内容</strong>，很浪费空间，这个时候使用合并格式输出<strong>将f1和f2的上下文(默认3行)合并在一起显示</strong>：</p><blockquote><p><code>diff -u test1.txt test2.txt</code><br>— test1.txt 2019-03-14 15:26:48.960323475 +0800<br>+++ test2.txt 2019-03-14 15:27:07.411322620 +0800<br>@@ -1,5 +1,4 @@<br>-Hi,<br>Hello,<br>+Hi,<br>How are you?<br>-I am fine,<br>-Thank you.<br>+I am fine.</p></blockquote><ul><li><code>---</code>表示变动前的文件，<code>+++</code>表示变动后的文件</li><li>变动的位置用两个<code>@</code>作为起首和结束，<code>-1,5</code>表示第一个文件的1到5行，<code>+1,4</code>表示第二个文件的1到4行</li><li>每一行最前面的标志位，<strong>空表示无变动</strong>，<strong>减号表示第一个文件删除的行</strong>，<strong>加号表示第二个文件新增的行</strong></li></ul><hr><h3 id="U-NUM-指定合并格式上下文的行数"><a href="#U-NUM-指定合并格式上下文的行数" class="headerlink" title="-U NUM-指定合并格式上下文的行数"></a>-U NUM-指定合并格式上下文的行数</h3><p>这个功能和上面的<code>-u</code>是相同的，只是<code>-u</code>只能是默认的上下3行，而<code>-U num</code>可以指定具体的上下文行数</p><hr><h3 id="结合patch进行内容更新"><a href="#结合patch进行内容更新" class="headerlink" title="结合patch进行内容更新"></a>结合patch进行内容更新</h3><p>这个暂时应该用不到，所以就不学习了，后期如果使用的话再进行学习补充，后面列出的参考链接有对应的示例。</p><hr><p><br></p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><div class="note info"><ul><li>diff的<strong>几种输出模式</strong>：<strong>并列输出(-y)</strong>、<strong>上下文格式输出(-c)</strong>、<strong>合并格式输出(-u)</strong>之间的不兼容的，只能使用其中一种，参数不能混用</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/12/2814048.html" target="_blank" rel="noopener">实例较多</a></li><li><a href="https://linux.cn/article-2298-1.html" target="_blank" rel="noopener">举例说明Linux diff 命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-diff.html" target="_blank" rel="noopener">参数讲解</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">清晰的讲解</a></li><li><a href="http://wiki.jikexueyuan.com/project/shell-learning/file-comparing-cmp-diff-patch.html" target="_blank" rel="noopener">文件比较 cmp，diff，patch</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了使用&lt;code&gt;diff&lt;/code&gt;命令对&lt;strong&gt;文件和目录&lt;/strong&gt;进行比较，对文件比较时采用的是&lt;strong&gt;逐行进行比较&lt;/strong&gt;；包括的参数有&lt;code&gt;-r&lt;/code&gt;、&lt;code&gt;-q&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;、&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-y&lt;/code&gt;、&lt;code&gt;-W&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-C&lt;/code&gt;、&lt;code&gt;-u&lt;/code&gt;和&lt;code&gt;-U&lt;/code&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>cmp-比较文件差异</title>
    <link href="http://showteeth.tech/posts/62860.html"/>
    <id>http://showteeth.tech/posts/62860.html</id>
    <published>2019-03-06T11:57:37.000Z</published>
    <updated>2019-03-14T11:47:30.224Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<code>cmp</code>对<strong>两个文件</strong>进行比较，比较时是<strong>逐字节</strong>进行的；包括的参数：<code>-b</code>、<code>-i</code>、<code>-i</code>、<code>-l</code>、<code>-n</code>、<code>-s</code>以及<strong>显示运行进度</strong>。</p></div><a id="more"></a><h2 id="cmp简介"><a href="#cmp简介" class="headerlink" title="cmp简介"></a>cmp简介</h2><p><code>cmp</code>命令用于比较两个文件是否有差异；当相互比较的两个文件<strong>完全一样</strong>时，则该命令不会有输出结果；若发现<strong>有所差异</strong>，<strong>默认会标示出第一个不同之处的字符和列数编号</strong></p><p>若不指定任何文件名称或是所给予的文件名为<code>-</code>，则<code>cmp</code>指令会从标准输入读取数据</p><p><mark>这个和前面讲到的<code>comm</code>命令的不同之处在于</mark>：comm命令对已排序的文件进行比较并将结果分为3列，便于提取文件比较的结果，如得到两个文件的差集、交集、并集和对称差集等，而<code>cmp</code>命令侧重于比较两个文件差异，大多用于比较同一个文件修改之后和修改之前的差异，并且<code>cmp</code>比较文件不需要进行排序；<code>cmp</code>命令比较文件是<strong>byte by byte</strong>，而comm命令比较文件是<strong>line by line</strong>。</p><hr><p><br></p><h2 id="cmp命令用法"><a href="#cmp命令用法" class="headerlink" title="cmp命令用法"></a>cmp命令用法</h2><h3 id="cmp命令格式"><a href="#cmp命令格式" class="headerlink" title="cmp命令格式"></a>cmp命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  cmp [OPTION] FILE1 [FILE2 [SKIP1 [SKIP2]]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The optional SKIP1 and SKIP2 specify the number of bytes to skip</span></span><br><span class="line"><span class="comment"># at the beginning of each file (zero by default).</span></span><br></pre></td></tr></table></figure><p><strong>Compare two files byte by byte</strong></p><hr><h3 id="cmp-options说明"><a href="#cmp-options说明" class="headerlink" title="cmp options说明"></a>cmp options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–print-bytes</td><td>除了标明差异处所在之外，一并显示该字符所对应字符和字节值</td></tr><tr><td>-i SKIP</td><td>–ignore-initial=SKIP</td><td>跳过一定的字节数(不包括SKIP)</td></tr><tr><td>-i SKIP1:SKIP2</td><td>–ignore-initial=SKIP1:SKIP2</td><td>从两个文件中跳过不同的字节数，SKIP1是FILE1跳过的字节数，SKIP为FILE2跳过的字节数</td></tr><tr><td>-l</td><td>–verbose</td><td>显示所有不同字节的字节位置（和值）</td></tr><tr><td>-n</td><td>–bytes=LIMIT</td><td>限制要比较的字节数(包括LIMIT)</td></tr><tr><td>-s</td><td>–quiet, –silent</td><td>抑制正常生成的输出，只返回文件是否相同的退出码(可以通过<code>$?</code>得到)</td></tr></tbody></table><hr><h3 id="cmp-i选项可选单位"><a href="#cmp-i选项可选单位" class="headerlink" title="cmp -i选项可选单位"></a>cmp -i选项可选单位</h3><table><thead><tr><th>简写</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>kB</td><td>kilobytes</td><td>1000</td></tr><tr><td>K</td><td>kibibytes</td><td>1024</td></tr><tr><td>MB</td><td>megabytes</td><td>1,000,000</td></tr><tr><td>M</td><td>mebibytes</td><td>1,048,576</td></tr><tr><td>GB</td><td>gigabytes</td><td>1,000,000,000</td></tr><tr><td>G</td><td>gibibytes</td><td>1,073,741,824</td></tr></tbody></table><hr><p><br></p><h2 id="cmp用法实例"><a href="#cmp用法实例" class="headerlink" title="cmp用法实例"></a>cmp用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Absncn 50<br>Asldssja 60<br>Jslkadjls 85</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Absncn 50<br>AsldssjE 62<br>Jslkadjls 85</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><p>默认会告诉在第几行的第几个字节出现不同：</p><blockquote><p><code>cmp test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2</p></blockquote><p><strong>注意这里的<code>byte 18</code>来源：系统默认编码方式为UTF-8(查看方式见<a href="http://showteeth.tech/posts/56690.html">这篇文章</a>)，1个英文字符 = 1个字节；换行符占一个字节；空格占一个字节；第二行的结果存在差异的话，字符会从第一行的第一个开始算起，叠加的，不是单独每一行算</strong></p><h3 id="b-显示不同的字节及字节值"><a href="#b-显示不同的字节及字节值" class="headerlink" title="-b-显示不同的字节及字节值"></a>-b-显示不同的字节及字节值</h3><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is <strong>141 a 105 E</strong></p></blockquote><p><strong>只会显示第一个，不会显示所有的</strong>，具体是字母a和E不同，字节值分别为141和105(这个没算。。。)</p><hr><h3 id="i-跳过指定的字节"><a href="#i-跳过指定的字节" class="headerlink" title="-i-跳过指定的字节"></a>-i-跳过指定的字节</h3><blockquote><p><code>cmp -b -i 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 3</strong>, line 1 is 60 0 62 2</p></blockquote><p>跳过<strong>前18个之后开始的第3个字节</strong>，0和2不同</p><div class="note info"><p>注意这个是<strong>不包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置</p></div><hr><h3 id="i-从两个文件跳过不同数量的字节"><a href="#i-从两个文件跳过不同数量的字节" class="headerlink" title="-i-从两个文件跳过不同数量的字节"></a>-i-从两个文件跳过不同数量的字节</h3><blockquote><p><code>cmp -b -i 18:18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 3, line 1 is 60 0 62 2</p></blockquote><p>18:18：第一个文件跳过的字节数为18，第二个文件跳过的字节数也是18</p><hr><h3 id="l-显示所有不同字节的字节位置（和值）"><a href="#l-显示所有不同字节的字节位置（和值）" class="headerlink" title="-l-显示所有不同字节的字节位置（和值）"></a>-l-显示所有不同字节的字节位置（和值）</h3><blockquote><p><code>cmp -l test1.txt test2.txt</code><br>18 141 105<br>21 60 62</p></blockquote><p>输出结果：</p><ul><li>第一列（如上所示）表示不同<strong>字节的位置</strong>（字节数）</li><li>第二列表示<strong>第一个文件</strong>中不同字节的字节值</li><li>第三列表示<strong>第二个文件</strong>中不同字节的字节值</li></ul><p>前面的<code>-b</code>等参数只会显示<strong>第一个</strong>不同的字节位置和值，这里会<strong>显示所有的</strong>字节数字和值</p><hr><h3 id="n-限制要比较的字节数"><a href="#n-限制要比较的字节数" class="headerlink" title="-n-限制要比较的字节数"></a>-n-限制要比较的字节数</h3><p>最多只比较的字符数：</p><blockquote><p><code>cmp -n 17 test1.txt test2.txt</code><br><code>cmp -n 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 18</strong>, line 2</p></blockquote><p>如果和<code>-i</code>参数联合使用：</p><blockquote><p><code>cmp -b -l -i 3 -n 18 test1.txt test2.txt</code><br>15 141 a 105 E<br>18 60 0 62 2</p></blockquote><p>注意这里相比于没有设置跳过字节会多出一行差异的结果，<strong>表明-n是相对字节位置，而不是绝对的字节位置</strong></p><p>和不使用<code>-i</code>的对比：</p><blockquote><p><code>cmp -b -l -n 18 test1.txt test2.txt</code><br>18 141 a 105 E</p></blockquote><div class="note info"><ul><li>注意这里是<strong>包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置，因为包括了所以才会输出在byte18位置存在区别</li><li><strong>-n指定的是相对字节位置，而不是绝对字节位置</strong>，比如上面跳过前3个字符之后出现差异的就成了第15个字节位置的，同时因为-n设置为18向后推移3个字节，就会出现了第二个不同的位置，而如果不设置-i参数就不会得到第二个不同的位置</li></ul></div><hr><h3 id="s-抑制正常生成的输出，只返回反映文件是否相同的退出码"><a href="#s-抑制正常生成的输出，只返回反映文件是否相同的退出码" class="headerlink" title="-s-抑制正常生成的输出，只返回反映文件是否相同的退出码"></a>-s-抑制正常生成的输出，只返回反映文件是否相同的退出码</h3><blockquote><p><code>cmp -s -b test1.txt test2.txt</code></p></blockquote><p>没有输出结果，也就是原本需要输出的在哪一行存在差异都不会输出来了，然后查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果是<code>1</code>，表明文件是不相同的，这样可<strong>得到文件是否相同的信息，但是并不关注具体的差异在什么地方</strong></p><p>而如果不加<code>-s</code>就会正常输出：</p><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is 141 a 105 E</p></blockquote><p>同时不加<code>-s</code>查看查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果和加了<code>-s</code>一样都返回的是<code>1</code></p><div class="note info"><p>在脚本中使用<code>cmp</code>命令时，此选项可以会派上用场。 例如，根据文件是否相同(通过访问命令的退出代码可以知道)来进行下一步的操作，这个时候我们可能并<strong>不关心具体文件的差异在什么地方，而是关心文件是不是有差异这个整体的结果</strong></p></div><h3 id="显示运行进度"><a href="#显示运行进度" class="headerlink" title="显示运行进度"></a>显示运行进度</h3><p>这个需要结合<a href="http://showteeth.tech/posts/6225.html">pv命令</a>，安装和使用<a href="http://showteeth.tech/posts/6225.html">pv命令</a>之后再进行学习，参考参考链接的前两个</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtoforge.com/linux-cmp-command/" target="_blank" rel="noopener">Linux cmp command tutorial for beginners （7 examples）</a></li><li><a href="https://www.howtoing.com/linux-cmp-command" target="_blank" rel="noopener">Linux初学者的cmp命令教程（7个例子）</a></li><li><a href="https://www.computerhope.com/unix/ucmp.htm" target="_blank" rel="noopener">Linux cmp command-关于-i参数单位的问题很好</a></li><li><a href="https://www.tutorialspoint.com/unix_commands/cmp.htm" target="_blank" rel="noopener">cmp - Unix, Linux Command</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章主要学习了&lt;code&gt;cmp&lt;/code&gt;对&lt;strong&gt;两个文件&lt;/strong&gt;进行比较，比较时是&lt;strong&gt;逐字节&lt;/strong&gt;进行的；包括的参数：&lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-l&lt;/code&gt;、&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt;以及&lt;strong&gt;显示运行进度&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>journey</title>
    <link href="http://showteeth.tech/posts/34270.html"/>
    <id>http://showteeth.tech/posts/34270.html</id>
    <published>2019-03-06T08:12:34.000Z</published>
    <updated>2019-03-13T12:14:03.220Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><h3 id="磁器口"><a href="#磁器口" class="headerlink" title="磁器口"></a>磁器口</h3><ul><li>吃的：陈麻花-推荐<strong>陈昌银</strong>或者<strong>夏麻花</strong>、<strong>张老汉手工酸辣粉</strong>（磁器口必吃之一）</li><li>有很多文艺的小咖啡馆或者书店</li><li>磁器口的主街人满为患，商业化严重，<strong>更建议去侧街</strong>，也是咖啡馆一条街，客量少，店面装饰都很有文艺味儿，<strong>是来磁器口的正确打开方式</strong>。（在此安利一家咖啡馆——<strong>懒鱼时光馆</strong>，上图即是该咖啡馆，是一家有故事的咖啡馆）</li></ul><h3 id="洪崖洞"><a href="#洪崖洞" class="headerlink" title="洪崖洞"></a>洪崖洞</h3><ul><li><strong>晚上去</strong>，白天不好看，晚上有灯光</li><li>主要是建筑构造和风貌</li></ul><h3 id="南山一棵树观景台"><a href="#南山一棵树观景台" class="headerlink" title="南山一棵树观景台"></a>南山一棵树观景台</h3><ul><li>可以将重庆所有的美景尽收眼底！建议<strong>夜晚去</strong>，重庆的夜景很美很美很美！<ul><li>门票：门票30，学生证15</li></ul></li><li>吃的：泉水鸡、枇杷园（火锅）</li></ul><h3 id="十八梯"><a href="#十八梯" class="headerlink" title="十八梯"></a><del>十八梯</del></h3><ul><li>电影《从你的全世界路过》</li><li>十八梯是重庆渝中半岛的一条街，从重庆城的上半城（山顶）通到下半城（山脚），全部由石阶铺成，<strong>把山顶的繁华商业区和山下江边的老城区连起来</strong>。</li><li><strong>拆迁了</strong></li></ul><h3 id="朝天门两江游"><a href="#朝天门两江游" class="headerlink" title="朝天门两江游"></a>朝天门两江游</h3><ul><li>重庆很出名的两江交汇：<strong>长江与嘉陵江</strong></li><li>夜景</li></ul><h3 id="长江索道"><a href="#长江索道" class="headerlink" title="长江索道"></a>长江索道</h3><ul><li>到达对岸后不用着急回来可以在那边拍拍照，然后再返回来</li></ul><h3 id="皇冠大扶梯"><a href="#皇冠大扶梯" class="headerlink" title="皇冠大扶梯"></a>皇冠大扶梯</h3><ul><li>亚洲第二长的一级提升坡地大扶梯</li><li>这个扶梯<strong>不用刻意去</strong>，如果方便可以去坐坐，其实<em>就是一个长长的扶梯</em>，但是因为有坡度而且特别长所以很炫酷！</li></ul><h3 id="中山四路"><a href="#中山四路" class="headerlink" title="中山四路"></a>中山四路</h3><ul><li>历史遗迹很多，除了中国民主党派博物馆的特园外，此地还有桂园、周公馆、戴公馆、张骧公馆、国民政府总统府旧址等</li></ul><h3 id="解放碑"><a href="#解放碑" class="headerlink" title="解放碑"></a>解放碑</h3><ul><li><strong>解放碑是重庆的标志</strong>，特别是圣诞节和跨年的时候，大家会不约而同地去解放碑一同度过！场面壮观到每年都会提前进行封路。</li><li>解放碑那有一条<strong>好吃街</strong>，可以去吃吃～</li><li><strong>李串串</strong></li></ul><h3 id="两江影视城民国街"><a href="#两江影视城民国街" class="headerlink" title="两江影视城民国街"></a>两江影视城民国街</h3><ul><li>再现了百年老重庆风土人情</li><li>影视城里重现了当时的解放碑、磁器口、朝天门、十八梯，特别有意思</li><li>当地也可以<strong>租民国服装</strong></li></ul><h2 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h2><h3 id="重庆小面"><a href="#重庆小面" class="headerlink" title="重庆小面"></a>重庆小面</h3><h3 id="重庆火锅"><a href="#重庆火锅" class="headerlink" title="重庆火锅"></a>重庆火锅</h3><ul><li><strong>大龙火锅</strong>。以<strong>超辣</strong>闻名，吃这家店的人超级多，中午都得排很久的队</li></ul><h3 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h3><ul><li>串串推荐小郡肝、李记、怒火八零等等</li></ul><h3 id="酸辣粉-凉粉-冰粉凉虾-凉糕"><a href="#酸辣粉-凉粉-冰粉凉虾-凉糕" class="headerlink" title="酸辣粉/凉粉/冰粉凉虾/凉糕"></a>酸辣粉/凉粉/冰粉凉虾/凉糕</h3><ul><li><strong>莱得快</strong>的杂酱酸辣粉</li><li><strong>阿坤</strong>的杂酱酸辣粉、苕皮、海带，有点辣。但是阿坤里面有甜品所以可以也点一份甜品，防止被辣着，推荐它们的双皮奶。</li><li>好又来酸辣粉（口碑店家）、手工酸辣粉（视觉和味觉两不误）</li></ul><h3 id="麻辣鱼-酸菜鱼-尖椒兔"><a href="#麻辣鱼-酸菜鱼-尖椒兔" class="headerlink" title="麻辣鱼/酸菜鱼/尖椒兔"></a>麻辣鱼/酸菜鱼/尖椒兔</h3><ul><li>大渡口，店名是：<strong>霸王兔</strong></li></ul><h3 id="夜啤酒-万州烤鱼-烧烤"><a href="#夜啤酒-万州烤鱼-烧烤" class="headerlink" title="夜啤酒/万州烤鱼/烧烤"></a>夜啤酒/万州烤鱼/烧烤</h3><h3 id="奶制品"><a href="#奶制品" class="headerlink" title="奶制品"></a>奶制品</h3><ul><li>重庆本土的<strong>天友</strong>，以及后发的<strong>奶牛梦工厂</strong></li></ul><h2 id="参考路线"><a href="#参考路线" class="headerlink" title="参考路线"></a>参考路线</h2><ul><li><a href="https://www.zhihu.com/question/36219939/answer/109923082" target="_blank" rel="noopener">两天</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这里写摘要，显示更好看&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://showteeth.tech/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="旅游" scheme="http://showteeth.tech/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>comm-文件比较，文本文件的交集、差集与求差</title>
    <link href="http://showteeth.tech/posts/39582.html"/>
    <id>http://showteeth.tech/posts/39582.html</id>
    <published>2019-03-06T06:22:30.000Z</published>
    <updated>2019-03-14T10:17:06.893Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>comm</code>命令对两个文件内容进行比较，注意文件<strong>需要排序</strong>，相比于其他比较文件的命令，<code>comm</code>可以将文件内容不同的分列显示，<strong>便于提取(文件求交、并、差、对称差等)所需要的内容</strong>，另外两个文件比较命令包括<a href="http://showteeth.tech/posts/62860.html">cmp</a>、<a href="http://showteeth.tech/posts/56778.html">diff</a>。</p></div><a id="more"></a><h2 id="comm用法"><a href="#comm用法" class="headerlink" title="comm用法"></a>comm用法</h2><p><code>comm</code>命令会<strong>一行行(line by line)地</strong>比较两个<mark>已排序文件</mark>的差异，并将其结果显示出来，如果没有指定任何参数，则会把<strong>结果分成3行显示</strong>：</p><ul><li>第1行<strong>仅</strong>是在<strong>第1个文件中</strong>出现过的列</li><li>第2行是<strong>仅</strong>在<strong>第2个文件中</strong>出现过的列</li><li>第3行则是在第1与第2个文件里<strong>都出现过</strong>的列。</li></ul><p>若给予的文件名称为<code>-</code>，则<code>comm</code>命令会从<strong>标准输入</strong>设备读取数据</p><h3 id="comm命令格式"><a href="#comm命令格式" class="headerlink" title="comm命令格式"></a>comm命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  comm [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="comm-options说明"><a href="#comm-options说明" class="headerlink" title="comm options说明"></a>comm options说明</h3><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>不显示第1列（即不显示只在file1中找到的行）</td></tr><tr><td>-2</td><td>不显示第2列（即不显示只在file2中找到的行）</td></tr><tr><td>-3</td><td>不显示第3列（即不显示在两个文件中都找到的行）</td></tr><tr><td>–check-order</td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td>不判断所有输入文件是不是已经排好序</td></tr><tr><td>–output-delimiter=STR</td><td>指定输出结果的分隔符</td></tr></tbody></table><hr><p><br></p><h2 id="comm用法实例"><a href="#comm用法实例" class="headerlink" title="comm用法实例"></a>comm用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat a.txt<br>aaa<br>bbb<br>ccc<br>111<br>ddd<br>eee<br>222</p></blockquote><blockquote><p>cat b.txt<br>bbb<br>ccc<br>aaa<br>hhh<br>ttt<br>jjj</p></blockquote><p>注意上面两个文件都没有排序，看看comm对没排序文件的处理</p><hr><h3 id="使用默认方式对文本进行比较"><a href="#使用默认方式对文本进行比较" class="headerlink" title="使用默认方式对文本进行比较"></a>使用默认方式对文本进行比较</h3><blockquote><p><code>comm a.txt b.txt</code><br>aaa<br>bbb<br>ccc<br>comm: file 1 is not in sorted order<br>comm: file 2 is not in sorted order<br>111<br>aaa<br>ddd<br>eee<br>222<br>hhh<br>ttt<br>jjj</p></blockquote><p>从上面可以看出，没排序comm命令会爆出问题，但是仍然会运行得到结果；发现因为没有排序的原因，第二个文件的<code>aaa</code>在第一个文件中也存在但是却被当成了file2独有的。<strong>总的来说就是如果没排序，comm命令会爆出问题但不会停止运行，并且结果会存在问题</strong>，正常结果如下：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><p>可以看出默认情况会输出三列，第一列是第一个文件独有的内容，第二列是第二个文件独有的内容，第三列是第三个文件独有的内容，各列是以制表符<code>\t</code>作为定界符，可以通过对定界符-制表符<code>\t</code>的操作来达到相应的目的。</p><p>由于参数较为简单，这里就不单独列出每个参数单独的用法的示例，主要给出<strong>参数组合用法以及和定界符组合使用的示例如下</strong>：</p><table><thead><tr><th>集合操作</th><th>含义及对应的参数组合</th></tr></thead><tbody><tr><td>A∩B</td><td>文件交集，-12</td></tr><tr><td>A∪B</td><td>文件的并集，将输出整合为一列，去掉定界符\t</td></tr><tr><td>A-B</td><td>差集，-23</td></tr><tr><td>B-A</td><td>差集，-13</td></tr><tr><td>A∆B</td><td>对称差集，并集减去交集，也就是去除文件中相同的部分，需要使用-3以及将剩下两列整合为一列</td></tr></tbody></table><h3 id="12-A∩B-文件交集"><a href="#12-A∩B-文件交集" class="headerlink" title="-12-A∩B-文件交集"></a>-12-A∩B-文件交集</h3><p>默认输出结果的第三列就是两个文件共有的部分：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -12 - &lt;(sort -k 1,1 b.txt)</code><br>aaa<br>bbb<br>ccc</p></blockquote><hr><h3 id="定界符-t-A∪B-文件的并集"><a href="#定界符-t-A∪B-文件的并集" class="headerlink" title="定界符\t-A∪B-文件的并集"></a>定界符\t-A∪B-文件的并集</h3><p>并集就是将三列输出结果合并：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="23-A-B-差集"><a href="#23-A-B-差集" class="headerlink" title="-23-A-B-差集"></a>-23-A-B-差集</h3><p>差集就是在A中但是不在B中的部分，去掉第三列(A、B共有的)以及第二列B独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -23 - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>ddd<br>eee</p></blockquote><hr><h3 id="12-B-A-差集"><a href="#12-B-A-差集" class="headerlink" title="-12-B-A-差集"></a>-12-B-A-差集</h3><p>差集就是在B中但是不在A中的部分，去掉第三列(A、B共有的)以及第一列A独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -13 - &lt;(sort -k 1,1 b.txt)</code><br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="3-定界符-t-A∆B-对称差集"><a href="#3-定界符-t-A∆B-对称差集" class="headerlink" title="-3+定界符\t-A∆B-对称差集"></a>-3+定界符\t-A∆B-对称差集</h3><p>对称差集就是两个文件独有的内容的并集：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -3 - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="多列文件的处理"><a href="#多列文件的处理" class="headerlink" title="多列文件的处理"></a>多列文件的处理</h3><p>多列文件处理会<strong>将一整行当成一个元素进行比较</strong>，来列出各个文件独有的、文件共有的信息，具体的每列代表的意思和单列文件相同，注意如果<strong>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠</strong></p><blockquote><p><code>cat c.txt</code><br>aaa 111<br>bbb 222</p></blockquote><blockquote><p><code>cat d.txt</code><br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><blockquote><p><code>comm c.txt d.txt</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><p>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠：</p><blockquote><p><code>sed &#39;s/ /\t/&#39; c.txt |comm - &lt;(sed &#39;s/ /\t/&#39; d.txt)</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/comm" target="_blank" rel="noopener">comm命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-comm.html" target="_blank" rel="noopener">Linux comm命令</a></li><li><a href="https://www.cnblogs.com/nerxious/archive/2013/01/09/2853004.html" target="_blank" rel="noopener">简明Linux命令行笔记：comm</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;这篇文章学习了使用&lt;code&gt;comm&lt;/code&gt;命令对两个文件内容进行比较，注意文件&lt;strong&gt;需要排序&lt;/strong&gt;，相比于其他比较文件的命令，&lt;code&gt;comm&lt;/code&gt;可以将文件内容不同的分列显示，&lt;strong&gt;便于提取(文件求交、并、差、对称差等)所需要的内容&lt;/strong&gt;，另外两个文件比较命令包括&lt;a href=&quot;http://showteeth.tech/posts/62860.html&quot;&gt;cmp&lt;/a&gt;、&lt;a href=&quot;http://showteeth.tech/posts/56778.html&quot;&gt;diff&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://showteeth.tech/categories/Linux/"/>
    
    
      <category term="常用基本命令" scheme="http://showteeth.tech/tags/%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>anaconda安装多版本python及常用命令</title>
    <link href="http://showteeth.tech/posts/34297.html"/>
    <id>http://showteeth.tech/posts/34297.html</id>
    <published>2019-03-05T15:27:36.000Z</published>
    <updated>2019-03-07T01:47:33.958Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本是通过anaconda给电脑安装的python3，但是今天在从github上下载使用一个package时候报错：</p><blockquote><p>SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(‘File does not exist: %s’ % filepath)?</p></blockquote><p>后来发现这个是因为<strong>python版本的问题</strong>，所以就需要<strong>重新再安装一个python2的环境</strong></p><hr><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><p>这个本来可以使用简单地打开<code>anaconda navigator</code>图形界面进行<code>creat</code>环境即可，但是秉承着想对anaconda进行学习的态度，这里主要使用命令行的形式。</p><h3 id="显示所有环境名字和路径"><a href="#显示所有环境名字和路径" class="headerlink" title="显示所有环境名字和路径"></a>显示所有环境名字和路径</h3><p>创建新环境之前先看看目前的电脑有哪些环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>发现电脑只有一个原装的<code>base</code>环境，也就是<code>python3</code>的环境以及我自己安装的<code>rstudio</code>环境，同时需要注意<strong>上面的<code>*</code>表明是当前使用的环境！</strong></p><hr><h3 id="创建环境并指定环境名称和python版本"><a href="#创建环境并指定环境名称和python版本" class="headerlink" title="创建环境并指定环境名称和python版本"></a>创建环境并指定环境名称和python版本</h3><p>这一步是使用<code>conda create</code>创建环境，同时指定环境的名称为<code>pyenv2_7</code>，使用的python版本为<code>python=2.7</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pyenv2_7 python=2.7</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="再次显示所有环境名字和路径"><a href="#再次显示所有环境名字和路径" class="headerlink" title="再次显示所有环境名字和路径"></a>再次显示所有环境名字和路径</h3><p>创建新环境再次查看现在所有的环境名称和对应的路径：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><p>发现已经出现了新建的环境：</p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>pyenv2_7 C:\Users\14910\Anaconda3\envs\pyenv2_7<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>由于只是创建了环境，还没有激活，所以当前使用的环境(<code>*</code>标记的)还是<code>base</code>环境，<strong>新建的环境需要激活才能够使用</strong></p><hr><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>为了能够使用新创建的环境还需要激活：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pyenv2_7</span><br></pre></td></tr></table></figure><p></p><p>为了验证环境是不是已经成功应用，检查python版本：</p><blockquote><p>python –version<br>Python 2.7.15 :: Anaconda, Inc.</p></blockquote><p>发现环境已经安装成功</p><hr><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><p>使用完成之后推出新建的环境，回到<code>base</code>环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p></p><p><strong>注意<code>conda deactivate</code>后面不需要跟退出的环境名，直接就退出当前环境，退出环境之后直接就进入了base环境</strong>。</p><hr><h2 id="anaconda-常用命令"><a href="#anaconda-常用命令" class="headerlink" title="anaconda 常用命令"></a>anaconda 常用命令</h2><ul><li>activate // 切换到base环境</li><li>activate learn // 切换到learn环境</li><li>conda deactivate // 退出当前环境</li><li>conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)</li><li>conda env list (conda env –info) // 列出conda管理的所有环境</li><li>conda list // 列出当前环境的所有包</li><li>conda install requests (pip install requests) // 安装requests包</li><li>conda remove requests (pip uninstall requests) // 卸载requets包</li><li>conda update requests // 更新requests包</li><li>conda remove -n learn –all // <strong>删除learn环境及下属所有包</strong></li><li>conda env export &gt; environment.yaml // <strong>导出当前环境的包信息</strong></li><li>conda env create -f environment.yaml // <strong>用配置文件创建新的虚拟环境</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/tangwenbo124/article/details/74784044" target="_blank" rel="noopener">ananconda创建新环境，python 2.7、3.5共存，pycharm 使用conda新环境，win10、linux下通用</a></li><li><a href="https://www.jb51.net/article/114614.htm" target="_blank" rel="noopener">利用Anaconda完美解决Python 2与python 3的共存问题</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署github项目</title>
    <link href="http://showteeth.tech/posts/62916.html"/>
    <id>http://showteeth.tech/posts/62916.html</id>
    <published>2019-03-05T01:26:30.000Z</published>
    <updated>2019-03-06T04:41:05.761Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>linux系统，换电脑之后再写！</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://segmentfault.com/a/1190000011218410?utm_source=tag-newest" target="_blank" rel="noopener">Travis CI 自动化部署博客</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程</a></li><li><a href="https://www.cnblogs.com/zqzjs/p/6119750.html" target="_blank" rel="noopener">Travis CI用来持续集成你的项目</a></li><li><a href="https://www.cnblogs.com/morang/p/7228488.html" target="_blank" rel="noopener">使用travis-ci自动部署github上的项目</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;linux系统，换电脑之后再写！&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>管理多个SSH公钥</title>
    <link href="http://showteeth.tech/posts/51573.html"/>
    <id>http://showteeth.tech/posts/51573.html</id>
    <published>2019-03-05T01:21:56.000Z</published>
    <updated>2019-03-05T09:20:37.015Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法</p></div><a id="more"></a><h2 id="SSH-key介绍"><a href="#SSH-key介绍" class="headerlink" title="SSH key介绍"></a>SSH key介绍</h2><p>SSH key提供了一种与GitHub或其他平台通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub或其他平台作为自己的remote端服务器，进行版本控制。</p><p>需要注意的是<strong>不同平台的SSH key各不相同</strong>，所以为了能在各个平台上方便地使用git进行版本控制，就需要设置多个SSH key。</p><p><strong>使用SSH key的步骤</strong>：</p><ul><li>在客户端生成SSH key（密钥对：公钥-&gt;锁头和私钥-&gt;钥匙，利用了公钥和私钥实现数据加密和解密）</li><li>在服务端的配置文件中加入你的公钥。（比如我们需要再GitHub中粘贴你的公钥）</li></ul><p><strong>具体原理</strong>：用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回远程主机，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。</p><hr><p><br></p><h2 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h2><p>默认情况下，使用<code>ssh-keygen</code>生成会在<code>C:\Users\user\.ssh</code>目录下生成SSH key(<code>id_rsa</code>和<code>id_rsa.pub(公钥)</code>)，为了使生成了SSH key互不干扰，所以需要使用<code>-f</code>参数进行设置生成了SSH key名称，不然可能会覆盖。</p><p>在<strong>git bash</strong>中输入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/keyname(eg:github)</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/coding_pages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-t：指定要创建的密钥类型，默认是 rsa ，可以省略</span><br><span class="line">-C：添加注释，比如邮箱；</span><br><span class="line">-f：指定用来保存密钥的文件名；</span><br><span class="line">-b：指定密钥长度；</span><br><span class="line">-e：读取openssh的私钥或者公钥文件；</span><br><span class="line">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；</span><br><span class="line">-l：显示公钥文件的指纹数据；</span><br><span class="line">-N：提供一个新密语；</span><br><span class="line">-P：提供（旧）密语；</span><br><span class="line">-q：静默模式；</span><br></pre></td></tr></table></figure><p></p><p>上述命令输入后，会出现<strong>如下提示</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line"><span class="comment"># Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p></p><ul><li>可以不输入文件名，使用默认文件名（推荐），那么就会生成 github 和 github.pub 两个秘钥文件；</li><li>接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）；</li><li>也可以不输入密码，直接按回车，那么push的时候就不需要输入密码，直接提交到github上了；</li><li>将 github.pub 文件的内容添加到github上面的ssh key</li></ul><p>以上是生成一个的过程，生成另一个的过程也是相同的操作。</p><hr><p><br></p><h2 id="添加生成的SSH"><a href="#添加生成的SSH" class="headerlink" title="添加生成的SSH"></a>添加生成的SSH</h2><p>将上述得到的公钥(以<strong>pub结尾的文件</strong>内容复制到平台相应的ssh key添加部位)：</p><div><br><img title="github_key" alt="github_key" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/github_key.png?imageView2/2/w/600"><br></div><div><br><img title="coding_pages_key" alt="coding_pages_key" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/coding_pages_key.png?imageView2/2/w/600"><br></div><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在 <code>C:\Users\user\.ssh</code> 目录下新建一个config文件，并添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host 公司github的地址 如：github.com</span><br><span class="line">HostName 公司github的地址 如：github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host git.dev.tencent.com</span><br><span class="line">    HostName git.dev.tencent.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/coding_pages</span><br></pre></td></tr></table></figure><p>上述host地址的得到可以通过点击平台任意一个项目的<code>clone and download</code>看到，冒号<code>:</code>前面的就是host地址了</p><hr><p><br></p><h2 id="验证SSH-key是否添加成功"><a href="#验证SSH-key是否添加成功" class="headerlink" title="验证SSH key是否添加成功"></a>验证SSH key是否添加成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding pages</span></span><br><span class="line">ssh -T git@git.dev.tencent.com</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Hi showteeth! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><blockquote><p>Coding 提示: Hello showteeth, You’ve connected to Coding.net via SSH. This is a personal key.<br>showteeth，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</p></blockquote><p>到这里留完成了管理多个SSH公钥的步骤，接下来就可以不用输入密码地将代码托管到相应的平台上了!</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/3e57bb0f8185" target="_blank" rel="noopener">如何同时使用多个SSH公钥提交代码至不同平台</a></li><li><a href="https://blog.csdn.net/DBB_zifeng/article/details/71698865" target="_blank" rel="noopener">管理多个SSH公钥密钥</a></li><li><a href="https://www.jianshu.com/p/a869072a0092" target="_blank" rel="noopener">同一台电脑关于多个SSH KEY管理</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>PDF转HTML-pdf2htmlex</title>
    <link href="http://showteeth.tech/posts/40996.html"/>
    <id>http://showteeth.tech/posts/40996.html</id>
    <published>2019-03-04T03:41:11.000Z</published>
    <updated>2019-03-04T06:43:30.913Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。</p></div><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><p>由于电脑是windows系统，所以只能按照<a href="https://gist.github.com/cnstar9988/3571c66b49050d98df92142dc19fbb00" target="_blank" rel="noopener">这里</a>给定的教程进行安装，无奈尝试了很多次，最终都以失败告终，都有点想放弃使用这个工具了，但是后来尝试了其他工具如<a href="https://github.com/mgufrone/pdf-to-html" target="_blank" rel="noopener">pdf-to-html</a>，但是效果很差，出来的效果和原本的pdf差很多，所以还是放弃了。</p><p>最近忽然发现应该可以使用docker进行安装，所以尝试使用<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>，接下来就是安装和使用docker：</p><ul><li>注册docker账号然后下载</li><li>安装docker，这里注意如果电脑上安装了360会提示<strong>发现黑客新建用户帐号，建议阻止</strong>，鉴于360的一贯行为以及阻止后不能顺利安装，我选择了允许操作</li><li>安装完成之后会<strong>注销和重启电脑</strong>，这个按照提示操作即可</li><li>最后需要注意的是<strong>运行docker是在命令行形式下运行</strong>，而不是直接打开桌面的快捷方式</li></ul><hr><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>使用docker安装pdf2htmlex，可以参考<a href="https://github.com/BWITS/pdf2htmlEX_docker" target="_blank" rel="noopener">官方给出的教程</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><p>输入上述命令后<strong>发现错误</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> connection (Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span><br></pre></td></tr></table></figure><p></p><p>上网搜了一下，发现这个错误是因为网络原因导致无法拉取镜像，解决方法：<strong>使用国内的Docker仓库daocloud</strong>：</p><ul><li>进入<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daocloud关于docker加速器的网站</a>，找到<strong>配置 Docker 加速器</strong>下对应的操作系统，因为我使用的windows系统，所以选择windows系统下的<code>http://f1361db2.m.daocloud.io</code></li></ul><img title="docker配置镜像" alt="docker配置镜像" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/docker配置镜像2.png?imageView2/2/w/500"><ul><li>将上述所得到的的地址写入<code>docker-&gt;setting-&gt;daemon-&gt;registry mirrors</code>中，然后<strong>apply</strong>，docker会提示<strong>restart</strong>：</li></ul><img title="配置docker加速器" alt="配置docker加速器" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/docker配置镜像.png?imageView2/2/w/500"><ul><li>上述操作完成之后重新执行命令，发现下载速度飞快~~~</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="通过docker命令"><a href="#通过docker命令" class="headerlink" title="通过docker命令"></a>通过docker命令</h3><p>详细的使用参考<a href="https://github.com/coolwanglu/pdf2htmlEX/wiki/Quick-Start" target="_blank" rel="noopener">工具的github</a>，这里我只尝试较为简单的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX --zoom 1.8  resume.pdf</span><br></pre></td></tr></table></figure><p></p><p>用到的docker参数说明：</p><ul><li><code>-v</code>：挂载宿主机目录，~/pdf对应于C:\Users\user\pdf，/pdf的容器的目录，在容器启动后，容器内会自动创建/pdf目录，也就是冒号<code>:</code>前面的目录是宿主机目录，后面的目录是容器内目录。<strong>注意使用时docker会提示需要使用文件权限</strong>，如果宿主机目录放在C盘，还要输入电脑密码</li><li><code>--rm</code>：默认情况下，每个container在退出时，它的文件系统也会保存下来，该参数可以让docker在container结束时自动清理其所产生的数据</li><li><code>-ti</code>：以交互模式启动一个容器</li></ul><hr><h3 id="创建命令调用别名"><a href="#创建命令调用别名" class="headerlink" title="创建命令调用别名"></a>创建命令调用别名</h3><p>因为使用的docker安装，每次调用可能全长命令比较麻烦，所以这里使用alias创建命令别名-pdf2htmlEX：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己修改挂载目录</span></span><br><span class="line"><span class="built_in">alias</span> pdf2htmlEX=<span class="string">"docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX"</span></span><br></pre></td></tr></table></figure><p>这里一直没有成功不知道是为什么，总是显示<code>文件名、目录名或卷标语法不正确。</code>，但我直接使用命令不使用alias的方式却能正常使用，所以就没有继续使用这个</p><blockquote><p>系统自带的cmd是不支持alias的，我这里使用的是<a href="https://cmder.net/" target="_blank" rel="noopener">cmder</a>，很强大的命令行工具，关于如何在windows下配置这个工具，可以参考博客中关于配置cmder的文章</p></blockquote><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="工具" scheme="http://showteeth.tech/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="pdf2htmlex" scheme="http://showteeth.tech/tags/pdf2htmlex/"/>
    
  </entry>
  
  <entry>
    <title>coding_pages和mkdocs使用</title>
    <link href="http://showteeth.tech/posts/54578.html"/>
    <id>http://showteeth.tech/posts/54578.html</id>
    <published>2019-03-03T08:31:43.000Z</published>
    <updated>2019-03-05T09:56:22.851Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>coding pages和mkdocs使用简介</p></div><a id="more"></a><h2 id="注册coding-pages"><a href="#注册coding-pages" class="headerlink" title="注册coding pages"></a>注册coding pages</h2><ul><li>前往其<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>，常规的注册方法即可</li><li>关于会员：<ul><li><a href="https://feedback.coding.net/topics/7257" target="_blank" rel="noopener">免费升级</a>好像</li><li>升级之前不可以创建项目，如果有项目需要转让或者删除，具体操作步骤<a href="https://dev.tencent.com/help/doc/account/up-to-tencent#CODING-3" target="_blank" rel="noopener">参考文章</a></li></ul></li></ul><hr><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>填写项目标识，项目标识在最后创建完pages之后就会显示为username.coding.me/项目标识/</li><li>项目名称填写：username.coding.me，相当于 github 上面的 name.github.io</li><li>创建完成即进入项目，选择代码下的代码浏览，创建<code>index.html</code>页面(注意名字一定要叫 <code>index.html</code>)，随意写一段话：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Coding Pages<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Coding!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>然后点击左侧<strong>代码</strong>下的 <strong>Pages 服务</strong>，选择<strong>静态 Pages 服务</strong>，一键创建pages</li><li>静态 Coding Pages 允许的部署分支来源为master 分支和coding-pages 分支，默认部署来源是master 分支，用户可在设置(右上角)里更改部署来源（实测发现只有master分支）。部署成功后后可通过<code>&lt;user_name&gt;.coding.me／&lt;project_name&gt;</code>形式的 URL 访问静态 Pages</li><li>如果需要自定义域名，这个也在pages服务中的设置(右上角)中进行设置</li></ul><hr><p><br></p><h2 id="结合mkdocs"><a href="#结合mkdocs" class="headerlink" title="结合mkdocs"></a>结合mkdocs</h2><h3 id="安装相关packages"><a href="#安装相关packages" class="headerlink" title="安装相关packages"></a>安装相关packages</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装mkdocs</span></span><br><span class="line">pip install mkdocs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure><hr><h3 id="常规用法："><a href="#常规用法：" class="headerlink" title="常规用法："></a>常规用法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">mkdocs new my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动内建服务器</span></span><br><span class="line">mkdocs serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点生成，创建了一个 site 新目录</span></span><br><span class="line">mkdocs build</span><br></pre></td></tr></table></figure><hr><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主题和头像</span></span><br><span class="line">theme:</span><br><span class="line">  name: material</span><br><span class="line">  favicon: <span class="string">'/dark_logo_16x16.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加页面</span></span><br><span class="line">nav:</span><br><span class="line">- 主页 : index.md</span><br><span class="line">- 软件 : about.md</span><br><span class="line">- 项目 : about.md</span><br><span class="line">- 关于 : about.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持中文搜索，虽然search功能(lunr.js)暂不直接支持中文，但测试发现设置为日语后，中文和英文搜索都可以使用</span></span><br><span class="line">extra:</span><br><span class="line">  search:</span><br><span class="line">    language: <span class="string">'jp'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加扩展</span></span><br><span class="line">markdown_extensions:</span><br><span class="line">  - admonition</span><br><span class="line">  - codehilite:</span><br><span class="line">      guess_lang: <span class="literal">false</span></span><br><span class="line">      linenums: <span class="literal">false</span></span><br><span class="line">  ......</span><br><span class="line"><span class="comment"># 自定义的CSS和JS</span></span><br><span class="line">extra_javascript:</span><br><span class="line">  - <span class="string">'js/extra.js'</span></span><br><span class="line">  - <span class="string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'</span></span><br><span class="line"></span><br><span class="line">extra_css:</span><br><span class="line">  - <span class="string">'css/extra.css'</span></span><br></pre></td></tr></table></figure><hr><h3 id="上传到coding-pages"><a href="#上传到coding-pages" class="headerlink" title="上传到coding pages"></a>上传到coding pages</h3><ul><li>将coding pages项目clone到本地：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里本想使用ssh的链接，但是失败，提示repo不存在，但是使用https的却可以成功，需要再看看问题</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.dev.tencent.com/showteeth/project.git bio_projects</span><br></pre></td></tr></table></figure><ul><li>将原本mkdoc目录下的文件拷进这个目录</li><li><p>部署到coding pages，详细参考<a href="https://www.mkdocs.org/user-guide/deploying-your-docs/" target="_blank" rel="noopener">官方教程</a></p><ul><li>自动将相应内容推送到项目的 master 分支上，默认会部署在 gh-pages 分支上，而我的账户好像只能部署在master分支上，所以只能修改分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdocs gh-deploy -b master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>输入链接即可访问</p></li></ul><p>最后吐槽一句：coding pages真的好慢好慢！！！！</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.mkdocs.org/" target="_blank" rel="noopener">mkdocs的官方网站</a></li><li><a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs的github</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">mkdocs主题material的相关材料（拓展、代码高亮）</a></li><li><a href="https://docs.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">readthedocs的官方网站（介绍的比较简答，具体实施还是需要看mkdocs的网站说明）</a></li><li><a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs托管文档</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/syntax/note_style/" target="_blank" rel="noopener">支持的markdown语法</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">基于mkdocs-material搭建个人静态博客(含支持的markdown语法)</a></li><li><a href="https://docs.flc.io/more/github-travis-mkdocs-document/" target="_blank" rel="noopener">使用mkdocs搭建的文档库</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;coding pages和mkdocs使用简介&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="折腾" scheme="http://showteeth.tech/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="coding pages" scheme="http://showteeth.tech/tags/coding-pages/"/>
    
  </entry>
  
  <entry>
    <title>jupyter主题、插件、技巧、server搭建</title>
    <link href="http://showteeth.tech/posts/13473.html"/>
    <id>http://showteeth.tech/posts/13473.html</id>
    <published>2019-03-02T14:16:26.000Z</published>
    <updated>2019-03-05T07:55:51.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>针对默认的jupyter notebook的页面进行修改、增加一些插件使jupyter的使用更加方便，整理一些jupyter使用技巧，最后是关于搭建jupyter server的内容</p></div><a id="more"></a><h2 id="jupyter默认页面的修改"><a href="#jupyter默认页面的修改" class="headerlink" title="jupyter默认页面的修改"></a>jupyter默认页面的修改</h2><p>jupyter默认页面的修改主要是使用<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyter-themes</a>包。</p><h3 id="jupyter-themes安装"><a href="#jupyter-themes安装" class="headerlink" title="jupyter-themes安装"></a>jupyter-themes安装</h3><p>常规的<code>pip</code>安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install jupyterthemes</span></span><br><span class="line">pip install jupyterthemes</span><br><span class="line"></span><br><span class="line"><span class="comment"># upgrade to latest version</span></span><br><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure><ul><li>为了达到最好的效果，建议notebook的版本是<code>&gt;=5.6.0</code>，如果低于此版本可以使用<code>pip install --upgrade notebook</code>进行升级</li><li>refreshing / removing / resetting：如果想要恢复默认值或者使新采用的主题生效，可能需要清除浏览器缓存（不一定非要进行，看自己的浏览器和系统，真遇到情况可以参考<a href="https://github.com/dunovank/jupyter-themes/issues/86" target="_blank" rel="noopener">issue</a>）；进行上述操作后刷新浏览器肯定是要刷新浏览器的！</li><li>安装或其他问题直接上<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">github</a>找答案！</li></ul><hr><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jt  [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">    [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">    [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim]</span><br><span class="line">    [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout]</span><br><span class="line">    [-P] [-T] [-N] [-r] [-dfonts]</span><br></pre></td></tr></table></figure><p>具体的参数说明：</p><table><thead><tr><th>cl options</th><th>arg</th><th>default</th></tr></thead><tbody><tr><td>Usage help</td><td>-h</td><td>–</td></tr><tr><td>List Themes</td><td>-l</td><td>–</td></tr><tr><td>Theme Name to Install</td><td>-t</td><td>–</td></tr><tr><td>Code Font</td><td>-f</td><td>–</td></tr><tr><td>Code Font-Size</td><td>-fs</td><td>11</td></tr><tr><td>Notebook Font</td><td>-nf</td><td>–</td></tr><tr><td>Notebook Font Size</td><td>-nfs</td><td>13</td></tr><tr><td>Text/MD Cell Font</td><td>-tf</td><td>–</td></tr><tr><td>Text/MD Cell Fontsize</td><td>-tfs</td><td>13</td></tr><tr><td>Pandas DF Fontsize</td><td>-dfs</td><td>9</td></tr><tr><td>Output Area Fontsize</td><td>-ofs</td><td>8.5</td></tr><tr><td>Mathjax Fontsize (%)</td><td>-mathfs</td><td>100</td></tr><tr><td>Intro Page Margins</td><td>-m</td><td>auto</td></tr><tr><td>Cell Width</td><td>-cellw</td><td>980</td></tr><tr><td>Line Height</td><td>-lineh</td><td>170</td></tr><tr><td>Cursor Width</td><td>-cursw</td><td>2</td></tr><tr><td>Cursor Color</td><td>-cursc</td><td>–</td></tr><tr><td>Alt Prompt Layout</td><td>-altp</td><td>–</td></tr><tr><td>Alt Markdown BG Color</td><td>-altmd</td><td>–</td></tr><tr><td>Alt Output BG Color</td><td>-altout</td><td>–</td></tr><tr><td>Style Vim NBExt*</td><td>-vim</td><td>–</td></tr><tr><td>Toolbar Visible</td><td>-T</td><td>–</td></tr><tr><td>Name &amp; Logo Visible</td><td>-N</td><td>–</td></tr><tr><td>Kernel Logo Visible</td><td>-kl</td><td>–</td></tr><tr><td>Reset Default Theme</td><td>-r</td><td>–</td></tr><tr><td>Force Default Fonts</td><td>-dfonts</td><td>–</td></tr></tbody></table><p>github上有具体的示例用法，建议大家去看看，我这里挑选我最喜欢的配置如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t monokai -f firacode -fs 12 -cellw 70% -ofs 10 -dfs 11 -T -N -altp -lineh 140</span><br></pre></td></tr></table></figure><p></p><ul><li>上述命令是在cmd中输入进行配置，而不是在jupyter notebook中</li><li>-fs：字体大小</li><li>-ofs：输出字体大小</li><li>-dfs：pandas dataframe字体大小</li><li>-cellw：主体宽度</li><li>-T：显示导航栏</li><li>-N：显示文件名称</li><li>-altp：不显示格子左上角的number</li><li>-lineh：行高</li></ul><p>设置完成之后发现<strong>jupyter的logo没有完全显示出来</strong>，同时<strong>文件名称也只显示了一部分</strong>，这些需要修改，找到<code>C:\Users\username\.jupyter\custom</code>目录下的<code>custom.css</code>进行修改:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将none改为block来显示jupyter的logo --&gt;</span></span><br><span class="line">div#ipython_notebook &#123;</span><br><span class="line"> display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将height: initial修改为20px，这个可以自己设置 --&gt;</span></span><br><span class="line">span.save_widget span.filename &#123;</span><br><span class="line"> margin-left: 8px;</span><br><span class="line"> height: 22px;</span><br><span class="line"> font-size: 100%;</span><br><span class="line"> color: #a6e22e;</span><br><span class="line"> background-color: #282828;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述修改每次重新修改主题相关配置后都需要重新修改</p><p>修改绘图配置：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jupyterthemes <span class="keyword">import</span> jtplot</span><br><span class="line">jtplot.style(theme=<span class="string">'grade3'</span>,ticks=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>主要使用的包是<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">jupyter_contrib_nbextensions</a>，这是一个非常强大的包，里面包含了很多在jupyter notebook只很常用的插件，包括代码段、显示目录等等等，同时这个包还提供了一个链接：<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">A collection of various notebook extensions for Jupyter</a>，里面总结了可以用在jupyter notebook中的插件。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install the python package</span></span><br><span class="line"><span class="comment">## 这个安装经常失败，下载速度太慢了</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment">## 换用这个了</span></span><br><span class="line">pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install javascript and css files</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>上述两步安装完成之后就可以在jupyter的homo page看到如下的插件：</p><img title="jupyter插件" alt="jupyter插件" class="class1 class2" src="http://pn9abh3rj.bkt.clouddn.com/static/images/jupyter插件.png?imageView2/2/w/600"><p>选取插件安装：</p><ul><li><strong>Code prettify</strong></li></ul><p>插件的快捷键：ctrl + l进行单个cell的prettify（也可以在选中cell时直接点击导航栏的小锤子按钮）、Ctrl-Shift-L进行所有的的prettify<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个插件安装后提示yapf没有安装</span></span><br><span class="line">pip install yapf</span><br></pre></td></tr></table></figure><p></p><p>After checking “Snippets Menu” in Configurable nbextensions, Snippets did’t appear in</p><ul><li><strong>Collapsible headings</strong>-折叠标题</li><li><strong>Snippets</strong>-自定义代码片段</li></ul><p>修改<code>C:\Users\user\AppData\Roaming\jupyter\nbextensions\snippets\snippets.json</code>来添加新的代码段，注意是上面的地址，<strong>而不是anaconda目录下的文件，如果修改了anaconda下的文件不起作用</strong>。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "name" : "common_use",</span><br><span class="line">    "code" : [</span><br><span class="line">        "import os",</span><br><span class="line">        "import sys",</span><br><span class="line">        "import numpy as np",</span><br><span class="line">        "import pandas as pd"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编辑完成之后想要生效需要重启jupyter notebook</p><ul><li><strong>Table of Contents (2)</strong>-显示目录结构</li></ul><p>这个和上面的jupyter-themes好像要有些冲突，导航栏遮挡部分的目录结构，现在还不知道有没有什么解决办法， 可以取舍一下</p><ul><li><strong>Highlight selected word</strong>-高亮代码中与选中部分相同的</li><li><strong>highlighter</strong>-高亮选中的文本</li><li><strong>ExecuteTime</strong>-显示每个cell的运行时间</li><li><strong>table_beautifier</strong>-让输出的table更好看</li><li><strong>Snippets Menu</strong>-和snippet类似，但是<mark>没有正常工作，需要看看为什么？？？</mark></li><li><strong>Hinterland</strong>-自动补全代码</li></ul><hr><p><br></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li><a href="https://www.jianshu.com/p/a85bc2a8fa56" target="_blank" rel="noopener">多行输出</a></li><li><a href="https://zhuanlan.zhihu.com/p/32600329" target="_blank" rel="noopener">关于Jupyter Notebook的28个技巧(快捷键、Magic命令等)</a></li></ul><h2 id="jupyter-server搭建"><a href="#jupyter-server搭建" class="headerlink" title="jupyter server搭建"></a>jupyter server搭建</h2><ul><li><a href="https://bitmingw.com/2017/07/09/run-jupyter-notebook-server/" target="_blank" rel="noopener">搭建 ipython/jupyter notebook 服务器</a></li><li><a href="https://jupyter-notebook.readthedocs.io/en/stable/public_server.html" target="_blank" rel="noopener">Running a notebook server</a></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;针对默认的jupyter notebook的页面进行修改、增加一些插件使jupyter的使用更加方便，整理一些jupyter使用技巧，最后是关于搭建jupyter server的内容&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://showteeth.tech/categories/Python/"/>
    
    
      <category term="工具" scheme="http://showteeth.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>HTML中的实体空格与markdown空格缩进</title>
    <link href="http://showteeth.tech/posts/58681.html"/>
    <id>http://showteeth.tech/posts/58681.html</id>
    <published>2019-03-01T08:07:24.000Z</published>
    <updated>2019-03-05T14:19:16.552Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了HTML中的6种实体空格以及在实际markdown写作中会涉及到的空格缩进应该使用哪种空格实体会比较好，最后发现使用<code>&amp;emsp;</code>-全角空格在中文markdown写作中是最合适的</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在markdown写作过程中，我们可能需要再文本中插入一些空格，比如中文的首行缩进，与word文档写作直接使用space键空两格即可出现空格不同，markdown不会识别这种空格(四个空格会代表代码块)，为了达到插入空格的效果就需要使用<strong>HTML中的空格实体</strong></p><hr><h2 id="HTML中的实体空格"><a href="#HTML中的实体空格" class="headerlink" title="HTML中的实体空格"></a>HTML中的实体空格</h2><p>HTML提供了6种空格实体（space entity），它们拥有不同的宽度，<strong>非断行空格（<code>&amp;nbsp;</code>）是常规空格的宽度，可运行于所有主流浏览器</strong>。其他几种空格（<code>&amp;ensp;</code>、<code>&amp;emsp;</code>、<code>&amp;thinsp;</code>、<code>&amp;zwnj;</code>、<code>&amp;zwj;</code>）在<strong>不同浏览器中宽度各异</strong></p><h3 id="amp-nbsp-不换行空格"><a href="#amp-nbsp-不换行空格" class="headerlink" title="&amp;nbsp;-不换行空格"></a><code>&amp;nbsp;</code>-不换行空格</h3><p>&emsp;&emsp;它叫不换行空格，全称是 <strong>No-Break Space</strong>，它是最常见和我们<em>使用最多</em>的空格，大多数的人可能只接触了<code>&amp;nbsp;</code>，它是<strong>按下space键产生的空格，一般两个<code>&amp;nbsp;</code>对应于一个中文字符</strong>。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个），要使用html实体表示才可累加，<strong>该空格占据宽度受字体影响明显而强烈</strong>。</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不同的！</p><hr><h3 id="amp-ensp-半角空格"><a href="#amp-ensp-半角空格" class="headerlink" title="&amp;ensp;-半角空格"></a><code>&amp;ensp;</code>-半角空格</h3><p>&emsp;&emsp;它叫<strong>半角空格</strong>，全称是 <strong>En Space</strong>，<code>en</code>是字体排印学的计量单位，为<code>em</code>宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母<code>n</code>的宽度。此空格传承空格家族一贯的特性：透明的，<strong>此空格有个相当稳健的特性，就是其占据的宽度正好是<u>1/2个中文宽度</u>，而且<mark>基本上不受字体影响</mark></strong></p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不变的，并且两格空格占据一个字体大小！</p><hr><h3 id="amp-emsp-全角空格"><a href="#amp-emsp-全角空格" class="headerlink" title="&amp;emsp;-全角空格"></a><code>&amp;emsp;</code>-全角空格</h3><p>&emsp;&emsp;它叫<strong>全角空格</strong>，全称是 <strong>Em Space</strong>，<code>em</code>是字体排印学的计量单位，相当于当前指定的点数。例如，<code>1 em</code>在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，<strong>此空格也有个相当稳健的特性，就是其占据的宽度正好是<u>1个中文宽度</u>，而且<mark>基本上不受字体影响</mark></strong>，和上面的<code>&amp;ensp;</code>-半角空格特性相同，但是是一个中文宽度</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不变的，并且两格空格占据两个字体大小！</p><hr><h3 id="amp-thinsp-窄空格"><a href="#amp-thinsp-窄空格" class="headerlink" title="&amp;thinsp;-窄空格"></a><code>&amp;thinsp;</code>-窄空格</h3><p>&emsp;&emsp;它叫<strong>窄空格</strong>，全称是 <strong>Thin Space</strong>。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是<code>em</code>之六分之一宽(前面的<code>&amp;ensp;</code>-半角空格是<code>em</code>宽度的一半，<code>&amp;emsp;</code>-全角空格就是<code>em</code>宽度)</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&emsp;字体，前面有一个<code>&amp;emsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;字体，前面有六个<code>&amp;thinsp;</code>空格</font></li></ul><hr><h3 id="amp-zwnj-零宽不连字"><a href="#amp-zwnj-零宽不连字" class="headerlink" title="&amp;zwnj;-零宽不连字"></a><code>&amp;zwnj;</code>-零宽不连字</h3><p>&emsp;&emsp;它叫<strong>零宽不连字</strong>，全称是 <strong>Zero Width Non Joiner</strong>，简称“ZWNJ”，是一个<strong>不打印字符</strong>，放在<strong>电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制</strong>。<em>Unicode</em>中的零宽不连字<strong>字符映射为</strong>（zero width non-joiner，<code>U+200C</code>），HTML<strong>字符值引用</strong>为<code>&amp;#8204</code></p><h3 id="amp-zwj-零宽连字"><a href="#amp-zwj-零宽连字" class="headerlink" title="&amp;zwj;-零宽连字"></a><code>&amp;zwj;</code>-零宽连字</h3><p>&emsp;&emsp;它叫<strong>零宽连字</strong>，全称是 <strong>Zero Width Joiner</strong>，简称“ZWJ”，是一个<strong>不打印字符</strong>，放在某些需要<strong>复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果</strong>。零宽连字符的Unicode码位是<code>U+200D</code> (HTML:<code>&amp;#8205;</code>、<code>&amp;zwj;</code>）。</p><p>此外，<strong>浏览器还会把以下字符当作空白进行解析</strong>：空格<code>&amp;#x0020;</code>、制表位<code>&amp;#x0009;</code>、换行<code>&amp;#x000A;</code>、回车<code>&amp;#x000D;</code>和<code>&amp;#12288;</code>等等。</p><hr><h2 id="markdowm首行缩进方法"><a href="#markdowm首行缩进方法" class="headerlink" title="markdowm首行缩进方法"></a>markdowm首行缩进方法</h2><p>通过上述对HTML中实体空格的介绍，可以总结出以下几种可以用在markdown中充当首行缩进的方法：</p><ul><li>使用<code>&amp;emsp;</code>-全角空格，优点：占据的宽度正好是<u>1个中文宽度</u>，而且<strong>基本上不受字体影响</strong>，<strong>推荐使用这个进行首行缩进</strong></li><li>使用<code>&amp;ensp;</code>-半角空格，优点：占据的宽度正好是<u>1/2个中文宽度</u>，需要使用两格才能达到缩进效果，而且<strong>基本上不受字体影响</strong></li><li>使用<code>&amp;nbsp;</code>-不换行空格，缺点：<u>需要使用四个来代表两个中文字符</u>，并且<strong>受字体影响较大</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/31eade263e7a" target="_blank" rel="noopener">markdown空格缩进以及HTML空格实体</a></li><li><a href="https://blog.csdn.net/testcs_dn/article/details/78957685" target="_blank" rel="noopener">markdown编辑器中可以使用的6种空格标记</a></li></ul><p><br></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文主要学习了HTML中的6种实体空格以及在实际markdown写作中会涉及到的空格缩进应该使用哪种空格实体会比较好，最后发现使用&lt;code&gt;&amp;amp;emsp;&lt;/code&gt;-全角空格在中文markdown写作中是最合适的&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="其他内容学习" scheme="http://showteeth.tech/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="markdown" scheme="http://showteeth.tech/tags/markdown/"/>
    
  </entry>
  
</feed>
