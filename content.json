{"meta":{"title":"showteeth's blog","subtitle":null,"description":null,"author":"showteeth","url":"http://showteeth.tech"},"pages":[{"title":"","date":"2019-02-17T05:56:14.120Z","updated":"2019-02-17T05:56:14.120Z","comments":true,"path":"projects/index.html","permalink":"http://showteeth.tech/projects/index.html","excerpt":"","text":"This is a project pageUnder construction"},{"title":"","date":"2019-02-17T05:56:27.181Z","updated":"2019-02-17T05:56:27.181Z","comments":true,"path":"about/index.html","permalink":"http://showteeth.tech/about/index.html","excerpt":"","text":"This is a self-introduce pageUnder construction"}],"posts":[{"title":"test-copyright","slug":"test-copyright","date":"2019-02-19T04:00:00.000Z","updated":"2019-02-19T04:01:03.116Z","comments":true,"path":"posts/37032.html","link":"","permalink":"http://showteeth.tech/posts/37032.html","excerpt":"Abstract:test copyright","text":"Abstract:test copyrightthis is title","categories":[],"tags":[]},{"title":"test_password","slug":"test-password","date":"2019-02-17T13:43:32.000Z","updated":"2019-02-19T04:13:06.783Z","comments":true,"path":"posts/30737.html","link":"","permalink":"http://showteeth.tech/posts/30737.html","excerpt":"Abstract:这是一篇用来测试加密文章的博客。","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/NexVxZRq4VhNAFSPjC6gkurGE+FVSJATMpNgJ29NEVJZNhma736gXjX2jDgg8ecpGgW9K5nvdc5K4QEZ31k+lvla3QP8UaVaNVaV/0H1hej1lbolRcefAtBSBxTy+E/yQMX1HL+FNojSLg/O9OmU9LvNUb3juIfG/Wj+I1uN5XioNSXewS9xv7o2njV/VpFIcTXPtq2HsCCyIJ2WHyaMfGF8LXU9CUXUkIrBP/0tHx14yF3/Pb1XZoE7FCwOjaqqJ8qqBUC7qoERsZc3utVlAlHCqyfPa3Zz//MMQXwPIW8d5hCqTSNcgAO+K439R5WVyD6CNFxq2PRNEANoAmQwAR3kBk40gXnWDbPoRrwLIuN0acko+yVvG93fd0mB++yUsbC0GX4X5IjqNa6KX6Jgvv3w4c4N7YwgcYJXVeJmmNRzpRCfE+IA6qZnrrkSfIbZcBYa10SvVT13RDTRfMRgbSLqi1ywHQfZeVN0S5lVGFWjvV23ONCIh2wx7QHhdo3R2ZVmBNGpYLayfWwLharGE1XZd6DYB3RpMiBuBA5BFy8MW0XdXRlCamifT6RsGeP66h8w+a134va0j0Fvlluc+UM5jGkhCdCTKAXbYy+gO+njFzYTZw48fT2T+DFNgVnZwo6A4IJaHrsdm1QKVUKN/iavPYyJatBwX64ScJmvYO1BmUOjAbk1jzEG+BIImm1jGPbZtKAdZYfRROYC2eg5X2T8I/HK6ItORwwvPptwbMigLYqw7aUEoDIADZ04Jhjk9Ghy0ypb1Zuo9/bubINyAD8qD2RQaq6ZNgAmjdmeFWRghGohNyrQ4IZB1uhga6PqX/4YR0YLM1rgy0qN7ijE+ms3z0CrOtOzjqiAwiAhAHRjwgfoeX0VvN6uV7ukjbLmVzOTmz2QVXL/ULGwZmG/ZTnRG/1yUemDz7nI0rXTl7ZO+Dvwei17GvVoVL0ewblhJ/Sh29ysGxMJ4BMxv5RF4I6xzP77fBQgLUy18UN+/rDGCC0zNLoYq8gC8mE4WXIuP1ftshpiyS4mtvAGmkyF4tAS46xj0B2gI3CdtEYmpi+6joXWE3g7asBc2QuDn3RToSU9F1M7f9FVhcCZkqbeffzhmK9rojRNYVcC/srOwU0OpboBNMcfqV+IlGDL/SOHvud4gI54Eo4CnGO+6Es3oAkaxqV0B7aptenHsRce/J5gZkOuK4ShSXPJgLEck0+cH9jIFb/mT6KuG0H5hLD4JGpL2+foVQzMfsMUbP6MLHUyIw/O558B5BMbksJlgaDtNa1+AdhETmCV4meoLqqnVqZV37ABEqcdGwrzZAyM/T1wQQyDkm///0My+W3TxvJZUdJAJMg8nEa1B+SS8wXACoz7TsHNtaF2CYs2c4ENQUlZn6rN2T7Z4gnodPlMeWjv8rLJnQmFfdEJd+k2OaXXHZZ1uyxYc0aH+DQSWzActD74dv4BW9ueNwu4v9e4q1HEhmxbhhf7eGYlU+QDHPLwxkNlptfrXhsA= var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[{"name":"test","slug":"test","permalink":"http://showteeth.tech/categories/test/"}],"tags":[{"name":"password","slug":"password","permalink":"http://showteeth.tech/tags/password/"}]},{"title":"test_templete2","slug":"test-templete","date":"2019-02-16T15:38:36.000Z","updated":"2019-02-17T11:19:49.821Z","comments":true,"path":"posts/37746.html","link":"","permalink":"http://showteeth.tech/posts/37746.html","excerpt":"Abstract: 测试创建博客模板","text":"Abstract: 测试创建博客模板this is contentthis is sub title“百度”二字，来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。1999年底，身在美国硅谷的李彦宏看到了中国互联网及中文搜索引擎服务的巨大发展潜力，抱着技术改变世界的梦想，他毅然辞掉硅谷的高薪工作，携搜索引擎专利技术，于 2000年1月1日在中关村创建了百度公司。","categories":[{"name":"test","slug":"test","permalink":"http://showteeth.tech/categories/test/"}],"tags":[{"name":"templete","slug":"templete","permalink":"http://showteeth.tech/tags/templete/"}]},{"title":"test-top2","slug":"test-top2","date":"2019-02-14T16:00:00.000Z","updated":"2019-02-19T06:25:45.604Z","comments":true,"path":"posts/39162.html","link":"","permalink":"http://showteeth.tech/posts/39162.html","excerpt":"Abstract: 测试置顶标签2","text":"Abstract: 测试置顶标签2this is titlethis is subtitle","categories":[{"name":"test","slug":"test","permalink":"http://showteeth.tech/categories/test/"}],"tags":[{"name":"top","slug":"top","permalink":"http://showteeth.tech/tags/top/"}]},{"title":"test-top","slug":"test-top","date":"2019-02-14T16:00:00.000Z","updated":"2019-02-19T06:25:34.245Z","comments":true,"path":"posts/48109.html","link":"","permalink":"http://showteeth.tech/posts/48109.html","excerpt":"Abstract: 测试置顶操作","text":"Abstract: 测试置顶操作this is titlethis is subtitle","categories":[{"name":"test","slug":"test","permalink":"http://showteeth.tech/categories/test/"}],"tags":[{"name":"top","slug":"top","permalink":"http://showteeth.tech/tags/top/"}]},{"title":"四种方法实现数据双向绑定","slug":"四种方法实现数据双向绑定","date":"2018-05-10T03:29:08.000Z","updated":"2019-02-18T17:02:57.141Z","comments":true,"path":"posts/12160.html","link":"","permalink":"http://showteeth.tech/posts/12160.html","excerpt":"前言在一些前端框架中，例如 angular，vue都有数据双向数据绑定的功能，这个功能极大的方便我们操作数据。那么接下来我会讲解一下双向数据绑定的4种实现方式。","text":"前言在一些前端框架中，例如 angular，vue都有数据双向数据绑定的功能，这个功能极大的方便我们操作数据。那么接下来我会讲解一下双向数据绑定的4种实现方式。方式1.手动触发绑定手动触发绑定的主要思路是通过在数据对象定义 get 和 set 方法(可以使用其他的命名方法)，调用时手动去触发 get 和 set 方法去获取数据，修改数据，改变数据后会主动去触发 get 和 set 函数中视图层的重新渲染。简单的手动触发绑定代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;手动双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"input\" s-value=\"value\"&gt; &lt;span id=\"el\" s-text=\"value\"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let data = &#123; value: '' &#125; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; set('value', e.target.value) &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; function set(key, value) &#123; data[key] = value; scan(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.数据劫持数据劫持的基本思路是使用 Object.defineProperty 对 ViewModel 数据对象进行 get 和 set 的监听，当有数据变动的时候扫描元素节点，然后去运行对应节点上的指令（directive）。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;数据劫持&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"input\" s-value=\"value\"&gt; &lt;span id=\"el\" s-text=\"value\"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let data = &#123; value: '' &#125; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; let value; defineGetAndSet(data, 'value') // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; function defineGetAndSet(obj, attrName) &#123; Object.defineProperty(obj, attrName, &#123; get: function () &#123; return value &#125;, set: function (newValue) &#123; value = newValue; scan() &#125;, configurable: true, enumerable: true &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.使用 es6的 Proxy利用Proxy ，它可以目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此可以对外界的访问进行过滤和改写，实现数据双向数据绑定和上一个类似。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;使用 proxy 进行数据双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"input\" s-value=\"value\"&gt; &lt;span id=\"el\" s-text=\"value\"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; // ------------- 看下面 ------------- let data = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; return target.value &#125;, set(target, key, value, receiver) &#123; target.value = value; scan(); &#125; &#125;) // ------------- 看上面 ------------- // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 脏检查脏检查的基本原理是在 ViewModel 对象的某个属性值发生变化的时候找到与这个属性值相关的所有元素，然后去比较数据变化，如果变化就用 directive 指令调用，对这个元素进行重新渲染。简单的脏检查代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;脏检查&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"input\" s-bind=\"value\" s-event=\"value\"&gt; &lt;span id=\"el\" s-event=\"text\" s-bind=\"value\"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let directives = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; let data = &#123; value: '' &#125; // 扫描元素，使每个元素的 directive 数组为空 scan(elems) // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; startDirtyCheck(e.target.getAttribute('s-bind')) &#125;) function scan() &#123; for (let elem of elems) &#123; elem.directive = [] &#125; &#125; // 开启脏检查 function startDirtyCheck(value) &#123; let list = document.querySelectorAll('[s-bind=' + value + ']') dirtyCheck(list) &#125; function dirtyCheck(elems) &#123; // 扫描带指令的节点属性 for (let i = 0, len = elems.length; i &lt; len; i++) &#123; let elem = elems[i]; for (let j = 0, len1 = elem.attributes.length; j &lt; len1; j++) &#123; let attr = elem.attributes[j]; if (attr.nodeName.indexOf('s-event') !== -1) &#123; let dataKey = elem.getAttribute('s-bind') // 进行脏数据检查，如果数据改变，重新执行指令 if (elem.directive[attr.nodeValue] !== data[dataKey]) &#123; directives[attr.nodeValue].call(elem, data[dataKey]) elem.directive[attr.nodeValue] = data[dataKey] &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://showteeth.tech/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://showteeth.tech/tags/前端/"},{"name":"js","slug":"js","permalink":"http://showteeth.tech/tags/js/"}]}]}