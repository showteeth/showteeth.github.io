<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test-copyright]]></title>
    <url>%2Fposts%2F37032.html</url>
    <content type="text"><![CDATA[Abstract:test copyrightthis is titleTESTTHIS IS A TEST]]></content>
  </entry>
  <entry>
    <title><![CDATA[test_password]]></title>
    <url>%2Fposts%2F30737.html</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+zBPL1Pw9qUAGXMvcqq5I/X/P3K6mXdV2du3onR0JzooOAs621TohNx9zhMtkIJRsUeUqTsJarNpW+P2QnYVP0QCX0s5NMWGHHNtIMDOt/pHxZpBmu4Tp/8Hn0i1IbLusyIu4MkpiLeKPpcwcGIwXIbh1Zn/aWPDqSRBUOGoeeI38woX9/azt2fjDYEmtudnBH54fF6JtxEttWOdyzilghnB1W4uvzZJfJdYfBa8txNDCExFiATymXMFdg0kV/H4Msws87lll3tx0gz7s+Af3LJcJK9PJzJdLZlV88Fali1+2MZUdOeA8n0XFrqoyW7N0U7Pcvj8H7y6MUuZ0zxnY+Lk5SuD8Jl+SOBnaMAdsnUzscOGnxOlmrm/zCW9bdnr3Xl5j/fWyzO3gep6bdHKsjOBGjgAbu3oJV9ZLX/A10PPt29g+XuDcoDfDQ7RGeAwoNLAma3GoOguge9fWhtdLTy7tS5oGetna6P0a0CTepX+TNsTfATtTUI8rFiTuO6Abk79vLWcosKuBU2n/mP9rPJSTb+ADEujKi9x911Y18668hv6uShEyOCt/BYhKmxbKa08IVUEp11HdQN33LUjEGfAtuC9P1irn4PFawHBq1FbfihL+QJMjzLuuOuixSZw2am9TenHDFHteUaiazgKcqw5qHZqUZwUHW/qf4/2JbTcKgx36CkTTHQ4KgEOycB5oE0k91u3kc8qqiNEd0eOkO1MG+wznebKTB9DROGYPrbPcMT+oHmokHsoWF5Tduez77A8dou6PvXiMMRh941EFrkPLKZt3Gxjie4XtyaXUBz1/mZlr2duEAQd8f0SkeJLiRoyoz4jAPliTOSHha8WdvYmqT1IXOqr47V1wzu6BsnCgHpQJdO/Vb58jobyNJUkYKrXYIlmSXoP4Cd16Y8DWMOE/nI4tGCcFnz9jFZUaLCw0Vi/UaLQJmriRHhC6hjbBVQE4F/FOwB86y9lhG7IN0UddQdVNq1QrlpD8pEysfEjVuBk+zosMBoshy6Glcql1JOPyFJIEmQiwaeOCpNycenNQf7IEF63grvWKw4w4faJs2uqfttut+dapKTEvj/8tBBqhZIbsohWpObWYnPl1rOi0DD3uP2ICpYqQIsdB/n+DZF0ZVsiTxE7A098ogP4UmGIGHxiKRhCszIjCzGREqeOBfUpWmkQmp6yHZAnV2RT+8J7xMuRuisjjOW7DKsWkzaiLO+soiXyoRu8wGoI5UBq6pgt7Cl+1Zx6oGZDw5/lVb+VW/9oG+I68YlUUhYNkMyZYKMkIA2oa8UriuNzI4GUGs3RutHC2ycsxi2hyXGIOOgJMyYfBegkzdLUKB906lPrMXMTNML8qncdsm21R7KAxKFFQZZHvbd95zoUiG3lNdv7SOP+grNTYRgHpoTn7uNdiBbe2TfdkwxMSm2uFmXY5ggn929xhi2HMUd6T7ahi0llhIsobOVMz3vZx2jnaSSUfc29PwSQYXVWmD7rEuDw1XHnbmg10= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>password</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题markdown技巧和模板]]></title>
    <url>%2Fposts%2F37746.html</url>
    <content type="text"><![CDATA[博客中常用的样式和模板markdown技巧分割线和空行1234&lt;hr /&gt;上面是分割线&lt;br /&gt;上面是空行上面是分割线上面是空行markdown引用以及html写法123&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;!-- 如果前后间隙很小，可以像下面这样写 --&gt;&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt;效果如下：引用内容引用内容居中和右对齐1234&lt;!-- 居中 --&gt;&lt;center&gt;内容&lt;/center&gt;&lt;!-- 右对齐 --&gt;&lt;div style="text-align:right"&gt;内容&lt;/div&gt;效果如下：内容内容字体大小和颜色123&lt;font color="#FF0000" size="8px"&gt;红色&lt;/font&gt;&lt;font color="#FFFF00" size="6px"&gt;黄色&lt;/font&gt;&lt;font color="#00FF00" size="4px"&gt;绿色&lt;/font&gt;效果如下：红色黄色绿色更多颜色请查看 web安全色、颜色对照表Todo list1234&lt;ul&gt;&lt;li&gt;&lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成&lt;/li&gt;&lt;li&gt;&lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成&lt;/li&gt;&lt;/ul&gt;效果如下： 已完成 未完成Note 嵌套 Todo list123456789101112131415161718192021222324&lt;!-- 一共有两种写法，效果看下面 --&gt;&lt;div class="note primary"&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成&lt;/div&gt;&lt;div class="note primary"&gt; &lt;p&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;/p&gt;&lt;/div&gt;效果如下： 已完成 已完成 已完成 已完成 已完成 未完成 未完成 未完成 已完成 已完成 已完成 已完成 已完成 未完成 未完成 未完成插入代码代码块1&lt;!-- ```[language] [title] [url] [link-text] --&gt;注意前后都，上面演示如果后面加了会出错language表示代码语言title表示出现在代码框左上角的标题url表示超链接地址link-text表示超链接的名称这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加 [] 了，要这样写：[] [] [url] [link text] 个人只验证出可以加title，url和text没验证成功。效果如下：title1&lt;div&gt;&lt;/div&gt;各种支持语言的名称可以查看这篇文章行内代码1`test`Font Awesome放大图标的方法示例：123&lt;i class="fa fa-download"&gt;&lt;/i&gt; 普通&lt;i class="fa fa-download fa-lg"&gt;&lt;/i&gt; 变大 33%&lt;i class="fa fa-download fa-2x"&gt;&lt;/i&gt; 两倍大效果如下： 普通 变大 33% 两倍大note标签next主题的note标签功能我一发现就爱上了，实在很好看啊~~~~首先该功能可以在next\_config.yml配置文件中进行配置，默认是打开的，但是可以挑选自己喜欢的模式。12345678910111213# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0我自己选择了其中的flat style，其用法如下：123456789101112131415&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt;&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt;&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt;&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt;&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;p&gt;danger&lt;/p&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&#123;% note danger %&#125;note danger, note danger, note dangernote danger, note danger, note dangernote danger, note danger, note danger&#123;% endnote %&#125;效果如下：defaultprimarysuccessinfowarningdangerdanger no-iconnote danger, note danger, note dangernote danger, note danger, note dangernote danger, note danger, note dangernext\_config.yml三种样式的具体情况请看网站label标签该标签也是在next\_config.yml配置文件中，默认是打开的default1&#123;% label default@default %&#125;primary1&#123;% label primary@primary %&#125;success1&#123;% label success@success %&#125;info1&#123;% label info@info %&#125;warning1&#123;% label warning@warning %&#125;danger1&#123;% label danger@danger %&#125;### Tab 选项卡该标签也是在next\_config.yml配置文件中1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 3用法讲解：123456789101112131415161718192021222324tabs.js | global hexo script.Usage:&#123;% tabs [Unique name], [index] %&#125;&lt;!-- tab [Tab caption]@[icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;[Unique name] : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not defined, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. May be not defined.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. May be not defined.[icon] : Font awesome icon. May be not defined.设定选中第二个选项卡应用示例：1234567891011&#123;% tabs 选项卡, 2 %&#125;&lt;!-- tab --&gt;**这是选项卡 1** 呵呵哈哈哈哈哈哈&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 2** 额。。。&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3** 哇，你找到我了！&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：选项卡 1选项卡 2选项卡 3这是选项卡 1 呵呵哈哈哈哈哈哈这是选项卡 2 额。。。这是选项卡 3 哇，你找到我了！tabs 选项卡, 2：选项卡表示选项卡的名称，如果为tab，得到的选项卡显示为tab 1、tab 2、tab 3；2 表示一开始在第二个选项卡，非必须，若数值为 -1 则隐藏选项卡内容(也就是不显示呵呵哈哈哈哈哈哈这一些话，点击之后才会显示)。自定义每个选项卡的名称1234567891011&#123;% tabs Fourth unique name %&#125;&lt;!-- tab Solution 1 --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 2 --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 3 --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：Solution 1Solution 2Solution 3This is Tab 1.This is Tab 2.This is Tab 3.上面的solution 1、2、3即为自定义的，每个tab都可以设置自己的每个tab只显示图标1234567891011&#123;% tabs Fifth unique name %&#125;&lt;!-- tab @text-width --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab @amazon --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab @bold --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：This is Tab 1.This is Tab 2.This is Tab 3.上面的@amazon即为图标icon既显示图标有显示名称1234567891011&#123;% tabs Sixth unique name %&#125;&lt;!-- tab Solution 1@text-width --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 2@amazon --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 3@bold --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：这个貌似会报错制作链接，快速访问多个tabs组参见网址tabs中套用其他标签12345678910111213141516171819202122232425262728293031323334353637383940&#123;% tabs Tags %&#125;&lt;!-- tab --&gt;**This is Tab 1.**1. One2. Two3. ThreeTabbed code block: nano /etc&#123;% code %&#125;code block tagcode block tagcode block tag&#123;% endcode %&#125;&#123;% note default %&#125;Note default tag.&#123;% endnote %&#125;&#123;% youtube A1Qb4zfurA8 %&#125;&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.*** Five* Six* Seven&#123;% note primary %&#125;&#123;% youtube rX3W5evpeJE %&#125;&#123;% endnote %&#125;&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&#123;% note success %&#125;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.&#123;% endnote %&#125;&lt;!-- endtab --&gt;&#123;% endtabs %&#125;最终效果：Tags 1Tags 2Tags 3This is Tab 1.OneTwoThreeTabbed code block:nano /etc 123code block tagcode block tagcode block tagNote default tag.This is Tab 2.FiveSixSevenThis is Tab 3.Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.按钮样式1&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;最终效果：更多关于按钮的使用点这里点击上面的按钮可以跳转到另一个网址，查看更过关于按钮的操作插入照片因为图片功能在markdown语法中比较常用，所以将其单列出来，便于查找。使用七牛作为图床用法实例：123456&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;&lt;!-- 将其插入html语句中 --&gt;&lt;div align="right"&gt;&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;&lt;/div&gt;title：鼠标移到图片上显示的名称alt：图片不能正常加载时显示的说明文字extend:?imageView2/2/w/600 ：表示生成宽度最多600px的缩略图最终效果：好像会自动进行居中处理常规markdown语法12345![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;&lt;center&gt;![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")&lt;/center&gt;最终效果：Optional title 是用来在鼠标移到图片上时显示的title使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别html代码插入图片针对使用markdown插入图片的缺点，使用html语句可以很好的解决123456&lt;!-- 使用img标签--&gt;&lt;img src="http://pn9abh3rj.bkt.clouddn.com/test.png" width = "300" height = "200" alt="图片名称" align=center /&gt;&lt;!-- 使用div标签包裹 --&gt;&lt;div align="center"&gt;&lt;img src="http://pn9abh3rj.bkt.clouddn.com/test.png" title="使用html插入图片" alt="图片名称" /&gt;&lt;/div&gt;最终效果：不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；推荐使用div标签包裹img标签。tips博客一般都以二级标题开始写起html代码如div标签后面一定要空行标签之间一般都是可以嵌套的插入图片推荐使用div标签包裹img标签实现参考链接很详细很好的技巧文章支持highlight的语言note、label、button、tab使用讲解及示例note、label、tab使用讲解及示例]]></content>
      <categories>
        <category>hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>markdown</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test-top2]]></title>
    <url>%2Fposts%2F39162.html</url>
    <content type="text"><![CDATA[Abstract: 测试置顶标签2this is titlethis is subtitle]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test-top]]></title>
    <url>%2Fposts%2F48109.html</url>
    <content type="text"><![CDATA[Abstract: 测试置顶操作this is titlethis is subtitle]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种方法实现数据双向绑定]]></title>
    <url>%2Fposts%2F12160.html</url>
    <content type="text"><![CDATA[前言在一些前端框架中，例如 angular，vue都有数据双向数据绑定的功能，这个功能极大的方便我们操作数据。那么接下来我会讲解一下双向数据绑定的4种实现方式。方式1.手动触发绑定手动触发绑定的主要思路是通过在数据对象定义 get 和 set 方法(可以使用其他的命名方法)，调用时手动去触发 get 和 set 方法去获取数据，修改数据，改变数据后会主动去触发 get 和 set 函数中视图层的重新渲染。简单的手动触发绑定代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;手动双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-value="value"&gt; &lt;span id="el" s-text="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let data = &#123; value: '' &#125; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; set('value', e.target.value) &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; function set(key, value) &#123; data[key] = value; scan(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.数据劫持数据劫持的基本思路是使用 Object.defineProperty 对 ViewModel 数据对象进行 get 和 set 的监听，当有数据变动的时候扫描元素节点，然后去运行对应节点上的指令（directive）。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;数据劫持&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-value="value"&gt; &lt;span id="el" s-text="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let data = &#123; value: '' &#125; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; let value; defineGetAndSet(data, 'value') // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; function defineGetAndSet(obj, attrName) &#123; Object.defineProperty(obj, attrName, &#123; get: function () &#123; return value &#125;, set: function (newValue) &#123; value = newValue; scan() &#125;, configurable: true, enumerable: true &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.使用 es6的 Proxy利用Proxy ，它可以目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此可以对外界的访问进行过滤和改写，实现数据双向数据绑定和上一个类似。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;使用 proxy 进行数据双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-value="value"&gt; &lt;span id="el" s-text="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; // ------------- 看下面 ------------- let data = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; return target.value &#125;, set(target, key, value, receiver) &#123; target.value = value; scan(); &#125; &#125;) // ------------- 看上面 ------------- // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 脏检查脏检查的基本原理是在 ViewModel 对象的某个属性值发生变化的时候找到与这个属性值相关的所有元素，然后去比较数据变化，如果变化就用 directive 指令调用，对这个元素进行重新渲染。简单的脏检查代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;脏检查&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-bind="value" s-event="value"&gt; &lt;span id="el" s-event="text" s-bind="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let directives = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; let data = &#123; value: '' &#125; // 扫描元素，使每个元素的 directive 数组为空 scan(elems) // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; startDirtyCheck(e.target.getAttribute('s-bind')) &#125;) function scan() &#123; for (let elem of elems) &#123; elem.directive = [] &#125; &#125; // 开启脏检查 function startDirtyCheck(value) &#123; let list = document.querySelectorAll('[s-bind=' + value + ']') dirtyCheck(list) &#125; function dirtyCheck(elems) &#123; // 扫描带指令的节点属性 for (let i = 0, len = elems.length; i &lt; len; i++) &#123; let elem = elems[i]; for (let j = 0, len1 = elem.attributes.length; j &lt; len1; j++) &#123; let attr = elem.attributes[j]; if (attr.nodeName.indexOf('s-event') !== -1) &#123; let dataKey = elem.getAttribute('s-bind') // 进行脏数据检查，如果数据改变，重新执行指令 if (elem.directive[attr.nodeValue] !== data[dataKey]) &#123; directives[attr.nodeValue].call(elem, data[dataKey]) elem.directive[attr.nodeValue] = data[dataKey] &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
