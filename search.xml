<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shell解析命令行过程以及eval命令]]></title>
    <url>%2Fposts%2F29719.html</url>
    <content type="text"><![CDATA[这里写摘要，显示更好看开始于二级标题参考链接shell解析命令行的过程以及eval命令Linux Shell 通配符、元字符、转义符使用实例介绍]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用字符实体]]></title>
    <url>%2Fposts%2F45689.html</url>
    <content type="text"><![CDATA[这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括特色字符实体、常用字符实体、货币类字符实体、数字类字符实体、方向类字符实体以及其他字符实体，以供需要时查阅HTML字符实体一些字符在 HTML 中拥有特殊的含义，比如小于号&lt;用于定义 HTML 标签的开始，在这种情况下如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体来使HTML不将其当做具有特殊含义的字符，例如，要在 HTML 文档中显示小于号，我们需要这样写：&amp;lt; 或者 &amp;#60;。字符实体有三部分：一个和号&amp;一个实体名称，或者 # 和一个实体编号以及一个分号 ;使用实体名称而不是实体编号的好处在于，名称相对来说更容易记忆；而这么做的坏处是，并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。注意：实体对大小写敏感。特色HTML字符实体table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:40%}字符名字编码说明©&amp;copy;&amp;#169;版权标志|&nbsp;&amp;#124;竖线，常用作菜单或导航中的分隔符·&amp;middot;&amp;#183;圆点，有时被用来作为菜单分隔符↑&amp;uarr;&amp;#8593;上箭头，常用作网页“返回页面顶部”标识€&amp;euro;&amp;#8364;欧元标识²&amp;sup2;&amp;#178;上标2，数学中的平方，在数字处理中常用到，例如：1000²½&amp;frac12;&amp;#189;二分之一♥&amp;hearts;&amp;#9829;心型，用来表达你的心常用HTML字符实体字符名字编码说明&nbsp;&amp;nbsp;&amp;#160;空格&amp;&amp;amp;&amp;#38;and符号，与"&amp;quot;&amp;#34;引号©&amp;copy;&amp;#169;版权标志®&amp;reg;&amp;#187;注册标志™&amp;trade;&amp;#153;商标标志“&amp;ldquo;&amp;#147;左双引号”&amp;rdquo;&amp;#148;右双引号‘&amp;lsquo;&amp;#145;做单引号’&amp;rsquo;&amp;#146;右单引号«&amp;laquo;&amp;#171;左三角双引号»&amp;raquo;&amp;#187;右三角双引号‹&amp;lsaquo;&amp;#8249;左三角单引号›&amp;rsaquo;&amp;#8250;右三角单引号§&amp;sect;&amp;#167;章节标志¶&amp;para;&amp;#182;段落标志•&amp;bull;&amp;#149;列表圆点（大）·&amp;middot;&amp;#183;列表圆点（中）…&amp;hellip;&amp;#8230;省略号|&nbsp;&amp;#124;竖线¦&amp;brvbar;&amp;#166;断的竖线–&amp;ndash;&amp;#150;短破折号—&amp;mdash;&amp;#151;长破折号货币类HTML字符实体字符名字编码说明¤&amp;curren;&amp;#164;一般货币符号$&nbsp;&amp;#36;美元符号¢&amp;cent;&amp;#162;分£&amp;pound;&amp;#163;英镑¥&amp;yen;&amp;#165;日元€&amp;euro;&amp;#8364;欧元数字类HTML字符实体字符名字编码说明&lt;&amp;lt;&amp;#60;小于号&gt;&amp;gt;&amp;#62;大于号≤&amp;le;&amp;#8804;小于等于号≥&amp;ge;&amp;#8805;大于等于号×&amp;times;&amp;#215;乘号÷&amp;divide;&amp;#247;除号−&amp;minus;&amp;#8722;减号±&amp;plusmn;&amp;#177;加/减 号≠&amp;ne;&amp;#8800;不等于号¹&amp;sup1;&amp;#185;上标1²&amp;sup2;&amp;#178;上标2³&amp;sup3;&amp;#179;上标3½&amp;frac12;&amp;#189;二分之一¼&amp;frac14;&amp;#188;四分之一¾&amp;frac34;&amp;#190;四分之三‰&amp;permil;&amp;#8240;千分率°&amp;deg;&amp;#176;度√&amp;radic;&amp;#8730;平方根∞&amp;infin;&amp;#8734;无限大方向类HTML字符实体字符名字编码说明←&amp;larr;&amp;#8592;左箭头↑&amp;uarr;&amp;#8593;上箭头→&amp;rarr;&amp;#8594;右箭头↓&amp;darr;&amp;#8595;下箭头↔&amp;harr;&amp;#8596;左右箭头↵&amp;crarr;&amp;#8629;回车箭头⌈&amp;lceil;&amp;#8968;左上限⌉&amp;rceil;&amp;#8969;右上限⌊&amp;lfloor;&amp;#8970;左下限⌋&amp;rfloor;&amp;#8971;右下限其他HTML字符实体字符名字编码说明♠&amp;spades;&amp;#9824;黑桃♣&amp;clubs;&amp;#9827;梅花♥&amp;hearts;&amp;#9829;红桃，心♦&amp;diams;&amp;#9830;方块牌◊&amp;loz;&amp;#9674;菱形†&amp;dagger;&amp;#8224;匕首‡&amp;Dagger;&amp;#8225;双剑号¡&amp;iexcl;&amp;#161;反向感叹号¿&amp;iquest;&amp;#191;反向问号参考链接HTML实体符号网页中常用HTML字符实体]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux通配符和正则表达式及其区别]]></title>
    <url>%2Fposts%2F37480.html</url>
    <content type="text"><![CDATA[这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有*、?、[]、{}这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像awk、sed、grep使用正则表达式、像find、ls、cp使用通配符。通配符问题引出12345678ls test2.txt test3.txt test.txtls test*.txt test2.txt test3.txt test.txtls d*.txt ls: cannot access d*.txt: No such file or directory通配符的作用方式通配符是由shell处理的(不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍), 它只会出现在命令的参数里(它不用在命令名称里， 也不用在操作符上)。当shell在参数中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给命令，然后再由命令进行处理。总之，通配符实际上就是一种shell实现的路径扩展功能。在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。我们回过头分析上面命令：在第2个命令中，test*.txt 实际shell搜索文件,找到了符合条件的文件，命令会变成：ls test2.txt test3.txt test.txt ,实际在执行ls时候传给它的参数是test2.txt test3.txt test.txt。而命令3，d*.txt 由于当前目录下面没有这样的文件或目录，直接将d*.txt作为普通字符传给ls作为参数。这个时候*只是一个普通的 ls参数而已，已经失去了它通配意义。由于找不到文件，所以会出现：无法访问提示！了解了shell通配符，我们现在看下，shell常见通配符有哪些了。常用通配符table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}字符含义实例*匹配 0 或多个字符a*b：a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab?匹配任意一个字符a?b：a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b[list]匹配 list 中的任意单一字符a[xyz]b：a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb[!list]匹配 除list 中的任意单一字符(一定要有一个)a[!0-9]b：a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b[^list]匹配 除list 中的任意单一字符(一定要有一个)a[^0-9]b：a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b[c1-c2]匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]a[0-9]b：0与9之间必须也只能有一个字符 如a0b, a1b… a9b{string1,string2,…}匹配 sring1 或 string2 (或更多)其一字符串a{abc,xyz,123}b：a与b之间只能是abc或xyz或123这三个字符串之一需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，*、?、[]、{}这几种通配符示例[!list] 和[^list]：ls test[^1-2].txttest3.txtls test[!1-2].txttest3.txt注意不会出现test.txt，因为test和.txt之间必须要有一个字符，而test.txt不具备这个条件正则表达式字符基础正则表达式字符字符含义实例^word待搜寻的字串(word)在行首grep -n ‘^#’ regular_express.txt：搜寻行首为 # 开始的那一行，并列出行号word$待搜寻的字串(word)在行尾grep -n ‘!$’ regular_express.txt：将行尾为 ! 的那一行打印出来，并列出行号.代表一定有一个任意字符的字符grep -n ‘e.e’ regular_express.txt：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定仅有一个字符，而空白字符也是字符！\转义字符，将特殊符号的特殊意义去除grep -n \’ regular_express.txt：搜寻含有单引号 ‘ 的那一行*重复零个到无穷多个的前一个字符grep -n ‘ess*’ regular_express.txt：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字串。另外，之前也可以紧接着一个 RE 字符，例如任意字符则为 “.”[list]字符集合，匹配list 中的任意单个字符grep -n ‘g[ld]’ regular_express.txt：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思[n1-n2]字符范围，匹配n1-n2中的任意单个字符grep -n ‘[A-Z]’ regular_express.txt：搜寻含有大写字母的那一行。需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关。[^list]字符集合，匹配 除list 中的任意单一字符(一定要有一个)不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字{n,m}连续 n 到 m 个的前一个字符；若为 {n} 则是连续 n 个的前一个字符；若是 {n,} 则是连续 n 个以上的前一个字符grep -n ‘go{2,3}g’ regular_express.txt：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)延伸正则表达式字符字符含义实例+重复一个或一个以上的前一个字符egrep -n ‘go+d’ regular_express.txt：搜寻 (god) (good) (goood)… 等等的字串，那个 o+ 代表一个以上的 o?零个或一个的前一个字符egrep -n ‘go?d’ regular_express.txt：搜寻 (gd) (god) 这两个字串，那个 o? 代表空的或 1 个 o&#124;用或( or )的方式找出数个字串egrep -n ‘gd&#124;good’ regular_express.txt：搜寻 gd 或 good 这两个字串()找出群组字串egrep -n ‘g(la&#124;oo)d’ regular_express.txt：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来()+多个重复群组的判别echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’grep 默认仅支持基础正则表达式，如果要使用延伸型正则表达式，你可以使用 grep -E ， 不过更建议直接使用 egrep！直接区分指令比较好记忆！其实 egrep 与 grep -E 是类似命令别名的关系啦！通配符和正则表达式关系在文本过滤工具里，都是用正则表达式，比如像awk、sed、grep等，是针对文件的内容的；而通配符多用在文件名上，比如find、ls、cp等等正则表达式中有部分与通配符是相近的含义，如[list]、[n1-n2]、[^list]，但也有一些差异非常大，如* 在通配符中表示匹配0或多个字符(可以独立使用)，但在正则表达式中表示重复零个到无穷多个的前一个字符(不能独立使用)参考链接Linux Shell 通配符、元字符、转义符使用实例介绍鸟哥的linux私房菜linux通配符和正则表达式]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用内容总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-循环结构]]></title>
    <url>%2Fposts%2F16486.html</url>
    <content type="text"><![CDATA[这里写摘要，显示更好看for循环for循环适用于已经知道需要进行多少次的循环，所以for循环也叫固定循环。循环结构12345Usage: for var in con1 con2 con3 ... do 程序段 done为了防止可能的字符分割(变量存在空格)问题，con1 con2 con3都需要被引用(使用双引号括起来)，关于字符分割的示例可以查看shell-if条件测试使用实例使用变量进行循环1234567891011cat test.txt this is a test that is a test there is a test those are testsfield1=$(cut -d ' ' -f 1 test.txt)for i in $&#123;field1&#125;do echo $idone输出：thisthattherethosename=&quot;my name is test&quot;for i in ${name};do echo $i;done输出：mynameistest使用seq命令进行循环seq命令的用法：12345678910Usage: seq [OPTION]... LAST or: seq [OPTION]... FIRST LAST or: seq [OPTION]... FIRST INCREMENT LASTPrint numbers from FIRST to LAST, in steps of INCREMENT.options: -f, --format=FORMAT use printf style floating-point FORMAT -s, --separator=STRING use STRING to separate numbers (default: \n) -w, --equal-width equalize width by padding with leading zeroes默认用法：123456789for i in `seq 1 5`do echo $i donefor i in $(seq 1 5)do echo $i done设置步长：1234for i in `seq 1 2 5`do echo $i done输出：135-w设置输出等长：1234for i in `seq -w 1 2 12`do echo $idone输出：010305070911使用特殊符号{}进行循环对数字循环：1234for i in &#123;1..5&#125; do echo $i done对字母循环：12345678910111213141516for i in &#123;a..d&#125; do echo $i done# 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;for i in a&#123;a..d&#125; do echo $i done# 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;for i in &#123;1..2&#125;&#123;a..d&#125;do echo $idone输出：abcdaaabacad1a1b1c1d2a2b2c2d特殊符号{}中的两个小数点来代表连续出现的意思，更多关于特殊符号{}的用法请参考这篇文章使用特殊符号(())进行循环使用形式：1234for （（ 初始值; 限制值; 执行步阶 ））do 程序段done使用实例：1234567891011121314for ((i=1;i&lt;6;i++))do echo $i donefor ((i=1;i&lt;6;i=i+2))do echo $i donefor ((i=1;i&lt;6;i+=2))do echo $i done特殊符号(())表示执行计算，和linux let命令相似，更多关于特殊符号(())的用法请参考这篇文章使用通配符进行循环通配符主要有星号(*)和问号(?)，用来模糊搜索文件。关于shell中常见的通配符以及通配符和正则表达式的区别请参考这篇文章123456789101112131415161718192021222324252627282930for i in test*.txtdo echo $idone# 输出： test2.txt test3.txt test.txt for file in *# ^ Bash 在检测到通配表达式时，#+ 会进行文件名扩展。do ls -l "$file" # 列出 $PWD（当前工作目录）下的所有文件。 # 回忆一下，通配符 "*" 会匹配所有的文件名， #+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。 # 如果没有匹配到文件，那么它将会扩展为它自身。 # 为了防止出现这种情况，需要设置 nullglob 选项。 #+ (shopt -s nullglob)。donefor file in [jx]*do rm -f $file # 删除当前目录下所有以 "j" 或 "x" 开头的文件。 echo "Removed file \"$file\"".done每个元素多个参数用于循环的每个参数可以继续分解为多个参数，这里使用 set 命令强制解析循环内容中的每一个元素，并将元素的每一个部分分配给位置参数12345678910111213141516171819#!/bin/bash# 将每个行星与其到太阳的距离放在一起。for planet in "Mercury 36" "Venus 67" "Earth 93" "Mars 142" "Jupiter 483"do set -- $planet # 解析变量 "planet" #+ 并将其每个部分赋值给位置参数。 # "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。 # 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。 # 你可以使用数组来保存 # original_params=("$@") echo "$1 $2,000,000 miles from the sum" #-------两个制表符---将后面的一系列 0 连到参数 $2 上。doneexit 0输出：Mercury 36,000,000 miles from the sumVenus 67,000,000 miles from the sumEarth 93,000,000 miles from the sumMars 142,000,000 miles from the sumJupiter 483,000,000 miles from the sum示例来源于这本书集成管道符1234for file in "$( find $directory -type 1 )" # -type 1 = 符号链接do echo "$file"done | sortfor i in test*.txt;do echo $i;done |wc -l3while/until循环while/until循环适用于条件判断，条件成立则进行循环，具体多少次的循环不知道，只要条件成立即可，所以while/until循环也叫不定循环。while和until循环在进行条件判断时执行的是完全相反的操作，while是条件成立则进行循环，而until这是条件成立终止循环，是完全相反的，所以后续的学习主要集中于使用较多的while循环，until循环一样的道理，只是将条件判断改变即可。循环结构1234567891011# 当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止while [ condition ] # 括号内的状态就是判断式do # do 是循环的开始！ 程序段落done # done 是循环的结束# 当 condition 条件成立时，就终止循环， 否则就持续进行循环的程序段(和while循环相反)until [ condition ]do 程序段落donewhile和until循环中当使用条件测试进行循环时和前面在if条件测试分支结构中使用的条件测试是相同的，具体的各种测试形式这里就不在列出，后续可以查看这篇文章使用实例使用条件测试进行循环和 if 一样， 使用条件测试进行循环时 while 会计算一系列命令的退出状态。只要退出状态为零(条件测试执行成功)，它就执行循环内的命令。123456789s=0 # 这是加总的数值变量i=0 # 这是累计的数值，亦即是 1, 2, 3....while [ "$&#123;i&#125;" != "100" ] # 变量使用双引号在进行变量替换的同时防止字符分割do i=$(($i+1)) # 每次 i 都会增加 1 s=$(($s+$i)) # 每次都会加总一次！ # 使用了特殊符号$(())来执行计算doneecho "The result of '1+2+3+...+100' is $s"如果一个 while 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止，这个也和if命令相同:123456789101112# 无限循环，输出this is truewhile false;truedo echo "this is true"done# 不循环while true;falsedo echo "this is true"done循环读取文件使用read结合标准输入&lt;来读取文件：12345678910cat test.txt this is a test that is a test there is a test those are testswhile read linedo echo $linedone &lt; test.txt输出：this is a testthat is a testthere is a testthose are tests也可以按字段读取文件的每行内容：12345678910111213while read field1 field2 do echo $field1 echo $field2done &lt; test.txtwhile read field1 field2 field3 field4 do echo $field1 echo $field2 echo $field3 echo $field4done &lt; test.txt输出：thisis a testthatis a testthereis a testthoseare teststhisisatestthatisatestthereisatestthosearetests这是空行为了重定向文件到循环中，可以将重定向操作符放置到 done 语句之后。循环使用 read 从重定向文件中读取字段；这个 read 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾，这时候它的退出状态为非零数值，因此终止循环。指定字段数小于每行字段数：第一个字段为第一个空格之前的内容，剩下的所有字段为第二个字段(这里只指定了两个字段来读取每一行)指定字段数大于每行字段数：不足的字段使用空格填补集成管道符上面使用使用read结合标准输入&lt;来读取文件的操作也可以使用管道符实现：12345678910cat test.txt|while read linedo echo $linedone# 输出： this is a test that is a test there is a test those are tests因为管道将会在子 shell 中执行循环，当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失，记住这一点很重要(这个还没测试过，先mark一下)循环控制语句break-终止循环break语句：在for、while、until等循环语句中，用于跳出当前所在的循环体(终止循环)，执行循环体之后的语句。终止单层循环1234567891011121314while [ condition ]do commands commands break---------+ | commands | commands | 跳出(终止)循环（通常在循环体中与条件语句一起使用） |done | |commands&lt;-------+commands示例：1234567891011121314151617for f in $(ls)do [ -d "$f" ] &amp;&amp; break # 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂doneecho "We have found a directory $f"# 使用常规的if条件测试分支结构就会比较复杂for f in $(ls)do if [ -d "$f" ] then break fi doneecho "We have found a directory $f"在循环中一旦发现目录，则立即停止循环并退出终止多层循环break 命令可以接受一个参数，普通的 break 命令仅仅跳出其所在的那层循环，而 break N 命令则可以跳出其上 N 层的循环123456789101112131415161718for outerloop in 1 2 3 4 5do echo -n "Group $outerloop: " # ------------------------------------------ for innerloop in 1 2 3 4 5 do echo -n "$innerloop " if [ "$innerloop" -eq 3 ] then break 2 # 尝试一下 break 2 看看会发生什么。 # （它同时中止了内层和外层循环。） fi done # ------------------------------------------ echodone直接使用break的输出结果：Group 1: 1 2 3Group 2: 1 2 3Group 3: 1 2 3Group 4: 1 2 3Group 5: 1 2 3使用了break 2的输出结果：Group 1: 1 2 3可以发现使用break 2不仅跳出了本层循环，还跳出了本层循环的外层循环，也就是跳出了2层循环continue-进行下一次循环continue语句：在for、while、until等循环语句中，用于跳过循环体内余下的语句，重新判断条件以便执行下一次循环。影响单层循环123456789101112131415while [ condition ]&lt;-------+do | | commands | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用） commands | | continue ----------------+ commands commands commandsdonecommandscommands示例：12345678910111213141516for f in $(ls)do [ -d "$f" ] || continue # 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂 chmod 3777 "$f"done# 使用常规的if条件测试分支结构就会比较复杂for f in $(ls)do if [ -d "$f" ] then chmod 3777 "$f" else continue fidone如果是目录，添加权限；如果不是，跳过当前循环，continue 后面代码不再执行，而是直接执行下次循环。影响多层循环与 break 类似，continue 也可以接受一个参数，普通的 continue 命令仅仅影响其所在的那层循环，而 continue N 命令则可以影响其上 N 层的循环12345678910111213141516171819for outer in I II III IV V # 外层循环do echo; echo -n "Group $outer: " # -------------------------------------------------------------------- for inner in 1 2 3 4 5 6 7 8 9 10 # 内层循环 do if [[ "$inner" -eq 7 &amp;&amp; "$outer" = "III" ]] then continue 2 # 影响两层循环，包括“外层循环”。 # 将其替换为普通的 "continue"，那么只会影响内层循环。 fi echo -n "$inner " # 7 8 9 10 将不会出现在 "Group III."中。 done # --------------------------------------------------------------------done直接使用continue的输出结果(只有第三组少了数字7)：Group I: 1 2 3 4 5 6 7 8 9 10Group II: 1 2 3 4 5 6 7 8 9 10Group III: 1 2 3 4 5 6 8 9 10Group IV: 1 2 3 4 5 6 7 8 9 10Group V: 1 2 3 4 5 6 7 8 9 10使用了continue 2的输出结果(第三组7以后的数字全消失了)：Group I: 1 2 3 4 5 6 7 8 9 10Group II: 1 2 3 4 5 6 7 8 9 10Group III: 1 2 3 4 5 6Group IV: 1 2 3 4 5 6 7 8 9 10Group V: 1 2 3 4 5 6 7 8 9 10continue N 结构不易理解并且可能在一些情况下有歧义，因此不建议使用参考链接鸟哥的linux私房菜The Linux Command Line 中文版高级Bash脚本编程指南中文版Linux Shell——流程控制条件测试操作与流程控制语句Shell 流程控制]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-if条件测试]]></title>
    <url>%2Fposts%2F58105.html</url>
    <content type="text"><![CDATA[本文主要学习了shell中的条件测试命令，包括test命令、[ ]、[[ ]]、(( ))，主要介绍了前三个，其中[ ]和[[ ]]可以用在if条件测试分支结构中，两者之间的优缺点在文中也有讲解；也学习了if条件测试分支结构在多种情形下的多种形式以及exit命令设定程序退出状态条件测试本来打算直接学习if判断分支结构，但是在阅读相关资料后发现if判断分支中的条件判断其实就是shell条件测试，所以这里先对shell的条件测试进行学习。shell的条件测试可以使用test命令、[ ]判断式、[[ ]]判断式以及(( ))判断式，其中[ ]和[[ ]]是if判断分支结构中主要使用的。test命令测试test命令是 shell 环境中用于测试条件表达式的工具，当条件成立时，命令执行后的返回值为0，否则为其他数值。test命令结构12345Usage: test EXPRESSION test ! EXPRESSION test EXPRESSION -a EXPRESSION test EXPRESSION -o EXPRESSIONtest EXPRESSION执行结果并不会显示任何信息，如果想要显示信息可以使用$?或者使用&amp;&amp;和||的组合来得到信息使用$?：test -f test1.txt # 不输出结果echo $? # $?返回最后运行的命令的结束代码0 # 正常运行的命令结束代码为0，也就是条件成立test -f test2.txtecho $?1 # 出错或者异常结束代码为非0，也就是条件不成立使用&amp;&amp;和||的组合：test -f test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;Not existtest -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;exist注意&amp;&amp;和||的顺序不能随意，如果上面的顺序调换：test -f test2.txt || echo &quot;Not exist&quot; &amp;&amp; echo &quot;exist&quot;Not existexist上面的判断是按顺序执行的，具体&amp;&amp;和||前后命令的执行规则参考这篇博客文件是否存在测试使用示例：test -e filenametable th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}参数说明-e该“文件名”是否存在（常用）-f该“文件名”是否存在且为文件（file）（常用）-d该“文件名”是否存在且为目录（directory）（常用）-s侦测该文件名是否存在且为“非空白文件”(文件大小不为0) （常用）-b该“文件名”是否存在且为一个 block device 设备-c该“文件名”是否存在且为一个 character device 设备-S该“文件名”是否存在且为一个 Socket 文件-p该“文件名”是否存在且为一个 FIFO （pipe） 文件-L该“文件名”是否存在且为一个链接文件test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;existtest -e test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;existtest -d test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;Not exist权限测试使用示例：test -r filename参数说明-r侦测该文件名是否存在且具有“可读”的权限-w侦测该文件名是否存在且具有“可写”的权限-x侦测该文件名是否存在且具有“可执行”的权限-u侦测该文件名是否存在且具有“SUID”的属性-g侦测该文件名是否存在且具有“SGID”的属性-k侦测该文件名是否存在且具有“Sticky bit”的属性-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txttest -r test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;existtest -w test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;existtest -x test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;Not exist文件之间的测试使用示例：test file1 -nt file2参数说明-nt（newer than）判断 file1 是否比 file2 新-ot（older than）判断 file1 是否比 file2 旧-ef判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上（通过硬链接两个文件名指向相同的文件）-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt-rw-rw-r– 1 user user 0 Mar 14 21:20 test2.txttest test1.txt -nt test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;Not existtest test1.txt -ot test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;exist整数之间的测试使用示例：test n1 -eq n2参数说明-eq两数值相等 （equal）-ne两数值不等 （not equal）-gtn1 大于 n2 （greater than）-ltn1 小于 n2 （less than）-gen1 大于等于 n2 （greater than or equal）-len1 小于等于 n2 （less than or equal）test 2 -eq 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;existtest 2 -ne 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;Not exist字符串的测试使用示例：test str1 == str2参数说明test -z string判定字串是否为 0 ，若 string 为空字串(空格不为空)，则为 truetest -n string判定字串是否非为 0 ，若 string 为空字串，则为 false。 -n 亦可省略test str1 == str2判定 str1 是否等于 str2 ，若相等，则回传 truetest str1 != str2判定 str1 是否不等于 str2 ，若相等，则回传 false注意：==前后需要空格隔开，不用空格隔开可能会出问题逻辑测试使用示例：test -r file -a -x file参数说明-a（and）两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true。-o（or）两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。!反向状态，如 test ! -x file ，当 file 不具有 x 时，回传 truetest命令最需要注意的是：单纯的test命令不会返回任何信息，所以如果想要显示信息可以使用$?或者使用&amp;&amp;和||的组合来得到信息[]判断式条件测试会使用一个特殊的命令 [，等同于 test 命令，它是一个内建命令，写法更加简洁高效。该命令将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）Bash 在 2.02 版本中引入了扩展测试命令 [[ ]]，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， [[ 是一个关键字 而非一个命令，Bash 将 [[ $a -lt $b ]] 视为一整条语句，执行并返回退出状态[]有几种不同的功能，如果想要用来作为条件测试必须要注意中括号的两端以及判断符前后需要有空白字符来分隔，如[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]中括号和test命令的各种测试是相同的，[ ]判断式和test命令可以相互转换，比如[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]可以转换为test “$HOME” == “$MAIL”，所以上面提到的各种测试都可以在中括号中使用在中括号 [ ] 内的每个元件都需要有空白键来分隔在中括号内的变量，最好都以双引号括号起来在中括号内的常数，最好都以单或双引号括号起来[ ]以及test命令中所有的表达式和操作符都被 shell 看作是命令参数，对于 bash 有特殊含义的字符，比如说 (、 )、&gt;、&lt;必须引起来或者是转义在复合测试中，仅仅引用字符串可能还不够，比如表达式[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ] 在某些 Bash 版本下，如果 $string 为空可能会出错。更加安全的方式是，对于可能为空的字符串，添加一个额外的字符，例如 [ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]（其中的 x 互相抵消）[]判断式需要注意的问题-字符分割：test=”my name”[ ${test} == “my” ]bash: [: too many arguments上面的出错显示判断式中存在太多参数，但是明明就只有test一个参数，为什么会出现这个问题呢？因为 ${test} 如果没有使用双引号括起来，那么上面的判定式会变成：[ my name == “my” ]如果写成这个样子就会发现问题，因为一个判断式仅能有两个数据的比对，上面 my 与 name 还有 “my” 就有三个数据！所以会出错，而我们需要的是：[ “my name” == “my” ]所以这就说明了(如果字符串中带有空格，以防万一都带上吧)需要使用双引号括起来，不用单引号的原因是单引号会防止任何变量替换[[]]判断式在 Bash(限制条件) 里，[[ ]] 是比 [ ] 更加通用的写法，使用 [[ ]] 代替[ ]可以避免很多逻辑错误。比如可以在 [[ ]] 中使用 &amp;&amp;、||、&lt; 和 &gt; 操作符，而在 [ ] 中使用则会报错下面列出[[ ]] 比 [ ]更好用的几点：使用正则匹配增加了一个重要的新的字符串表达式来使用正则匹配string1 =~ regex不需要使用双引号[[ ]]判断式不需要对其中的变量和常数使用双引号括起来：[[ ${test} == &quot;my&quot; ]] &amp;&amp; echo &quot;right&quot; || echo &quot;wrong&quot;wrong==操作符支持模式匹配:FILE=foo.barif [[ $FILE == foo.* ]]; then> echo “$FILE matches pattern ‘foo.*‘“> fifoo.bar matches pattern ‘foo.*’使[[ ]]有助于计算文件和路径名，如果foo.*外加了双引号就没有正则匹配的意思，单纯的字符相等的意思多重比较[[ condition1 &amp;&amp; condition2 ]] [[ condition1 || condition2 ]]对不同进制的数直接进行比较12345678910111213141516171819202122232425decimal=15octal=017 # = 15 (十进制)hex=0x0f # = 15 (十进制)if [ "$decimal" -eq "$octal" ]then echo "$decimal equals $octal"else echo "$decimal is not equal to $octal" # 15 不等于 017fi # 在单括号 [ ] 之间不会进行进制转换。if [[ "$decimal" -eq "$octal" ]]then echo "$decimal equals $octal" # 15 等于 017else echo "$decimal is not equal to $octal"fi # 在双括号 [[ ]] 之间会进行进制转换。if [[ "$decimal" -eq "$hex" ]]then echo "$decimal equals $hex" # 15 等于 0x0felse echo "$decimal is not equal to $hex"fi # 十六进制也可以进行转换。(())数值判断使用小于和大于符号，以及==用来测试是否相等，专为整数设计不仔细讲解，因为这些也可以使用上面提到的[ ]和[[ ]]进行较好的替代，后续想学习可以参考：文章一、文章二。if条件测试分支结构在学习test命令以及[ ]判断式过程中我们发现条件测试默认是不会返回任何信息的，如果想要进行操作或者返回信息就要使用&amp;&amp;或者||，这些其实和这里的if条件测试分支结构的作用的相同的，只是if条件测试分支结构可以支持的命令更加多和复杂，有利于大程序的编写。if条件测试分支结构工作原理：通过判断条件测试的退出状态，如果执行成功(命令退出状态为0)则执行then中的命令，否则(命令退出状态为非0)终止判断语句或者执行else或者执行下一层判断等。单层、简单条件判断式1234567Usage: if [ 条件判断式 ] then 当条件判断式成立时，可以进行的指令工作内容； fi 这里的条件判断式就是前面条件测试中使用的[]判断式多个表达式、多重判别前面在test命令中讲过关于使用多个表达式、多重判断的情况，在多个表达式之间使用-a表示and、-o表示or，示例如下：[ &quot;${yn}&quot; == &quot;Y&quot; -o &quot;${yn}&quot; == &quot;y&quot; ]如果想要使用多个括号将不同的表达式隔开可以使用&amp;&amp;和||:[ &quot;${yn}&quot; == &quot;Y&quot; ] || [ &quot;${yn}&quot; == &quot;y&quot; ]上面的多重判别实际是写成了一个判断式的形式，而如果 if 之后跟随一系列命令(使用;隔开)，则将计算列表中的最后一个命令：if false; true; then echo &quot;It&#39;s true.&quot;; fi 因为true在后，所以得到退出状态为0，输出结果It’s true.if true; false; then echo &quot;It&#39;s true.&quot;; fi 因为false在后，所以得到退出状态为非0，不输出结果双层判断式12345678Usage: # 一个条件判断，分成功进行与失败进行 （else） if [ 条件判断式 ] then 当条件判断式成立时，可以进行的指令工作内容； else 当条件判断式不成立时，可以进行的指令工作内容； fi多层、复杂判断式1234567891011Usage: # 多个条件判断 （if ... elif ... elif ... else） 分多种不同情况执行 if [ 条件判断式一 ] then 当条件判断式一成立时，可以进行的指令工作内容； elif [ 条件判断式二 ] then 当条件判断式二成立时，可以进行的指令工作内容； else 当条件判断式一与二均不成立时，可以进行的指令工作内容； fiif、elif后面需要使用then，而else后面就不用使用then，因为elif 也是个判断式，因此出现 elif 后面都要接 then 来处理！但是 else 已经是最后的没有成立的结果了， 所以 else 后面并没有 thenexit程序退出状态12345678910#!/bin/bashif [ $# -lt 1 ] then echo "Usage: $0 &lt;name&gt;" exit 1fiecho "Hello $1"exit 0在运行此脚本时，如果没有输入参数，则提示正确的使用方法，非正常退出(exit 1)；否则，打印输入的参数，程序正常退出(exit 0)。参考链接鸟哥的linux私房菜The Linux Command Line 中文版高级Bash脚本编程指南中文版Linux Shell——流程控制条件测试操作与流程控制语句Shell 流程控制]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pv-命令执行的进度信息]]></title>
    <url>%2Fposts%2F6225.html</url>
    <content type="text"><![CDATA[这个需要安装pv，需要root权限，后面在有root权限的机器上执行这个操作开始于二级标题参考链接官方文档很好的英文示例讲解博客英文示例博客中文讲解博客中文讲解博客中文讲解博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML块级标签和行内标签]]></title>
    <url>%2Fposts%2F8829.html</url>
    <content type="text"><![CDATA[这是一篇转载的文章，主要记录了HTML的块级标签和行内标签各自包括的内容块级标签标签描述&lt;address&gt;定义地址&lt;article&gt;定义文章&lt;aside&gt;定义页面内容之外的内容&lt;audio&gt;定义声音内容&lt;blockquote&gt;定义长的引用&lt;canvas&gt;定义图形&lt;caption&gt;定义表格标题&lt;dd&gt;定义定义列表中项目的描述&lt;div&gt;定义文档中的节&lt;dl&gt;定义定义列表&lt;dt&gt;定义定义列表中的项目&lt;details&gt;定义元素的细节&lt;fieldset&gt;定义围绕表单中元素的边框&lt;figcaption&gt;定义 figure 元素的标题&lt;figure&gt;定义媒介内容的分组，以及它们的标题&lt;footer&gt;定义 section 或 page 的页脚&lt;form&gt;定义供用户输入的 HTML 表单&lt;h1&gt; to &lt;h6&gt;定义 HTML 标题&lt;header&gt;定义 section 或 page 的页眉&lt;hr&gt;定义水平线&lt;legend&gt;定义 fieldset 元素的标题&lt;li&gt;定义列表的项目&lt;menu&gt;定义命令的列表或菜单&lt;meter&gt;定义预定义范围内的度量&lt;nav&gt;定义导航链接&lt;noframes&gt;定义针对不支持框架的用户的替代内容&lt;noscript&gt;定义针对不支持客户端脚本的用户的替代内容&lt;ol&gt;定义有序列表&lt;output&gt;定义输出的一些类型&lt;p&gt;定义段落&lt;pre&gt;定义预格式文本&lt;section&gt;定义 section&lt;table&gt;定义表格&lt;tbody&gt;定义表格中的主体内容&lt;td&gt;定义表格中的单元&lt;tfoot&gt;定义表格中的表注内容（脚注）&lt;th&gt;定义表格中的表头单元格&lt;thead&gt;定义表格中的表头内容&lt;time&gt;定义日期/时间&lt;tr&gt;定义表格中的行&lt;ul&gt;定义无序列表行内标签标签描述&lt;a&gt;定义锚&lt;abbr&gt;定义缩写&lt;acronym&gt;定义只取首字母的缩写&lt;b&gt;定义粗体字&lt;bdo&gt;定义文字方向&lt;big&gt;定义大号文本&lt;br&gt;定义简单的折行&lt;button&gt;定义按钮 (push button)&lt;cite&gt;定义引用(citation)&lt;code&gt;定义计算机代码文本&lt;command&gt;定义命令按钮&lt;dfn&gt;定义定义项目&lt;del&gt;定义被删除文本&lt;em&gt;定义强调文本&lt;embed&gt;定义外部交互内容或插件&lt;i&gt;定义斜体字&lt;img&gt;定义图像&lt;input&gt;定义输入控件&lt;kbd&gt;定义键盘文本&lt;label&gt;定义 input 元素的标注&lt;map&gt;定义图像映射&lt;mark&gt;定义有记号的文本&lt;objec&gt;定义内嵌对象&lt;progress&gt;定义任何类型的任务的进度&lt;q&gt;定义短的引用&lt;samp&gt;定义计算机代码样本&lt;select&gt;定义选择列表（下拉列表）&lt;small&gt;定义小号文本&lt;span&gt;定义文档中的节&lt;strong&gt;定义强调文本&lt;sub&gt;定义下标文本&lt;sup&gt;定义上标文本&lt;textarea&gt;定义多行的文本输入控件&lt;time&gt;定义日期/时间&lt;tt&gt;定义打字机文本&lt;var&gt;定义文本的变量部分&lt;video&gt;定义视频&lt;wbr&gt;定义可能的换行符参考链接关于两者之间的转换HTML中块级元素和行内元素的总结和区分，本文内容摘自此文章]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载其他博主博客]]></title>
    <url>%2Fposts%2F52283.html</url>
    <content type="text"><![CDATA[这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载CSDN博客、博客园博客、简书以及其他自建博客等转载CSDN博客博客页面右键，点击【检查】 点击检查后，页面右侧出现html代码，如下图： 找到article_content内容复制article_content内容在选中html的article_content代码处右键，点击【Copy】,再点击【Copy outerHTML】即可，至此，博客内容的html代码复制完成 新建markdown博客如果是转载到CSDN博客需要注意：使用markdown编辑器，CSDN博客默认的是html编辑器，在博客设置中修改成markdown编辑器，在html编辑器中是无法将html代码转换成相应博客内容如果是转载到自己搭建的博客，比如我的这个博客，需要注意：按照上述方法会得到很多的空格，这是因为直接使用html来编写markdown，只要存在换行(如标签换行)都会在最终生成的页面中得到一个空格，为了解决这个问题可以在整个article_content标签外加上escape标签即可，这个和插入html表格的处理是一样的HTML 区块标签间的 Markdown 格式语法将不会被处理，但 Markdown 语法在 HTML 行内标签间是有效的，具体的行内标签和区块标签包含的内容见这篇博客在手动更改html内容时需要注意：每个标题的id是不可以相同的，不然生成的目录会出问题，点击不能到达相应的标题(目录是根据id生成的)最后特别要注意的是，我们发表转载文章的时候一定要标注转载，尊重原创！！转载博客园博客将上述转载CSDN博客中article_content替换成data-note-content即可转载简书博客将上述转载CSDN博客中article_content替换成cnblogs_post_body即可转载其他自建博客将上述转载CSDN博客中article_content替换成post-body即可其他博客依据上述规律找到对应的文章主体内容，然后按照转载CSDN博客的方法进行处理即可参考链接CSDN怎么转载别人的博客]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-数组]]></title>
    <url>%2Fposts%2F46714.html</url>
    <content type="text"><![CDATA[这里写摘要，显示更好看开始于二级标题参考链接shell编程中使用数组进行操作Shell 数组The Linux Command Line 中文版shell-guide]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diff-比较文件差异]]></title>
    <url>%2Fposts%2F56778.html</url>
    <content type="text"><![CDATA[这篇文章主要学习了使用diff命令对文件和目录进行比较，对文件比较时采用的是逐行进行比较；包括的参数有-r、-q、-i、-s、-b、-y、-W、-c、-C、-u和-U。diff简介diff命令能比较(单个)文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，并以逐行的方式，比较文本文件的异同；如果指定比较的是目录，diff 命令会比较两个目录下名字相同但内容不同的文本文件，列出公共子目录和只在一个目录出现的文件和目录。这个和前面讲到的comm命令和cmp命令的不同之处在于：diff和comm命令都是以逐行的方式进行比较，而cmp是Compare two files byte by byte；同时diff命令可以比较单个文件，而comm和cmp都是针对的两个文件的比较，其中comm还需要文件是排过序的；diff命令还能用来对目录进行排序；感觉diff在比较两个文件或目录时是将两个文件当成了同一个文件修改前后的不同版本，通过diff可以知道新文件是在旧文件上进行了哪些操作得到的，得到的结果也更复杂。总结一下三个命令的适用情形：comm适合简单的比较，需要排序，逐行比较，用于比较的文件不是同一个文件的不同版本(新旧文件)，得到的结果简单清晰(文件求交、并、补等)，便于提取分析cmp可以应用于对两个文件逐字节的比较，可以跳过一定的字节(个人感觉这个实用性不是很强，不同系统编码方式字节也有所不同)diff适合逐行比较文件修改前后的区别(类似版本控制，新文件是旧文件经过什么操作得到的)，也可以对目录进行比较，但是输出结果较为复杂，还可以输出上下文关系的信息diff命令用法diff命令格式12Usage: diff [OPTION]... FILESCompare files line by linediff options说明由于diff命令的参数较多，这里就不一一列举，详细请查看帮助文档，比较常用的请看用法实例。diff用法实例测试文件cat test1.txtHi,Hello,How are you?I am fine,Thank you.cat test2.txtHello,Hi,How are you?I am fine.使用默认方式比较文件不同比较两个文件diff test1.txt test2.txt1d0&lt; Hi,2a2> Hi,4,5c4&lt; I am fine,&lt; Thank you.-–> I am fine.结果解读：可以将test1.txt当做旧文件，test2.txt当做新文件，通过比较看旧文件经过什么样的改变可以生成新文件1d0这一行意味着旧文件的第一行应该被删除(d)以使两个文件的第一行同步，旧文件中需要被删除的行以&lt;标记2a2行意味着新文件中的第二行应该加到旧文件的第二行后，要添加的行显示在输出的下一行用&gt;标记4,5c4这一行意味着在旧文件中的4到5行现在已被改变并且需要用新文件中的第4行代替，代替和删除的行分别用&gt;和&lt;表示，---用于隔开先后进行的不同操作，如先删除旧文件中的4到5行，然后再用新文件中的第4行代替，这两步之间使用---分割diff命令的第一个参数被视为旧文件而第二个参数被视为新文件，通过比较看旧文件经过什么样的改变可以生成新文件像1d0、2a2、4,5c4这种表达式可以用语法解码为 [旧文件的行号或者行的范围][行为][新文件的行号或者行的范围]，这里的行为可以是追加(a，代表addition)、删除(d，代表deletion)或者改变替换(c，代表change)&lt;代表删除的行，而&gt;代表添加的行，---用于改变替换(c，代表change)中分割先后的操作比较两个目录ls new_dir/comm_dir new_new_dir test1.txt test2.txt test3.txtls new_dir/new_new_dir/ and ls new_dir/comm_dir/test1.txt test2.txt test3.txtls orig_dir/comm_dir orig_orig_dir test1.txt test2.txt test4.txtls orig_dir/orig_orig_dir/ and ls orig_dir/comm_dir/test1.txt test2.txt test4.txtdiff orig_dir/ new_dir/Common subdirectories: new_dir/comm_dir and orig_dir/comm_dir # 两个目录共有的子目录，不会比较子目录中的文件信息Only in new_dir/: new_new_dir # 只出现在new_dir中的目录，不会比较子目录中的文件信息Only in orig_dir/: orig_orig_dir # 只出现在orig_dir中的目录，不会比较子目录中的文件信息diff orig_dir/test1.txt new_dir/test1.txt # new_dir和orig_dir共有的同名文件内容的差异0a1 # 具体的差异信息> asdfaf # 具体的差异信息Only in new_dir/: test3.txt # 只出现在new_dir中的文件Only in orig_dir/: test4.txt # 只出现在orig_dir中的文件比较两个目录可以找到每个目录共有的、独有的文件和目录信息；对于共有的子目录，不会继续比较子目录中的信息；对于共有的文件，会得出文件的差异信息-r-比较子目录中的文件上述对目录进行比较时默认不会比较子目录中的文件信息，使用-r参数可以对这些文件进行比较：diff -r orig_dir/ new_dir/diff -r orig_dir/comm_dir/test1.txt new_dir/comm_dir/test1.txt0a1> asdfafOnly in new_dir/comm_dir: test3.txtOnly in orig_dir/comm_dir: test4.txtOnly in new_dir/: new_new_dirOnly in orig_dir/: orig_orig_dirdiff -r orig_dir/test1.txt new_dir/test1.txt0a1> asdfafOnly in new_dir/: test3.txtOnly in orig_dir/: test4.txt-q-只显示有无差异默认情况下如果文件存在差异会显示差异信息，使用-q参数只会显示有无差异不会显示具体的差异信息:diff -q test1.txt test2.txtFiles test1.txt and test2.txt differ-i-忽略文件中文本大小写diff file1.txt file2.txt1c1&lt; hi-–> HI默认情况下是会区分文件中文本信息大小写的diff -i file1.txt file2.txt使用了-i参数没有输出内容，因为忽略大小写之后文件中文本信息是相同的-s-在文件内容相同条件下报告信息上面使用了-i参数得到了文件内容是相同的，这时默认就不会输出信息，如果想要在文件内容相同时报告文件内容是相同的，需要使用-s参数diff -is file1.txt file2.txtFiles file1.txt and file2.txt are identical-b-忽略文本中的空格cat file1Hi, how are you?cat file2Hi, how are you?diff file1 file21c1&lt; Hi, how are you?-–> Hi, how are you?上述文件中的区别仅仅是file2多了一个空格，但是使用diff命令后仍然会输出不同，而常规情形下，这应该被认为是相同的，这时就可以使用-b参数diff -bs file1 file2Files file1 and file2 are identical-y-以并列的方式显示文件的异同之处diff -y test1.txt test2.txtHi, &lt;Hello, Hello,&gt; Hi,How are you? How are you?I am fine, | I am fine.Thank you. &lt;|：表示前后2个文件内容存在差异&gt;：表示第一个文件删除的行&lt;：表示第二个文件增加的行-W-在使用-y参数时，指定栏宽如果指定的栏宽太窄，会显示每行的部分信息：diff -y -W 10 test1.txt test2.txtHi &lt;He He> HiHo HoI | ITh &lt;-c-上下文格式输出显示不同行的信息时一同显示上下文信息，默认是存在不同的上下3行：diff -c test1.txt test2.txt*** test1.txt 2019-03-14 15:26:48.960323475 +0800— test2.txt 2019-03-14 15:27:07.411322620 +0800* 1,5 **- Hi,Hello,How are you?! I am fine,! Thank you.— 1,4 —-Hello,+ Hi,How are you?! I am fine.***表示变动前的文件，---表示变动后的文件*** 1,5 ****表示变动前文件的1到5行，--- 1,4 ----表示变动后文件的1到4行文件内容的每一行最前面，还有一个标记位如果为空，表示该行无变化如果是感叹号（!），表示该行有改动如果是减号（-），表示该行被删除如果是加号（+），表示该行为新增-C NUM-指定具体是上下文行数这个功能和上面的-c是相同的，只是-c只能是默认的上下3行，而-C num可以指定具体的上下文行数diff -C 3 test1.txt test2.txt 等同于 diff -c test1.txt test2.txt*** test1.txt 2019-03-14 15:26:48.960323475 +0800— test2.txt 2019-03-14 15:27:07.411322620 +0800* 1,5 **- Hi,Hello,How are you?! I am fine,! Thank you.— 1,4 —-Hello,+ Hi,How are you?! I am fine.-u-合并格式输出如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间，这个时候使用合并格式输出将f1和f2的上下文(默认3行)合并在一起显示：diff -u test1.txt test2.txt— test1.txt 2019-03-14 15:26:48.960323475 +0800+++ test2.txt 2019-03-14 15:27:07.411322620 +0800@@ -1,5 +1,4 @@-Hi,Hello,+Hi,How are you?-I am fine,-Thank you.+I am fine.---表示变动前的文件，+++表示变动后的文件变动的位置用两个@作为起首和结束，-1,5表示第一个文件的1到5行，+1,4表示第二个文件的1到4行每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行-U NUM-指定合并格式上下文的行数这个功能和上面的-u是相同的，只是-u只能是默认的上下3行，而-U num可以指定具体的上下文行数结合patch进行内容更新这个暂时应该用不到，所以就不学习了，后期如果使用的话再进行学习补充，后面列出的参考链接有对应的示例。注意事项：diff的几种输出模式：并列输出(-y)、上下文格式输出(-c)、合并格式输出(-u)之间的不兼容的，只能使用其中一种，参数不能混用参考链接实例较多举例说明Linux diff 命令参数讲解清晰的讲解文件比较 cmp，diff，patch]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmp-比较文件差异]]></title>
    <url>%2Fposts%2F62860.html</url>
    <content type="text"><![CDATA[这篇文章主要学习了cmp对两个文件进行比较，比较时是逐字节进行的；包括的参数：-b、-i、-i、-l、-n、-s以及显示运行进度。cmp简介cmp命令用于比较两个文件是否有差异；当相互比较的两个文件完全一样时，则该命令不会有输出结果；若发现有所差异，默认会标示出第一个不同之处的字符和列数编号若不指定任何文件名称或是所给予的文件名为-，则cmp指令会从标准输入读取数据这个和前面讲到的comm命令的不同之处在于：comm命令对已排序的文件进行比较并将结果分为3列，便于提取文件比较的结果，如得到两个文件的差集、交集、并集和对称差集等，而cmp命令侧重于比较两个文件差异，大多用于比较同一个文件修改之后和修改之前的差异，并且cmp比较文件不需要进行排序；cmp命令比较文件是byte by byte，而comm命令比较文件是line by line。cmp命令用法cmp命令格式12345Usage: cmp [OPTION] FILE1 [FILE2 [SKIP1 [SKIP2]]]# The optional SKIP1 and SKIP2 specify the number of bytes to skip# at the beginning of each file (zero by default).Compare two files byte by bytecmp options说明table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}参数完整参数说明-b–print-bytes除了标明差异处所在之外，一并显示该字符所对应字符和字节值-i SKIP–ignore-initial=SKIP跳过一定的字节数(不包括SKIP)-i SKIP1:SKIP2–ignore-initial=SKIP1:SKIP2从两个文件中跳过不同的字节数，SKIP1是FILE1跳过的字节数，SKIP为FILE2跳过的字节数-l–verbose显示所有不同字节的字节位置（和值）-n–bytes=LIMIT限制要比较的字节数(包括LIMIT)-s–quiet, –silent抑制正常生成的输出，只返回文件是否相同的退出码(可以通过$?得到)cmp -i选项可选单位简写全称说明kBkilobytes1000Kkibibytes1024MBmegabytes1,000,000Mmebibytes1,048,576GBgigabytes1,000,000,000Ggibibytes1,073,741,824cmp用法实例测试文件cat test1.txtAbsncn 50Asldssja 60Jslkadjls 85cat test2.txtAbsncn 50AsldssjE 62Jslkadjls 85使用默认方式比较文件不同默认会告诉在第几行的第几个字节出现不同：cmp test1.txt test2.txttest1.txt test2.txt differ: byte 18, line 2注意这里的byte 18来源：系统默认编码方式为UTF-8(查看方式见这篇文章)，1个英文字符 = 1个字节；换行符占一个字节；空格占一个字节；第二行的结果存在差异的话，字符会从第一行的第一个开始算起，叠加的，不是单独每一行算-b-显示不同的字节及字节值cmp -b test1.txt test2.txttest1.txt test2.txt differ: byte 18, line 2 is 141 a 105 E只会显示第一个，不会显示所有的，具体是字母a和E不同，字节值分别为141和105(这个没算。。。)-i-跳过指定的字节cmp -b -i 18 test1.txt test2.txttest1.txt test2.txt differ: byte 3, line 1 is 60 0 62 2跳过前18个之后开始的第3个字节，0和2不同注意这个是不包括指定跳过的那个字节位置，比如这里的字节数为18的位置-i-从两个文件跳过不同数量的字节cmp -b -i 18:18 test1.txt test2.txttest1.txt test2.txt differ: byte 3, line 1 is 60 0 62 218:18：第一个文件跳过的字节数为18，第二个文件跳过的字节数也是18-l-显示所有不同字节的字节位置（和值）cmp -l test1.txt test2.txt18 141 10521 60 62输出结果：第一列（如上所示）表示不同字节的位置（字节数）第二列表示第一个文件中不同字节的字节值第三列表示第二个文件中不同字节的字节值前面的-b等参数只会显示第一个不同的字节位置和值，这里会显示所有的字节数字和值-n-限制要比较的字节数最多只比较的字符数：cmp -n 17 test1.txt test2.txtcmp -n 18 test1.txt test2.txttest1.txt test2.txt differ: byte 18, line 2如果和-i参数联合使用：cmp -b -l -i 3 -n 18 test1.txt test2.txt15 141 a 105 E18 60 0 62 2注意这里相比于没有设置跳过字节会多出一行差异的结果，表明-n是相对字节位置，而不是绝对的字节位置和不使用-i的对比：cmp -b -l -n 18 test1.txt test2.txt18 141 a 105 E注意这里是包括指定跳过的那个字节位置，比如这里的字节数为18的位置，因为包括了所以才会输出在byte18位置存在区别-n指定的是相对字节位置，而不是绝对字节位置，比如上面跳过前3个字符之后出现差异的就成了第15个字节位置的，同时因为-n设置为18向后推移3个字节，就会出现了第二个不同的位置，而如果不设置-i参数就不会得到第二个不同的位置-s-抑制正常生成的输出，只返回反映文件是否相同的退出码cmp -s -b test1.txt test2.txt没有输出结果，也就是原本需要输出的在哪一行存在差异都不会输出来了，然后查看命令的退出码：echo $?得到的结果是1，表明文件是不相同的，这样可得到文件是否相同的信息，但是并不关注具体的差异在什么地方而如果不加-s就会正常输出：cmp -b test1.txt test2.txttest1.txt test2.txt differ: byte 18, line 2 is 141 a 105 E同时不加-s查看查看命令的退出码：echo $?得到的结果和加了-s一样都返回的是1在脚本中使用cmp命令时，此选项可以会派上用场。 例如，根据文件是否相同(通过访问命令的退出代码可以知道)来进行下一步的操作，这个时候我们可能并不关心具体文件的差异在什么地方，而是关心文件是不是有差异这个整体的结果显示运行进度这个需要结合pv命令，安装和使用pv命令之后再进行学习，参考参考链接的前两个参考链接Linux cmp command tutorial for beginners （7 examples）Linux初学者的cmp命令教程（7个例子）Linux cmp command-关于-i参数单位的问题很好cmp - Unix, Linux Command]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[journey]]></title>
    <url>%2Fposts%2F34270.html</url>
    <content type="text"><![CDATA[这里写摘要，显示更好看景点磁器口吃的：陈麻花-推荐陈昌银或者夏麻花、张老汉手工酸辣粉（磁器口必吃之一）有很多文艺的小咖啡馆或者书店磁器口的主街人满为患，商业化严重，更建议去侧街，也是咖啡馆一条街，客量少，店面装饰都很有文艺味儿，是来磁器口的正确打开方式。（在此安利一家咖啡馆——懒鱼时光馆，上图即是该咖啡馆，是一家有故事的咖啡馆）洪崖洞晚上去，白天不好看，晚上有灯光主要是建筑构造和风貌南山一棵树观景台可以将重庆所有的美景尽收眼底！建议夜晚去，重庆的夜景很美很美很美！门票：门票30，学生证15吃的：泉水鸡、枇杷园（火锅）十八梯电影《从你的全世界路过》十八梯是重庆渝中半岛的一条街，从重庆城的上半城（山顶）通到下半城（山脚），全部由石阶铺成，把山顶的繁华商业区和山下江边的老城区连起来。拆迁了朝天门两江游重庆很出名的两江交汇：长江与嘉陵江夜景长江索道到达对岸后不用着急回来可以在那边拍拍照，然后再返回来皇冠大扶梯亚洲第二长的一级提升坡地大扶梯这个扶梯不用刻意去，如果方便可以去坐坐，其实就是一个长长的扶梯，但是因为有坡度而且特别长所以很炫酷！中山四路历史遗迹很多，除了中国民主党派博物馆的特园外，此地还有桂园、周公馆、戴公馆、张骧公馆、国民政府总统府旧址等解放碑解放碑是重庆的标志，特别是圣诞节和跨年的时候，大家会不约而同地去解放碑一同度过！场面壮观到每年都会提前进行封路。解放碑那有一条好吃街，可以去吃吃～李串串两江影视城民国街再现了百年老重庆风土人情影视城里重现了当时的解放碑、磁器口、朝天门、十八梯，特别有意思当地也可以租民国服装小吃重庆小面重庆火锅大龙火锅。以超辣闻名，吃这家店的人超级多，中午都得排很久的队串串串串推荐小郡肝、李记、怒火八零等等酸辣粉/凉粉/冰粉凉虾/凉糕莱得快的杂酱酸辣粉阿坤的杂酱酸辣粉、苕皮、海带，有点辣。但是阿坤里面有甜品所以可以也点一份甜品，防止被辣着，推荐它们的双皮奶。好又来酸辣粉（口碑店家）、手工酸辣粉（视觉和味觉两不误）麻辣鱼/酸菜鱼/尖椒兔大渡口，店名是：霸王兔夜啤酒/万州烤鱼/烧烤奶制品重庆本土的天友，以及后发的奶牛梦工厂参考路线两天]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[comm-文件比较，文本文件的交集、差集与求差]]></title>
    <url>%2Fposts%2F39582.html</url>
    <content type="text"><![CDATA[这篇文章学习了使用comm命令对两个文件内容进行比较，注意文件需要排序，相比于其他比较文件的命令，comm可以将文件内容不同的分列显示，便于提取(文件求交、并、差、对称差等)所需要的内容，另外两个文件比较命令包括cmp、diff。comm用法comm命令会一行行(line by line)地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成3行显示：第1行仅是在第1个文件中出现过的列第2行是仅在第2个文件中出现过的列第3行则是在第1与第2个文件里都出现过的列。若给予的文件名称为-，则comm命令会从标准输入设备读取数据comm命令格式12Usage: comm [OPTION] FILE1 FILE2comm options说明table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}参数说明-1不显示第1列（即不显示只在file1中找到的行）-2不显示第2列（即不显示只在file2中找到的行）-3不显示第3列（即不显示在两个文件中都找到的行）–check-order判断所有输入文件是不是已经排好序–nocheck-order不判断所有输入文件是不是已经排好序–output-delimiter=STR指定输出结果的分隔符comm用法实例测试文件cat a.txtaaabbbccc111dddeee222cat b.txtbbbcccaaahhhtttjjj注意上面两个文件都没有排序，看看comm对没排序文件的处理使用默认方式对文本进行比较comm a.txt b.txtaaabbbccccomm: file 1 is not in sorted ordercomm: file 2 is not in sorted order111aaadddeee222hhhtttjjj从上面可以看出，没排序comm命令会爆出问题，但是仍然会运行得到结果；发现因为没有排序的原因，第二个文件的aaa在第一个文件中也存在但是却被当成了file2独有的。总的来说就是如果没排序，comm命令会爆出问题但不会停止运行，并且结果会存在问题，正常结果如下：sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt)111222aaabbbcccdddeeehhhjjjttt可以看出默认情况会输出三列，第一列是第一个文件独有的内容，第二列是第二个文件独有的内容，第三列是第三个文件独有的内容，各列是以制表符\t作为定界符，可以通过对定界符-制表符\t的操作来达到相应的目的。由于参数较为简单，这里就不单独列出每个参数单独的用法的示例，主要给出参数组合用法以及和定界符组合使用的示例如下：集合操作含义及对应的参数组合A∩B文件交集，-12A∪B文件的并集，将输出整合为一列，去掉定界符\tA-B差集，-23B-A差集，-13A∆B对称差集，并集减去交集，也就是去除文件中相同的部分，需要使用-3以及将剩下两列整合为一列-12-A∩B-文件交集默认输出结果的第三列就是两个文件共有的部分：sort -k 1,1 a.txt |comm -12 - &lt;(sort -k 1,1 b.txt)aaabbbccc定界符\t-A∪B-文件的并集并集就是将三列输出结果合并：sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;111222aaabbbcccdddeeehhhjjjttt-23-A-B-差集差集就是在A中但是不在B中的部分，去掉第三列(A、B共有的)以及第二列B独有的：sort -k 1,1 a.txt |comm -23 - &lt;(sort -k 1,1 b.txt)111222dddeee-12-B-A-差集差集就是在B中但是不在A中的部分，去掉第三列(A、B共有的)以及第一列A独有的：sort -k 1,1 a.txt |comm -13 - &lt;(sort -k 1,1 b.txt)hhhjjjttt-3+定界符\t-A∆B-对称差集对称差集就是两个文件独有的内容的并集：sort -k 1,1 a.txt |comm -3 - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;111222dddeeehhhjjjttt多列文件的处理多列文件处理会将一整行当成一个元素进行比较，来列出各个文件独有的、文件共有的信息，具体的每列代表的意思和单列文件相同，注意如果文件内容是使用\t作为分隔符，产生的结果输出会重叠cat c.txtaaa 111bbb 222cat d.txtaaa 222bbb 222ccc 333comm c.txt d.txtaaa 111aaa 222bbb 222ccc 333文件内容是使用\t作为分隔符，产生的结果输出会重叠：sed &#39;s/ /\t/&#39; c.txt |comm - &lt;(sed &#39;s/ /\t/&#39; d.txt)aaa 111aaa 222bbb 222ccc 333参考链接comm命令Linux comm命令简明Linux命令行笔记：comm]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[anaconda安装多版本python及常用命令]]></title>
    <url>%2Fposts%2F34297.html</url>
    <content type="text"><![CDATA[anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!前言原本是通过anaconda给电脑安装的python3，但是今天在从github上下载使用一个package时候报错：SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(‘File does not exist: %s’ % filepath)?后来发现这个是因为python版本的问题，所以就需要重新再安装一个python2的环境创建环境这个本来可以使用简单地打开anaconda navigator图形界面进行creat环境即可，但是秉承着想对anaconda进行学习的态度，这里主要使用命令行的形式。显示所有环境名字和路径创建新环境之前先看看目前的电脑有哪些环境：1conda info --envs# conda environments:#base * C:\Users\14910\Anaconda3rstudio C:\Users\14910\Anaconda3\envs\rstudio发现电脑只有一个原装的base环境，也就是python3的环境以及我自己安装的rstudio环境，同时需要注意上面的*表明是当前使用的环境！创建环境并指定环境名称和python版本这一步是使用conda create创建环境，同时指定环境的名称为pyenv2_7，使用的python版本为python=2.7：1conda create --name pyenv2_7 python=2.7再次显示所有环境名字和路径创建新环境再次查看现在所有的环境名称和对应的路径：1conda info --envs发现已经出现了新建的环境：# conda environments:#base * C:\Users\14910\Anaconda3pyenv2_7 C:\Users\14910\Anaconda3\envs\pyenv2_7rstudio C:\Users\14910\Anaconda3\envs\rstudio由于只是创建了环境，还没有激活，所以当前使用的环境(*标记的)还是base环境，新建的环境需要激活才能够使用激活环境为了能够使用新创建的环境还需要激活：1activate pyenv2_7为了验证环境是不是已经成功应用，检查python版本：python –versionPython 2.7.15 :: Anaconda, Inc.发现环境已经安装成功退出环境使用完成之后推出新建的环境，回到base环境：1conda deactivate注意conda deactivate后面不需要跟退出的环境名，直接就退出当前环境，退出环境之后直接就进入了base环境。anaconda 常用命令activate // 切换到base环境activate learn // 切换到learn环境conda deactivate // 退出当前环境conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)conda env list (conda env –info) // 列出conda管理的所有环境conda list // 列出当前环境的所有包conda install requests (pip install requests) // 安装requests包conda remove requests (pip uninstall requests) // 卸载requets包conda update requests // 更新requests包conda remove -n learn –all // 删除learn环境及下属所有包conda env export &gt; environment.yaml // 导出当前环境的包信息conda env create -f environment.yaml // 用配置文件创建新的虚拟环境参考链接ananconda创建新环境，python 2.7、3.5共存，pycharm 使用conda新环境，win10、linux下通用利用Anaconda完美解决Python 2与python 3的共存问题]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Travis CI自动部署github项目]]></title>
    <url>%2Fposts%2F62916.html</url>
    <content type="text"><![CDATA[linux系统，换电脑之后再写！开始于二级标题参考链接Travis CI 自动化部署博客持续集成服务 Travis CI 教程Travis CI用来持续集成你的项目使用travis-ci自动部署github上的项目]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理多个SSH公钥]]></title>
    <url>%2Fposts%2F51573.html</url>
    <content type="text"><![CDATA[项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法SSH key介绍SSH key提供了一种与GitHub或其他平台通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub或其他平台作为自己的remote端服务器，进行版本控制。需要注意的是不同平台的SSH key各不相同，所以为了能在各个平台上方便地使用git进行版本控制，就需要设置多个SSH key。使用SSH key的步骤：在客户端生成SSH key（密钥对：公钥-&gt;锁头和私钥-&gt;钥匙，利用了公钥和私钥实现数据加密和解密）在服务端的配置文件中加入你的公钥。（比如我们需要再GitHub中粘贴你的公钥）具体原理：用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回远程主机，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。生成SSH key默认情况下，使用ssh-keygen生成会在C:\Users\user\.ssh目录下生成SSH key(id_rsa和id_rsa.pub(公钥))，为了使生成了SSH key互不干扰，所以需要使用-f参数进行设置生成了SSH key名称，不然可能会覆盖。在git bash中输入：1234567891011121314ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/keyname(eg:github)ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/coding_pages# 参数说明-t：指定要创建的密钥类型，默认是 rsa ，可以省略-C：添加注释，比如邮箱；-f：指定用来保存密钥的文件名；-b：指定密钥长度；-e：读取openssh的私钥或者公钥文件；-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；-l：显示公钥文件的指纹数据；-N：提供一个新密语；-P：提供（旧）密语；-q：静默模式；上述命令输入后，会出现如下提示：12Generating public/private rsa key pair.# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]可以不输入文件名，使用默认文件名（推荐），那么就会生成 github 和 github.pub 两个秘钥文件；接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）；也可以不输入密码，直接按回车，那么push的时候就不需要输入密码，直接提交到github上了；将 github.pub 文件的内容添加到github上面的ssh key以上是生成一个的过程，生成另一个的过程也是相同的操作。添加生成的SSH将上述得到的公钥(以pub结尾的文件内容复制到平台相应的ssh key添加部位)：修改配置文件在 C:\Users\user\.ssh 目录下新建一个config文件，并添加如下内容：1234567891011121314151617# gitlabHost 公司github的地址 如：github.comHostName 公司github的地址 如：github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github#githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github#githubHost git.dev.tencent.com HostName git.dev.tencent.com PreferredAuthentications publickey IdentityFile ~/.ssh/coding_pages上述host地址的得到可以通过点击平台任意一个项目的clone and download看到，冒号:前面的就是host地址了验证SSH key是否添加成功12345# githubssh -T git@github.com# coding pagesssh -T git@git.dev.tencent.com输出结果：Hi showteeth! You’ve successfully authenticated, but GitHub does not provide shell access.Coding 提示: Hello showteeth, You’ve connected to Coding.net via SSH. This is a personal key.showteeth，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥到这里留完成了管理多个SSH公钥的步骤，接下来就可以不用输入密码地将代码托管到相应的平台上了!参考链接如何同时使用多个SSH公钥提交代码至不同平台管理多个SSH公钥密钥同一台电脑关于多个SSH KEY管理]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF转HTML-pdf2htmlex]]></title>
    <url>%2Fposts%2F40996.html</url>
    <content type="text"><![CDATA[pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。安装windows下安装由于电脑是windows系统，所以只能按照这里给定的教程进行安装，无奈尝试了很多次，最终都以失败告终，都有点想放弃使用这个工具了，但是后来尝试了其他工具如pdf-to-html，但是效果很差，出来的效果和原本的pdf差很多，所以还是放弃了。最近忽然发现应该可以使用docker进行安装，所以尝试使用docker，接下来就是安装和使用docker：注册docker账号然后下载安装docker，这里注意如果电脑上安装了360会提示发现黑客新建用户帐号，建议阻止，鉴于360的一贯行为以及阻止后不能顺利安装，我选择了允许操作安装完成之后会注销和重启电脑，这个按照提示操作即可最后需要注意的是运行docker是在命令行形式下运行，而不是直接打开桌面的快捷方式docker安装使用docker安装pdf2htmlex，可以参考官方给出的教程：1docker pull bwits/pdf2htmlex-alpine输入上述命令后发现错误：1Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)上网搜了一下，发现这个错误是因为网络原因导致无法拉取镜像，解决方法：使用国内的Docker仓库daocloud：进入daocloud关于docker加速器的网站，找到配置 Docker 加速器下对应的操作系统，因为我使用的windows系统，所以选择windows系统下的http://f1361db2.m.daocloud.io将上述所得到的的地址写入docker-&gt;setting-&gt;daemon-&gt;registry mirrors中，然后apply，docker会提示restart：上述操作完成之后重新执行命令，发现下载速度飞快~~~1docker pull bwits/pdf2htmlex-alpine使用通过docker命令详细的使用参考工具的github，这里我只尝试较为简单的：1docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX --zoom 1.8 resume.pdf用到的docker参数说明：-v：挂载宿主机目录，~/pdf对应于C:\Users\user\pdf，/pdf的容器的目录，在容器启动后，容器内会自动创建/pdf目录，也就是冒号:前面的目录是宿主机目录，后面的目录是容器内目录。注意使用时docker会提示需要使用文件权限，如果宿主机目录放在C盘，还要输入电脑密码--rm：默认情况下，每个container在退出时，它的文件系统也会保存下来，该参数可以让docker在container结束时自动清理其所产生的数据-ti：以交互模式启动一个容器创建命令调用别名因为使用的docker安装，每次调用可能全长命令比较麻烦，所以这里使用alias创建命令别名-pdf2htmlEX：12# 自己修改挂载目录alias pdf2htmlEX="docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX"这里一直没有成功不知道是为什么，总是显示文件名、目录名或卷标语法不正确。，但我直接使用命令不使用alias的方式却能正常使用，所以就没有继续使用这个系统自带的cmd是不支持alias的，我这里使用的是cmder，很强大的命令行工具，关于如何在windows下配置这个工具，可以参考博客中关于配置cmder的文章]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>pdf2htmlex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coding_pages和mkdocs使用]]></title>
    <url>%2Fposts%2F54578.html</url>
    <content type="text"><![CDATA[coding pages和mkdocs使用简介注册coding pages前往其官网，常规的注册方法即可关于会员：免费升级好像升级之前不可以创建项目，如果有项目需要转让或者删除，具体操作步骤参考文章创建项目填写项目标识，项目标识在最后创建完pages之后就会显示为username.coding.me/项目标识/项目名称填写：username.coding.me，相当于 github 上面的 name.github.io创建完成即进入项目，选择代码下的代码浏览，创建index.html页面(注意名字一定要叫 index.html)，随意写一段话：12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;My Coding Pages&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Coding!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;然后点击左侧代码下的 Pages 服务，选择静态 Pages 服务，一键创建pages静态 Coding Pages 允许的部署分支来源为master 分支和coding-pages 分支，默认部署来源是master 分支，用户可在设置(右上角)里更改部署来源（实测发现只有master分支）。部署成功后后可通过&lt;user_name&gt;.coding.me／&lt;project_name&gt;形式的 URL 访问静态 Pages如果需要自定义域名，这个也在pages服务中的设置(右上角)中进行设置结合mkdocs安装相关packages12345# 安装mkdocspip install mkdocs# 安装主题pip install mkdocs-material常规用法：12345678# 创建新项目mkdocs new my-project# 启动内建服务器mkdocs serve# 站点生成，创建了一个 site 新目录mkdocs build修改配置12345678910111213141516171819202122232425262728293031# 修改主题和头像theme: name: material favicon: '/dark_logo_16x16.jpg'# 添加页面nav:- 主页 : index.md- 软件 : about.md- 项目 : about.md- 关于 : about.md# 支持中文搜索，虽然search功能(lunr.js)暂不直接支持中文，但测试发现设置为日语后，中文和英文搜索都可以使用extra: search: language: 'jp'# 添加扩展markdown_extensions: - admonition - codehilite: guess_lang: false linenums: false ......# 自定义的CSS和JSextra_javascript: - 'js/extra.js' - 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'extra_css: - 'css/extra.css'上传到coding pages将coding pages项目clone到本地：12# 这里本想使用ssh的链接，但是失败，提示repo不存在，但是使用https的却可以成功，需要再看看问题git clone https://git.dev.tencent.com/showteeth/project.git bio_projects将原本mkdoc目录下的文件拷进这个目录部署到coding pages，详细参考官方教程自动将相应内容推送到项目的 master 分支上，默认会部署在 gh-pages 分支上，而我的账户好像只能部署在master分支上，所以只能修改分支12mkdocs gh-deploy -b master输入链接即可访问最后吐槽一句：coding pages真的好慢好慢！！！！参考链接mkdocs的官方网站mkdocs的githubmkdocs主题material的相关材料（拓展、代码高亮）readthedocs的官方网站（介绍的比较简答，具体实施还是需要看mkdocs的网站说明）readthedocs托管文档支持的markdown语法基于mkdocs-material搭建个人静态博客(含支持的markdown语法)使用mkdocs搭建的文档库]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>coding pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter主题、插件、技巧、server搭建]]></title>
    <url>%2Fposts%2F13473.html</url>
    <content type="text"><![CDATA[针对默认的jupyter notebook的页面进行修改、增加一些插件使jupyter的使用更加方便，整理一些jupyter使用技巧，最后是关于搭建jupyter server的内容jupyter默认页面的修改jupyter默认页面的修改主要是使用jupyter-themes包。jupyter-themes安装常规的pip安装方式：12345# install jupyterthemespip install jupyterthemes# upgrade to latest versionpip install --upgrade jupyterthemes为了达到最好的效果，建议notebook的版本是&gt;=5.6.0，如果低于此版本可以使用pip install --upgrade notebook进行升级refreshing / removing / resetting：如果想要恢复默认值或者使新采用的主题生效，可能需要清除浏览器缓存（不一定非要进行，看自己的浏览器和系统，真遇到情况可以参考issue）；进行上述操作后刷新浏览器肯定是要刷新浏览器的！安装或其他问题直接上github找答案！具体使用命令行：12345jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout] [-P] [-T] [-N] [-r] [-dfonts]具体的参数说明：cl optionsargdefaultUsage help-h–List Themes-l–Theme Name to Install-t–Code Font-f–Code Font-Size-fs11Notebook Font-nf–Notebook Font Size-nfs13Text/MD Cell Font-tf–Text/MD Cell Fontsize-tfs13Pandas DF Fontsize-dfs9Output Area Fontsize-ofs8.5Mathjax Fontsize (%)-mathfs100Intro Page Margins-mautoCell Width-cellw980Line Height-lineh170Cursor Width-cursw2Cursor Color-cursc–Alt Prompt Layout-altp–Alt Markdown BG Color-altmd–Alt Output BG Color-altout–Style Vim NBExt*-vim–Toolbar Visible-T–Name &amp; Logo Visible-N–Kernel Logo Visible-kl–Reset Default Theme-r–Force Default Fonts-dfonts–github上有具体的示例用法，建议大家去看看，我这里挑选我最喜欢的配置如下：1jt -t monokai -f firacode -fs 12 -cellw 70% -ofs 10 -dfs 11 -T -N -altp -lineh 140上述命令是在cmd中输入进行配置，而不是在jupyter notebook中-fs：字体大小-ofs：输出字体大小-dfs：pandas dataframe字体大小-cellw：主体宽度-T：显示导航栏-N：显示文件名称-altp：不显示格子左上角的number-lineh：行高设置完成之后发现jupyter的logo没有完全显示出来，同时文件名称也只显示了一部分，这些需要修改，找到C:\Users\username\.jupyter\custom目录下的custom.css进行修改:12345678910111213&lt;!-- 将none改为block来显示jupyter的logo --&gt;div#ipython_notebook &#123; display: block;&#125;&lt;!-- 将height: initial修改为20px，这个可以自己设置 --&gt;span.save_widget span.filename &#123; margin-left: 8px; height: 22px; font-size: 100%; color: #a6e22e; background-color: #282828;&#125;上述修改每次重新修改主题相关配置后都需要重新修改修改绘图配置：12from jupyterthemes import jtplotjtplot.style(theme='grade3',ticks=True)插件使用主要使用的包是jupyter_contrib_nbextensions，这是一个非常强大的包，里面包含了很多在jupyter notebook只很常用的插件，包括代码段、显示目录等等等，同时这个包还提供了一个链接：A collection of various notebook extensions for Jupyter，里面总结了可以用在jupyter notebook中的插件。安装：123456789# Install the python package## 这个安装经常失败，下载速度太慢了pip install jupyter_contrib_nbextensions## 换用这个了pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master# Install javascript and css filesjupyter contrib nbextension install --user上述两步安装完成之后就可以在jupyter的homo page看到如下的插件：选取插件安装：Code prettify插件的快捷键：ctrl + l进行单个cell的prettify（也可以在选中cell时直接点击导航栏的小锤子按钮）、Ctrl-Shift-L进行所有的的prettify12# 这个插件安装后提示yapf没有安装pip install yapfAfter checking “Snippets Menu” in Configurable nbextensions, Snippets did’t appear inCollapsible headings-折叠标题Snippets-自定义代码片段修改C:\Users\user\AppData\Roaming\jupyter\nbextensions\snippets\snippets.json来添加新的代码段，注意是上面的地址，而不是anaconda目录下的文件，如果修改了anaconda下的文件不起作用。123456789&#123; "name" : "common_use", "code" : [ "import os", "import sys", "import numpy as np", "import pandas as pd" ]&#125;编辑完成之后想要生效需要重启jupyter notebookTable of Contents (2)-显示目录结构这个和上面的jupyter-themes好像要有些冲突，导航栏遮挡部分的目录结构，现在还不知道有没有什么解决办法， 可以取舍一下Highlight selected word-高亮代码中与选中部分相同的highlighter-高亮选中的文本ExecuteTime-显示每个cell的运行时间table_beautifier-让输出的table更好看Snippets Menu-和snippet类似，但是没有正常工作，需要看看为什么？？？Hinterland-自动补全代码使用技巧多行输出关于Jupyter Notebook的28个技巧(快捷键、Magic命令等)jupyter server搭建搭建 ipython/jupyter notebook 服务器Running a notebook server参考链接]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中的实体空格与markdown空格缩进]]></title>
    <url>%2Fposts%2F58681.html</url>
    <content type="text"><![CDATA[本文主要学习了HTML中的6种实体空格以及在实际markdown写作中会涉及到的空格缩进应该使用哪种空格实体会比较好，最后发现使用&amp;emsp;-全角空格在中文markdown写作中是最合适的简介在markdown写作过程中，我们可能需要再文本中插入一些空格，比如中文的首行缩进，与word文档写作直接使用space键空两格即可出现空格不同，markdown不会识别这种空格(四个空格会代表代码块)，为了达到插入空格的效果就需要使用HTML中的空格实体HTML中的实体空格HTML提供了6种空格实体（space entity），它们拥有不同的宽度，非断行空格（&amp;nbsp;）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（&amp;ensp;、&amp;emsp;、&amp;thinsp;、&amp;zwnj;、&amp;zwj;）在不同浏览器中宽度各异&amp;nbsp;-不换行空格&emsp;&emsp;它叫不换行空格，全称是 No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了&amp;nbsp;，它是按下space键产生的空格，一般两个&amp;nbsp;对应于一个中文字符。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个），要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。示例如下：微软雅黑&nbsp;&nbsp;字体，前面有两个&amp;nbsp;空格这是黑体&nbsp;&nbsp;字体，前面有两个&amp;nbsp;空格这是宋体&nbsp;&nbsp;字体，前面有两个&amp;nbsp;空格发现在不同字体中，空格的大小是不同的！&amp;ensp;-半角空格&emsp;&emsp;它叫半角空格，全称是 En Space，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响示例如下：微软雅黑&ensp;&ensp;字体，前面有两个&amp;ensp;空格这是黑体&ensp;&ensp;字体，前面有两个&amp;ensp;空格这是宋体&ensp;&ensp;字体，前面有两个&amp;ensp;空格发现在不同字体中，空格的大小是不变的，并且两格空格占据一个字体大小！&amp;emsp;-全角空格&emsp;&emsp;它叫全角空格，全称是 Em Space，em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响，和上面的&amp;ensp;-半角空格特性相同，但是是一个中文宽度示例如下：微软雅黑&emsp;&emsp;字体，前面有两个&amp;emsp;空格这是黑体&emsp;&emsp;字体，前面有两个&amp;emsp;空格这是宋体&emsp;&emsp;字体，前面有两个&amp;emsp;空格发现在不同字体中，空格的大小是不变的，并且两格空格占据两个字体大小！&amp;thinsp;-窄空格&emsp;&emsp;它叫窄空格，全称是 Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽(前面的&amp;ensp;-半角空格是em宽度的一半，&amp;emsp;-全角空格就是em宽度)示例如下：微软雅黑&emsp;字体，前面有一个&amp;emsp;空格这是黑体&ensp;&ensp;字体，前面有两个&amp;ensp;空格这是宋体&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;字体，前面有六个&amp;thinsp;空格&amp;zwnj;-零宽不连字&emsp;&emsp;它叫零宽不连字，全称是 Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。Unicode中的零宽不连字字符映射为（zero width non-joiner，U+200C），HTML字符值引用为&amp;#8204&amp;zwj;-零宽连字&emsp;&emsp;它叫零宽连字，全称是 Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。零宽连字符的Unicode码位是U+200D (HTML:&amp;#8205;、&amp;zwj;）。此外，浏览器还会把以下字符当作空白进行解析：空格&amp;#x0020;、制表位&amp;#x0009;、换行&amp;#x000A;、回车&amp;#x000D;和&amp;#12288;等等。markdowm首行缩进方法通过上述对HTML中实体空格的介绍，可以总结出以下几种可以用在markdown中充当首行缩进的方法：使用&amp;emsp;-全角空格，优点：占据的宽度正好是1个中文宽度，而且基本上不受字体影响，推荐使用这个进行首行缩进使用&amp;ensp;-半角空格，优点：占据的宽度正好是1/2个中文宽度，需要使用两格才能达到缩进效果，而且基本上不受字体影响使用&amp;nbsp;-不换行空格，缺点：需要使用四个来代表两个中文字符，并且受字体影响较大参考链接markdown空格缩进以及HTML空格实体markdown编辑器中可以使用的6种空格标记]]></content>
      <categories>
        <category>其他内容学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结|位、字节、字符和编码]]></title>
    <url>%2Fposts%2F56690.html</url>
    <content type="text"><![CDATA[本文主要讲解了编码、字符、字节、位的概念，以及不同编码情况下字节与字符的对应关系，主要包括ASCII码、UTF-8编码、Unicode编码、UTF-16编码和UTF-32编码。编码问题的由来，相关概念的理解字符与编码的发展从计算机对多国语言的支持角度看，大致可以分为三个阶段： 系统内码说明系统阶段一ASCII计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。英文 DOS阶段二ANSI编码（本地化）为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 '中' 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些 使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。不同 ANSI 编码之间 互不兼容 ，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。中文 DOS，中文 Windows 95/98，日文 Windows 95/98阶段三UNICODE（国际化）为了使国际间信息交流更加方便，国际组织制定了 UNICODE 字符集，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。Windows NT/2000/XP，Linux，Java字符串在内存中的存放方法：在 ASCII 阶段，单字节字符串使用一个字节存放一个字符（SBCS）。比如，”Bob123” 在内存中为：42 6F 62 31 32 33 00&nbsp;B&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0在使用 ANSI 编码支持多种语言阶段，每个字符使用一个字节或多个字节来表示（MBCS），因此，这种方式存放的字符也被称作多字节字符。比如，”中文123” 在中文 Windows 95 内存中为7个字节，每个汉字占2个字节，每个英文和数字字符占1个字节：D6 D0 CE C4 31 32 33 00&emsp;中&emsp;&emsp;文&emsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0在 UNICODE 被采用之后，计算机存放字符串时，改为存放每个字符在 UNICODE 字符集中的序号。目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS），因此，这种方式存放的字符也被称作宽字节字符。比如，字符串 “中文123” 在 Windows 2000 下，内存中实际存放的是 5 个序号：2D 4E 87 65 31 00 32 00 33 00 00 00 &lt;-在 x86 CPU 中，低字节在前&emsp;中&emsp;&emsp;文&emsp;&emsp;1&emsp;&emsp;2&emsp;&emsp;3&emsp;&emsp;\0一共占 10 个字节字符、字节、字符串理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分： 概念描述举例字符人们使用的记号，抽象意义上的一个符号。'1', '中', 'a', '$', '￥', ……字节计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。0x01, 0x45, 0xFA, ……ANSI字符串在内存中，如果“字符”是以 ANSI 编码形式存在的，一个字符可能使用一个字节或多个字节来表示，那么我们称这种字符串为 ANSI 字符串或者多字节字符串。"中文123"（占7字节）UNICODE字符串在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 UNICODE 字符串或者宽字节字符串。L"中文123"（占10字节）由于不同 ANSI 编码所规定的标准是不相同的，因此，对于一个给定的多字节字符串，我们必须知道它采用的是哪一种编码规则，才能够知道它包含了哪些“字符”。而对于 UNICODE 字符串来说，不管在什么环境下，它所代表的“字符”内容总是不变的。字符集与编码各个国家和地区所制定的不同 ANSI 编码标准中，都只规定了各自语言所需的“字符”。比如：汉字标准（GB2312）中没有规定韩国语字符怎样存储。这些 ANSI 编码标准所规定的内容包含两层含义：使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。“UNICODE 字符集”包含了各种语言中使用到的所有“字符”。用来给 UNICODE 字符集编码的标准有很多种，比如：UTF-8, UTF-7, UTF-16, UnicodeLittle, UnicodeBig 等。常用的编码简介简单介绍一下常用的编码规则，为后边的章节做一个准备。在这里，我们根据编码规则的特点，把所有的编码分成三类：分类编码标准说明单字节字符ISO-8859-1最简单的编码规则，每一个字节直接作为一个 UNICODE 字符。比如，[0xD6, 0xD0] 这两个字节，通过 iso-8859-1 转化为字符串时，将直接得到 [0x00D6, 0x00D0] 两个 UNICODE 字符，即 "ÖÐ"。反之，将 UNICODE 字符串通过 iso-8859-1 转化为字节串时，只能正常转化 0~255 范围的字符。ANSIGB2312,BIG5,Shift_JIS,ISO-8859-2 ……把 UNICODE 字符串通过 ANSI 编码转化为“字节串”时，根据各自编码的规定，一个 UNICODE 字符可能转化成一个字节或多个字节。反之，将字节串转化成字符串时，也可能多个字节转化成一个字符。比如，[0xD6, 0xD0] 这两个字节，通过 GB2312 转化为字符串时，将得到 [0x4E2D] 一个字符，即 '中' 字。“ANSI 编码”的特点：1. 这些“ANSI 编码标准”都只能处理各自语言范围之内的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间的关系是人为规定的。UNICODEUTF-8,UTF-16, UnicodeBig ……与“ANSI 编码”类似的，把字符串通过 UNICODE 编码转化成“字节串”时，一个 UNICODE 字符可能转化成一个字节或多个字节。与“ANSI 编码”不同的是：1. 这些“UNICODE 编码”能够处理所有的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间是可以通过计算得到的。我们实际上没有必要去深究每一种编码具体把某一个字符编码成了哪几个字节，我们只需要知道“编码”的概念就是把“字符”转化成“字节”就可以了。对于“UNICODE 编码”，由于它们是可以通过计算得到的，因此，在特殊的场合，我们可以去了解某一种“UNICODE 编码”是怎样的规则。简介介绍区别位（bit）：计算机存储信息的最小单位，11001100是一个八位二进制数。字节（byte）：是一种计量单位，表示数据量多少，是计算机存储容量基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）字符：是指计算机中使用的字母、数字、字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。编码：把“字符”转化成“字节”不同编码里，字符和字节的对应关系如下：ASCII码：1个英文字母（不分大小写）= 1个字节的空间1个中文汉字 = 2个字节的空间Unicode编码：1个英文字符 = 2个字节英文标点 = 2个字节1个中文（含繁体） = 2个字节中文标点 = 2个字节UTF-8编码：1个英文字符 = 1个字节英文标点 = 1个字节1个中文（含繁体） = 3个字节中文标点 = 3个字节UTF-16编码：一个英文字母字符或一个汉字字符存储都需要2个字节Unicode扩展区的一些汉字存储需要4个字节UTF-32编码：世界上任何字符的存储都需要4个字节unicode编码、UTF-8编码、UTF-16编码、UTF-32编码都是对Unicode字符集进行编码的实现方式查看系统编码linux系统localeLANG=en_US.UTF-8LC_CTYPE=en_US.UTF-8LC_NUMERIC=”en_US.UTF-8”LC_TIME=”en_US.UTF-8”LC_COLLATE=”en_US.UTF-8”LC_MONETARY=”en_US.UTF-8”LC_MESSAGES=”en_US.UTF-8”LC_PAPER=”en_US.UTF-8”LC_NAME=”en_US.UTF-8”LC_ADDRESS=”en_US.UTF-8”LC_TELEPHONE=”en_US.UTF-8”LC_MEASUREMENT=”en_US.UTF-8”LC_IDENTIFICATION=”en_US.UTF-8”LC_ALL=可以看出linux系统的默认编码是UTF-8windows系统windows在dos环境下输入chcp：chcp活动代码页: 936活动代码页为：936，对应的编码格式为GBK参考链接字符与字节的区别字符，字节和编码位、字节、字符的区别UTF-8和Unicode关系简单几句话总结Unicode，UTF-8和UTF-16]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单行命令嵌套]]></title>
    <url>%2Fposts%2F50164.html</url>
    <content type="text"><![CDATA[单行命令嵌套，也就是一行命令使用另一行命令的结果，或者将命令的结果当做参数传给另一个命令，使用方法command1 &lt;(command2).命令格式将command2的结果作为command1的输入：12Usage: command1 &lt;(command2)使用实例uniq命令去重常常需要先进行排序操作：uniq -c &lt;(sort uniq.txt)1 i am test2 i love test1 i want go abroad4 this is a test1 those are good men1 we are good men1 whom have a try1 WhoM have a try1 you have a try当前上述也可以直接使用管道符|来操作但是如果是像join这种需要操作两个文件的，单纯地使用管道符就很难达到目的，join对指定列进行连接时也需要进行排序操作：cat test1.txtaa 1 2bb 2 3cc 4 6dd 3 3cat test2.txtaa 2 1bb 8 2ff 2 4cc 4 4dd 5 5管道符和命令嵌套合用：sort -k 1,1 test2.txt |join -j 1 &lt;(sort -k 1,1 test1.txt) -aa 1 2 2 1bb 2 3 8 2cc 4 6 4 4dd 3 3 5 5当然也可以直接使用命令嵌套：join -j 1 &lt;(sort -k 1,1 test1.txt) &lt;(sort -k 1,1 test2.txt)aa 1 2 2 1bb 2 3 8 2cc 4 6 4 4dd 3 3 5 5]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用内容总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cut-按列切分文件字段工具]]></title>
    <url>%2Fposts%2F64687.html</url>
    <content type="text"><![CDATA[本文主要学习了Linux下对每一行文本按照给定的分隔符进行切割并按照指定的范围提取字段、字符或字节的命令cut，其主要选项包括：-d、-f、--complement、-s、-c、-b、-n和--output-delimiter。cut用法cut命令从文件的每一行剪切字节、字符或字段并将这些字节、字符或字段写至标准输出如果不指定文件，cut命令将读取标准输入cut命令格式12Usage: cut OPTION [FILE]cut options说明table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}参数完整参数说明-b–bytes=LIST以字节为单位进行分割，这些字节位置将忽略多字节字符边界，除非也指定了-n标志-c–characters=LIST以字符为单位进行分割-d–delimiter=DELIM自定义分隔符，默认为制表符tab-f–fields=LIST与-d一同使用，显示指定字段的内容；也会打印不包含分隔符的行，除非指定了-s参数-nwith -b: 取消分割多字节字符，仅和 -b 标志一起使用；如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出，否则该字符将被排除–complement补足被选择的字节、字符或字段-s–only-delimited不打印没有包含分隔符的行，有利于去掉注释和标题–output-delimiter=STRING指定输出内容的分隔符cut指定字段、字符或字节范围的方法指定字段、字符或字节范围有以下三种方法：N-：获取连续范围，从第N个字节、字符、字段到结尾；N-M：获取连续范围，从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；-M：获取连续范围，从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段N,M：获取不连续范围，得到第N个字节、字符、字段和第M个字节、字符、字段N,M,Z-P：获取连续范围和不连续范围，第N个字节、字符、字段、第M个字节、字符、字段以及从第Z个字节、字符、字段到第P个（包括P在内）字节、字符、字段逗号(,)可以使用多个cut用法实例测试数据cat cut.txtNo Name Mark Percent01 tom 69 9102 jack 71 8703 alex 68 98-d 自定义分隔符默认-d是制表符tab，这个很关键，不是空白字符，同时自定义的分隔符必须是单个的字符，比如单个的空格，不能是两个或以上空格cut -d &#39; &#39; -f 1 cut.txtNo010203awk &#39;{print $1&quot;;&quot;$2&quot;;&quot;$3&quot;;&quot;$4}&#39; cut.txt |cut -d &#39;;&#39; -f 1No010203-f 提取指定字段内容选取单个filed如上面-d用法示例选取多个字段，直接将多个字段在-f选项后使用,分割即可：cut -d &#39; &#39; -f 1,3 cut.txtNo Mark01 6902 7103 68也可以使用-和,混用的方法：cut -d &#39; &#39; -f 1,3-4 cut.txtNo Mark Percent01 69 9102 71 8703 68 98–complement 提取指定字段之外的内容cut -d &#39; &#39; -f 1,3 --complement cut.txtName Percenttom 91jack 87alex 98这里得到的结果和上面单纯使用-f得到的结果可以说是互补的，因为--complement是提取指定字段之外的内容-s 不打印没有包含分隔符的行在cut.txt上增加一行文本，其分隔符和其他几行不同：cat cut.txt#this-is-testNo Name Mark Percent01 tom 69 9102 jack 71 8703 alex 68 98默认情况，如果一行不包含分隔符，就会输出这一行：cut -d ‘ ‘ -f 1 cut.txt#this-is-testNo010203为了防止上述情形出现，可以使用-s选项：cut -d &#39; &#39; -s -f 1 cut.txtNo010203可以发现，不包含空格作为分隔符的第一行就没有进行输出-c 提取指定字符范围的内容cat cut2.txtabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz指定连续范围：cut -c -2 cut2.txtabababababcut -c 5- cut2.txtefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyzefghijklmnopqrstuvwxyz指定不连续范围和连续范围（,和-混用）：cut -c 1,3-5 cut2.txtacdeacdeacdeacdeacde-b 提取指定字符范围的内容cut -b 1-5 cut2.txtabcdeabcdeabcdeabcdeabcde这结果咋一看和前面的-c没有什么区别，这是因为操作对象都是英文字母，而在ASCII码和UTF-8编码中英文字母的字节和字符是相等的，具体的字节和字符的区别见这篇博客由于我使用的vscode的默认编码方式为utf-8，所以英文字母的字节和字符是相等的，而中文1个中文（含繁体） = 3个字节，为了凸显-b和-c的区别，下面采用中文进行测试：cat cut3.txt星期一星期二星期三星期四星期五cut -b 1-3 cut3.txt # cut -b 1-2 cut3.txt结果为空，因为需要三个字节才可以星星星星星cut -c 1-3 cut3.txt星期一星期二星期三星期四星期五针对英文字符进行提取指定字符范围内容时，-b和-c选项没什么差别，因为在大部分编码方式中，英文字母的字节和字符是相等的，而针对中文就需要注意不同的编码方式对中文字符对应字节数的设置，当然cut命令还提供了了一个选项-n来解决上述-b可能遇到的问题-n 取消分割多字节字符该选项仅和 -b 选项一起使用，用来取消分割多字节字符cut -b 3 cut3.txtcut -nb 3 cut3.txt星星星星星cut -nb 3,6,9 cut3.txt星期一星期二星期三星期四星期五当-nb后面的数字为3的整数倍（utf-8编码）时就不会分割多字节字符，得到对应的字符，不过感觉这没啥大用处，一般都直接使用了-c参数来获取字符–output-delimiter=STRING 指定输出内容是的分隔符cut -d &#39; &#39; -f 1-3 --output-delimiter=$&#39;\t&#39; cut.txt#this-is-testNo Name Mark01 tom 6902 jack 7103 alex 68注意这里指定输出分割符为tab的时候使用了$&#39;\t&#39;的方式，其中$和单引号都是必须的不能更改的，这个和join命令中指定分隔符的用法相同，具体原因查看这篇文章参考链接cut命令linux的cut命令Linux下的cut选取命令详解linux每日一命令–cut]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniq-去重]]></title>
    <url>%2Fposts%2F20744.html</url>
    <content type="text"><![CDATA[本文学习了linux中准备对文本进行去重操作的uniq命令，其重要的参数包括-c、-d、-D、-f、-s、-w、-i、-u。这个命令通常与sort一起使用。uniq用法uniq命令是专门用来去除重复行的命令，使用时需要注意：对文本操作时，它一般会和sort命令进行组合使用，因为uniq 不会检查重复的行，除非它们是相邻的，如果您想先对输入排序，使用sort -u对文本操作时，若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中字符前的空字符将被跳过uniq命令格式1234Usage: uniq [OPTION] [INPUT [OUTPUT]] # 从输入文件或者标准输入中过滤相邻的匹配行并将结果写入到输出文件或标准输出 # 在不加options的情况下，匹配行将在首次出现处被合并uniq options说明table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}参数完整参数说明-c–count在每行前加上表示行出现次数-d–repeated只输出重复的行，即出现次数&gt;=2的行，且只打印一次-D–all-repeated[=delimit-method]仅显示重复的行，即出现次数&gt;=2的行，且打印重复行的所有行。其中delimit-method表示对重复行集合的分隔方式，有三种取值，分别为none（默认）、prepend和separate。-u–unique只显示唯一的行，即出现次数等于1的行-f–skip-fields=N忽略前N个字段-s–skip-chars=N和-f类似，不过-s是忽略前N个字符-w–check-chars=N指定每行要比较的前N个字符数-i–ignore-case不区分大小写-z–zero-terminatedend lines with 0 byte, not newlineuniq用法实例测试文本cat uniq.txtthis is a testthis is a testthis is a testi am testi love testi love testthis is a testwhom have a tryWhoM have a tryyou have a tryi want go abroadthose are good menwe are good men使用默认方式进行去重uniq uniq.txtthis is a testi am testi love testthis is a testwhom have a tryWhoM have a tryyou have a tryi want go abroadthose are good menwe are good men可以发现，uniq在计算重复的时候只会看相邻行，有一个this is a test没有和其他相邻，结果就被保留下来，当做非重复行-c 显示行重复出现的次数uniq -c uniq.txt3 this is a test1 i am test2 i love test1 this is a test1 whom have a try1 WhoM have a try1 you have a try1 i want go abroad1 those are good men1 we are good men依旧存在前面提到的问题，uniq在计算重复的时候只会看相邻行，和sort连用：sort uniq.txt |uniq -c1 i am test2 i love test1 i want go abroad4 this is a test1 those are good men1 we are good men1 whom have a try1 WhoM have a try1 you have a try单纯使用sort命令去重的结果和上面是一样的，只是不能得到具体的重复数目，uniq功能更加强大：sort -u uniq.txti am testi love testi want go abroadthis is a testthose are good menwe are good menwhom have a tryWhoM have a tryyou have a try-d 只输出重复的行sort uniq.txt |uniq -dc2 i love test4 this is a test-D 仅显示重复的行sort uniq.txt |uniq -Di love testi love testthis is a testthis is a testthis is a testthis is a test这个就不能和-c连用，因为重复行都显示出来了delimit-method=nonenone表示不进行分隔，为默认选项，uniq -D等同于uniq --all-repeated=none注意使用delimit-method的时候就不能使用option的简写形式，必须使用完整参数delimit-method=prependprepend表示在每一个重复行集合前面插入一个空行sort uniq.txt |uniq --all-repeated=prependi love testi love testthis is a testthis is a testthis is a testthis is a testdelimit-method=separateseparate表示在每个重复行集合间插入一个空行sort uniq.txt |uniq --all-repeated=separatei love testi love testthis is a testthis is a testthis is a testthis is a test-f 忽略前N个字段sort uniq.txt |uniq -f 1 --all-repeated=separatei love testi love testthis is a testthis is a testthis is a testthis is a testthose are good menwe are good menwhom have a tryWhoM have a tryuniq -f 2 --all-repeated=separate uniq2.txtthis is a testthis are a testmy name is showteethyour mmmm is showteeth-f是指定前N个field，而不是仅仅规定单独的field来进行判断是不是重复，如果仅仅想看某一列，可以将那一列放在第一个field，然后使用-f参数即可-s 忽略前N个字符sort uniq.txt |uniq -s 4 --all-repeated=separatei love testi love testthis is a testthis is a testthis is a testthis is a testwhom have a tryWhoM have a tryyou have a try-w 指定每行要比较的前N个字符数sort uniq.txt |uniq -w 2 --all-repeated=separatei am testi love testi love testi want go abroadthis is a testthis is a testthis is a testthis is a testthose are good men注意这个参数和前面的-f、-s相同，都是前N个字段或者字符，而不是单纯地指定某一个字段或者字符-i 不区分大小写sort uniq.txt |uniq -i --all-repeated=separatei love testi love testthis is a testthis is a testthis is a testthis is a testwhom have a tryWhoM have a try-u 只显示唯一的行sort uniq.txt |uniq -ui am testi want go abroadthose are good menwe are good menwhom have a tryWhoM have a tryyou have a try显示在忽略大小写情况下的唯一的行：sort uniq.txt |uniq -u -ii am testi want go abroadthose are good menwe are good menyou have a try上面的whom存在大小写区别的行就没排除在外不会显示去除了重复之后的保留的唯一重复行参考链接Linux uniq命令详解Linux命令——uniq命令实例详细说明linux下去除重复行命令uniquniq命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[join-连接文本]]></title>
    <url>%2Fposts%2F5579.html</url>
    <content type="text"><![CDATA[本文学习了可以按照指定field内容来将两个文件连接起来的join命令，其重要的参数包括-1、-2、-j、-o、-t、-a、-e、-v、–nocheck-order。join用法join命令用来将两个文件中指定栏位内容相同的行连接起来，再输出到标准输出设备默认连接的栏位是有空白字符分隔的第一个栏位join命令格式12Usage: join [OPTION] FILE1 FILE2join options说明table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}参数完整参数说明-aFILENUMFILENUM 取1或者2，表示除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行，相当于指定左外链接还是右外连接-vFILENUM与-a相似 但只显示文件里没匹配上的行-eEMPTY取值为字符串，将须要显示可是文件里不存在的域用此选项指定的字符取代-i–ignore-case比较栏位内容时，忽略大小写的差异-jFIELD-j指定一个域作为匹配字段，等同于 -1 FIELD -2 FIELD-1FIELD以file1中FIELD字段进行匹配-2FIELD以file2中FIELD字段进行匹配-oFORMAT以指定格式输出-tCHAR指定输入输出的分隔符，join 默认以空白字符做分隔符–check-order判断所有输入文件是不是已经排好序–nocheck-order不判断所有输入文件是不是已经排好序join用法实例测试数据cat test1.txtaa 1 2bb 2 3cc 4 6dd 3 3cat test2.txtaa 2 1bb 8 2ff 2 4cc 4 4dd 5 5使用默认方式连接文件join test1.txt test2.txtaa 1 2 2 1bb 2 3 8 2join: file 2 is not in sorted order上面的结果没有输出完整，同时输出了提示信息，file 2(test2.txt)没有进行没有进行排序，结合前面学习的sort命令对其第一列进行排序并进行连接：sort -k 1,1 test2.txt |join test1.txt -aa 1 2 2 1bb 2 3 8 2cc 4 6 4 4dd 3 3 5 5这次得到了完整的结果，同时注意在管道符后使用-表示read standard input也就是前面的sort的输出内容对某一列进行连接，就需要保证文件的这一列是排好序的，而不是只要对整个文件进行排序即可–nocheck-order 检查是否排序针对上面出现的文件没有排序的问题，也可以在不报错的情况下直接输出部分结果，默认情况应该是--check-order的：join --nocheck-order test1.txt test2.txtaa 1 2 2 1bb 2 3 8 2这个感觉没啥意义，得不到正确结果-1、-2 指定连接列-1：指定文件1（写在前面的文件）中用于连接的列-2：指定文件2（写在后面的文件）中用于连接的列sort -k 1,1 test2.txt |join -1 1 -2 1 test1.txt -aa 1 2 2 1bb 2 3 8 2cc 4 6 4 4dd 3 3 5 5这个结果和上面默认的结果相同让文件1的第2列与文件2的第3列进行连接（两列都是已经排好序的，不用再排序）：join -1 2 -2 3 test1.txt test2.txt1 aa 2 aa 22 bb 3 bb 84 cc 6 ff 24 cc 6 cc 4可以发现文件1中的cc 4 6出现了两次，这是因为文件2中在第3列上出现了2个4，这2个4对应的行都和文件1中的对应的行进行连接，从而出现了2次如果在文件1中增加一列重复的cc 4 6，得到如下结果：join -1 2 -2 3 test1.txt test2.txt1 aa 2 aa 22 bb 3 bb 84 cc 6 ff 24 cc 6 cc 44 cc 6 ff 24 cc 6 cc 4即使存在重复，连接也会进行组合操作，得到2x2个结果默认情况下，对哪一列进行连接，输出的结果中，用于连接的那一列就会放在最前面，如果需要自定义输出内容和顺序，可以使用后面提到的-o参数进行修改文件在指定的列上存在相同的，则会进行组合，比如各有2个相同的，则会得到2x2也就是4个结果（这里不管文件是否存在重复）-j 指定用于连接的列如果两个文件中用于连接的列(field)相同，可以直接使用-j参数统一制定，不用使用上面那种-1、-2这种分别指定，较为简便：sort -k 1,1 test2.txt |join -j 1 test1.txt -aa 1 2 2 1bb 2 3 8 2cc 4 6 4 4dd 3 3 5 5-o 自定义输出内容和顺序输出文件1的第1列和第2列以及文件2的第1列和第3列：join -1 2 -2 3 -o 1.{1,2} 2.{1,3} test1.txt test2.txtaa 1 aa 1bb 2 bb 2cc 4 ff 4cc 4 cc 4注意这里大括号{}的用法，详细请参考文章-t 指定分隔符sort -k 1,1 test2.txt|awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39;|join -t $&#39;\t&#39; &lt;(awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39; test1.txt) -aa 1 2 2 1bb 2 3 8 2cc 4 6 4 4dd 3 3 5 5指定-t $&#39;\t&#39;后，输出的内容也是以tab作为分隔的；使用默认的分隔符也能对上述案例进行连接，但是输出的是空格分隔，不管原始文件内是使用空格份额各还是tab分隔注意这里指定tab作为分隔符的方式，$&#39;\t&#39;设定的原因（单引号+$）参考之前的这篇文章-a 指定外连接join默认进行的是内连接，也就是找到两个文件中在指定列上能够连接起来的行显示出现，但是要想显示共有的以及一个文件有一个文件没有的行就需要涉及到外连接，分为左外链接和右外连接和全外连接。左外链接指除了显示在指定列上能够连接起来的行外，还要把左边文件有，右边文件没有的行显示出来，右外连接类似，全外连接是将左边和右边的都显示出来，不管有没有连接上设置左外连接：join -1 2 -2 3 **-a 1** test1.txt test2.txt1 aa 2 aa 22 bb 3 bb 84 cc 6 ff 24 cc 6 cc 43 dd 3设置右外连接：join -1 2 -2 3 -a 2 test1.txt test2.txt1 aa 2 aa 22 bb 3 bb 84 cc 6 ff 24 cc 6 cc 45 dd 5设置全外连接：join -1 2 -2 3 -a1 -a2 test1.txt test2.txt1 aa 2 aa 22 bb 3 bb 84 cc 6 ff 24 cc 6 cc 43 dd 35 dd 5这个顺序好像有点错乱，不管是文件1还是文件2的内容都靠左显示，使用-o指定输出内容：join -1 2 -2 3 -a1 -a2 -o 1.{1..3} 2.{1..3} test1.txt test2.txtaa 1 2 aa 2 1bb 2 3 bb 8 2cc 4 6 ff 2 4cc 4 6 cc 4 4dd 3 3dd 5 5发现文件1的内容靠左，文件2的内容前面会留有3个空格（文件1每一行的长度），刚好错开-e 指定替代字符在上面设置左外链接和右外连接的情况下，使用-e设置字符来填充某个文件没有的行的信息:join -1 2 -2 3 -a 2 -o 1.{1..3} 2.{1..3} -e &quot;empty&quot; test1.txt test2.txtaa 1 2 aa 2 1bb 2 3 bb 8 2cc 4 6 ff 2 4cc 4 6 cc 4 4empty empty empty dd 5 5使用-e选项时必须也要设定-o选项，不然不能使用字符进行填充（可能是因为如-a参数使用中的不设置-o参数会使得结果显示出现问题，指定连接的列会在最左边显示，不能连接的行的内容不管是文件1还是文件2都会靠左显示，不能正确显示出内容和文件的对应关系）-v 显示未匹配行join -1 2 -2 3 -v 1 test1.txt test2.txt3 dd 3join -1 2 -2 3 -v 2 test1.txt test2.txt5 dd 5使用实战指定多个列来进行链接因为join命令只支持单个field的连接，而指定多个field作为连接列又非常常用，所以这里给出了几种解决方法：思路一：既然join命令只支持单个field的连接，那就把多个field转化为单个field进行连接即可将上述test1.txt的第1列和第2列与test2.txt的第1列和第3列进行连接：join -j 1 &lt;(awk &#39;{print $1&quot;-&quot;$2&quot;\t&quot;$0}&#39; test1.txt |sort -k 1,1) &lt;(awk &#39;{print $1&quot;-&quot;$3&quot;\t&quot;$0}&#39; test2.txt |sort -k 1,1)aa-1 aa 1 2 aa 2 1bb-2 bb 2 3 bb 8 2cc-4 cc 4 6 cc 4 4控制输出的时候可以使用-o参数对输出进行控制，来决定输出的内容思路二：通过处理其中一个文件得到匹配的fileds，然后利用grep命令在另一个文件中查找这个fields，得到最终的结果提取test1.txt的第1列和第2列作为pattern_file，在test2.txt文件中对齐进行查找：cut -d &#39; &#39; -f 1,2 test1.txt |grep -f - &lt;(awk &#39;{print $1,$3,$2}&#39; test2.txt )aa 1 2bb 2 8cc 4 4注意这个只能得到test2.txt中的内容，而且还必须得调整列的位置，使test2.txt中需要和pattern_file进行连接的列进行对应（pattern_file是第1、2列，那就需要把test2.txt的第3列换到第2列的位置，和pattern_file进行对应），不然不能查找结果。还可以使用awk命令进行操作，具体参考这个链接参考链接Linux join命令linux下join命令的用法Linux命令——join命令linux: join]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort-排序]]></title>
    <url>%2Fposts%2F61024.html</url>
    <content type="text"><![CDATA[本文学习sort-对文件进行排序，主要包括了sort用法(命令格式、参数说明)、用法实例(各种参数：-u、-n、-r、-k、-t、-o、-c、h和g等的实例讲解)并在最后给出了几个非常常用的实战示例。sort用法sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出sort命令既可以从特定的文件，也可以从stdin中获取输入sort命令格式12Usage: sort [OPTION] [FILE]sort options说明table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}参数完整参数说明-b–ignore-leading-blanks忽略每行前面开始出的空格字符-d–dictionary-order排序时，处理英文字母、数字及空格字符外，忽略其他的字符-f–ignore-case排序时，将小写字母视为大写字母，亦即忽略大小写-g–general-numeric-sort按通用数值排序，支持科学计数法-i–ignore-nonprinting排序时，除了040至176之间的ASCII字符外，忽略其他的字符-M–month-sort将前面3个字母依照月份的缩写进行排序 (unknown) &lt; ‘JAN’ &lt; … &lt; ‘DEC’-m–merge将几个排序号的文件进行合并-h–human-numeric-sort使用易读性数字(例如： 2K 1G)-n–numeric-sort依照数值的大小排序-o–output=FILE将排序后的结果存入指定的文件-r–reverse降序排序，默认为升序-t–field-separator=SEP指定排序时所用的栏位分隔字符-k–key=POS1[,POS2]排序从POS1开始，若指定POS2，则POS2结束，否则以pos1排序-u–unique去除重复的行-c–check检查文件是否已经按照顺序排序sort用法实例使用默认方式对文件进行排序sort 命令将以默认的方式将文本文件的第一列以ASCII码的次序排列，并将结果输出到标准输出测试文件default.txt:cat default.txttest 30Hello 95Linux 25sort default.txtHello 95Linux 25test 30-u 去除重复行cat uniq.txttest 30Hello 95Linux 25Linux 25Linux 20文件中存在两行完全相同的信息，这将其去除:sort -u uniq.txtHello 95Linux 20Linux 25test 30会考察所有的列是否相同来进行去除，只有第一列相同是不会进行去除的-n 对数字进行排序cat num.txt102030110120210sort默认会把所有列当成字符来进行排序，因为1小于3，所以110小于20：sort num.txt101101202021030为了避免上述情况，需要使用-n选项，声明是数字进行排序，而不是字符：sort -n num.txt102030110120210-r 降序排列从上面的输出结果可以看出：sort默认进行的是升序排列，为了能够得到降序排列的结果，需要使用参数-r：sort -n -r num.txt 等价于 sort -nr num.txt210120110302010-k 指定排序开始(和结束)的位置-k选项的语法格式123FStart.CStart Modifie,FEnd.CEnd Modifier # 详细划分-------Start--------,-------End-------- # 整体划分FStart.CStart 选项 , FEnd.CEnd 选项 # 详细划分解读这个语法格式可以被其中的逗号,分为两大部分，Start部分和End部分Start部分也由两部分组成:Modifier部分是选项部分，可以用到b、d、f、i、n 或 r。FStart.CStart，其中FStart就是表示使用的域而CStart则表示在FStart域中从第几个字符开始算“排序首字符”。C.Start也是可以省略的，省略的话就表示从本域的开头部分开始同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”如果直接省略了End部分，则会直接从指定的开始位置到一行的结束进行排序实例cat salary.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000从公司英文名称（第一个域）的第二个字母开始进行排序：sort -k 1.2 salary.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000结果解读：使用了-k 1.2，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序，结果是baidu因为第二个字母是a而名列榜首，sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三，guge只能排在第四了。只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序：sort -k 1.2 -k 3nr salary.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000可以发现这个与预期的结果并不一致，和没有按照员工工资进行降序排序的结果相同，所以命令肯定存在问题。首先，-k 3nr没有起作用，相当于只是用前面的-k 1.2就可以达到效果，事实上也正是如此，因为-k 1.2表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序，按照上一个示例的分析，可以将这些结果分开，所以就不存在上面所说的如果相同的按照员工工资进行降序排序，因此后面的排序也就没有了意义。随后基于此我做了一个测试，在最后一行增加”google 110 4500”，这样就存在了-k 1.2不能讲所有的分开是现象，依旧使用上面的命令进行排序：sort -k 1.2 -k 3nr salary.txtbaidu 100 5000sohu 100 4500google 110 4500google 110 5000guge 50 3000发现上述并没有按照我预定的-k 1.2不能讲所有的分开，然后就按照第二个指定的-k 3nr进行排序，然后我去google上搜索相关问题发现有个回答说对多行进行排序时需要指定sort keys的开始和结束，如果没指定结束就会在一直到一行的末尾结束（可能是因为第一个key是主key），不会考虑后面继续设置的key，基于此，做了测试：sort -k 1.2,1 -k 3nr salary.txtbaidu 100 5000sohu 100 4500google 110 5000google 110 4500guge 50 3000最终得到了正确的结果，使用-k 1.2,1是省略.CEnd，则表示结尾到“域尾”，同时吸取上面的教训，为了严谨期间，虽然第3列是最后一列，也直接加上sort key的结束位置：sort -k 1.2,1 -k 3,3nr salary.txt，结果和上面相同-k 3nr：表示在第3列上进行按数字的降序进行排列对不同的列进行不同的排序方式时尤其需要指定sort key的结束为止，如果不指定，会以第一个key设置的为主，忽略后续key的设置，这个在对不同的列分别依据ascii和数字进行排序中非常常见-t 指定field分隔符sort使用-t参数来指定分隔符，默认的分隔符为空格(包括空格和tab):cat sep.txtaaa:eeeccc:eeeddd:dddbbb:ccceee:bbbeee:aaa以:为分隔符，对第二列进行排序：sort -t : -k 2 sep.txteee:aaaeee:bbbbbb:cccddd:dddaaa:eeeccc:eee当然也可以指定列来判断重复与否，并进行删除：sort -t : -uk 2 sep.txteee:aaaeee:bbbbbb:cccddd:dddaaa:eee-o 输出到文件输出到文件也可以使用重定向&gt;进行操作，但是如果使用重定向想要写入原文件，这个时候不但写不进去，还把原文件清空了这个问题可以很好的使用-o参数解决，-o后面接原文件，即可将重排序的结果写入原文件-c 检查文件是否已经排序如果乱序，则输出第一个乱序的行的相关信息sort -c uniq.txtsort: uniq.txt:2: disorder: Hello 95使用实战对多行进行排序并进行去重示例文件：含有google共有三行，其中有两行1、2列是完全相同的，有一行是第一列是相同的：cat salary.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000google 110 4500google 120 4500对1、2列进行排序并删除在这两列上的重复行：sort -uk 1,2 salary.txtbaidu 100 5000google 110 5000google 120 4500guge 50 3000sohu 100 4500可以发现达到了目的只针对第一列来看：sort -uk 1 salary.txtbaidu 100 5000google 110 4500google 110 5000google 120 4500guge 50 3000sohu 100 4500这个并没有达到目的，和前面提到的-k选项中提到的一样，必须要指定终止位置，不然会比较整个行，这样最终结果是没有重复的，如果在上面文件中故意加一行重复的，还果真如此，比较的是整个行：cat salary.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000google 110 4500google 120 4500google 120 4500sort -uk 1 salary.txtbaidu 100 5000google 110 4500google 110 5000google 120 4500guge 50 3000sohu 100 4500增加终止位置，得到预期结果：sort -uk 1,1 salary.txtbaidu 100 5000google 110 5000guge 50 3000sohu 100 4500第一列相同的行中进行去重复保留的是原始文件中第一个出现的对文件大小进行排序-h：排序时使用易读性数字(例如： 2K 1G)统计目录下子目录的大小，并按大小进行降序排列：du -h |sort -hr # du -h统计目录下子目录的大小2.6G ./test22.6G . # 整个目录大小6.8M ./test4.0K ./test3系统进程内存占用排序-g：按通用数值排序，支持科学计数法ps aux |less -SUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDps aux|sort -gr -k 4|head -n 5|awk &#39;{print $2,$3,$4}&#39;10742 0.0 0.83916 99.5 0.7110870 99.5 0.4131268 99.5 0.366967 0.0 0.0参考链接linux sort 命令详解sort命令Linux sort命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串截取方法]]></title>
    <url>%2Fposts%2F43811.html</url>
    <content type="text"><![CDATA[字符串截取在平常的工作中非常常用，这里总结常用的截取方法，便于查阅和温习，主要包括：${}的字符串截取和正则匹配、cut命令的-c参数、awk的substr函数和FS内置参数以及expr的substr表达式使用${}进行截取${}是一种非常常用的linux特殊符号，一般来说共有五种不同的功能，具体的是哪五种功能，之前已经写过一篇博文，这里就不赘述了，这里主要用示例的形式讲解其中与字符串截取相关的两种功能：字符串截取和正则匹配替换。字符串截取${str:offest}：从字符串尾端（左侧）下标offset(含)开始截取到末尾的子串${str:offest:length}：从字符串尾端（左侧）下标offset(含)开始向后截取长度为length的子串，长度超出不报错${str:0-offset:length}：从字符串尾端（右侧）下标offset(含)开始以及向后截取长度为length的子串1234567891011121314str="http://showteeth.tech/posts/55603.html"# 截取从下标5到字符串结尾的子串，注意下标是从0开始的echo $&#123;str:0&#125;echo $&#123;str:1&#125;echo $&#123;str:5&#125;# 从下标5开始截取长度为10的子串echo $&#123;str:5:10&#125;# 字符长度超出不会报错echo $&#123;str:5:40&#125;# 从右数下标15开始截取长度为10的子串echo $&#123;str:0-15:10&#125;http://showteeth.tech/posts/55603.htmlttp://showteeth.tech/posts/55603.html//showteeth.tech/posts/55603.html//showteet//showteeth.tech/posts/55603.htmlosts/55603下标（offset）从0开始 （注意与使用awk的substr函数进行字符截取不同）${str:0-offset:length}是从字串右侧开始数坐标，然后和正常的一样，向后截取长度正则匹配替换${\#parameter}：获取变量长度${parameter#word}、${parameter##word}：从头开始扫描word(pattern)，将匹配word(pattern)的字符过滤掉，#为最短匹配，##为最长匹配${parameter%word}、${parameter%%word}：从尾开始扫描word(pattern)，将匹配word(pattern)的字符过滤掉，%为最短匹配，%%为最长匹配${parameter/pattern/string}、${parameter//pattern/string}：使用string替换pattern，/表示只替换一次；//表示全部替换1234567891011121314151617181920212223# 获取变量长度echo $&#123;#str&#125;# 从左边开始删除第一次出现子字符串即其左边字符，保留右边字符echo $&#123;str#*/&#125;# 从左边开始删除最后一次出现子字符串即其左边字符，保留符号最右边字符echo $&#123;str##*/&#125;# 从右边开始删除第一次出现子字符串即其右边字符，保留左边字符echo $&#123;str%/*&#125;# 从右边开始删除最后一次出现子字符串即其右边字符，保留最左边字符echo $&#123;str%%/*&#125;# 替换，只替换第一次出现的字符echo $&#123;str/\//%&#125;# 替换，所有匹配的都进行替换echo $&#123;str//\//%&#125;38/showteeth.tech/posts/55603.html55603.htmlhttp://showteeth.tech/postshttp:http:%/showteeth.tech/posts/55603.htmlhttp:%%showteeth.tech%posts%55603.html#在%的左边，所以#是从左向右删除字符，保留右边子串，而%是从右向左删除字符，保留左边字符一个#或%是匹配并删除第一次出现的pattern，而##或%%是匹配并删除最后一次出现的pattern（相当于贪婪匹配）上述的parameter都是可以不用引用的，因为${var}本来就和$var是一个意思使用awk进行截取使用awk中的substr函数，substr()用于从字符串中指定位置和长度截取出子串：12345usage： substr(s, i [, n]) s 待截取的字符串 i 索引位置，从1开始，按照字符计算、非字节 n 要截取的长度，默认或者填写长度超出字符尾，则截取到字符尾1echo $str |awk '&#123;print substr($str,5,10)&#125;'://showtee也可以使用awk指定输入分割符的方式截取：1echo $str |awk -v FS="/" '&#123; print $3 &#125;'注意这里与使用${}进行字符串截取不同，这里字符的索引开始为1，而上面${}索引开始位置为0FS是awk内置的系统变量，表示域分隔符，默认为空白字符（空格），使用时需要结合-v来传递参数使用cut进行截取直接通过范围得到子串：cut命令的-c参数：仅显示行中指定范围的字符1echo $str |cut -c 2-6ttp:/注意这里与使用${}进行字符串截取不同，与使用awk的substr函数进行字符截取相同，这里字符的索引开始为1，而上面${}索引开始位置为0cut -c 后面接的是index的起始和终止范围，而不是像前面的awk和${}一样是index和length的组合利用cut按分割符分割来得到子串：cut命令的-d参数：指定字段的分隔符，默认的字段分隔符为”TAB”cut命令的-f参数：指定需要显示的字段1echo $str |cut -d / -f 3showteeth.techcut命令的-d和-f参数合用主要用于得到被已知分隔符分割的一块子串使用expr进行截取expr用于计算表达式变量的值，其中有表达式：substr String StartPosition Length，表示从String的StartPosition开始截取Length的子串1expr substr $str 2 6ttp://注意每个单词之间都有空格，不带空格会出错索引位置也是从1开始，和awk的substr函数、cut命令的-c参数相同，和${}不同使用总结一般最为常用的是${}的正则匹配替换方法(保留字符串最左或者最右的子串)，同时awk和cut使用的也非常多使用需要提供索引位置的方法时需要注意索引的开始位置：awk的substr函数、cut命令的-c参数还有expr的substr表达式索引都是从1开始${str:offest:length}方法的索引则开始于0${}、cut命令的-c参数以及awk的FS内置参数都是用于通过已知分割符得到相应的一块子串，而不是具体地通过索引位置]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用内容总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数计算、浮点计算并保留小数]]></title>
    <url>%2Fposts%2F28430.html</url>
    <content type="text"><![CDATA[在linux中进行整数计算、浮点计算并保留小数，主要包括：使用expr进行整数运算以及简单的字符串操作、let、(( ))、$(())与declare -i、$[]进行整数运算、使用bc进行浮点运算和进制转换以及使用awk进行浮点运算。整数运算shell中默认的操作都是字符操作，如果想要进行数学运算，简单的shell操作可能得不到预期的结果：a=1b=1echo $a + $b1 + 1所以为了执行数学计算就需要有专门的命令来进行操作，以下介绍几种常用的命令和特殊符号。expr 整数或字符串表达式计算expr语法：1expr 表达式表达式说明:expr只能用于整数计算用空格隔开每个项用/(反斜杠)放在shell特定的字符前面对包含空格和其他特殊字符的字符串要用引号括起来整数计算类别语法说明四则运算expr1 \| expr2如果 expr1 不是零或 null 则传回 expr1，否则传回 expr2expr1 \&amp; expr2如果 expr1 及 expr2 都不为零或 null，则传回 expr1，否则传回 0四则运算expr1 + expr2传回 expr1 加 expr2 后的值expr1 - expr2传回 expr1 减 expr2 后的值expr1\* expr2传回 expr1 乘 expr2 后的值expr1 / expr2传回 expr1 除 expr2 后的整数位值（小数位直接丢弃，不四舍五入）expr1 % expr2传回 expr1 除 expr2 的余数大小判断expr1 \&gt; expr2如果 expr1 大于 expr2 则传回 1，否则传回 0。如果 expr1 及 expr2 都是数字，则是以数字大小判断，否则是以文字判断。以下皆同expr1 \&lt; expr2如果 expr1 小于 expr2 则传回 1，否则传回 0expr1 = expr2如果 expr1 等于 expr2 则传回 1，否则传回 0expr1 != expr2如果 expr1 不等于 expr2 则传回 1，否则传回 0expr1 \&gt;= expr2如果 expr1 大于或等于 expr2 则传回 1，否则传回 0expr1 \&lt;= expr2如果 expr1 小于或等于 expr2 则传回 1，否则传回 0123456789expr 2+3expr 2 + 3expr 2 * 3expr 2 \* 3expr 5 / 3expr 2 % 32+3 # 2和3之间没有空格，直接被输出，没有进行计算5 # 输出正确结果expr: syntax error # 因为没有对*进行转义，所以报错6 # 转义后输出正确结果1 # 直接去掉余数，不进行四舍五入2 # 输出余数字符串表达式计算因为expr用于字符串计算并不常见，所以这里不仔细了解，只了解几个个人感觉比较常用的，需要了解的可以参考这篇博客计算字串长度(length)：1expr length "this is a test"14截取子串(substr)：12# substr String StartPosition Lengthexpr substr "this is a test" 3 5is is匹配第一个字符(串)出现的位置(index)：1expr index "this is a test" is3注意四则运算中的*需要进行转义处理，同时还有条件判断中的| &amp;和大小判断中的&gt; &lt;都需要进行转义处理let-运算并赋值let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不要加上 $ 来表示变量(否则会报错)。如果表达式中包含了空格或其他特殊字符，则必须引起来(可以看出来与expr命令每个都需要空格隔开不同，let命令最好不要有空格)。自加操作：let no++自减操作：let no--简写形式 let no+=10，let no-=20，分别等同于 let no=no+10，let no=no-20let var +=1 //存在空格但是不带引号会报错-bash: let: +=1: syntax error: operand expected (error token is “+=1”)let “var +=1” //增加引号即可echo $var2let $var+=1 //加上 $ 来表示变量会报错-bash: let: 2+=1: attempted assignment to non-variable (error token is “+=1”)let var+=1 //不加 $ 正常echo $var3a=1b=2let c=a+b //赋值操作echo $c3(( )) 执行计算和linuxlet指令相似，比let命令好的方面是可以在括号内加空格，不会报错123456789101112# 自加操作a=5;b=7((a--));echo $a# 用在for循环中for ((i=0;i&lt;5;i++));do echo $i;done# 赋值((c=b+1))# 加空格(( c = b + 1 ))$(())与declare -i 整数运算12declare -i total=$firstnu*$secnutotal=$(($firstnu*$secnu))区别就是小方括号内可以加上空格符，也是合法的写法，而declare -i 不可以：12345678910111213# 正确的写法declare -i total=2*3# 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以declare -i total=2* 3# 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错total=$((2*3))# $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取a=5;b=7;c=2echo $((a+b*c))echo $(($a+$b*$c))declare -i加空格报错：bash: declare: 2: syntax error: operand expected (error token is ““)$(())在等号左右加空格报错：bash: 6: command not found$(())进制转化：将其他进制转成十进制数显示出来12# N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值echo $((N#xx))$[]运算a=1echo $[a+1]2echo $[c=a+1]2 //会先输出运算的结果echo $c2 //也会赋值浮点计算并保留小数bcbc命令是任意精度计算器语言，通常在linux下当计算器用, 它类似基本的计算器, 使用这个计算器可以做基本的数学运算。常用的运算：+ 加法- 减法* 乘法/ 除法^ 指数% 余数sqrt 开方语法：1bc (选项) (参数)在shell中直接输入bc即可进入交互式界面，类似于没有图形界面的计算器，输入表达式得到结果具体用法不详细讲解，可以参考这篇博客实际进行浮点运算常用的方法是通过管道符：1234usage: echo 'scale=num; expression'|bc num：表示保留的小数点后位数 expression：表示计算表达式1echo 'scale=2;2/3' |bc.66可以发现上述输出结果中并没有0(因为结果小于0)，如果想要显示可以使用：1echo 'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"' |bc0.66bc还能用来进行进制的转换：123456usage： echo "obase=base;ibase=base;num" | bc obase:输出数字的进制，默认值为10 ibase:输入数字的进制，默认值为10 num:进行进制转换的数字 obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的obase如果放在ibase后可能会出错：1234# obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的echo "obase=10;ibase=2;110" | bcecho "ibase=2;obase=10;110" | bc6110awkawk中的计算，默认支持浮点运算：1echo |awk '&#123;print 2/3&#125;'格式化输出：12# 保留两位小数echo |awk '&#123;printf("%.2f\n" , 3/50)&#125;']]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell编程</tag>
        <tag>常用内容总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中特殊符号用法]]></title>
    <url>%2Fposts%2F55603.html</url>
    <content type="text"><![CDATA[Linux常见特殊符号作用，包括#、~、~+、~-、;、;;、.、&#39;&#39;、&quot;&quot;、`、,、/、\、|、!、:、*、**、$、$$、?、${}、$*、$@、$#、$(())、(())、()、{}、[]、[[]]、|| 、&amp;&amp;、\&lt;...\&gt;和文件操作符以及重定向。#号-注释在脚本中 #也常出现在一行的开头,或者位于完整指令之后,这类情况表示符号后边是注解文字,不会被执行，如果被用在指令中，或者引号、双引号括住的话，或者在反斜线的后面，那他就变成一般符号，不具上述的特殊功能。123#!/bin/bash#this line is comments~ home目录代表使用者的home目录：cd ~表示进入home目录；也可以直接在符号后加上某帐户的名称：cd ~user表示进入这个user的home目录；或者当成是路径的一部份：~/bin~+表示当前的工作目录~-表示上一个工作目录，这个在目录切换很好用啊，cd ~-直接进入上一次cd之前的目录123456789# 当前工作目录pwdecho ~+# 进入上一次cd之前的目录cd ~-# 进入上一次cd之前目录下的test目录cd ~-/test/; 分号连续命令之间起到连接作用，命令之间没有依赖，不管上一条命令是否执行成功，分号后的命令都会执行。;;连续分号专用在case（多分支条件判断）的选项，担任 Terminator 的角色. 点号(dot)在目录中：一个.表示当前目录，两个..表示上层目录在文件命名中：以.开头的文件表明该文件是隐藏文件，需要使用ls -a才能看到在正则表达式中：一个逗号表示一个任意字符（换行符 \n 之外），如果想要匹配.，需要使用转义\.。‘’ 单引号被单引号用括住的内容，将被视为单一字串。在引号内的代表变量的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。12345test="hello"echo '$test'test="HELLO"echo "hello WORLD" |sed 's/hello/$test/'输出结果：$test$test WORLD“” 双引号被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量替换，这点与单引号的处理方式不同。12345test="hello"echo "$test"test="HELLO"echo "hello WORLD" |sed "s/hello/$test/"输出结果：helloHELLO WORLD`` 反引号在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用反引号来做，被反引号括住的内容是可以执行的。与反引号相同可以用来进行命令执行的还有$()，两者的区别在于如果是使用反引号执行命令在进行命令嵌套时会比较麻烦，而使用$()进行命令的嵌套会比较简单。12test="hello"echo `echo $test`等同于：1echo $(echo $test)命令嵌套：1echo $(echo $(echo $test))不等同于：1echo `echo `echo $test``反引号遇到第一个匹配的反引号就结束，之间的内容会当做命令运行，可以使用转义字符\解决嵌套问题等同于：1echo `echo \`echo $test\``所以还是使用$()来得到命令执行结果更为简便，但是不需要嵌套时两者差不多, 逗号这个符号常运用在运算当中当做区隔用途。1awk '&#123;print $1,$2,$3,$4&#125;' filename/ 斜线在路径表示时，分割不同级别的目录单一的斜线/表示根目录，和上面的~表示的家目录不同在四则运算中，代表除法的符号\ 反斜线在交互模式下的escape字元，有几个作用放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失（转义）；放在指令的最末端，表示指令连接下一行。12345678# ls -lll# 取消ll代表ls -l，在ll之前防止反斜线表示暂时取消别名的功能，将 ll 指令还原\ll# 转义，取消变量应用\$test最终ll结果输出：bash: ll: command not found| 管道符连结上个指令的标准输出，做为下个指令的标准输入。! 惊叹号通常它代表反逻辑的作用，如!=表示不等于匹配模式取反：sed -n &#39;1,2!p&#39; test.txt表示打印第1、2行之外的行；ls a[!0-9]表示显示除了a0, a1 …. a9 这几个文件的其他文件在历史命令（history）中：!number ：表示执行history中第number条命令!!：表示执行上一条命令!command：执行最近一条command为开头的命令!$：表示最近一条命令的第二个字符信息12mkdir test!!输出结果：mkdir testmkdir: cannot create directory `test’: File exists12mkdir test!$输出结果：test: 冒号在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0: &gt; f：相当于cat/dev/null&gt;f，这样不仅写法简短了，而且执行效率也好上许多: ${HOSTNAME?} ${USER?} ${MAIL?}这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。(这个具体还没试验过)添加环境变量时需要使用:分割，比如PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla* 星号在文件名扩展(Filename expansion)上，用来代表0到无穷多个任意字符在正则表达式（Regular Expressions）中，代表重复零个到无穷多个的前一个字符，而代销0到无穷多个任意字符是使用.*。在运算时，它则代表 “乘法”*在不同地方不同的用法需要注意，尤其是代表0到无穷多个任意字符、重复零个到无穷多个的前一个字符这方面。** 次方运算两个星号在运算时代表 “次方” 的意思。$和$$引用变量的前导符号，如var=&quot;test&quot; echo $var在正则表达式里被定义为行的最末端 (end-of-line)，这个常用在grep、sed、awk 以及 vim(vi) 当中在bash中$本身也是个变量。代表的是目前这个shell的进程代码，即所谓的PID（Process ID）$$ Shell本身的PID（ProcessID）$! Shell最后运行的后台Process的PID$? 最后运行的命令的结束代码（返回值），一般指令程序倘若执行成功，其回传值为 0，失败为 1。其他参考该博客$后接引号（单双引号），单引号可以使引号内的内容被特殊对待：会将某些反斜线序列(如\n，\t，\&quot;，\&#39;等)继续转义(\t-&gt;tab;\n-&gt;换行)，而不认为它是字面符号(如果没有$符号，单引号会强制将string翻译为字面符号，包括反斜线)；而双引号则没有上述效果，$&quot;string&quot;和&quot;string&quot;是完全等价的，使用$&quot;&quot;只是为了保证本地化echo &#39;a\nb&#39;a\nb上述结果并没有和预期的一样在a、b之间进行换行，这是因为单引号中的\n被看成了字面意思，就是反斜线加上n，而不是特殊的换行的意思如果在前面加上$：echo $&#39;a\nb&#39;ab这个结果和预期的一样，因为$将\n翻译成了换行，而不是单纯的反斜线加上n，这个在join命令指定分隔符时会用到，具体参考介绍join用法的文章如果将上述单引号转换为双引号：echo $&quot;a\nb&quot;a\nb发现在使用双引号的情况下，得到的结果和没使用$是一样的，这和前面说的$&quot;string&quot;和&quot;string&quot;是完全等价的是相符的。常见的需要注意使用$和单引号的转义字符包括：123456789101112\a alert (bell)\b backspace\e\E an escape character\f form feed\n new line\r carriage return\t horizontal tab\v vertical tab\\ backslash\' single quote\" double quote? 问号在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字符，但不包含空字符，注意是一个字符，不能是0个也不能是两个，注意和正则表达式的用法区分。比如：ls a?c.txt可以得到abc.txt和amc.txt 但是不能得到abbc.txt，也不能得到ac.txt在正则表达式式中，?表示匹配前面的字符0次或1次，不是任意字符，注意和文件名拓展的区分。同时在正则表达式中还可以用来表示非贪婪匹配在bash中，这个变量是上一个执行的命令所回传的值。当我们执行某些命令时，这些命令都会回传一个执行后的代码，一般说，如果成功执行该命令，则会回传一个0值，如果执行过程发生错误，就会回传错误代码，一般以非0的数值来替代${} 变量的正规表达式一般情况下，$var与${var}是没有区别的，但是用${}会比较精确的界定变量名称的范围1234# 这个明确说明了var才是变量$&#123;var&#125;_suffix$var_suffix${} 参数替换${var_name} 等价于$var_name（通常用这种简写方式）$(var:-default) 和 $(var-default)$(var:-default)：当var为空或未定义时整个表达式的值为default$(var-default)：当且仅当var未定义时整个表达式的值为default$(var:=default) 和 $(var=default)$(var:=default)：当var为空或未定义时整个表达式的值为default，并且将var的值设置为default$(var=default)：当且仅当var未定义时整个表达式的值为default，并且将var的值设置为default$(var:?default) 和 $(var?message)$(var:?message)：当var为空或未定义时，打印错误信息，信息内容为message表示的值$(var?message)：当且仅当var未定义时，打印错误信息，信息内容为message表示的值$(var:+default) 和 $(var+default)$(var:+default)：当var已定义且不为空时整个表达式的值为default$(var+default)：当var已定义时整个表达式的值为default(不管var是否是空)${} 字符串截取${str:offest}：从下标offset(含)开始截取到末尾的子串${str:offest:length}：从下标offset(含)开始向后截取长度为length的子串，长度超出不报错${str:offest:index}：${} 变量匹配${!prefix*}、${!prefix@}：将带有前缀为prefix的变量名打印出来${} 数组操作${!name[@]}、${!name[*]}：将数组name的所有下标返回，如果变量name不是数组则返回0,不存在则空${name[@]}、${name[*]}：将数组name的所有元素返回，如果变量name不是数组则返回name的值,不存在则空${\#name[@]}、${\#name[*]}：返回数组元素总个数${name[index]}：将数组name的index处的元素返回，如果变量name不是数组且index为0时返回name的值，变量或索引index处的元素不存在则返回空${\#name[index]}：返回数组name的index处的元素长度name[index]=xyz：数组name的index处的元素重新赋值上面的${\#name[@]}中对#做了转义处理，不然博客可能报错，参考github issue，正常情况下使用时不用加\进行转义。${} 正则匹配替换${parameter#word}、${parameter##word}：从头开始扫描word(pattern)，将匹配word(pattern)的字符过滤掉，#为最短匹配，##为最长匹配${parameter%word}、${parameter%%word}：从尾开始扫描word(pattern)，将匹配word(pattern)的字符过滤掉，%为最短匹配，%%为最长匹配${parameter/pattern/string}、${parameter//pattern/string}：使用string替换pattern，/表示只替换一次；//表示全部替换${\#parameter}：获取变量长度上述的parameter都是可以不用引用的，因为${var}本来就和$var是一个意思$* 得到脚本变量$*引用script的执行引用变量，引用参数的算法与一般指令相同，script本身为0，其后第一个为1，然后依此类推。引用变量的代表方式如下：$0, $1, $2, $3, ${10}, ${11}，注意个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。$* 则是代表所有引用变量的符号，使用时得视情况加上双引号，如echo &quot;$*&quot;12bash example.sh var1 var2 var3# $0是example.sh、$1是var1、$2是var2、$3是var3$@ 得到脚本变量$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数但是当它们被双引号(“ “)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数也就是说$@不管有没有被双引号包围，其输出结果都是单个的变量形式，而$*在不被双引号包围时输出单个变量的形式，被双引号包围时，所有的参数以整体的形式输出$# 变量总数12# 输出变量总数echo "$#"$(())与declare -i 整数运算12declare -i total=$firstnu*$secnutotal=$(($firstnu*$secnu))区别就是小方括号内可以加上空格符，也是合法的写法，而declare -i 不可以：12345678910111213# 正确的写法declare -i total=2*3# 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以declare -i total=2* 3# 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错total=$((2*3))# $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取a=5;b=7;c=2echo $((a+b*c))echo $(($a+$b*$c))declare -i加空格报错：bash: declare: 2: syntax error: operand expected (error token is ““)$(())在等号左右加空格报错：bash: 6: command not found$(())进制转化：将其他进制转成十进制数显示出来12# N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值echo $((N#xx))(( )) 执行计算和linuxlet指令相似1234a=5;b=7((a--));echo $afor ((i=0;i&lt;5;i++));do echo $i;done( ) 指令群组用括号将一串连续指令括起来，这被称为指令群组指令群组有一个特性，shell会以产生subshell来执行这组指令，因此，在指令群组所定义的变量，仅作用于指令群组本身：12test="test"(cd ~ ; test=`pwd` ;echo $test);echo $test最终结果：/home/usrtest( )也可被用于数组的声明中：1Array=(element1 element2 element3){ } 大括号作为代码块代码块，又被称为内部组，这个结构事实上创建了一个匿名函数。与上面小括号中的指令群组不同，花括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量，因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。12345678# 第一个命令和左括号之间没有空格&#123;cd ~ ; test=`pwd` ;echo $test&#125;;echo $test# 最后一个命令没有分号&#123; cd ~ ; test=`pwd` ;echo $test&#125;;echo $test# 正确用法&#123; cd ~ ; test=`pwd` ;echo $test;&#125;;echo $test第一个命令和左括号之间没有空格报错：bash: {cd: command not found/home/user/test}/home/user/test最后一个命令没有分号报错：> ^C正确输出：/home/user/home/user作为拓展通配(globbing)将对花括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt对大括号中以点点（..）分割的顺序文件列表起拓展作用，如 for i in {1..2};do echo $i;done 结果为1 2进行组合大括号{}里面的内容以逗号分隔，两个或多个大括号内的内容进行组合。12345# 3x3的组合，中间的短横线是分割线，可以自定义mkdir &#123;userA,userB,userC&#125;-&#123;home,bin,data&#125;# 进行嵌套使用chown root /usr/&#123;ucb/&#123;ex,edit&#125;,lib/&#123;ex?.?*,how_ex&#125;&#125;[ ] 中括号在通配符和正则表达式中[]代表一定有一个在中括号内的字符，例如[abcd]代表一定有一个字符，可能是a、b、c、d这四个任何一个，[num1-num2]表示范围、[^]表示非流程控制中，扮演括住判断式的作用，[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较&quot;ab&quot;和&quot;bc&quot;：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示在一个array结构的上下文中，中括号用来引用数组的索引[[ ]] 双中括号这组符号与先前的 [] 符号，基本上作用相同，但是&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式，字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]]中匹配字符串或通配符，不需要引号1234567891011[root@localhost ~]# [[ 2\&lt;3 ]] &amp;&amp; echo true || falsetrue[root@localhost ~]# [[ 2 -lt 3 ]] &amp;&amp; echo true || falsetrue[root@localhost ~]# [[ 2 \&lt; 3 ]] &amp;&amp; echo true || false-bash: 期待二元条件运算符-bash: `\&lt;' 附近有语法错误，这是因为空格的原因[root@localhost ~]# [ 2 \&lt; 3 ] &amp;&amp; echo true || falsetrue[root@localhost ~]# [ 2 &lt; 3 ] &amp;&amp; echo true || false-bash: 3: 没有那个文件或目录|| 逻辑符号在中括号中[]代表 or 逻辑的符号在命令行中：cmd1||cmd2若cmd1执行完毕且正确执行($?=0)，则cmd2不执行若cmd1执行完毕且为错误($?≠0)，则开始执行cmd2&amp;&amp; 逻辑符号在中括号中[]代表 and 逻辑的符号在命令行中如下:cmd1&amp;&amp;cmd2若cmd1执行完毕且正确执行（$?=0）,则开始执行cmd2若cmd1执行完毕且为错误（$?≠0），则cmd2不执行12# 如果./symbol/abc目录不存在则创建这个目录，成功后在目录下创建hehe文件ls ./symbol/abc || mkdir ./symbol/abc &amp;&amp; touch ./symbol/abc/hehe目录不存在，ls的报错信息ls: cannot access ./symbol/abc: No such file or directory\&lt;…\&gt; 单字边界这组符号在规则表达式中，被定义为”边界”的意思。12# 删除能完整匹配This这个单词的行sed '/\&lt;This\&gt;/d' test.txt文件操作符合输出/输入重定向&gt;：表示重定向&amp;：表示等同于的意思文件描述符是和文件的输入、输出相关联的非负整数，Linux内核（kernel）利用文件描述符（file descriptor）来访问文件。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。常见的文件描述符是stdin、stdout和stderr。常用的文件描述符如下：文件描述符名称常用缩写默认值0标准输入stdin键盘1标准输出stdout屏幕2标准错误输出stderr屏幕在简单地用&lt;或&gt;时，相当于使用 0&lt; 或 1&gt;，注意文件描述符和重定向符号之间不能存在空格，同时也可以将&gt;改为&gt;&gt;追加而不是覆盖文本信息cmd &gt; file等同于cmd 1&gt; file：把cmd命令的输出重定向到文件file中，如果file已经存在，则覆盖原有文件cmd &gt;&gt; file等同于cmd 1&gt;&gt; file：把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面cmd &lt; file等同于cmd 0&lt; file：使cmd命令从file读入，必须是文件，不能是字符cmd &lt;&lt; text等同于cmd 0&lt;&lt; text：从命令行读取输入，直到一个与text字符相同的行结束cmd 2&gt; file：把cmd命令的标准错误输出重定向到文件file中，如果file已经存在，则覆盖原有文件cmd 2&gt;&gt; file：把cmd命令的标准错误输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面cmd &gt;&amp;n等同于cmd 1&gt;&amp;n：把输出重定向到文件描述符n，通过对&amp;的解读：标准输出的重定向等同于文件描述符ncmd m&gt;&amp;n ：把输出到文件符m的信息重定向到文件描述符n从命令行读取输入：1cat &lt;&lt; wang &gt; haha.txt从命令行得到输入，直到出现wang为止cat &lt;&lt; wang &gt;haha.txt> test> test2> wangcmd &lt;&lt;&lt; word：将word(字符)，注意不是上面的file读入标准错误输出：123456789101112# test.file不存在，没有任何错误提示，正常运行cat test.file 2&gt; out.txt # 与上面的方法结果相同，错误的信息都被输入到了out.txt中cat test.file &amp;&gt; out.txt# 将错误输出丢弃到/dev/null中，/dev/null是一个特殊的设备文件，这个文件接受到任何数据都会被丢系，通常被称为位桶、黑洞cat test.file 2&gt; /dev/null# 将标准输出重定向大list.txt文件中，标准错误输出重定向到list.err文件中cat test.file 1&gt; list.txt 2&gt; list.err将标准错误stderr与stdout一同重定向到test.log文件:12# 将标准输出重定向到test.log中，然后文件描述符2（标准错误输出）的重定向等同于文件描述符1（标准输出）./test.sh &gt;test.log 2&gt;&amp;1文件描述符支持自定义，参考文章实战总结得到数字用于循环的方法汇总1234567for i in `seq 1 5`;do echo $i ;donefor i in $(seq 1 5);do echo $i ;donefor ((i=1;i&lt;6;i++));do echo $i ;donefor i in &#123;1..5&#125; ;do echo $i ;done转义字符总结有时候，我们想让通配符或者元字符变成普通字符，不需要使用它，那么这里我们就需要用到转义符了，shell提供转义符有三种：字符说明‘’(单引号)又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)“”(双引号)又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替\(反斜杠)又叫转义，去除其后紧跟的元字符或通配符的特殊意义参考链接linux 特殊符号大全Linux命令中特殊符号，排版更好看Linux中的特殊符号及含义linux中特殊符号用法]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux特殊符号用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日总结和计划]]></title>
    <url>%2Fposts%2F51961.html</url>
    <content type="text"><![CDATA[2019-2-24开始的每日学习总结与计划.tg{border-collapse:collapse;border-spacing:0;border-color:#999}.tg td{font-family:Arial,sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#f7fdfa}.tg th{font-family:Arial,sans-serif;font-size:14px;font-weight:400;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ade4}.tg .tg-phtq{background-color:#d2e4fc;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-hmp3{background-color:#d2e4fc;text-align:left;vertical-align:top}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}2019-2-24今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令-sed学习了基本语法、掌握了选项i、n、e、f以及命令s、p、g2小时 Python 机器学习 其他内容markdown完成了markdown基本语法的学习3个小时今日学习情况总结：首先是学习了markdown基本语法，收获了很多，比如html块元素是必须要进行留空白行的、有序列表前的数字不关键、创建表格以及进行相应的优化（还不够完善）等新内容；也开始学习了linux基本命令sed，对其使用有了基本的了解，明天还要接着学习！明日学习哪些内容明日学习计划总览：markdown表格的优化（宽度调整）shell中特殊符号的学习sed命令的学习2019-2-25今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令-sed完成了sed的学习大概3个小时 Python 机器学习 其他内容今日学习情况总结：今天主要是完成了sed命令的学习，学习过程中发现sed和之前学的其他命令如awk、grep等有很多相似之处，有了之前的基础学起来更加容易理解，果然是学的越多学得越快！！！通过对sed命令的学习，在以后处理文本时就又增加了一个非常有力的工具！每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：shell中特殊符号的处理markdown表格的优化（宽度调整）~sort排序命令2019-2-26今日学习完成情况类别学习内容大致描述大概用时 Linux其他一些常用内容总结Linux中特殊符号用法大概4个小时 Python 机器学习 其他内容markdown基本语法表格优化-单元格宽度自定义大概30分钟今日学习情况总结：主要学习和总结了linux中很多特殊的符号的常见用法，加强了对前面学习知识的理解与认知，如sed命令中出现变量引用需要将单引号修改为双引号在这里就找到了答案，同时这也是普适的用法，因为单引号防止任何变量替换，而双引号恰好可以允许变量替换，同时还有很多提高脚本效率的知识，并且觉得这部分内容比较杂（需要不断更新和回顾），但是很重要，如果很多符号的含义不清楚，后面学习其他命令很容易迷糊和犯错。每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：sort排序命令整理字符串截取和浮点计算并保留小数的方法2019-2-27今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令-sort、其他一些常用内容总结完成了sort命令学习、字符串截取方法和浮点计算并保留小数大概5个小时 Python 机器学习 其他内容今日学习情况总结：今天主要学习了sort命令的使用，对其中的-k参数进行了深刻的理解，同时学习到了一些实战用法也很实用！同时也温习和补充了之前学习的字符串截取方法和浮点计算并保留小数内容。每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：uniq、join、cut单行命令嵌套准备学习李航老师的机器学习内容安装并使用pdf2htmlex2019-2-28今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令完成了join命令、uniq命令学习、开始了cut命令学习大概5个小时 Python 机器学习 其他内容今日学习情况总结：今天主要学习了几个非常使用的命令，完成了uniq、join还有开始了大部分的cut命令学习，这些都是非常常用的命令，平常都有使用，但是掌握不够完善，这里系统的学习有助于后续应用同时也可以当做笔记查询。每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：继续学习cut单行命令嵌套准备学习李航老师的机器学习内容完成研究2019-3-1今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令、其他一些常用内容总结完成了cut命令学习、总结了位、字节、字符和编码、单行命令嵌套大概5个小时 Python 机器学习 其他内容今日学习情况总结：完成了cut命令学习、总结了位、字节、字符和编码、单行命令嵌套等相关内容每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：继续学习cut单行命令嵌套准备学习李航老师的机器学习内容完成研究2019-3-2今日学习完成情况类别学习内容大致描述大概用时 Linux其他一些常用内容总结监控脚本运行脚本大概3个小时 Python 机器学习 其他内容今日学习情况总结：今天主要在进行研究，完善之前的脚本，同时还整理了一下关于后台脚本监控相关内容，这个非常实用！每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：准备学习李航老师的机器学习内容完成研究整理lncRNA分析流程将脚本监控上传到github2019-3-3今日学习完成情况类别学习内容大致描述大概用时 Linux Python常用工具整理jupyter notebook优化-主题和插件大概3个小时 机器学习 其他内容coding_pages使用coding_pages使用以及mkdocs大概1个小时今日学习情况总结：今天完成了研究内容，同时对jupyter notebook进行了相应的优化并且也开通了coding pages，准备将projects转移过去。每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：准备学习李航老师的机器学习内容整理研究结果，形成文档给师兄看看整理lncRNA分析流程将脚本监控上传到github2019-3-4今日学习完成情况类别学习内容大致描述大概用时 Linux Python 机器学习 其他内容coding_pages以及mkdocs使用、PDF转HTML-pdf2htmlexcoding_pages使用以及mkdocs、PDF转HTML-pdf2htmlex大概3个小时今日学习情况总结：今天对lncRNA的分析步骤进行了一定的整理(发现事后去整理分析步骤真的很难受，所以以后还是在边分析边整理比较好)；搭建了基于mkdocs的项目管理系统；将后台程序监控脚本上传到了github每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：准备学习李航老师的机器学习内容整理研究结果，形成文档给师兄看看coding pages搭建好2019-3-5今日学习完成情况类别学习内容大致描述大概用时 Linux Python 机器学习资料整理在ipad上上传了李航机器学习等部分的书本，便于记笔记大概2个小时 其他内容管理多个SSH公钥、HTML中的空格实体与markdown空格缩进、整理了github管理多个SSH公钥、HTML中的空格实体与markdown空格缩进、整理了github大概3个小时今日学习情况总结：今日将研究内容整理完毕并将其交给师兄看了，然后师兄给我拍了新的任务；学习了在一台电脑上管理多个SSH公钥的方法，便于在多个平台上提交管理代码；学习了HTML中的空格实体与markdown空格缩进，对markdown的技能又掌握了一项！同时我将我的github整理了一下，之前没有很好区分fork和star，结果导致fork项目过多，但是自己真正用到的很少，所以将暂时用不到的等放在了star部分，后期用到的时候再去fork修改也行；整理了李航机器学习的部分资料，必须整理出一个学习大纲出来了！每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：准备学习师兄布置的新任务linux-comm命令学习2019-3-6今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令comm-文件比较，文本文件的交集、差集与求差1.5小时 Python 机器学习 其他内容上课、尝试了enex、html转markdown工具、重庆旅游攻略上课、尝试了enex、html转markdown工具、重庆旅游攻略7小时今日学习情况总结：今天主要是在上课（一下午）；上午尝试了了enex、html转markdown工具，结果都不是很理想；收集了一下重庆的旅游攻略；学习了comm命令、diff命令以及cmp命令每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：准备学习师兄布置的新任务完成linux-comm命令、diff命令以及cmp命令学习修改整数计算、浮点计算并保留小数，增加数学运算(融合成一个)，也就是shell编程中的部分(这个不急，后面做，只是罗列出来，免得忘记)2019-3-7~12今日学习完成情况类别学习内容大致描述大概用时 Linux Python 机器学习 其他内容这段时间情况总结：这段时间主要是去重庆玩了一趟每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：准备学习师兄布置的新任务完成linux-comm命令、diff命令以及cmp命令学习2019-3-13今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令cmp-比较文件差异1小时 Python 机器学习 其他内容学会了转载其他博客的方法包括CSDN、博客园、其他自建博客以及简书博客等2小时今日学习情况总结：今天主要是在上课（一下午）；晚上学习了转载其他博客的方法以及完成了之前剩下的一些cmp-比较文件差异学习的小尾巴每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：学习pv命令，完善cmp命令和pv命令相应的文章学习完成diff命令，比较comm、cmp、diff区别和联系完成师兄布置的任务学习if条件测试分支结构2019-3-14今日学习完成情况类别学习内容大致描述大概用时 Linux常用基本命令、shell编程diff-比较文件差异、if条件测试分支结构5小时 Python 机器学习 其他内容今日学习情况总结：今天主要学习了diff命令，了解了diff、cmp、comm命令之间的差别；也完成了对if条件测试分支结构的学习，发现鸟叔的linux私房菜好像确实写的不错，后面可以多看看。每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：学习pv命令，完善cmp命令和pv命令相应的文章学习循环结构完成师兄布置的任务2019-3-15今日学习完成情况类别学习内容大致描述大概用时 Linuxshell编程、其他常用内容总结完成了shell循环结构的学习、以及Linux通配符和正则表达式及其区别5小时 Python 机器学习 其他内容总结了HTML常用字符实体总结了HTML常用字符实体1个小时今日学习情况总结：今天主要学习了shell的循环结构，包括for、while、until循环，其中比较重要的是整理了各种循环的不同使用环境，同时循环控制结构的break和continue可以作用于多层循环给我留下了深刻的印象；在学习循环的过程中也涉及到了Linux通配符和正则表达式的区别，所以对其也进行了总结学习，了解了在不同的linux命令中如何选择正则表达式和通配符(在涉及到对文件名进行操作的linux命令中使用通配符，涉及到内容进行操作的linux命令中选择正则表达式—解决了我一直以来莫大的苦恼)；最后是在使用markdown进行表格插入的时候发现不能正常的插入竖线|，为了解决这个问题以及应对后续可能发生的问题，总结了HTML常见字符实体。每日学习之后不要忘了： 修改todo list 修改对应文章中的链接 在前一天对应的学习任务上画删除线明日学习哪些内容明日学习计划总览：学习pv命令，完善cmp命令和pv命令相应的文章完成数组的学习]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>每日总结和计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础语法]]></title>
    <url>%2Fposts%2F65136.html</url>
    <content type="text"><![CDATA[这篇文章总结markdown基础语法，便于后续查找和使用。另有一篇next-markdown技巧和模板总结了博客写作中常用的markdown技巧和模板，有些并不是原生的markdown语法，但是写作效果很好看，需要的时候可以查阅这个。markdown特性Markdown 的目标是实现易读易写兼容HTML，不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了，不过有一些标签需要特殊注意特殊字符转换：特殊字符如HTML中需要特殊处理的字符&lt;和&amp;，markdown会将其自动转化为&amp;lt; 和 &amp;amp;这种实体的形式（虽然在markdown中看不到，但是实际上在生成html时markdown自动将其转化为上述实体的形式），但是如果是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 不会对它做任何转换。附上HTML 中有用的字符实体在markdown使用HTML标签需要特殊注意的是 HTML 的区块元素，比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进;Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签HTML 区块标签间的 Markdown 格式语法将不会被处理，如&lt;p&gt;这是**一个**测试&lt;/p&gt;中一个不会加粗显示HTML 的行内标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用与处在 HTML 区块标签间不同，Markdown 语法在 HTML 行内标签间是有效的具体的HTML区块标签和行内标签有哪些，请参考这篇转载的文章基础语法区块元素换行和段落在markdown中进行换行操作：一行文本末尾增加两个以上的空格然后回车，如果只使用回车，不添加或者没加够空格看上去两行的文字会变为一行。markdown区分段落的关键是：这两行文字之间是否有空行，空行的定义是显示上看起来像是空的，便会被视为空行。比如，若某一行只包含空格和制表符，则该行也会被视为空行。如果这两行文字之间有空行，就代表这两行文字为两个段落，如果这两行文字之间没有空行，仅仅使用另个以上空格加回车进行换行，这两行文字仍旧是属于同一个段落。得到空行的方法：在上一行文本末尾加上两个以上空格然后回车，再加上&lt;br /&gt;即可两个段落之间有一个空行就可以证明其为两个段落，再多的空行也不会在html中渲染（上述添加&lt;br /&gt;制造空行的方式除外，增加几个&lt;br /&gt;就会有几个空行）。标题markdown依据#的数量，支持六级的标题，一个#代表一级标题，用于标题的#数目最多为6个，当数目大于6个时不再以标题的形式显现，如####### 7将直接显示为####### 7，而不是以标题的形式。当然也可以选择闭合标题的#，在标题之后加上若干数目的#，标题的级别是依据标题之前的#数目决定，和之后的#数目无关。如# 1 ##########还是代表的1级标题。区块引用 Blockquotesmarkdown使用&gt;进行引用段落内多行一同进行区块引用可以在每一行之前都加上&gt;，也可以进行偷懒，在整个段落的第一行加上&gt;引用一整行引用可以进行嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;这是一句引用这也是一个引用当然，这个还是一个引用使用blockquotes标签进行引用，可以修改文字颜色以及左边框颜色。1&lt;blockquote style="color:red;border-left: 3px solid #F44336;"&gt;使用blockquotes标签进行引用&lt;/blockquote&gt;效果如下：使用blockquotes标签进行引用引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等1234567&gt; #### 这是一个标题&gt; &gt; 1. 这是第一行列表项&gt; 2. 这是第二行列表项&gt; &gt; &lt;blockquote style="color:red;border-left: 3px solid #F44336;"&gt;使用blockquotes标签进行引用&lt;/blockquote&gt;&gt; **引用**结束列表markdown支持有序列表和无序列表。无序列表无序列表使用星号、加号或是减号作为列表标记。123* Red* Green* Blue等同于：123+ Red+ Green+ Blue也等同于：123- Red- Green- Blue有序列表有序列表则使用数字接着一个英文句点作为列表标记。值得注意的是有序列表中英文句号前面的数字并不重要，也就是说可以是完全相同或者不连续的数字，这些都不会影响最终解析得到的html信息，得到的结果都是相同的。1231. Bird2. McHale3. Parish等同于：1231. Bird1. McHale1. Parish多级列表多级列表的产生：先得到一级列表，然后使用tab键将后续的列表依次缩进即可得到多级列表。123* this is a test * this is a test * this is a test最终效果：this is a testthis is a testthis is a test包含段落的列表列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符。段落的每一行都可以进行缩进：1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing.效果如下：This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing.当然也支持只对段落首行进行缩进，和上面的段落每行都缩进结果是一样的：1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list.包含引用的列表如果要在列表项目内放进引用，那 &gt; 就需要缩进：1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item.效果如下：A list item with a blockquote:This is a blockquoteinside a list item.包含代码块的列表如果要放代码块的话，该代码块就需要缩进两次，也就是 8 个空格或是 2 个制表符：123* 一列表项包含一个列表区块： &lt;代码写在这&gt;如果在行首出现数字-句点-空白，可能会误认为是有序列表，要避免这样的状况，你可以在句点前面加上反斜杠，如1986. What a great season.标记后面最少有一个空格或制表符必须和前后文本存在空行，不然列表可能不能正确解析以及后面的文本可能出现偏移。表格使用markdown原生的方式插入表格1234| 一个普通标题 | 一个普通标题 | 一个普通标题 || ------ | ------ | ------ || *短文本* | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 |效果如下：一个普通标题一个普通标题一个普通标题短文本中等文本稍微长一点的文本稍微长一点的文本短文本中等文本表格的语句上一行必须为空行，不然表格不生效;内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;-的数量至少有一个;|、-、:之间的多余空格会被忽略，不影响布局;表格内容中可以套用其他用法，如加粗、斜体等；直接在markdown原生表格之前添加html样式（style）也可以对表格样式进行修改。设置表格宽度自适应解决了按照第一列表头宽度进行自适应的问题：12345&lt;style&gt;table th:first-of-type &#123; width: 100px;&#125;&lt;/style&gt;为每一列单独设置宽度：12345678&lt;table&gt; &lt;tr&gt; &lt;th width=10%&gt;第一列&lt;/th&gt; &lt;th width=35%&gt;第二列&lt;/th&gt; &lt;th width=45%&gt;第三列&lt;/th&gt; &lt;th width=10%&gt;第四列&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;第一列占整个表格宽度的10%、第二列占35%、第三列占45%、第四列占10%。th:first-of-type 的意思是每个 &lt;th&gt; 为其父级的第一个元素，就是指第一列的表头，同理第二、三个使用 th:nth-of-type(2)、th:nth-of-type(3)修改表头的宽度表头对应的列的宽度也就得到了修改这里有一篇关于markdown表格样式优化的文章，包括鼠标悬停变色、表格滚动条、隔行变色、表头不换行和首列不换行等优化excel也能导出html，先在excel中创建表格，然后保存为html，最后复制其中的表格，参考文章表格对齐问题-:表示内容和标题栏居右对齐；:-表示内容和标题栏居左对齐；:-:表示内容和标题栏居中对齐；1234| 一个普通标题 | 一个普通标题 | 一个普通标题 || :------ | :------: | ------: || *短文本* | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 |效果如下：一个普通标题一个普通标题一个普通标题短文本中等文本稍微长一点的文本稍微长一点的文本短文本中等文本使用html插入表格上述markdown原生的方法只能创建一些简单的表格，如果想创建复杂的表格，如合并单元格、调整表格颜色等就需要直接使用html进行创建表格。实现合并单元格：1234567891011121314151617181920&lt;table&gt; &lt;tr&gt; &lt;th&gt;项目1&lt;/th&gt; &lt;th&gt;项目2&lt;/th&gt; &lt;th&gt;项目3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a1&lt;/td&gt; &lt;td colspan="2"&gt;a2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;b1&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;b3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c2&lt;/td&gt; &lt;td&gt;c3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;最终效果：项目1项目2项目3a1a2b1b2b3c2c3table标签：定义 HTML 表格tr 元素定义表格行th 元素定义表头td 元素定义表格单元td标签下的colspan（跨列-合并一行的多列）及rowspan（跨行-合并一列的多行）属性进行单元格的合并。使用html插入表格需要注意空行markdown在处理上述的表格时会产生大量的空行，除非将整个表格写成一行，不然空行的书目和整个html代码占的行数相同，解决方法是加上escape标签，将整个table套起来。12345678910111213141516171819202122&lt;escape&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;项目1&lt;/th&gt; &lt;th&gt;项目2&lt;/th&gt; &lt;th&gt;项目3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a1&lt;/td&gt; &lt;td colspan="2"&gt;a2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;b1&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;b3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c2&lt;/td&gt; &lt;td&gt;c3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/escape&gt;最终效果：项目1项目2项目3a1a2b1b2b3c2c3偷懒方法之直接复制html代码从上面html代码可以看出来写着比较麻烦，为了解决这个问题，这里有一个专门生成Latex、html、markdown、text、mediawiki支持的表格源码的网站，只需要选取相应的内容即可，还可以调整表格颜色，生成相应的css样式。生成表格源码的网站在markdown表格显示竖线在使用markdown表格时如果想要显示竖线，仅仅使用转义是不能成功的，需要使用HTML实体，竖线的HTML实体为&amp;#124;，一个竖线就使用一个&amp;#124;两个竖线就使用两个&amp;#124;&amp;#124;，使用HTML实体后，网页会自动将其显示为|，关于HTML中的常用字符实体请参考这篇文章代码块代码块有两种写法：使用反引号加代码语言种类，代码写完后面也跟三个相同的符号（这种方法最为常用）；第二种写法就是简单地缩进 4 个空格或是 1 个制表符就可以。123这是一个普通段落： 这是一个代码区块。需要和普通段落之间存在空行最后的三个反引号之后不能存在空格，不然会出错分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：1234567891011* * *********- - ----------------------------------------_____最终效果：使用带空格的星号、减号、底线建立空格线，空格线会粗一些。行内元素链接markdown支持两种形式的链接语法：行内式和参考式两种形式，一般行内式使用较为简单和普遍，所以这里就采用行内式的方式。链接的使用形式：1[an example](http://example.com/ "Title")最终效果：an example方括号内的文字（an example）表示链接作用的文字圆括号内部第一个是链接地址第二个是title：鼠标移到链接文字上显示的内容如果你是要链接到同样主机的资源，你可以使用相对路径：1See my [About](/about/) page for details.关于参考式链接:参考式的链接其实重点不在于它比较好写，而是它比较好读使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断具体关于参考是的讲解可以参考这篇文章。123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ "Google" [2]: http://search.yahoo.com/ "Yahoo Search" [3]: http://search.msn.com/ "MSN Search"最终效果：I get 10 times more traffic from Google than fromYahoo or MSN.强调斜体markdown使用星号*和底线_作为标记强调字词的符号，被*或 _ 包围的字词会被转成用 &lt;em&gt;标签包围，显示出斜体的效果。1这是关于*斜体*的测试最终效果：这是关于斜体的测试加粗markdown使用两个星号*和底线_作为标记强调字词的符号，被两个*或 _ 包围的字词会被转成用 &lt;strong&gt;（加粗显示）包围，显示出加粗的效果。1这是关于**加粗**的测试最终效果：这是关于加粗的测试斜体加粗使用以上的斜体和加粗叠加可以实现斜体和加粗的效果：1这是关于***斜体加粗***的测试最终效果：这是关于斜体的测试删除线要加删除线的文字左右分别用两个~~号包起来，这个也可以叠加斜体以及加粗标记。1这是关于~~删除线~~的测试最终效果：这是关于删除线的测试星号*和底线_与被包围的文字之间不能有空格，不然星号*和底线_就会被当成普通的字符显示如果想加入普通的星号*和底线_，你可以用反斜线，如行内代码行内插入代码，可以直接使用反引号（`）将代码包围起来即可。如&lt;div&gt; &lt;/div&gt;就是写成：1`&lt;div&gt; &lt;/div&gt;`行内代码中加入反引号：可以用多个反引号来开启和结束代码区段，同时起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：如 A backtick-delimited string in a code span: `foo`、三个反引号就是写成：1234`` `foo` ``# 三个反引号在hexo博客中显示可能会出问题`` ``` ``插入图片使用markdown语法插入图片：使用markdown插入图片与插入链接类似，也有两种方式：行内式和参考式，这里讲解的主要为行内式。关于参考式的用法可以参考链接参考式的用法。12345![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;&lt;center&gt;![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")&lt;/center&gt;最终效果：Optional title 是用来在鼠标移到图片上时显示的title使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别html代码插入图片针对使用markdown插入图片的缺点，使用html语句可以很好的解决123456&lt;!-- 使用img标签--&gt;&lt;img src="http://pn9abh3rj.bkt.clouddn.com/test.png" width = "300" height = "200" alt="图片名称" align=center /&gt;&lt;!-- 使用div标签包裹 --&gt;&lt;div align="center"&gt;&lt;img src="http://pn9abh3rj.bkt.clouddn.com/test.png" title="使用html插入图片" alt="图片名称" /&gt;&lt;/div&gt;最终效果：不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；推荐使用div标签包裹img标签。常见问题字符转义markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号常见错误原因集锦html块级元素上下没有空格，块级元素是指 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签列表与前后内容之间没有空格列表内容和标记之间没有空格换行操作只回车没有在上一行文本末尾增加两个以上空格停止引用需要和下一行文本空行（另起一段），不然也会被引用进去代码最后的` 之后不能存在空格，不然会将后面的内容也写入代码内强调，不管是加粗还是斜体，标记*或`不能与文本之间存在距离**，不然会失效，标记会显示成标记本身，即*或**`表格的语句上一行必须为空行，不然表格不生效参考链接markdown融合单元单元格问题Latex|html|markdown|text|mediawiki制作表格并得到相应源代码的利器Markdown 语法说明 (简体中文版)Markdown: Basics （快速入门）Markdown 基本语法Markdown-Chinese-Demo]]></content>
      <categories>
        <category>其他内容学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed-文本处理工具]]></title>
    <url>%2Fposts%2F1752.html</url>
    <content type="text"><![CDATA[sed处理文本，包括sed命令的基本格式、参数和命令说明、文本的替换、打印、删除、增加、插入以及其他常用的技巧（分组、传入参数、命令连用以及对文件进行读取和写入等）。sed简介sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，接着处理下一行，这样不断重复，直到文件末尾（和awk都是对文件和输入的每一行进行操作）。文件内容并没有改变，除非你使用重定向存储输出。sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。sed 用法sed 命令格式12345Usage: sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...sed [options] 'command' file(s)sed [options] -f scriptfile file(s)sed options说明参数完整参数说明-e script–expression=script以选项中的指定的script来处理输入的文本文件，直接在命令行模式上进行sed动作编辑，此为默认选项-f script–files=script以选项中的指定的script文件来处理输入的文本文件-i–in-place直接在原位修改原文件-n–quiet –silent仅显示script处理后的结果-V–version显示版本信息-h–help显示帮助sed command说明命令说明a在当前行下面插入文本。i在当前行上面插入文本。c把选定的行改为新的文本。d删除，删除选择的行D删除模板块的第一行s替换指定字符h拷贝模板块的内容到内存中的缓冲区H追加模板块的内容到内存中的缓冲区g获得内存缓冲区的内容，并替代当前模板块中文本G获得内存缓冲区的内容，并追加到当前模板块文本的后面l列表不能打印字符的清单n读取下一个输入行，用下一个命令处理新的行而不是第一个命令N追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码p打印模板块的行P打印模板块的第一行q退出sedb label分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾r file从file中读行t labelif分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾T label错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾w file写并追加模板块到file末尾W file写并追加模板块的第一行到file末尾!表示后面的命令对所有没有被选定的行发生作用=打印当前行号#把注释扩展到第一个换行符以前sed 正则匹配元字符集命令说明^匹配行开始，如：/^sed/匹配所有以sed开头的行。$匹配行结束，如：/sed$/匹配所有以sed结尾的行。.匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。*匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。[]匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。[^]匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。(..)匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。&amp;保存搜索字符用来替换其他字符，如s/love/&amp;/，love这成love。&lt;匹配单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。&gt;匹配单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。x{m}重复字符x，m次，如：/0{5}/匹配包含5个0的行。x{m,}重复字符x，至少m次，如：/0{5,}/匹配至少有5个0的行。x{m,n}重复字符x，至少m次，不多于n次，如：/0{5,10}/匹配5~10个0的行。sed 用法实例测试文件cat test.txtmy cat’s name is bettyThis is your dogmy dog’s name is frankThis is your fishmy fish’s name is georgeThis is your goatmy goat’s name is adam替换操作sed 替换标记table th:first-of-type{width:10%}命令说明g表示行内全面替换p表示打印行w表示把行写入一个文件x表示互换模板块中的文本和缓冲区中的文本y表示把一个字符翻译为另外的字符（但是不用于正则表达式）\1子串匹配标记&amp;已匹配字符串标记sed s 替换指定字符将每一行文本中的This替换为sub1234sed -e 's/is/are/' test.txt# 省略-esed 's/is/are/' test.txt输出结果：my cat’s name are bettyThare is your dogmy dog’s name are frankThare is your fishmy fareh’s name is georgeThare is your goatmy goat’s name are adamoption的默认就是-e，所以-e可以省略s命令：替换指定字符指的是每一行的第一个发生替换，第二个以及后续的不会发生替换只打印那些发生替换的行-n选项和p命令一起使用表示只打印那些发生替换的行-n选项:仅显示script处理后的结果p命令:打印模板块的行选项、命令、命令三者连用就是：打印处理后的模板块的行1sed -n 's/is/are/p' test.txt输出结果：my cat’s name are bettyThare is your dogmy dog’s name are frankThare is your fishmy fareh’s name is georgeThare is your goatmy goat’s name are adam全局替换g命令表示行内全面替换1sed 's/is/are/g' test.txt输出结果:my cat’s name are bettyThare are your dogmy dog’s name are frankThare are your farehmy fareh’s name are georgeThare are your goatmy goat’s name are adam注意与单独的s命令的结果对比命令s、命令g之间的顺序是固定的从第几处开始替换从第二处开始替换：1sed 's/is/are/2' test.txt输出结果:my cat’s name is bettyThis are your dogmy dog’s name is frankThis are your fishmy fish’s name are georgeThis are your goatmy goat’s name is adam数字后面可以接命令g或者命令p等从每行中第N除开始全局替换：g命令之前加上数字N，表示从第N处之后的匹配开始全局替换1sed 's/is/are/2g' test.txt输出结果：my cat’s name is bettyThis are your dogmy dog’s name is frankThis are your farehmy fish’s name are georgeThis are your goatmy goat’s name is adam从第二处（包括）开始，后面的所有匹配上的都被替换掉了以行为单位进行替换命令c：把选定的行改为新的文本将第2-5行的内容取代成为this is sub of line 2-512# c 和文字之间有没有空行都可以sed '2,5c this is sub of line 2-5' test.txt最终结果：my cat’s name is bettythis is sub of line 2-5my fish’s name is georgeThis is your goatmy goat’s name is adam替换为多行的内容，只需要通过\n进行文本的换行即可：1sed '2,5cthis is sub of line 2-5 \nthis is a second sub' test.txt最终结果：my cat’s name is bettythis is sub of line 2-5this is a second submy fish’s name is georgeThis is your goatmy goat’s name is adam原位修改文件选项i：在文件的原位修改，不在屏幕输出，如果-i后跟着suffix，则会产生备份文件，形式为原文件名suffix。命令g也可以替换为其他命令。1sed -i_suffix 's/is/are/g' test.txt输出结果：lstest.txttest.txt_suffixcat test.txtmy cat’s name are bettyThare are your dogmy dog’s name are frankThare are your farehmy fareh’s name are georgeThare are your goatmy goat’s name are adam定界符/命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符.1234# 使用冒号替代echo sksksksksksk | sed 's:sk:ma:4g'# 使用竖线替代echo sksksksksksk | sed 's|sk|ma|4g'输出结果：skskskmamamaskskskmamama定界符出现在样式内部时，需要进行转义或者直接更换定界符这个定界符个人感觉其实是用来作为正则匹配的，和awk用法相似1234# 转义echo '/usr/local/bin' |sed 's/\/usr/\/test/g'# 直接更换定界符echo '/usr/local/bin' |sed 's|/usr|/test|g'输出结果：/test/local/bin/test/local/bin已匹配字符串标记&amp;&amp;：已经匹配上的内容暂存在这个变量中，方便对已匹配内容进行处理正则表达式\w\+匹配每一个单词，使用[&amp;]替换它，&amp;对应之前所匹配到的单词：1echo this is a test line | sed 's/\w\+/[&amp;]/g'最终结果：echo test is a test line |sed &#39;s/\w\+/[&amp;]/g&#39;[test] [is] [a] [test] [line]从上面可以看出，这种方法主要是用来针对一次匹配多个字符串，然后对多个字符串进行分开处理，而不是使用相同的处理（如使用同一个字符替换）分组标记\1 、\2\1 、\2：表示正则匹配的分组1echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'最终结果：echo this is digit 7 in a number |sed &#39;s/digit \([0-9]\)/\1/&#39;this is 7 in a number命令中digit 7，被替换成7。样式匹配到的子串是7，\(..\)用于匹配子串，对于匹配到的第一个子串标记为\1，依此类推匹配到的第二个结果就是\2,例如：1echo aaa BBB | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'最终结果：echo aaa BBB | sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;BBB aaa括号需要进行转义传入变量-引用sed作为文本处理工具，可能经常需要传入变量来进行操作，这里提供了关于传入变量的方法，但是需要注意的是，如果表达式内部存在变量字符串，command的单引号就要变成双引号。123test="HELLO"echo "hello WORLD" |sed "s/hello/$test/"最终结果：echo &quot;hello WORLD&quot; |sed &quot;s/hello/$test/&quot;HELLO WORLD组合多个命令 ;命令组合在Linux中是非常常见的，一般是使用管道符，在sed命令中可以使用;分割命令，这种用法同样和awk使用非常相似。1sed '表达式' | sed '表达式'等价于：1sed '表达式; 表达式'多个命令连用 -e选项-e本就是sed的默认选项，用于说明使用的是command而不是文件命令形式，多个命令连用，注意是有前后顺序的连用，在连用的command之前加上-e即可。1sed -e '1,5d' -e 's/my/MY/' test.txt先删除test.txt文件中的第1、5行，输出删除的内容，然后对这两行进行将my替换为MY。最终结果：This is your goatMY goat’s name is adam这个方式进行命令的连用和上面使用分号;将不同命令连写的方式效果相同使用{}连用命令使用{}将需要连用的命令包围，并使用;将多个命令隔开1sed -n '/This/&#123;s/This/this/;n;p&#125;' test.txt最终结果：my dog’s name is frankmy fish’s name is georgemy goat’s name is adam命令n：当前匹配行的下一行选项n：仅显示script处理后的结果选定行的范围 ,(逗号)选取行的范围来对文本进行处理，可以使用在不同行之间加逗号,的方式打印从第5行开始到第一个包含以this开始的行之间的所有行：1sed -n '5,/^This/p' test.txt最终结果：sed -n ‘5,/^This/p’ test.txtmy fish’s name is georgeThis is your goat行的索引开始于1需要注意的是：是包含尾部的，5,7p是包含第七行的选取行号之后不仅仅可以用来做打印，还可以进行其他操作，具体见本文使用实战打印命令 p12345678910111213141516171819202122# 打印第3行sed -n '3p' test.txt# 打印第3-5行sed -n '3,5p' test.txt# 数字和正则表达式连用# 打印从第1行开始，第一次出现This结束之间的行（起始行固定，终止行第一次正则匹配位置）sed -n '1,/This/p' test.txt# 起始行固定，终止行第一次正则匹配位置sed -n "/my cat's name is betty/,/This/p" test.txt# 打印从第一次匹配到This的行到第3行，然后再输出所有匹配到This的行sed -n '/This/,3p' test.txt# 如果含有This的行在第1行之后，则打印所有含有This的行sed -n '/This/,1p' test.txt# 起始行和终止行都不固定，打印全文sed -n '/my/,/This/p' test.txt最终结果：sed -n &#39;3p&#39; test.txtmy dog’s name is franksed -n &#39;3,5p&#39; test.txtmy dog’s name is frankThis is your fishmy fish’s name is georgesed -n &#39;1,/This/p&#39; test.txtmy cat’s name is bettyThis is your dogsed -n &quot;/my cat&#39;s name is betty/,/This/p&quot; test.txtmy cat’s name is bettyThis is your dogsed -n &#39;/This/,3p&#39; test.txtThis is your dogmy dog’s name is frankThis is your fishThis is your goatsed -n &#39;/This/,1p&#39; test.txtThis is your dogThis is your fishThis is your goatsed -n &#39;/my/,/This/p&#39; test.txtmy cat’s name is bettyThis is your dogmy dog’s name is frankThis is your fishmy fish’s name is georgeThis is your goatmy goat’s name is adam使用打印命令p时需要注意，sed默认会打印出所有的行（命令d除外，只会打印保留下来的行），所以想要打印出特定修改过的行需要加上选项n，如果不加，匹配上的行会打印两遍使用正则表达式进行匹配打印时需要特别小心如果数字在前面，是从数字开始到第一次匹配到正则表达式的部分（1就是从1开始，3就是从3开始看后面第一次匹配的）如果数字在后面，正则表达式在前面，那么一定会将全文中包含正则表达式的全部输出，其他部分如果数字大于正则表达式第一次出现的行，则输出正则表达式第一次出现的行到数字之间的其他内容，如果数字小于正则表达式第一次出现的行，那就只会打印包含正则表达式的行。全文匹配正则表达式的输出以及正则表达式第一次出现的行到数字之间的其他内容输出如果前后都为正则表达式，则输出全文内容关于上述正则表达式我的理解：因为数字是完全确定的，开始和结束行都很确定，所以可以很明确输出想要的结果，但是如果是正则表达式的话，不是唯一的匹配结果（段落中有几行都可以匹配上），那么如果正则表达式在前，则不知道从第几行开始当起始行，所以如果数字大于第一个匹配位置所在的行，那么以第一个匹配位置所在的行为起始行到数字规定的终止行之间的行都会输出，同时起始行可能有很多（其他位置也有匹配），所以还会输出其他匹配位置作为开始，这时如果数字小于第二个匹配位置的话，就只会输出匹配正则表达式的行，同时如果数字大于第二个匹配位置，由于第一个匹配位置的输出已经包含第二个位置，所以不会再输出一遍第二个匹配位置到终止行的信息说了很多，总结一下：使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。匹配模式取反 ！打印除第一行和第二行之外的其他行：1sed -n '1,2!p' test.txt最终结果：sed -n &#39;1,2!p&#39; test.txtmy dog’s name is frankThis is your fishmy fish’s name is georgeThis is your goatmy goat’s name is adam显示行号 =1sed -n '/my/&#123;=;p&#125;' test.txt最终结果：sed -n &#39;/my/{=;p}&#39; test.txt1my cat’s name is betty3my dog’s name is frank5my fish’s name is george7my goat’s name is adam删除命令 d命令d：删除，删除选择的行删除空白行cat test2.txtmy cat’s name is bettythis is your this dogmy dog’s name is this frankthis is your fishmy fish’s name is this georgethis is your goatmy goat’s name is this adam1sed '/^$/d' test2.txt最终结果：my cat’s name is bettythis is your this dogmy dog’s name is this frankthis is your fishmy fish’s name is this georgethis is your goatmy goat’s name is this adam空白行的表示方法：^$ (开头和结尾之间的内容为空)删除含有固定单词的行&lt;：匹配单词的开始，注意需要转义&gt;：匹配单词的结束，注意需要转义1sed '/\&lt;This\&gt;/d' test.txtsed &#39;/\&lt;This\&gt;/d&#39; test.txtmy cat’s name is bettymy dog’s name is frankmy fish’s name is georgemy goat’s name is adam正则匹配删除-删除文件中所有以my开头的行1sed '/^my/d' test2.txt最终结果：this is your this dogthis is your fishthis is your goat从某一行开始删除1sed '2,$d' test2.txt最终结果：sed &#39;2,$d&#39; test2.txtmy cat’s name is betty最后一行：$首行不是^，直接使用1删除文件最后一行1sed '$d' test2.txt最终结果：my cat’s name is bettythis is your this dogmy dog’s name is this frankthis is your fishmy fish’s name is this georgethis is your goat最后一行：$可以发现前面删掉空行的操作没有影响原始文件，如果想修改原始文件，可以加上选项i写入文件 w命令在test.txt中所有包含my的行都被写入test2.txt里：1sed -n '/my/w test2.txt' test.txt最终结果：cat test2.txtmy cat’s name is bettymy dog’s name is frankmy fish’s name is georgemy goat’s name is adam从文件读入 r命令file里的内容被读进来，显示在与test.txt匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：cat test1.txtaaaaaaaa1sed '/my/r test1.txt' test.txt最终结果：my cat’s name is bettyaaaaaaaaaThis is your dogmy dog’s name is frankaaaaaaaaaThis is your fishmy fish’s name is georgeaaaaaaaaaThis is your goatmy goat’s name is adamaaaaaaaaa追加文件 a\追加与上述读取不同，虽然两者都是讲在匹配的行下增加文本信息，但是读取处理的是两个文件，追加处理的是一个文件和一行或多行文本。a后面的反斜杠可有可无1sed '/^my/a\this is a test line' test.txt最终效果：my cat’s name is bettythis is a test lineThis is your dogmy dog’s name is frankthis is a test lineThis is your fishmy fish’s name is georgethis is a test lineThis is your goatmy goat’s name is adamthis is a test line同样也可以通过追加操作也增加两行甚至多行内容：1sed '/^my/a\this is a test line \nthis is second line' test.txt通过使用\n进行换行操作来达到增加多行的目的最终结果：my cat’s name is bettythis is a test linethis is second lineThis is your dogmy dog’s name is frankthis is a test linethis is second lineThis is your fishmy fish’s name is georgethis is a test linethis is second lineThis is your goatmy goat’s name is adamthis is a test linethis is second line如果命令a之前什么都不加，表明给在每一行下都增加文本当然，a之前也可以是单纯的数字插入操作 i\插入操作和上述追加和读取操作都不同，插入是在匹配行的上面进行插入，而追加和读取是在匹配行的下方进行的追加，同时插入和追加操作都是针对单个文件和一行或多行文本。1sed '/^my/i\this is insert line' test.txtthis is insert linemy cat’s name is bettyThis is your dogthis is insert linemy dog’s name is frankThis is your fishthis is insert linemy fish’s name is georgeThis is your goatthis is insert linemy goat’s name is adam在匹配文本上方插入多行的操作与追加类似，都是使用\n换行1sed '/^my/i\this is insert line \nthis is second insert line' test.txt最终效果：this is insert linethis is second insert linemy cat’s name is bettyThis is your dogthis is insert linethis is second insert linemy dog’s name is frankThis is your fishthis is insert linethis is second insert linemy fish’s name is georgeThis is your goatthis is insert linethis is second insert linemy goat’s name is adam匹配行的下一行 n命令打印匹配字符串的下一行：12345# 下面这个写法会使得以my开头的行被打印两遍，是错误的sed '/my/&#123;n;p&#125;' test.txt# 正确的写法是仅显示script处理后的结果sed -n '/my/&#123;n;p&#125;' test.txt最终结果：sed -n &#39;/my/{n;p}&#39; test.txthhhh is your dogThis is your fishThis is your goat在原始test文件中增加了一行用于防止和普通的替换混淆如果my被匹配，则移动到匹配行的下一行，替换这一行的this为This,并打印该行：1234sed '/my/&#123;n;s/This/this/; &#125;' test.txt# 上述式子不等于sed '/my/n;s/This/this/' test.txt最终输出：my cat’s name is bettyhhhh is your dogThis is your dogmy dog’s name is frankthis is your fishmy fish’s name is georgethis is your goatmy goat’s name is adam不是以my为开头的下一行的This不会被替换为this注意花括号{}，不能丢掉使用grep、awk得到匹配行的下一行123grep -A 1 my test.txtsed -n '/my/&#123;n;p&#125;' test.txtawk '/my/&#123;getline; print&#125;' test.txt字符变换 y命令把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令：1sed '1,10y/abcde/ABCDE/' test.txt最终结果：my CAt’s nAmE is BEttyhhhh is your DogThis is your Dogmy Dog’s nAmE is frAnkThis is your fishmy fish’s nAmE is gEorgEThis is your goAtmy goAt’s nAmE is ADAm注意这个和普通的替换不同，替换是将abcde这个字符串进行替换为ABCDE字符串，而这里是将a、b、c、d、e变为大写；与通过已匹配字符串&amp;也不同，这个更为简单显示分隔符等详细信息 l命令如果想知道文件内容的具体分割符，以及其他不能打印的字符信息可以使用’l’命令：sed -n &#39;l&#39; test3.txttab\tsep\tend$blank sep end$adsfaaaaaaaaaaaaaaaaafdadfasdfasdfasdfasdfsaaavfcadsasd asda asafdafa\sd$每行显示30个字符（包括最后的\）:sed -n &#39;l30&#39; test3.txttab\tsep\tend$blank sep end$adsfaaaaaaaaaaaaaaaaafdadfasd\fasdfasdfasdfsaaavfcadsasd as\da asafdafasd$l命令用明确的形式显示模版空间的数据：以C-style的转义形式显示不能打印的字符(换行符、制表符等)和本身的\Char形式长的行将进行分割，以字符\结尾的行表示分割，以字符$结尾的行表示分割结束n指定显示行的长度，超过就进行分割；若为0表示不分割所有行；没有指定时就取命令行选项-l的设置，再没有就取默认值70。这是GNU的扩展功能打印奇数行或偶数行方法一：通过下一行（命令n）的方式打印奇数行：1sed -n 'p;n' test.txt最终结果：my cat’s name is bettyThis is your dogThis is your fishThis is your goat打印偶数行：1sed -n 'n;p' test.txt最终结果：hhhh is your dogmy dog’s name is frankmy fish’s name is georgemy goat’s name is adam命令n在前而p在后为打印偶数行命令p在前而n在后为打印奇数行命令n为当前匹配的下一行方法二：简单方法12345# 打印奇数行sed -n '1~2p' test.txt# 打印偶数行sed -n '2~2p' test.txt使用实战在开头添加start12# 主要里面的空格也是有用的sed 's/^/start /' test.txt最终效果：sed &#39;s/^/start /&#39; test.txtstart my cat’s name is bettystart This is your dogstart my dog’s name is frankstart This is your fishstart my fish’s name is georgestart This is your goatstart my goat’s name is adam在结尾增加end12# 主要里面的空格也是有用的sed 's/$/ END/' test.txt最终效果：sed &#39;s/$/ END/&#39; test.txtmy cat’s name is betty ENDThis is your dog ENDmy dog’s name is frank ENDThis is your fish ENDmy fish’s name is george ENDThis is your goat ENDmy goat’s name is adam END在前三行之前增加#号做注释1sed '1,3s/^/# /' test.txt最终结果：sed &#39;1,3s/^/# /&#39; test.txt# my cat’s name is betty# This is your dog# my dog’s name is frankThis is your fishmy fish’s name is georgeThis is your goatmy goat’s name is adam使用技巧及注意事项使用打印命令p时需要注意，sed默认会打印出所有的行（命令d除外，只会打印保留下来的行），所以想要打印出特定修改过的行需要加上选项n区分选项和命令的关系和书写相对位置（如选项和命令都有n，但是作用却不同）使用正则表达式进行匹配打印时需要特别小心，总结一下：使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。参考链接sed命令sed命令详解，很多关于实战的讲的很好！！！sed命令用法sed_and_awk，github上148星]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大致计划]]></title>
    <url>%2Fposts%2F18198.html</url>
    <content type="text"><![CDATA[对于想学习内容的大致实施计划，需要根据实际情况灵活更改。总体思路Linux的内容比较细小，可以使用零散的时间来学习；机器学习的内容需要学习的连贯性，需要大量时间学习和理解；Python学习还好，介于Linux和机器学习内容之间；其他内容的学习不是很急切，但是一些工具性的可以先学习，比如git以及markdown，时间需求不是很大；可以将Linux中比较大的内容和其他内容学习中比较小的内容搭配，比如sed命令和下面的markdown搭配这种；大块的内容比如机器学习和Python可以放在晚上10-1点半之间（每天3个小时）？这个还需要考虑；机器学习和Python学习的内容可以放在github上。Linux学习 一个常用命令的学习 总结一个常用内容 shell编程一个技巧Python学习 一个常用命令的学习 总结一个常用内容 shell编程一个技巧机器学习学习 一个常用命令的学习 总结一个常用内容 shell编程一个技巧其他内容学习 一个常用命令的学习 总结一个常用内容 shell编程一个技巧]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>每日学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他想学习的内容]]></title>
    <url>%2Fposts%2F49862.html</url>
    <content type="text"><![CDATA[其他想学习的内容汇总，包括Latex排版、git使用、readthedocs+mkdocs静态网站、markdown学习、docker学习以及snakemake等内容，如果遇到后续会持续添加。markdown学习&emsp;&emsp;在后面的学习中，我将尽可能使用markdown进行文档的编写，这样看着更加美观，所以有必要对齐进行完善的学习，同时在真正的语法与在博客中遇到的可能有所差别，所以这里的将主要关注一些基础的语法，其他在博客写作中常用的可以参考之前写的博客。markdown基础语法学习next-markdown技巧和模板git使用&emsp;&emsp;接触到github之后，git操作是经常需要使用的，所以对其进行学习非常有必要。Git教程-廖雪峰Pro GitLatex排版&emsp;&emsp;第一次真正见识到latex是看到清本大佬使用latex对课程论文进行排版以及数学公式编写，觉得非常牛逼，同时也反思了自己的本科经历，果然大佬就是大佬！啥也不说了学习吧。一份其实很短的 LaTeX 入门文档Markdown中输入数学公式及LaTex常用数学符号整理刘海洋-latex入门readthedocs+mkdocs静态网站&emsp;&emsp;在binbin师兄的带领下，也算是接触了一下readthedocs+mkdocs静态网站（写技术文档），感觉也挺好看的，可以用来展示自己使用markdown编写的一些文本，主要是指项目。mkdocs的官方网站好用的参考很好的教程mkdocs可用的拓展docker&emsp;&emsp;docker是开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。Docker——从入门到实践docker学习笔记snakemake&emsp;&emsp;snakemake是用来编写任务流程的工具。snakemake使用笔记snakemake-tutorial使用Snakemake搭建分析流程实例-binbin师兄写的]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>其他内容学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习计划]]></title>
    <url>%2Fposts%2F130.html</url>
    <content type="text"><![CDATA[需要学习的机器学习内容汇总，包括自己总结的学习路线、书本和视频内容学习、竞赛等实战项目、很好的博主和网站以及收藏的shell相关书本等相关内容。自己规划的学习路线第一阶段-经典课程学习&emsp;&emsp;我觉得可以先通过一些经典课程，比如吴恩达老师或者林轩田老师在Coursera上的课程视频来对机器学习有一个初步了解，并通过课程配套的编程习题来动手实现一下算法，来提升一些感性的认识。第二阶段-经典教材学习&emsp;&emsp;之后再选择一本经典教材，学习其中理论和算法的基础部分。同时也可以尝试把讲到的算法实现一下，这样将书本和实践结合起来的办法，我觉得比较有效，这个过程的学习可以与第一个阶段同时进行，学习经典的书本的时候参考视频可以加深理解，目前很多书本都有相应的视频学习课程。第三阶段-实战&emsp;&emsp;通过这两个阶段的学习，已经掌握了机器学习的基本原理，并且对常用的经典算法，如boosting, svm, logistic regression乃至neural network比较熟悉以后，就可以考虑做一个大的project, 例如尝试参加一个在线的数据科学竞赛，通过这样一个过程，可能就能真正体会到入门的感觉。第三阶段-提升&emsp;&emsp;借助一些比较经典的、但是也需要一些基础的书来进行提升阶段的学习。如果只是想在毕业之后能找到算法工程师的工作，《统计学习方法》、CS229、CS231N、《deep learning》这些书再加上leetcode、数据挖掘比赛、以及相关项目经验就已经足够课程与教材学习&emsp;&emsp;现在机器学习部分主要是想根据书本进行学习，同时借助相应的视频课程，也就是上面自己总结学习路线的第一个和第二个阶段。 《统计学习方法》（李航） 《机器学习》（周志华） ISL(An Introduction to Statistical Learning: with Applications in R) 机器学习Machine-Learning 《机器学习实战》 《机器学习实战：基于Scikit-Learn和TensorFlow》 机器学习基石、技法视频 吴恩达机器学习视频 ISL配套视频 上交张志华统计机器学习视频《统计学习方法》（李航）这本书比较精炼，基本上是把模型推导一遍然后给出一个很简单的例子帮助你理解（完整的解释与论证）。《统计学习方法》（李航）《机器学习》（周志华）比较简单，有些只是提及，并没有很好地解释和证明，更系统和全面一点；是偏教材的书籍，需要有人引导才能更好地使用。《机器学习》（周志华）ISL(An Introduction to Statistical Learning: with Applications in R)ESL的基础书，统计学习的入门书，通俗易懂；监督学习占了大部分篇幅，我觉得这本书最好的部分就是模型的讨论都围绕variance和bias的trade-off展开，还有就是对模型的整体性能。ISL(An Introduction to Statistical Learning: with Applications in R)机器学习Machine-Learninggithub上别人总结的学习路径，可以看看。机器学习Machine-Learning《机器学习实战》用最基本的pyton语法，从底层上让你构建代码；理论讲的不是很清楚不是很透彻《机器学习实战》《机器学习实战：基于Scikit-Learn和TensorFlow》评价较好《机器学习实战：基于Scikit-Learn和TensorFlow》机器学习基石、技法视频机器学习基石视频机器学习基技法视频吴恩达机器学习视频吴恩达机器学习视频ISL配套视频ISL配套视频上交张志华统计机器学习视频上交张志华统计机器学习视频机器学习实战项目好的项目&emsp;&emsp;搜集的好的机器学习项目 AI项目实战AI项目实战AI项目实战竞赛Kaggle“泰迪杯”数据挖掘挑战赛中国高校计算机大赛——大数据挑战赛Kesci 科赛AI Challenger 全球AI挑战赛datafountain-DF竞赛平台sas中国高校数据分析大赛统计建模大赛研究生数学建模竞赛深圳杯数学建模挑战赛电工杯数学建模竞赛名称时间范围所需时间“泰迪杯”数据挖掘挑战赛3.31 4.11 4.15差不多一个半月中国高校计算机大赛-大数据挑战赛5.26 7.25 8.20差不多三个月研究生数学建模竞赛9.10 9.13 9.15 9.19 9.20 9.21三天深圳杯数学建模挑战赛4.15 6.10 8月下旬不详电工杯数学建模5.23 5.25 5.28 7.15不详统计建模大赛5-6月不详sas中国高校数据分析大赛10.10不详竞赛对应的教程学习Kaggle Competition Past SolutionsKaggle入门，看这一篇就够了Kaggle比赛：Text Normalization for English银牌全程记录Kaggle 首战拿银总结House Prices: 比赛经验分享Kaggle泰坦尼克如何在 Kaggle 首战中进入前 10%大数据竞赛平台——Kaggle 入门篇Python机器学习kaggle案例DATA TRAIN | 数据分析学习计划可视化与可视分析优秀的博主和网站机器学习、深度学习各种资料，很完善Jupyter notebooks Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.各种资源的中文翻译人大机器学习笔记机器学习算法Python3机器学习机器学习、深度学习鹅厂大佬Scikit-learn使用总结收藏的机器学习相关书本和笔记李沐 动手学深度学习斯坦福机器学习笔记Sklearn 与 TensorFlow 机器学习实用指南Sklearn 与 TensorFlow 机器学习实用指南scikit-learn (sklearn) 官方文档中文版国科大机器学习课程&amp;机器学习笔记AiLearning: 机器学习 - MachineLearning - ML、深度学习 - DeepLearning - DL、自然语言处理 NLP机器学习算法機器學習：使用PythonNeural Networks and Deep Learning中文神经网络与深度学习另一个版本机器学习训练秘籍Algorithm_Interview_Notes-ChineseNotebooks for my “Deep Learning with TensorFlow 2 and Keras” course]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习计划]]></title>
    <url>%2Fposts%2F22463.html</url>
    <content type="text"><![CDATA[需要学习的Python内容汇总，包括面向对象、常用模块使用、其他技巧整理、常用工具整理、实战项目、优秀的博主和网站以及收藏的Python相关书本等相关内容。面向对象&emsp;&emsp;这个是我一直想要学习的内容，但是由于诸多原因还没能学习，所以把这个放在了Python学习的第一位。面向对象面向对象-网页收藏夹Python标准库vamei的博客博客博客常用模块使用&emsp;&emsp;这里是一些比较常用的模块的学习。 numpy-数组与矩阵运算 matplotlib-绘图 Seaborn-绘图 SciPy-科学计算 argparse-命令行选项与参数解析 Bokeh-交互式数据可视化 HDF5-大数据存储与读取 tqdm-显示运行进度条 logging-日志 glob-文件操作相关模块 os-处理文件和目录 sys-程序与python解释器的交互 rpy2-调用R语言 collections-内建的一个集合模块numpy-数组与矩阵运算numpy-数组与矩阵运算numpy-数组与矩阵运算matplotlib-绘图matplotlib-绘图Seaborn-绘图Seaborn-绘图SciPy-科学计算SciPy-科学计算argparse-命令行选项与参数解析argparse-命令行选项与参数解析Bokeh-交互式数据可视化Bokeh-交互式数据可视化HDF5-大数据存储与读取HDF5-大数据存储与读取tqdm-显示运行进度条tqdm-显示运行进度条logging-日志logging-日志glob-文件操作相关模块glob-文件操作相关模块os-处理文件和目录os-处理文件和目录sys-程序与python解释器的交互sys-程序与python解释器的交互rpy2-调用R语言rpy2-调用R语言rpy2-调用R语言collections-内建的一个集合模块collections-内建的一个集合模块其他技巧整理&emsp;&emsp;这部分内容虽然不是具体的模块，但是对他们的理解和应用对于Python的学习非常有益处。 main函数的理解 接入pipelinemain函数的理解接入pipeline接入pipeline接入pipeline常用工具整理jupyter notebookjupyter主题、插件、技巧、server搭建实战项目&emsp;&emsp;这部分是收集的一些实战项目，可以在学习的过程中穿插学习，巩固对知识的掌握 以撸代码的形式学习Python Python项目-w3cschool 电影分析-爬虫+可视化 12个Python实战项目教程 Python练手项目推荐 Python100例测试以撸代码的形式学习Python以撸代码的形式学习PythonPython项目-w3cschool以撸代码的形式学习Python电影分析-爬虫+可视化电影分析-爬虫+可视化12个Python实战项目教程12个Python实战项目教程Python练手项目推荐Python练手项目推荐Python100例测试Python100例测试优秀的博主和网站廖雪峰Python数据之道收藏的Python相关书本Python之numpy教程Matplotlib用户指南类与对象编写高质量代码改善 Python 程序的 91 个建议Python 核心编程 第二版Python进阶Python数据结构与算法Python 数据科学入门教程Sklearn 与 TensorFlow 机器学习实用指南scikit-learn (sklearn) 官方文档中文版Scikit-learn 秘籍python数据分析与挖掘实战的代码笔记Python3网络爬虫开发实战Python 文本数据分析初学指南]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习计划]]></title>
    <url>%2Fposts%2F34794.html</url>
    <content type="text"><![CDATA[需要学习的Linux内容汇总，包括基本命令、其他一些常用的总结、shell编程、小技巧、其他博主的命令总结、很好的博主和网站以及收藏的shell相关书本等相关内容。常用基本命令&emsp;&emsp;这些命令是在工作和学习中常用的一些命令，有些我之前系统的学习过，但是学习的笔记都存放在我的印象笔记上，等有时间了会把这些笔记整理到这个博客上（回顾之前学习的内容），感觉博客上面记笔记会比较清爽，便于后期回顾学习，还没有系统学习过的命令后期都将直接呈现在这个博客上。下面列出了需要学习的常用命令，接下来将依据这个进行学习，同时在学习中遇到新的常用命令也会进行补充和完善，同时这一页主要是一个综括页，具体的每一个命令的学习笔记都将单独的页面展示，但是可以通过这个页面直接链接过去。 awk系列-强大的文本处理语言 find-搜索文件名 grep-搜索文件内容 sed-文本处理工具 sort-排序 uniq-去重 join-连接文本 cut-按列切分文件字段工具 comm-文件比较，文本文件的交集、差集与求差 cmp-文件比较命令 diff-文件比较命令 cat-显示、读取或拼接文件内容 wget-下载网站文件或网页 curl-命令行下的高级网络工具 nohup-不挂断地运行命令 打印输出 数据归档和解压缩 paste-按列合并文件 split-按大小分割文件 csplit-根据文本内容切割文件 scp-跨平台复制命令 shuf-随机打乱文件 seq-产生固定步长整数 ps-报告当前系统的进程状态 rsnyc-远程数据同步 xargs-将输入转换成命令行参数 read-从键盘或文件中获取标准输入 time-计算命令执行花费的时间 获取时间日期格式和延时 pv-命令执行的进度信息awk系列-强大的文本处理语言该系列包括13个小节，已经学习完毕 ，笔记都保存在印象笔记上。find-搜索文件名grep-搜索文件内容sed-文本处理工具sed-文本处理工具sort-排序sort-排序uniq-去重uniq-去重join-连接文本join-连接文本cut-按列切分文件字段工具cut-按列切分文件字段工具comm-文件比较，文本文件的交集、差集与求差comm-文件比较，文本文件的交集、差集与求差cmp-文件比较命令cmp-文件比较命令diff-文件比较命令diff-文件比较命令cat-显示、读取或拼接文件内容cat-显示、读取或拼接文件内容wget-下载网站文件或网页wget-下载网站文件或网页curl-命令行下的高级网络工具wget-下载网站文件或网页nohup-不挂断地运行命令nohup-不挂断地运行命令打印输出打印输出数据归档和解压缩数据归档和解压缩paste-按列合并文件paste-按列合并文件split-按大小分割文件split-按大小分割文件csplit-根据文本内容切割文件csplit-根据文本内容切割文件scp-跨平台复制命令scp-跨平台复制命令shuf-随机打乱文件shuf-随机打乱文件seq-产生固定步长整数seq-产生固定步长整数ps-报告当前系统的进程状态ps-报告当前系统的进程状态rsnyc-远程数据同步rsnyc-远程数据同步xargs-将输入转换成命令行参数xargs-将输入转换成命令行参数read-从键盘或文件中获取标准输入read-从键盘或文件中获取标准输入time-计算命令执行花费的时间time-计算命令执行花费的时间获取时间日期格式和延时获取时间日期格式和延时pv-命令执行的进度信息pv-命令执行的进度信息其他一些常用内容总结&emsp;&emsp;这些虽然不是具体的linux命令，但是在具体学习中页非常实用，所以有必要进行积累和整理。 Linux中特殊符号用法 浮点计算并保留小数 字符串截取方法 单行命令嵌套 输入输出重定向Linux中特殊符号用法Linux中特殊符号用法浮点计算并保留小数浮点计算并保留小数字符串截取方法字符串截取方法单行命令嵌套单行命令嵌套输入输出重定向输入输出重定向shell编程&emsp;&emsp;这一块平常接触没有那些常用命令那么频繁，但是也很多很实用（不用为了一个简单的目的去编写一个Python脚本），所以这里需要系统的学习一下。 传递参数 循环结构 if判断 数组 数学运算循环结构循环结构if判断if判断传递参数传递参数数组数组数学运算数学运算小技巧&emsp;&emsp;这里总结一下使用常用命令以及进行shell编程的一些常用小技巧。awk使用技巧awk使用技巧shell技巧-非shell脚本shell技巧-非shell脚本shell脚本技巧shell脚本技巧其他博主的命令总结&emsp;&emsp;其他优秀的博主整理的常用命令，可作为自查以及必要时查阅。97条 Linux 常用命令总结文件与目录基础自查很好的博主和网站大佬博客，讲解非常细致常用命令和shell总结、很完善查询各种linux命令，基本都有且分类清楚查询各种linux命令，基本都有其他博主的每日一个linux命令讲解以及实际问题代码收藏的shell相关书本鸟哥的Linux私房菜：基础学习篇高级Bash脚本编程指南Shell 编程范例shell脚本linux command line中文版]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-markdown技巧和模板-持续更新]]></title>
    <url>%2Fposts%2F37746.html</url>
    <content type="text"><![CDATA[博客中常用markdown的样式和模板markdown技巧分割线和空行1234&lt;hr /&gt;上面是分割线&lt;br /&gt;上面是空行上面是分割线上面是空行markdown引用以及html写法123&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;!-- 如果前后间隙很小，可以像下面这样写 --&gt;&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt;效果如下：引用内容引用内容居中和右对齐1234&lt;!-- 居中 --&gt;&lt;center&gt;内容&lt;/center&gt;&lt;!-- 右对齐 --&gt;&lt;div style="text-align:right"&gt;内容&lt;/div&gt;效果如下：内容内容字体大小和颜色123&lt;font color="#FF0000" size="8px"&gt;红色&lt;/font&gt;&lt;font color="#FFFF00" size="6px"&gt;黄色&lt;/font&gt;&lt;font color="#00FF00" size="4px"&gt;绿色&lt;/font&gt;效果如下：红色黄色绿色更多颜色请查看 web安全色、颜色对照表字体高亮显示使用mark标签进行标记，高亮显示文档中的文字12&lt;mark&gt;这是一个标记&lt;/mark&gt;使用mark标签进行标记，&lt;mark&gt;高亮显示&lt;/mark&gt;文档中的文字效果如下：使用mark标签进行标记，高亮显示文档中的文字插入表格1234| 一个普通标题 | 一个普通标题 | 一个普通标题 || ------ | ------ | ------ || *短文本* | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 |效果如下：一个普通标题一个普通标题一个普通标题短文本中等文本稍微长一点的文本稍微长一点的文本短文本中等文本表格的语句上一行必须为空行，不然表格不生效;内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;-的数量至少有一个;|、-、:之间的多余空格会被忽略，不影响布局;表格内容中可以套用其他用法，如加粗、斜体等。表格对齐问题-:表示内容和标题栏居右对齐；:-表示内容和标题栏居左对齐；:-:表示内容和标题栏居中对齐；1234| 一个普通标题 | 一个普通标题 | 一个普通标题 || :------ | :------: | ------: || *短文本* | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 |效果如下：一个普通标题一个普通标题一个普通标题短文本中等文本稍微长一点的文本稍微长一点的文本短文本中等文本合并单元格、修改表格样式Todo list1234&lt;ul&gt;&lt;li&gt;&lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成&lt;/li&gt;&lt;li&gt;&lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成&lt;/li&gt;&lt;/ul&gt;效果如下： 已完成 未完成Note 嵌套 Todo list123456789101112131415161718192021222324&lt;!-- 一共有两种写法，效果看下面 --&gt;&lt;div class="note primary"&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成&lt;/div&gt;&lt;div class="note primary"&gt; &lt;p&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;/p&gt;&lt;/div&gt;效果如下： 已完成 已完成 已完成 已完成 已完成 未完成 未完成 未完成 已完成 已完成 已完成 已完成 已完成 未完成 未完成 未完成插入代码代码块1&lt;!-- ```[language] [title] [url] [link-text] --&gt;注意前后都，上面演示如果后面加了会出错language表示代码语言title表示出现在代码框左上角的标题url表示超链接地址link-text表示超链接的名称这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加 [] 了，要这样写：[] [] [url] [link text] 个人只验证出可以加title，url和text没验证成功。效果如下：title1&lt;div&gt;&lt;/div&gt;各种支持语言的名称可以查看这篇文章行内代码1`test`Font Awesome放大图标的方法示例：123456&lt;i class="fa fa-download"&gt;&lt;/i&gt; 普通&lt;i class="fa fa-download fa-lg"&gt;&lt;/i&gt; 变大 33%&lt;i class="fa fa-download fa-2x"&gt;&lt;/i&gt; 两倍大#fa-fw：ensuring proper alignment of the icons&lt;i class="fa fa-download fa-fw"&gt;&lt;/i&gt; 图标和文字之间合适间距效果如下： 普通 变大 33% 两倍大 图标和文字之间合适间距fa-fw：ensuring proper alignment of the iconsnote标签next主题的note标签功能我一发现就爱上了，实在很好看啊~~~~首先该功能可以在next\_config.yml配置文件中进行配置，默认是打开的，但是可以挑选自己喜欢的模式。12345678910111213# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0我自己选择了其中的flat style，其用法如下：123456789101112131415&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt;&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt;&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt;&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt;&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;p&gt;danger&lt;/p&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&#123;% note danger %&#125;note danger, note danger, note dangernote danger, note danger, note dangernote danger, note danger, note danger&#123;% endnote %&#125;效果如下：defaultprimarysuccessinfowarningdangerdanger no-iconnote danger, note danger, note dangernote danger, note danger, note dangernote danger, note danger, note dangernext\_config.yml三种样式的具体情况请看网站label标签该标签也是在next\_config.yml配置文件中，默认是打开的123456* Usage:** &#123;% label [class] %&#125;Content&#123;% endlabel %&#125;** [class] : default | primary | success | info | warning | danger.* If not defined, default class will be selected.default1&#123;% label default@default %&#125;primary1&#123;% label primary@primary %&#125;success1&#123;% label success@success %&#125;info1&#123;% label info@info %&#125;warning1&#123;% label warning@warning %&#125;danger1&#123;% label danger@danger %&#125;12345Lorem &#123;% label @ipsum %&#125; &#123;% label primary@dolor sit %&#125; amet, consectetur &#123;% label success@adipiscing elit, %&#125; sed &#123;% label info@do eiusmod %&#125; tempor incididunt ut labore et dolore magna aliqua.Ut enim *&#123;% label warning @ad %&#125;* minim veniam, quis **&#123;% label danger @nostrud %&#125;** exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.Duis aute irure dolor in reprehenderit in voluptate ~~&#123;% label default @velit %&#125;~~ &lt;mark&gt;esse&lt;/mark&gt; cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.效果如下：Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.更多相关使用请看网站Tab 选项卡该标签也是在next\_config.yml配置文件中1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 3用法讲解：123456789101112131415161718192021222324tabs.js | global hexo script.Usage:&#123;% tabs [Unique name], [index] %&#125;&lt;!-- tab [Tab caption]@[icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;[Unique name] : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not defined, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. May be not defined.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. May be not defined.[icon] : Font awesome icon. May be not defined.设定选中第二个选项卡应用示例：1234567891011&#123;% tabs 选项卡, 2 %&#125;&lt;!-- tab --&gt;**这是选项卡 1** 呵呵哈哈哈哈哈哈&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 2** 额。。。&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3** 哇，你找到我了！&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：选项卡 1选项卡 2选项卡 3这是选项卡 1 呵呵哈哈哈哈哈哈这是选项卡 2 额。。。这是选项卡 3 哇，你找到我了！tabs 选项卡, 2：选项卡表示选项卡的名称，如果为tab，得到的选项卡显示为tab 1、tab 2、tab 3；2 表示一开始在第二个选项卡，非必须，若数值为 -1 则隐藏选项卡内容(也就是不显示呵呵哈哈哈哈哈哈这一些话，点击之后才会显示)。自定义每个选项卡的名称1234567891011&#123;% tabs Fourth unique name %&#125;&lt;!-- tab Solution 1 --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 2 --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 3 --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：Solution 1Solution 2Solution 3This is Tab 1.This is Tab 2.This is Tab 3.上面的solution 1、2、3即为自定义的，每个tab都可以设置自己的每个tab只显示图标1234567891011&#123;% tabs Fifth unique name %&#125;&lt;!-- tab @text-width --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab @amazon --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab @bold --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：This is Tab 1.This is Tab 2.This is Tab 3.上面的@amazon即为图标icon既显示图标有显示名称1234567891011&#123;% tabs Sixth unique name %&#125;&lt;!-- tab Solution 1@text-width --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 2@amazon --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 3@bold --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;效果如下：这个貌似会报错制作链接，快速访问多个tabs组参见网址tabs中套用其他标签12345678910111213141516171819202122232425262728293031323334353637383940&#123;% tabs Tags %&#125;&lt;!-- tab --&gt;**This is Tab 1.**1. One2. Two3. ThreeTabbed code block: nano /etc&#123;% code %&#125;code block tagcode block tagcode block tag&#123;% endcode %&#125;&#123;% note default %&#125;Note default tag.&#123;% endnote %&#125;&#123;% youtube A1Qb4zfurA8 %&#125;&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.*** Five* Six* Seven&#123;% note primary %&#125;&#123;% youtube rX3W5evpeJE %&#125;&#123;% endnote %&#125;&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&#123;% note success %&#125;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.&#123;% endnote %&#125;&lt;!-- endtab --&gt;&#123;% endtabs %&#125;最终效果：Tags 1Tags 2Tags 3This is Tab 1.OneTwoThreeTabbed code block:nano /etc 123code block tagcode block tagcode block tagNote default tag.This is Tab 2.FiveSixSevenThis is Tab 3.Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.按钮样式12345678# fa-lg：放大图标33%# fa-fw：图标和文字之间合理间距显示# download：图标的名称，fa-download，这里只写download即可&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;&lt;div class="text-center"&gt;&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;&lt;/div&gt;&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-rotate-90 %&#125;最终效果：更多关于按钮的使用点这里更多关于按钮的使用点这里更多关于按钮的使用点这里点击上面的按钮可以跳转到另一个网址，查看更过关于按钮的操作可以将其放在html语句中进行居中等各种操作btn后跟着点击按钮之后想访问的链接fa-lg：放大图标33%fa-fw：图标和文字之间合理间距显示fa-rotate-90：顺时针旋转90度download：图标的名称，fa-download，这里只写download即可插入照片因为图片功能在markdown语法中比较常用，所以将其单列出来，便于查找。使用七牛作为图床用法实例：123456&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;&lt;!-- 将其插入html语句中 --&gt;&lt;div align="right"&gt;&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;&lt;/div&gt;title：鼠标移到图片上显示的名称alt：图片不能正常加载时显示的说明文字extend:?imageView2/2/w/600 ：表示生成宽度最多600px的缩略图最终效果：好像会自动进行居中处理常规markdown语法12345![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;&lt;center&gt;![图片描述，相当于alt](http://pn9abh3rj.bkt.clouddn.com/test.png "Optional title，相当于title")&lt;/center&gt;最终效果：Optional title 是用来在鼠标移到图片上时显示的title使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别html代码插入图片针对使用markdown插入图片的缺点，使用html语句可以很好的解决123456&lt;!-- 使用img标签--&gt;&lt;img src="http://pn9abh3rj.bkt.clouddn.com/test.png" width = "300" height = "200" alt="图片名称" align=center /&gt;&lt;!-- 使用div标签包裹 --&gt;&lt;div align="center"&gt;&lt;img src="http://pn9abh3rj.bkt.clouddn.com/test.png" title="使用html插入图片" alt="图片名称" /&gt;&lt;/div&gt;最终效果：不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；推荐使用div标签包裹img标签。tips博客一般都以二级标题开始写起html代码如div标签后面一定要空行标签之间一般都是可以嵌套的插入图片推荐使用div标签包裹img标签实现写完一段记得空行！！！尽量每写完一段就空一行，尤其是代码段和文字之间，不然可能会出现markdown语法不能识别的情况（前面的错误可能导致后续很多语法都不能正常识别，在找错误的时候看第一个不能识别的位置）参考链接很详细很好的技巧文章也是很好的教程，可结合上一个看支持highlight的语言note、label、button、tab使用讲解及示例note、label、tab使用讲解及示例]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
