<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux系列之按文件类型统计空间占用</title>
      <link href="/posts/21373.html"/>
      <url>/posts/21373.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对实际问题-<strong>按照文件类型统计空间占用</strong>进行了实例学习，主要复习巩固了<strong>通配符和正则表达式的区别</strong>、<strong>awk数组和流程控制</strong>的使用，<strong>结合find的帮助文档学习了<code>-printf</code>参数以及<code>-exec</code>参数</strong>的使用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近想检查备份集群数据的备份情况，是不是都是只备份了某一种格式的文件，以及每种格式的文件占的空间大小，这种情况下单纯地使用du命令就不能解决问题，所以这里结合<a href="https://unix.stackexchange.com/questions/308846/how-to-find-total-filesize-grouped-by-extension" target="_blank" rel="noopener">How to find total filesize grouped by extension</a>中的高赞答案来学习一下。</p><hr><h2 id="命令和最终效果"><a href="#命令和最终效果" class="headerlink" title="命令和最终效果"></a>命令和最终效果</h2><p>命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span> |</span><br><span class="line">  awk -F . -v RS=<span class="string">'\0'</span> <span class="string">'</span></span><br><span class="line"><span class="string">    &#123;s[$NF] += $1; n[$NF]++&#125;</span></span><br><span class="line"><span class="string">    END &#123;for (e in s) printf "%15d %4d %s\n", s[e]*512, n[e], e&#125;'</span> |</span><br><span class="line">  sort -n</span><br></pre></td></tr></table></figure><p></p><p>最终结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      4096    1 cron</span><br><span class="line">      4096    1 cron2</span><br><span class="line">      4096    1 h</span><br><span class="line">      4096    1 json</span><br><span class="line">      4096    1 md5</span><br><span class="line">      4096    1 r</span><br><span class="line">      4096    1 tsv</span><br><span class="line">      8192    2 bai</span><br><span class="line">      8192    2 yml</span><br><span class="line">     12288    3 yaml</span><br><span class="line">     16384    3 cpp</span><br><span class="line">     28672    1 jpeg</span><br><span class="line">     32768    1 R</span><br><span class="line">    122880   12 py</span><br><span class="line">    122880   13 snakemake</span><br><span class="line">    155648   18 md</span><br><span class="line">    155648   31 sh</span><br><span class="line">   1544192    2 ipynb</span><br><span class="line">   7966720   41 txt</span><br><span class="line">  11456512   65 png</span><br><span class="line">  11685888    1 zip</span><br><span class="line">  36081664    1 out</span><br><span class="line"> 136515584    2 <span class="built_in">log</span></span><br><span class="line"> 542244864    2 <span class="built_in">test</span></span><br><span class="line">1084489728    4 filepart</span><br><span class="line">1941045248    5 bam</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><h3 id="通配符和正则表达式"><a href="#通配符和正则表达式" class="headerlink" title="通配符和正则表达式"></a>通配符和正则表达式</h3><p>首先需要注意的就是<strong>通配符和正则表达式的区别和使用</strong>，具体可以参考<a href="http://showteeth.tech/posts/37480.html">Linux通配符和正则表达式及其区别</a>。在这里<strong>使用的是<code>find</code>命令，对应的使用的就是通配符，而不是正则表达式</strong>，所以<code>-name &#39;?*.*&#39;</code>是正确的，<code>?</code>表示任意一个字符、<code>*</code>表示任意多个字符，而不是正则表达式中针对的是前一个字符的数目。</p><hr><h3 id="find的参数-printf"><a href="#find的参数-printf" class="headerlink" title="find的参数-printf"></a>find的参数-printf</h3><p>注意这里写的是<strong>find的参数-printf，而不是printf在find中的应用，两者有着本质的区别</strong>，前者说明这里的-printf是具有单独的用法的，而后者则说明是linux中格式化输出的语法使用。这也就涉及到其中<code>%s</code>、<code>%f</code>的用法不同了，在<a href="http://showteeth.tech/posts/47162.html">printf用法中</a>，<code>%f</code>表示浮点格式输出、<code>%b</code>表示开启转义模式(转义字符会被转义).</p><p>而在参数<code>-printf</code>用法中：</p><ul><li><code>%b</code>表示The amount of disk space used for this file in <strong>512-byte blocks</strong>. Since disk space is allocated in multiples of the filesystem block size, this is <strong>usually greater than %s/512, but it can also be smaller if the file is a sparse file.</strong></li><li><code>%f</code>表示仅输出文件名称。<strong>File’s name with any leading directories removed (only the last element).</strong></li></ul><p><mark>果然还是命令的帮助文档是最全面的！！！</mark></p><hr><h3 id="find命令的输出"><a href="#find命令的输出" class="headerlink" title="find命令的输出"></a>find命令的输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span></span><br><span class="line">  8.test1.txt8.test2.txt8.test3.txt8.test4.txt8.test5.txt16.test.txt16.merged.txt8.server.log8.test1.txt8.test2.txt8.test.txt8.shuf.txt8.test1.txt8.test2.txt8.test.sh8.test_t.sh8.test_s.sh8.n.sh8.u_1.sh8.u_2.sh8.u_3.sh8.test.txt8.u_4.sh8.i.sh8.test_2.sh8.a.sh8.d.sh8.e.sh8.test.txt8.test.txt529536.B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart8.test2.txt8.test.sh70472.nohup.out266624.test.log529536.B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br></pre></td></tr></table></figure><hr><h3 id="输出文件大小、文件数目、文件后缀"><a href="#输出文件大小、文件数目、文件后缀" class="headerlink" title="输出文件大小、文件数目、文件后缀"></a>输出文件大小、文件数目、文件后缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用awk的数组</span></span><br><span class="line"><span class="comment"># 将512-byte block转化为了4096-byte block的大小</span></span><br><span class="line"><span class="comment"># 控制了输出的位数15、4</span></span><br><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span> |</span><br><span class="line">  awk -F . -v RS=<span class="string">'\0'</span> <span class="string">'</span></span><br><span class="line"><span class="string">    &#123;s[$NF] += $1; n[$NF]++&#125;</span></span><br><span class="line"><span class="string">    END &#123;for (e in s) printf "%15d %4d %s\n", s[e]*512, n[e], e&#125;'</span> |</span><br><span class="line">  sort -n</span><br></pre></td></tr></table></figure><hr><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>需要改进的地方是不能转化为K、M、G、T这种形式，这里尝试改进一下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'?*.*'</span> -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%b.%f\0'</span> |</span><br><span class="line">  awk -F . -v RS=<span class="string">'\0'</span> <span class="string">'</span></span><br><span class="line"><span class="string">    &#123;s[$NF] += $1; n[$NF]++&#125;</span></span><br><span class="line"><span class="string">    END &#123;</span></span><br><span class="line"><span class="string">      for (e in s)</span></span><br><span class="line"><span class="string">        if(int(s[e]*512/1024/1024/1024/1024) &gt; 0)&#123;printf "%8.2fT %6d %s\n", s[e]*512/1024/1024/1024/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else if(int(s[e]*512/1024/1024/1024) &gt; 0)&#123;printf "%8.2fG %6d %s\n", s[e]*512/1024/1024/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else if(int(s[e]*512/1024/1024) &gt; 0)&#123;printf "%8.2fM %6d %s\n", s[e]*512/1024/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else if(int(s[e]*512/1024) &gt; 0)&#123;printf "%8.2fK %6d %s\n", s[e]*512/1024, n[e], e&#125;</span></span><br><span class="line"><span class="string">        else &#123;printf "%8fB %6d %s\n", s[e]*512, n[e], e&#125;</span></span><br><span class="line"><span class="string">        &#125;'</span> |</span><br><span class="line">  sort -hr</span><br></pre></td></tr></table></figure><p></p><p>效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  1.81G      5 bam</span><br><span class="line">  1.01G      4 filepart</span><br><span class="line">517.12M      2 <span class="built_in">test</span></span><br><span class="line">130.19M      2 <span class="built_in">log</span></span><br><span class="line"> 34.41M      1 out</span><br><span class="line"> 11.14M      1 zip</span><br><span class="line"> 10.93M     65 png</span><br><span class="line">  7.60M     41 txt</span><br><span class="line">  1.47M      2 ipynb</span><br><span class="line">152.00K     31 sh</span><br><span class="line">152.00K     18 md</span><br><span class="line">120.00K     13 snakemake</span><br><span class="line">120.00K     12 py</span><br><span class="line"> 32.00K      1 R</span><br><span class="line"> 28.00K      1 jpeg</span><br><span class="line"> 16.00K      3 cpp</span><br><span class="line"> 12.00K      3 yaml</span><br><span class="line">  8.00K      2 yml</span><br><span class="line">  8.00K      2 bai</span><br><span class="line">  4.00K      1 tsv</span><br><span class="line">  4.00K      1 r</span><br><span class="line">  4.00K      1 md5</span><br><span class="line">  4.00K      1 json</span><br><span class="line">  4.00K      1 h</span><br><span class="line">  4.00K      1 cron2</span><br><span class="line">  4.00K      1 cron</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="只统计某个后缀文件大小"><a href="#只统计某个后缀文件大小" class="headerlink" title="只统计某个后缀文件大小"></a>只统计某个后缀文件大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -name使用了通配符指定</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.bam'</span> -<span class="built_in">exec</span> du -ch &#123;&#125; +</span><br><span class="line">  717M./linux_learn/scp/LJ_mt_677_1_paired.bam</span><br><span class="line">  717M./linux_learn/pv/LJ_mt_677_1_paired.bam</span><br><span class="line">  210M./python_learn/pysam/chrM_no_gap.bam</span><br><span class="line">  209M./python_learn/pysam/chrM_no_gap_mapped.bam</span><br><span class="line">  8.0K./python_learn/pysam/with_gap.bam</span><br><span class="line">  1.9Gtotal</span><br></pre></td></tr></table></figure><p>需要注意的是这里的<code>-exec</code>参数的<code>+</code>，之前只知道<code>\;</code>，看了帮助文档才知道原来配合<code>-exec</code>参数使用的有<strong>两种模式</strong>：</p><ul><li><code>-exec command ;</code>：Execute command; true if 0 status is returned. <strong>All following arguments to find are taken to be arguments to the command until an argument consisting of ‘;’is encountered</strong>. The string ‘{}’ is replaced by the current file name being processed everywhere it occurs in the arguments to the command, not just in arguments where it is alone, as in some versions of find. <strong>Both of these constructions might need to be escaped (with a ‘\’) or quoted to protect them from expansion by the shell</strong>. The specified command is run once for each matched file. The command is executed in the starting directory. There are unavoidable security problems surrounding use of the -exec action; you should use the -execdir option instead.</li><li><code>-exec command {} +</code>：This variant of the -exec action runs the specified command on the selected files, <strong>but the command line is built by appending each selected file name at the end</strong>; <strong>the total number of invocations of the command will be much less than the number of matched files</strong>. The command line is built in much the same way that <code>xargs</code> builds its command lines. <strong>Only one instance of ‘{}’ is allowed within the command</strong>. The command is executed in the starting directory.</li><li><code>-execdir command ;</code>、<code>-execdir command {} +</code>：Like -exec, but <strong>the specified command is run from the subdirectory containing the matched file, which is not normally the directory in which you started find</strong>. This a much more secure method for invoking commands, as it avoids race conditions during resolution of the paths to the matched files. As with the -exec action, the ‘+’ form of -execdir will build a command line to process more than one matched file, but any given invocation of command will only list files that exist in the same subdirectory. If you use this option, you must ensure that your $PATH environment variable does not reference ‘.’; otherwise, an attacker can run any commands they like by leaving an appropriately-named file in a directory in which you will run -execdir. The same applies to having entries in $PATH which are empty or which are not absolute directory names.</li></ul><p><strong>使用上面的统计指定后缀文件大小的实例来巩固一下上面的内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加模式，也就是先把所有的文件找到，然后调用du命令一次</span></span><br><span class="line"><span class="comment"># 所以只会出现一个total</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.bam'</span> -<span class="built_in">exec</span> du -ch &#123;&#125; +</span><br><span class="line">  717M./linux_learn/scp/LJ_mt_677_1_paired.bam</span><br><span class="line">  717M./linux_learn/pv/LJ_mt_677_1_paired.bam</span><br><span class="line">  210M./python_learn/pysam/chrM_no_gap.bam</span><br><span class="line">  209M./python_learn/pysam/chrM_no_gap_mapped.bam</span><br><span class="line">  8.0K./python_learn/pysam/with_gap.bam</span><br><span class="line">  1.9Gtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规模式</span></span><br><span class="line"><span class="comment"># 每次找到一个后缀为bam的文件就统计其大小</span></span><br><span class="line"><span class="comment"># 所以每个文件对应于一个大小，同时并没有显示总大小</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.bam'</span> -<span class="built_in">exec</span> du -ch &#123;&#125; \;</span><br><span class="line">  717M./linux_learn/scp/LJ_mt_677_1_paired.bam</span><br><span class="line">  717Mtotal</span><br><span class="line">  717M./linux_learn/pv/LJ_mt_677_1_paired.bam</span><br><span class="line">  717Mtotal</span><br><span class="line">  210M./python_learn/pysam/chrM_no_gap.bam</span><br><span class="line">  210Mtotal</span><br><span class="line">  209M./python_learn/pysam/chrM_no_gap_mapped.bam</span><br><span class="line">  209Mtotal</span><br><span class="line">  8.0K./python_learn/pysam/with_gap.bam</span><br><span class="line">  8.0Ktotal</span><br></pre></td></tr></table></figure><p></p><p>为什么需要使用<code>\;</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止被解释为shell脚本的标点符号</span></span><br><span class="line"><span class="comment"># 不仅;需要加上\或者单引号来进行保护，&#123;&#125;也可以加上单引号</span></span><br><span class="line"><span class="comment"># Runs 'file' on every file in or below the current directory.  </span></span><br><span class="line"><span class="comment"># Notice that the braces are enclosed in single quote </span></span><br><span class="line"><span class="comment"># marks to protect them from interpretation as shell script punctuation.  </span></span><br><span class="line"><span class="comment"># The semicolon is similarly protected by the use of a backslash, </span></span><br><span class="line"><span class="comment"># though single quotes could have been used in that case also.</span></span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> file <span class="string">'&#123;&#125;'</span> \;</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/308846/how-to-find-total-filesize-grouped-by-extension" target="_blank" rel="noopener">How to find total filesize grouped by extension</a></li><li><a href="https://stackoverflow.com/questions/34971106/print-total-of-du-for-one-filetype-directory-is-not-flat" target="_blank" rel="noopener">print total of ‘du’ for one filetype, directory is not flat</a></li><li><a href="https://unix.stackexchange.com/questions/41550/find-the-total-size-of-certain-files-within-a-directory-branch" target="_blank" rel="noopener">Find the total size of certain files within a directory branch</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之没有root权限安装gcc</title>
      <link href="/posts/53937.html"/>
      <url>/posts/53937.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<strong>没有<code>root</code>权限</strong>条件下<strong>安装(升级)<code>gcc</code></strong>的步骤。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在安装一个软件的过程中出现了如下错误：</p><blockquote><p>cc1plus: error: unrecognized command line option “-std=c++11”</p></blockquote><p>仔细一查原来是集群的<code>gcc</code>版本太低，安装这个软件需要<code>4.7.X</code>版本：</p><blockquote><p>gcc (GCC) 4.4.6 20120305 (Red Hat 4.4.6-4)<br>Copyright (C) 2010 Free Software Foundation, Inc.<br>This is free software; see the source for copying conditions. There is NO<br>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p></blockquote><p>但自己没有<code>root</code>权限，所以不能直接使用<code>yum</code>这种命令来升级<code>gcc</code>，这里记录一下没有<code>root</code>权限如何解决这个问题。</p><hr><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><h3 id="下载gcc"><a href="#下载gcc" class="headerlink" title="下载gcc"></a>下载gcc</h3><p>可以从<a href="https://gcc.gnu.org/releases.html" target="_blank" rel="noopener">这个链接</a>查看<code>gcc</code>版本混合更新时间(才发现原来已经更新到<code>9.2</code>版本了)，具体的<a href="https://ftp.gnu.org/gnu/gcc/" target="_blank" rel="noopener">下载链接</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载对应的gcc版本</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf gcc-9.2.0.tar.gz</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>安装<code>gcc</code>需要先安装一些依赖的库：<code>GMP</code>、<code>MPFR</code> 和 <code>MPC</code>。安装这些依赖库可以按照常规地<a href="https://blog.csdn.net/qq_36573282/article/details/79762028" target="_blank" rel="noopener">下载源码安装</a>，但是三个包之间存在相互依赖，所以安装也有相应的顺序，而且不同的gcc版本还有不同的依赖库的版本，比较麻烦；<code>gcc</code>给出了下载这些依赖库的<a href="https://gcc.gnu.org/wiki/InstallingGCC" target="_blank" rel="noopener">简便命令</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="comment"># 必须要在gcc解压目录下运行，不能进入下一级目录</span></span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line">  <span class="comment"># 下载在当前目录下</span></span><br><span class="line">  2019-11-06 13:43:20 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2 [2383840] -&gt; <span class="string">"./gmp-6.1.0.tar.bz2"</span> [1]</span><br><span class="line">  2019-11-06 13:44:01 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2 [1279284] -&gt; <span class="string">"./mpfr-3.1.4.tar.bz2"</span> [1]</span><br><span class="line">  2019-11-06 13:44:28 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz [669925] -&gt; <span class="string">"./mpc-1.0.3.tar.gz"</span> [1]</span><br><span class="line">  2019-11-06 13:46:29 URL: ftp://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2 [1658291] -&gt; <span class="string">"./isl-0.18.tar.bz2"</span> [2]</span><br><span class="line">  gmp-6.1.0.tar.bz2: OK</span><br><span class="line">  mpfr-3.1.4.tar.bz2: OK</span><br><span class="line">  mpc-1.0.3.tar.gz: OK</span><br><span class="line">  isl-0.18.tar.bz2: OK</span><br><span class="line">  All prerequisites downloaded successfully.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="安装gcc-1"><a href="#安装gcc-1" class="headerlink" title="安装gcc"></a>安装gcc</h3><h4 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gcc-9.2.0/configure --prefix=`<span class="built_in">pwd</span>` --<span class="built_in">enable</span>-languages=c,c++,fortran,go</span><br></pre></td></tr></table></figure><p>出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误一：</span></span><br><span class="line">checking build system <span class="built_in">type</span>... config.guess: cannot create a temporary directory <span class="keyword">in</span> /800T/wangjb/tmp</span><br><span class="line">configure: error: cannot guess build <span class="built_in">type</span>; you must specify one</span><br><span class="line"><span class="comment">## 解决办法：在/800T/wangjb下创建tmp文件夹，当然也可以添加build选项(没有尝试过)</span></span><br><span class="line"><span class="comment">## 可能的原因是：在.bashrc文件中添加了export TEMP=/800T/wangjb/tmp、export TMPDIR=/800T/wangjb/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误二：</span></span><br><span class="line">configure: error: I suspect your system does not have 32-bit development libraries (libc and headers). If you have them, rerun configure with --<span class="built_in">enable</span>-multilib. If you <span class="keyword">do</span> not have them, and want to build a 64-bit-only compiler, rerun configure with --<span class="built_in">disable</span>-multilib.</span><br><span class="line"><span class="comment">## 解决办法：添加参数--disable-multilib</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译，开启4个线程</span></span><br><span class="line">make -j4</span><br><span class="line">  <span class="comment"># 可能出现如下warning</span></span><br><span class="line">  <span class="comment">## make[2]: warning:  Clock skew detected.  Your build may be incomplete.</span></span><br><span class="line">  <span class="comment">## make[2]: Leaving directory `/BioII/wangjb/usr/gcc/gotools'</span></span><br><span class="line">  <span class="comment">## make[1]: warning:  Clock skew detected.  Your build may be incomplete.</span></span><br><span class="line">  <span class="comment">## make[1]: Leaving directory `/BioII/wangjb/usr/gcc'</span></span><br><span class="line">  <span class="comment">## make: warning:  Clock skew detected.  Your build may be incomplete.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><hr><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>一定要确保安装路径在<code>$LD_LIBRARY_PATH</code>和<code>$PATH</code>之前，这样安装的程序才能<strong>取代之前系统默认的程序</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcc 9.2.0</span></span><br><span class="line"><span class="built_in">export</span> PATH=/BioII/wangjb/usr/gcc/bin:/BioII/wangjb/usr/gcc/lib64:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/BioII/wangjb/usr/gcc/lib/:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="重现安装软件"><a href="#重现安装软件" class="headerlink" title="重现安装软件"></a>重现安装软件</h2><p>在安装完成<code>gcc</code>以及将其写入环境变量之后，再次安装软件即可成功安装。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://gcc.gnu.org/wiki/InstallingGCC" target="_blank" rel="noopener">Installing GCC</a></li><li><a href="https://gcc.gnu.org/install/configure.html" target="_blank" rel="noopener">Installing GCC: Configuration</a></li><li><a href="http://www.xieqiang.site/2017/07/31/install-gcc-5.4-without-root/" target="_blank" rel="noopener">Linux下非root用户安装GCC 5.4</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之head命令</title>
      <link href="/posts/35269.html"/>
      <url>/posts/35269.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>Linux</code>中常用的命令<code>head</code>，主要学习了其<strong>输出文件的前多少字节</strong>的用法；同时也了解了文件大小单位中<code>K</code>和<code>KB</code>的区别，加<code>B</code>的如<code>KB</code>是以<code>1000</code>换算的，而不加<code>B</code>的如<code>K</code>是以<code>1024</code>换算的。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>head</code>命令是日常学习和工作中很常用的一个命令，但有时候越常使用的命令越容易忽视其一些非常重要的功能，比如今天想要学习的<strong>使用<code>head</code>来获取文件的前9M信息</strong>。</p><hr><h2 id="用法和参数"><a href="#用法和参数" class="headerlink" title="用法和参数"></a>用法和参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>-c, --bytes=[-][K|M|G]</code>: <strong>输出文件的前多少字节</strong>，如果前面增加了<code>-</code>表示从文档的最后获取信息。print the first K bytes of each file; with the leading ‘-‘, print all but the last K bytes of each file</li><li><code>-n, --lines=[-]K</code>: <strong>输出文件的前多少行</strong>，如果前面增加了<code>-</code>表示从文档的最后获取信息。print the first K lines instead of the first 10; with the leading ‘-‘, print all but the last K lines of each file</li><li><code>-v, --verbose</code>: <strong>输出文件名</strong>。always print headers giving file names</li><li><code>-q, --quiet, --silent</code>: <strong>不打印文件名</strong>。never print headers giving file names</li></ul><p><strong>关于单位</strong>：</p><blockquote><p>K may have a multiplier suffix: <code>b 512</code>, <code>kB 1000</code>, <code>K 1024</code>, <code>MB 1000*1000</code>, <code>M 1024*1024</code>, <code>GB 1000*1000*1000</code>, <code>G 1024*1024*1024</code>, and so on for <code>T</code>, <code>P</code>, <code>E</code>, <code>Z</code>, <code>Y</code>.</p></blockquote><hr><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规用法</span></span><br><span class="line">head -n 5 shuf.txt </span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件名称</span></span><br><span class="line">head -v -n 5 shuf.txt </span><br><span class="line">  ==&gt; shuf.txt &lt;==</span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定大小的文件</span></span><br><span class="line">head -c 10M user.storage &gt; user_10M.storage</span><br><span class="line">  -rw-rw-r-- 1 root root  10M Oct 31 16:33 user_10M.storage</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/head" target="_blank" rel="noopener">head(1) - Linux man page</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-字典</title>
      <link href="/posts/17760.html"/>
      <url>/posts/17760.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章对<code>Shell</code>中的<strong>字典(关联数组)</strong>进行了学习，主要包括<strong>字典的创建</strong>和<strong>字典的常用操作</strong>，其实<strong>字典的常用操作和数组基本相同</strong>，但<strong>字典可以使用字符串(key)作为索引来直接获取value</strong>，提高了效率。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天在写脚本的时候忽然发现<code>shell</code>可以支持<strong>字典(hash)</strong>操作了，不过好像只有<code>bash 4.X</code>的版本可以使用，还好自己平常使用的集群的<code>bash</code>都是<code>4.X</code>的，这里记录一下使用过程。</p><p>实际上这里所谓的字典其实是数组的一种，叫做<strong>关联数组(associative array)</strong>，我之所以将其称为字典(后续我都会称其为字典)是因为<strong>其和字典的用法基本一致</strong>，都是键值对的形式。</p><blockquote><p>Bash provides <code>one-dimensional</code> indexed and <code>associative array</code> variables.<br>Associative arrays are created using <code>declare -A</code> name.</p></blockquote><p>关于数组的使用可以回顾<a href="http://showteeth.tech/posts/46714.html">这个文章</a>。</p><hr><h2 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明一个名为color的字典</span></span><br><span class="line"><span class="comment"># 必须用-A才能创建关联数组(字典)，-a创建的是一般的数组</span></span><br><span class="line"><span class="built_in">declare</span> -A color</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值操作</span></span><br><span class="line"><span class="comment">## 赋值方式一：</span></span><br><span class="line">color[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">color[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">color[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line"><span class="comment">## 赋值方式二：</span></span><br><span class="line"><span class="comment">### 注意这里不需要在每个键值对后面添加,分割</span></span><br><span class="line">color=(</span><br><span class="line">  [<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">  [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">  [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">## 赋值方式三(声明的同时赋值)：</span></span><br><span class="line"><span class="built_in">declare</span> -A color=([<span class="string">"red"</span>]=<span class="string">"#ff0000"</span> [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span> [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="字典常见操作"><a href="#字典常见操作" class="headerlink" title="字典常见操作"></a>字典常见操作</h2><p>使用字典的初衷就是其访问值更加方便，可以直接<strong>通过键值去取对应的value</strong>，而<strong>不需要像传统数组一样去使用索引</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;color["blue"]&#125;</span></span><br><span class="line">  <span class="comment">#0000ff</span></span><br></pre></td></tr></table></figure><p></p><p><mark>如果键值key在字典中不存在，那么获取的返回值就是空值。</mark></p><p>只需要<strong>将这些的key值理解为传统数组中的索引</strong>，那么数组的使用就会方便许多：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数组所有元素，这个和传统数组基本相同</span></span><br><span class="line"><span class="comment"># 也可以使用 echo $&#123;color[@]&#125;</span></span><br><span class="line"><span class="comment"># 关于@和*之间的区别也是一样的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;color[*]&#125;</span></span><br><span class="line">  <span class="comment">#ff0000 #0000ff #00ff00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到数组所有的key值---对应于常规数组中的下标值</span></span><br><span class="line"><span class="comment"># 也可以使用 echo $&#123;!color[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[*]&#125;</span>  </span><br><span class="line">  red blue green</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典长度</span></span><br><span class="line"><span class="comment"># 也可以使用 echo $&#123;#color[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#color[@]&#125;</span></span><br><span class="line">  3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取value值的长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#color["red"]&#125;</span></span><br><span class="line">  7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">color[<span class="string">"white"</span>]=<span class="string">"#ffffff"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[*]&#125;</span></span><br><span class="line">  red blue white green</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时添加多个元素</span></span><br><span class="line"><span class="comment"># dic+=( ["key2"]=val2 ["key3"]=val3 )</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[@]&#125;</span></span><br><span class="line">  red blue white green</span><br><span class="line">color+=([<span class="string">"black"</span>]=<span class="string">"#000000"</span></span><br><span class="line">        [<span class="string">"purple"</span>]=<span class="string">"#7F00FF"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!color[@]&#125;</span></span><br><span class="line">  red blue white black green purple</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/bash" target="_blank" rel="noopener">bash(1) - Linux man page</a></li><li><a href="https://stackoverflow.com/questions/14370133/is-there-a-way-to-create-key-value-pairs-in-bash-script/23697848" target="_blank" rel="noopener">Is there a way to create key-value pairs in Bash script?</a></li><li><a href="https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash" target="_blank" rel="noopener">How to define hash tables in Bash?</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之定时执行任务发送邮件</title>
      <link href="/posts/6366.html"/>
      <url>/posts/6366.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇实战的文章，主要目的是<strong>定期统计集群存储使用情况并通过邮箱告知用户</strong>。其中涉及到的技术点主要有：<strong>定时任务的设置</strong>、<strong>集群邮件的发送</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室使用了学校的一个公共集群，上面的存储空间有限，一旦存储到达90%左右就不能继续运行任务，所以需要定期检查集群存储的使用情况，但是人工每次check很容易忘记，所以就想能不能使用定期检测的方式。总结来说，我的需求有两个：</p><ul><li>定期检测集群存储—<strong>定期执行任务</strong></li><li>给所有用户发邮件提醒各自账户的使用情况—<strong>发送邮件</strong></li></ul><hr><p><br></p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><h3 id="crontab简介"><a href="#crontab简介" class="headerlink" title="crontab简介"></a>crontab简介</h3><p><code>cron</code>是<code>Unix</code>、<code>Solaris</code>、<code>Linux</code>等系统下的可以<strong>自动在后台执行定时任务的工具</strong>，比如在某一天9点提醒你开会，某一天6点去给女票买礼物等等，这是由<strong>cron守护进程定期执行</strong>的。如果启用了 <code>cron</code>(一般默认启用), <code>cron</code> 守护进程会在系统启动后自动启动，并按时执行任务。 <code>cron</code>也能手动启用、关闭、重启等。</p><p><code>crontab(cron table)</code>是<code>cron</code>的<strong>任务库</strong>文件，它存储了<code>cron</code>要执行的计划任务项目。不同系统下该文件的位置可能不同，<code>centos</code>下是在<code>/var/spool/cron/</code>目录下，但是需要<code>root</code>权限才能访问。</p><p><code>crontab</code>也是一个<strong>命令</strong>，其用来<strong>创建、删除、查看当前用户（或者指定用户）的crontab文件</strong>。</p><hr><h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> crontab [options] file</span><br><span class="line"> crontab [options]</span><br><span class="line"> crontab -n [hostname]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -u &lt;user&gt;  define user</span><br><span class="line"> -e         edit user<span class="string">'s crontab</span></span><br><span class="line"><span class="string"> -l         list user'</span>s crontab</span><br><span class="line"> -r         delete user<span class="string">'s crontab</span></span><br><span class="line"><span class="string"> -i         prompt before deleting</span></span><br><span class="line"><span class="string"> -n &lt;host&gt;  set host in cluster to run users'</span> crontabs</span><br><span class="line"> -c         get host <span class="keyword">in</span> cluster to run users<span class="string">' crontabs</span></span><br><span class="line"><span class="string"> -s         selinux context</span></span><br><span class="line"><span class="string"> -x &lt;mask&gt;  enable debugging</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Default operation is replace, per 1003.2</span></span><br></pre></td></tr></table></figure><p>常用参数说明：</p><ul><li><code>file</code>：<code>file</code>是命令文件的名字,表示<strong>将<code>file</code>做为<code>crontab</code>的任务列表文件并载入<code>crontab</code></strong>。如果在命令行中没有指定这个文件，<code>crontab</code>命令将接受标准输入（键盘）上键入的命令，并将它们载入<code>crontab</code>。</li><li><code>-u</code>: 指定 <code>crontab</code> 的用户名, 此选项<strong>只能 <code>root</code>使用</strong></li><li><code>-e</code>: 编辑 <code>crontab</code> 文件，如果没有，会新建一个</li><li><code>-l</code>: 打印出 <code>crontab</code> 文件内容，列出计划任务</li><li><code>-r</code>: 移除 <code>crontab</code> 文件</li><li><code>-c</code>: 获取用户在集群上的 <code>crontabs</code></li></ul><hr><h3 id="crontab文件格式和定时规则"><a href="#crontab文件格式和定时规则" class="headerlink" title="crontab文件格式和定时规则"></a>crontab文件格式和定时规则</h3><p><code>crontab</code> 文件的格式可以查看<code>/etc/crontab</code>文件(也可以直接在其中添加命令作为系统的routine)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的shell</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line"><span class="comment"># 命令的查找路径，也就是环境变量</span></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"><span class="comment"># 如果出现错误，或者有数据输出，数据作为邮件发给这个帐号</span></span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="comment"># 使用者运行的路径,这里默认是根目录</span></span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现其主要有<strong>六个字段</strong>，具体来说就是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个字段之间使用空格分隔</span></span><br><span class="line">&#123;minute&#125; &#123;hour&#125; &#123;day-of-month&#125; &#123;month&#125; &#123;day-of-week&#125; &#123;full-path-to-shell-script&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中每个字段的具体说明：</p><ul><li><code>minute</code>：区间为<code>0–59</code>；</li><li><code>hour</code>：区间为<code>0–23</code>；</li><li><code>day-of-month</code>：区间为<code>0–31</code>；</li><li><code>month</code>：区间为<code>1–12</code>；1是1月，12是12月；</li><li><code>day-of-week</code>：区间为<code>0–6</code>，<strong>周日是0</strong>，这个不会影响到前面的<code>day-of-month</code>、<code>month</code></li></ul><p>除了数字还有以下<strong>几个特殊的符号</strong>需要特殊说明：</p><ul><li><code>*</code>：代表<strong>所有的取值范围内的数字，也就是任意数字</strong>；</li><li><code>/</code>：代表<strong>每</strong>的意思，<strong>”*/5″表示每5个单位</strong>；</li><li><code>-</code>：代表<strong>从某个数字到某个数字</strong>，<code>0 10-20 * * * command</code> 表示在每天 <code>10:00</code> 到 <code>20:00</code> 执行任务</li><li><code>,</code>：分开<strong>几个离散的数字</strong>，<code>0 3,6 * * * command</code> 表示在每天 <code>3:00</code>、<code>6:00</code> 执行任务</li></ul><hr><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><ul><li>第一步：进入<code>crontab</code>编辑模式：输入命令<code>crontab -e</code>，默认就是<code>vim</code>的编辑环境</li><li>第二步：编写定期规则，可以是<code>58 * * * * echo &quot;Good morning.&quot; &gt;/home/log.log</code>表示<strong>每小时的58分</strong>输出一次<code>Good morning.</code>到文件<code>/home/log.log</code>中</li><li>第三步：退出<code>vim</code>编辑环境，会显示<code>crontab: installing new crontab</code>，这时会在<code>/var/spool/cron</code>中生成对应用户名的文件，用于保存这个定时规则。需要注意的是<strong>每次重新执行<code>crontab -e</code>打开的都是同一个文件，不同的定时任务可以叠加处理</strong>。</li></ul><hr><h4 id="自定义文件"><a href="#自定义文件" class="headerlink" title="自定义文件"></a>自定义文件</h4><p>除了上述直接在编辑模式中编辑之外，还可以自定义文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim test.cron</span><br><span class="line">  58 * * * * <span class="built_in">echo</span> <span class="string">"Good morning."</span> &gt;/home/log2.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加定时任务</span></span><br><span class="line"><span class="comment">## crontab 刚刚新建的任务名</span></span><br><span class="line">crontab test.cron </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本</span></span><br><span class="line">crontab -l</span><br><span class="line">  58 * * * * <span class="built_in">echo</span> <span class="string">"Good morning."</span> &gt;/home/log2.log</span><br></pre></td></tr></table></figure><p></p><p><mark>需要注意的是：这里如果先后编辑两个文件，然后执行<code>crontab 文件名</code>，那么就会进行覆盖，也就是说最后执行的是最后一次编辑的内容。</mark></p><hr><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>有时我们创建了一个<code>crontab</code>，但是这个任务却<strong>无法自动执行</strong>，而<strong>手动执行这个任务却没有问题</strong>，这种情况<strong>一般是由于在<code>crontab</code>文件中没有配置环境变量引起的</strong>。</p><p>在<code>crontab</code>文件中定义多个调度任务时，需要特别注环境变量的设置，<strong>因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量</strong>，而<strong>系统自动执行任务调度时，是不会加载任何环境变量的</strong>，因此，就需要在<code>crontab</code>文件中<strong>指定任务运行所需的所有环境变量</strong>，这样，系统执行任务调度时就没有问题了。</p><p>不要假定<code>cron</code>知道所需要的特殊环境，它其实并不知道。所以你要保证在<code>shell</code>脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。</p><hr><h4 id="关闭邮件通知"><a href="#关闭邮件通知" class="headerlink" title="关闭邮件通知"></a>关闭邮件通知</h4><p><code>cron</code>默认会在执行一个<code>cronjob</code>后发送一封邮件的，如果执行任务勤了，会产生大量的邮件，为了避免这种情况，可以将输出重定向到一个日志文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;/home/log2.log</span></span><br><span class="line">58 * * * * <span class="built_in">echo</span> <span class="string">"Good morning."</span> &gt;/home/log2.log</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每1分钟执行一次myCommand</span></span><br><span class="line">* * * * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天早上6点执行一次myCommand</span></span><br><span class="line">0 6 * * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每两个小时执行一次myCommand</span></span><br><span class="line">0 */2 * * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔两天的上午8点到11点的第3和第15分钟执行一次myCommand</span></span><br><span class="line">3,15 8-11 */2 * * myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每周一上午8点到11点的第3和第15分钟执行一次myCommand</span></span><br><span class="line">3,15 8-11 * * 1 myCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定使用的shell</span></span><br><span class="line">0 1 30 * * /bin/sh command.sh</span><br></pre></td></tr></table></figure><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jellythink.com/archives/155" target="_blank" rel="noopener">Linux定时执行任务Crontab</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">crontab 定时任务</a></li><li><a href="https://amito.me/2018/Using-Crontab-in-Linux/" target="_blank" rel="noopener">在 Linux 中使用 Cron 执行定时任务</a></li></ul><hr><p><br></p><h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><h3 id="安装mailx"><a href="#安装mailx" class="headerlink" title="安装mailx"></a>安装mailx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">yum install mailx</span><br></pre></td></tr></table></figure><p>安装完成测试命令却<strong>出现如下错误</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mail</span><br><span class="line">  /var/spool/mail/username: Permission denied</span><br></pre></td></tr></table></figure><p></p><p>这种情况可能就是因为当前用户<code>username</code>并没有在mail这个group中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户所属组的信息</span></span><br><span class="line">groups</span><br><span class="line">  username vboxusers</span><br></pre></td></tr></table></figure><p></p><p>可以发现当前用户<code>username</code>并没有在mail这个group中，那么就直接添加即可，具体的命令可以查看<a href="http://showteeth.tech/posts/61241.html">这个链接</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">usermod -a -G mail username</span><br></pre></td></tr></table></figure><p></p><p><strong>再次测试</strong>即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mail -h</span><br><span class="line">  mail: option requires an argument -- h</span><br><span class="line">  Usage: mail -eiIUdEFntBDNHRVv~ -T FILE -u USER -h hops -r address -s SUBJECT -a FILE -q FILE -f FILE -A ACCOUNT -b USERS -c USERS -S OPTION users</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="发件"><a href="#发件" class="headerlink" title="发件"></a>发件</h3><p>安装完成之后就可以进行发件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v：显示执行过程</span></span><br><span class="line"><span class="comment"># -s：指定邮件的主题</span></span><br><span class="line">mail -v -s <span class="string">"test"</span> <span class="built_in">test</span>@163.com</span><br><span class="line">  <span class="comment"># 随意输入一段信息作为信件内容</span></span><br><span class="line">  <span class="comment"># 然后 ctrl + D 才会让新建发送出去</span></span><br><span class="line">  <span class="comment"># 新建发送的日志</span></span><br><span class="line">  Mail Delivery Status Report will be mailed to &lt;wangjb&gt;.</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：</p><ul><li>上述命令<strong>敲入命令行之后并没有执行发件操作</strong>，而是<strong>等待输入信件内容</strong>，随意输入一段信息作为信件内容，然后 <code>ctrl + D</code> 才会让新建发送出去。</li><li>默认的发件信息是<a href="mailto:`username@loginview03.localdomain" target="_blank" rel="noopener">`username@loginview03.localdomain</a>`，其组成为：<strong>用户名@发送邮件的节点名称.localdomain</strong></li><li>发件完成之后输入<code>mail</code>命令会出现<code>You have mail in /var/spool/mail/username</code>，这个是发件的日志文件</li></ul></div><hr><h3 id="配置发件信息"><a href="#配置发件信息" class="headerlink" title="配置发件信息"></a>配置发件信息</h3><p>如果<strong>不想使用默认的邮箱作为发件信箱(可能会会很多邮箱当成是垃圾邮件)</strong>，可以对发件信息进行设置，配置文件为<code>/etc/mail.rc</code>。</p><h4 id="单个发件邮箱"><a href="#单个发件邮箱" class="headerlink" title="单个发件邮箱"></a>单个发件邮箱</h4><p><strong>配置单个邮箱时</strong>具体修改信息如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mail.rc</span><br><span class="line">  <span class="comment"># 在文件的最后添加如下命令</span></span><br><span class="line">  <span class="built_in">set</span> from=123456@qq.com</span><br><span class="line">  <span class="built_in">set</span> smtp=smtp.qq.com  </span><br><span class="line">  <span class="built_in">set</span> smtp-auth-user=123456</span><br><span class="line">  <span class="built_in">set</span> smtp-auth-password=授权码</span><br><span class="line">  <span class="built_in">set</span> smtp-auth=login</span><br></pre></td></tr></table></figure><p></p><p>发件时和前面<a href="#%e5%8f%91%e4%bb%b6">发件步骤</a>命令相同。</p><p>如果是使用<code>qq</code>邮箱，那么密码就是授权码(登录第三方客户端时，密码框请输入“授权码”进行验证)，获取方式如下：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/linux_mail_qq.png" alt="linux_mail_qq.png"></p><hr><h4 id="配置多个发件邮箱"><a href="#配置多个发件邮箱" class="headerlink" title="配置多个发件邮箱"></a>配置多个发件邮箱</h4><p>如果想要配置<strong>多个发件邮箱</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">account qq &#123;</span><br><span class="line"><span class="built_in">set</span> from=123456@qq.com <span class="comment"># 对方收到邮件时显示的发件人</span></span><br><span class="line"><span class="built_in">set</span> smtp=smtp.qq.com <span class="comment"># 指定第三方发邮件的smtp服务器地址</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=123456 <span class="comment"># 第三方发邮件的用户名</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=授权码 <span class="comment"># 用户名对应的密码,有些邮箱填的是授权码</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth=login  <span class="comment"># SMTP的认证方式，默认是login，也可以改成CRAM-MD5或PLAIN方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">account gmail &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个时候发件操作就和前面的<a href="#%e5%8f%91%e4%bb%b6">发件步骤</a>命令有所差异：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -A：发件邮箱名称，前面定义的那个</span></span><br><span class="line">mail -v -s “主题” -A qq 收件人</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="邮件内容"><a href="#邮件内容" class="headerlink" title="邮件内容"></a>邮件内容</h3><p>邮件内容添加方式有三种：</p><ul><li><strong>命令行方式输入</strong>，这个在前面<a href="#%e5%8f%91%e4%bb%b6">发件步骤</a>已经用过了</li><li><strong>管道方式发送</strong>：<code>echo &quot;hey,how are you &quot; | mail -v -s &quot;test&quot; test@163.com</code></li><li><strong>借助重定向符进行输入</strong>：<code>mail -v -s &quot;test&quot; test@163.com &lt; test.txt</code></li></ul><hr><h3 id="添加附件"><a href="#添加附件" class="headerlink" title="添加附件"></a>添加附件</h3><p>添加附件使用<code>-a</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加附件</span></span><br><span class="line">mail -v -s “主题” -a 附件 收件人 </span><br><span class="line"><span class="comment"># 也可同时将文件内容作为正文</span></span><br><span class="line">mail -v -s “主题” -a 附件 收件人  &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>注意收件人的address在命令行的最后</strong>，不然可能会报错：<code>smtp-server: 501 Bad address syntax</code></p></div><hr><h3 id="正文和附件大小限制"><a href="#正文和附件大小限制" class="headerlink" title="正文和附件大小限制"></a>正文和附件大小限制</h3><p>Linux对发送的邮件以及附件大小存在限制，可以使用如下命令查看系统的限制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看正文大小限制</span></span><br><span class="line">postconf -d | grep message_size</span><br><span class="line">  <span class="comment"># 默认情况下都是10M的大小</span></span><br><span class="line">  message_size_limit = 10240000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看附件大小限制</span></span><br><span class="line">postconf -d | grep mailbox_size</span><br><span class="line">  <span class="comment"># 默认的大小是50M</span></span><br><span class="line">  mailbox_size_limit = 51200000</span><br></pre></td></tr></table></figure><p></p><p>因为大部分情况下使用的都是公有集群，所以这里就不写出修改默认设置的方法了。</p><hr><h3 id="发件端口"><a href="#发件端口" class="headerlink" title="发件端口"></a>发件端口</h3><p><code>mail</code>命令发送邮件默认使用<code>25</code>端口，也可以使用<code>587</code>、<code>465(ssl)</code>、<code>587</code>端口，<code>465</code>端口就是<strong>加密端口</strong>。平常一些服务器运营商会禁止使用<code>25</code>端口，使得用上面的配置则发送不去出，因此可以使用<code>587</code>端口。</p><p>设置使用<code>465</code>端口来发送邮件的<code>/etc/mail.rc</code>配置：<code>set smtp=smtps://smtp.qq.com:465</code></p><p>设置使用<code>587</code>端口来发送邮件的<code>/etc/mail.rc</code>配置：<code>set smtp=smtp.qq.com:587</code></p><hr><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>如果出现如果错误：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> certificate: Peer’s certificate issuer is not recognized.</span><br></pre></td></tr></table></figure><p></p><p>解决办法：<a href="https://www.wenjinyu.me/zh/mail-send-mail-through-the-command-line-in-linux/" target="_blank" rel="noopener">mail: 在linux上通过命令行发送邮件</a></p><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linux.die.net/man/1/mail" target="_blank" rel="noopener">mail(1) - Linux man page</a></li><li><a href="https://www.wenjinyu.me/zh/mail-send-mail-through-the-command-line-in-linux/" target="_blank" rel="noopener">mail: 在linux上通过命令行发送邮件</a></li><li><a href="https://cgspace.date/2017/08/30/linux/2017-08-30-linux-sendEmail/" target="_blank" rel="noopener">使用shell发送qq邮件</a></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/email-attachment-size-limit-734249/" target="_blank" rel="noopener">Email Attachment size limit</a></li></ul><hr><p><br></p><h2 id="设置定时任务-邮箱提醒"><a href="#设置定时任务-邮箱提醒" class="headerlink" title="设置定时任务+邮箱提醒"></a>设置定时任务+邮箱提醒</h2><p>OK，回到最原始的目的：</p><ul><li>定期检测集群存储—<strong>定期执行任务</strong></li><li>给所有用户发邮件提醒各自账户的使用情况—<strong>发送邮件</strong></li></ul><p>现在已经具备了所需的知识，那么就开始写脚本吧。</p><p>具体的脚本可以查看<a href="https://github.com/showteeth/useful_scripts" target="_blank" rel="noopener">Github</a></p><p>注意点：</p><ul><li><strong>正文大小和附件大小限制</strong>—解决办法：正文显示最大的前20个文件，附件添加不超过9M的文件(大于9M会其他前9M的信息)</li><li><strong>用户名和邮箱的对应</strong>—解决办法：使用了<a href="http://showteeth.tech/posts/17760.html">Shell中的字典</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Matplotlib-基础(二)</title>
      <link href="/posts/31747.html"/>
      <url>/posts/31747.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章是<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>的一个补充，从另一个<strong>更加贴合日常使用的角度</strong>理解<code>Matplotlib</code>中图片的元素，将元素分为<strong>基础(primitives)类</strong>和<strong>容器(containers)类</strong>，最后<strong>结合实例</strong>的方式来加深理解。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的文章<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>中已经对<code>Matplotlib</code>有了一个大概的认知：<strong>Python绘图系统中非常重要的模块，具有很强大的对图片进行自定义的功能</strong>，同时对其组件也有了一定的认识。这里会换个角度来认识一个图片中的所有元素。</p><p>前面我们将一个图片拆分为了<code>Figure</code>、<code>Axes</code>、<code>Axis</code>、<code>Artist</code>四大部分，虽然简洁，但是和平常绘图使用还是有一定的距离，尤其是最后的那个<code>Artist</code>，太过笼统和抽象。下面我们从另一种角度对图片中的元素进行分类，使其更加贴近我们的日常使用。总的来说，可以将一个图片拆分为<strong>两类元素</strong>：</p><ul><li><strong>基础 (primitives) 类</strong>：线 (<code>line</code>)、点 (<code>marker</code>)、文字 (<code>text</code>)、图例 (<code>legend</code>)、网格 (<code>grid</code>)、标题 (<code>title</code>)、图片 (<code>image</code>) 等。</li><li><strong>容器 (containers) 类</strong>：图 (<code>figure</code>)、坐标系 (<code>axes</code>)、坐标轴 (<code>axis</code>)和刻度 (<code>tick</code>)</li></ul><p>基础类元素是我们想画出的标准对象，而容器类元素顾名思义就是包含基础类元素的对象，基础类元素画在容器类元素之上。看了上述两类元素包含的对象和作用，有没有感觉非常熟悉，自己平常绘图的过程不就是在容器类元素中添加基础类元素嘛。</p><p><strong>这里主要学习容器类元素</strong>，原因有二：一是基础类元素纷繁复杂，种类较多，且相互之间没有联系，学着比较费劲；二是基础类元素是绘制在容器类元素之上的，在学习容器类元素的过程中就会涉及到基础类元素。</p><p>首先结合之前学习的内容，我们可以知道这里的容器类元素是有层级关系的：<strong>图 &gt; 坐标系 &gt; 坐标轴 &gt; 刻度</strong></p><hr><p><br></p><h2 id="图-Figure"><a href="#图-Figure" class="headerlink" title="图(Figure)"></a>图(Figure)</h2><p>之前已经对其有过介绍，所以这里主要集中在图(Figure)的容器类元素方面的内容.</p><h3 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Figure'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_with_text.png" alt="figure_with_text.png"></p><p>关于<code>plt.text()</code>：</p><ul><li><strong>第一、二个参数</strong>是指添加的<code>text</code>的横轴和纵轴坐标</li><li><strong>第三个参数</strong>是指要<code>text</code>显示的内容</li><li><code>ha, va</code>：是对齐方式，<code>horizontalalignment</code>、<code>verticalalignment</code></li><li><code>size</code>：设置字体大小</li><li><code>alpha</code>：设置字体透明度 (<code>0.5</code> 是半透明)</li></ul><hr><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">plt.figure()</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">im = np.array(Image.open(<span class="string">'Houston Rockets.png'</span>))</span><br><span class="line">plt.imshow(im)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_with_figure.png" alt="figure_with_figure.png"></p><hr><h3 id="添加线条"><a href="#添加线条" class="headerlink" title="添加线条"></a>添加线条</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.plot( [<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>] )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_with_line.png" alt="figure_with_line.png"></p><div class="note info"><p>前面这些操作看似是直接加在<code>figure</code>上，其实并不是，实际上上述各种操作都是在<code>Axes</code>上，而<code>Axes</code>又是被包含在<code>figure</code>中。默认情况下，一个<code>figure</code>中只有一个<code>Axes</code>，所以不需要在向<code>Axes</code>添加元素时进行显式声明，所以感觉就是直接在<code>figure</code>上操作，接下来我们来看看多个<code>Axes</code>的情况，这样就会对<code>figure</code>和<code>Axes</code>以及操作的具体界面有更进一步的了解。</p></div><hr><p><br></p><h2 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a>Axes</h2><p>首先说明一下关于<code>Axes</code>和<code>Subplot</code>的关系，两者都可以表示存在多个坐标系，但是存在细微的差别：</p><ul><li><strong>子图(Subplot)</strong>在<code>figure</code>中的网格结构<strong>一定是规则的</strong></li><li><strong>坐标系(Axes)</strong>在<code>figure</code>中的网格结构<strong>可以是不规则的</strong></li></ul><p>由此可见，<strong>子图是坐标系的一个特例，来我们先研究特例。</strong></p><h3 id="子图-Subplot"><a href="#子图-Subplot" class="headerlink" title="子图(Subplot)"></a>子图(Subplot)</h3><p><strong>子图有两种生成方式</strong>：</p><ul><li><code>plt.subplots(nrows=NUM,ncols=NUM)</code>：返回一个<code>NUM x NUM</code>的<strong>数组</strong>，在哪个子图上画图就将其调出来即可，相当于是<strong>先声明再调用</strong>。</li><li><code>plt.subplot(rows=NUM, columns=NUM, i-th plots)</code>：返回<strong>单个的子图</strong>，<strong>每次画子图之前先声明是哪个子图</strong>。</li></ul><h4 id="plt-subplots"><a href="#plt-subplots" class="headerlink" title="plt.subplots"></a>plt.subplots</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建4个坐标系，2行2列</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>)</span><br><span class="line">axes</span><br><span class="line">  <span class="comment"># 二维数组，每个元素表示一个坐标系</span></span><br><span class="line">  array([[&lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f2ac6630</span>&gt;,</span><br><span class="line">          &lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f2a2b9b0</span>&gt;],</span><br><span class="line">        [&lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f2766da0</span>&gt;,</span><br><span class="line">          &lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x7f30f288f390</span>&gt;]],</span><br><span class="line">        dtype=object)</span><br><span class="line"><span class="comment"># 以每个坐标系为单位添加文字</span></span><br><span class="line"><span class="keyword">for</span> i,ax <span class="keyword">in</span> enumerate(axes.flat):</span><br><span class="line">    ax.set(xticks=[],yticks=[])</span><br><span class="line">    s=<span class="string">'subplot(2,2,'</span> + str(i) + <span class="string">')'</span></span><br><span class="line">    ax.text(<span class="number">0.5</span>,<span class="number">0.5</span>,s,ha=<span class="string">"center"</span>,va=<span class="string">"center"</span>,size=<span class="number">20</span>,alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axes_add_subplots.png" alt="axes_add_subplots.png"></p><p>上面是例子是不是很明天可以看出层级关系了：<code>figure(fig)</code>包含四个<code>Axes(ax)</code>，具体的添加<code>text</code>是在<code>ax</code>上操作的。</p><hr><h4 id="plt-subplot"><a href="#plt-subplot" class="headerlink" title="plt.subplot"></a>plt.subplot</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2行1列figure的第一个子图</span></span><br><span class="line"><span class="comment"># 声明完子图后，下面所有代码就只在这幅子图上生效，直到声明下一幅子图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'subplot(2,1,1)'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 2行1列figure的第二个子图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'subplot(2,1,2)'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axes_add_subplot.png" alt="axes_add_subplot.png"></p><div class="note info"><p><code>plt.subplot</code>和<code>plt.subplots</code>还有一个区别是：<code>plt.subplots</code>会先把子图画出来(先形成<code>2x2</code>的子图)，即使只在其中一个子图上添加了基础类元素，最后显示的时候也会将所有的子图画出来；而<code>plt.subplot</code>因为是用时在声明，所以即使使用的是<code>plt.subplot(2,2,1)</code>，最后也只会显示出这个小子图，只是其大小是符合子图的对应比例的(长和宽都是<code>figure</code>的一半)。</p></div><hr><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p><strong>坐标系比子图更通用，布局更加随意</strong>，所以在某些需要对坐标系进行特殊排布的情况就非常实用，下面就是一个使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"><span class="comment"># 创建3x3的网格</span></span><br><span class="line">G=gridspec.GridSpec(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 第1行的所有网格作为第一个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">0</span>,:])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 1'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行除最后一列之外的所有部分作为第二个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">1</span>,:<span class="number">-1</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 2'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行和第3行的最后一列的网格作为第三个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">1</span>:,<span class="number">-1</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 3'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行第1列的网格作为第三个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">-1</span>,<span class="number">0</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 4'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br><span class="line"><span class="comment"># 第2行第2列的网格作为第三个Axes</span></span><br><span class="line">plt.subplot(G[<span class="number">-1</span>,<span class="number">-2</span>])</span><br><span class="line">plt.xticks([]);plt.yticks([])</span><br><span class="line">plt.text( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'Axes 5'</span>, ha=<span class="string">'center'</span>, </span><br><span class="line">          va=<span class="string">'center'</span>, size=<span class="number">20</span>, alpha=<span class="number">.5</span> )</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axes_add_gridspec.png" alt="axes_add_gridspec.png"></p><hr><p><br></p><h2 id="坐标轴和刻度"><a href="#坐标轴和刻度" class="headerlink" title="坐标轴和刻度"></a>坐标轴和刻度</h2><p>一个二维坐标系 (<code>Axes</code>)，有两条坐标轴 (<code>Axis</code>)：</p><ul><li>横轴：<code>X-Axis</code></li><li>纵轴：<code>Y-Axis</code></li></ul><p>而每个坐标轴都有两个元素:</p><ul><li><strong>容器类元素「刻度」</strong>：该对象里还包含<strong>刻度本身</strong>和<strong>刻度标签</strong></li><li><strong>基础类元素「标签」</strong>：该对象包含的是<strong>坐标轴标签</strong></li></ul><p><strong>「刻度」</strong> 和 <strong>「标签」</strong> 都是对象，下面代码通过改变它们一些属性值来进行可视化：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="comment"># 显示坐标轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">"Label on X-Axis"</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">"Label on Y-Axis"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改X轴的刻度标签</span></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.xaxis.get_ticklabels():</span><br><span class="line">    <span class="comment"># 设置刻度标签的字体颜色</span></span><br><span class="line">    label.set_color(<span class="string">"blue"</span>)</span><br><span class="line">    <span class="comment"># 设置刻度标签选择的角度</span></span><br><span class="line">    label.set_rotation(<span class="number">45</span>)</span><br><span class="line">    <span class="comment"># 设置刻度标签选择的字体大小</span></span><br><span class="line">    label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 设置刻度Y轴的刻度本身---刻度线</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ax.yaxis.get_ticklines():</span><br><span class="line">    <span class="comment"># 设置刻度线的颜色</span></span><br><span class="line">    line.set_color(<span class="string">"red"</span>)</span><br><span class="line">    <span class="comment"># 设置刻度线长度(凸出部分的长度)</span></span><br><span class="line">    line.set_markersize(<span class="number">30</span>)</span><br><span class="line">    <span class="comment"># 设置刻度线的宽度</span></span><br><span class="line">    line.set_markeredgewidth(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/axis_tick_add.png" alt="axis_tick_add.png"></p><hr><p><br></p><h2 id="关于图形选择"><a href="#关于图形选择" class="headerlink" title="关于图形选择"></a>关于图形选择</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/choosing_a_good_chart_en.png" alt="choosing_a_good_chart_en.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/choosing_a_good_chart_zh.png" alt="choosing_a_good_chart_zh.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&amp;mid=2247487597&amp;idx=2&amp;sn=e2a61c9637900d7bcb3fb658a28758a3&amp;chksm=fb39b566cc4e3c70fc6d06c5be5b962dee3e68ce66e51b03533db5cd9fd60cd0c51a64fb3d3f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1571474906951&amp;sharer_shareid=1b54e58f922202bb93a6ffe28bb2f3a7&amp;key=7fbd4d18e8fd1c6fff6d9c4f75a5f7a7aa84450f1bafdbddcb15955ec1c1602ad5b32e505be4f4262cb7c3a654ae46ad1f778ab74bfca91c73afbcc665063b69ce1f6fe3338b9a0ae66edf55bbfdbebc&amp;ascene=1&amp;uin=MjU2NzcxOTIxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060841&amp;lang=zh_CN&amp;pass_ticket=GwsbQV788IMD6AiagF%2BPxa50XmG0oazH9xqtxGhmt5vIPH0QkD3SChoH46%2Fsdj%2FX" target="_blank" rel="noopener">干货一文掌握Matplotlib的使用方法</a></li><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplots.html" target="_blank" rel="noopener">matplotlib.pyplot.subplots</a></li><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplot.html" target="_blank" rel="noopener">matplotlib.pyplot.subplot</a></li><li><a href="https://matplotlib.org/3.1.1/gallery/subplots_axes_and_figures/gridspec_multicolumn.html#sphx-glr-gallery-subplots-axes-and-figures-gridspec-multicolumn-py" target="_blank" rel="noopener">Using Gridspec to make multi-column/row subplot layouts</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘图系列-matplotlib中50个最常用的图</title>
      <link href="/posts/56749.html"/>
      <url>/posts/56749.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章对应于<a href="http://showteeth.tech/posts/59768.html">R绘图系列-ggplot2中50个最常用的图</a>，参考<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/" target="_blank" rel="noopener">Top 50 matplotlib Visualizations – The Master Plots (with full python code)</a>给出了matplotlib中最常用的50个图，这里mark一下，便于学习使用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这篇文章起源于<a href="http://showteeth.tech/posts/59768.html">R绘图系列-ggplot2中50个最常用的图</a>，这里对应于<code>ggplot2</code>中常用的50个图给出了<code>matplotlib</code>中常用的50个图，具体的参考文章是<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/" target="_blank" rel="noopener">Top 50 matplotlib Visualizations – The Master Plots (with full python code)</a>。</p><hr><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>因为这里所有的图都和ggplot2中的相对应的，所以就没有继续学习，后续如果使用的话可以结合<a href="http://showteeth.tech/posts/59768.html">R绘图系列-ggplot2中50个最常用的图</a>以及<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/" target="_blank" rel="noopener">Top 50 matplotlib Visualizations – The Master Plots (with full python code)</a>、中文译文：<a href="http://liyangbit.com/pythonvisualization/matplotlib-top-50-visualizations/" target="_blank" rel="noopener">深度好文 | Matplotlib可视化最有价值的 50 个图表（附完整 Python 源代码）</a>。</p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用图 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R绘图系列-ggplot2中50个最常用的图</title>
      <link href="/posts/59768.html"/>
      <url>/posts/59768.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章是从<a href="http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html" target="_blank" rel="noopener">Top 50 ggplot2 Visualizations - The Master List (With Full R Code)</a>选出了我自己<strong>之前比较少用，但是又挺有实际意义的图</strong>，这里记录学习一下。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天看到了这篇文章：<a href="http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html" target="_blank" rel="noopener">Top 50 ggplot2 Visualizations - The Master List (With Full R Code)</a>，感觉里面有些解释和有些图也挺实用的，这里mark一下并挑选几个进行学习。</p><hr><h2 id="整数散点图重叠"><a href="#整数散点图重叠" class="headerlink" title="整数散点图重叠"></a>整数散点图重叠</h2><p>散点图是绘图中很常用的一种图，其可以<strong>在很直观地显示变量之间相关关系的同时保留原始的数据特征</strong>。但是在对整数类型的数据进行散点图绘制中<strong>存在的问题</strong>是：<strong>数据点之间存在重叠，这样的话很多散点信息其实就被隐藏了(重叠的数据点在散点图上只表现为单个散点)</strong>。解决这种数据重叠的方法有两种：</p><ul><li><code>Jitter Plot</code>：给点<strong>增加扰动，使点与点之间分开</strong></li><li><code>Counts Chart</code>：点的<strong>大小表示数据点的密度</strong></li></ul><h3 id="Jitter-Plot"><a href="#Jitter-Plot" class="headerlink" title="Jitter Plot"></a>Jitter Plot</h3><p><strong>对每个点的位置添加了随机的变异</strong>.</p><blockquote><p>It adds a small amount of random variation to the location of each point, and is a useful way of handling overplotting caused by discreteness in smaller datasets.</p></blockquote><p>使用<code>geom_jitter</code>替换原始的<code>geom_point</code>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"><span class="comment"># 数据</span></span><br><span class="line">data(mpg, package=<span class="string">"ggplot2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主题背景</span></span><br><span class="line">theme_set(theme_bw())  <span class="comment"># pre-set the bw theme.</span></span><br><span class="line"><span class="comment"># 普通的散点图</span></span><br><span class="line">p1 &lt;- ggplot(mpg, aes(cty, hwy)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Scatterplot with overlapping points"</span>, </span><br><span class="line">       caption=<span class="string">"Source: midwest"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了jitter</span></span><br><span class="line">p2 &lt;- ggplot(mpg, aes(cty, hwy)) + </span><br><span class="line">  geom_jitter(width = <span class="number">0.5</span>) +</span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Jittered Points"</span>)   </span><br><span class="line">grid.arrange(p1,p2,nrow=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/top_50_jitter_R.png" alt="top_50_jitter_R.png"></p><p><code>jitter</code>图明显比原始的散点图点更多(扰动之后点分开了)。<strong><code>jitter</code>中<code>width</code>参数是控制点的离散程度的</strong>，<code>width</code>值越大，那么图中的点与原始点之间的距离就越大。</p><hr><h3 id="Counts-Chart"><a href="#Counts-Chart" class="headerlink" title="Counts Chart"></a>Counts Chart</h3><p>前面使用<code>jitter</code>解决整数数据散点图重叠有一个很大的问题就是<strong>改变了原始数据的值</strong>，虽然只是在原始点附近随机扰动，并不影响最终的结果，但这对于强迫症来说可能有点难受。这里给出另一种解决方案就是<strong>修改点的大小</strong>，如果多个点重叠在同一个位置，那么画的点就大一些，这样也能很好的区分。</p><p>使用<code>geom_count</code>替换<code>geom_point</code>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line">data(mpg, package=<span class="string">"ggplot2"</span>) </span><br><span class="line"><span class="comment"># 设置主题背景</span></span><br><span class="line">theme_set(theme_bw())  <span class="comment"># pre-set the bw theme.</span></span><br><span class="line"><span class="comment"># 原始的散点图</span></span><br><span class="line">p1 &lt;- ggplot(mpg, aes(cty, hwy)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Scatterplot with overlapping points"</span>, </span><br><span class="line">       caption=<span class="string">"Source: midwest"</span>)</span><br><span class="line"><span class="comment"># count chart</span></span><br><span class="line">p3 &lt;- ggplot(mpg, aes(cty, hwy)) +  </span><br><span class="line">  geom_count(col=<span class="string">"tomato3"</span>, show.legend=<span class="literal">F</span>) +</span><br><span class="line">  geom_smooth(method=<span class="string">"lm"</span>, se=<span class="literal">F</span>) +</span><br><span class="line">  labs(subtitle=<span class="string">"mpg: city vs highway mileage"</span>, </span><br><span class="line">       y=<span class="string">"hwy"</span>, </span><br><span class="line">       x=<span class="string">"cty"</span>, </span><br><span class="line">       title=<span class="string">"Counts Plot"</span>)</span><br><span class="line">grid.arrange(p1,p3,nrow=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/top_50_count_R.png" alt="top_50_count_R.png"></p><hr><h2 id="选中部分画圈"><a href="#选中部分画圈" class="headerlink" title="选中部分画圈"></a>选中部分画圈</h2><p>选中部分的数据点，在图中将其圈起来(使用多边形圈起来，不是圆或者椭圆)。这个可以<strong>适用于PCA选中不同群的点</strong>以及<strong>其他任意想要圈起来的</strong>。</p><p>这部分需要使用的是一个<code>ggplot2</code>插件：<a href="https://github.com/hrbrmstr/ggalt" target="_blank" rel="noopener">ggalt</a>。所谓插件的意思就是可以在原有ggplot2图形的基础上添加语法即可完成想要的图。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装proj</span></span><br><span class="line"><span class="comment"># 可以直接使用conda安装</span></span><br><span class="line">conda install -c conda-forge proj</span><br><span class="line"><span class="comment"># proj安装完成之后再安装ggalt</span></span><br><span class="line">install.packages(<span class="string">"ggalt"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="任意部分画圈"><a href="#任意部分画圈" class="headerlink" title="任意部分画圈"></a>任意部分画圈</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(ggalt)</span><br><span class="line"><span class="comment"># 得到选中的区域</span></span><br><span class="line">midwest_select &lt;- midwest[midwest$poptotal &gt; <span class="number">350000</span> &amp; </span><br><span class="line">                            midwest$poptotal &lt;= <span class="number">500000</span> &amp; </span><br><span class="line">                            midwest$area &gt; <span class="number">0.01</span> &amp; </span><br><span class="line">                            midwest$area &lt; <span class="number">0.1</span>, ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画多边形将上面选中的圈起来</span></span><br><span class="line">ggplot(midwest, aes(x=area, y=poptotal)) + </span><br><span class="line">  geom_point(aes(col=state, size=popdensity)) +   <span class="comment"># draw points</span></span><br><span class="line">  geom_smooth(method=<span class="string">"loess"</span>, se=<span class="literal">F</span>) + </span><br><span class="line">  xlim(c(<span class="number">0</span>, <span class="number">0.1</span>)) + </span><br><span class="line">  ylim(c(<span class="number">0</span>, <span class="number">500000</span>)) +   <span class="comment"># draw smoothing line</span></span><br><span class="line">  <span class="comment"># 这个是画多边形的</span></span><br><span class="line">  geom_encircle(aes(x=area, y=poptotal), </span><br><span class="line">                data=midwest_select, </span><br><span class="line">                color=<span class="string">"red"</span>, </span><br><span class="line">                size=<span class="number">2</span>, </span><br><span class="line">                expand=<span class="number">0.08</span>) +   <span class="comment"># encircle</span></span><br><span class="line">  labs(subtitle=<span class="string">"Area Vs Population"</span>, </span><br><span class="line">       y=<span class="string">"Population"</span>, </span><br><span class="line">       x=<span class="string">"Area"</span>, </span><br><span class="line">       title=<span class="string">"Scatterplot + Encircle"</span>, </span><br><span class="line">       caption=<span class="string">"Source: midwest"</span>)</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>expand</code>：画的多边形<strong>向外扩的大小</strong></li><li><code>color</code>：多边形<strong>圈的颜色</strong></li><li><code>size</code>：<strong>线的宽度</strong></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/scatter_circle.png" alt="scatter_circle.png"></p><hr><h3 id="PCA部分"><a href="#PCA部分" class="headerlink" title="PCA部分"></a>PCA部分</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(ggalt)</span><br><span class="line"><span class="keyword">library</span>(ggfortify)</span><br><span class="line">theme_set(theme_classic())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute data with principal components ------------------</span></span><br><span class="line">df &lt;- iris[c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line">pca_mod &lt;- prcomp(df)  <span class="comment"># compute principal components</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data frame of principal components ----------------------</span></span><br><span class="line">df_pc &lt;- data.frame(pca_mod$x, Species=iris$Species)  <span class="comment"># dataframe of principal components</span></span><br><span class="line">df_pc_vir &lt;- df_pc[df_pc$Species == <span class="string">"virginica"</span>, ]  <span class="comment"># df for 'virginica'</span></span><br><span class="line">df_pc_set &lt;- df_pc[df_pc$Species == <span class="string">"setosa"</span>, ]  <span class="comment"># df for 'setosa'</span></span><br><span class="line">df_pc_ver &lt;- df_pc[df_pc$Species == <span class="string">"versicolor"</span>, ]  <span class="comment"># df for 'versicolor'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot ----------------------------------------------------</span></span><br><span class="line">ggplot(df_pc, aes(PC1, PC2, col=Species)) + </span><br><span class="line">  geom_point(aes(shape=Species), size=<span class="number">2</span>) +   <span class="comment"># draw points</span></span><br><span class="line">  labs(title=<span class="string">"Iris Clustering"</span>, </span><br><span class="line">       subtitle=<span class="string">"With principal components PC1 and PC2 as X and Y axis"</span>,</span><br><span class="line">       caption=<span class="string">"Source: Iris"</span>) + </span><br><span class="line">  coord_cartesian(xlim = <span class="number">1.2</span> * c(min(df_pc$PC1), max(df_pc$PC1)), </span><br><span class="line">                  ylim = <span class="number">1.2</span> * c(min(df_pc$PC2), max(df_pc$PC2))) +   <span class="comment"># change axis limits</span></span><br><span class="line">  geom_encircle(data = df_pc_vir, aes(x=PC1, y=PC2)) +   <span class="comment"># draw circles</span></span><br><span class="line">  geom_encircle(data = df_pc_set, aes(x=PC1, y=PC2)) + </span><br><span class="line">  geom_encircle(data = df_pc_ver, aes(x=PC1, y=PC2))</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/pca_circle_ggplot.png" alt="pca_circle_ggplot.png"></p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他有意思的图如<strong>分组之间连线(Slope Chart)</strong>、<strong>哑铃图(Dumbbell Plot)</strong>，具体可以直接看原文：<a href="http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html" target="_blank" rel="noopener">Top 50 ggplot2 Visualizations - The Master List (With Full R Code)</a>，或者译文：<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODQ1MzQ0Mg==&amp;mid=2648661801&amp;idx=1&amp;sn=05cc8ff30e1e9831dc7163e0bc8beb38&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">50个ggplot2可视化案例</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用图 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘图系列-给boxplot添加统计性的注释</title>
      <link href="/posts/26853.html"/>
      <url>/posts/26853.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Python</code>中如何<strong>给<code>boxplot</code>添加两两之间比较的统计注释信息</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这篇文章起源于<a href="http://showteeth.tech/posts/40911.html">R绘图系列-带有significant信息的boxplot</a>，因为<code>R</code>中有可以对<code>boxplot</code>两两样本之间<strong>添加显著性注释</strong>的包，这里对应地记录一下<code>Python</code>中<strong>实现相同目的需要的包</strong>和<strong>基本命令</strong>。</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为该包没有发表在<code>Pypi</code>上，所以不可以直接使用<code>pip</code>安装，这里直接使用<code>setup.py</code>安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone到本地目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/webermarcolivier/statannot.git</span><br><span class="line"><span class="comment"># 如果没有权限将它安装到系统Python库中去，可以使用如下命令</span></span><br><span class="line"><span class="comment"># 会安装在~/.local/</span></span><br><span class="line">python setup.py install --user</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>特点</strong>：</p><ul><li>给由<code>seaborn boxplot</code>画出的<code>boxplot</code>添加<strong>统计注释</strong></li><li>内置的检验：<ul><li><code>Mann-Whitney</code>—<strong>非参检验(不要求正态分布)</strong></li><li><code>t-test (independent and paired)</code>—<strong>配对和不配对的t检验</strong></li><li><code>Welch&#39;s t-test</code>—<strong>方差不同情况下的t检验</strong></li></ul></li><li>可以控制统计注释在<strong>图内还是图外</strong>以及<strong>多个注释之间的间隔</strong></li><li>统计注释有三种格式：<ul><li><strong>star annotation</strong>：对应的参数<code>star</code>，这个是<strong>默认格式</strong>，<ul><li><code>ns</code>: 5.00e-02 &lt; p &lt;= 1.00e+00</li><li><code>*</code>: 1.00e-02 &lt; p &lt;= 5.00e-02</li><li><code>**</code>: 1.00e-03 &lt; p &lt;= 1.00e-02</li><li><code>***</code>: 1.00e-04 &lt; p &lt;= 1.00e-03</li><li><code>****</code>: p &lt;= 1.00e-04</li></ul></li><li><strong>simplified pvalue</strong>：对应的参数是<code>simple</code>，这个会<strong>直接显示pvalue数值</strong></li><li><strong>explicit pvalue</strong>：对应的参数是<code>full</code>，这个会显示使用的<strong>检验名称</strong>、<strong>pvalue的数值</strong></li></ul></li></ul><p>具体使用可以参考<a href="https://nbviewer.jupyter.org/github/webermarcolivier/statannot/blob/master/example/example.ipynb" target="_blank" rel="noopener">statannot使用example</a></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/webermarcolivier/statannot" target="_blank" rel="noopener">statannot的Github</a></li><li><a href="https://nbviewer.jupyter.org/github/webermarcolivier/statannot/blob/master/example/example.ipynb" target="_blank" rel="noopener">statannot使用example</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘图 </tag>
            
            <tag> annotation </tag>
            
            <tag> boxplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R绘图系列-带有significant信息的boxplot</title>
      <link href="/posts/40911.html"/>
      <url>/posts/40911.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用R中的<code>ggsignif</code>包对<code>boxplot</code>两两样本之间<strong>添加显著性注释</strong>的过程；其实这个包可以两两对比的使用<code>ggplot2</code>画图的都可以添加，对<strong>任何可以两两对比的、使用<code>ggplot2</code>画图的都可以添加</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>boxplot</code>既可以很好地显示某个属性内部样本点的变化，也可以与其他属性进行对比，所以使用非常广泛。但是有时候我们需要对属性之间的样本点变化有个准确的度量，也就是比较两个样本是不是存在显著性地差异，这个时候就需要在原始的<code>boxplot</code>上加上样本之间假设检验的显著性信息。</p><hr><h2 id="ggsignif"><a href="#ggsignif" class="headerlink" title="ggsignif"></a>ggsignif</h2><p><code>R</code>中的<code>ggsignif</code>就是专门解决前面遇到问题的包，<a href="https://www.jianshu.com/p/678213d605a5" target="_blank" rel="noopener">其他包如ggpubr</a>也可以达到类似的目的，这里主要学习<code>ggsignif</code>，因为其是基于<code>ggplot2</code>的语法，相当于是<a href="https://www.ggplot2-exts.org/gallery/" target="_blank" rel="noopener">ggplot2的一个拓展</a>，这也就意味着<strong>其不仅可以对<code>boxplot</code>添加显著性，对于任何可以两两对比的使用<code>ggplot2</code>画图的都可以添加</strong>，很是方便；同时对熟悉<code>ggplot2</code>的人来说也比较容易上手。下面来简单介绍其使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">install.packages(<span class="string">"ggsignif"</span>)</span><br><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(ggsignif)</span><br></pre></td></tr></table></figure><hr><h3 id="简单绘制"><a href="#简单绘制" class="headerlink" title="简单绘制"></a>简单绘制</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(x=Species, y=Sepal.Length)) + </span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  geom_signif(comparisons = list(c(<span class="string">"versicolor"</span>, <span class="string">"virginica"</span>)), </span><br><span class="line">              map_signif_level=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/boxplot_with_sign.png" alt="boxplot_with_sign.png"></p><div class="note info"><p>注意<strong>默认的检验的两个样本的非参检验(不需要样本符合正太分布)</strong>：<code>‘Mann-Whitney’ test.(wilcox.test)</code></p></div><hr><h2 id="自定义绘制"><a href="#自定义绘制" class="headerlink" title="自定义绘制"></a>自定义绘制</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两两比较的列表</span></span><br><span class="line">compaired &lt;- list(c(<span class="string">"versicolor"</span>, <span class="string">"virginica"</span>), </span><br><span class="line">                  c(<span class="string">"versicolor"</span>,<span class="string">"setosa"</span>), </span><br><span class="line">                  c(<span class="string">"virginica"</span>,<span class="string">"setosa"</span>))</span><br><span class="line"><span class="comment"># 使用t.test代替默认的wilcox.test</span></span><br><span class="line">ggplot(iris, aes(Species, Sepal.Width, fill = Species)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  ylim(<span class="number">1.5</span>, <span class="number">6.5</span>) +</span><br><span class="line">  geom_signif(comparisons = compaired,</span><br><span class="line">              step_increase = <span class="number">0.3</span>,</span><br><span class="line">              map_signif_level = <span class="literal">F</span>,</span><br><span class="line">              test = t.test)</span><br></pre></td></tr></table></figure><ul><li><code>step_increase</code>：调整每个显著性标记之间的间隔。</li><li><code>test</code>：指定要使用的检验类型，默认是<code>wilcox.test</code></li><li><code>map_signif_level</code>：是显示具体<code>pvalue</code>还是显示符号<code>c(&quot;***&quot;=0.001,&quot;**&quot;=0.01, &quot;*&quot;=0.05)</code>，可以自行指定符号。</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/boxplot_with_sign_2.png" alt="boxplot_with_sign_2.png"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ggplot(iris, aes(Species, Sepal.Width, fill = Species)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  ylim(<span class="number">1.5</span>, <span class="number">6.5</span>) +</span><br><span class="line">  geom_signif(comparisons = compaired,</span><br><span class="line">              map_signif_level = <span class="literal">F</span>,</span><br><span class="line">              y_position=c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),</span><br><span class="line">              tip_length = c(<span class="number">0</span>),</span><br><span class="line">              test = t.test)</span><br></pre></td></tr></table></figure><ul><li><code>y_position</code>：指定显著性标记的高度，如<code>y_position=c(4,5,6)</code></li><li><code>tip_length</code>：设置横线两端向下生出的长度，如 <code>tip_length = c(0)</code></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/boxplot_with_sign_3.png" alt="boxplot_with_sign_3.png"></p><p>其他常用参数：</p><ul><li><code>annotations</code>：character vector with alternative annotations, <strong>if not null test is ignored</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/const-ae/ggsignif" target="_blank" rel="noopener">ggsignif的Github</a></li><li><a href="https://cran.r-project.org/web/packages/ggsignif/ggsignif.pdf" target="_blank" rel="noopener">ggsignif的文档</a></li><li><a href="https://cran.r-project.org/web/packages/ggsignif/vignettes/intro.html" target="_blank" rel="noopener">ggsignif官方介绍</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzQzMjU4Mw==&amp;mid=2247487837&amp;idx=3&amp;sn=6559108238df05ddbb261416bbc0851c&amp;chksm=ec736d35db04e423545b852bb6eedbc2275b0a884f85513fdf06770e35f1f105fa9f6d360141&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1570442620363&amp;sharer_shareid=1b54e58f922202bb93a6ffe28bb2f3a7&amp;key=0a90e6804693187e27a3239b02db27a4572be4a61502c8d3c582ed2cf63ac02fb7c1f7ba2c4ddcf96ee86e173f89f985e926f84a233154d2660ff56f51e0fda374a6b37deda76be77484d35e635e4165&amp;ascene=1&amp;uin=MjU2NzcxOTIxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060841&amp;lang=zh_CN&amp;pass_ticket=62x9VlAM9BQRQsx6qYImjeGo2KjVm0E3ZgT1cQ7V8AytSS45gCiqY%2FtyNXhl%2B6mt" target="_blank" rel="noopener">Boxplot | 用R画一个漂亮的boxplot</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3Mzc1MzczMA==&amp;mid=2247484318&amp;idx=1&amp;sn=aeeb47d5f0cc6ce0971032f4709393ef&amp;chksm=eb1f3073dc68b9651aa3fe1fed06db66ade6231c5f9790868ffcf680e76f67e329e04f823da3&amp;scene=21" target="_blank" rel="noopener">神奇小工具丨ggplot绘图显著性添加工具—ggsignif</a></li><li><a href="http://www.bioinfo-scrounger.com/archives/403" target="_blank" rel="noopener">R作图 显著性绘制工具-ggsignif</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘图 </tag>
            
            <tag> boxplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘图系列-处理annotation重叠</title>
      <link href="/posts/46875.html"/>
      <url>/posts/46875.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>R</code>和<code>Python</code>中<strong>对<code>annotation</code>重叠进行自动调整的包</strong>，便于日后查询使用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前不管在使用<code>R</code>语言绘图还是<code>Python</code>绘图都会涉及到<strong>对图中的某些点进行注释</strong>的问题，点比较少并且分得开也还好，但是一旦点比较多或者想要标注的点比较密集就很容易遇到annotation重叠的问题，这种情况下自己慢慢调整就非常费劲。今天刚好看到有文章在分享关于解决<code>R</code>中<code>annotation</code>注释重叠的问题(专门的基于<code>ggplot2</code>的包来解决这个问题)，顺藤摸瓜居然发现<code>Python</code>也已经有了类似的包可以解决<code>annotation</code>重叠(白高兴一场，本来以为自己可以开发一个自动调整<code>annotation</code>的包来着)，这里就记录一下这个包，日后需要的时候方便。</p><hr><h2 id="Python-adjustText"><a href="#Python-adjustText" class="headerlink" title="Python-adjustText"></a>Python-adjustText</h2><p>在具体使用方面总的来说是<strong>先使用<code>Matplotlib</code>的命令将图画出来</strong>，然后<strong>再使用该包的一些命令对<code>annotation</code>进行调整</strong>(没有脱离于<code>Matplotlib</code>，大大增强了其易用性)：</p><ul><li><a href="https://github.com/Phlya/adjustText" target="_blank" rel="noopener">Github链接</a></li><li><a href="https://adjusttext.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a></li><li><a href="https://github.com/Phlya/adjustText/wiki" target="_blank" rel="noopener">wiki</a></li><li><a href="https://nbviewer.jupyter.org/github/Phlya/adjustText/blob/master/docs/source/Examples.ipynb" target="_blank" rel="noopener">使用example</a></li></ul><hr><h2 id="R-ggrepel"><a href="#R-ggrepel" class="headerlink" title="R-ggrepel"></a>R-ggrepel</h2><p>上面的<code>adjustText</code>就是基于R包<code>ggrepel</code>思想来开发的，该包在我看来最大的好处就是<strong>没有脱离于<code>ggplot2</code>(属于<a href="https://www.ggplot2-exts.org/gallery/" target="_blank" rel="noopener">ggplot2的拓展</a>)</strong>，也就是说使用者可以在常规地<code>ggplot2</code>绘图脚本之后添加一行命令就可以达到调整<code>annotation</code>重叠的目的(吹爆这个特点)：</p><ul><li><a href="https://github.com/slowkow/ggrepel" target="_blank" rel="noopener">Github链接</a></li><li><a href="https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html" target="_blank" rel="noopener">ggrepel examples</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 绘图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘图 </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置Github项目徽章</title>
      <link href="/posts/19563.html"/>
      <url>/posts/19563.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了为自己的<a href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener">项目</a><strong>增加徽章</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>Github</code>上我们经常能看到一些项目的小徽章(<code>Badge</code>)，这些小徽章可以很简洁明了地介绍项目信息，比如下面<code>pandas</code>的项目徽章：</p><table><tr><td>Latest Release</td><td><a href="https://pypi.org/project/pandas/" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/v/pandas.svg" alt="latest release"></a></td></tr><td></td><td><a href="https://anaconda.org/anaconda/pandas/" target="_blank" rel="noopener"><img src="https://anaconda.org/conda-forge/pandas/badges/version.svg" alt="latest release"></a></td><tr><td>Package Status</td><td><a href="https://pypi.org/project/pandas/" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/status/pandas.svg" alt="status"></a></td></tr><tr><td>License</td><td><a href="https://github.com/pandas-dev/pandas/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/pypi/l/pandas.svg" alt="license"></a></td></tr><tr><td>Build Status</td><td><a href="https://travis-ci.org/pandas-dev/pandas" target="_blank" rel="noopener"><img src="https://travis-ci.org/pandas-dev/pandas.svg?branch=master" alt="travis build status"></a></td></tr><tr><td></td><td><a href="https://dev.azure.com/pandas-dev/pandas/_build/latest?definitionId=1&branch=master" target="_blank" rel="noopener"><img src="https://dev.azure.com/pandas-dev/pandas/_apis/build/status/pandas-dev.pandas?branch=master" alt="Azure Pipelines build status"></a></td></tr><tr><td>Coverage</td><td><a href="https://codecov.io/gh/pandas-dev/pandas" target="_blank" rel="noopener"><img src="https://codecov.io/github/pandas-dev/pandas/coverage.svg?branch=master" alt="coverage"></a></td></tr><tr><td>Downloads</td><td><a href="https://pandas.pydata.org" target="_blank" rel="noopener"><img src="https://anaconda.org/conda-forge/pandas/badges/downloads.svg" alt="conda-forge downloads"></a></td></tr><tr><td>Gitter</td><td><a href="https://gitter.im/pydata/pandas" target="_blank" rel="noopener"><img src="https://badges.gitter.im/Join%20Chat.svg"></a></td></tr></table><p>这篇文章将会学习如何给自己的项目加上一些项目徽章。</p><h2 id="徽章生成网站"><a href="#徽章生成网站" class="headerlink" title="徽章生成网站"></a>徽章生成网站</h2><p>GitHub 项目的徽章可以使用<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>来生成。使用该网站生成徽章主要有两种方法：</p><ul><li><a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>自动推荐。这种方法只需要你提供<code>Github</code>项目的<code>url</code>链接，<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>会依据你的项目项目信息进行推荐，一般会包括<code>Github issues</code>、<code>Github forks</code>、<code>Github stars</code>、<code>Github license</code>、<code>Twitter</code>。</li><li><strong>生成自定义的徽章标签</strong>。如果想要自己修改徽章的文字和颜色，<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>也支持自定义的方式来进行设置。</li></ul><h2 id="自动推荐徽章"><a href="#自动推荐徽章" class="headerlink" title="自动推荐徽章"></a>自动推荐徽章</h2><h3 id="得到徽章"><a href="#得到徽章" class="headerlink" title="得到徽章"></a>得到徽章</h3><p>打开<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>，输入<code>Github</code>项目链接，点击<code>Suggest badges</code>即可，具体效果如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章.png" alt="Github项目徽章.png"></p><h3 id="设置徽章"><a href="#设置徽章" class="headerlink" title="设置徽章"></a>设置徽章</h3><p>点击图标或者链接，即可进入设置页，设置图标的颜色、样式等属性，最后选择你想要的 <code>markdown</code> 或者 <code>URL</code> 代码到 <code>README.md</code> 或者项目的文档页面即可:<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_2.png" alt="Github项目徽章_2.png"></p><p>效果图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_3.png" alt="Github项目徽章_3.png"></p><h2 id="自定义徽章"><a href="#自定义徽章" class="headerlink" title="自定义徽章"></a>自定义徽章</h2><p>打开<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>，找到<code>Your Badge</code>，输入<code>label</code>、<code>message</code>和<code>color</code>，<code>Make Badge</code>即可：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_4.png" alt="Github项目徽章_4.png"></p><p>最后将得到的信息加入到项目的<code>README.md</code>中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置了超链接</span></span><br><span class="line">[![blog__reprint](https://img.shields.io/badge/showteeth-blog__reprint-yellow)](https://github.com/showteeth/blog_reprint)</span><br><span class="line">[![GitHub forks](https://img.shields.io/github/forks/showteeth/blog_reprint)](https://github.com/showteeth/blog_reprint/network)</span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果图</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Github项目徽章_5.png" alt="Github项目徽章_5.png"></p><div class="note info"><p>总结：</p><ul><li>实际上徽章就是<a href="https://shields.io/" target="_blank" rel="noopener">Shields</a>帮助我们<strong>生成的一些小图片</strong>，得到这些图片后我们可以将其以<code>markdown</code>的语法加载<code>.md</code>文件中；</li><li><strong>徽章是静态的</strong>，不会根据项目内容的改变而做出自动的调整，所以<strong>如果项目更改了和徽章相关的信息就需要手动对其进行修改</strong>。</li></ul></div><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Matplotlib-两种绘图接口的统一</title>
      <link href="/posts/22997.html"/>
      <url>/posts/22997.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>plt.gca()</code>将<code>Matplotlib</code>的<code>state-based interface</code>转化为<code>object-oriented interface</code>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的<a href="http://showteeth.tech/posts/4719.html">Python系列之Matplotlib-基础</a>文章中提到过<code>Matplotlib</code>有两种让初学者非常难受的地方，其中之一就是其有<strong>两种绘图接口(两种绘图的语法)</strong>，这意味着使用<code>Matplotlib</code>绘图需要记住两种截然不同的绘图语法规则，这是非常痛苦的，尤其是在需要对图片进行自定义地调整的时候。基于这种情况，如果能够找到一种方法将两种绘图接口统一起来，那就极大减少<code>Matplotlib</code>的使用难度。这里发现了一种可以将两种绘图接口结合起来的方法：使用<code>plt.gca()</code>将<code>state-based interface</code>转化为<code>object-oriented interface</code>，下面将会仔细了解一下。</p><hr><h2 id="plt-gca"><a href="#plt-gca" class="headerlink" title="plt.gca()"></a>plt.gca()</h2><p><code>plt.gca()</code>的作用是得到<strong>当前图片的<code>Axes</code>实例</strong>，如果<code>Axes</code>不存在，那就创建一个。</p><blockquote><p>Get the <strong>current Axes instance</strong> on the current figure matching the given keyword args, or create one. If the current axes doesn’t exist, or isn’t a polar one, the appropriate axes will be created and then returned.</p></blockquote><hr><h2 id="两种接口转化"><a href="#两种接口转化" class="headerlink" title="两种接口转化"></a>两种接口转化</h2><p>以隐藏<code>tick label</code>为例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用state-based interface的方法</span></span><br><span class="line">plt.plot(range(<span class="number">10</span>))</span><br><span class="line">plt.tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用object-oriented interface的方法</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(range(<span class="number">10</span>))</span><br><span class="line">ax.tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用plt.gca()将state-based interface转换为object-oriented interface语法</span></span><br><span class="line">plt.gca().tick_params(</span><br><span class="line">    axis=<span class="string">'x'</span>,          <span class="comment"># 选择应用的刻度</span></span><br><span class="line">    which=<span class="string">'both'</span>,      <span class="comment"># 选择是minor或者major</span></span><br><span class="line">    bottom=<span class="keyword">False</span>,      <span class="comment"># ticks along the bottom edge are off</span></span><br><span class="line">    top=<span class="keyword">False</span>         <span class="comment"># ticks along the top edge are off</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.gca.html" target="_blank" rel="noopener">matplotlib.pyplot.gca</a></li><li><a href="https://stackoverflow.com/questions/45381589/how-does-plt-gca-work-internally" target="_blank" rel="noopener">How does plt.gca work internally</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Matplotlib-速查表</title>
      <link href="/posts/12679.html"/>
      <url>/posts/12679.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章是一个<code>Matplotlib</code>绘图的速查表，便于日后使用<code>Matplotlib</code>绘图查询使用，内容源于<a href="https://github.com/rougier/matplotlib-cheatsheet/blob/master/README.md" target="_blank" rel="noopener">matplotlib-cheatsheet</a>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在系统学习<code>Matplotlib</code>绘图，恰巧看到知乎上一篇文章讲的是<code>Matplotlib</code>速查表，我大致看了一看，感觉整理地确实很详细，所以在这里学习和记录一下，以便以后查阅。</p><hr><h2 id="线条类型和常用颜色"><a href="#线条类型和常用颜色" class="headerlink" title="线条类型和常用颜色"></a>线条类型和常用颜色</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_1.png" alt="matplotlib速查_1.png"></p><p>相关名词：</p><ul><li><strong><a href="https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/joinstyle.html" target="_blank" rel="noopener">Cap styles</a></strong>: Cap styles define how the the end of a line is drawn</li><li><strong><a href="https://stackoverflow.com/questions/8750203/what-is-antialiased-in-matplotlib-collections-and-how-do-you-set-the-paramet" target="_blank" rel="noopener">Antialias</a></strong>:<ul><li>The antialiased keyword argument controls <strong>whether or not a particular matplotlib artist (e.g. line, polygon, etc) is drawn with antialising or not</strong>. <mark>Non-antialiased plotting will be faster, so if you’re plotting a large amount of data, it can be worthwhile to turn it off.</mark></li><li>简单理解就是matplotlib在画图时会对呈现的图像进行处理来使图像更加光滑，不至于出现那种锯齿状的像素块形状(混叠效应)。</li></ul></li></ul><hr><h2 id="marker的种类和颜色"><a href="#marker的种类和颜色" class="headerlink" title="marker的种类和颜色"></a>marker的种类和颜色</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_2.png" alt="matplotlib速查_2.png"></p><ul><li><strong><a href="https://matplotlib.org/examples/pylab_examples/markevery_demo.html" target="_blank" rel="noopener">Marker spacing</a></strong>：控制绘制marker的频率，如<ul><li><code>markevery=5</code>表示隔五个数据点画一个marker</li><li><code>markevery=[0, -1]</code>表示只在第一个数据点和最后一个数据点画marker</li></ul></li></ul><hr><h2 id="多边形集合"><a href="#多边形集合" class="headerlink" title="多边形集合"></a>多边形集合</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_3.png" alt="matplotlib速查_3.png"></p><hr><h2 id="常用图形"><a href="#常用图形" class="headerlink" title="常用图形"></a>常用图形</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_4.png" alt="matplotlib速查_4.png"></p><hr><h2 id="刻度控制"><a href="#刻度控制" class="headerlink" title="刻度控制"></a>刻度控制</h2><p><a href="https://matplotlib.org/3.1.1/gallery/ticks_and_spines/tick-locators.html" target="_blank" rel="noopener">官网链接</a><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_5.png" alt="matplotlib速查_5.png"></p><hr><h2 id="图片布局调整"><a href="#图片布局调整" class="headerlink" title="图片布局调整"></a>图片布局调整</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_6.png" alt="matplotlib速查_6.png"></p><hr><h2 id="legend控制"><a href="#legend控制" class="headerlink" title="legend控制"></a>legend控制</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_7.png" alt="matplotlib速查_7.png"></p><hr><h2 id="坐标轴类型-线性和对数"><a href="#坐标轴类型-线性和对数" class="headerlink" title="坐标轴类型-线性和对数"></a>坐标轴类型-线性和对数</h2><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_8.png" alt="matplotlib速查_8.png"></p><hr><h2 id="常用colormap名称"><a href="#常用colormap名称" class="headerlink" title="常用colormap名称"></a>常用colormap名称</h2><p><a href="https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html" target="_blank" rel="noopener">官方教程</a><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib速查_9.png" alt="matplotlib速查_9.png"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/rougier/matplotlib-cheatsheet/blob/master/matplotlib-cheatsheet.pdf" target="_blank" rel="noopener">pdf的Github地址</a></li><li><a href="https://zhuanlan.zhihu.com/p/77782561?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=680025552107343872" target="_blank" rel="noopener">Matplotlib速查表——画图时候一定要放手边的表</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R系列之包的相关操作汇总</title>
      <link href="/posts/28413.html"/>
      <url>/posts/28413.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了对<code>R</code>包的一些常用操作，包括<strong>安装<code>R</code>包的各种方法</strong>、<strong>查看已加载的包</strong>、<strong>卸除加载包</strong>、<strong>卸载R包</strong>、<strong>查看包提供的函数</strong>以及<strong>查看包的版本</strong>。</p></div><a id="more"></a><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><h3 id="install-packages安装"><a href="#install-packages安装" class="headerlink" title="install.packages安装"></a>install.packages安装</h3><p>这个是安装<code>R</code>包最常用也是最简单的方法，关键在于镜像的选择(有时候安装不成功，换个镜像说不定就成功了)：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定使用清华的镜像</span></span><br><span class="line">install.packages(<span class="string">"getopt"</span>, repos=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/CRAN"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用官方镜像</span></span><br><span class="line">install.packages(<span class="string">'ggplot2'</span>, dependencies=<span class="literal">TRUE</span>, repos=<span class="string">'http://cran.rstudio.com/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用如下方法一次指定</span></span><br><span class="line"><span class="comment"># Allow the user to set and examine a variety of global options </span></span><br><span class="line"><span class="comment"># which affect the way in which R computes and displays its results.</span></span><br><span class="line">options(repos=structure(c(CRAN=<span class="string">"http://cran.rstudio.com/"</span>)))</span><br><span class="line">install.packages(<span class="string">"ggplot2"</span>, dependencies = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="从github直接安装"><a href="#从github直接安装" class="headerlink" title="从github直接安装"></a>从github直接安装</h3><p>有些包如果没有发布在<code>CRAN(Comprehensive R Archive Network)</code>或者使用前面的安装方法不成功上可以直接从<code>github</code>上安装：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Github安装</span></span><br><span class="line"><span class="comment"># 先安装devtools，然后在利用devtools中的install_github进行安装</span></span><br><span class="line">install.packages(<span class="string">"devtools"</span>, repo=<span class="string">"http://cran.rstudio.com/"</span>)</span><br><span class="line"><span class="keyword">library</span>(devtools)</span><br><span class="line">install_github(<span class="string">"kassambara/ggpubr"</span>)</span><br></pre></td></tr></table></figure><p></p><p><code>github</code>安装<code>R</code>包还可以使用<code>githubinstall</code>包，其<strong>功能更加完善一些</strong>，可以<strong>搜索某个用户</strong>的所有包、<strong>关键词搜索R包**</strong>、显示指定<code>R</code>函数的源代码**等，不过我觉得有一个就可以了，后续如果需要再看吧。</p><hr><h3 id="Bioconductor安装"><a href="#Bioconductor安装" class="headerlink" title="Bioconductor安装"></a>Bioconductor安装</h3><p><code>Bioconductor</code>中主要包含的是进行生信分析所需要的包，如果不是生信行业从业者，这个方法可能不是很适用，不过也有可能自己需要的包包含在了<code>Bioconductor</code>中：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source一下源码</span></span><br><span class="line"><span class="comment"># 如果源码被黑存在病毒，那就gg</span></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">biocLite(<span class="string">"org.Dr.eg.db"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在R3.5.1之后，推出了BiocManager包Bioconductor包的安装</span></span><br><span class="line"><span class="comment"># 先安装BiocManager</span></span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">"BiocManager"</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">"BiocManager"</span>)</span><br><span class="line"><span class="comment"># BiocManager::install()</span></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">BiocManager::install(c(<span class="string">"GenomicFeatures"</span>, <span class="string">"AnnotationDbi"</span>))</span><br></pre></td></tr></table></figure><p></p><p>安装包的自动化脚本：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要安装的包的名称</span></span><br><span class="line">package_list &lt;- c(<span class="string">"clusterProfiler"</span>,<span class="string">"getopt"</span>,<span class="string">"org.Hs.eg.db"</span>,<span class="string">"org.Mm.eg.db"</span>,<span class="string">"topGO"</span>,<span class="string">"pathview"</span>,<span class="string">"Rgraphviz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> package_list)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!suppressWarnings(suppressMessages(<span class="keyword">require</span>(p, character.only = <span class="literal">TRUE</span>, quietly = <span class="literal">TRUE</span>, warn.conflicts = <span class="literal">FALSE</span>))))&#123;</span><br><span class="line">    <span class="comment"># Bioconductor安装</span></span><br><span class="line">    <span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">    biocLite(p)</span><br><span class="line">    suppressWarnings(suppressMessages(<span class="keyword">library</span>(p, character.only = <span class="literal">TRUE</span>, quietly = <span class="literal">TRUE</span>, warn.conflicts = <span class="literal">FALSE</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><mark>require和library加载包的区别</mark>：</p><ul><li><strong>包不存在时</strong>：使用<code>library</code>加载包会<strong>直接报错停止</strong>；而使用<code>require</code>加载则只会出现<code>Warning message</code>，<strong>不会停止执行</strong>，并且<code>require</code>命令会返回<code>FALSE</code>，所以可以<strong>利用这个特性进行检测环境是不是安装了某个包，并进行自动化安装</strong>；</li><li><strong>包存在时</strong>：都是加载包</li></ul></div><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/tandelin/article/details/87601729" target="_blank" rel="noopener">从Github上获取R包/安装</a></li><li><a href="https://www.bioconductor.org/install/" target="_blank" rel="noopener">Using Bioconductor</a></li><li><a href="https://stackoverflow.com/questions/5595512/what-is-the-difference-between-require-and-library" target="_blank" rel="noopener">What is the difference between require() and library()?</a></li></ul><hr><h2 id="查看已加载的包"><a href="#查看已加载的包" class="headerlink" title="查看已加载的包"></a>查看已加载的包</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意外面的括号和前面的点不能省</span></span><br><span class="line">(.packages())</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"htmlwidgets"</span> <span class="string">"recharts"</span>    <span class="string">"stats"</span>       <span class="string">"graphics"</span>    <span class="string">"grDevices"</span>   <span class="string">"utils"</span>       <span class="string">"datasets"</span>   </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"methods"</span></span><br></pre></td></tr></table></figure><hr><h2 id="卸除加载包"><a href="#卸除加载包" class="headerlink" title="卸除加载包"></a>卸除加载包</h2><p>注意<strong>是卸除，不是卸载</strong>，也就是说不是把包从R运行环境中彻底删除，只是<strong>不希望该包被加载使用</strong>；在<strong>包使用函数冲突</strong>，<strong>检验函数依赖</strong>时比较有用。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">detach</span>(<span class="string">"package:htmlwidgets"</span>)</span><br><span class="line">(.packages())</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"recharts"</span>  <span class="string">"stats"</span>     <span class="string">"graphics"</span>  <span class="string">"grDevices"</span> <span class="string">"utils"</span>     <span class="string">"datasets"</span>  <span class="string">"methods"</span>   <span class="string">"base"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="卸载R包"><a href="#卸载R包" class="headerlink" title="卸载R包"></a>卸载R包</h2><p><strong>彻底删除</strong>已安装的包：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># "pkg1","pkg2"表示包名，即一次可以卸载多个包；</span></span><br><span class="line">remove. packages(c(<span class="string">"pkg1"</span>,<span class="string">"pkg2"</span>) , lib = file .path(<span class="string">"path"</span>, <span class="string">"to"</span>, <span class="string">"library"</span>))</span><br><span class="line"><span class="comment"># "path", "to", "library"表示R的库路径，字符向量，通常情况下只输一个路径即可。</span></span><br><span class="line"><span class="comment"># 使用命令.libPaths()可以查看库路径。示例：</span></span><br><span class="line">&gt; .libPaths()</span><br><span class="line">[<span class="number">1</span>] <span class="string">"D:/R-3.5.1/library"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="查看某个包提供的函数"><a href="#查看某个包提供的函数" class="headerlink" title="查看某个包提供的函数"></a>查看某个包提供的函数</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(package=<span class="string">'ggplot2'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="查看包的版本"><a href="#查看包的版本" class="headerlink" title="查看包的版本"></a>查看包的版本</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packageVersion(<span class="string">"ggplot2"</span>)</span><br><span class="line">  [<span class="number">1</span>] ‘<span class="number">3.2</span><span class="number">.0</span>’</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之SGE出现Command Not Found, Undefined Variable</title>
      <link href="/posts/35609.html"/>
      <url>/posts/35609.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>SGE</code>集群任务管理系统提交任务时出现的<code>Command Not Found, Undefined Variable</code>错误的<strong>原因</strong>以及<strong>解决方法</strong>，同时也列出了<strong>常用的参数</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>SGE(Sun Grid Engine)</code>集群任务管理系统提交任务时莫名出现了错误<code>Command Not Found, Undefined Variable</code>，具体就是使用<code>a=path; cd ${a}</code>，结果发现<code>a=path: Command not found; a: Undefined variable.</code>，这个错误让我很纳闷，平常在另一个机器上使用<code>SGE</code>使用同样的脚本并不会出错啊，但是为啥现在就不行了呢？这篇文章就记录了出现这个问题的原因以及可行的解决办法。</p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现上述问题的原因总的来说就是<mark>当前机器上<code>SGE</code>默认的<code>shell</code>不是<code>bash</code>，而是<code>csh</code>，而<code>csh</code>在对(局部)变量进行赋值操作时需要使用<code>set a=path</code>，而不是<code>bash</code>中常用的<code>a=path</code></mark>。</p><p>查看<code>SGE</code>集群节点的默认<code>shell</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看queue列表</span></span><br><span class="line">qconf -sql</span><br><span class="line">  all.q</span><br><span class="line">  bnode.q</span><br><span class="line">  guo.q</span><br><span class="line">  little.q</span><br><span class="line">  login04.q</span><br><span class="line">  lu.q</span><br><span class="line">  qlogin.q</span><br><span class="line">  yang.q</span><br><span class="line">  zhong.q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看自己所属队列的情况</span></span><br><span class="line">qconf -sq all.q</span><br><span class="line">  qname                 all.q</span><br><span class="line">  <span class="comment"># 主机列表，也就是这个队列可以使用的节点名称</span></span><br><span class="line">  hostlist              hpbnode-0-1.local hpbnode-0-2.local node-0-1.local \</span><br><span class="line">                        node-0-13.local node-0-14.local node-0-15.local \</span><br><span class="line">                        node-0-16.local.hpc.org node-0-18.local node-0-19.local \</span><br><span class="line">                        node-0-2.local node-0-20.local node-0-3.local \</span><br><span class="line">                        node-0-4.local node-0-5.local node-0-6.local \</span><br><span class="line">                        node-0-7.local</span><br><span class="line">  seq_no                0</span><br><span class="line">  load_thresholds       np_load_avg=1.5</span><br><span class="line">  suspend_thresholds    NONE</span><br><span class="line">  nsuspend              1</span><br><span class="line">  suspend_interval      00:05:00</span><br><span class="line">  priority              0</span><br><span class="line">  min_cpu_interval      00:05:00</span><br><span class="line">  processors            UNDEFINED</span><br><span class="line">  qtype                 BATCH INTERACTIVE</span><br><span class="line">  ckpt_list             NONE</span><br><span class="line">  pe_list               make mpi mpich openmp orte smp</span><br><span class="line">  rerun                 FALSE</span><br><span class="line">  slots                 16,[bnode02.local=32],[C-login01.local=32], \</span><br><span class="line">                        [C-login02.local=32],[C-login03.local=32], \</span><br><span class="line">                        [C-login04.local=56],[hpbnode-0-2.local=24]</span><br><span class="line">  tmpdir                /tmp</span><br><span class="line">  <span class="comment"># 默认的shell就是csh，而不是bash</span></span><br><span class="line">  <span class="comment"># 这个就是问题的关键</span></span><br><span class="line">  shell                 /bin/csh</span><br><span class="line">  prolog                NONE</span><br><span class="line">  epilog                NONE</span><br><span class="line">  shell_start_mode      posix_compliant</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>既然<code>SGE</code>默认的<code>shell</code>不是<code>bash</code>，而我们大部分对<code>bash</code>比较熟悉，所以<strong>最简单直接</strong>的办法就是将<code>SGE</code>默认的<code>shell</code>修改为<code>bash</code>，这个是一劳永逸的方法，具体的可以参考<a href="https://stackoverflow.com/questions/2020957/how-to-change-the-default-shell-for-the-sun-grid-engine" target="_blank" rel="noopener">这个</a>，因为使用的是学校的集群，所以自己不敢轻举妄动，或许也没有轻举妄动的权利，有兴趣的可以自行尝试。</p><p><strong>另一种方法，也是最推荐的方法</strong>就是在任务提交脚本中指明<code>SGE</code>使用的<code>shell</code>，使用语句：<code>#$ -S /bin/bash</code>，这样就可以直接使用熟悉的<code>bash</code>语法进行脚本的编写了。</p><p><strong>最后一种方法也是个人最不推荐的方法</strong>就是使用<code>csh</code>的语法进行脚本的编写，如上述需求可以使用：<code>set a=path</code>来解决，这种方法对于我来说不方便，有些复杂，还需要去了解<code>csh</code>的语法。</p><hr><h2 id="sge任务提交脚本示例"><a href="#sge任务提交脚本示例" class="headerlink" title="sge任务提交脚本示例"></a>sge任务提交脚本示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh This script is interpreted by the Bourne shell, sh.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The name of my job:</span></span><br><span class="line"><span class="comment">#$ -N glxspheres</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The interpreter SGE must use:</span></span><br><span class="line"><span class="comment">#$ -S /bin/shSun Grid Engine always uses sh to interpret this script.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Join stdout and stderr:</span></span><br><span class="line"><span class="comment">#$ -j y</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This job needs a graphics device:</span></span><br><span class="line"><span class="comment">#$ -l gfx=1 # Allocate a graphics resource to this job.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify that these environment variables are to be sent to SGE with the job:</span></span><br><span class="line"><span class="comment">#$ -v DISPLAY</span></span><br><span class="line"><span class="comment">#$ -v VGL_CLIENT</span></span><br><span class="line"><span class="comment">#$ -v VGL_GAMMA</span></span><br><span class="line"><span class="comment">#$ -v VGL_GLLIB</span></span><br><span class="line"><span class="comment">#$ -v VGL_SPOIL</span></span><br><span class="line"><span class="comment">#$ -v VGL_X11LIB</span></span><br><span class="line"><span class="comment">#$ -v SSH_CLIENT</span></span><br><span class="line"><span class="comment"># If these variables are not set before qsub/qrsh is invoked,</span></span><br><span class="line"><span class="comment"># then the job will find these variables set, but with a null string value ("").</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Script can run on what systems?</span></span><br><span class="line"><span class="comment"># Solaris (SPARC or x86, 32-bit or 64-bit) and Linux systems (32- or 64-bit),</span></span><br><span class="line"><span class="comment"># provided glxspheres is installed on the target system in one of the paths below.</span></span><br><span class="line"><span class="comment">#$ -l arch=sol-sparc|sol-sparc64|sol-x86|sol-amd64|lx24-x86|lx24-amd64</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># If VGL_DISPLAY is set by SGE, then run program with vglrun. Otherwise don't.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;VGL_DISPLAY+set&#125;</span>"</span> ]; <span class="keyword">then</span> If VGL_DISPLAY is <span class="built_in">set</span> (even <span class="keyword">if</span> null)...</span><br><span class="line"></span><br><span class="line">VGLRUN=/opt/VirtualGL/bin/vglrun Then the script will use vglrun to launch application.</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -x <span class="variable">$VGLRUN</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> 1&gt;&amp;2 <span class="string">"vglrun not found on host <span class="variable">$&#123;HOSTNAME:=‘hostname‘&#125;</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    VGLRUN=<span class="string">""</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>  [ -x /opt/VirtualGL/bin/glxspheres ]; <span class="keyword">then</span></span><br><span class="line">    path=/opt/VirtualGL/bin/glxspheres</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 1&gt;&amp;2 <span class="string">"glxspheres not found on host <span class="variable">$&#123;HOSTNAME&#125;</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Sun Grid Engine job starts vglrun which starts glxspheres</span></span><br><span class="line"><span class="comment"># with any arguments passed to this script.  If VGL_DISPLAY is not set,</span></span><br><span class="line"><span class="comment"># $VGLRUN will be the empty string, and vglrun won't be invoked.</span></span><br><span class="line"><span class="variable">$VGLRUN</span> <span class="string">"<span class="variable">$path</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="其他实用参数"><a href="#其他实用参数" class="headerlink" title="其他实用参数"></a>其他实用参数</h2><ul><li><code>-V</code>： 将<strong>当前的环境变量传递到执行命令的节点中</strong>，<code>Specifies that all environment variables active within the qsub utility be exported to the context of the job</code>.</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://talby.rcs.manchester.ac.uk/~ri/_linux_and_hpc_lib/sge_intro.html#jobshellsect" target="_blank" rel="noopener">An Intro to SGE</a></li><li><a href="https://stackoverflow.com/questions/17271931/sge-command-not-found-undefined-variable" target="_blank" rel="noopener">SGE Command Not Found, Undefined Variable</a></li><li><a href="https://docs.oracle.com/cd/E19279-01/820-3257-12/n1ge.html#50577430_84220" target="_blank" rel="noopener">Sun Grid Engine Reference</a></li><li><a href="http://gridscheduler.sourceforge.net/htmlman/htmlman1/qsub.html" target="_blank" rel="noopener">qsub的帮助文档，查看参数</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Matplotlib-基础</title>
      <link href="/posts/4719.html"/>
      <url>/posts/4719.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章是<strong>系统</strong>学习<code>Matplotlib</code>包的开始，主要包括<strong>对<code>Matplotlib</code>的介绍</strong>、<strong>其他常用的绘图包</strong>、<strong><code>Matplotlib</code>中的两种绘图接口</strong>、<strong><code>Matplotlib</code>所接受的输入数据类型</strong>以及<strong><code>Matplotlib</code>中一些常用术语和模块关系</strong>，为以后的深入学习打下基础。</p></div><a id="more"></a><h2 id="Matplotlib简介"><a href="#Matplotlib简介" class="headerlink" title="Matplotlib简介"></a>Matplotlib简介</h2><p>在<code>Python</code>中只要是使用常规的绘图功能(交互式绘图除外)，<code>Matplotlib</code>是你必然会使用的一个<code>package</code>。有时候你的使用是<strong>显式的</strong>，有时候你的使用是<strong>隐式的</strong>，说隐式的原因是<code>Python</code>中常用的绘图包都是基于<code>Matplotlib</code>进行二次开发的，比如<code>Seaborn</code>、<code>pandas</code>(内置的一些绘图方法)、<code>plotnine</code>(类似<code>R</code>中的<code>ggplot2</code>)、<code>ggplot</code>(类似R中的<code>ggplot2</code>)。所以学习使用<code>Matplotlib</code>是使用<code>Python</code>进行绘图不可避免的一个环节。</p><p>但是<code>Matplotlib</code>也有一些很让<strong>初学者难受</strong>的地方：</p><ul><li><strong>两种绘图接口</strong>。一种是基于<code>MATLAB</code>的<code>state-based interface</code>，一种是<code>object-oriented interface</code>(这两种接口在后续会进行进一步地介绍)，因为存在两种绘图接口，也就是说<strong>可以使用两套代码来完成同一个图</strong>，在实际使用过程中可能会<strong>带来混乱</strong>——当你使用一种<code>interface</code>绘图遇到错误去搜索的时候，发现大部分的答案是基于另一种<code>interface</code>的，直接把这种代码拷贝过来发现并不能得到别人所说的效果；</li><li><strong>基于Matplotlib的工具太多，这些工具既相似又存在很大差异</strong>。在<code>Python</code>中绘图，有时候发现<code>pandas</code>可以直接实现，有时候发现<code>Seaborn</code>也可以绘图，并且用的人也很多，但是使用的时候发现自己的需求单纯使用<code>pandas</code>、<code>Seaborn</code>可能不能解决，同时这两者绘图中的大部分语句又和<code>Matplotlib</code>类似，导致的结果就是想去学习绘图，但是又不知道从哪个<code>package</code>开始学习，最终的结果就是啥也没学会。</li></ul><p>虽然<code>Matplotlib</code>存在一些让初学者很难受的地方(我这么晚才开始系统学习<code>Matplotlib</code>的原因)，但是这些问题在初学者对<code>Matplotlib</code>有基本的学习和了解之后就可以很轻松的解决(<strong>个人的真实感受</strong>)。</p><p><br></p><h2 id="其他绘图包"><a href="#其他绘图包" class="headerlink" title="其他绘图包"></a>其他绘图包</h2><p>在具体了解<code>Matplotlib</code>之前，先详细了解一下其他目前<code>Python</code>中<strong>常用的绘图包以及其适用场景</strong>：</p><ul><li><code>Seaborn</code>：<code>Seaborn</code> 是一个基于 <code>Matplotlib</code> 的高级可视化效果库， <strong>偏向于统计作图</strong>。因此，<strong>针对的点主要是数据挖掘和机器学习中的变量特征选取</strong>。相比 <code>Matplotlib</code> ，它<strong>语法相对简化些</strong>，绘制出来的图不需要花很多功夫去修饰。但是它<strong>绘图方式比较局限，不过灵活</strong>。</li><li><code>Bokeh</code>：<code>Bokeh</code> 是基于 <code>javascript</code> 来实现<strong>交互可视化库</strong>，它可以在<code>WEB</code>浏览器中实现美观的视觉效果。但是它也有明显的<strong>缺点</strong>:其一是<strong>版本时常更新</strong>，最重要的是有时<strong>语法还不向下兼容</strong>；其二是<strong>语法晦涩</strong>。</li><li><code>Plotly</code>：<code>Plotly</code> 也是一个<strong>交互可视化库</strong>。它不仅支持 <code>Python</code> 还支持 <code>R</code> 语言。<code>Plotly</code> 的<strong>优点</strong>是能提供 <code>WEB</code> 在线交互，配色也真心好看。如果你是一名数据分析师，<code>Plotly</code> 强大的交互功能能助你一臂之力完成展示。</li><li><code>ggplot</code>：<code>ggplot</code> 是 <code>yhat</code> 大神基于 <code>R</code> 语言的 <code>ggplot2</code>制作的 <code>python</code> 版本库。 如果你使用 <code>R</code> 语言的话，<code>ggplot2</code> 可以算是必不可少的工具。所以，很多人都推荐使用该库，不过可惜的是，<code>yhat</code> 大神已<strong>经停止维护该库</strong>了(<a href="https://github.com/yhat/ggpy" target="_blank" rel="noopener">github</a>上最近一次更新还是3年之前了)。</li><li><code>plotnine</code>：<code>plotnine</code>也是一个为了在<code>Python</code>中实现<code>ggplot2</code>语法进行绘图的<code>package</code>，相比对长时间没有维护的<code>ggplot</code>，这个<code>package</code>目前仍然活跃，<a href="https://github.com/has2k1/plotnine" target="_blank" rel="noopener">github</a>上最近一次更新是2个月前，而且其<a href="https://plotnine.readthedocs.io/en/stable/" target="_blank" rel="noopener">文档</a>也比<code>ggplot</code>做得好很多，便于学习和使用。</li></ul><p><a href="https://pbpython.com/python-vis-flowchart.html" target="_blank" rel="noopener">最后附上绘图package的选择</a>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/matplotlib_packages.png" alt="matplotlib_packages.png"></p><p><br></p><h2 id="关于Matplotlib中的两种绘图接口"><a href="#关于Matplotlib中的两种绘图接口" class="headerlink" title="关于Matplotlib中的两种绘图接口"></a>关于Matplotlib中的两种绘图接口</h2><h3 id="state-based-interface"><a href="#state-based-interface" class="headerlink" title="state-based interface"></a>state-based interface</h3><p>这种<code>interface</code>是基于<code>MATLAB</code>，其在创建<strong>简单图形</strong>的时候比较好用(可以使用<code>plt.XXX</code>来绘制图形的各个部分)，但是允许的<strong>对图形的控制不是很多</strong>。使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># 使用plt完成所有的绘图操作</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.title(<span class="string">'Test figure'</span>)        </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="object-oriented-interface"><a href="#object-oriented-interface" class="headerlink" title="object-oriented interface"></a>object-oriented interface</h3><p>这种方法<strong>较为复杂</strong>，但是可以<strong>对图形进行完整的控制</strong>。使用这种<code>interface</code>进行绘图的<strong>主要思想</strong>是：</p><ul><li>创建一个<code>&quot;figure&quot;</code>对象(可以将其视为可视化的边界框)</li><li>然后创建一个或多个<code>&quot;axes&quot;</code>对象(作为可视化的子图)，主要这里的<code>&quot;axes&quot;</code>需要和<code>&quot;axis&quot;</code>进行区分，<code>&quot;axes&quot;</code>是指子图，而<code>&quot;axis&quot;</code>指的是一个图形的<code>x/y</code>轴</li><li>最后可以使用<code>&quot;axes&quot;</code>对象的方法来控制子图。</li></ul><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 创建"figure"对象以及一个"axes"对象</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 使用"axes"对象的方法来控制子图</span></span><br><span class="line">ax.bar(x=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>], height=[<span class="number">3.1</span>,<span class="number">7</span>,<span class="number">4.2</span>], color=<span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(xlabel=<span class="string">'X title'</span>, size=<span class="number">20</span>)</span><br><span class="line">ax.set_ylabel(ylabel=<span class="string">'Y title'</span> , color=<span class="string">'b'</span>, size=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意事项：</p><ul><li>通常情况下，尽量使用<code>object-oriented interface</code>，而不是<code>state-based(Pyplot) interface</code>.</li><li>在<code>object-oriented interface</code>中也会用到<code>state-based(Pyplot) interface</code>，不过用到的功能很少，包括<strong>用来创建和显示图片</strong>。</li></ul></div><p><br></p><h2 id="学习和使用步骤"><a href="#学习和使用步骤" class="headerlink" title="学习和使用步骤"></a>学习和使用步骤</h2><p>在这篇文章中提到了学习和使用<code>Matplotlib</code>的步骤，我觉得不错，这里直接对其进行翻译：</p><ul><li>学习<code>Matplotlib</code>中常用的术语，尤其是什么是<code>Figure</code>以及<code>Axes</code>；</li><li>使用<code>object-oriented interface</code>，在开始分析之前就养成这种习惯；</li><li>从基本的<code>pandas</code>绘图开始进行可视化操作；</li><li>使用<code>Seaborn</code>进行<strong>更加复杂的统计可视化</strong>；</li><li>使用<code>Matplotlib</code>来对<code>pandas</code>和<code>Seaborn</code>做的图进行<strong>自定义</strong>；</li><li>有了<code>Matplotlib</code>基础再根据需求学习其他的绘图<code>package</code>，比如<code>plotly</code>等.</li></ul><p><br></p><h2 id="图形的组件"><a href="#图形的组件" class="headerlink" title="图形的组件"></a>图形的组件</h2><p><code>Matplotlib Usage</code>中对图形的<strong>每个部分</strong>有个很好的图示说明：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/figure_element.png" alt="figure_element.png"></p><p><strong>了解图形组件的意义</strong>：</p><blockquote><p>Once you understand what these are and how to access them through the object oriented API, the rest of the process starts to fall into place.</p></blockquote><blockquote><p>The other benefit of this knowledge is that you <strong>have a starting point when you see things on the web</strong>. If you take the time to understand this point, <strong>the rest of the matplotlib API will start to make sense</strong>. Also, many of the advanced python packages like seaborn and ggplot rely on matplotlib so understanding the basics will <strong>make those more powerful frameworks much easier to learn</strong>.</p></blockquote><h3 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h3><p><code>Figure</code>涵盖了<strong>整个图片的内容</strong>，包括所有的<code>Axes</code>、a smattering of ‘special’ artists (<code>titles</code>, <code>figure legends</code>, etc)以及<code>canvas</code>(很重要的一个组成成分，是实际绘图和获取图像的部分，但是<strong>对于user来说是不可见的</strong>，具体可以看后面<a href="#artist">Artist部分</a>)。</p><p><code>Figure</code>可以包含任意数目的<code>Axes</code>，但要有用，最少要包含一个，也就是说常规的(<code>object-oriented interface</code>)，<strong>一个<code>Figure</code>可以包括一个或多个<code>Axes</code></strong>。</p><p>创建<code>Figure</code>最简单的方法是使用<code>pyplot</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># an empty figure with no axes</span></span><br><span class="line"><span class="comment"># 适用于state-based(Pyplot) interface</span></span><br><span class="line">fig = plt.figure()  </span><br><span class="line"><span class="comment"># a figure with a 2x2 grid of Axes</span></span><br><span class="line">fig, ax_lst = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a>Axes</h3><p><code>Axes</code>就是<strong>所谓的(子)图的概念</strong>，它是具有数据空间的图像区域。<strong>一个给定的<code>Figure</code>可以包含多个<code>Axes</code>，但是一个给定的<code>Axes</code>只能是某一个<code>Figure</code>的一部分</strong>。</p><p>一个<code>Axes</code>包括两个或三个<code>Axis</code>对象(注意区分<code>Axes</code>和<code>Axis</code>，前者是图，后者是图片的<code>X/Y</code>轴)；每个<code>Axes</code>包括一个<code>title</code>、<code>x-label</code>、<code>y-label</code>。</p><p><strong>打个比方：<code>Figure</code>类似于一整A4纸(画布)，然后我们将这个A4纸对折得到两个隔区，这每个隔区可以用来写字(画图)，这里的每个隔区就类似于<code>Axes</code></strong>。</p><hr><h3 id="Axis"><a href="#Axis" class="headerlink" title="Axis"></a>Axis</h3><p><code>Axis</code>是<code>number-line-like objects</code>，主要是用来设置图形的<code>(x、y)limits</code>以及产生<code>ticks</code>(凸起的小刻度线)和<code>ticklabels</code>(小刻度线对应的数值)。<code>ticks</code>的位置是由<a href="https://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Locator" target="_blank" rel="noopener">Locator</a>对象决定的，<code>ticklabel</code>是由<a href="https://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Formatter" target="_blank" rel="noopener">Formatter</a>对象决定的，正确使用这两个对象可以很好地控制<code>ticks</code>以及<code>ticklabels</code>。</p><p><strong><code>Figure</code>、<code>Axes</code>以及<code>Axis</code>关系的图示</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Figure_Axes_Axis.png" alt="Figure_Axes_Axis.png"></p><hr><h3 id="Artist"><a href="#Artist" class="headerlink" title="Artist"></a>Artist</h3><p>在<strong>图中所有可以看见的部分基本上都是artist(甚至包括前面提到的<code>Figure</code>、<code>Axes</code>和<code>Axis</code>)</strong>，其包括：<code>Text</code>对象、<code>Line2D</code>对象、<code>collection</code>对象以及<code>Patch</code>对象等。在绘制图形时，所有的<code>artists</code>都会画在<code>canvas</code>(用户不可见)上。大部分的<code>artists</code>都绑定在<code>Axes</code>上，<strong>因此<code>artists</code>不能被共享或者进行移动</strong>。</p><p><strong>补充说明关于<code>Artist</code>、<code>Renderer</code>、<code>FigureCanvas</code>之间关系</strong>：</p><p><code>Matplotlib</code>绘图过程与人自身绘图过程的类比：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Artist_Renderer_FigureCanvas.png" alt="Artist_Renderer_FigureCanvas.png"></p><p>想想平时我们怎么画图，是不是分三步:</p><ul><li><strong>找画板</strong>——解决图画在哪的问题</li><li><strong>用调色板</strong>——解决用什么画的问题</li><li><strong>画画</strong>——解决谁来画、怎么画的问题</li></ul><p><code>Matplotlib</code> 模拟了类似过程，也分三步：</p><ul><li><code>FigureCanvas</code></li><li><code>Renderer</code></li><li><code>Artist</code></li></ul><p>上面是 <code>Matplotlib</code> 里的三层 <code>API</code>：</p><ul><li><code>FigureCanvas</code>——帮你确定画图的地方</li><li><code>Renderer</code>——帮你把想画的东西展示在屏幕上</li><li><code>Artist</code>——帮你用 <code>Renderer</code> 在 <code>Canvas</code> 上画图</li></ul><hr><h2 id="画图所需的数据类型"><a href="#画图所需的数据类型" class="headerlink" title="画图所需的数据类型"></a>画图所需的数据类型</h2><p><strong>所有的绘图函数都以<code>np.array</code>或者<code>np.ma.masked_array</code>作为输入</strong>，其他的<code>array-like</code>对象<strong>如<code>pandas</code>的数据对象以及<code>np.matrix</code>可能不会很好的<code>work</code></strong>，最好能将这些数据对象在绘图之前转为<code>np.array</code>对象。</p><p>当然<code>pandas</code>中的数据对象可以直接使用<code>pandas</code>内置的画图方法，也是基于<code>Matplotlib</code>的。</p><p><br></p><h2 id="Matplotlib、pyplot、pylab之间的关系"><a href="#Matplotlib、pyplot、pylab之间的关系" class="headerlink" title="Matplotlib、pyplot、pylab之间的关系"></a>Matplotlib、pyplot、pylab之间的关系</h2><p><code>Matplotlib</code>是整个<code>package</code>的名称，而<code>matplotlib.pyplot</code>是<code>Matplotlib</code>中的一个<code>module</code>，而<code>pylab</code>是在伴随着<code>matplotlib</code>一块安装的<code>module</code>。</p><p><code>Pyplot</code>为基础的<code>object-oriented interface</code>提供了<code>state-based interface</code>(前面提到了<code>object-oriented interface</code>中也会用到<code>state-based interface</code>中创建和保存图片的功能)。<code>state-based interface</code>会<strong>显式或者隐式地创建<code>Figure</code>和<code>Axes</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 隐式创建</span></span><br><span class="line"><span class="comment"># 第一次调用plt.plot会自动创建figure和axes</span></span><br><span class="line">plt.plot(x, x, label=<span class="string">'linear'</span>)</span><br><span class="line"><span class="comment"># 后续的plt.plot会使用当前的axes，直接添加一条线</span></span><br><span class="line">plt.plot(x, x**<span class="number">2</span>, label=<span class="string">'quadratic'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">3</span>, label=<span class="string">'cubic'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置title、legend以及axis labels也会使用当前的axes</span></span><br><span class="line">plt.xlabel(<span class="string">'x label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y label'</span>)</span><br><span class="line">plt.title(<span class="string">"Simple Plot"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><p><code>pylab</code> is a convenience module that <strong><code>bulk imports</code> <code>matplotlib.pyplot</code> (for plotting) and <code>numpy</code> (for mathematics and working with arrays) in a single name space.</strong> Although many examples use pylab, <strong>it is no longer recommended</strong>.</p><p><mark>对于非交互式绘图，推荐使用pyplot来创建图片，然后使用object-oriented interface进行绘图</mark></p><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://matplotlib.org/faq/usage_faq.html" target="_blank" rel="noopener">Matplotlib Usage</a></li><li><a href="https://matplotlib.org/tutorials/introductory/lifecycle.html" target="_blank" rel="noopener">The Lifecycle of a Plot</a></li><li><a href="https://pbpython.com/effective-matplotlib.html" target="_blank" rel="noopener">Effectively Using Matplotlib</a></li><li><a href="https://www.jianshu.com/p/ebe721199d72" target="_blank" rel="noopener">Python 绘图，我只用 Matplotlib（一）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&amp;mid=2247487597&amp;idx=2&amp;sn=e2a61c9637900d7bcb3fb658a28758a3&amp;chksm=fb39b566cc4e3c70fc6d06c5be5b962dee3e68ce66e51b03533db5cd9fd60cd0c51a64fb3d3f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1571474906951&amp;sharer_shareid=1b54e58f922202bb93a6ffe28bb2f3a7&amp;key=7fbd4d18e8fd1c6fff6d9c4f75a5f7a7aa84450f1bafdbddcb15955ec1c1602ad5b32e505be4f4262cb7c3a654ae46ad1f778ab74bfca91c73afbcc665063b69ce1f6fe3338b9a0ae66edf55bbfdbebc&amp;ascene=1&amp;uin=MjU2NzcxOTIxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060841&amp;lang=zh_CN&amp;pass_ticket=GwsbQV788IMD6AiagF%2BPxa50XmG0oazH9xqtxGhmt5vIPH0QkD3SChoH46%2Fsdj%2FX" target="_blank" rel="noopener">干货：一文掌握Matplotlib的使用方法</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Matplotlib中文显示</title>
      <link href="/posts/60218.html"/>
      <url>/posts/60218.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux</code>下如何让<code>matplotlib</code>可以<strong>正确地显示中文</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习使用<code>matplotlib</code>画图过程中<strong>遇到了中文显示的问题</strong>，在<code>google</code>上搜索了很多结果，按照这些结果都不能正确显示(<strong>大部分的博客都是互相抄的，没有经过自己的实验验证，这也坚定了我自己写blog的决心</strong>)，所以这里自己记录一下。</p><hr><h2 id="查找matplotlib字体文件夹"><a href="#查找matplotlib字体文件夹" class="headerlink" title="查找matplotlib字体文件夹"></a>查找matplotlib字体文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找matplotlib配置文件的位置</span></span><br><span class="line">import matplotlib</span><br><span class="line">matplotlib.matplotlib_fname()</span><br><span class="line">  /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体文件夹和这个文件在同一目录</span></span><br><span class="line">ll /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data</span><br><span class="line">  drwxr-xr-x. 2 root root 4.0K Aug  8 22:27 stylelib</span><br><span class="line">  drwxr-xr-x. 2 root root 4.0K Aug  8 22:27 images</span><br><span class="line">  -rw-rw-r--. 2 root root  33K Jul 24 13:42 matplotlibrc</span><br><span class="line">  drwxr-xr-x. 5 root root   61 Apr 11  2019 fonts</span><br></pre></td></tr></table></figure><hr><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><p>这个具体的操作参考<a href="http://showteeth.tech/posts/358.html">Linux系列之添加中文字体</a></p><hr><h2 id="查找和更新matplotlib中文缓存"><a href="#查找和更新matplotlib中文缓存" class="headerlink" title="查找和更新matplotlib中文缓存"></a>查找和更新matplotlib中文缓存</h2><h3 id="查找字体缓存地址"><a href="#查找字体缓存地址" class="headerlink" title="查找字体缓存地址"></a>查找字体缓存地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字体缓存地址</span></span><br><span class="line"><span class="comment"># 最好是直接输出这个目录的绝对路径</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.get_cachedir()</span><br><span class="line">  <span class="comment"># /home/user/.cache/matplotlib</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除字体缓存"><a href="#删除字体缓存" class="headerlink" title="删除字体缓存"></a>删除字体缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到字体缓存地址后，可以将其中的缓存信息全部删除</span></span><br><span class="line">rm -rf /home/user/.cache/matplotlib/*</span><br></pre></td></tr></table></figure><hr><h3 id="直接更新字体缓存"><a href="#直接更新字体缓存" class="headerlink" title="直接更新字体缓存"></a>直接更新字体缓存</h3><p>除了上面的<strong>手动删除字体缓存</strong>之外，可以<strong>直接使用python语句更新字体缓存</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> _rebuild</span><br><span class="line">_rebuild()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用中文字体"><a href="#使用中文字体" class="headerlink" title="使用中文字体"></a>使用中文字体</h2><p><strong>上述更新完缓存之后，如果是<code>jupyter</code>，一定要重启一次，切记，不然不会生效</strong>。</p><h3 id="暂时使用中文字体"><a href="#暂时使用中文字体" class="headerlink" title="暂时使用中文字体"></a>暂时使用中文字体</h3><p><strong>在<code>Python</code>中指明使用的中文字体</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>]= <span class="string">'SimHei'</span> <span class="comment"># 指定字体，实际上相当于修改 matplotlibrc 文件　只不过这样做是暂时的　下次失效</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment"># 正确显示负号，防止变成方框</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用如下命令也行</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>] <span class="comment">#用来正常显示中文标签 </span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment">#用来正常显示负号</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y,label=<span class="string">"$sin(x)$"</span>,color=<span class="string">"red"</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">"t轴"</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y轴'</span>)</span><br><span class="line">plt.title(<span class="string">'中文'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="永久使用中文字体"><a href="#永久使用中文字体" class="headerlink" title="永久使用中文字体"></a>永久使用中文字体</h3><p>如果想要一次修改永久使用，可以直接修改<code>matplotlibrc</code>文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件地址在第一步就已经得到了</span></span><br><span class="line">vim /home/softwares/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改如下内容：</span></span><br><span class="line"><span class="comment">## SimHei必须写在font.sans-serif的第一位，不然不会生效</span></span><br><span class="line">font.family         : sans-serif        </span><br><span class="line">font.sans-serif     : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif <span class="comment"># 在其中添加中文字体名</span></span><br><span class="line">axes.unicode_minus  :False，<span class="comment">#作用就是解决负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zsxh.github.io/blog/2018/05/28/matplotlib%20%E5%9C%A8%20Linux%20Deepin%20%E4%B8%8B%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/" target="_blank" rel="noopener">matplotlib 在 Linux Deepin 下中文显示</a></li><li><a href="https://zodiac911.github.io/blog/matplotlib-chinese.html" target="_blank" rel="noopener">让Matplotlib正确显示中文</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之添加中文字体</title>
      <link href="/posts/358.html"/>
      <url>/posts/358.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux(centos)</code>下<strong>安装(中文)字体</strong>的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>Python</code>画图的时候发现中文乱码，想要进行中文的显示就需要系统有中文字体，但是<code>centos</code>默认是没有中文字体的，所以就需要下载，这里记录一下下载安装过程。</p><hr><h2 id="查看已安装字体"><a href="#查看已安装字体" class="headerlink" title="查看已安装字体"></a>查看已安装字体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装字体配置相关库</span></span><br><span class="line">yum install -y fontconfig mkfontscale</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装的字体</span></span><br><span class="line"><span class="built_in">fc</span>-list</span><br><span class="line">  /usr/share/fonts/default/Type1/c059016l.pfb: Century Schoolbook L:style=Bold</span><br><span class="line">  /usr/share/fonts/default/Type1/c059033l.pfb: Century Schoolbook L:style=Italic</span><br><span class="line">  /usr/share/fonts/default/Type1/p052024l.pfb: URW Palladio L:style=Bold Italic</span><br><span class="line">  /usr/share/fonts/default/Type1/d050000l.pfb: Dingbats:style=Regular</span><br><span class="line">  /usr/share/fonts/default/Type1/s050000l.pfb: Standard Symbols L:style=Regular</span><br><span class="line">  /usr/share/fonts/liberation/LiberationMono-Bold.ttf: Liberation Mono:style=Bold</span><br><span class="line">  /usr/share/fonts/default/Type1/n021003l.pfb: Nimbus Roman No9 L:style=Regular</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装了的中文字体</span></span><br><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line">  <span class="comment"># 没有结果输出，说明没有安装到中文字体</span></span><br></pre></td></tr></table></figure><hr><h2 id="部分中文字体的英文名"><a href="#部分中文字体的英文名" class="headerlink" title="部分中文字体的英文名"></a>部分中文字体的英文名</h2><table><tr><th width="25%">中文字体</th><th width="25%">英文名</th><th width="25%">中文字体</th><th width="25%">英文名</th></tr><tr><td>宋体</td><td>SimSun</td><td>华文细黑</td><td>STXihei</td></tr><tr><td>黑体</td><td>SimHei</td><td>华文楷体</td><td>STKaiti</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>华文宋体</td><td>STSong</td></tr><tr><td>微软正黑体</td><td>Microsoft JhengHei</td><td>华文中宋</td><td>STZhongsong</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>华文仿宋</td><td>STFangsong</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>方正舒体</td><td>FZShuTi</td></tr><tr><td>细明体</td><td>MingLiU</td><td>方正姚体</td><td>FZYaoti</td></tr><tr><td>标楷体</td><td>DFKai-SB</td><td>华文彩云</td><td>STCaiyun</td></tr><tr><td>仿宋</td><td>FangSong</td><td>华文琥珀</td><td>STHupo</td></tr><tr><td>楷体</td><td>KaiTi</td><td>华文隶书</td><td>STLiti</td></tr><tr><td>隶书</td><td>LiSu</td><td>华文行楷</td><td>STXingkai</td></tr><tr><td>幼圆</td><td>YouYuan</td><td>华文新魏</td><td>STXinwei</td></tr></table><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><ul><li><strong>创建字体目录</strong>：在<code>linux</code>下的<code>/usr/share/fonts</code>目录中创建目录：<code>mkdir chinese</code></li><li><strong>复制字体</strong>：在<code>windows</code>下的<code>C:\Windows\Fonts</code>目录中选择自己想要的字体移动到刚刚在<code>linux</code>上创建的<code>chinese</code>目录</li><li><strong>下载字体</strong>：从<a href="https://github.com/tracyone/program_font" target="_blank" rel="noopener">github</a>上下载字体</li><li><strong>安装字体</strong>：建立字体索引信息，更新字体缓存。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里一共有三个字体：宋体、微软雅黑、中易黑体</span></span><br><span class="line">-rw-r--r--. 1 root root 9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">-rw-r--r--. 1 root root 18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">-rw-r--r--. 1 root root 19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改目录权限，可选操作</span></span><br><span class="line">chmod -R 755 /usr/share/fonts/chinese</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立字体索引信息，更新字体缓存</span></span><br><span class="line">mkfontscale</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line">mkfontdir</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.dir</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br><span class="line"></span><br><span class="line"><span class="built_in">fc</span>-cache</span><br><span class="line">  total 37M</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.dir</span><br><span class="line">  -rw-r--r--. 1 root root 1.1K Oct 12 10:04 fonts.scale</span><br><span class="line">  -rw-r--r--. 1 root root  9.4M Oct 12 10:01 simhei.ttf</span><br><span class="line">  -rw-r--r--. 1 root root  18M Oct 12 09:58 SIMSUN.TTC</span><br><span class="line">  -rw-r--r--. 1 root root  19M Oct 12 09:57 MSYH.TTC</span><br></pre></td></tr></table></figure><hr><h2 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line">  <span class="comment"># 相比于第一次运行没有结果输出，这里出现了字体添加的中文字体</span></span><br><span class="line">  /usr/share/fonts/chinese/MSYH.TTC: Microsoft YaHei:style=Normal</span><br><span class="line">  /usr/share/fonts/chinese/SIMSUN.TTC: SimSun,宋体:style=Regular,常规</span><br><span class="line">  /usr/share/fonts/chinese/MSYH.TTC: Microsoft YaHei UI:style=Normal</span><br><span class="line">  /usr/share/fonts/chinese/SIMSUN.TTC: NSimSun,新宋体:style=Regular,常规</span><br><span class="line">  /usr/share/fonts/chinese/simhei.ttf: SimHei:style=Regular,Normal</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ilanni.com/?p=11746" target="_blank" rel="noopener">linux安装中文字体</a></li><li><a href="https://www.cnblogs.com/cuishuai/p/8441132.html" target="_blank" rel="noopener">Centos7 安装字体库&amp;中文字体</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Linux安装scipy</title>
      <link href="/posts/34795.html"/>
      <url>/posts/34795.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Python2.7</code>环境下安装<code>scipy</code>过程中遇到的一些问题以及爬坑过程(解决方案).</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近实验室的师姐在分析数据的时候需要用到一个软件，该软件依赖于<code>Python2.7</code>以及<code>scipy</code>、<code>numpy</code>包的，但师姐在安装scipy中遇到了一些问题，我在解决的时候也发现了<strong>很多陷阱</strong>，这里记录一下。</p><hr><h2 id="安装之路"><a href="#安装之路" class="headerlink" title="安装之路"></a>安装之路</h2><h3 id="直接pip安装默认scipy"><a href="#直接pip安装默认scipy" class="headerlink" title="直接pip安装默认scipy"></a>直接pip安装默认scipy</h3><p>安装<code>python</code>包最简单粗暴的方法就是直接上<code>pip</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pip之前先更新一波</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接pip安装scipy</span></span><br><span class="line">pip install scipy</span><br></pre></td></tr></table></figure><p></p><p><strong>直接报错，报错信息如下</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Python version &gt;= 3.5 required.</span><br></pre></td></tr></table></figure><p></p><p>上述报错提示需要<code>Python</code>版本<code>&gt;=3.5</code>才可以安装，但是我用的是<code>python2</code>的<code>pip</code>啊，为什么不能直接安装<code>python2</code>对应的<code>scipy</code>版本呢？</p><p><strong>原因猜测</strong>：在<a href="https://github.com/scipy/scipy/releases" target="_blank" rel="noopener">scipy的github</a>上可以发现现在的<strong>scipy会有两个不同的更新</strong>，一个是<code>1.3.x</code>的还有一个就是<code>1.2.x</code>的更新，仔细看两种版本的更新可以发现：<code>1.3.x</code>支持的是<code>Python 3.5+</code>的版本，没有提供<code>Python 2.x</code>版本的安装信息；而与之对应的<code>1.2.x</code>版本的就有提供<code>Python 2.x</code>版本的安装文件。基于上述判断，<strong>直接使用<code>pip</code>安装可能会默认安装<code>scipy 1.3.x</code>，也就是<code>Python 3.5+</code>的版本，所以可以尝试使用<code>pip</code>安装指定的版本。</strong></p><hr><h3 id="使用whl文件安装指定版本scipy"><a href="#使用whl文件安装指定版本scipy" class="headerlink" title="使用whl文件安装指定版本scipy"></a>使用whl文件安装指定版本scipy</h3><p>从<a href="https://github.com/scipy/scipy/releases" target="_blank" rel="noopener">github上scipy的release处</a>下载<code>1.2.2</code>版本的<code>scipy</code>的<code>whl</code>文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中的cp27就是python2.7的意思</span></span><br><span class="line">wget https://github.com/scipy/scipy/releases/download/v1.2.2/scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完成之后使用pip安装</span></span><br><span class="line">pip install scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl</span><br></pre></td></tr></table></figure><p></p><p><strong>再次出现报错</strong>，报错信息如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 报错信息</span></span><br><span class="line">scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br><span class="line">Storing debug <span class="built_in">log</span> <span class="keyword">for</span> failure <span class="keyword">in</span> /root/.pip/pip.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># log文件内容：</span></span><br><span class="line">cat /root/.pip/pip.log</span><br><span class="line">  ------------------------------------------------------------</span><br><span class="line">  /usr/bin/pip run on Tue Oct  8 09:03:00 2019</span><br><span class="line">  scipy-1.2.2-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br><span class="line">  Exception information:</span><br><span class="line">  Traceback (most recent call last):<span class="comment">#   File "/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/basecommand.py", line 122, in main</span></span><br><span class="line">      status = self.run(options, args)</span><br><span class="line">    File <span class="string">"/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/commands/install.py"</span>, line 257, <span class="keyword">in</span> run</span><br><span class="line">      InstallRequirement.from_line(name, None))</span><br><span class="line">    File <span class="string">"/usr/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/req.py"</span>, line 167, <span class="keyword">in</span> from_line</span><br><span class="line">      raise UnsupportedWheel(<span class="string">"%s is not a supported wheel on this platform."</span> % wheel.filename)</span><br><span class="line">  UnsupportedWheel: scipy-1.2.2-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform.</span><br></pre></td></tr></table></figure><p></p><p>报错信息提示说该whl文件不是一个目前系统支持的文件，然后我查看了该系统支持的文件信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统可以支持的版本</span></span><br><span class="line">&gt;&gt;&gt; import pip; <span class="built_in">print</span>(pip.pep425tags.get_supported())</span><br><span class="line">[(<span class="string">'cp27'</span>, <span class="string">'none'</span>, <span class="string">'linux_x86_64'</span>), (<span class="string">'cp27'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp2'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp26'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp25'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp24'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp23'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp22'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp21'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'cp20'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py27'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py2'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py26'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py25'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py24'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py23'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py22'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py21'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>), (<span class="string">'py20'</span>, <span class="string">'none'</span>, <span class="string">'any'</span>)]</span><br></pre></td></tr></table></figure><p></p><p>通过前面命令发现下载的文件确实<strong>不是系统支持的</strong>，但是在<code>scipy</code>官网上也<strong>没找到完全符合上面信息的文件</strong>，但是<a href="https://stackoverflow.com/questions/28568070/filename-whl-is-not-supported-wheel-on-this-platform" target="_blank" rel="noopener">从这里</a>发现可以<strong>直接修改文件名称</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改名</span></span><br><span class="line">mv scipy-1.2.2-cp27-cp27mu-manylinux1_x86_64.whl scipy-1.2.2-cp27-none-linux_x86_64.whl</span><br><span class="line">pip install scipy-1.2.2-cp27-none-linux_x86_64.whl</span><br><span class="line"><span class="comment"># 还是报错：RuntimeError: Python version &gt;= 3.5 required.</span></span><br></pre></td></tr></table></figure><p></p><p>因为<strong>改名字在我看来确实不是一个很科学的做法</strong>，加上<strong>后续又报错了</strong>，所以就<strong>放弃了这个做法</strong>，转而使用下一个方法安装指定版本的scipy。</p><div class="note info"><p>关于<code>whl</code>文件：</p><ul><li>A Distribution format <strong>containing files and metadata that only need to be moved to the correct location on the target system, to be installed</strong>. Wheel is such a format, whereas distutil’s Source Distribution is not, in that it requires a build step before it can be installed. <strong>This format does not imply that Python files have to be precompiled (Wheel intentionally does not include compiled Python files)</strong>. <a href="https://packaging.python.org/glossary/#term-built-distribution" target="_blank" rel="noopener">参考链接</a></li><li><a href="https://fileinfo.com/extension/whl" target="_blank" rel="noopener">There are three types of WHL files</a>:<ul><li><code>Universal Wheel</code> - It <strong>only contains Python files</strong>, <strong>no compiled extensions</strong>, and <strong>natively supports Python 2 and 3</strong>.</li><li><code>Pure Python Wheel</code> - It <strong>only contains Python files and no compiled extensions</strong>, but does <strong>not natively support Python 2 and 3</strong>.</li><li><code>Platform Wheel</code> - It <strong>contains Python files and compiled extensions</strong> but does <strong>not natively support Python 2 and 3</strong>. This type of wheel is <strong>specific to a platform</strong>, such as Windows or macOS, because it contains compiled extensions.</li></ul></li></ul></div><hr><h3 id="使用pip安装指定版本的scipy"><a href="#使用pip安装指定版本的scipy" class="headerlink" title="使用pip安装指定版本的scipy"></a>使用pip安装指定版本的scipy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接安装指定版本的scipy</span></span><br><span class="line">pip install scipy==1.2.2</span><br><span class="line"><span class="comment"># 出现如下报错信息</span></span><br><span class="line">  Collecting numpy&gt;=1.8.2 (from scipy==1.2.2)</span><br><span class="line">  ERROR: multicoretsne 0.1 requires cffi, <span class="built_in">which</span> is not installed.</span><br><span class="line">  Installing collected packages: numpy, scipy</span><br><span class="line">    Found existing installation: numpy 1.7.1</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p>上述报错有两个方面，一是缺少<code>cffi</code>包，二是发现已经安装了<code>numpy</code>，并且版本是<code>1.7.1</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装cffi</span></span><br><span class="line">pip install cffi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行</span></span><br><span class="line">pip install scipy==1.2.2</span><br><span class="line"><span class="comment"># cffi的报错解决，numpy的问题依旧存在</span></span><br><span class="line">  Collecting numpy&gt;=1.8.2 (from scipy==1.2.2)</span><br><span class="line">  Installing collected packages: numpy, scipy</span><br><span class="line">    Found existing installation: numpy 1.7.1</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p></p><p>查看<code>numpy</code>版本以及更新或者卸载<code>numpy</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看numpy版本</span></span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt; numpy.__version__</span><br><span class="line"><span class="string">'1.7.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载numpy</span></span><br><span class="line">pip uninstall numpy</span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级numpy</span></span><br><span class="line">pip install --upgrade numpy</span><br><span class="line">  ERROR: Cannot uninstall <span class="string">'numpy'</span>. It is a distutils installed project and thus we cannot accurately determine <span class="built_in">which</span> files belong to it <span class="built_in">which</span> would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p></p><p>上面尝试升级或者删除<code>numpy</code>包均报错，提示numpy是<code>distutils installed project</code>，所以不能进行卸载。</p><p>随后在<a href="https://stackoverflow.com/questions/50421287/pip-cannot-uninstall-ipython-it-is-a-distutils-installed-project-and-thus-w" target="_blank" rel="noopener">这篇文章</a>中发现，可以添加参数来忽略已经安装的numpy，从而进行下一版本的安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略已安装的版本</span></span><br><span class="line">pip install --ignore-installed -U numpy</span><br><span class="line"><span class="comment"># 可以安装numpy和scipy，但是在python中导入numpy模块的时候报错</span></span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/numpy/__init__.py"</span>, line 142, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from . import core</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/numpy/core/__init__.py"</span>, line 91, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raise ImportError(msg.format(path))</span><br><span class="line">ImportError: Something is wrong with the numpy installation. While importing we detected an older version of numpy <span class="keyword">in</span> [<span class="string">'/usr/lib64/python2.7/site-packages/numpy'</span>]. One method of fixing this is to repeatedly uninstall numpy until none is found, <span class="keyword">then</span> reinstall this version.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line"><span class="comment">## 进入安装目录：/usr/lib64/python2.7/site-packages</span></span><br><span class="line"><span class="comment">## 再次尝试导入numpy即可</span></span><br><span class="line">rm numpy-1.7.1-py2.7.egg-info</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>问题虽然解决了，但是仍然<strong>有一些疑惑需要解答</strong>：什么是<code>distutils installed project</code>，为什么不能通过<strong>pip升级和卸载</strong>？</p><blockquote><p>This error means that <strong>this package’s metadata doesn’t include a list of files that belong to it</strong>. Most probably, you have installed this package <code>via your OS&#39; package manager(比如apt、yum)</code>, so you need to use that <code>rather than pip to update or remove it, too</code>. <a href="https://stackoverflow.com/questions/53807511/pip-cannot-uninstall-package-it-is-a-distutils-installed-project" target="_blank" rel="noopener">参考链接</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-实现字母和数字的混合排序</title>
      <link href="/posts/10477.html"/>
      <url>/posts/10477.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了使用<code>Python</code>对<strong>字母和数字混合的字符串</strong>进行排序的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际工作中经常会遇到需要将带有字母和数字的字符串进行混合排序，在linux中可以使用<a href="http://showteeth.tech/posts/61024.html">sort加上-V参数</a>轻松实现，但是在Python中并没有这种类似的参数，所以需要自己进行设置。</p><hr><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>Python脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将可以转化为数字的转化为数字</span></span><br><span class="line"><span class="comment"># 不可以转化的保留原始类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryint</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> int(s)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="comment"># 也可以使用</span></span><br><span class="line">    <span class="comment"># return int(s) if s.isdigit() else s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字母和数字分开</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alphanum_key</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">""" Turn a string into a list of string and number chunks.</span></span><br><span class="line"><span class="string">        "z23a" -&gt; ["z", 23, "a"]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> [ tryint(c) <span class="keyword">for</span> c <span class="keyword">in</span> re.split(<span class="string">'([0-9]+)'</span>, s) ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_nicely</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="string">""" Sort the given list in the way that humans expect.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 使用alphanum_key作为key进行排序</span></span><br><span class="line">    l.sort(key=alphanum_key)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alist=[</span><br><span class="line">    <span class="string">"something1"</span>,</span><br><span class="line">    <span class="string">"something12"</span>,</span><br><span class="line">    <span class="string">"something17"</span>,</span><br><span class="line">    <span class="string">"something2"</span>,</span><br><span class="line">    <span class="string">"something25"</span>,</span><br><span class="line">    <span class="string">"somethingM"</span>]</span><br><span class="line">alist.sort(key=alphanum_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">[<span class="string">'something1'</span>,</span><br><span class="line"> <span class="string">'something2'</span>,</span><br><span class="line"> <span class="string">'something12'</span>,</span><br><span class="line"> <span class="string">'something17'</span>,</span><br><span class="line"> <span class="string">'something25'</span>,</span><br><span class="line"> <span class="string">'somethingM'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://nedbatchelder.com/blog/200712/human_sorting.html" target="_blank" rel="noopener">Human sorting</a></li><li><a href="https://stackoverflow.com/questions/4836710/does-python-have-a-built-in-function-for-string-natural-sort" target="_blank" rel="noopener">Does Python have a built in function for string natural sort?</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML语言学习</title>
      <link href="/posts/64657.html"/>
      <url>/posts/64657.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文依据<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a>结合<strong>python中对yaml的调用</strong>对<code>yaml</code>语言进行了学习，主要包括其<strong>语法</strong>和<strong>数据结构</strong>，为以后<strong>使用<code>yaml</code>编写配置文件</strong>打下基础。</p></div><a id="more"></a><h2 id="yaml简介"><a href="#yaml简介" class="headerlink" title="yaml简介"></a>yaml简介</h2><p>编程免不了要<strong>写配置文件</strong>，怎么写配置也是一门学问。<code>YAML</code> 是<strong>专门用来写配置文件的语言，非常简洁和强大</strong>，远比 <code>JSON</code> 格式方便。</p><p><code>YAML</code> 语言（发音 <code>/ˈjæməl/</code> ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p><p><code>YAML</code>的基本语法和规则如下：</p><ul><li><strong>大小写敏感</strong></li><li>使用<strong>缩进表示层级关系</strong></li><li><mark>缩进时不允许使用Tab键，只允许使用空格</mark></li><li>缩进的<strong>空格数目不重要</strong>，只要<strong>相同层级的元素左侧对齐即可</strong></li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p><code>YAML</code>支持的数据结构：</p><ul><li><code>对象</code>：<strong>键值对的集合</strong>，又称为<code>映射（mapping）</code>/ <code>哈希（hashes）</code> / <code>字典（dictionary）</code></li><li><code>数组</code>：一组按次序排列的值，又称为<code>序列（sequence）</code> / <code>列表（list）</code></li><li><code>纯量（scalars）</code>：单个的、不可再分的值</li></ul><p>以下分别介绍这三种数据结构。</p><hr><p><br></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="单层字典"><a href="#单层字典" class="headerlink" title="单层字典"></a>单层字典</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure><p>使用python进行解析：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.yaml'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = yaml.load(f)</span><br><span class="line"><span class="keyword">print</span> (data)</span><br></pre></td></tr></table></figure><p></p><p>解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典的形式</span></span><br><span class="line">&#123;<span class="string">'animal'</span>: <span class="string">'pets'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="嵌套字典"><a href="#嵌套字典" class="headerlink" title="嵌套字典"></a>嵌套字典</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">Steve</span></span><br><span class="line"><span class="attr">  foo:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套的字典</span></span><br><span class="line">&#123;<span class="string">'hash'</span>: &#123;<span class="string">'name'</span>: <span class="string">'Steve'</span>, <span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p></p><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">Steve,</span> <span class="attr">foo:</span> <span class="string">bar</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'hash'</span>: &#123;<span class="string">'name'</span>: <span class="string">'Steve'</span>, <span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>一组短横线开头的行，构成一个列表。</p><h3 id="单层列表"><a href="#单层列表" class="headerlink" title="单层列表"></a>单层列表</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析之后得到列表</span></span><br><span class="line">[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>短横线开头(不需要加任何标识)，然后空格缩进之后再添加短横线就可以得到嵌套列表：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Goldfish</span></span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p></p><p>python解析：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析得到嵌套列表</span></span><br><span class="line">[[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>], [<span class="string">'test'</span>]]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字典-列表"><a href="#字典-列表" class="headerlink" title="字典+列表"></a>字典+列表</h3><p>可以将字典和列表进行组合，达到以列表作为键值的字典的目的：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">[</span> <span class="string">'Cat'</span><span class="string">,</span> <span class="string">'Dog'</span> <span class="string">]</span> </span><br><span class="line"><span class="attr">fruit:</span> <span class="string">'apple'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析得到以列表作为键值的字典</span></span><br><span class="line">&#123;<span class="string">'animal'</span>: [<span class="string">'Cat'</span>, <span class="string">'Dog'</span>], <span class="string">'fruit'</span>: <span class="string">'apple'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line"><span class="attr"> Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span> </span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure><p>python解析的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'languages'</span>: [<span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span>], </span><br><span class="line">  <span class="string">'websites'</span>: &#123;<span class="string">'YAML'</span>: <span class="string">'yaml.org'</span>, <span class="string">'Ruby'</span>: <span class="string">'ruby-lang.org'</span>, <span class="string">'Python'</span>: <span class="string">'python.org'</span>, <span class="string">'Perl'</span>: <span class="string">'use.perl.org'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于python的纯量：</p><ul><li><strong>字符串</strong>：使用引号或者双引号</li><li><strong>布尔值</strong>：<code>true</code>、<code>false</code></li><li><strong>整数</strong></li><li><strong>浮点数</strong></li><li><strong>Null</strong>：使用<code>~</code>表示</li><li><strong>时间</strong></li><li><strong>日期</strong></li><li><strong>强制类型转换</strong>：使用<code>!!</code>加上需要转换的类型进行强制类型转换</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">b:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">c:</span> <span class="string">~</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">1976</span><span class="bullet">-07</span><span class="bullet">-31</span></span><br><span class="line"><span class="attr">e:</span> <span class="type">!!str</span> <span class="number">123</span></span><br><span class="line"><span class="attr">f:</span> <span class="type">!!str</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">g:</span> <span class="string">"g"</span></span><br></pre></td></tr></table></figure><p>python解析之后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'a'</span>: 0, </span><br><span class="line">  <span class="string">'b'</span>: True, </span><br><span class="line">  <span class="string">'c'</span>: None, </span><br><span class="line">  <span class="string">'date'</span>: datetime.date(1976, 7, 31), </span><br><span class="line">  <span class="string">'e'</span>: <span class="string">'123'</span>, </span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'true'</span>, </span><br><span class="line">  <span class="string">'g'</span>: <span class="string">'g'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是最常见，也是最复杂的一种数据类型，不使用引号、使用单引号、使用双引号都可以表示字符串。</p><h3 id="不使用引号"><a href="#不使用引号" class="headerlink" title="不使用引号"></a>不使用引号</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">num:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动识别数据类型</span></span><br><span class="line"><span class="comment"># 字符串解析为字符串</span></span><br><span class="line"><span class="comment"># 数字解析为数字</span></span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="string">'string'</span>, <span class="string">'num'</span>: 10&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用单引号"><a href="#使用单引号" class="headerlink" title="使用单引号"></a>使用单引号</h3><p>如果字符串之中包含空格或特殊字符，需要放在引号之中:<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="attr">a:b</span></span><br><span class="line"><span class="attr">s2:</span> <span class="string">'a:b'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然解析结果没有差异，但是添加引号更保险一些</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a:b'</span>, <span class="string">'s2'</span>: <span class="string">'a:b'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>使用单引号会对字符中的特殊符号进行转义</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号</span></span><br><span class="line"><span class="attr">s1:</span> <span class="string">'a\nb'</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对字符中的\n进行了转义</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a\\nb'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用双引号"><a href="#使用双引号" class="headerlink" title="使用双引号"></a>使用双引号</h3><p>双引号和单引号的作用相同，但是与单引号相比，双引号不会对字符串中的特殊字符进行转义：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="string">'a\nb'</span></span><br><span class="line"><span class="attr">s2:</span> <span class="string">"a\nb"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号会对特殊字符进行转义</span></span><br><span class="line"><span class="comment"># 双引号会对特殊字符进行转义</span></span><br><span class="line">&#123;<span class="string">'s1'</span>: <span class="string">'a\\nb'</span>, <span class="string">'s2'</span>: <span class="string">'a\nb'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="引号嵌套"><a href="#引号嵌套" class="headerlink" title="引号嵌套"></a>引号嵌套</h3><p>单引号中嵌套单引号，必须连续使用两个单引号转义：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号连用进行转义</span></span><br><span class="line"><span class="attr">str1:</span> <span class="string">'labor'</span><span class="string">'s day'</span></span><br><span class="line"><span class="comment"># 直接使用双引号包含单引号</span></span><br><span class="line"><span class="attr">str2:</span> <span class="string">"labor's day"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号转义和使用双引号包围解析的结果是相同的</span></span><br><span class="line">&#123;<span class="string">'str1'</span>: <span class="string">"labor's day"</span>, <span class="string">'str2'</span>: <span class="string">"labor's day"</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串换行"><a href="#字符串换行" class="headerlink" title="字符串换行"></a>字符串换行</h3><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进，<strong>换行符(<code>\n</code>)会被转为空格</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">longsting:</span> <span class="string">"this is long</span></span><br><span class="line"><span class="string"> string"</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># long和string之间会出现一个换行符</span></span><br><span class="line">&#123;<span class="string">'longsting'</span>: <span class="string">'this is long string'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="保留和折叠换行符"><a href="#保留和折叠换行符" class="headerlink" title="保留和折叠换行符"></a>保留和折叠换行符</h3><p>多行字符串可以<strong>使用<code>|</code>保留换行符(<code>\n</code>)</strong>，也可以<strong>使用<code>&gt;</code>折叠换行符</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留换行符</span></span><br><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br><span class="line"><span class="string"># 折叠换行符</span></span><br><span class="line"><span class="string"></span><span class="attr">that:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  Foo</span></span><br><span class="line"><span class="string">  Bar</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留换行符和折叠换行符</span></span><br><span class="line">&#123;<span class="string">'this'</span>: <span class="string">'Foo\nBar\n'</span>, <span class="string">'that'</span>: <span class="string">'Foo Bar'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果遇到重复内容需要多次书写，可以使用引用的方式，具体做法是借助锚点&amp;和别名*:<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp;用来建立锚点（defaults）</span></span><br><span class="line"><span class="comment"># &lt;&lt;表示合并到当前数据</span></span><br><span class="line"><span class="comment"># *用来引用锚点</span></span><br><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'defaults'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>&#125;, </span><br><span class="line">  <span class="string">'development'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'database'</span>: <span class="string">'myapp_development'</span>&#125;, </span><br><span class="line">  <span class="string">'test'</span>: </span><br><span class="line">    &#123;<span class="string">'adapter'</span>: <span class="string">'postgres'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'database'</span>: <span class="string">'myapp_test'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>列表中的示例</strong>：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="meta">&amp;showell</span> <span class="string">Steve</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Clark</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Brian</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Oren</span> </span><br><span class="line"><span class="bullet">-</span> <span class="meta">*showell</span></span><br></pre></td></tr></table></figure><p></p><p>python解析结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span>]</span><br></pre></td></tr></table></figure><p></p><p>引用实现过程：</p><ul><li>先使用<code>&amp;</code>用来建立锚点，<code>&amp;+锚点名称</code></li><li>使用<code>*+锚点名称</code>用来引用锚点</li><li><code>&lt;&lt;</code>表示合并到当前数据</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> YAML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之文件的MD5校验</title>
      <link href="/posts/60644.html"/>
      <url>/posts/60644.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中对文件完整性进行验证的命令<code>md5sum</code>，该命令可以<strong>对指定的文件生成MD5值</strong>，也可以<strong>根据已有的MD5值对文件进行完整性校验</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在学习和研究过程中，经常会从公司拿到很多数据，连同数据一起的还有md5文件；在数据传输和下载过程中，难免会遇到数据缺失的情况，所以得到数据后对数据进行校验非常重要。</p><h2 id="md5sum命令"><a href="#md5sum命令" class="headerlink" title="md5sum命令"></a>md5sum命令</h2><p><code>md5sum</code>命令用于<strong>生成文件的md5数字摘要</strong>，并<strong>可以验证文件内容是否发生了改变</strong>，间接地还可以检验两个文件内容是否完全相同。因为<code>md5sum</code>是读取文件内容来计算校验码的，因此<strong>只能验证文件内容，而无法验证文件属性</strong>，所以只要文件内容没有发生变化，<code>md5sum</code>命令都会将其判定为相同的文件。</p><h3 id="生成md5值"><a href="#生成md5值" class="headerlink" title="生成md5值"></a>生成md5值</h3><p>需要注意的是，如果<code>md5sum</code>命令后的文件使用的是<strong>相对路径</strong>，那么生成的<strong>md5值中的文件信息就是相对路径</strong>，而如果文件使用的是<strong>绝对路径</strong>，<strong>生成的md5值中的文件信息就是绝对路径</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum后的文件路径是相对路径</span></span><br><span class="line">md5sum test.sh</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  test.sh</span><br><span class="line"><span class="comment"># md5sum后的文件路径是绝对路径</span></span><br><span class="line">md5sum /home/user/learn/linux_learn/variable/test.sh</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  /home/user/learn/linux_learn/variable/test.sh</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看文件是否修改"><a href="#查看文件是否修改" class="headerlink" title="查看文件是否修改"></a>查看文件是否修改</h3><p>可以<strong>使用<code>md5sum -c</code>结合md5信息文件来判断文件是否完整</strong>，注意：<strong>这个检查是内容上的，权限和属性等的改变不会影响md5值，所以不会检测出问题</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c test.md5</span><br><span class="line">  test.sh: OK</span><br></pre></td></tr></table></figure><p></p><p><strong>md5文件中存储的文件路径必须要是正确</strong>的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 储存的md5值以及文件相对路径</span></span><br><span class="line">cat test.md5</span><br><span class="line">  76fb29a8da79d88abfbadb3796adf5c2  test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件相对路径发生变化，或者名称被修改</span></span><br><span class="line">mv test.sh test_old.sh</span><br><span class="line"></span><br><span class="line">md5sum -c test.md5</span><br><span class="line">  md5sum: test.sh: No such file or directory</span><br><span class="line">  test.sh: FAILED open or <span class="built_in">read</span></span><br><span class="line">  md5sum: WARNING: 1 listed file could not be <span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件内容被修改</span></span><br><span class="line">md5sum -c test.md5</span><br><span class="line">  test.sh: FAILED</span><br><span class="line">  md5sum: WARNING: 1 computed checksum did NOT match</span><br></pre></td></tr></table></figure><p></p><p>当使用了<code>-c</code>选项时，还支持以下选项：</p><ul><li><code>--quiet</code>：<strong>不显示验证结果为OK的记录</strong>；</li><li><code>--status</code>：<strong>完全不显示任何信息</strong>，只能通过命令的退出状态码判断验证结果是否有failed；<strong>只要有一条failed记录，则状态码为1，否则为0。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5sum --status -c test.md5</span><br><span class="line"><span class="comment"># 使用$?来获取最后运行的命令的结束代码</span></span><br><span class="line"><span class="comment"># 正常运行的命令结束代码为0，出错或者出现异常结束代码不为0</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7430264.html" target="_blank" rel="noopener">Linux中文件MD5校验</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之Shell子进程以及何时进入子Shell</title>
      <link href="/posts/36597.html"/>
      <url>/posts/36597.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章基于<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">子shell以及什么时候进入子shell</a>进行了学习和整理，学习了<strong>Shell的子进程</strong>以及列举了几种<strong>不产生</strong>和<strong>产生Shell子进程</strong>的场景。同时，这篇文章也是对<a href="http://showteeth.tech/posts/16586.html">关于Linux中脚本执行方式</a>以及<a href="http://showteeth.tech/posts/52906.html">全局变量、局部变量和环境变量</a>两篇文章的内容的补充和参考。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前学习的<a href="http://showteeth.tech/posts/16586.html">关于Linux中脚本执行方式</a>以及<a href="http://showteeth.tech/posts/52906.html">全局变量、局部变量和环境变量</a>中都有提到Shell进程以及如何进入Shell子进程，但是了解不够全面，恰巧读到<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">这篇文章</a>，发现讲解非常详细，所以这里主要是基于<a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">这篇文章</a>的学习笔记，大部分都是与原封不动copy下来的。</p><hr><h2 id="子Shell简介"><a href="#子Shell简介" class="headerlink" title="子Shell简介"></a>子Shell简介</h2><p>子shell的概念贯穿整个shell，写shell脚本时更是不可不知。所谓<strong>子shell</strong>，即<strong>从当前shell环境新开一个shell环境</strong>，这个新开的shell环境就称为子shell(subshell)，而<strong>开启子shell的环境称为该子shell的父shell</strong>。子shell和父shell的关系其实就是子进程和父进程的关系，只不过子shell和父shell所关联的进程是bash进程。</p><p>子shell会从父shell中<strong>继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等</strong>，但<strong>子shell有很多种类型，不同类型的子shell继承的环境不相同</strong>。可以使用<code>$BASH_SUBSHELL</code>变量来<strong>查看从当前进程开始的子shell层数</strong>，<code>$BASHPID</code>查看<strong>当前所处BASH的PID</strong>，<mark>这不同于特殊变量<code>$$</code>值，因为<code>$$</code>在大多数情况下都会从父shell中继承</mark>。</p><hr><h2 id="何时产生子Shell"><a href="#何时产生子Shell" class="headerlink" title="何时产生子Shell"></a>何时产生子Shell</h2><p>要解释清楚子shell以及产生何种类型的子shell，需要搞清楚Linux中如何产生子进程。Linux上<strong>创建子进程的方式有三种</strong>：</p><ul><li>一种是<code>fork</code>出来的进程。它会复制当前进程的副本(不考虑写时复制的模式)，以适当的方式将这些资源交给子进程；所以<strong>子进程掌握的资源和父进程是一样的，包括内存中的内容，所以也包括环境变量和变量</strong>；但父子进程是完全独立的，它们是一个程序的两个实例。</li><li>一种是<code>exec</code>出来的进程。<code>exec</code>是加载另一个应用程序，替代当前运行的进程，也就是说在不创建新进程的情况下加载一个新程序；<code>exec</code>还有一个动作：在进程执行完毕后，退出<code>exec</code>所在的shell环境。</li><li>一种是<code>clone</code>出来的进程。此处无需关心<code>clone</code>，因为它用来实现Linux中的线程。</li></ul><p>所以为了保证进程安全，若要形成新的且独立的子进程，都会先<code>fork</code>一份当前进程，然后在<code>fork</code>出来的子进程上调用<code>exec</code>来加载新程序替代该子进程。例如<strong>在bash下执行cp命令，会先fork出一个bash，然后再exec加载cp程序覆盖子bash进程变成cp进程。</strong></p><p>再来说明子shell的问题。一般<code>fork</code>出来的子进程，内容和父进程是一样的(包括变量)，例如执行<code>cp</code>命令时也能获取到父进程的变量；但是<code>cp</code>命令在哪里执行呢？执行<code>cp</code>命令敲入回车后，当前的bash进程<code>fork</code>出一个<strong>子bash</strong>，然后<strong>子bash</strong>通过<code>exec</code>加载<code>cp</code>程序<strong>替代子bash</strong>。这算是进入了<strong>子shell</strong>吗？更通用的问题是：<strong>什么情况下会进入子shell环境，什么时候不进入子shel环境呢？</strong></p><p>判断是否进入了子shell的方式非常简单，执行<code>echo $BASHPID</code>，如果该值和父bash进程的pid值不同，则表示进入了子shell。</p><h3 id="不产生子Shell"><a href="#不产生子Shell" class="headerlink" title="不产生子Shell"></a>不产生子Shell</h3><h4 id="执行bash内置命令"><a href="#执行bash内置命令" class="headerlink" title="执行bash内置命令"></a>执行bash内置命令</h4><p>bash内置命令是非常特殊的，<strong>父进程不会创建子进程来执行这些命令</strong>，而是直接<strong>在当前bash环境中执行</strong>。但如果<strong>将内置命令放在管道后，就会创建子shell</strong>。关于Linux中的内置命令，可以查看<a href="#%e8%a1%a5%e5%85%85-linux%e5%86%85%e7%bd%ae%e5%91%bd%e4%bb%a4">这部分</a>。</p><p>内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span>   </span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># let命令为bash内置命令，不进入子shell</span></span><br><span class="line"><span class="built_in">let</span> a=<span class="variable">$BASHPID</span>   </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">  65230</span><br></pre></td></tr></table></figure><p></p><p>管道结合内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 增加管道后看看ID</span></span><br><span class="line"><span class="comment"># 发现这里虽然使用了内置命令，但是依然创建了子Shell</span></span><br><span class="line">ls |<span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  28580</span><br></pre></td></tr></table></figure><p></p><p>这时候的<strong>子shell的作用</strong>是为bash内置命令提供执行环境。</p><hr><h4 id="执行shell函数"><a href="#执行shell函数" class="headerlink" title="执行shell函数"></a>执行shell函数</h4><p>其实shell函数就是命令，它和bash内置命令的情况一样，直接执行时不会进入子shell，但放在管道后会进入子shell：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数，输出ID</span></span><br><span class="line"><span class="function"><span class="title">fun_test</span></span> ()&#123; <span class="built_in">echo</span> <span class="variable">$BASHPID</span>; &#125;</span><br><span class="line"><span class="comment"># 输出当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 执行函数，输出Shell的ID</span></span><br><span class="line">fun_test </span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 加入管道</span></span><br><span class="line">ls |fun_test </span><br><span class="line">  30637</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="产生子Shell"><a href="#产生子Shell" class="headerlink" title="产生子Shell"></a>产生子Shell</h3><h4 id="执行bash命令本身"><a href="#执行bash命令本身" class="headerlink" title="执行bash命令本身"></a>执行bash命令本身</h4><p>显然它<strong>会进入子shell环境</strong>，它的<strong>绝大多数环境都是新配置的</strong>，因为<strong>会加载一些环境配置文件</strong>。<mark>事实上<code>fork</code>出来的bash子进程内容完全继承父shell，但因<strong>重新加载了环境配置项</strong>，所以<strong>子shell没有继承普通变量</strong>，更准确的说是<strong>覆盖</strong>了从父shell中继承的变量</mark>。不妨试试在<code>/etc/bashrc</code>文件中定义一个变量，再在父shell中<code>export</code>名称相同值却不同的环境变量，然后到子shell中看看该变量的值为何？<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"var=55"</span> &gt;&gt;/etc/bashrc</span><br><span class="line"><span class="built_in">export</span> var=66</span><br><span class="line"><span class="comment"># 进入子Shell</span></span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">  55</span><br></pre></td></tr></table></figure><p></p><p>由结果55可知，执行bash时加载的<code>/etc/bashrc</code>中的变量<strong>覆盖</strong>了父bash中的导出的环境变量值66。</p><p>使用<code>exit</code>命令退出当前子Shell：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 执行bash命令</span></span><br><span class="line">bash</span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  29075</span><br><span class="line"><span class="comment"># 使用exit退出当前子Shell</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>变量<code>$$</code>不会被继承：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 使用bash进入子Shell</span></span><br><span class="line">bash</span><br><span class="line"><span class="comment"># 查看bash进入的子Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  32310</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="执行Shell脚本"><a href="#执行Shell脚本" class="headerlink" title="执行Shell脚本"></a>执行Shell脚本</h4><p>这里的执行Shell脚本是<a href="http://showteeth.tech/posts/16586.html">这篇文章</a>中<strong>作为可执行程序</strong>、<strong>作为解释器参数</strong>进行的执行，而不是<strong>source方式执行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  29479</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的进程ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> </span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>可以发现：执行shell脚本相比于直接执行bash命令，还多了一个动作——<strong>脚本执行完毕后自动退出子shell</strong>。</p><p>变量<code>$$</code>不会被继承：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line">cat test_run.sh</span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  32477</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="执行非bash内置命令"><a href="#执行非bash内置命令" class="headerlink" title="执行非bash内置命令"></a>执行非bash内置命令</h4><p>例如执行<code>cp</code>命令、<code>grep</code>命令等，它们直接<code>fork</code>一份bash进程，然后使用<code>exec</code>加载程序替代该子bash。此类子进程<strong>会继承所有父bash的环境</strong>。但<strong>严格地说，这已经不是子shell</strong>，因为<code>exec</code>加载的程序已经把子bash进程替换掉了，这意味着丢失了很多bash环境。在bash文档中，直接<strong>称呼这种环境为”单独的环境”，和子shell的概念类似。</strong></p><hr><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p><strong>当命令行中包含了命令替换部分时，将开启一个子shell先执行这部分内容，再将执行结果返回给当前命令</strong>。因为这次的子shell<strong>不是通过bash命令</strong>进入的子shell，所以它<strong>会继承父shell的所有变量内容</strong>。这也就解释了<code>echo $(echo $$)</code>中<code>$$</code>的结果是当前bash(父Shell)的pid号，而不是子shell的pid号，但<code>echo $(echo $BASHPID)</code>却和父bash进程的pid不同，因为它不是使用bash命令进入的子shell:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$$查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$BASHPID查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令替换，使用$BASHPID查看命令替换得到的子Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  31157</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令替换，使用$$测试命令替换是不是继承了父Shell的$$变量</span></span><br><span class="line"><span class="comment"># 发现使用命令替换会继承父Shell的$$变量</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过bash命令进入子Shell</span></span><br><span class="line"><span class="comment"># 发现并没有继承父Shell的$$变量</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  31232</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="使用括号-组合一系列命令"><a href="#使用括号-组合一系列命令" class="headerlink" title="使用括号()组合一系列命令"></a>使用括号()组合一系列命令</h4><p>例如<code>(ls;date;echo haha)</code>，独立的括号将会<strong>开启一个子shell来执行括号内的命令</strong>，这种情况等同于上述<a href="#%e6%89%a7%e8%a1%8c%e9%9d%9ebash%e5%86%85%e7%bd%ae%e5%91%bd%e4%bb%a4%e6%97%b6">执行非bash内置命令</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看括号组合的命令的Shell ID </span></span><br><span class="line">(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  31804</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line">(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="放入后台的任务"><a href="#放入后台的任务" class="headerlink" title="放入后台的任务"></a>放入后台的任务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 查看放入后台命令运行的Shell ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> &amp;</span><br><span class="line">  [1] 32030</span><br><span class="line">  32030</span><br></pre></td></tr></table></figure><p>变量<code>$$</code>会被继承:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line"><span class="built_in">echo</span> $$ &amp;</span><br><span class="line">  [1] 316</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>既然是新进程了，当然进入子shell执行，例如<code>cat &lt;(echo haha)</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"><span class="comment"># 进程替换，进入子Shell</span></span><br><span class="line">cat &lt;(<span class="built_in">echo</span> <span class="variable">$BASHPID</span>)</span><br><span class="line">  32181</span><br></pre></td></tr></table></figure><p></p><p>变量<code>$$</code>会被继承:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前Shell的$$变量值</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承了$$变量的值</span></span><br><span class="line">cat &lt;(<span class="built_in">echo</span> $$)</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>关于<code>$$</code>变量的继承：除了<strong>直接执行bash命令</strong>和<strong>shell脚本这两种子shell</strong>，<strong>其他进入子shell的情况都会继承父shell的值</strong>。前面也已经说了，其实shell脚本和直接执行bash命令开启子shell的方式是一样的，它们<strong>都不会继承<code>$$</code>值</strong>，上面对应的部分已经做过了验证。</li><li>子shell的环境设置不会粘滞到父shell环境，无论是使用<code>export</code>还是<code>source</code>，环境设置都只能从父shell到子shell，不是也不会是从子shell到父shell。也就是说<strong>子shell的变量等不会影响父shell</strong>。</li></ul><hr><p><br></p><h2 id="补充-Linux内置命令"><a href="#补充-Linux内置命令" class="headerlink" title="补充-Linux内置命令"></a>补充-Linux内置命令</h2><p>通常来说，<strong>内置命令会比外部命令执行得更快</strong>，执行外部命令时不但会<strong>触发磁盘 I/O</strong>，还需要 <code>fork</code> 出一个单独的进程来执行，执行完成后再退出。而<strong>执行内建命令相当于调用当前 Shell 进程的一个函数。</strong></p><h3 id="判断命令是不是内置命令"><a href="#判断命令是不是内置命令" class="headerlink" title="判断命令是不是内置命令"></a>判断命令是不是内置命令</h3><p>type命令可以判断命令是不是内置命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd命令是内置命令</span></span><br><span class="line"><span class="comment"># 返回为builtin</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span></span><br><span class="line">  <span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp不是内置命令</span></span><br><span class="line"><span class="comment"># cp不是内置命令，其路径为/usr/bin/cp</span></span><br><span class="line"><span class="built_in">type</span> cp</span><br><span class="line">  cp is /usr/bin/cp</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="查看内置命令帮助"><a href="#查看内置命令帮助" class="headerlink" title="查看内置命令帮助"></a>查看内置命令帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> | less</span><br><span class="line">  GNU bash, version 4.2.46(2)-release (x86_64-redhat-linux-gnu)</span><br><span class="line">  These shell commands are defined internally.  Type `<span class="built_in">help</span><span class="string">' to see this list.</span></span><br><span class="line"><span class="string">  Type `help name'</span> to find out more about the <span class="keyword">function</span> `name<span class="string">'.</span></span><br><span class="line"><span class="string">  Use `info bash'</span> to find out more about the shell <span class="keyword">in</span> general.</span><br><span class="line">  Use `man -k<span class="string">' or `info'</span> to find out more about commands not <span class="keyword">in</span> this list.</span><br><span class="line"></span><br><span class="line">  A star (*) next to a name means that the <span class="built_in">command</span> is disabled.</span><br><span class="line"></span><br><span class="line">  job_spec [&amp;]                                                 <span class="built_in">history</span> [-c] [-d offset] [n] or <span class="built_in">history</span> -anrw [filename] &gt;</span><br><span class="line">  (( expression ))                                             <span class="keyword">if</span> COMMANDS; <span class="keyword">then</span> COMMANDS; [ <span class="keyword">elif</span> COMMANDS; <span class="keyword">then</span> COMMAND&gt;</span><br><span class="line">  . filename [arguments]                                       <span class="built_in">jobs</span> [-lnprs] [jobspec ...] or <span class="built_in">jobs</span> -x <span class="built_in">command</span> [args]</span><br><span class="line">  :                                                            <span class="built_in">kill</span> [-s sigspec | -n signum | -sigspec] pid | jobspec ..&gt;</span><br><span class="line">  [ arg... ]                                                   <span class="built_in">let</span> arg [arg ...]</span><br></pre></td></tr></table></figure><hr><h3 id="内置命令列表"><a href="#内置命令列表" class="headerlink" title="内置命令列表"></a>内置命令列表</h3><table><caption>Bash Shell 内建命令</caption><tbody><tr><th width="10%">命令</th><th width="90%">说明</th></tr><tr><td>:</td><td>扩展参数列表，执行重定向操作</td></tr><tr><td>.</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>alias</td><td>为指定命令定义一个别名</td></tr><tr><td>bg</td><td>将作业以后台模式运行</td></tr><tr><td>bind</td><td>将键盘序列绑定到一个 readline 函数或宏</td></tr><tr><td>break</td><td>退出 for、while、select 或 until 循环</td></tr><tr><td>builtin</td><td>执行指定的 shell 内建命令</td></tr><tr><td>caller</td><td>返回活动子函数调用的上下文</td></tr><tr><td>cd</td><td>将当前目录切换为指定的目录</td></tr><tr><td>command</td><td>执行指定的命令，无需进行通常的 shell 查找</td></tr><tr><td>compgen</td><td>为指定单词生成可能的补全匹配</td></tr><tr><td>complete</td><td>显示指定的单词是如何补全的</td></tr><tr><td>compopt</td><td>修改指定单词的补全选项</td></tr><tr><td>continue</td><td>继续执行 for、while、select 或 until 循环的下一次迭代</td></tr><tr><td>declare</td><td>声明一个变量或变量类型。</td></tr><tr><td>dirs</td><td>显示当前存储目录的列表</td></tr><tr><td>disown</td><td>从进程作业表中刪除指定的作业</td></tr><tr><td>echo</td><td>将指定字符串输出到 STDOUT</td></tr><tr><td>enable</td><td>启用或禁用指定的内建shell命令</td></tr><tr><td>eval</td><td>将指定的参数拼接成一个命令，然后执行该命令</td></tr><tr><td>exec</td><td>用指定命令替换 shell 进程</td></tr><tr><td>exit</td><td>强制 shell 以指定的退出状态码退出</td></tr><tr><td>export</td><td>设置子 shell 进程可用的变量</td></tr><tr><td>fc</td><td>从历史记录中选择命令列表</td></tr><tr><td>fg</td><td>将作业以前台模式运行</td></tr><tr><td>getopts</td><td>分析指定的位置参数</td></tr><tr><td>hash</td><td>查找并记住指定命令的全路径名</td></tr><tr><td>help</td><td>显示帮助文件</td></tr><tr><td>history</td><td>显示命令历史记录</td></tr><tr><td>jobs</td><td>列出活动作业</td></tr><tr><td>kill</td><td>向指定的进程 ID(PID) 发送一个系统信号</td></tr><tr><td>let</td><td>计算一个数学表达式中的每个参数</td></tr><tr><td>local</td><td>在函数中创建一个作用域受限的变量</td></tr><tr><td>logout</td><td>退出登录 shell</td></tr><tr><td>mapfile</td><td>从 STDIN 读取数据行，并将其加入索引数组</td></tr><tr><td>popd</td><td>从目录栈中删除记录</td></tr><tr><td>printf</td><td>使用格式化字符串显示文本</td></tr><tr><td>pushd</td><td>向目录栈添加一个目录</td></tr><tr><td>pwd</td><td>显示当前工作目录的路径名</td></tr><tr><td>read</td><td>从 STDIN 读取一行数据并将其赋给一个变量</td></tr><tr><td>readarray</td><td>从 STDIN 读取数据行并将其放入索引数组</td></tr><tr><td>readonly</td><td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td></tr><tr><td>return</td><td>强制函数以某个值退出，这个值可以被调用脚本提取</td></tr><tr><td>set</td><td>设置并显示环境变量的值和 shell 属性</td></tr><tr><td>shift</td><td>将位置参数依次向下降一个位置</td></tr><tr><td>shopt</td><td>打开/关闭控制 shell 可选行为的变量值</td></tr><tr><td>source</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>suspend</td><td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td></tr><tr><td>test</td><td>基于指定条件返回退出状态码 0 或 1</td></tr><tr><td>times</td><td>显示累计的用户和系统时间</td></tr><tr><td>trap</td><td>如果收到了指定的系统信号，执行指定的命令</td></tr><tr><td>type</td><td>显示指定的单词如果作为命令将会如何被解释</td></tr><tr><td>typeset</td><td>声明一个变量或变量类型。</td></tr><tr><td>ulimit</td><td>为系统用户设置指定的资源的上限</td></tr><tr><td>umask</td><td>为新建的文件和目录设置默认权限</td></tr><tr><td>unalias</td><td>刪除指定的别名</td></tr><tr><td>unset</td><td>刪除指定的环境变量或 shell 属性</td></tr><tr><td>wait</td><td>等待指定的进程完成，并返回退出状态码</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7446194.html" target="_blank" rel="noopener">子shell以及什么时候进入子shell</a></li><li><a href="https://linux.cn/article-9343-1.html" target="_blank" rel="noopener">如何列出所有的 Bash Shell 内置命令</a></li><li><a href="http://c.biancheng.net/view/1136.html" target="_blank" rel="noopener">Shell内建命令（内置命令）</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R系列之文件目录操作</title>
      <link href="/posts/49759.html"/>
      <url>/posts/49759.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>R中文件目录相关操作</strong>，主要包括：<code>查看和设置工作路径</code>、<code>查看文件或目录是否存在</code>、<code>列出目录下文件或目录</code>、<code>新建文件或目录</code>、<code>复制文件或目录</code>、<code>删除文件或目录</code>、<code>重命名文件或目录</code>。</p></div><a id="more"></a><h2 id="工作路径"><a href="#工作路径" class="headerlink" title="工作路径"></a>工作路径</h2><p>设置工作路径：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置工作路径为path/to/your/workdir</span></span><br><span class="line">setwd(<span class="string">'path/to/your/workdir'</span>)</span><br></pre></td></tr></table></figure><p></p><p>得到当前工作路径：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到当前的工作路径</span></span><br><span class="line">getwd()</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="查看文件-目录-是否存在"><a href="#查看文件-目录-是否存在" class="headerlink" title="查看文件(目录)是否存在"></a>查看文件(目录)是否存在</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个函数都可以用于查看文件(目录)是否存在</span></span><br><span class="line">dir.exists(paths)</span><br><span class="line">file.exists(paths)</span><br></pre></td></tr></table></figure><p>参数<code>paths</code>可以是<code>vector</code>，即可以<strong>批量查看文件（目录）是否存在</strong></p><hr><p><br></p><h2 id="列出目录下文件-目录"><a href="#列出目录下文件-目录" class="headerlink" title="列出目录下文件(目录)"></a>列出目录下文件(目录)</h2><ul><li>函数<code>list.files</code>和<code>dir</code>用法<strong>完全一样</strong>，可以<strong>列出路径下所有文件（包括目录）</strong>；</li><li>函数<code>list.dirs</code>只列出路径下<strong>所有目录</strong></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录下所有文件和目录</span></span><br><span class="line">list.files(path = <span class="string">"."</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">       dir(path = <span class="string">"."</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目录下的所有目录</span></span><br><span class="line">list.dirs(path = <span class="string">"."</span>, full.names = <span class="literal">TRUE</span>, recursive = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>path</code>：路径，如不填则<strong>默认为当前工作路径</strong>，即<code>getwd()</code>得到的路径；</li><li><code>pattern</code>：<strong>正则表达式</strong>，若pattern不为NULL，返回文件（目录）名满足该正则表达式的文件（目录）；</li><li><code>all.files</code>：若为<code>FALSE</code>则<strong>不显示隐藏文件（目录）</strong>，若为<code>TRUE</code>则返回所有文件（目录）；</li><li><code>full.names</code>：若为<code>FALSE</code>则<strong>只返回文件（目录）名</strong>，若为<code>TRUE</code>则返回<strong>文件（目录）路径</strong>；</li><li><code>recursive</code>：若为<code>FALSE</code>则<strong>只返回该路径的子级文件（目录）</strong>，若为<code>TRUE</code>则返回<strong>所有子、孙文件（目录）</strong>；</li><li><code>ignore.case</code>：若为<code>TRUE</code>则在匹配pattern时<strong>不区分大小写</strong>；</li><li><code>include.dirs</code>：在<code>recursive</code>为<code>TURE</code>，即显示所有子、孙文件时，若<code>include.dirs</code>为<code>FALSE</code>则只列出最终端的文件名，而不列出中间层级的目录名；</li><li><code>no..</code>：若为<code>TRUE</code>，则不显示<code>.</code>和<code>..</code>。</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; list.files(recursive=<span class="literal">TRUE</span>,include.dirs=<span class="literal">FALSE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"filtered_feature_bc_matrix/barcodes.tsv.gz"</span> <span class="string">"filtered_feature_bc_matrix/features.tsv.gz"</span></span><br><span class="line">[<span class="number">3</span>] <span class="string">"filtered_feature_bc_matrix/matrix.mtx.gz"</span>   <span class="string">"npas4l.pdf"</span>                                </span><br><span class="line">[<span class="number">5</span>] <span class="string">"top_zebrafish_cluster_markers.csv"</span>          <span class="string">"zebrafish_cluster_markers.csv"</span>             </span><br><span class="line">[<span class="number">7</span>] <span class="string">"zebrafish_first.rds"</span>                  </span><br><span class="line"></span><br><span class="line"><span class="comment"># include.dirs=TRUE时多出"filtered_feature_bc_matrix" 中间文件夹</span></span><br><span class="line">&gt; list.files(recursive=<span class="literal">TRUE</span>,include.dirs=<span class="literal">TRUE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"filtered_feature_bc_matrix"</span>                 <span class="string">"filtered_feature_bc_matrix/barcodes.tsv.gz"</span></span><br><span class="line">[<span class="number">3</span>] <span class="string">"filtered_feature_bc_matrix/features.tsv.gz"</span> <span class="string">"filtered_feature_bc_matrix/matrix.mtx.gz"</span>  </span><br><span class="line">[<span class="number">5</span>] <span class="string">"npas4l.pdf"</span>                                 <span class="string">"top_zebrafish_cluster_markers.csv"</span>         </span><br><span class="line">[<span class="number">7</span>] <span class="string">"zebrafish_cluster_markers.csv"</span>              <span class="string">"zebrafish_first.rds"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="新建文件-目录"><a href="#新建文件-目录" class="headerlink" title="新建文件(目录)"></a>新建文件(目录)</h2><p>函数<code>file.create</code>用于新建文件，<code>dir.create</code>用于新建目录：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">file.create(<span class="keyword">...</span>, showWarnings = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment"># 新建目录</span></span><br><span class="line">dir.create(path, showWarnings = <span class="literal">TRUE</span>, recursive = <span class="literal">FALSE</span>,mode = <span class="string">"0777"</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>函数默认<code>recursive</code>为<code>FALSE</code>，即<strong>只新建path中的第一级子目录</strong>，而当<code>recursive</code>为<code>TRUE</code>时可以<strong>新建多级子目录</strong>；</li><li>当目录<strong>已存在时不会新建目录覆盖原先的目录</strong>，此时如果<code>showWarnings</code>为<code>TRUE</code>，则会<strong>提醒</strong>该目录已存在，为<code>FALSE</code>时不会提醒；</li></ul><hr><p><br></p><h2 id="复制文件-目录"><a href="#复制文件-目录" class="headerlink" title="复制文件(目录)"></a>复制文件(目录)</h2><p>函数<code>file.copy</code>用于复制文件(目录)：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.copy(from, to, overwrite = recursive, recursive = <span class="literal">FALSE</span>,copy.mode = <span class="literal">TRUE</span>, copy.date = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>from</code>是<strong>原始文件（目录）名</strong>，<code>to</code>是<strong>新文件（目录）名</strong>，二者可以是vector，但是长度需相同；</li><li><code>overwrite</code> 若为<code>TRUE</code>，则<strong>文件被覆盖</strong>；</li><li><code>recursive</code> <strong>复制目录时recursive需为TRUE</strong>；</li><li><code>copy.mode</code>若为<code>TRUE</code>，<code>permission bits</code>一并复制过来；</li><li><code>copy.date</code>若为<code>TRUE</code>，文件<strong>日期一并复制过来</strong>。</li></ul><hr><p><br></p><h2 id="删除文件-目录"><a href="#删除文件-目录" class="headerlink" title="删除文件(目录)"></a>删除文件(目录)</h2><p>函数<code>unlink</code>可以用来删除<strong>文件或目录</strong>，函数<code>file.remove</code>可以用来删除<strong>文件</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(x, recursive = <span class="literal">FALSE</span>, force = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>x</code>是要删除的文件或目录，可以是<code>vector（即批量删除）</code>；</li><li>当<strong>删除目录</strong>时，<code>recursive</code>应为<code>TRUE</code>，表示目录内文件一并删除。</li></ul><hr><p><br></p><h2 id="重命名文件-目录"><a href="#重命名文件-目录" class="headerlink" title="重命名文件(目录)"></a>重命名文件(目录)</h2><p>函数<code>file.rename</code>用于重命名：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.rename(from, to)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>from</code>是<strong>原始文件（目录）名</strong>，<code>to</code>是<strong>新文件（目录）名</strong>，二者可以是<code>vector</code>，但是<code>长度需相同</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.omicsclass.com/article/338" target="_blank" rel="noopener">R语言文件目录操作</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell系列之局部变量、全局变量和环境变量</title>
      <link href="/posts/52906.html"/>
      <url>/posts/52906.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章重点学习了Shell中<strong>变量的作用域</strong>，主要包括了<strong>局部变量</strong>、<strong>全局变量</strong>以及<strong>环境变量</strong>。其中在学习环境变量时又学习了使用<code>export</code>命令导出的<strong>临时环境变量</strong>以及<strong>在Shell进程启动时自动加载永久环境变量的过程</strong>。</p></div><a id="more"></a><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><code>Shell</code> 变量的<strong>作用域（Scope）</strong>，就是 <strong>Shell 变量的有效范围（可以使用的范围）</strong>。在<strong>不同的作用域</strong>中，同名的变量<strong>不会相互干涉</strong>；但是在<strong>相同的作用域中</strong>，同名的变量就会<strong>互相干扰</strong>，这也是为什么需要对变量作用域进行学习的原因。</p><p><code>Shell</code> 变量的作用域可以<strong>分为三种</strong>：</p><ul><li>有的变量只能在<strong>函数内部使用</strong>，这叫做<code>局部变量（local variable）</code>；</li><li>有的变量可以在<strong>当前 Shell 进程</strong>中使用，这叫做<code>全局变量（global variable）</code>；</li><li>而有的变量还可以在<strong>子进程</strong>中使用，这叫做<code>环境变量（environment variable）</code>。</li></ul><hr><p><br></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p><code>Shell</code> 也支持自定义函数，但是 <code>Shell</code> 函数和其他编程语言(如Python)函数的一个不同点就是：在 <strong>Shell 函数中定义的变量默认也是全局变量</strong>，它和在函数外部定义变量拥有一样的效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p></p><p>最后输出的结果是：99，是a的值。a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。</p><p>如果想要定义<strong>只在函数内部起作用的变量</strong>，需要在<strong>声明变量</strong>或者<strong>赋值之前</strong>加上<code>local</code>命令，这样就使得变量成为了<strong>局部变量</strong>，只在函数内部起作用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">local</span> a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p><hr><p><br></p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>所谓全局变量，就是指变量在<strong>当前的整个 Shell 进程中都有效</strong>；<strong>每个 Shell 进程(可以理解为在终端中打开的两个窗口)都有自己的作用域，彼此之间互不影响(在终端的一个窗口中定义的变量在另一个窗口中并不能调用)</strong>；<strong>在 Shell 中定义的变量，默认就是全局变量</strong>。</p><p>需要强调的是，全局变量的作用范围是<strong>当前的 Shell 进程</strong>，而<strong>不是当前的 Shell 脚本文件</strong>，它们是不同的概念；打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID；在一个 Shell 进程中可以使用 <code>source</code> 命令执行多个 Shell 脚本文件，此时<strong>全局变量在这些脚本文件中都有效</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  a.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">b=200</span><br><span class="line"></span><br><span class="line"><span class="comment">## b.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p></p><p>在打开的终端窗口中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前窗口的全局变量</span></span><br><span class="line">a=99</span><br><span class="line"></span><br><span class="line"><span class="comment"># source执行a脚本</span></span><br><span class="line">. ./a.sh</span><br><span class="line">  <span class="comment"># 输出99，也就是当前窗口的全局变量a的值</span></span><br><span class="line">  99</span><br><span class="line"></span><br><span class="line"><span class="comment"># source执行b脚本</span></span><br><span class="line">. ./b.sh</span><br><span class="line">  <span class="comment"># 输出a脚本中引入的全局变量</span></span><br><span class="line">  200</span><br></pre></td></tr></table></figure><p></p><p>这三条命令都是在<strong>一个进程</strong>中执行的，从输出结果可以发现，在 <code>Shell</code> 窗口中以命令行的形式定义的变量 <code>a</code>，在 <code>a.sh</code> 中有效；在 <code>a.sh</code>中定义的变量 <code>b</code>，在 <code>b.sh</code> 中也有效，变量 <code>b</code> 的作用范围已经超越了 <code>a.sh</code>。</p><div class="note info"><p>注意：这里是使用<code>source</code>的方式执行的脚本，效果是<strong>在当前进程下执行</strong>，而如果使用<code>bash a.sh</code>这种方式执行脚本就不会有上述结果，因为这种方式执行脚本是<strong>在子进程下执行的</strong>，具体执行方式的区别参考<a href="http://showteeth.tech/posts/16586.html">这篇文章</a>。</p></div><h3 id="全局变量冲突实例"><a href="#全局变量冲突实例" class="headerlink" title="全局变量冲突实例"></a>全局变量冲突实例</h3><p>最近在写shell脚本的时候恰巧遇到了全局变量导致程序出错的实例，这里记录一下：</p><ul><li>写了一个函数脚本，名为<code>qc.sh</code></li><li>在另一个脚本<code>run.sh</code>中对<code>qc.sh</code>进行了<code>source</code>执行</li></ul><p><code>qc.sh</code>截取：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func one</span></span><br><span class="line"><span class="function"><span class="title">func_1</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$&#123;local_variable&#125;</span>/*_test.zip)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    mv <span class="variable">$&#123;i&#125;</span> something</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># func two</span></span><br><span class="line"><span class="function"><span class="title">func_2</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$&#123;local_variable_2&#125;</span>/*_test.zip)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    mv <span class="variable">$&#123;i&#125;</span> something_2</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>run.sh</code>截取：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"190915_data"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  func_1  <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/qc</span><br><span class="line">  func_2  <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/trim <span class="variable">$&#123;results_folder&#125;</span>/<span class="variable">$&#123;i&#125;</span>/<span class="variable">$&#123;j&#125;</span>/trim</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>最后程序在执行<code>func_2</code>时报错，而<code>func_1</code>正常执行，检查日志发现<code>func_2</code>传递的参数有误，其中的<code>${i}</code>部分变成了<code>func_1</code>中<code>for循环</code>最终停止的<code>i</code>，已经不是目标的<code>190915_data</code>，回顾之前学习的<a href="http://showteeth.tech/posts/16586.html">Linux系列之各种执行脚本方式的区别</a>，<code>source</code>方式执行脚本会打通全局变量，所以<code>func_1</code>执行之后由于其中的<code>i</code>变量<strong>不是局部变量，所以其作用域是整个脚本，并且会对之前的变量i的值进行覆盖</strong>，从而导致其值变为了<code>func_1</code>中<code>for循环</code>最终停止的<code>i</code>，并将其传递给了第二个函数<code>func_2</code>，最终导致出错。</p><p><strong>解决方法</strong>就是将<code>func_1</code>、<code>func_2</code>中的<code>i</code>声明为局部变量<code>local i</code></p><hr><p><br></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>全局变量</strong>只在<strong>当前 Shell 进程中有效</strong>，在<strong>其它 Shell 进程和子进程中都无效</strong>；如果想要使变量在Shell子进程甚至是所有的Shell进程中都有效，可以使用环境变量，环境变量又分为<strong>临时的环境变量</strong>和<strong>永久的环境变量</strong>：</p><ul><li>如果是使用<code>export</code>命令<strong>将全局变量导出</strong>，那么它就在所有的<strong>子进程</strong>中也有效了，这种变量被称为<strong>临时的环境变量</strong>；</li><li>而<strong>永久的环境变量</strong>是在shell启动时加载的，在<strong>所有的Shell进程中都有效的变量</strong>，如写在<code>~/.bashrc</code>中的变量。</li></ul><h3 id="临时的环境变量"><a href="#临时的环境变量" class="headerlink" title="临时的环境变量"></a>临时的环境变量</h3><p><strong>环境变量被创建(使用<code>export</code>命令)时所处的 Shell 进程称为父进程</strong>，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 <strong>Shell 子进程</strong>；当 Shell 子进程产生时，它会<strong>继承父进程的环境变量</strong>为自己所用，所以说环境变量可从父进程传给子进程；不难理解，环境变量还可以传递给孙进程。</p><p>注意，两个<strong>没有父子关系的 Shell 进程是不能传递使用<code>export</code>创建的环境变量的</strong>，并且这种环境变量<strong>只能向下传递而不能向上传递，即“传子不传父”</strong>。</p><p><strong>创建Shell子进程</strong>最简单的方法就是<code>bash</code>命令，退出Shell子进程的方法是<code>exit</code>命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前所处BASH的PID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  9512</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bash命令创建Shell子进程</span></span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看所处BASH的PID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  9963</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所处BASH的PID</span></span><br><span class="line"><span class="comment"># 发现回到了最开始的Shell进程</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span> </span><br><span class="line">  9512</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个全局变量</span></span><br><span class="line">a=22       </span><br><span class="line"><span class="comment">#在当前Shell中输出a，成功</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line">  22</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入Shell子进程</span></span><br><span class="line">bash       </span><br><span class="line"><span class="comment">#在子进程中输出a，失败，输出为空</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#退出Shell子进程，返回上一级Shell</span></span><br><span class="line"><span class="built_in">exit</span>       </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将a导出为环境变量</span></span><br><span class="line"><span class="built_in">export</span> a   </span><br><span class="line"><span class="comment">#重新进入Shell子进程</span></span><br><span class="line">bash      </span><br><span class="line"><span class="comment">#在子进程中再次输出a，成功 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>    </span><br><span class="line">  22</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span>       </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出父进程，结束整个Shell会话</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现，<strong>默认情况下</strong>，<strong>a (父进程定义的变量)在 Shell 子进程中是无效的</strong>；使用 <code>export</code> 将 a <strong>导出为环境变量</strong>后，在子进程中就可以使用了；<code>export a</code>这种形式是在<strong>定义变量 a 以后</strong>再将它导出为环境变量，如果想在<strong>定义的同时导出为环境变量</strong>，可以写作<code>export a=22</code>。</p><div class="note info"><p>需要注意的是：</p><ul><li><strong>使用export导入的环境变量是临时的</strong>，这种环境变量只会在当前Shell进程及其Shell子进程(使用bash命令进入的Shell子进程)中起效，而不会在其他Shell进程(不同的终端窗口)中起效。</li><li>这种情况比较常见的是安装软件之后，没有将其写入环境变量，而是直接<code>export</code>，这种情况下，在该Shell进程以及其子Shell中都可以正常使用该软件，但是一旦切换终端窗口(其他Shell进程)就不能使用；另一种比较常见的就是编译、安装软件过程中通过<code>export</code>指定的依赖包的地址了。</li></ul></div><hr><h3 id="永久的环境变量"><a href="#永久的环境变量" class="headerlink" title="永久的环境变量"></a>永久的环境变量</h3><p>永久的环境变量主要是写在bash的<strong>环境配置文件</strong>中的变量，这些变量是在shell进程启动时<strong>自动加载</strong>的，在<strong>所有的Shell进程中都有效</strong>；bash的环境配置文件主要有<code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>、<code>/etc/bashrc</code>和<code>/etc/profile.d/*.sh</code>，其中的<code>~/.bashrc</code>文件就是平常使用中用来添加环境变量的文件；常规登录shell(交互式登录shell)之后会先读取<code>/etc/profile</code>，再依次搜索<code>~/.bash_profile</code>、<code>~/.bash_login</code>和<code>~/.profile</code>，并仅<strong>加载第一个搜索到且可读的文件(前面三个文件中的某一个)</strong>。当<strong>退出</strong>时，将执行<code>~/.bash_logout</code>中的命令。</p><p>配置文件的读取顺序中并没有包括提到的<code>/etc/profile</code>、<code>~/.bashrc</code>等常见的配置文件，主要是因为<strong>这些配置文件会被读取顺序中的文件所执行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/profile文件会以source的方式执行/etc/profile.d/*.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;-#*i&#125;</span>"</span> != <span class="string">"$-"</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile.d/*.sh包括</span></span><br><span class="line">vim.csh  vim.sh  256term.csh  256term.sh  </span><br><span class="line">lang.csh  lang.sh  csh.local  sh.local  colorls.csh  </span><br><span class="line">colorls.sh  colorgrep.csh  colorgrep.sh  </span><br><span class="line">less.csh  less.sh  which2.csh  which2.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bash_profile文件也会以source方式执行~/.bashrc</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在~/.bashrc也会以source的方式执行/etc/bashrc</span></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/bashrc其实也有以source方式执行/etc/profile.d/*.sh的语句</span></span><br><span class="line"><span class="comment"># 但是前提是非登录式shell时才会执行</span></span><br><span class="line"><span class="comment"># 这里不对shell的登录方式进行学习，只了解最简单的交互式登录</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">shopt</span> -q login_shell ; <span class="keyword">then</span>   <span class="comment"># We're not a login shell</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">"<span class="variable">$PS1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">                . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>具体的加载过程可以使用下图表示(图中的X表示在交互式登录shell中不会执行，<a href="https://www.cnblogs.com/f-ck-need-u/p/7417651.html" target="_blank" rel="noopener">图片来源</a>)：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/shell_load.png" alt="shell_load.png"></p><p>使用示例这里就不在进行列举了，感兴趣的可以自行尝试。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/view/773.html" target="_blank" rel="noopener">Shell变量的作用域：Shell全局变量、环境变量和局部变量</a></li><li><a href="https://blog.51cto.com/lspgyy/1542930" target="_blank" rel="noopener">shell函数的局部变量，全局变量</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7417651.html" target="_blank" rel="noopener">bash启动时加载配置文件过程</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之各种执行脚本方式的区别</title>
      <link href="/posts/16586.html"/>
      <url>/posts/16586.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中执行shell脚本的三种方式：<strong>作为可执行程序</strong>、<strong>作为解释器参数</strong>、<strong>source方式执行</strong>，了解了这三种方式在<strong>指定脚本解释器</strong>、<strong>变量共用性</strong>方面的区别和联系。</p></div><a id="more"></a><h2 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h2><p>在学习shell脚本执行方式之前，先学习一下脚本解释器。脚本解释器简单来说就是告诉脚本使用什么语言来执行(目前我的理解)，Linux下常用的shell脚本解释器有：</p><ul><li><code>sh</code>：即<code>Bourne shell</code>，<code>POSIX</code>（Portable Operating System Interface）标准的<strong>shell解释器</strong>，它的二进制文件路径通常是<code>/bin/sh</code>；</li><li><code>bash</code>：Bash是<code>Bourne shell</code>的替代品，属<code>GNU Project</code>，二进制文件路径通常是<code>/bin/bash</code>；</li></ul><p>在<code>centos</code>下，<code>/bin/sh</code>是一个指向<code>/bin/bash</code>的链接：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx. 1 root root      4 Jul 16 01:21 /bin/sh -&gt; bash</span><br><span class="line">-rwxr-xr-x. 1 root root 964608 Oct 30  2018 /bin/bash</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="shell脚本执行方式"><a href="#shell脚本执行方式" class="headerlink" title="shell脚本执行方式"></a>shell脚本执行方式</h2><p>shell脚本共有<strong>三种</strong>执行方式：</p><ul><li><strong>作为可执行程序</strong></li><li><strong>作为解释器参数</strong></li><li><strong>source方式执行</strong></li></ul><h2 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建脚本</span></span><br><span class="line">cat test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予权限</span></span><br><span class="line"><span class="comment"># 赋予脚本可执行的权限</span></span><br><span class="line">chmod +x test_run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>#!/bin/bash</code>：<strong>指定脚本解释器</strong>，这里是指定使用<code>/bin/bash</code>做解释器的，其中的<code>#!</code>是一个<strong>约定的标记</strong>，它<strong>告诉系统这个脚本需要什么解释器来执行</strong>。使用这种方式执行脚本，这一句话一定要正确，<strong>要和脚本使用的语言是一致的</strong>，如果脚本是使用Python编写，那么这句话加就要指定Python的解释器，指定其他的解释器可能会出错；如果编写的是<code>bash shell</code>脚本，可以省略第一行的<code>#!/bin/bash</code>，这样依旧是可以执行的。</li><li><code>./test_run.sh</code>需要<strong>具有可执行</strong>的权限；</li><li><code>./test_run.sh</code>：这句话一定要加上<code>./</code>，不然也不能正确执行；如果直接写上<code>test_run.sh</code>，linux就会在系统的环境变量(PATH)中去查找有没有<code>test_run.sh</code>这个脚本，如果有就ok，会执行这个脚本，但是如果没有将<code>test_run.sh</code>加入到环境变量，那么就会显示<code>command not found</code>；使用<code>./test_run.sh</code>的含义是告诉linux在当前目录下寻找<code>test_run.sh</code>脚本，从而使其能被找到并执行。</li></ul><div class="note info"><p>一种常见地执行脚本解释器的写法是：<code>#!/usr/bin/env python</code>，这里的<strong>env表示的是环境变量中指定的Python</strong>，而不是<code>/bin/python</code>这种默认的Python。</p></div><hr><h2 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h2><p>这种运行方式是，<strong>直接运行解释器，其参数就是shell脚本的文件名</strong>，如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定解释器的全路径</span></span><br><span class="line">/bin/bash test_run.sh</span><br><span class="line"><span class="comment"># 因为在环境变量中，所以可以直接使用bash</span></span><br><span class="line">bash test_run.sh</span><br></pre></td></tr></table></figure><p></p><p>这种方式运行的脚本，<strong>不需要在第一行指定解释器信息</strong>，写了也没用，同时也<strong>不需要脚本具有可执行权限</strong>。</p><hr><h2 id="Shell子进程"><a href="#Shell子进程" class="headerlink" title="Shell子进程"></a>Shell子进程</h2><p>上述两种执行方式都是在<strong>当前Shell进程的子进程中</strong>进行的，查看Shell当前进程的方式是使用内置的<code>$$</code>、<code>$BASHPID</code>变量查看进程ID，两种用法的区别可以参考<a href="http://showteeth.tech/posts/36597.html">这篇文章</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前shell进程</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看shell脚本执行时的进程ID</span></span><br><span class="line">cat  test_run.sh </span><br><span class="line">  <span class="comment">#!/bin/bash</span></span><br><span class="line">  a=10</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$BASHPID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序执行</span></span><br><span class="line"><span class="comment"># shell子进程ID不同</span></span><br><span class="line">./test_run.sh </span><br><span class="line">  10</span><br><span class="line">  23163</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释器变量执行</span></span><br><span class="line"><span class="comment"># shell子进程ID不同</span></span><br><span class="line">bash test_run.sh </span><br><span class="line">  10</span><br><span class="line">  23194</span><br></pre></td></tr></table></figure><p></p><p>既然是在不同的Shell进程中执行的命令，所以某个shell进程中的全局(局部)变量在另一个Shell进程中是无法使用的，如果想要使用可以使用环境环境变量，具体可以查看<a href="http://showteeth.tech/posts/52906.html">这篇文章</a>。</p><hr><h3 id="source方式执行"><a href="#source方式执行" class="headerlink" title="source方式执行"></a>source方式执行</h3><p><code>source</code>方式执行的脚本不同于上述两种执行方式，其是<strong>在当前Shell进程下执行的</strong>；<code>source</code>执行脚本有<strong>两种写法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两种写法都是使用source执行脚本</span></span><br><span class="line">. test_run.sh</span><br><span class="line"><span class="built_in">source</span> test_run.sh</span><br></pre></td></tr></table></figure><p></p><p>具体示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用source命令执行程序</span></span><br><span class="line"><span class="comment"># 并输出程序执行的Shell进程ID</span></span><br><span class="line"><span class="built_in">source</span> test_run.sh </span><br><span class="line">  10</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line">. test_run.sh </span><br><span class="line">  10</span><br><span class="line">  20924</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前Shell进程ID</span></span><br><span class="line"><span class="comment"># 发现和source执行脚本的进程ID相同</span></span><br><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">  20924</span><br></pre></td></tr></table></figure><p></p><p>因为<code>source</code>执行的脚本是在<strong>当前Shell进程</strong>中进行的，所以<strong>当前Shell进程的全局变量以及脚本中的全局变量是共通的</strong>，两者之间可以相互使用。</p><p>其他<code>source</code>命令注意事项：</p><ul><li><code>source</code> 命令<strong>不需要脚本具有可执行权限</strong>；</li><li><code>source</code> 命令可以<strong>强行让一个脚本去立即影响当前的环境</strong>；</li><li><code>source</code> 命令通常用于<strong>重新执行刚修改的初始化文件，使修改生效</strong>，如<code>~/.bashrc</code>；</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li></li><li><a href="https://www.centos.bz/2017/12/%E8%AF%A6%E8%A7%A3shell%E4%B8%ADsource%E3%80%81sh%E3%80%81bash%E3%80%81-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">详解shell中source、sh、bash、./执行脚本的区别</a></li><li><a href="https://blog.51cto.com/xoyabc/1673249" target="_blank" rel="noopener">shell中的点命令与source命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R系列之向量、矩阵、数组、数据框和列表</title>
      <link href="/posts/30224.html"/>
      <url>/posts/30224.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是基于<a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">这篇文章</a>学习了R中几种常见的数据结构，包括<code>向量</code>、<code>矩阵</code>、<code>数组</code>、<code>数据框</code>以及<code>列表</code>，主要围绕这些数据结构的<code>构成</code>、<code>创建</code>、<code>获取元素</code>进行了学习，后续使用中可以查询和补充。</p></div><a id="more"></a><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量的创建"><a href="#向量的创建" class="headerlink" title="向量的创建"></a>向量的创建</h3><p>向量是用于存储<code>数值型</code>、<code>字符型</code>或<code>逻辑型</code>数据的一维数组。执行组合功能的函数<code>c()</code>可用来<strong>创建向量</strong>。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为数值：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向量创建使用示例</span></span><br><span class="line">&gt; a &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">4</span>)   <span class="comment">#数值型向量</span></span><br><span class="line">&gt; a</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span> -<span class="number">2</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt; b &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)  <span class="comment">#字符型向量</span></span><br><span class="line">&gt; b</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">&gt; c &lt;- c(<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>,<span class="literal">FALSE</span>)  <span class="comment">#逻辑型向量</span></span><br><span class="line">&gt; c</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure><p></p><p>特别地，对于整数型向量，可以使用<code>seq</code>函数进行创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始值（from），结束值（to），步长（by）</span></span><br><span class="line">seq(from = <span class="number">1</span>, to = <span class="number">1</span>, by=step)</span><br><span class="line"><span class="comment"># 创建从1开始到5(包括)截止，步长为1的整数向量</span></span><br><span class="line">seq(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用这种方式创建步长为1的整数向量</span></span><br><span class="line"><span class="number">1</span>:<span class="number">5</span></span><br><span class="line">  [<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p></p><p><strong>创建带名称的向量</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不带名称的向量</span></span><br><span class="line">some_vector &lt;- c(<span class="string">"John Doe"</span>, <span class="string">"poker player"</span>)</span><br><span class="line">some_vector</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"John Doe"</span>     <span class="string">"poker player"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带名称的向量</span></span><br><span class="line">some_vector &lt;- c(<span class="string">"John Doe"</span>, <span class="string">"poker player"</span>)</span><br><span class="line">names(some_vector) &lt;- c(<span class="string">"Name"</span>, <span class="string">"Profession"</span>)</span><br><span class="line">some_vector</span><br><span class="line">          Name     Profession </span><br><span class="line">    <span class="string">"John Doe"</span> <span class="string">"poker player"</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h3><p>通过<code>is.*</code> 函数检查变量的类型，通过<code>as.*</code>函数转换变量的类型：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; vc &lt;- c(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>)</span><br><span class="line"><span class="comment"># 判断vc是不是字符型向量</span></span><br><span class="line">&gt; is.character(vc)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 将vc转换为整数型向量</span></span><br><span class="line">&gt; vi &lt;- as.integer(vc)</span><br><span class="line">&gt; is.integer(vi)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问向量中的元素"><a href="#访问向量中的元素" class="headerlink" title="访问向量中的元素"></a>访问向量中的元素</h3><p>通过索引的方式可以访问向量中的元素，注意<strong>R中是索引开始于1</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取索引为1的元素</span></span><br><span class="line">&gt; a[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line"><span class="comment"># 获取索引为1、5的元素</span></span><br><span class="line">&gt; a[c(<span class="number">1</span>,<span class="number">3</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 切片操作，获取1-3的元素</span></span><br><span class="line">&gt; b[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>获取逻辑判断为TRUE的元素</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过判断语句得到逻辑向量</span></span><br><span class="line">&gt; v&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; class(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"logical"</span></span><br><span class="line"><span class="comment"># 得到逻辑向量为TRUE的索引位置</span></span><br><span class="line">&gt; which(v&gt;<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[which(v&gt;<span class="number">2</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取逻辑向量为TRUE的元素值</span></span><br><span class="line">&gt; v[v&gt;<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="向量的排序"><a href="#向量的排序" class="headerlink" title="向量的排序"></a>向量的排序</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># sort返回排序之后的向量</span></span><br><span class="line">&gt; sort(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># order返回排序后的向量元素在原始向量中的索引位置</span></span><br><span class="line">&gt; order(v)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 通过索引位置获取排序后的向量</span></span><br><span class="line">&gt; v[order(v)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="补充知识-NULL和NA"><a href="#补充知识-NULL和NA" class="headerlink" title="补充知识-NULL和NA"></a>补充知识-NULL和NA</h3><p><code>NULL</code>是个特殊值，表示未知值，<code>NA</code>表示缺失值，<code>NULL</code>和<code>NA</code>之间<strong>最大的区别是</strong>：<code>NA</code>是一个标量值，<code>长度为1</code>，而<code>NULL</code>不会占用任何空间，<strong>长度为零</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出长度</span></span><br><span class="line">&gt; length(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; length(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断null、na</span></span><br><span class="line">&gt; is.null(<span class="literal">NULL</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; is.na(<span class="literal">NA</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h3><p>矩阵是一个二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通 过函数matrix创建矩阵。一般使用格式为：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mymatrix &lt;- matrix(vector,nrow=number_of_rows,ncol=number_of_columns,   </span><br><span class="line">    + byrow=logical_value,dimnames=list(   </span><br><span class="line">    + char_vector_rowname,char_vector_colnames))</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了矩阵的元素，</li><li><code>nrow</code>和<code>ncol</code>用以指定行和列的维数，</li><li><code>dimnames</code>包含了可选的、以字符型向量表示的行名和列名</li><li>选项<code>byrow</code>则表明矩阵应当按行填充（<code>byrow=TRUE</code>）还是按列填充（<code>byrow=FALSE</code>），默认情况下按列填充。简单示例如下：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个5*4的矩阵</span></span><br><span class="line">&gt; y &lt;- matrix(<span class="number">1</span>:<span class="number">20</span>,nrow=<span class="number">5</span>,ncol=<span class="number">4</span>)     </span><br><span class="line">&gt; y</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span>   <span class="number">11</span>   <span class="number">16</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span>   <span class="number">12</span>   <span class="number">17</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span>   <span class="number">13</span>   <span class="number">18</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span>   <span class="number">14</span>   <span class="number">19</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span>   <span class="number">15</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按行填充的2*2矩阵</span></span><br><span class="line">&gt; cells &lt;- c(<span class="number">1</span>,<span class="number">26</span>,<span class="number">24</span>,<span class="number">68</span>)</span><br><span class="line">&gt; rnames &lt;- c(<span class="string">"R1"</span>,<span class="string">"R2"</span>)</span><br><span class="line">&gt; cname &lt;- c(<span class="string">"C1"</span>,<span class="string">"C2"</span>)</span><br><span class="line">&gt; &gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">TRUE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">26</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">#按列填充的2*2矩阵</span></span><br><span class="line">&gt; mymatrix &lt;- matrix(cells,nrow=<span class="number">2</span>,ncol=<span class="number">2</span>,byrow=<span class="literal">FALSE</span>,</span><br><span class="line">+ dimnames=list(rnames,cname))</span><br><span class="line">&gt; mymatrix</span><br><span class="line">    C1 C2</span><br><span class="line">R1  <span class="number">1</span> <span class="number">24</span></span><br><span class="line">R2 <span class="number">26</span> <span class="number">68</span></span><br></pre></td></tr></table></figure><hr><h3 id="矩阵元素的获取"><a href="#矩阵元素的获取" class="headerlink" title="矩阵元素的获取"></a>矩阵元素的获取</h3><p>我们可以使用索引的方式来选择矩阵中的行、列或元素。<code>X[i,]</code>指矩阵X中的第i行，<code>X[,j]</code>指第j列，<code>X[i, j]</code>指第i行第j个元素。选择<strong>多行或多列</strong>时，下标i和j可为数值型向量，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">2</span>)</span><br><span class="line">&gt; x</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">7</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span>    <span class="number">8</span>   <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二行的元素</span></span><br><span class="line">&gt; x[<span class="number">2</span>,]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 获取第二列的元素</span></span><br><span class="line">&gt; x[,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取第一行第4列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span></span><br><span class="line"><span class="comment"># 获取第一行第4列、第五列的元素</span></span><br><span class="line">&gt; x[<span class="number">1</span>,c(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p></p><p>矩阵都是二维的，和向量类似，<strong>矩阵中也仅能包含一种数据类型</strong>；当<strong>维度超过2时，不妨使用数组</strong>；当有<strong>多种模式的数据时，不妨使用数据框</strong>。</p><hr><p><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p>数组（array）与矩阵类似，但是维度可以大于2。数组可通过array函数创建，形式如下：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray &lt;- array(vector,dimensions,dimnames)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>vector</code>包含了数组中的数据；</li><li><code>dimensions</code>是一个数值型向量，给出了各个维度下标的最大值；</li><li><code>dimnames</code>是可选的、各维度名称标签的列表。</li></ul><p>创建三维 （2×3×4）数值型数组:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; z &lt;- array(<span class="number">1</span>:<span class="number">24</span>, c(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&gt; z</span><br><span class="line">, , <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span></span><br><span class="line">A2  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1  <span class="number">7</span>  <span class="number">9</span> <span class="number">11</span></span><br><span class="line">A2  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">13</span> <span class="number">15</span> <span class="number">17</span></span><br><span class="line">A2 <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">, , <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    B1 B2 B3</span><br><span class="line">A1 <span class="number">19</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line">A2 <span class="number">20</span> <span class="number">22</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p></p><p>如你所见，数组是矩阵的一个自然推广；它们在编写新的统计方法时可能很有用。</p><p>像矩阵一样，<strong>数组中的数据也只能拥有一种模式</strong>。</p><hr><h3 id="数组元素的获取"><a href="#数组元素的获取" class="headerlink" title="数组元素的获取"></a>数组元素的获取</h3><p>从数组中选取元素的方式与矩阵类似：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">15</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">1</span>,<span class="number">2</span>,]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">3</span>  <span class="number">9</span> <span class="number">15</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>由于<strong>不同的列可以包含不同模式（数值型、字符型等）的数据，但每一列的数据类型必须唯一</strong>，数据框的用途更为广泛。</p><h3 id="数据框的创建"><a href="#数据框的创建" class="headerlink" title="数据框的创建"></a>数据框的创建</h3><p>数据框可通过函数<code>data.frame()</code>创建：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydata &lt;- data.frame(col1,col2,col3,…)</span><br></pre></td></tr></table></figure><p></p><ul><li>列向量<code>col1</code>, <code>col2</code>, <code>col3</code>,… 可为任何类型（如字符型、数值型或逻辑型）</li><li>每一列的名称可由函数<code>names</code>指定</li></ul><p>使用实例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientID &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt; age &lt;- c(<span class="number">25</span>,<span class="number">34</span>,<span class="number">28</span>,<span class="number">52</span>)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID,age,diabetes,status)</span><br><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br></pre></td></tr></table></figure><p></p><p>每一列数据的模式必须唯一，不过你却可以将多个模式的不同列放到一起组成数据框。</p><h3 id="数据框元素的获取"><a href="#数据框元素的获取" class="headerlink" title="数据框元素的获取"></a>数据框元素的获取</h3><p>选取数据框中元素的方式有若干种，你可以使用索引，亦可直接指定列名。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; patientdata</span><br><span class="line">  patientID age diabetes    status</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span>    Type1      Poor</span><br><span class="line"><span class="comment"># 通过索引</span></span><br><span class="line">&gt; patientdata[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">  patientID age</span><br><span class="line"><span class="number">1</span>         <span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>         <span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>         <span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>         <span class="number">4</span>  <span class="number">52</span></span><br><span class="line"><span class="comment"># 直接指定列名</span></span><br><span class="line">&gt; patientdata[c(<span class="string">"diabetes"</span>,<span class="string">"status"</span>)]</span><br><span class="line">  diabetes    status</span><br><span class="line"><span class="number">1</span>    Type1      Poor</span><br><span class="line"><span class="number">2</span>    Type2  Improved</span><br><span class="line"><span class="number">3</span>    Type1 Excellent</span><br><span class="line"><span class="number">4</span>    Type1      Poor</span><br><span class="line">&gt; patientdata[c(<span class="string">"age"</span>)]</span><br><span class="line">  age</span><br><span class="line"><span class="number">1</span>  <span class="number">25</span></span><br><span class="line"><span class="number">2</span>  <span class="number">34</span></span><br><span class="line"><span class="number">3</span>  <span class="number">28</span></span><br><span class="line"><span class="number">4</span>  <span class="number">52</span></span><br><span class="line">&gt; class(patientdata[c(<span class="string">"age"</span>)])</span><br><span class="line">[<span class="number">1</span>] <span class="string">"data.frame"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某列的值，并得到向量</span></span><br><span class="line">&gt; patientdata$age</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">&gt; class(patientdata$age)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br></pre></td></tr></table></figure><p></p><p>第三个例子中的记号<code>$</code>是新出现的，它被用来<strong>选取一个给定数据框中的某个特定变量，并且返回向量形式</strong>。例如，如果你想生成糖尿病类型变量diabetes和病情变量status的列联表，使用以下代码即可：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; table(patientdata$diabetes,patientdata$status)</span><br><span class="line"></span><br><span class="line">        Excellent Improved Poor</span><br><span class="line">  Type1         <span class="number">1</span>        <span class="number">0</span>    <span class="number">2</span></span><br><span class="line">  Type2         <span class="number">0</span>        <span class="number">1</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>在每个变量名前都键入一次<code>patientdata$</code>可能会让人生厌，所以不妨走一些捷径。可以联合使用函数<code>attach()</code>和<code>detach()</code>或单独使用函数<code>with()</code>来简化代码.</p><p><code>attach()</code>函数可<strong>将数据框添加到R的搜索路径中</strong>，R在遇到一个变量名以后，将检查搜索路径中的数据框，以定位到这个变量：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;summary(mtcars$mpg)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line">&gt;plot(mtcars$mpg,mtcars$disp)</span><br><span class="line">&gt; <span class="comment">#也可写成：</span></span><br><span class="line"><span class="comment"># 将数据框添加到R的搜索路径中</span></span><br><span class="line">&gt;<span class="keyword">attach</span>(mtcars)</span><br><span class="line">&gt;plot(mpg,disp)</span><br><span class="line"><span class="comment"># 将数据框从搜索路径中移除</span></span><br><span class="line">&gt;<span class="keyword">detach</span>(mtcars)</span><br></pre></td></tr></table></figure><p>当<strong>名称相同的对象不止一个时</strong>，这种方法的局限性就很明显了。<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; mpg &lt;- c(<span class="number">25</span>,<span class="number">36</span>,<span class="number">47</span>)</span><br><span class="line">&gt; <span class="keyword">attach</span>(mtcars)</span><br><span class="line">The following object is masked _by_ .GlobalEnv:  mpg</span><br><span class="line"><span class="comment"># mtcars中也有mpg变量</span></span><br><span class="line">&gt; plot(mpg,wt)</span><br><span class="line">Error <span class="keyword">in</span> xy.coords(x, y, xlabel, ylabel, log) : </span><br><span class="line">  <span class="string">'x'</span> and <span class="string">'y'</span> lengths differ</span><br><span class="line">&gt; mpg</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">36</span> <span class="number">47</span></span><br><span class="line"><span class="comment"># 指定mpg来源</span></span><br><span class="line">&gt; plot(mtcars$mpg,wt)</span><br></pre></td></tr></table></figure><p></p><p>这里，在数据框mtcars被绑定（attach）之前，我们的环境中已经有了一个名为mpg的对象。 在这种情况下，原始对象将取得优先权，故而报错，这个时候想使用mpg时，便要像最后一段代码示例那般指定变量来源。</p><p>除此之外，另一种方式是使用函数<code>with()</code>，你可以这样重写上例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ plot(mpg,disp)</span><br><span class="line">+ &#125;)</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，<strong>大括号{}之间的语句都针对数据框mtcars执行</strong>，这样就无须担心名称冲突了；如果<strong>仅有一条语句（例如summary(mpg)），那么大括号{}可以省略</strong>；<strong>函数<code>with()</code>的局限性在于，赋值仅在此函数的括号内生效</strong>，如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;stats &lt;-summary(mpg)</span><br><span class="line">+ stats</span><br><span class="line">+ &#125;)</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span> </span><br><span class="line"><span class="comment"># 在with的&#123;&#125;之外</span></span><br><span class="line">&gt; stats</span><br><span class="line">错误: 找不到对象<span class="string">'stats'</span></span><br></pre></td></tr></table></figure><p></p><p>如果你需要创建在<code>with()</code>结构以外存在的对象，使用<code>特殊赋值符&lt;&lt;-</code>替代<code>标准赋值符&lt;-</code>即可，它可将对象保存到<code>with()</code>之外的全局环境中。如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; with(mtcars,&#123;</span><br><span class="line">+ nokeepstats &lt;- summary(mpg)</span><br><span class="line">+ keepstats &lt;&lt;- summary(mpg)</span><br><span class="line">+ &#125;)</span><br><span class="line">&gt; nokeepstats</span><br><span class="line">错误: 找不到对象<span class="string">'nokeepstats'</span></span><br><span class="line">&gt; keepstats</span><br><span class="line">    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">10.40</span>   <span class="number">15.42</span>   <span class="number">19.20</span>   <span class="number">20.09</span>   <span class="number">22.80</span>   <span class="number">33.90</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>如你所见，变量可归结为名义型、有序型或连续型变量。名义型变量是没有顺序之分的类别变量，糖尿病类型Diabetes（Type1、Type2）是名义型变量的一例，即使在数据中Type1编码为1而Type2编码为2，这也并不意味着二者是有序的。有序型变量表示一种顺序关系，而非数量关系，病情Status（poor、improved、excellent）是顺序型变量的一个上佳示例。我们明白， 病情为poor（较差）病人的状态不如improved（病情好转）的病人，但并不知道相差多少。连续型变量可以呈现为某个范围内的任意值，并同时表示了顺序和数量，年龄Age就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值，我们很清楚，15岁的人比14岁的人年长一岁。</p><p><strong>类别（名义型）变量</strong>和<strong>有序类别（有序型）变量</strong>在R中称为<strong>因子（factor）</strong>。因子在R中非常重要，因为它决定了<strong>数据的分析方式</strong>以及<strong>如何进行视觉呈现</strong>，你将在本书中通篇看到这样的例子。函数<code>factor()</code>以一个整数向量的形式存储类别值，整数的取值范围是<code>[1… k]</code>（其中<code>k</code>是名义型变量中<strong>唯一值</strong>的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</p><p>举例来说，假设有向量：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; diabetes &lt;- c( <span class="string">"Type1"</span>,<span class="string">"Type2"</span>,<span class="string">"Type1"</span>,<span class="string">"Type1"</span>)</span><br><span class="line">&gt; diabetes &lt;- factor(diabetes)</span><br><span class="line">&gt; diabetes</span><br><span class="line">[<span class="number">1</span>] Type1 Type2 Type1 Type1</span><br><span class="line">Levels: Type1 Type2</span><br></pre></td></tr></table></figure><p></p><p>语句<code>diabetes &lt;- factor(diabetes)</code>将此向量存储为<code>(1, 2, 1, 1)</code>，并在内部将其关联为<code>1=Type1</code>和<code>2=Type2</code>（具体赋值根据字母顺序而定）。针对向量diabetes进行的任何分析都会<strong>将其作为名义型变量对待</strong>，并<strong>自动选择适合这一测量尺度的统计方法</strong>。要表示<strong>有序型变量</strong>，需要为函数<code>factor()</code>指定参数<code>ordered=TRUE</code>。给定向量:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>)</span><br></pre></td></tr></table></figure><p></p><p>语句<code>status &lt;- factor(status, ordered=TRUE)</code>会将向量编码为<code>(3, 2, 1, 3)</code>，并在内部将这些值关联为<code>1=Excellent</code>、<code>2=Improved</code>以及<code>3=Poor</code>.对于<strong>字符型向量</strong>，因子的水平<strong>默认依字母顺序创建</strong>，这对于因子status是有意义的，因为 <code>Excellent</code>、<code>Improved</code>、<code>Poor</code>的排序方式恰好与逻辑顺序相一致，如果<code>Poor</code>被编码为<code>Ailing</code>，会有问题，因为顺序将为<code>Ailing</code>、<code>Excellent</code>、<code>Improved</code>。如果理想中的顺序是<code>Poor</code>、<code>Improved</code>、<code>Excellent</code>，则会出现类似的问题：按默认的字母顺序排序的因子很少能够让人满意，你可以通过指定<code>levels</code>选项来覆盖默认排序。例如：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是按照字母顺序创建</span></span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现Ailing会破坏顺序</span></span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>,<span class="string">"Poor"</span>,<span class="string">"Ailing"</span>)</span><br><span class="line">&gt; status=factor(status, ordered=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor      Ailing   </span><br><span class="line">Levels: Ailing &lt; Excellent &lt; Improved &lt; Poor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用levels指定顺序</span></span><br><span class="line">&gt; status &lt;- factor(status,ordered=<span class="literal">TRUE</span>,</span><br><span class="line">+ levels=c(<span class="string">"Poor"</span>,<span class="string">"Improved"</span>,<span class="string">"Excellent"</span>)</span><br><span class="line">+ )</span><br><span class="line">&gt; status</span><br><span class="line">[<span class="number">1</span>] Poor      Improved  Excellent Poor     </span><br><span class="line">Levels: Poor &lt; Improved &lt; Excellent</span><br></pre></td></tr></table></figure><p></p><p>因子的使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建dataframe</span></span><br><span class="line">&gt; patientdata &lt;-data.frame(patientID,age,diabetes,status)</span><br><span class="line"><span class="comment"># 查看各列数据的类型</span></span><br><span class="line">&gt; str(patientdata)</span><br><span class="line"><span class="string">'data.frame'</span>:   <span class="number">4</span> obs. of  <span class="number">4</span> variables:</span><br><span class="line">  $ patientID: num  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">  $ age      : num  <span class="number">25</span> <span class="number">34</span> <span class="number">28</span> <span class="number">52</span></span><br><span class="line">  $ diabetes : Factor w/ <span class="number">2</span> levels <span class="string">"Type1"</span>,<span class="string">"Type2"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  $ status   : Ord.factor w/ <span class="number">3</span> levels <span class="string">"Poor"</span>&lt;<span class="string">"Improved"</span>&lt;..: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 显示基本统计信息</span></span><br><span class="line">&gt; summary(patientdata)</span><br><span class="line">    patientID         age         diabetes       status </span><br><span class="line">  Min.   :<span class="number">1.00</span>   Min.   :<span class="number">25.00</span>   Type1:<span class="number">3</span>   Poor     :<span class="number">2</span>  </span><br><span class="line">  1st Qu.:<span class="number">1.75</span>   1st Qu.:<span class="number">27.25</span>   Type2:<span class="number">1</span>   Improved :<span class="number">1</span>  </span><br><span class="line">  Median :<span class="number">2.50</span>   Median :<span class="number">31.00</span>             Excellent:<span class="number">1</span>  </span><br><span class="line">  Mean   :<span class="number">2.50</span>   Mean   :<span class="number">34.75</span>                          </span><br><span class="line">  3rd Qu.:<span class="number">3.25</span>   3rd Qu.:<span class="number">38.50</span>                          </span><br><span class="line">  Max.   :<span class="number">4.00</span>   Max.   :<span class="number">52.00</span></span><br></pre></td></tr></table></figure><p></p><p><code>str(patientdata)</code>清楚地显示<code>diabetes</code>是一个<strong>因子</strong>，而<code>status</code>是一个<strong>有序型因子</strong>，以及此数据框在<strong>内部是如何进行编码的</strong>。注意，函数<code>summary()</code>会<strong>区别对待各个变量</strong>，它显示了连续型变量age的最小值、最大值、均值和各四分位数，并显示了类别型变量diabetes和status（各水平）的频数值。</p><hr><p><br></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）是R的数据类型中为复杂的一种，一般来说，列表就是一些对象（或成分， component）的有序集合，列表允许你整合若干（可能无关的）对象到单个对象名下。例如，某个列表中可能是若干<strong>向量</strong>、<strong>矩阵</strong>、<strong>数据框</strong>，甚至<strong>其他列表</strong>的组合。</p><p>可以使用函数<code>list()</code>创建列表:<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;- list(object1,object2,…)</span><br></pre></td></tr></table></figure><p></p><p>其中的对象可以是目前为止讲到的任何结构。你还可以为列表中的对象命名：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mylist &lt;`- list(name1=object1,name2=object2,…)</span><br></pre></td></tr></table></figure><p>具体使用示例：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; g &lt;- <span class="string">"My First List"</span></span><br><span class="line">&gt; h &lt;- c(<span class="number">25</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">39</span>)</span><br><span class="line">&gt; j &lt;- matrix(<span class="number">1</span>:<span class="number">10</span>,nrow=<span class="number">5</span>)</span><br><span class="line">&gt; k &lt;- c(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)</span><br><span class="line">&gt; mylist &lt;- list(title=g,ages=h,j,k)</span><br><span class="line">&gt; mylist</span><br><span class="line">$title</span><br><span class="line">[<span class="number">1</span>] <span class="string">"My First List"</span></span><br><span class="line"></span><br><span class="line">$ages</span><br><span class="line">[<span class="number">1</span>] <span class="number">25</span> <span class="number">26</span> <span class="number">18</span> <span class="number">39</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">      [,<span class="number">1</span>] [,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">6</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">7</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">8</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">5</span>,]    <span class="number">5</span>   <span class="number">10</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br></pre></td></tr></table></figure><p></p><p>本例创建了一个列表，其中有四个成分：一个字符串、一个数值型向量、一个矩阵以及一个字符型向量。</p><p>在访问列表中元素时，可以通过在<strong>双重方括号</strong>中<strong>指明代表某个成分的数字</strong>或<strong>名称</strong>来访问列表中的元素。此例 中，<code>mylist[[2]]</code>和<code>mylist[[“ages”]]</code>均指那个含有四个元素的向量。</p><p>由于两个原因，列表成为了R中的重要数据结构:</p><ul><li>首先，列表允许以一种简单的方式组织和重新调用不相干的信息；</li><li>其次，许多R函数的运行结果都是以列表的形式返回的，需要取出其中哪些成分由分析人员决定。</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/qq_28945021/article/details/52100765" target="_blank" rel="noopener">R语言入门之创建数据集——向量、矩阵、数组、数据框和列表</a></li><li><a href="https://www.cnblogs.com/ljhdo/p/5173674.html" target="_blank" rel="noopener">R语言学习 第一篇：变量和向量</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R系列之字符串处理</title>
      <link href="/posts/28337.html"/>
      <url>/posts/28337.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<strong>R中的字符向量处理函数</strong>，主要包括<strong>字符数统计和字符翻译</strong>、<strong>字符串连接</strong>、<strong>字符串拆分</strong>、<strong>字符串查询</strong>、<strong>字符串替换</strong>、<strong>字符串提取</strong>、<strong>字符串显示控制</strong>等。</p></div><a id="more"></a><h2 id="字符数统计和字符翻译"><a href="#字符数统计和字符翻译" class="headerlink" title="字符数统计和字符翻译"></a>字符数统计和字符翻译</h2><h3 id="nchar和length"><a href="#nchar和length" class="headerlink" title="nchar和length"></a>nchar和length</h3><p><code>nchar</code>这个函数简单，统计<strong>向量中每个元素的字符个数</strong>，注意<strong>这个函数和<code>length</code>函数的差别</strong>：</p><ul><li><code>nchar</code>是<strong>向量元素的字符个数</strong>;</li><li>而<code>length</code>是<strong>向量长度（向量元素的个数）</strong>.</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"Hellow"</span>, <span class="string">"World"</span>, <span class="string">"!"</span>)</span><br><span class="line"><span class="comment"># 向量中每个元素的长度</span></span><br><span class="line">nchar(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">6</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量的长度</span></span><br><span class="line">length(x)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h3 id="tolower、toupper和chartr"><a href="#tolower、toupper和chartr" class="headerlink" title="tolower、toupper和chartr"></a>tolower、toupper和chartr</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DNA &lt;- <span class="string">"AtGCtttACC"</span></span><br><span class="line"><span class="comment"># 将上述字符转换为小写</span></span><br><span class="line">tolower(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"atgctttacc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述字符转换为大写</span></span><br><span class="line">toupper(DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"ATGCTTTACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;u</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"Uu"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AuGCuuuACC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将T-&gt;U、t-&gt;U</span></span><br><span class="line">chartr(<span class="string">"Tt"</span>, <span class="string">"UU"</span>, DNA)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"AUGCUUUACC"</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><h3 id="paste函数"><a href="#paste函数" class="headerlink" title="paste函数"></a>paste函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义分隔符</span></span><br><span class="line">paste (<span class="keyword">...</span>, sep = <span class="string">" "</span>, collapse = <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment"># 默认没有分隔符</span></span><br><span class="line">paste0(<span class="keyword">...</span>, collapse = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短的向量CK会被循环使用</span></span><br><span class="line">paste(<span class="string">"CK"</span>, <span class="number">1</span>:<span class="number">6</span>, sep = <span class="string">"|"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"CK|1"</span> <span class="string">"CK|2"</span> <span class="string">"CK|3"</span> <span class="string">"CK|4"</span> <span class="string">"CK|5"</span> <span class="string">"CK|6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短的向量会被循环使用</span></span><br><span class="line">x = c(a = <span class="string">"aaa"</span>, b = <span class="string">"bbb"</span>, c = <span class="string">"ccc"</span>)</span><br><span class="line">y = c(d = <span class="number">1</span>, e = <span class="number">2</span>)</span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>) </span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span> <span class="string">"bbb-2"</span> <span class="string">"ccc-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述操作返回的都是一个向量</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>)[<span class="number">1</span>]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想将所有的连接成一个字符串</span></span><br><span class="line"><span class="comment"># 使用collapse参数</span></span><br><span class="line">paste(x, y, sep = <span class="string">"-"</span>,collapse = <span class="string">";"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"aaa-1;bbb-2;ccc-1"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><h3 id="strsplit函数"><a href="#strsplit函数" class="headerlink" title="strsplit函数"></a>strsplit函数</h3><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strsplit(x, split, fixed = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li>参数<code>x</code>为字串向量，<strong>每个元素都将单独进行拆分</strong>;</li><li>参数<code>split</code>为拆分位置的字串向量，默认<code>fixed=FALSE</code>为<strong>正则表达式匹配</strong>。如果你没接触过正则表达式，设置<code>fixed=TRUE</code>，表示使用<strong>普通文本匹配或正则表达式的精确匹配</strong>；普通文本的运算速度快;</li><li><code>perl=TRUE/FALSE</code>的设置和perl语言版本有关，如果正则表达式很长，正确设置表达式并且使用perl=TRUE可以提高运算速度;</li><li>参数<code>useBytes</code>设置<strong>是否逐个字节进行匹配</strong>，默认为FALSE，即按字符而不是字节进行匹配。</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- <span class="string">"Hello Adam!\nHello Ava!"</span></span><br><span class="line"><span class="comment"># 将上述字符按空格分隔</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span>        <span class="string">"Adam!\nHello"</span> <span class="string">"Ava!"</span> </span><br><span class="line"><span class="comment"># 返回的是一个列表</span></span><br><span class="line">class(strsplit(text, <span class="string">" "</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line"><span class="comment"># 输出分割后的第一个字符</span></span><br><span class="line">strsplit(text, <span class="string">" "</span>)[[<span class="number">1</span>]][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式进行分割</span></span><br><span class="line"><span class="comment"># 按空白分隔：空格、制表符、换行符等</span></span><br><span class="line">strsplit(text, <span class="string">"\\s"</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hello"</span> <span class="string">"Adam!"</span> <span class="string">"Hello"</span> <span class="string">"Ava!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到单个字符</span></span><br><span class="line">strsplit(text, <span class="string">""</span>)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"d"</span>  <span class="string">"a"</span>  <span class="string">"m"</span>  <span class="string">"!"</span>  <span class="string">"\n"</span> <span class="string">"H"</span>  <span class="string">"e"</span>  <span class="string">"l"</span>  <span class="string">"l"</span>  <span class="string">"o"</span>  <span class="string">" "</span>  <span class="string">"A"</span>  <span class="string">"v"</span>  <span class="string">"a"</span>  <span class="string">"!"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h2><h3 id="grep和grepl函数"><a href="#grep和grepl函数" class="headerlink" title="grep和grepl函数"></a>grep和grepl函数</h3><p>这两个函数返回向量水平的匹配结果(向量中每个元素可以不可以匹配上)，不涉及匹配字符串的详细位置信息(在每个元素的什么索引位置匹配上).</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>, value = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>, invert = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">grepl(pattern, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">      fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下所有的文件</span></span><br><span class="line">files &lt;- list.files(<span class="string">"./"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找以gz结尾的文件</span></span><br><span class="line"><span class="comment"># 返回的是可以匹配上的元素在整个向量中的索引位置</span></span><br><span class="line">grep(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的是向量元素中的每一个是不是可以匹配上</span></span><br><span class="line">grepl(<span class="string">"\\.gz$"</span>, files)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者虽然在输出表现上有所差异，但是在提取向量子集时结果相同</span></span><br><span class="line">files[grep(<span class="string">"\\.gz$"</span>, files)]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="regexpr、gregexpr和regexec"><a href="#regexpr、gregexpr和regexec" class="headerlink" title="regexpr、gregexpr和regexec"></a>regexpr、gregexpr和regexec</h3><p>这三个函数返回的结果包含了<strong>匹配的具体位置</strong>和<strong>匹配上的字符串长度信息</strong>，可以用于字符串的提取操作.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gregexpr(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">         fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">regexec(pattern, text, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">        fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>三个函数的区别：</p><ul><li><code>regexpr</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>数字向量</strong></li><li><code>gregexpr</code>返回的是向量中每个元素<strong>所有出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li><li><code>regexec</code>返回的是向量中每个元素<strong>首次出现</strong>匹配上的字符的索引位置，返回的数据类型为<strong>列表</strong></li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">text &lt;- c(<span class="string">"Hellow, Adam!Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素第一次出现Adam的位置</span></span><br><span class="line">class(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"integer"</span></span><br><span class="line">regexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  <span class="comment"># 匹配上的第一个字符位置 </span></span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span>  <span class="number">5</span> <span class="number">14</span></span><br><span class="line">  <span class="comment"># 匹配上的部分长度</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 获取上述结果中的match.length</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  $match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  $index.type</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line"></span><br><span class="line">  $useBytes</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 得到向量</span></span><br><span class="line">attributes(regexpr(<span class="string">"Adam"</span>, text))$match.length</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素所有出现Adam的位置</span></span><br><span class="line">class(gregexpr(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">gregexpr(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">9</span> <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># 这个也是一样的方法</span></span><br><span class="line">attributes(gregexpr(<span class="string">"Adam"</span>, text)[[<span class="number">1</span>]])$match.length</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个元素首次出现Adam的位置</span></span><br><span class="line">class(regexec(<span class="string">"Adam"</span>, text))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"list"</span></span><br><span class="line">regexec(<span class="string">"Adam"</span>, text)</span><br><span class="line">  [[<span class="number">1</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">9</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">2</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">5</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span>]]</span><br><span class="line">  [<span class="number">1</span>] <span class="number">14</span></span><br><span class="line">  attr(,<span class="string">"match.length"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">  attr(,<span class="string">"index.type"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"chars"</span></span><br><span class="line">  attr(,<span class="string">"useBytes"</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="sub和gsub函数"><a href="#sub和gsub函数" class="headerlink" title="sub和gsub函数"></a>sub和gsub函数</h3><p>虽然<code>sub</code>和<code>gsub</code>是用于字符串替换的函数，但严格地说R语言没有字符串替换的函数，因为<strong>R语言不管什么操作对参数都是传值不传址(原始变量不会被修改)</strong>.</p><p>帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">    fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">gsub(pattern, replacement, x, ignore.case = <span class="literal">FALSE</span>, perl = <span class="literal">FALSE</span>,</span><br><span class="line">     fixed = <span class="literal">FALSE</span>, useBytes = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p></p><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sub</span></span><br><span class="line"><span class="comment"># 将每个元素中的Adam替换为world</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始的text的内容还是没有发生改变</span></span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, Adam!"</span>      <span class="string">"Hi, Adam!"</span>          <span class="string">"How are you, Adam."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gsub</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world!"</span>      <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取表达式</span></span><br><span class="line"><span class="comment"># 使用转义字符+数字表示分组</span></span><br><span class="line">sub(pattern = <span class="string">".*(Adam).*"</span>, replacement = <span class="string">"\\1"</span>, text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Adam"</span> <span class="string">"Adam"</span> <span class="string">"Adam"</span></span><br></pre></td></tr></table></figure><p></p><p><code>sub</code>和<code>gsub</code>的区别：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改text内容</span></span><br><span class="line">text &lt;- c(<span class="string">"Hellow, Adam! Adam"</span>, <span class="string">"Hi, Adam!"</span>, <span class="string">"How are you, Adam."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub只会替换第一次出现的</span></span><br><span class="line">sub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! Adam"</span> <span class="string">"Hi, world!"</span>          <span class="string">"How are you, world."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而gsub会将所有的都进行替换</span></span><br><span class="line">gsub(pattern = <span class="string">"Adam"</span>,replacement = <span class="string">"world"</span>,text)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"Hellow, world! world"</span> <span class="string">"Hi, world!"</span>           <span class="string">"How are you, world."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串提取"><a href="#字符串提取" class="headerlink" title="字符串提取"></a>字符串提取</h2><h3 id="substr和substring函数"><a href="#substr和substring函数" class="headerlink" title="substr和substring函数"></a>substr和substring函数</h3><p><code>substr</code>和<code>substring</code>函数<strong>通过位置进行字符串拆分或提取</strong>，它们<strong>本身并不使用正则表达式</strong>，但是结合正则表达式函数<code>regexpr</code>、<code>gregexpr</code>或<code>regexec</code>使用可以非常方便地从大量文本中提取所需信息。两者的参数设置基本相同：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substr(x, start, <span class="keyword">stop</span>)</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>)</span><br><span class="line">substr(x, start, <span class="keyword">stop</span>) &lt;- value</span><br><span class="line">substring(text, first, last = <span class="number">1000000L</span>) &lt;- value</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>均为要拆分的字串向量</li><li><code>start/first</code> 为截取的起始位置向量</li><li><code>stop/last</code> 为截取字串的终止位置向量</li></ul><p>两个函数在返回值上存在差异：</p><ul><li>substr返回的字串个数等于第一个参数(要拆分的字串向量)的长度</li><li>substring返回字串个数等于三个参数中最长向量长度(要拆分的字串向量、起始位置向量、终止位置向量)，短向量循环使用</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">"123456789"</span></span><br><span class="line"><span class="comment"># 截取的区间是2-4、4-5、2-8(单向量循环使用)</span></span><br><span class="line"><span class="comment"># 因为x的长度为1，所以只会输出第一个2-4的结果</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># substring使用是输出最长向量长度的子串</span></span><br><span class="line">substring(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"45"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>关于短向量循环使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = c(<span class="string">"123456789"</span>, <span class="string">"abcdefghijklmnopq"</span>)</span><br><span class="line"><span class="comment"># 因为x的长度为2，所以输出了两个</span></span><br><span class="line"><span class="comment"># 另外，x向量也会循环使用，2-4切数字、4-5切字母</span></span><br><span class="line">substr(x, c(<span class="number">2</span>, <span class="number">4</span>), c(<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span> <span class="string">"de"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于x也可以循环可以看看substring</span></span><br><span class="line"><span class="comment"># 2-4切数字、4-5切字母、2-8切数字</span></span><br><span class="line">substring(x,c(<span class="number">2</span>,<span class="number">4</span>),c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"234"</span>     <span class="string">"de"</span>      <span class="string">"2345678"</span></span><br></pre></td></tr></table></figure><p></p><p>用<code>substring</code>函数可以很方便地把<code>DNA/RNA</code>序列进行<strong>三联拆分（用于蛋白质翻译）</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到随机序列</span></span><br><span class="line">bases = c(<span class="string">"A"</span>, <span class="string">"T"</span>, <span class="string">"G"</span>, <span class="string">"C"</span>)</span><br><span class="line">DNA = paste(sample(bases, <span class="number">12</span>, replace = <span class="literal">T</span>), collapse = <span class="string">""</span>)</span><br><span class="line">DNA</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCTGTCGGCTGC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三联拆分</span></span><br><span class="line">substring(DNA, seq(<span class="number">1</span>, <span class="number">10</span>, by = <span class="number">3</span>), seq(<span class="number">3</span>, <span class="number">12</span>, by = <span class="number">3</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"GCT"</span> <span class="string">"GTC"</span> <span class="string">"GGC"</span> <span class="string">"TGC"</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="字符串显示控制"><a href="#字符串显示控制" class="headerlink" title="字符串显示控制"></a>字符串显示控制</h2><h3 id="显示宽度-strtrim函数"><a href="#显示宽度-strtrim函数" class="headerlink" title="显示宽度-strtrim函数"></a>显示宽度-strtrim函数</h3><p>用于将字符串修剪到特定的显示宽度，其用法为<code>strtrim(x, width)</code>，<strong>返回字符串向量的长度等于x的长度</strong>。因为是“修剪”，所以<strong>只能去掉多余的字符不能增加其他额外的字符(这就感觉很鸡肋了。。。。)</strong>; 如果<strong>字符串本身的长度小于width，得到的是原字符串</strong>，别指望它会用空格或其他什么字符补齐：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大于width的字符部分会被去除</span></span><br><span class="line">strtrim(c(<span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>), c(<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"a"</span>      <span class="string">"abcde"</span>  <span class="string">"abcdef"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不足width的字符会输出原字符串</span></span><br><span class="line">strtrim(c(<span class="number">1</span>, <span class="number">123</span>, <span class="number">1234567</span>), <span class="number">4</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"1"</span>    <span class="string">"123"</span>  <span class="string">"1234"</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="字符串段落化-strwrap函数"><a href="#字符串段落化-strwrap函数" class="headerlink" title="字符串段落化-strwrap函数"></a>字符串段落化-strwrap函数</h3><p>strwrap函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串，其帮助文档：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strwrap(x, width = <span class="number">0.9</span> * getOption(<span class="string">"width"</span>), indent = <span class="number">0</span>,</span><br><span class="line">        exdent = <span class="number">0</span>, prefix = <span class="string">""</span>, simplify = <span class="literal">TRUE</span>, initial = prefix)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>x</code>表示待处理的字符向量</li><li><code>width</code>表示每行的宽度</li><li><code>indent</code>表示首行缩进</li><li><code>exdent</code>表示除首行外的其他行的缩进</li><li><code>simplify</code>表示结果的显示形式，<code>TRUE</code>表示返回向量，<code>FALSE</code>表示返回列表</li></ul><p>具体使用：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"Each character string in the input is first split into paragraphs\n(or lines containing whitespace only).  The paragraphs are then\nformatted by breaking lines at word boundaries.  The target\ncolumns for wrapping lines and the indentation of the first and\nall subsequent lines of a paragraph can be controlled\nindependently."</span></span><br><span class="line">str2 = rep(str1, <span class="number">2</span>)</span><br><span class="line">strwrap(str2, width = <span class="number">80</span>, indent = <span class="number">2</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">2</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">3</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">4</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">5</span>] <span class="string">"controlled independently."</span>                                                    </span><br><span class="line">  [<span class="number">6</span>] <span class="string">"  Each character string in the input is first split into paragraphs (or lines"</span></span><br><span class="line">  [<span class="number">7</span>] <span class="string">"containing whitespace only).  The paragraphs are then formatted by breaking"</span>  </span><br><span class="line">  [<span class="number">8</span>] <span class="string">"lines at word boundaries.  The target columns for wrapping lines and the"</span>     </span><br><span class="line">  [<span class="number">9</span>] <span class="string">"indentation of the first and all subsequent lines of a paragraph can be"</span>      </span><br><span class="line">  [<span class="number">10</span>] <span class="string">"controlled independently."</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><p>##参考链接</p><ul><li><a href="https://blog.csdn.net/duqi_yc/article/details/9817243" target="_blank" rel="noopener">R字符串处理-grep/grepl/sub/gsub等等</a></li><li><a href="https://likan.info/cn/post/pattern-matching-and-replacement/" target="_blank" rel="noopener">R 中字符串的查找和替换</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中常用的snippets</title>
      <link href="/posts/21065.html"/>
      <url>/posts/21065.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录一下在Python中经常需要导入的一些module组，便于积累、查询和使用。</p></div><a id="more"></a><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> qgrid</span><br><span class="line"><span class="comment"># qgrid.show_grid(df, show_toolbar=True)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"><span class="comment"># ignore warning info</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># sns.set_style("white")</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.style.use('ggplot')</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># interactive visualization</span></span><br><span class="line"><span class="keyword">from</span> bokeh.palettes <span class="keyword">import</span> Spectral11</span><br><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_notebook, show</span><br><span class="line"><span class="keyword">from</span> bokeh.models <span class="keyword">import</span> LinearAxis, Range1d</span><br><span class="line">output_notebook()</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse, sys, os, errno</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,format=<span class="string">"%(levelname)s-%(filename)s:[%(lineno)d]-%(message)s"</span>)</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之正则表达式系统梳理</title>
      <link href="/posts/28940.html"/>
      <url>/posts/28940.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">正则表达式学习</a></li><li><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">正则表达式在线练习</a></li><li><a href="http://aandds.com/blog/lang-regex.html" target="_blank" rel="noopener">Regular Expressions</a></li><li><a href="https://juejin.im/post/5b4a9539f265da0f521de210" target="_blank" rel="noopener">正则中关于环视（lookaround）的小例子</a></li><li><a href="https://zhuanlan.zhihu.com/p/50789818" target="_blank" rel="noopener">正则表达式中 Lookaround</a></li><li><a href="http://www.ayqy.net/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">正则表达式学习笔记</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之grep进阶</title>
      <link href="/posts/5793.html"/>
      <url>/posts/5793.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对学习中经常遇到的几种情况：<strong>允许mismatch的grep</strong>、<strong>加速grep</strong>、<strong>管道grep高亮</strong>等问题，探索了一些解决方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>针对以下需求：</p><ul><li><code>grep</code>仅支持<strong>完全的匹配</strong>，如果想要进行<strong>支持mismatch的操作</strong>，该怎么办？</li><li>常规的<code>grep</code>在进行大文件的查找时很慢，如果<strong>加速这种查找</strong>？</li><li><code>grep</code>加入管道之后，查找出来的<strong>字符就不高亮</strong>了，如何解决？</li></ul><hr><h2 id="允许mismatch的grep"><a href="#允许mismatch的grep" class="headerlink" title="允许mismatch的grep"></a>允许mismatch的grep</h2><h3 id="agrep工具"><a href="#agrep工具" class="headerlink" title="agrep工具"></a>agrep工具</h3><p><code>agrep</code>命令简介：</p><blockquote><p>AGREP is a powerful tool for <strong>fast searching</strong> a file or many files for a <strong>string or regular expression</strong>, with <strong>approximate matching</strong> capabilities and <strong>user-definable records</strong>. AGREP is similar to egrep (or grep or fgrep), but it is <strong>much more general</strong> and usually <strong>faster</strong>. Approximate matching allows finding records that <strong>contain the pattern</strong> with several errors including <strong>substitutions</strong>, <strong>insertions</strong>, and <strong>deletions</strong>.</p></blockquote><h4 id="agrep安装"><a href="#agrep安装" class="headerlink" title="agrep安装"></a>agrep安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget ftp://ftp.cs.arizona.edu/agrep/agrep-2.04.tar</span><br><span class="line"><span class="comment"># 提取文件</span></span><br><span class="line">tar -xvf  agrep-2.04.tar</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 写入环境变量</span></span><br></pre></td></tr></table></figure><hr><h4 id="agrep命令格式及相关参数"><a href="#agrep命令格式及相关参数" class="headerlink" title="agrep命令格式及相关参数"></a>agrep命令格式及相关参数</h4><p>命令格式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agrep [ -<span class="comment">#cdehiklnpstvwxBDGIS ] pattern [ -f patternfile ] [ filename... ]</span></span><br></pre></td></tr></table></figure><p></p><p>相关参数：</p><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td>-#</td><td>find matches with at most # errors</td></tr><tr><td>-c</td><td>output the number of matched records</td></tr><tr><td>-d</td><td>define record delimiter</td></tr><tr><td>-h</td><td>do not output file names</td></tr><tr><td>-i</td><td>case-insensitive search, e.g., 'a' = 'A'</td></tr><tr><td>-l</td><td>output the names of files that contain a match</td></tr><tr><td>-n</td><td>output record prefixed by record number</td></tr><tr><td>-v</td><td>output those records containing no matches</td></tr><tr><td>-w</td><td>pattern has to match as a word, e.g., 'win' will not match 'wind'</td></tr><tr><td>-B</td><td>best match mode. find the closest matches to the pattern</td></tr><tr><td>-G</td><td>output the files that contain a match</td></tr><tr><td>-D<span style="font-style:italic">k</span></td><td>Set the cost of a deletion to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr><tr><td>-I<span style="font-style:italic">k</span></td><td>Set the cost of an insertion to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr><tr><td>-S<span style="font-style:italic">k</span></td><td>Set the cost of a substitution to k (k is a positive integer). This option does not currently work with regular expressions.</td></tr></table><hr><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><hr><h4 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h4><p>近似匹配直接使用<code>-num</code>开启，其中<code>num</code>表示<code>mismatch</code>的个数，最终输出的结果是<code>mismatch&lt;=num</code>的行。</p><p>允许<strong>一个</strong>mimatch：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'ABCDEFG'</span> test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>允许<strong>两个</strong>mimatch：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">agrep -2 <span class="string">'ABCDEFG'</span> test.txt </span><br><span class="line">  ABCDEFG</span><br><span class="line">  ABMDEFG</span><br><span class="line">  ABMNEFG</span><br><span class="line">  ABMNPFG ABCDEFG</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="设置罚分"><a href="#设置罚分" class="headerlink" title="设置罚分"></a>设置罚分</h4><p>测试文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p><strong>不设置</strong>罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>设置<strong>增加deletion</strong>的罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deletiond 的罚分增加到2</span></span><br><span class="line"><span class="comment"># 这样将会去除deletion的匹配</span></span><br><span class="line">agrep -1 -D2 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p>设置<strong>增加deletion、insertion</strong>的罚分：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deletiond、insertion的罚分增加到2</span></span><br><span class="line"><span class="comment"># 这样将会去除deletion、insertion的匹配</span></span><br><span class="line">agrep -1 -D2 -I2 <span class="string">'ABDEFG'</span> test2.txt </span><br><span class="line">  ABCEFG</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="结合正则表达式"><a href="#结合正则表达式" class="headerlink" title="结合正则表达式"></a>结合正则表达式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agrep -1 <span class="string">'abc[0-9](de|fg)*[x-z]'</span> foo</span><br></pre></td></tr></table></figure><p>Outputs the lines containing, <strong>within up to one error</strong>, the string that starts with “abc” followed by one digit, followed by zero or more repetitions of either “de” or “fg”, followed by either “x”, “y”, or “z”.</p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.biostars.org/p/4346/" target="_blank" rel="noopener">Question: Matching Strings With Mismatches</a></li><li><a href="https://github.com/Wikinaut/agrep" target="_blank" rel="noopener">github链接</a></li><li><a href="https://linux.die.net/man/1/agrep" target="_blank" rel="noopener">agrep(1) - Linux man page</a></li><li><a href="https://www.computerhope.com/unix/agrep.htm" target="_blank" rel="noopener">Linux agrep command-使用实例</a></li></ul><hr><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul><li><a href="https://github.com/laurikari/tre" target="_blank" rel="noopener">tre-The approximate regex matching library and agrep command line tool.</a></li><li><a href="https://metacpan.org/release/LIMAONE/Bio-Grep-v0.10.6" target="_blank" rel="noopener">Bio::Grep-perl module</a></li></ul><hr><p><br></p><h2 id="加速grep操作"><a href="#加速grep操作" class="headerlink" title="加速grep操作"></a>加速grep操作</h2><h3 id="parallel命令"><a href="#parallel命令" class="headerlink" title="parallel命令"></a>parallel命令</h3><p>结合之前学习了<a href="http://showteeth.tech/posts/25074.html">parallel命令</a>的<code>--pipe</code>模式对<code>grep</code>进行加速：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未进行优化的grep</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz | grep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line"></span><br><span class="line">  real    2m3.063s</span><br><span class="line">  user    2m14.375s</span><br><span class="line">  sys     0m10.078s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用parallel命令</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |parallel --pipe --block 1M --roundrobin --<span class="built_in">jobs</span> 10 grep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line">  real    2m53.983s</span><br><span class="line">  user    2m57.954s</span><br><span class="line">  sys     0m24.801s</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="优化grep"><a href="#优化grep" class="headerlink" title="优化grep"></a>优化grep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化后的grep</span></span><br><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz | LC_ALL=C fgrep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line"></span><br><span class="line">  real    2m12.462s</span><br><span class="line">  user    2m24.124s</span><br><span class="line">  sys     0m11.276s</span><br></pre></td></tr></table></figure><ul><li>Prefix your grep command with <code>LC_ALL=C</code> to use the <code>C locale</code> instead of <code>UTF-8</code>.</li><li>Use <code>fgrep</code> because you’re searching for a <code>fixed string</code>, not a regular expression.</li></ul><hr><h3 id="使用ripgrep"><a href="#使用ripgrep" class="headerlink" title="使用ripgrep"></a>使用ripgrep</h3><p>安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/BurntSushi/ripgrep/releases/download/11.0.2/ripgrep-11.0.2-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf  ripgrep-11.0.2-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ripgrep-11.0.2-x86_64-unknown-linux-musl</span><br><span class="line"></span><br><span class="line">./rg --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p></p><p>使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |/Share2/home/wangjb/songyabing/software/ripgrep-11.0.2-x86_64-unknown-linux-musl/rg <span class="string">"GTGAGATAGGAA"</span> dev/null</span><br><span class="line">  real    2m12.286s</span><br><span class="line">  user    2m26.400s</span><br><span class="line">  sys     0m12.404s</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用agrep"><a href="#使用agrep" class="headerlink" title="使用agrep"></a>使用agrep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time zcat Undetermined_sub_S0_L001_R2_001.fastq.gz |/Share2/home/wangjb/songyabing/software/agrep-2.04/agrep <span class="string">"GTGAGATAGGAA"</span> &gt;/dev/null</span><br><span class="line">  real    2m12.551s</span><br><span class="line">  user    2m26.266s</span><br><span class="line">  sys     0m10.803s</span><br></pre></td></tr></table></figure><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/9066609/fastest-possible-grep/9067042" target="_blank" rel="noopener">Fastest possible grep</a></li><li><a href="https://stackoverflow.com/questions/13913014/grepping-a-huge-file-80gb-any-way-to-speed-it-up" target="_blank" rel="noopener">Grepping a huge file (80GB) any way to speed it up?</a></li><li><a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">ripgrep recursively searches directories for a regex pattern</a></li><li><a href="https://github.com/chinanf-boy/ripgrep-zh#%E6%9B%B4%E6%96%B0-" target="_blank" rel="noopener">ripgrep 是一个面向行的搜索工具</a></li></ul><div class="note info"><p>虽然大部分的网站都给出了上述几种加速的方法，但是<strong>实际测试之后发现效果并不是很好</strong>，难道是不适用我这种情况？后续再看看吧。</p></div><hr><p><br></p><h2 id="管道grep高亮"><a href="#管道grep高亮" class="headerlink" title="管道grep高亮"></a>管道grep高亮</h2><p>使用<code>--color=always</code>参数可以使grep的结果<strong>一直保持高亮</strong>，不管处于管道的什么位置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat test2.txt|grep --color=always <span class="string">"ABCD"</span> |more </span><br><span class="line">  ABCDEFG</span><br></pre></td></tr></table></figure><p></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之parallel-并行化工具</title>
      <link href="/posts/25074.html"/>
      <url>/posts/25074.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中强大的并行工具<code>parallel</code>，其主要有<strong>两种工作模式</strong>：给<strong>命令传递参数</strong>以及<strong>管道模式(<code>--pipe</code>参数)</strong>，在实际使用中其主要作用在于<strong>改写for循环、减少重复性的操作</strong>。</p></div><a id="more"></a><h2 id="parallel介绍"><a href="#parallel介绍" class="headerlink" title="parallel介绍"></a>parallel介绍</h2><p><a href="https://www.gnu.org/software/parallel/" target="_blank" rel="noopener">官网介绍</a>：</p><blockquote><p>GNU parallel is a shell tool for <strong>executing jobs in parallel using one or more computers</strong>. A job can be a <strong>single command</strong> or <strong>a small script</strong> that has to be <strong>run for each of the lines in the input</strong>. The typical input is <strong>a list of files</strong>, <strong>a list of hosts</strong>, <strong>a list of users</strong>, <strong>a list of URLs</strong>, or <strong>a list of tables</strong>. A job can also be a command that <strong>reads from a pipe</strong>. GNU parallel can then <strong>split the input and pipe it into commands in parallel</strong>.</p><p>If you use <strong>xargs</strong> and tee today you will find GNU parallel very easy to use as GNU parallel is written to <strong>have the same options as xargs</strong>. If you write <strong>loops in shell</strong>, you will find GNU parallel may be able to <strong>replace most of the loops and make them run faster</strong> by running several jobs in parallel.</p><p>GNU parallel makes sure output from the commands is the same output as you would get had you run the commands sequentially. This makes it possible to use output from GNU parallel as input for other programs.</p><p>For each line of input GNU parallel will execute command with the line as arguments. If no command is given, the line of input is executed. Several lines will be run in parallel. <strong>GNU parallel can often be used as a substitute for xargs or cat | bash.</strong></p></blockquote><hr><p><br></p><h2 id="安装parallel"><a href="#安装parallel" class="headerlink" title="安装parallel"></a>安装parallel</h2><p>parallel并不是系统自带的命令，所以需要先下载安装才可以正常使用，这里是<strong>非root</strong>下的下载安装过程，root下要简单很多，具体的<a href="https://ftp.gnu.org/gnu/parallel/" target="_blank" rel="noopener">下载地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/parallel/parallel-20190722.tar.bz2</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -jxvf parallel-20190722.tar.bz2</span><br><span class="line"><span class="comment"># 为编译做准备</span></span><br><span class="line">./configure --prefix=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 测试安装是否成功</span></span><br><span class="line"><span class="built_in">cd</span> bin </span><br><span class="line">./parallel --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑环境变量</span></span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="parallel命令格式"><a href="#parallel命令格式" class="headerlink" title="parallel命令格式"></a>parallel命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"><span class="comment"># 模式一：传递参数给command</span></span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] &lt; list_of_arguments</span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] (::: arguments|:::: argfile(s))...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式二：pipe模式，给command传递stdin</span></span><br><span class="line">cat ... | parallel --pipe [options] [<span class="built_in">command</span> [arguments]]</span><br></pre></td></tr></table></figure><h2 id="parallel使用示例"><a href="#parallel使用示例" class="headerlink" title="parallel使用示例"></a>parallel使用示例</h2><h3 id="参数输入方式"><a href="#参数输入方式" class="headerlink" title="参数输入方式"></a>参数输入方式</h3><h4 id="命令行输入"><a href="#命令行输入" class="headerlink" title="命令行输入"></a>命令行输入</h4><p><code>tee命令</code>：<code>Linux tee</code>命令将<strong>数据重定向到文件</strong>，<strong>另一方面</strong>还可以提供一份重定向数据的副本<strong>作为后续命令的stdin</strong>。简单的说就是<strong>把数据重定向到给定文件和屏幕上。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个输入源</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: a b c d e |tee test.txt</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p>第一次使用还会输出引用的提示：</p><blockquote><p>Academic tradition requires you to cite works you base your article on.<br>If you use programs that use GNU Parallel to process data for an article in a<br>scientific publication, please cite:</p><p>O. Tange (2018): GNU Parallel 2018, Mar 2018, ISBN 9781387509881,<br>DOI <a href="https://doi.org/10.5281/zenodo.1146014" target="_blank" rel="noopener">https://doi.org/10.5281/zenodo.1146014</a></p><p>This helps funding further development; AND IT WON’T COST YOU A CENT.<br>If you pay 10000 EUR you should feel free to use GNU Parallel without citing.</p><p>More about funding GNU Parallel and the citation notice:<br><a href="https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice" target="_blank" rel="noopener">https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice</a></p><p>To silence this citation notice: run ‘parallel –citation’ once.</p></blockquote><hr><h4 id="管道输入"><a href="#管道输入" class="headerlink" title="管道输入"></a>管道输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt |parallel <span class="built_in">echo</span></span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><hr><h4 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用重定向符号进行文件输入</span></span><br><span class="line">parallel <span class="built_in">echo</span> &lt; test.txt </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::输入文件</span></span><br><span class="line">parallel <span class="built_in">echo</span> :::: test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="组合输入的信息"><a href="#组合输入的信息" class="headerlink" title="组合输入的信息"></a>组合输入的信息</h3><p>将输入的信息进行组合，需要指定<strong>多个输入源</strong>，指定多个输入源的方法主要包括：</p><ul><li><strong>多个命令行形式</strong>的输入源</li><li><strong>多个文件形式(-a参数或者::::)</strong>的输入源</li><li><strong>命令行、管道和文件形式的输入源组合</strong></li></ul><h4 id="命令行输入-1"><a href="#命令行输入-1" class="headerlink" title="命令行输入"></a>命令行输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parallel <span class="built_in">echo</span> ::: a b c ::: a b c</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  c a</span><br><span class="line">  c b</span><br><span class="line">  c c</span><br></pre></td></tr></table></figure><hr><h4 id="文件输入-1"><a href="#文件输入-1" class="headerlink" title="文件输入"></a>文件输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意下面两种方法的echo位置</span></span><br><span class="line">parallel -a test.txt -a test2.txt  <span class="built_in">echo</span></span><br><span class="line">parallel <span class="built_in">echo</span> :::: test.txt test2.txt</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  a d</span><br><span class="line">  a e</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><div class="note info"><p>当使用<code>-a</code>传递文件作为参数的时候，<code>-a</code>作为<code>parallel</code>的<strong>参数</strong>在<code>echo</code>命令<strong>前面</strong>；而直接使用<code>::::</code>传递文件作为输入的时候，文件作为<code>arguments</code>在<code>command</code>的<strong>后面</strong>。</p></div><hr><h4 id="混合输入"><a href="#混合输入" class="headerlink" title="混合输入"></a>混合输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a指定文件和管道的组合</span></span><br><span class="line">cat test.txt |parallel -a - -a test2.txt <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::指定文件和管道的组合</span></span><br><span class="line">cat test.txt |parallel <span class="built_in">echo</span> ::::  - test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ::::指定文件和:::指定命令行的组合</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: a b :::: test.txt</span><br><span class="line">  a a</span><br><span class="line">  a b</span><br><span class="line">  a c</span><br><span class="line">  a d</span><br><span class="line">  a e</span><br><span class="line">  b a</span><br><span class="line">  b b</span><br><span class="line">  b c</span><br><span class="line">  b d</span><br><span class="line">  b e</span><br></pre></td></tr></table></figure><hr><h3 id="取消输入的组合"><a href="#取消输入的组合" class="headerlink" title="取消输入的组合"></a>取消输入的组合</h3><p>如果<strong>不想在进行多个输入源的输入时出现的组合现象</strong>，可以使用<code>--xapply</code>指定从<strong>每个输入源中获取一个参数(或一行)</strong>，<strong>较短的输入源会进行重复直到较长的输入源全部输出</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个输入源长度相同</span></span><br><span class="line">parallel --xapply <span class="built_in">echo</span> ::: a b c ::: d e f </span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个输入源长度不同，较短的重复至较长的输出完</span></span><br><span class="line">parallel --xapply <span class="built_in">echo</span> ::: a b c ::: d e f g h</span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line">  a g</span><br><span class="line">  b h</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数分隔符"><a href="#指定参数分隔符" class="headerlink" title="指定参数分隔符"></a>指定参数分隔符</h3><p>在进行命令行参数输入时，如果遇到<code>:::</code>或<code>::::</code>被占用时，可以使用<code>--arg-sep</code>和<code>--arg-file-sep</code>分别指定命令行和文件的参数分隔符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定命令行的参数分隔符</span></span><br><span class="line">parallel --xapply --arg-sep ,,, <span class="built_in">echo</span> ,,, a b c ,,, d e f g h</span><br><span class="line">  a d</span><br><span class="line">  b e</span><br><span class="line">  c f</span><br><span class="line">  a g</span><br><span class="line">  b h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件的参数分隔符</span></span><br><span class="line">parallel --arg-file-sep ,,, <span class="built_in">echo</span> ,,, test.txt </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数定界符"><a href="#指定参数定界符" class="headerlink" title="指定参数定界符"></a>指定参数定界符</h3><p>默认的参数定界符为<code>\n</code>，也就是把<strong>每一行当做一个参数</strong>，可以通过参数<code>-d</code>来<strong>改变参数定界符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变参数定界符为\t</span></span><br><span class="line">paste test.txt  test2.txt |parallel -d <span class="string">"\t"</span> <span class="built_in">echo</span> :::: - </span><br><span class="line">  a</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数结束值"><a href="#指定参数结束值" class="headerlink" title="指定参数结束值"></a>指定参数结束值</h3><p><code>Parallel</code>支持通过<code>-E</code>参数<strong>指定一个值做为结束标志</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parallel -E stop <span class="built_in">echo</span> ::: A B stop C D</span><br><span class="line">  A</span><br><span class="line">  B</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="跳过空行"><a href="#跳过空行" class="headerlink" title="跳过空行"></a>跳过空行</h3><p><code>Parallel</code>使用 <code>--no-run-if-empty</code> 来跳过空行:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> 1; <span class="built_in">echo</span>; <span class="built_in">echo</span> 2) | parallel --no-run-if-empty <span class="built_in">echo</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对输入参数进行替换"><a href="#对输入参数进行替换" class="headerlink" title="对输入参数进行替换"></a>对输入参数进行替换</h3><p>Parallel支持多种方式来对输入的参数进行字符串替换，默认使用的是符号是 <code>{}</code>，也就是<strong>输出原始输入，没有任何替换(占位符)</strong>。其<strong>最常见的字符串替换</strong>如下：</p><ul><li><code>{.}</code>: 去掉<strong>扩展名</strong>；</li><li><code>{/}</code>: <strong>去掉路径</strong>，只<strong>保留文件名</strong>；</li><li><code>{//}</code>: 只<strong>保留路径</strong>；</li><li><code>{/.}</code>: <strong>同时去掉路径和扩展名</strong>；</li><li><code></code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入是A目录下存在B.C这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数-I来改变默认的占位符符号&#123;&#125;</span></span><br><span class="line">parallel <span class="built_in">echo</span> ::: A/B.C ; parallel <span class="built_in">echo</span> &#123;&#125; ::: A/B.C ; parallel -I ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line">  A/B.C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉输出参数中包括的拓展名信息</span></span><br><span class="line"><span class="comment"># 将默认的&#123;.&#125;替换为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;.&#125; ::: A/B.C ; parallel --extensionreplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  A/B</span><br><span class="line">  A/B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中包括的文件名信息，和basename命令作用相同</span></span><br><span class="line"><span class="comment"># 将默认的&#123;/&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;/&#125; ::: A/B.C ; parallel --basenamereplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  B.C</span><br><span class="line">  B.C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中包括的路径信息</span></span><br><span class="line"><span class="comment"># 将默认的&#123;//&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;//&#125; ::: A/B.C ; parallel --dirnamereplace ,, <span class="built_in">echo</span> ,, ::: A/B.C </span><br><span class="line">  A</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出输入参数中的文件名信息(不包括后缀)</span></span><br><span class="line"><span class="comment"># 将默认的&#123;/.&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;/.&#125; ::: A/B.C ; parallel --basenameextensionreplace ,, <span class="built_in">echo</span> ,, ::: A/B.C</span><br><span class="line">  B</span><br><span class="line">  B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入并行的任务编号</span></span><br><span class="line"><span class="comment"># 将默认的&#123;#&#125;修改为,,</span></span><br><span class="line">parallel <span class="built_in">echo</span> &#123;<span class="comment">#&#125; ::: A B C ; parallel --seqreplace ,, echo ,, ::: A B C</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><hr><h3 id="指定输入源输出顺序"><a href="#指定输入源输出顺序" class="headerlink" title="指定输入源输出顺序"></a>指定输入源输出顺序</h3><p>如果有多个输入源时，可以通过 <code>{编号}</code> <strong>代指某一个输入源的参数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;1&#125;表示输入源1中的内容，&#123;2&#125;表示输入源2中的内容</span></span><br><span class="line">parallel --xapply  <span class="built_in">echo</span> &#123;1&#125; and &#123;2&#125; ::: A B ::: C D;parallel --xapply  <span class="built_in">echo</span> &#123;2&#125; and &#123;1&#125; ::: A B ::: C D</span><br><span class="line">  A and C</span><br><span class="line">  B and D</span><br><span class="line">  C and A</span><br><span class="line">  D and B</span><br></pre></td></tr></table></figure><p></p><p>输入源也可以使用<strong>负数指定，表示倒着数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parallel <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; -1=&#123;-1&#125; -2=&#123;-2&#125; ::: A B ::: C D</span><br><span class="line">  1=A 2=C -1=C -2=A</span><br><span class="line">  1=A 2=D -1=D -2=A</span><br><span class="line">  1=B 2=C -1=C -2=B</span><br><span class="line">  1=B 2=D -1=D -2=B</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="指定参数名和参数"><a href="#指定参数名和参数" class="headerlink" title="指定参数名和参数"></a>指定参数名和参数</h3><p>使用 <code>--header</code>指定每一行输入中的第一个值做为参数名:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parallel --xapply --header : <span class="built_in">echo</span> f1=&#123;f1&#125; f2=&#123;f2&#125; ::: f1 A B ::: f2 C D | tee d.txt</span><br><span class="line">  f1=A f2=C</span><br><span class="line">  f1=B f2=D</span><br></pre></td></tr></table></figure><p></p><p>使用 <code>--colsep</code> 指定列分隔符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'printf "f1\tf2\nA\tB\nC\tD\n"'</span> &gt; tsv-file.tsv</span><br><span class="line">parallel --header : --colsep <span class="string">'\t'</span> <span class="built_in">echo</span> f1=&#123;f1&#125; f2=&#123;f2&#125; :::: tsv-file.tsv </span><br><span class="line">  f1=A f2=B</span><br><span class="line">  f1=C f2=D</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="背景文本"><a href="#背景文本" class="headerlink" title="背景文本"></a>背景文本</h3><p>占位符<code>{}</code>可以是<strong>输出字符的一部分</strong>，使用<code>-m</code>参数表示<strong>每个jobs不重复输出背景文本(除去替换字符串之外的字符内容)</strong>，而<code>-X</code>参数与<code>-m</code>参数<strong>功能相反</strong>，会在<strong>每个jobs中都输出背景文本</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下是会输出背景文本的</span></span><br><span class="line"><span class="comment"># 并且每个参数输出一行</span></span><br><span class="line">parallel  --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A-post</span><br><span class="line">  pre-B-post</span><br><span class="line">  pre-C-post</span><br><span class="line">  pre-D-post</span><br><span class="line">  pre-E-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-m参数取消在每个jobs中输出背景文本</span></span><br><span class="line"><span class="comment"># 并且同一个jobs中的参数在同一行输出</span></span><br><span class="line">parallel -m --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A B-post</span><br><span class="line">  pre-C D-post</span><br><span class="line">  pre-E-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-X参数指定在每个jobs中输出背景文本</span></span><br><span class="line"><span class="comment"># 并且同一个jobs中的参数在同一行输出</span></span><br><span class="line">parallel -X --<span class="built_in">jobs</span> 3 <span class="built_in">echo</span> pre-&#123;&#125;-post ::: A B C D E </span><br><span class="line">  pre-A-post pre-B-post</span><br><span class="line">  pre-C-post pre-D-post</span><br><span class="line">  pre-E-post</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="限制每次读取的参数个数"><a href="#限制每次读取的参数个数" class="headerlink" title="限制每次读取的参数个数"></a>限制每次读取的参数个数</h3><p><code>parallel</code>使用 <code>-N</code> 限制每次参数的个数，其中<code>-N0</code>表示一次<strong>只读取一个参数，且不输入这个参数（作为计数器来使用）</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次读取四个参数，并将所有读取的参数输出</span></span><br><span class="line"><span class="comment"># 相当于依次把数据分成了四个源，然后进行不带组合的输出</span></span><br><span class="line">parallel -N 4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125; 4=&#123;4&#125; ::: A B C D E F G H</span><br><span class="line">  1=A 2=B 3=C 4=D</span><br><span class="line">  1=E 2=F 3=G 4=H</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次读取四个参数，只输出其中的一部分参数</span></span><br><span class="line">parallel -N 4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125;  ::: A B C D E F G H</span><br><span class="line">  1=A 2=B 3=C</span><br><span class="line">  1=E 2=F 3=G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当做计数器使用，不会输出后续的参数</span></span><br><span class="line">parallel -N 0 <span class="built_in">echo</span> &#123;&#125;_foo ::: A B C</span><br><span class="line">  _foo</span><br><span class="line">  _foo</span><br><span class="line">  _foo</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="去除输入参数的空格"><a href="#去除输入参数的空格" class="headerlink" title="去除输入参数的空格"></a>去除输入参数的空格</h3><p><code>parallel</code>使用<code>--trim</code>去除参数两头的空格，其有三种模式，去除左边的空格(<code>--trim l</code>)、右边的空格(<code>--trim r</code>)、左右的空格(<code>--trim lr</code>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除右边的空格</span></span><br><span class="line">parallel --trim r <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre- A-post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除左边的空格</span></span><br><span class="line">parallel --trim l <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre-A -post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除左右两边的空格</span></span><br><span class="line">parallel --trim lr <span class="built_in">echo</span> pre-&#123;&#125;-post ::: <span class="string">' A '</span></span><br><span class="line">  pre-A-post</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="添加输出前缀"><a href="#添加输出前缀" class="headerlink" title="添加输出前缀"></a>添加输出前缀</h3><p><code>parallel</code>允许使用<code>--tag</code>参数来指定<strong>以参数作为输出字符的前缀</strong>，使用<code>--tagstring</code>来<strong>自定义输出前缀</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --tag：输入参数作为输出前缀</span></span><br><span class="line">parallel --tag <span class="built_in">echo</span> foo_&#123;&#125; ::: A B C</span><br><span class="line">  A       foo_A</span><br><span class="line">  B       foo_B</span><br><span class="line">  C       foo_C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改输出前缀</span></span><br><span class="line">parallel --tagstring &#123;&#125;_foo <span class="built_in">echo</span> foo_&#123;&#125; ::: A B C</span><br><span class="line">  A_foo   foo_A</span><br><span class="line">  B_foo   foo_B</span><br><span class="line">  C_foo   foo_C</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="运行之前打印命令"><a href="#运行之前打印命令" class="headerlink" title="运行之前打印命令"></a>运行之前打印命令</h3><p><code>parallel</code>使用<code>--verbose</code>参数来指定在运行命令之前先打印命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parallel --verbose <span class="built_in">echo</span> &#123;&#125; ::: A B C</span><br><span class="line">  <span class="built_in">echo</span> A</span><br><span class="line">  <span class="built_in">echo</span> B</span><br><span class="line">  <span class="built_in">echo</span> C</span><br><span class="line">  A</span><br><span class="line">  B</span><br><span class="line">  C</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="任务运行日志"><a href="#任务运行日志" class="headerlink" title="任务运行日志"></a>任务运行日志</h3><p>使用<code>--joblog</code>参数能够<strong>生成各个任务的日志文件</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parallel的运行日志为/tmp/log</span></span><br><span class="line">parallel --joblog /tmp/<span class="built_in">log</span> <span class="built_in">exit</span>  ::: 1 2 3 0</span><br><span class="line">cat /tmp/<span class="built_in">log</span> </span><br><span class="line">  Seq Host    Starttime   JobRuntime  Send    Receive Exitval Signal  Command</span><br><span class="line">  1   :   1523950890.344       0.018  0   0   1   0   <span class="built_in">exit</span> 1</span><br><span class="line">  2   :   1523950890.350       0.014  0   0   2   0   <span class="built_in">exit</span> 2</span><br><span class="line">  3   :   1523950890.357       0.006  0   0   3   0   <span class="built_in">exit</span> 3</span><br><span class="line">  4   :   1523950890.363       0.006  0   0   0   0   <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p><strong>运行失败任务</strong>处理：</p><ul><li>通过<code>--resume-failed</code>参数可以重新运行失败的任务;</li><li><code>--retry-failed</code>的作用与<code>--resume-failed</code>类似，只是<code>--resume-failed</code>从<strong>命令行</strong>读取失败任务，而<code>--retry-failed</code>则是从<strong>日志文件</strong>中读取失败任务：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从命令行读取失败任务</span></span><br><span class="line"><span class="comment"># 所以需要加载最开始的运行命令中</span></span><br><span class="line">parallel --resume-failed --joblog /tmp/<span class="built_in">log</span> <span class="built_in">exit</span>  ::: 1 2 3 0 0 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从日志文件读取失败任务</span></span><br><span class="line"><span class="comment"># 只用指定日志文件即可</span></span><br><span class="line">parallel --retry-failed --joblog /tmp/<span class="built_in">log</span></span><br></pre></td></tr></table></figure><hr><h3 id="终止任务"><a href="#终止任务" class="headerlink" title="终止任务"></a>终止任务</h3><p><code>parallel</code>支持<strong>在某一情况下</strong>（如第一个失败或成功时，或者20%任务失败时）终止任务，终止任务又有<strong>两种类型</strong>:</p><ul><li>其一为<strong>立即终止（通过<code>--halt now</code>指定）</strong>，<strong>杀死所有正在运行</strong>的任务并停止生成新的任务;</li><li>其二为<strong>稍后终止（通过<code>--halt soon</code>指定）</strong>，停止生成新任务并<strong>等待正在运行任务完成</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在遇到一个失败任务之后待正在运行的任务完成就终止</span></span><br><span class="line">parallel -j2 --halt soon,fail=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在遇到一个失败任务之后立即终止</span></span><br><span class="line">parallel -j2 --halt now,fail=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 0 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在失败任务数达到20%之后待正在运行的任务完成就终止</span></span><br><span class="line">parallel -j2 --halt soon,fail=20% <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 0 1 2 3 4 5 6 7 8 9  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在成功的任务数达到1之后立即终止</span></span><br><span class="line">parallel -j2 --halt now,success=1 <span class="built_in">echo</span> &#123;&#125;\; <span class="built_in">exit</span> &#123;&#125; ::: 1 2 3 0 4 5 6</span><br></pre></td></tr></table></figure><hr><h3 id="管道模式–pipe"><a href="#管道模式–pipe" class="headerlink" title="管道模式–pipe"></a>管道模式–pipe</h3><p>前面学习的所有内容基本都是<strong>传参数模式</strong>，也就是不管是从文件还是命令行获取输入，都会作为命令的参数；而使用<code>--pipe</code>模式之后则会将<strong>管道前面的内容作为标准输入传给后面的命令</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_large_log   |parallel --pipe grep pattern</span><br></pre></td></tr></table></figure><p></p><p>如果不加 <code>--pipe</code> ，相当于 <code>my_large_log</code>中的<strong>每一行</strong>都变成 <code>grep pattern line</code>的命令展开了；而加入了<code>--pipe</code>，则和 <code>cat my_large_log | grep pattern</code> 没有区别，只是分配到各个核上去执行了。</p><p>具体的，<code>--pipe</code>参数会<strong>将输入(stdin)分为多个block</strong>，然后<strong>分配给多个核运行</strong>，具体的过程：</p><blockquote><p>command_A | command_B. By default GNU parallel will start an instance of command_B, read a chunk of 1 MB, and pass that to the instance. Then start another instance, read another chunk, and pass that to the second instance.</p></blockquote><p>可以使用<code>--block</code>参数可以指定每块的大小，<strong>默认为1M(The size of the chunk is not exactly 1 MB because GNU parallel only passes full lines - never half a line, thus the blocksize is only 1 MB on average.)</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并行计算文件行数</span></span><br><span class="line">cat num30000 | parallel --pipe wc -l</span><br><span class="line">  30000 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置block大小为100k</span></span><br><span class="line">cat num30000 | parallel --block 100k  --pipe wc -l </span><br><span class="line">  18517</span><br><span class="line">  11483</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用原始方法计算</span></span><br><span class="line">wc -l num30000</span><br><span class="line">  30000 num30000</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>输出结果的顺序不重要</strong>，可以使用<code>--roundrobin</code>参数，并且结合<code>--jobs</code>参数指定任务，那么所有的block就会在指定的任务数中执行，某个提前运行完了就会接着运行下一个(或者一部分)，这样更加均衡；如果不加<code>--roundrobin</code>参数，每个block都会开启一个任务，不会管均衡不均衡。</p><hr><p><br></p><h2 id="parallel相关实战"><a href="#parallel相关实战" class="headerlink" title="parallel相关实战"></a>parallel相关实战</h2><h3 id="改写for循环"><a href="#改写for循环" class="headerlink" title="改写for循环"></a>改写for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始的for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *jpeg</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  convert <span class="variable">$i</span> <span class="variable">$i</span>.png </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改写后的命令行</span></span><br><span class="line"><span class="comment"># --max-args表示每次读取的参数个数，使用-N2也是一样的效果</span></span><br><span class="line"><span class="comment"># -I修改了占位符</span></span><br><span class="line">find . -name <span class="string">"*jpeg"</span> | parallel -I % --max-args 1 convert % %.png</span><br></pre></td></tr></table></figure><h3 id="一次传入多个参数"><a href="#一次传入多个参数" class="headerlink" title="一次传入多个参数"></a>一次传入多个参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意需要将&gt;使用引号括起来，不然得到的结果是所有的文件保存到了&#123;1&#125;_&#123;2&#125;.person中</span></span><br><span class="line">ls -1 | parallel --max-args=2 cat &#123;1&#125; &#123;2&#125; <span class="string">"&gt;"</span> &#123;1&#125;_&#123;2&#125;.person</span><br><span class="line"><span class="comment"># 使用-N2也是一样的效果</span></span><br><span class="line">ls -1 | parallel -N2 cat &#123;1&#125; &#123;2&#125; <span class="string">"&gt;"</span> &#123;1&#125;_&#123;2&#125;.png</span><br></pre></td></tr></table></figure><hr><h3 id="负载管理"><a href="#负载管理" class="headerlink" title="负载管理"></a>负载管理</h3><p>关于<a href="https://www.cnblogs.com/muahao/p/6492665.html" target="_blank" rel="noopener">cpu负载</a>：</p><blockquote><p>单核单CPU：如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。<br>单核多CPU：2个CPU，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍；所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。<br>多CPU多核：在系统负荷方面，多核CPU与多CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过1.0，就表明电脑正常运行。</p></blockquote><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parallel --eta -j 2 --load 80% --noswap \</span><br><span class="line">  <span class="string">'blastp -db pdb_blast_db_example/pdb_seqres.txt -query &#123;&#125; \</span></span><br><span class="line"><span class="string">  -out blastp_outfiles/&#123;.&#125;.out -evalue 0.0001 -word_size 7 -outfmt "6 std stitle staxids sscinames" \</span></span><br><span class="line"><span class="string">  -max_target_seqs 10 -num_threads 1'</span> \</span><br><span class="line">  ::: test_seq*.fas</span><br></pre></td></tr></table></figure><p></p><p>其中：</p><ul><li><code>--eta</code>：显示任务完成的预计剩余时间；</li><li><code>-j 2</code>或<code>-jobs 2</code>：同时运行的命令数，在本例中设置为2；</li><li><code>--load 80%</code>：<strong>最大cpu负载</strong>；在上面的命令中，我们指定最多可以运行80％的CPU</li><li><code>--noswap</code>：如果服务器处于大量<strong>内存负载</strong>下，则<strong>不会启动新作业</strong>，以便在存储新信息之前从内存中删除信息。</li></ul><p>其他：</p><ul><li><code>--memfree 1G</code>：内存只有内存满足时才启动任务，Additionally, GNU parallel will kill off the <strong>youngest job if the memory free falls below 50% of the size</strong>. The killed job will put back on the queue and retried later.</li></ul><hr><h3 id="对脚本进行parallel"><a href="#对脚本进行parallel" class="headerlink" title="对脚本进行parallel"></a>对脚本进行parallel</h3><p>创建<code>python</code>脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"the input num of arguments is \t:%s"</span> %str(len(sys.argv)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br></pre></td></tr></table></figure><p></p><p>运行<code>parallel</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">parallel python parallel.py ::: a b c d e</span><br><span class="line">  <span class="comment"># 发现每次输出的参数格式都是2，说明是并行运行的，不是串行的</span></span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  d</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  a</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  b</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  c</span><br><span class="line">  the input num of arguments is   :2</span><br><span class="line">  parallel.py</span><br><span class="line">  e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接运行python</span></span><br><span class="line">python parallel.py a b c d e</span><br><span class="line">  the input num of arguments is   :6</span><br><span class="line">  parallel.py</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.gnu.org/software/parallel/parallel_tutorial.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.youtube.com/watch?v=OpaiGYxkSuQ&amp;list=PL284C9FF2488BC6D1" target="_blank" rel="noopener">官方操作视频</a></li><li><a href="https://linux.cn/article-9718-1.html" target="_blank" rel="noopener">使用 GNU Parallel 提高 Linux 命令行执行效率</a></li><li><a href="http://blog.sciencenet.cn/blog-3353749-1130387.html" target="_blank" rel="noopener">强大的并行工具 GNU Parallel</a></li><li><a href="https://www.jianshu.com/p/cc54a72616a1" target="_blank" rel="noopener">Linux下的并行神器——parallel</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac远程连接Windows</title>
      <link href="/posts/11103.html"/>
      <url>/posts/11103.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了<strong>在mac上远程连接windows</strong>进行的设置。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近新购置了一台mac笔记本，但是因为之前使用的windows，并且很多资料都在windows上，所以迁移可能会花一点时间，所以就想先用mac，在遇到资料的时候直接远程windows获取资料即可。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里使用的工具是<code>Windows</code>官方为<code>Mac OS X</code>系统打造的远程连接<code>Windows</code>的软件，名字叫做<code>Microsoft Remote Desktop</code>，<a href="https://rink.hockeyapp.net/apps/5e0c144289a51fca2d3bfa39ce7f2b06/" target="_blank" rel="noopener">下载地址</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先是安装软件，这一步没啥问题直接跳过。</p><hr><h3 id="设置windows"><a href="#设置windows" class="headerlink" title="设置windows"></a>设置windows</h3><p>此电脑—&gt;属性—&gt;远程设置—&gt;远程—&gt;允许远程连接到此计算机。</p><hr><h3 id="添加windows"><a href="#添加windows" class="headerlink" title="添加windows"></a>添加windows</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_1.png" alt="Remote_Desktop_1.png"></p><p>其中的<code>PC name</code>是<strong>远程windows的IP地址</strong>，具体可以通过如下方式查看：</p><ul><li>打开<code>cmd</code></li><li>输入<code>ipconfig</code></li><li><code>IPv4 地址</code>即为这里需要填写的<code>PC name</code>信息</li></ul><p>其中的<code>friendly name</code>就是<code>Microsoft Remote Desktop</code>显示的远程桌面名称。</p><hr><h3 id="连接远程windows"><a href="#连接远程windows" class="headerlink" title="连接远程windows"></a>连接远程windows</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_2.png" alt="Remote_Desktop_2.png"></p><p>正确输入windows的用户名和密码之后就可以完成连接；<strong>第一次连接会有点慢和卡顿</strong>，这是正常的，后续连接几次就正常了。</p><p>需要注意的是：<strong>一旦mac远程连接了windows，那么windows就会回到锁屏界面，如果在windows上打开锁屏界面，回到桌面，那么mac就会出现如下报错</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_3.png" alt="Remote_Desktop_3.png"></p><hr><h2 id="使用中的问题"><a href="#使用中的问题" class="headerlink" title="使用中的问题"></a>使用中的问题</h2><h3 id="mac和windows连接不同的网络报错"><a href="#mac和windows连接不同的网络报错" class="headerlink" title="mac和windows连接不同的网络报错"></a>mac和windows连接不同的网络报错</h3><p>在上述操作完成之后，如果windows和mac在同一网络下是可以正常使用的，但一旦两者连接的网络不同，就会报错：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_4.png" alt="Remote_Desktop_4.png"></p><p>上述的<a href="#%e8%ae%be%e7%bd%aewindows">设置windows</a>步骤中只是打开了服务</p><p>解决方法：<br>看着好像都需要购买域名。。。。弃！</p><hr><h3 id="添加共享目录"><a href="#添加共享目录" class="headerlink" title="添加共享目录"></a>添加共享目录</h3><p>进行如下设置：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_5.png" alt="Remote_Desktop_5.png"></p><p>得到的效果：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Remote_Desktop_6.png" alt="Remote_Desktop_6.png"></p><p>上述操作完成后就可以在mac和windows之间共享文件了，只要放在这个目录下即可。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.hudongdong.com/skill/259.html" target="_blank" rel="noopener">mac远程控制windows</a></li><li><a href="https://www.jianshu.com/p/be9d825fc4a3" target="_blank" rel="noopener">Mac如何远程控制Windows</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之添加动态链接库地址</title>
      <link href="/posts/10801.html"/>
      <url>/posts/10801.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章针对<strong>安装Python包没有出错但是在调用的时候却出错</strong>而发现的<strong>动态链接库地址不完整</strong>的问题，通过<strong>在环境变量(<code>~/.bashrc</code>)</strong>中添加<code>LD_LIBRARY_PATH</code>地址来解决；同时也学习了使用<code>locate</code>命令来直接查找文件。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在<strong>安装Python包的时候一直很顺利</strong>，并没有出现任何错误，但是在<strong>导入包的时候却报错</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libhdf5.so<span class="number">.101</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p></p><p>错误提示是找不到动态链接库<code>libhdf5.so.101</code>，但使用<code>find ~ -name &quot;libhdf5.so.101&quot;</code>是可以找到的。。。</p><h2 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h2><p>之前一直使用的是<code>find ~ -name &quot;libhdf5.so.101&quot;</code>来查找文件，虽说已经可以满足需求，但是毕竟需要输入这么长的命令，感觉有些麻烦，刚好发现了<code>locate</code>命令可以<strong>直接搜索文件名</strong>，所以这里就使用这个进行查找文件。</p><h3 id="安装locate"><a href="#安装locate" class="headerlink" title="安装locate"></a>安装locate</h3><p>使用<code>locate</code>的时候发现集群没有安装这个命令，所以需要先安装才能使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用yum查找一下</span></span><br><span class="line">yum search locate</span><br><span class="line">  mlocate.x86_64 : An utility <span class="keyword">for</span> finding files by name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装mlocate</span></span><br><span class="line">yum  install mlocate</span><br></pre></td></tr></table></figure><p></p><p>安装<code>mlocate</code>之后，使用<code>locate</code>命令的时候提示：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate: can not <span class="built_in">stat</span> () `/var/lib/mlocate/mlocate.db<span class="string">': No such file or directory</span></span><br></pre></td></tr></table></figure><p></p><p>解决方法是使用<code>updatedb</code>命令：</p><blockquote><p>This manual page documents the GNU version of updatedb, which <strong>updates</strong><br><strong>file name databases used by GNU locate</strong>. The file name databases<br>contain lists of files that were in particular directory trees when<br>the databases <strong>were last updated</strong>. The file name of the default<br>database is determined when locate and updatedb are configured and<br>installed. <strong>The frequency with which the databases are updated and</strong><br><strong>the directories for which they contain entries depend on how often</strong><br><strong>updatedb is run, and with which arguments.</strong></p></blockquote><p>因为是第一次运行<code>updatedb</code>，所以运行的时间很长，虽然后续运行也会很久。。。</p><h3 id="使用locate命令"><a href="#使用locate命令" class="headerlink" title="使用locate命令"></a>使用locate命令</h3><p><code>updatedb</code>命令运行完成之后就可以顺利使用<code>locate</code>命令了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">locate libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hba1933b_1/lib/libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hba1933b_1/lib/libhdf5.so.101.1.0</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hc401514_3/lib/libhdf5.so.101</span><br><span class="line">  /home/softwares/anaconda3/pkgs/hdf5-1.10.2-hc401514_3/lib/libhdf5.so.101.1.0</span><br></pre></td></tr></table></figure><p></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>回到最开始的找不到动态链接库<code>libhdf5.so.101</code>上，首先剖析出现这个问题的过程：</p><ul><li>安装的时候没有报错，说明编译是没有问题的，可以找到动态链接库<code>libhdf5.so.101</code></li><li>调用的时候报错了，说明是在程序加载过程中没有找到动态链接库<code>libhdf5.so.101</code></li></ul><p>既然是调用过程中没有找到，那么可能就是安装包的过程中没有将这个动态链接库放在<code>LD_LIBRARY_PATH</code>中(<code>LD_LIBRARY_PATH</code>环境变量用于在<strong>程序加载运行期间</strong>查找动态链接库时指定的除了系统默认路径之外的其他路径).</p><p>接下来就是查看<code>LD_LIBRARY_PATH</code>以及确认<code>libhdf5.so.101</code>不在这个路径中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span> </span><br><span class="line">  /usr/<span class="built_in">local</span>/lib:</span><br><span class="line"></span><br><span class="line">ls /usr/<span class="built_in">local</span>/lib</span><br><span class="line">  <span class="comment"># 没有出现libhdf5.so.101</span></span><br></pre></td></tr></table></figure><p></p><p>上述结果表明<code>LD_LIBRARY_PATH</code>确实是没有动态链接库<code>libhdf5.so.101</code>，那么最直接的方法就是将<code>libhdf5.so.101</code>放在<code>/usr/local/lib</code>中，但是显然不是没有人都有权限修改这个文件夹的内容的，那么就只能修改<code>LD_LIBRARY_PATH</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一劳永逸的方法是修改环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/your/custom/path/</span><br><span class="line"><span class="comment"># 使修改生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p></p><p>经过以上过程之后再次导入包发现解决了问题。</p><div class="note info"><p><a href="https://www.cnblogs.com/panfeng412/archive/2011/10/20/library_path-and-ld_library_path.html" target="_blank" rel="noopener">补充说明</a>：</p><ul><li><code>LIBRARY_PATH</code>环境变量用于在程序<strong>编译期间</strong>查找动态链接库时指定查找共享库的路径，例如，指定<code>gcc</code>编译需要用到的动态链接库的目录</li><li>如果想要<strong>覆盖集群上的某些动态链接库</strong>也可以修改<code>LD_LIBRARY_PATH</code>，不过这个时候需要注意将<code>/your/custom/path/</code>放在<code>$LD_LIBRARY_PATH</code>前面，也就是<code>export LD_LIBRARY_PATH=/your/custom/path/:$LD_LIBRARY_PATH</code>。</li></ul></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/11581898/hdf5-h5py-importerror-libhdf5-so-7" target="_blank" rel="noopener">hdf5 / h5py ImportError: libhdf5.so.7</a></li><li><a href="https://stackoverflow.com/questions/13428910/how-to-set-the-environmental-variable-ld-library-path-in-linux" target="_blank" rel="noopener">How to set the environmental variable LD_LIBRARY_PATH in linux</a></li><li><a href="https://my.oschina.net/shootercn/blog/94498" target="_blank" rel="noopener">设置 Linux 的 LD_LIBRARY_PATH 变量</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R系列之查看package源代码</title>
      <link href="/posts/33992.html"/>
      <url>/posts/33992.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了查看R语言中源代码的方法：首先直接<strong>输出函数名</strong>或者使用<code>page</code>函数、<code>edit</code>函数查看，一般的函数可以直接显示源代码；如果出现<code>UseMethod(&quot;mean&quot;)</code>表明是使用S3对象进行面向对象封装，此时结合<code>methods</code>函数以及<code>getAnywhere()</code>、<code>package:::function</code>查看源代码；如果出现<code>standardGeneric(&quot;chol2inv&quot;)</code>就是表明使用的<strong>S4对象进行面向对象封装</strong>，此时结合<code>showMethods</code>函数以及<code>getMethod</code>查看源代码。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做项目过程中需要使用到R(虽然之前学过R，但是很久没用，所以已经有些生疏了)，想要看某个package中函数的源代码。</p><hr><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>直接输入函数名就可以得到相应的源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lm</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="page函数"><a href="#page函数" class="headerlink" title="page函数"></a>page函数</h3><p><code>page</code>函数会<strong>打开新窗口</strong>显示源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page(lm)</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><p>edit函数会<strong>弹出新窗口</strong>显示源代码，<strong>修改完成之后可以直接保存修改</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page(lm)</span><br><span class="line">  <span class="keyword">function</span> (formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, </span><br><span class="line">      model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, </span><br><span class="line">      contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      ret.x &lt;- x</span><br><span class="line">      ret.y &lt;- y</span><br><span class="line">      cl &lt;- match.call()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对于S3对象系统"><a href="#对于S3对象系统" class="headerlink" title="对于S3对象系统"></a>对于S3对象系统</h3><p>在<a href="http://blog.fens.me/r-class-s3/" target="_blank" rel="noopener">R的面向对象编程</a>中，有<strong>3种底层对象类型</strong>，一种是<code>S3类型</code>，一种是<code>S4类型</code>，还有一种是<code>RC类型</code>:</p><ul><li><code>S3对象</code>简单、具有动态性、结构化特征不明显；</li><li><code>S4对象</code>结构化、功能强大；</li><li><code>RC对象</code>是2.12版本后使用的新类型，用于解决S3,S4很难实现的对象。</li></ul><h4 id="S3对象特征"><a href="#S3对象特征" class="headerlink" title="S3对象特征"></a>S3对象特征</h4><p><code>S3对象</code>的特征：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mean</span><br><span class="line">  standardGeneric <span class="keyword">for</span> <span class="string">"mean"</span> defined from package <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  standardGeneric(<span class="string">"mean"</span>)</span><br><span class="line">  &lt;environment: <span class="number">0x92ef470</span>&gt;</span><br><span class="line">  Methods may be defined <span class="keyword">for</span> arguments: x</span><br><span class="line">  Use  showMethods(<span class="string">"mean"</span>)  <span class="keyword">for</span> currently available ones.</span><br></pre></td></tr></table></figure><p></p><p>出现<code>UseMethod(&quot;mean&quot;)</code>的情况就是表明使用的<strong>S3对象进行面向对象封装</strong>。</p><hr><h4 id="查看内部行为函数-methods"><a href="#查看内部行为函数-methods" class="headerlink" title="查看内部行为函数-methods"></a>查看内部行为函数-methods</h4><p>对于S3对象进行面向对象封装的函数可以使用<code>methods</code>函数<strong>查看S3对象中的定义的内部行为函数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods(mean)</span><br><span class="line">  [<span class="number">1</span>] mean,ANY-method          mean,Matrix-method       mean,sparseMatrix-method mean,sparseVector-method</span><br><span class="line">  [<span class="number">5</span>] mean.Date                mean.default             mean.difftime            mean.IDate*</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是<strong>带星号的表示the function is not exported from its package’s namespace.</strong></p><p>这里列出来的<strong>不同的mean</strong>可能是<strong>针对不同的数据类型进行不同的计算方式</strong>，比如求一个向量的平均值和求一个数据框的平均值就有所差异，就要<strong>编写多个mean函数，然后“封”起来，以一个统一的mean出现，方便使用</strong>。</p><hr><h4 id="查看源代码-getAnywhere"><a href="#查看源代码-getAnywhere" class="headerlink" title="查看源代码-getAnywhere()"></a>查看源代码-getAnywhere()</h4><p>使用<code>getAnywhere()</code> 查看源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getAnywhere(mean.default)</span><br><span class="line">  A single object matching ‘mean.default’ was found</span><br><span class="line">  It was found <span class="keyword">in</span> the following places</span><br><span class="line">    package:base</span><br><span class="line">    registered S3 method <span class="keyword">for</span> mean from namespace base</span><br><span class="line">    namespace:base</span><br><span class="line">  with value</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, trim = <span class="number">0</span>, na.rm = <span class="literal">FALSE</span>, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) &#123;</span><br><span class="line">          <span class="keyword">warning</span>(<span class="string">"argument is not numeric or logical: returning NA"</span>)</span><br><span class="line">          <span class="keyword">return</span>(<span class="literal">NA_real_</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>使用<code>getAnywhere()</code>不仅能查看<strong>不带星号的函数的源代码</strong>，还能查看<strong>带星号的函数的源代码</strong></li><li>同时使用<code>getAnywhere()</code>查看函数的源代码可以<strong>不用指定函数的来源</strong>，这个后面的使用<code>package:::function</code>查看方式不同</li></ul></div><hr><h4 id="查看源代码-package-function"><a href="#查看源代码-package-function" class="headerlink" title="查看源代码-package:::function"></a>查看源代码-package:::function</h4><p>也可以使用<code>package:::function</code>查看：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base::mean.default</span><br><span class="line">  <span class="keyword">function</span> (x, trim = <span class="number">0</span>, na.rm = <span class="literal">FALSE</span>, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) &#123;</span><br><span class="line">          <span class="keyword">warning</span>(<span class="string">"argument is not numeric or logical: returning NA"</span>)</span><br><span class="line">          <span class="keyword">return</span>(<span class="literal">NA_real_</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p></p><p>但使用<code>package:::function</code><strong>不能查看带星号的函数的源代码</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base::mean.IDate</span><br><span class="line">  Error <span class="keyword">in</span> get(name, envir = ns, inherits = <span class="literal">FALSE</span>) : </span><br><span class="line">    object <span class="string">'mean.IDate'</span> not found</span><br><span class="line"></span><br><span class="line">stats::predict.ar</span><br><span class="line">  Error: <span class="string">'predict.ar'</span> is not an exported object from <span class="string">'namespace:stats'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="对于S4对象系统"><a href="#对于S4对象系统" class="headerlink" title="对于S4对象系统"></a>对于S4对象系统</h3><h4 id="S4对象特征"><a href="#S4对象特征" class="headerlink" title="S4对象特征"></a>S4对象特征</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chol2inv</span><br><span class="line">  standardGeneric <span class="keyword">for</span> <span class="string">"chol2inv"</span> defined from package <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  standardGeneric(<span class="string">"chol2inv"</span>)</span><br><span class="line">  &lt;bytecode: <span class="number">0x7907390</span>&gt;</span><br><span class="line">  &lt;environment: <span class="number">0x78fbfc0</span>&gt;</span><br><span class="line">  Methods may be defined <span class="keyword">for</span> arguments: x</span><br><span class="line">  Use  showMethods(<span class="string">"chol2inv"</span>)  <span class="keyword">for</span> currently available ones.</span><br></pre></td></tr></table></figure><p>出现<code>standardGeneric(&quot;chol2inv&quot;)</code>就是表明使用的<strong>S4对象进行面向对象封装</strong>.</p><hr><h4 id="查看内部行为函数-showMethods"><a href="#查看内部行为函数-showMethods" class="headerlink" title="查看内部行为函数-showMethods"></a>查看内部行为函数-showMethods</h4><p>对于S4对象进行面向对象封装的函数可以使用<code>showMethods</code>函数<strong>查看S4对象中的定义的内部行为函数</strong>：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showMethods(chol2inv)</span><br><span class="line">  Function: chol2inv (package base)</span><br><span class="line">  x=<span class="string">"ANY"</span></span><br><span class="line">  x=<span class="string">"CHMfactor"</span></span><br><span class="line">  x=<span class="string">"denseMatrix"</span></span><br><span class="line">  x=<span class="string">"diagonalMatrix"</span></span><br><span class="line">  x=<span class="string">"dtrMatrix"</span></span><br><span class="line">  x=<span class="string">"sparseMatrix"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看源代码-getMethod"><a href="#查看源代码-getMethod" class="headerlink" title="查看源代码-getMethod"></a>查看源代码-getMethod</h4><p>使用<code>getMethod</code>查看源代码：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getMethod (<span class="string">"chol2inv"</span>, <span class="string">"diagonalMatrix"</span>)</span><br><span class="line">  Method Definition:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> (x, <span class="keyword">...</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      chk.s(<span class="keyword">...</span>, which.call = -<span class="number">2</span>)</span><br><span class="line">      tcrossprod(solve(x))</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;bytecode: <span class="number">0x50dac48</span>&gt;</span><br><span class="line">  &lt;environment: namespace:Matrix&gt;</span><br><span class="line"></span><br><span class="line">  Signatures:</span><br><span class="line">          x               </span><br><span class="line">  target  <span class="string">"diagonalMatrix"</span></span><br><span class="line">  defined <span class="string">"diagonalMatrix"</span></span><br></pre></td></tr></table></figure><p></p><p></p><hr><br><br><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://rfaqs.com/source-code-of-r-method" target="_blank" rel="noopener">How to View Source Code of R Method/ Function?</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之集群之间不输入密码传输数据</title>
      <link href="/posts/17109.html"/>
      <url>/posts/17109.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在多个集群之间设置免密传输数据的过程。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做项目的过程中经常会遇到将<strong>数据在多个集群中移动</strong>的步骤，但是<strong>每个集群的密码都不一样</strong>，记住密码比较麻烦，同时<strong>需要输入密码的行为也不适合写成脚本</strong>来运行，所以这里就想对各个集群进行设置，使其可以免密传输。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>之前学习过<a href="http://showteeth.tech/posts/51573.html">使用ssh key来将本地项目免密传输到远程的github以及coding pages</a>，这里也是使用ssh key来进行类似的设置。</p><h3 id="server1配置"><a href="#server1配置" class="headerlink" title="server1配置"></a>server1配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">  <span class="comment"># 输出如下内容，期间内容之间按enter即可</span></span><br><span class="line">  ssh-keygen -t rsa</span><br><span class="line">  Generating public/private rsa key pair.</span><br><span class="line">  Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Share2/home/wangjb//.ssh/id_rsa): </span><br><span class="line">  Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">  Enter same passphrase again: </span><br><span class="line">  Your identification has been saved <span class="keyword">in</span> /Share2/home/wangjb//.ssh/id_rsa.</span><br><span class="line">  Your public key has been saved <span class="keyword">in</span> /Share2/home/wangjb//.ssh/id_rsa.pub.</span><br><span class="line">  The key fingerprint is:</span><br><span class="line">  11:65:05:8c:ac:93:6b:40:4d:9d:91:c4:65:6c:68:fb wangjb@loginview02</span><br><span class="line">  The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">  +--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">  |     o.=+@*o.    |</span></span><br><span class="line"><span class="string">  |    . . X++      |</span></span><br><span class="line"><span class="string">  |   .   +.o       |</span></span><br><span class="line"><span class="string">  |    . + ..       |</span></span><br><span class="line"><span class="string">  |     . oS.       |</span></span><br><span class="line"><span class="string">  |      o   E      |</span></span><br><span class="line"><span class="string">  |     .           |</span></span><br><span class="line"><span class="string">  |                 |</span></span><br><span class="line"><span class="string">  |                 |</span></span><br><span class="line"><span class="string">  +-----------------+</span></span><br></pre></td></tr></table></figure><p>上述步骤会在<code>~/.ssh</code>生成<code>id_rsa</code>、<code>id_rsa.pub</code>，其中的<code>id_rsa</code>是私钥，<strong>不能泄露出去</strong>，<code>id_rsa.pub</code>是公钥，可以用于与其他远程平台的交互。</p><h3 id="server2配置"><a href="#server2配置" class="headerlink" title="server2配置"></a>server2配置</h3><p>将上述得到的公钥(以<code>pub</code>结尾的文件)内容复制到<code>server2</code>的<code>~/.ssh</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;authorized_keys</span><br></pre></td></tr></table></figure><p></p><p>执行上述步骤之后进行scp测试，发现<strong>还是不能免密传输</strong>，这时需要修改<code>server2</code>的<code>authorized_keys</code>权限为<code>600</code>，同时设置<code>~/.ssh</code>文件夹权限为<code>700</code>，<strong>保证同组或其他用户不能对这个进行修改</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p></p><p>完成权限设置之后就可以在<strong>从server1到server2进行免密传输了</strong>，但是<strong>server2到server1之间还是不能进行免密传输</strong>，如果想要在server2到server1上进行免密传输还需要反过来设置一次。</p><h3 id="多个authorized-keys"><a href="#多个authorized-keys" class="headerlink" title="多个authorized_keys"></a>多个authorized_keys</h3><p>如果存在<code>3个以上</code>的集群之间免密，就需要在每个集群上的<code>authorized_keys</code>中加入多个集群的<code>id_rsa.pub</code>内容，添加的方式是<strong>直接追加<code>&gt;&gt;</code>即可</strong>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/182483/scp-without-password-prompt-using-different-username" target="_blank" rel="noopener">SCP without password prompt using different username</a></li><li><a href="https://blogs.oracle.com/jkini/how-to-scp,-ssh-and-rsync-without-prompting-for-password" target="_blank" rel="noopener">How To scp, ssh and rsync without prompting for password</a></li><li><a href="https://stackoverflow.com/questions/1462284/how-to-respond-to-password-prompt-when-using-scp-in-a-shell-script" target="_blank" rel="noopener">How to respond to password prompt when using SCP in a shell script?</a></li><li><a href="https://stackoverflow.com/questions/6377009/adding-public-key-to-ssh-authorized-keys-does-not-log-me-in-automatically" target="_blank" rel="noopener">Adding public key to ~/.ssh/authorized_keys does not log me in automatically</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之导入python文件</title>
      <link href="/posts/14806.html"/>
      <url>/posts/14806.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了将不同目录下的文件导入到另一个文件的方法，主要有两种：将<strong>文件路径加到package的搜索路径</strong>以及<strong>在需要导入的文件目录中加入<code>__init__.py</code>文件使其变成一个可以直接导入的包</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在画韦恩图的时候遇到一个<a href="https://github.com/tctianchi/pyvenn" target="_blank" rel="noopener">画图的脚本</a>不错，但是这个没有形成一个package，想要使用的话只能直接导入python文件，从而使用其中的绘图函数。</p><h2 id="导入python文件"><a href="#导入python文件" class="headerlink" title="导入python文件"></a>导入python文件</h2><p>这里有两种方法可以导入python文件从而使用其中的函数：</p><ul><li>将文件夹添加到<strong>系统路径(python package的安装和搜索路径)</strong></li><li>在需要导入的文件夹中添加<code>__init__.py</code>文件</li></ul><h3 id="添加到搜索路径"><a href="#添加到搜索路径" class="headerlink" title="添加到搜索路径"></a>添加到搜索路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_file.py</span></span><br><span class="line">import sys</span><br><span class="line"><span class="comment"># insert at 1, 0 is the script path (or '' in REPL)</span></span><br><span class="line">sys.path.insert(1, <span class="string">'/path/to/application/app/folder'</span>)</span><br><span class="line"></span><br><span class="line">import file</span><br></pre></td></tr></table></figure><hr><h3 id="添加init-py文件"><a href="#添加init-py文件" class="headerlink" title="添加init.py文件"></a>添加<strong>init</strong>.py文件</h3><p><code>__init__.py</code>文件的作用：<strong>It can be an empty file. Its very existence tells Python to treat the directory as a package.</strong></p><p>添加<code>__init__.py</code>文件之后，如果需要导入的文件的路径：<code>application/app/folder/file.py</code>，可以通过如下命令导入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from application.app.folder.file import func_name</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder" target="_blank" rel="noopener">Importing files from different folder</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系列之用户、用户组和权限管理</title>
      <link href="/posts/61241.html"/>
      <url>/posts/61241.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>Linux</code>中<strong>用户、用户组和权限管理</strong>的相关知识。<strong>用户管理</strong>中，首先使用<code>adduser</code><strong>创建账号</strong>，然后使用<code>passwd</code>给创建的账号<strong>设置密码</strong>；在<strong>分组管理</strong>中，首先使用<code>groups</code>和<code>id</code>命令<strong>查看了用户的分组</strong>信息，然后使用<code>usermod</code><strong>更改了用户主分组</strong>；在<strong>权限管理</strong>中，首先介绍了文件(夹)的权限信息，然后使用<code>chmod</code><strong>修改文(夹)权限</strong>，最后使用<code>chown</code> 和 <code>chgrp</code> 命令来分别<strong>修改文件(夹)的所属用户和组</strong></p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验室新来了几个同学，需要给他们创建账号使用集群，刚好实验室之前的集群用户和用户组非常混乱，这里就统一学习和管理一下。</p><hr><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>首先需要创建新账户，创建账户有两个命令：<code>useradd</code>和<code>adduser</code>，关于<a href="https://askubuntu.com/questions/345974/what-is-the-difference-between-adduser-and-useradd" target="_blank" rel="noopener">两者的区别</a>：</p><blockquote><p>adduser and addgroup add users and groups to the system according to command line options and configuration information in <strong>/etc/adduser.conf</strong>. They are <strong>friendlier front ends</strong> to the low level tools like useradd, groupadd and usermod programs, by default choosing Debian policy conformant UID and GID values, creating a home directory with skeletal configuration, running a custom script, and other features.</p></blockquote><blockquote><p>useradd is a <strong>low level utility</strong> for adding users. On Debian, administrators should usually use adduser(8) instead.</p></blockquote><p>另外使用<code>useradd</code>命令不会自动创建<code>/home/username</code>目录(可以通过添加<code>-m</code>参数指定创建)，而使用<code>adduser</code>会自动创建<code>/home/username</code>目录，两个命令创建的用户家目录都可以通过<code>-d</code>参数指定。</p><p>这里我使用的命令是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户名为zhengshuang，家目录在/workstation/zhengshuang的用户</span></span><br><span class="line">adduser -d /workstation/zhengshuang zhengshuang</span><br><span class="line"></span><br><span class="line">  drwx------.  2 zhengshuang zhengshuang 4.0K Aug 13 02:17 zhengshuang</span><br><span class="line">  drwxr-xr--.  6 root        root        4.0K Aug  8 11:55 softwares</span><br></pre></td></tr></table></figure><p></p><p>发现创建完成之后会自动创建一个与用户名同名的分组，这种情况下如果创建多个账号，每个人都是不同的分组，以后不方便管理，所以这里需要对其分组进行更改。</p><hr><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">passwd zhengshuang</span><br><span class="line">  Changing password <span class="keyword">for</span> user zhengshuang.</span><br><span class="line">  New password: </span><br><span class="line">  Retype new password: </span><br><span class="line">  passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><hr><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除账号以及家目录</span></span><br><span class="line"><span class="comment"># -r, --remove：remove home directory and mail spool</span></span><br><span class="line">userdel -r username</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h2><h3 id="查看分组信息"><a href="#查看分组信息" class="headerlink" title="查看分组信息"></a>查看分组信息</h3><p>可以先看看所有的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分组信息</span></span><br><span class="line">getent group</span><br><span class="line"><span class="comment"># 查看所有分组信息</span></span><br><span class="line">cut -d<span class="string">':'</span> -f 1 /etc/group</span><br><span class="line"><span class="comment"># 也可以顺便查看所有的用户信息</span></span><br><span class="line">cut -d<span class="string">':'</span> -f 1 /etc/passwd</span><br></pre></td></tr></table></figure><p></p><p>使用<code>groups</code>命令查看某个用户的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看zhengshuang的分组信息</span></span><br><span class="line">groups zhengshuang</span><br><span class="line">  zhengshuang : zhengshuang</span><br></pre></td></tr></table></figure><p></p><p>使用<code>id</code>命令查看某个用户的分组信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id zhengshuang</span><br><span class="line">  uid=1027(zhengshuang) gid=1029(zhengshuang) groups=1029(zhengshuang)</span><br></pre></td></tr></table></figure><p></p><p>可以发现这个结果比前面使用<code>groups</code>的输出更加复杂一些：这里有一个 <code>gid</code>，表示<strong>主工作组(primary group)</strong>，后面还有个 <code>groups</code>，它列出了用户<strong>所在的所有组</strong>；<strong>主工作组只有一个，而后者(secondary groups)的数量则不限</strong>。总的来说，可以使用<code>id</code>命令看到用户组的结果和使用 <code>groups</code> 命令看到的结果是一致的。</p><hr><h3 id="添加组"><a href="#添加组" class="headerlink" title="添加组"></a>添加组</h3><p>为了解决创建用户步骤遗留下来的问题，首先需要添加组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加lab分组</span></span><br><span class="line">groupadd lab</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="更改用户分组信息"><a href="#更改用户分组信息" class="headerlink" title="更改用户分组信息"></a>更改用户分组信息</h3><p><strong>更改用户主分组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g:force use GROUP as new primary group</span></span><br><span class="line">usermod -g lab zhengshuang</span><br><span class="line">  drwx------.  2 zhengshuang lab         4.0K Aug 13 02:17 zhengshuang</span><br><span class="line">  drwxr-xr--.  6 root        root        4.0K Aug  8 11:55 softwares</span><br></pre></td></tr></table></figure><p></p><p>这里使用了<code>-g</code>来改变用户的主用户组，也就是前面<code>gid</code>显示组别，也是<code>ll</code>显示的组别，而如果不想改变主用户组，而是<strong>添加用户组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a:append the user to the supplemental GROUPS </span></span><br><span class="line"><span class="comment">#    mentioned by the -G option without removing him/her from other groups</span></span><br><span class="line"><span class="comment"># -G:new list of supplementary GROUPS</span></span><br><span class="line">usermod -a -G examplegroup exampleusername1,exampleusername2,exampleusername3...</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建用户并指定分组"><a href="#创建用户并指定分组" class="headerlink" title="创建用户并指定分组"></a>创建用户并指定分组</h3><p>在使用adduser创建用户的同时也可以指定分组信息：</p><ul><li><code>-g</code>：name or ID of the primary group of the new account</li><li><code>-G</code>：list of supplementary groups of the new account</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser -d /workstation/zhengshuang zhengshuang -g lab</span><br></pre></td></tr></table></figure><hr><h3 id="删除分组"><a href="#删除分组" class="headerlink" title="删除分组"></a>删除分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除默认创建用户时的分组</span></span><br><span class="line">groupdel zhengshuang</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><div class="note info"><p>这部分参考了<a href="https://cuiqingcai.com/6284.html" target="_blank" rel="noopener">这篇博客文章</a>，讲解非常细致。</p></div><h3 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ls -l  /etc/nginx </span><br><span class="line">  total 80</span><br><span class="line">  drwxr-xr-x   7 root root  4096 Jun 21 22:16 ./</span><br><span class="line">  drwxr-xr-x 103 root root  4096 Sep  4 18:04 ../</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jul 12  2017 conf.d/</span><br><span class="line">  -rw-r--r--   1 root root  1077 Feb 12  2017 fastcgi.conf</span><br><span class="line">  -rw-r--r--   1 root root  1007 Feb 12  2017 fastcgi_params</span><br><span class="line">  -rw-r--r--   1 root root  2837 Feb 12  2017 koi-utf</span><br><span class="line">  -rw-r--r--   1 root root  2223 Feb 12  2017 koi-win</span><br><span class="line">  -rw-r--r--   1 root root  3957 Feb 12  2017 mime.types</span><br><span class="line">  -rw-r--r--   1 root root  1505 Jun 21 20:24 nginx.conf</span><br><span class="line">  -rw-r--r--   1 root root 12288 Jun 21 20:44 .nginx.conf.swp</span><br><span class="line">  -rw-r--r--   1 root root   180 Feb 12  2017 proxy_params</span><br><span class="line">  -rw-r--r--   1 root root   636 Feb 12  2017 scgi_params</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 22:42 sites-available/</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 19:08 sites-enabled/</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 21 19:08 snippets/</span><br><span class="line">  -rw-r--r--   1 root root   664 Feb 12  2017 uwsgi_params</span><br><span class="line">  drwxr-xr-x   2 root root  4096 Jun 22 02:44 vhosts/</span><br><span class="line">  -rw-r--r--   1 root root  3071 Feb 12  2017 win-utf</span><br></pre></td></tr></table></figure><p>可以发现每一行都是一个文件或文件夹的信息，一共包括七列：</p><ul><li>第一列是文件的<strong>权限信息</strong></li><li>第二列表示该文件夹<strong>连接的文件数(？？)</strong></li><li>第三列表示文件<strong>所属用户</strong></li><li>第四列表示文件<strong>所属用户组</strong></li><li>第五列表示<strong>文件大小（字节）</strong></li><li>第六列表示<strong>最后修改日期</strong></li><li>第七列表示<strong>文件名</strong></li></ul><p>其中<strong>第一列</strong>的文件<strong>权限信息</strong>是非常重要的，它由十个字符组成：</p><ul><li>第一个字符代表文件的类型，有三种，<code>-</code> 代表这是一个文件，<code>d</code> 代表这是一个文件夹，<code>l</code> 代表这是一个链接。</li><li>第 <code>2-4</code> 个字符代表文件<strong>所有者</strong>对该文件的权限，<ul><li><code>r</code> 就是读</li><li><code>w</code> 就是写</li><li><code>x</code> 就是执行，如果是<strong>文件夹</strong>的话，<strong>执行就意味着查看文件夹下的内容</strong>，例如 <code>rw-</code> 就代表文件所有者可以对该文件进行读取和写入。</li></ul></li><li>第 <code>5-7</code> 个字符代表文件<strong>所属组</strong>对该文件的权限，含义是一样的，如 <code>r-x</code>就代表该文件<strong>所属组内的所有用户</strong>对该文件有读取和执行的权限。</li><li>第 <code>8-10</code> 个字符代表是<strong>其他用户</strong>对该文件的权限，含义也是一样的，如 <code>r–</code> 就代表<strong>非所有者、非用户组的用户</strong>只拥有对该文件的读取权限。</li></ul><hr><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>可以使用<code>chmod</code>命令来修改文件的权限，其中<strong>权限的表示</strong>有两种：</p><ul><li>一种是<strong>数字权限命名</strong>，<code>rwx</code> 对应一个<strong>二进制数字</strong>，如 <code>101</code> 就代表拥有<strong>读取和执行</strong>的权限，而转为十进制的话，<code>r</code> 就代表 <code>4</code>，<code>w</code>就代表 <code>2</code>，<code>x</code> 就代表 <code>1</code>，然后<strong>三个数字加起来就和二进制数字对应起来了</strong>。如 <code>7=4+2+1</code>，这就对应着 <code>rwx</code>；<code>5=4+1</code>，这就对应着 <code>r-x</code>。所以，相应地 <code>777</code> 就代表了 <code>rwxrwxrwx</code>，即<strong>所有者、所属用户组、其他用户对该文件都拥有读取、写入、执行的权限，这是相当危险的</strong>！</li><li>也可以使用<strong>代号来赋予权限</strong>，代号有 <code>u</code>、<code>g</code>、<code>o</code>、<code>a</code> 四中，分别代表<strong>所有者权限</strong>，<strong>用户组权限</strong>，<strong>其他用户权限</strong>和<strong>所有用户权限</strong>，这些代号后面通过 <code>+</code> 和 <code>–</code> 符号来<strong>控制权限的添加和移除</strong>，再后面跟上权限类型就好。例如：<code>u-x</code>就是给所有者移除 <code>x</code> 权限，也就是执行权限.</li></ul><p>如果是需要修改<strong>文件夹</strong>的权限，可以对文件夹进行<strong>递归赋权限</strong>操作：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 share 文件夹和其内所有内容都赋予 777 权限</span></span><br><span class="line">chmod -R 777 share</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="修改文件所有者和组"><a href="#修改文件所有者和组" class="headerlink" title="修改文件所有者和组"></a>修改文件所有者和组</h3><p>通过上面的<code>chmod</code>命令可以给文件(夹)针对不同的用户和组添加不同的权限，但是前提是要确定文件(夹)所属的用户和组具体。这里可以使用<code>chown</code> 和 <code>chgrp</code> 命令来分别<strong>修改文件(夹)的所属用户和组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件的所属用户</span></span><br><span class="line">chown &lt;username&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 修改文件的所属组</span></span><br><span class="line">chgrp &lt;group&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件夹的所属用户</span></span><br><span class="line">chown -R &lt;username&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 修改文件夹的所属组</span></span><br><span class="line">chgrp -R &lt;group&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p></p><p>实践：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 root root 4.0K Aug 13 03:46 Mouseproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件的所属用户</span></span><br><span class="line">chown -R zhengshuang Mouseproject</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 zhengshuang root 4.0K Aug 13 03:46 Mouseproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件的所属组</span></span><br><span class="line">chgrp lab -R Mouseproject</span><br><span class="line">  total 4.0K</span><br><span class="line">  drwxr-xr-x. 8 zhengshuang lab 4.0K Aug 13 03:46 Mouseproject</span><br></pre></td></tr></table></figure><p></p><p>通过上述修改(没有修改文件权限，默认的权限即可满足需求)，Mouseproject文件夹中的数据就可以被<code>zhengshuang</code>用户<code>rwx</code>，被<code>lab</code>组的其他用户<code>r-x</code>，被<code>非lab组</code>的其他用户<code>r-x</code>了。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/" target="_blank" rel="noopener">Create a New User and Assign a Group in One Command</a></li><li><a href="https://cuiqingcai.com/6284.html" target="_blank" rel="noopener">详解 Linux 下的用户管理、用户组管理和权限管理</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell系列之eval、printf和组合数</title>
      <link href="/posts/13990.html"/>
      <url>/posts/13990.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>使用shell得到组合数</strong>，其中用到了三个方面的trick：<code>特殊符号{}</code>、<code>printf中的{,}</code>，<code>eval命令</code>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在学习过程中遇到一个步骤需要得到组合数，之前也学习过使用使用python的<a href="http://showteeth.tech/posts/49907.html">itertools库(itertools.combinations)</a>得到组合数，但是这里是在shell中某一步需要得到组合数，再使用Python非常不划算，就想着直接使用shell得到组合数，在shell中得到组合数可以使用特殊符号<code>{}</code>，这个<a href="http://showteeth.tech/posts/55603.html">之前</a>也学习过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单纯的数字的组合数</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;0..1&#125;</span><br><span class="line">  00 01 10 11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字结合字母的组合数</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;a..b&#125;</span><br><span class="line">  0a 0b 1a 1b</span><br></pre></td></tr></table></figure><p>这里主要是遇到了两个trick进行命令行的简化。</p><h2 id="命令行的简化"><a href="#命令行的简化" class="headerlink" title="命令行的简化"></a>命令行的简化</h2><p>先给出简化的命令行形式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line">  000 001 010 011 100 101 110 111</span><br></pre></td></tr></table></figure><p></p><p>上述命令涉及到两个小trick：</p><ul><li><code>printf的{,}</code></li><li><code>eval命令</code></li></ul><h3 id="printf的"><a href="#printf的" class="headerlink" title="printf的{,}"></a>printf的{,}</h3><p>分解上述命令为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line">  &#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现printf应该是将<code>&#39;{0..1}&#39;</code>作为字符串打印了三遍，这是为什么呢？其中的<code>{,,}</code>是干什么的呢？</p><p>再次将上述命令分解为常见的形式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>)</span><br><span class="line">  &#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现，这里只打印出了一遍<code>{0..1}</code>，相较于存在<code>{,,}</code>的情形少打印了两遍，也就是说，存在<code>{,,}</code>会打印三遍<code>{0..1}</code>，两个逗号打印三遍，刚好两个逗号将3个字符(串)分开，那么如果如果存在一个逗号，是不是就是打印两遍呢？：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,&#125; )</span><br><span class="line">  &#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里确实是打印了两遍，联想之前学习的<a href="http://showteeth.tech/posts/47162.html">printf的用法</a>，猜测{,}是重复之前的字符，并且其中的,是重复的次数-1：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'abc'</span>&#123;,&#125;)</span><br><span class="line">  abcabc</span><br></pre></td></tr></table></figure><p></p><h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>在搞清楚上面<code>printf</code>的trick之后，再来看看<code>eval</code>命令，关于<code>eval</code>命令，大部分的介绍都是：当将命令行放入<code>eval</code>命令中后，shell在执行命令行之前扫描它两次，第一次会进行变量替换或运算，第二次是执行替换之后的命令(将<code>eval</code>之后的命令当成一个命令执行)；其<a href="https://www.tutorialspoint.com/unix_commands/eval" target="_blank" rel="noopener">英文说明</a>：</p><blockquote><p>eval is a built in linux or unix command. The eval command is used to <strong>execute the arguments as a shell command on unix or linux system</strong>. Eval command comes in handy <strong>when you have a unix or linux command stored in a variable</strong> and you <strong>want to execute that command stored in the string</strong>. The eval command <strong>first evaluates the argument</strong> and then <strong>runs the command stored in the argument</strong>.</p></blockquote><p>使用示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COMMAND=<span class="string">"ls -lrt"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="variable">$&#123;COMMAND&#125;</span></span><br><span class="line">  total 702</span><br><span class="line">  -rw-rw-r-- 1 user user 3595660 Aug 12 12:02 H12881_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user 3447580 Aug 12 12:02 H892.2_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user    7803 Aug 12 12:03 H892.2_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  -rw-rw-r-- 1 user user    7799 Aug 12 12:03 H12881_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  -rw-rw-r-- 1 user user 3621459 Aug 12 12:19 H892_WO-1_filter_final.vcf.gz</span><br><span class="line">  -rw-rw-r-- 1 user user    7816 Aug 12 12:19 H892_WO-1_filter_final.vcf.gz.tbi</span><br><span class="line">  drwxrwxr-x 2 user user    4096 Aug 12 20:15 dir</span><br><span class="line">  -rw-rw-r-- 1 user user 4653958 Aug 12 20:35 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>具体到这次的命令行中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：</span></span><br><span class="line">将$(<span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">'&#123;0..1&#125;'</span>&#123;,,&#125; )替换为&#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：</span></span><br><span class="line"><span class="built_in">echo</span> &#123;0..1&#125;&#123;0..1&#125;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于<code>eval</code>命令的更多用法，在后续学习中慢慢补充吧。</p><ul><li><strong>eval变量替换、执行结果替换、指定命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=5</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">printf</span> <span class="string">',%.0s'</span> &#123;1..$(expr <span class="variable">$&#123;num&#125;</span> - 1)&#125;</span><br><span class="line">  ,,,,</span><br></pre></td></tr></table></figure></li></ul><p><strong>eval嵌套</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=4</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> $(<span class="built_in">eval</span> <span class="built_in">printf</span> <span class="string">"'&#123;0..1&#125;'%.0s"</span> &#123;1..<span class="variable">$&#123;num&#125;</span>&#125;)</span><br><span class="line">  0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/204069/all-possible-combinations-of-characters-and-numbers" target="_blank" rel="noopener">All possible combinations of characters and numbers</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell系列之cp和mv的进阶用法</title>
      <link href="/posts/15765.html"/>
      <url>/posts/15765.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>cp</code>和<code>mv</code>命令将<strong>多个文件(夹)复制或者剪切到同一个目录</strong>中的方法以及<strong>将一(多)个文件拷贝到多个目录</strong>的方法。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>linux</code>下使用<code>cp</code>和<code>mv</code>命令时，经常会遇到需要<strong>将多个文件复制或者剪切到同一个目录</strong>下以及<strong>将一(多)个文件复制到多个目录中</strong>，这种时候使用简单的<code>cp</code>和<code>mv</code>就很难达到目的。</p><hr><h2 id="将多个文件复制到同一个目录"><a href="#将多个文件复制到同一个目录" class="headerlink" title="将多个文件复制到同一个目录"></a>将多个文件复制到同一个目录</h2><p><code>cp</code>命令使用较多的是<code>-r</code>和<code>-f</code>参数，但是这两个参数并不能解决目前的问题，这里需要使用另一个参数：<code>-t</code>-<strong>将所有的原文件(夹)复制到目标文件夹(copy all SOURCE arguments into DIRECTORY)</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个目录复制到同一个目录</span></span><br><span class="line">cp -r dir1 dir2 dir3 -t target_dir</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将一-多-个文件拷贝到多个目录"><a href="#将一-多-个文件拷贝到多个目录" class="headerlink" title="将一(多)个文件拷贝到多个目录"></a>将一(多)个文件拷贝到多个目录</h2><p>在这种情况下单凭<code>cp</code>命令是不能完成这个任务的，因为<code>cp</code>命令的介绍：<code>Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</code>并没有提到过可以将一(多)个文件复制到多个目录，这种情况下就需要借助之前学习的命令<a href="http://showteeth.tech/posts/30003.html">xargs</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xargs -n：指定一次处理的参数个数</span></span><br><span class="line"><span class="comment"># 每次只传递给cp一个目录</span></span><br><span class="line"><span class="built_in">echo</span> dir1 dir2 dir3 | xargs -n 1 cp file1 file2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意<code>xargs</code>一定要加<code>-n 1</code>，不然会将<code>dir1</code>、<code>dir2</code>、<code>file1</code>、<code>file2</code>全部复制到<code>dir3</code></p></div><hr><h2 id="将多个文件剪切到同一个目录"><a href="#将多个文件剪切到同一个目录" class="headerlink" title="将多个文件剪切到同一个目录"></a>将多个文件剪切到同一个目录</h2><p>和<code>cp</code>命令类似，<code>mv</code>命令也有一个<code>-t</code>参数，可以将多个文件(夹)剪切到同一个目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 dir2 dir3 -t target_dir1</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/195655/how-to-copy-a-file-to-multiple-directories-using-the-gnu-cp-command" target="_blank" rel="noopener">How to copy a file to multiple directories using the gnu cp command</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-同时给多个变量赋值</title>
      <link href="/posts/60071.html"/>
      <url>/posts/60071.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>如何将程序的输出结果同时赋值给多个变量</strong>，主要有两种方法：<strong><code>read</code>命令结合<code>&lt;&lt;&lt;</code></strong>、使用<strong>数组存储</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天写了一个<code>bash shell</code>小程序，有多个输出，想要将这多个输出同时传递给多个变量。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法主要有两种：使用reads命令、使用数组。</p><h3 id="使用read命令"><a href="#使用read命令" class="headerlink" title="使用read命令"></a>使用read命令</h3><p>之前也学习过<a href="http://showteeth.tech/posts/59492.html">read命令</a>，其可以<strong>从键盘或文件中获取输入</strong>，这里需要的是使用read从<strong>命令行</strong>读入变量，就需要结合之前的重定向符号<code>&lt;&lt;&lt;</code>，这里需要回顾一下<code>&lt;</code>、<code>&lt;&lt;</code>、<code>&lt;&lt;&lt;</code>三者的区别，之前在<a href="http://showteeth.tech/posts/55603.html">这篇文章</a>中也学习过：</p><ul><li><code>&lt;</code>：从<strong>文件</strong>获取读入</li><li><code>&lt;&lt; text</code>：从<strong>命令行</strong>读取输入，直到一个与<strong>text字符相同的行结束</strong></li><li><code>&lt;&lt;&lt;</code>：将<strong>word(字符)</strong>，注意不是上面的file读入。</li></ul><p>具体的使用如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接存储变量</span></span><br><span class="line"><span class="built_in">read</span> a b c &lt;&lt;&lt;$(<span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span>)</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"<span class="variable">$a</span>\t<span class="variable">$b</span>\t<span class="variable">$c</span>"</span></span><br><span class="line">  1       2       3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数组存储变量</span></span><br><span class="line"><span class="built_in">read</span> -a array &lt;&lt;&lt;$(<span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line"><span class="comment"># 使用的数组下标</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line">  0 1 2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array2=($(<span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array2[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/1952404/linux-bash-multiple-variable-assignment" target="_blank" rel="noopener">Linux bash: Multiple variable assignment</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之没有root安装packages</title>
      <link href="/posts/9464.html"/>
      <url>/posts/9464.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在没有<code>root</code>权限的条件下给系统(<code>centos</code>)自带的<code>python</code>安装<code>packages</code>的方法，主要是使用<code>pip install --user package</code>，安装的路径在<code>~/.local/</code></p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为课题的需要，今天打算另一个集群2.7的python中安装<code>pybedtools</code>包，但是安装却发现如下报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOError: [Errno 13] Permission denied: <span class="string">'/usr/lib/python2.7/site-packages/six.py'</span></span><br></pre></td></tr></table></figure><p></p><p>这一看就是没有访问权限的问题，毕竟是别人的集群，没有root权限想要安装package到自带的python中就不能使用上述方法。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用如下方法进行安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user pybedtools</span><br></pre></td></tr></table></figure><p></p><p>这种包默认的安装路径是在<code>~/.local/</code></p><p>如果上述方法不奏效，可以参考<a href="https://stackoverflow.com/questions/7465445/how-to-install-python-modules-without-root-access" target="_blank" rel="noopener">How to install python modules without root access?</a>中的其他方法。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/7465445/how-to-install-python-modules-without-root-access" target="_blank" rel="noopener">How to install python modules without root access?</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之加速Python小tips</title>
      <link href="/posts/47268.html"/>
      <url>/posts/47268.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>Python中加速计算的一些小tips</strong>，其中有很多方法只是<strong>略有提及</strong>，并没有做深入地学习，目前只是大致了解一些针对不同情形可以使用什么加速方法，<strong>后续使用的时候再有针对性地学习</strong>。</p></div><a id="more"></a><h2 id="分析代码运行时间"><a href="#分析代码运行时间" class="headerlink" title="分析代码运行时间"></a>分析代码运行时间</h2><p>总结：</p><ul><li>测试代码<strong>单次运行时间</strong>：<code>time.time()</code>之差，或者使用<code>%%time</code>，如果是单行，可以使用<code>%time</code>；</li><li><strong>平均</strong>用时：<code>timeit</code>模块或者<code>%%timeit</code></li><li>按<strong>函数</strong>分析运行时间：<code>profile</code>模块或者<code>%prun</code></li><li>按<strong>行</strong>分析代码运行时间：<code>line_profiler</code>或者<code>%lprun</code></li></ul><h3 id="测试代码的运行时间"><a href="#测试代码的运行时间" class="headerlink" title="测试代码的运行时间"></a>测试代码的运行时间</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 记录开始时间</span></span><br><span class="line">tic=time.time()</span><br><span class="line"><span class="comment"># 运行陈程序</span></span><br><span class="line">much_job=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 记录结束时间</span></span><br><span class="line">toc=time.time()</span><br><span class="line"><span class="comment"># 小数点后保留5位小数</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'used &#123;:.5&#125;s'</span>.format(toc-tic))</span><br></pre></td></tr></table></figure><pre><code>used 0.13954s</code></pre><h4 id="jupyter中的方法"><a href="#jupyter中的方法" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">much_job=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 135 ms, sys: 7.1 ms, total: 142 msWall time: 140 ms</code></pre><h3 id="测试代码平均用时"><a href="#测试代码平均用时" class="headerlink" title="测试代码平均用时"></a>测试代码平均用时</h3><h4 id="通用方法-1"><a href="#通用方法-1" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line">g=<span class="keyword">lambda</span> x:x**<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (g(<span class="number">2</span>)**<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">timeit(<span class="string">'main()'</span>,globals=&#123;<span class="string">'main'</span>:main&#125;,number=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>2.5913002900779247e-05</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(timeit)</span><br></pre></td></tr></table></figure><pre><code>Help on function timeit in module timeit:timeit(stmt=&apos;pass&apos;, setup=&apos;pass&apos;, timer=&lt;built-in function perf_counter&gt;, number=1000000, globals=None)    Convenience function to create Timer object and call timeit method.</code></pre><h4 id="jupyter中的方法-1"><a href="#jupyter中的方法-1" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%timeit -n <span class="number">10</span></span><br><span class="line">g=<span class="keyword">lambda</span> x:x**<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (g(<span class="number">2</span>)**<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><pre><code>2.34 µs ± 211 ns per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre><h3 id="分析函数运行时间"><a href="#分析函数运行时间" class="headerlink" title="分析函数运行时间"></a>分析函数运行时间</h3><h4 id="通用方法-2"><a href="#通用方法-2" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(x <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result=[relu(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-100000</span>,<span class="number">100000</span>,<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> (result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> profile</span><br><span class="line">profile.run(<span class="string">'main()'</span>)</span><br></pre></td></tr></table></figure><pre><code>      200006 function calls in 0.672 secondsOrdered by: standard namencalls  tottime  percall  cumtime  percall filename:lineno(function)     1    0.000    0.000    0.672    0.672 :0(exec)     1    0.000    0.000    0.000    0.000 :0(setprofile)200000    0.322    0.000    0.322    0.000 &lt;ipython-input-9-aae7666d2db5&gt;:1(relu)     1    0.000    0.000    0.671    0.671 &lt;ipython-input-9-aae7666d2db5&gt;:4(main)     1    0.348    0.348    0.671    0.671 &lt;ipython-input-9-aae7666d2db5&gt;:5(&lt;listcomp&gt;)     1    0.001    0.001    0.672    0.672 &lt;string&gt;:1(&lt;module&gt;)     1    0.000    0.000    0.672    0.672 profile:0(main())     0    0.000             0.000          profile:0(profiler)</code></pre><h4 id="jupyter中的方法-2"><a href="#jupyter中的方法-2" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><p>和前面的结果相同，但是是以弹框的形式展示的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun main()</span><br></pre></td></tr></table></figure><h3 id="按行分析代码运行时间"><a href="#按行分析代码运行时间" class="headerlink" title="按行分析代码运行时间"></a>按行分析代码运行时间</h3><p><code>%lprun</code>命令如果不能得到正确的输出，可以参考：<a href="https://stackoverflow.com/questions/19942653/interactive-python-cannot-get-lprun-to-work-although-line-profiler-is-impor" target="_blank" rel="noopener">Interactive Python: cannot get <code>%lprun</code> to work, although line_profiler is imported properly</a></p><h4 id="通用方法-3"><a href="#通用方法-3" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(x <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result=[relu(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-100000</span>,<span class="number">100000</span>,<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> (result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> line_profiler <span class="keyword">import</span> LineProfiler</span><br><span class="line">lprofile = LineProfiler(main,relu)</span><br><span class="line">lprofile.run(<span class="string">'main()'</span>)</span><br><span class="line">lprofile.print_stats()</span><br></pre></td></tr></table></figure><pre><code>Timer unit: 1e-06 sTotal time: 0.077296 sFile: &lt;ipython-input-72-aae7666d2db5&gt;Function: relu at line 1Line #      Hits         Time  Per Hit   % Time  Line Contents==============================================================     1                                           def relu(x):     2    200000      77296.0      0.4    100.0      return(x if x&gt;0 else 0)Total time: 0.259755 sFile: &lt;ipython-input-72-aae7666d2db5&gt;Function: main at line 4Line #      Hits         Time  Per Hit   % Time  Line Contents==============================================================     4                                           def main():     5         1     259754.0 259754.0    100.0      result=[relu(x) for x in range(-100000,100000,1)]     6         1          1.0      1.0      0.0      return (result)</code></pre><h4 id="jupyter中的方法-3"><a href="#jupyter中的方法-3" class="headerlink" title="jupyter中的方法"></a>jupyter中的方法</h4><p>如果报错：UsageError: Line magic function <code>%lprun</code> not found.<br><a href="https://stackoverflow.com/questions/19942653/interactive-python-cannot-get-lprun-to-work-although-line-profiler-is-impor" target="_blank" rel="noopener">解决方法</a>：</p><ul><li>暂时的解决方法：<code>%load_ext line_profiler</code></li><li>永久的解决方法：在<code>~/.ipython/profile_default/ipython_config.py</code>(如果没有这个文件，可以使用<code>ipython profile create</code>创建)文件中添加<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.TerminalIPythonApp.extensions = [</span><br><span class="line">    <span class="string">'line_profiler'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load_ext line_profiler</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%lprun -f main -f relu main()</span><br></pre></td></tr></table></figure><h2 id="加速查找"><a href="#加速查找" class="headerlink" title="加速查找"></a>加速查找</h2><p>总结：</p><ul><li>在<strong>单个列表</strong>中查找某个元素：使用<code>set</code>比使用<code>list</code>快</li><li><strong>两个列表联合</strong>查找：使用<code>dict</code>比使用两个<code>list</code>要快</li></ul><h3 id="使用set而不是list进行查找"><a href="#使用set而不是list进行查找" class="headerlink" title="使用set而不是list进行查找"></a>使用set而不是list进行查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=(i**<span class="number">2</span> + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>) )</span><br></pre></td></tr></table></figure><h4 id="低速方法-list"><a href="#低速方法-list" class="headerlink" title="低速方法-list"></a>低速方法-list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_data=list(data)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="number">1098987</span> <span class="keyword">in</span> list_data</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 25.4 ms, sys: 0 ns, total: 25.4 msWall time: 25.1 msFalse</code></pre><h4 id="高速方法-set"><a href="#高速方法-set" class="headerlink" title="高速方法-set"></a>高速方法-set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_data=set(data)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="number">1098987</span> <span class="keyword">in</span> set_data</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 7 µs, sys: 0 ns, total: 7 µsWall time: 12.9 µsFalse</code></pre><h3 id="使用dict而非两个list进行匹配查找"><a href="#使用dict而非两个list进行匹配查找" class="headerlink" title="使用dict而非两个list进行匹配查找"></a>使用dict而非两个list进行匹配查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_a=[<span class="number">2</span>*i<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)]</span><br><span class="line">list_b=[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> list_a]</span><br></pre></td></tr></table></figure><h4 id="低速方法-两个list"><a href="#低速方法-两个list" class="headerlink" title="低速方法-两个list"></a>低速方法-两个list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">print</span> (list_b[list_a.index(<span class="number">876567</span>)])</span><br></pre></td></tr></table></figure><pre><code>768369705489CPU times: user 12 ms, sys: 0 ns, total: 12 msWall time: 11.9 ms</code></pre><h4 id="高速方法-dict"><a href="#高速方法-dict" class="headerlink" title="高速方法-dict"></a>高速方法-dict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b=[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">dict(zip(a,b))</span><br></pre></td></tr></table></figure><pre><code>{1: 3, 2: 4}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_ab=dict(zip(list_a,list_b))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">print</span> (dict_ab.get(<span class="number">876567</span>))</span><br></pre></td></tr></table></figure><pre><code>768369705489CPU times: user 179 µs, sys: 12 µs, total: 191 µsWall time: 109 µs</code></pre><h2 id="加速循环"><a href="#加速循环" class="headerlink" title="加速循环"></a>加速循环</h2><p>总结：</p><ul><li>使用<code>for</code>循环比使用<code>while</code>循环更加快</li><li><strong>避免在循环中重复计算</strong></li></ul><h3 id="优先使用for循环而不是while循环"><a href="#优先使用for循环而不是while循环" class="headerlink" title="优先使用for循环而不是while循环"></a>优先使用for循环而不是while循环</h3><h4 id="低速方法-while"><a href="#低速方法-while" class="headerlink" title="低速方法-while"></a>低速方法-while</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">s,i=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10000</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    s += i</span><br><span class="line"><span class="keyword">print</span> (s)</span><br></pre></td></tr></table></figure><pre><code>50005000CPU times: user 4.14 ms, sys: 7 µs, total: 4.15 msWall time: 4 ms</code></pre><h4 id="高速方法-for"><a href="#高速方法-for" class="headerlink" title="高速方法-for"></a>高速方法-for</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10001</span>):</span><br><span class="line">    s += i</span><br><span class="line"><span class="keyword">print</span> (s)</span><br></pre></td></tr></table></figure><pre><code>50005000CPU times: user 3.05 ms, sys: 2 µs, total: 3.06 msWall time: 2.91 ms</code></pre><h3 id="在循环体中避免重复计算"><a href="#在循环体中避免重复计算" class="headerlink" title="在循环体中避免重复计算"></a>在循环体中避免重复计算</h3><h4 id="低速方法"><a href="#低速方法" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[i**<span class="number">2</span>+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="comment"># sum重复计算</span></span><br><span class="line">b=[i/sum(a) <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 54.7 ms, sys: 76 µs, total: 54.8 msWall time: 53.6 ms</code></pre><h4 id="高速方法"><a href="#高速方法" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time </span><br><span class="line">sum_a=sum(a)</span><br><span class="line">b=[i/sum_a <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 360 µs, sys: 0 ns, total: 360 µsWall time: 367 µs</code></pre><h2 id="加速函数"><a href="#加速函数" class="headerlink" title="加速函数"></a>加速函数</h2><p>总结：</p><ul><li>使用<strong>循环代替递归</strong>，递归速度更慢一些</li><li>使用<code>lru_cache</code>的<strong>缓存机制</strong>加速递归</li><li>使用<code>numba</code>加速函数</li></ul><h3 id="使用循环代替递归"><a href="#使用循环代替递归" class="headerlink" title="使用循环代替递归"></a>使用循环代替递归</h3><h4 id="低速方法-递归"><a href="#低速方法-递归" class="headerlink" title="低速方法-递归"></a>低速方法-递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">else</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>))</span><br><span class="line"><span class="keyword">print</span> (fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 273 ms, sys: 2.78 ms, total: 275 msWall time: 274 ms</code></pre><h4 id="高速方法-循环"><a href="#高速方法-循环" class="headerlink" title="高速方法-循环"></a>高速方法-循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>)</span><br><span class="line">    a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">    <span class="keyword">return</span> (b)</span><br><span class="line">print(fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 195 µs, sys: 13 µs, total: 208 µsWall time: 149 µs</code></pre><h3 id="缓存机制加速递归函数"><a href="#缓存机制加速递归函数" class="headerlink" title="缓存机制加速递归函数"></a>缓存机制加速递归函数</h3><h4 id="低速方法-递归-1"><a href="#低速方法-递归-1" class="headerlink" title="低速方法-递归"></a>低速方法-递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">else</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>))</span><br><span class="line"><span class="keyword">print</span> (fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 275 ms, sys: 2.79 ms, total: 277 msWall time: 275 ms</code></pre><h4 id="高速方法-缓存"><a href="#高速方法-缓存" class="headerlink" title="高速方法-缓存"></a>高速方法-缓存</h4><p><a href="http://kuanghy.github.io/2016/04/20/python-cache" target="_blank" rel="noopener">lru_cache参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多缓存100个函数运行的结果</span></span><br><span class="line"><span class="comment"># 如果为None，则无限制，设置为2n时，性能最佳</span></span><br><span class="line"><span class="meta">@lru_cache(100)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">else</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>))</span><br><span class="line"><span class="keyword">print</span> (fib(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><pre><code>832040CPU times: user 293 µs, sys: 19 µs, total: 312 µsWall time: 227 µs</code></pre><h3 id="使用numba加速Python函数"><a href="#使用numba加速Python函数" class="headerlink" title="使用numba加速Python函数"></a>使用numba加速Python函数</h3><h4 id="低速方法-1"><a href="#低速方法-1" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power_sum</span><span class="params">(n)</span>:</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        s=s+my_power(i)</span><br><span class="line">    <span class="keyword">return</span> (s)</span><br><span class="line"></span><br><span class="line">print(my_power_sum(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><pre><code>333333833333500000CPU times: user 456 ms, sys: 1.81 ms, total: 458 msWall time: 456 ms</code></pre><h4 id="高速方法-numba"><a href="#高速方法-numba" class="headerlink" title="高速方法-numba"></a>高速方法-numba</h4><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/27152060" target="_blank" rel="noopener">Python · numba 的基本应用</a></li><li><a href="https://www.jianshu.com/p/69d9d7e37bc5" target="_blank" rel="noopener">加速python运行-numba</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_power_sum</span><span class="params">(n)</span>:</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        s=s+my_power(i)</span><br><span class="line">    <span class="keyword">return</span> (s)</span><br><span class="line"></span><br><span class="line">print(my_power_sum(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><pre><code>333333833333500000CPU times: user 100 ms, sys: 1.11 ms, total: 101 msWall time: 100 ms</code></pre><h2 id="使用标准库函数进行加速"><a href="#使用标准库函数进行加速" class="headerlink" title="使用标准库函数进行加速"></a>使用标准库函数进行加速</h2><p>总结：</p><ul><li>使用<code>collections.Counter</code>加速计数</li><li>使用<code>collections.ChainMap</code>加速字典合并</li></ul><h3 id="使用collections-Counter加速计数"><a href="#使用collections-Counter加速计数" class="headerlink" title="使用collections.Counter加速计数"></a>使用collections.Counter加速计数</h3><h4 id="低速方法-2"><a href="#低速方法-2" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=[x**<span class="number">2</span>%<span class="number">1989</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2000000</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">values_count=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    i_cnt=values_count.get(i,<span class="number">0</span>)</span><br><span class="line">    values_count[i]=i_cnt + <span class="number">1</span></span><br><span class="line">print(values_count.get(<span class="number">4</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>8044CPU times: user 682 ms, sys: 440 µs, total: 682 msWall time: 680 ms</code></pre><p>函数的使用:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.get(key, default=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p>参数：</p><ul><li><code>key</code> – 字典中要查找的键。</li><li><code>default</code> – 如果指定键的值不存在时，返回该默认值值</li></ul><h4 id="高速方法-collections"><a href="#高速方法-collections" class="headerlink" title="高速方法-collections"></a>高速方法-collections</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">values_count=Counter(data)</span><br><span class="line">print(values_count.get(<span class="number">4</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>8044CPU times: user 234 ms, sys: 0 ns, total: 234 msWall time: 233 ms</code></pre><h3 id="使用collections-ChainMap加速字典合并"><a href="#使用collections-ChainMap加速字典合并" class="headerlink" title="使用collections.ChainMap加速字典合并"></a>使用collections.ChainMap加速字典合并</h3><h4 id="低速方法-3"><a href="#低速方法-3" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_a=&#123;i:i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">2</span>)&#125;</span><br><span class="line">dict_b=&#123;i:<span class="number">2</span>*i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)&#125;</span><br><span class="line">dict_c=&#123;i:<span class="number">3</span>*i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">5</span>)&#125;</span><br><span class="line">dict_d=&#123;i:<span class="number">4</span>*i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">7</span>)&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">result=dict_a.copy()</span><br><span class="line">result.update(dict_b)</span><br><span class="line">result.update(dict_c)</span><br><span class="line">result.update(dict_d)</span><br><span class="line">print(result.get(<span class="number">9999</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>10000CPU times: user 79.9 ms, sys: 33.6 ms, total: 113 msWall time: 112 ms</code></pre><h4 id="高速方法-1"><a href="#高速方法-1" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">chain=ChainMap(dict_a,dict_b,dict_c,dict_d)</span><br><span class="line">print(result.get(<span class="number">9999</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>10000CPU times: user 186 µs, sys: 18 µs, total: 204 µsWall time: 150 µs</code></pre><h2 id="使用numpy向量化代替list"><a href="#使用numpy向量化代替list" class="headerlink" title="使用numpy向量化代替list"></a>使用numpy向量化代替list</h2><p>总结：</p><ul><li>使用<code>array</code>代替<code>list</code>进行运算</li><li>使用<code>np.ufunc</code>代替<code>math.func</code></li><li>使用<code>np.where</code>代替<code>if</code></li></ul><h3 id="使用array代替list"><a href="#使用array代替list" class="headerlink" title="使用array代替list"></a>使用array代替list</h3><h4 id="低速方法-list-1"><a href="#低速方法-list-1" class="headerlink" title="低速方法-list"></a>低速方法-list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">a=range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">b=range(<span class="number">1000000</span>,<span class="number">1</span>,<span class="number">-3</span>)</span><br><span class="line">c=[<span class="number">3</span>*a[i] - <span class="number">2</span>*b[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(a))]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 176 ms, sys: 7.75 ms, total: 184 msWall time: 181 ms</code></pre><h4 id="高速方法-2"><a href="#高速方法-2" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_a=np.arange(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">array_b=np.arange(<span class="number">1000000</span>,<span class="number">1</span>,<span class="number">-3</span>)</span><br><span class="line">array_c=<span class="number">3</span>*array_a - <span class="number">2</span>*array_b</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.18 ms, sys: 935 µs, total: 5.12 msWall time: 3.65 ms</code></pre><h3 id="使用np-ufunc代替math-func"><a href="#使用np-ufunc代替math-func" class="headerlink" title="使用np.ufunc代替math.func"></a>使用np.ufunc代替math.func</h3><h4 id="低速方法-math-func"><a href="#低速方法-math-func" class="headerlink" title="低速方法-math.func"></a>低速方法-math.func</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">a=range(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">b=[math.log(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 117 ms, sys: 1.88 ms, total: 119 msWall time: 116 ms</code></pre><h4 id="高速方法-np-ufunc"><a href="#高速方法-np-ufunc" class="headerlink" title="高速方法-np.ufunc"></a>高速方法-np.ufunc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_a=np.arange(<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">3</span>)</span><br><span class="line">array_b=np.log(array_a)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 20.8 ms, sys: 1.98 ms, total: 22.8 msWall time: 21.3 ms</code></pre><h3 id="使用np-where代替if"><a href="#使用np-where代替if" class="headerlink" title="使用np.where代替if"></a>使用np.where代替if</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_a=np.arange(<span class="number">-100000</span>,<span class="number">1000000</span>)</span><br></pre></td></tr></table></figure><h4 id="低速方法-4"><a href="#低速方法-4" class="headerlink" title="低速方法"></a>低速方法</h4><p><code>np.vectorize</code>可以将普通函数转换为支持向量化的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">relu=np.vectorize(<span class="keyword">lambda</span> x:x <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">array_b=relu(array_a)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 241 ms, sys: 29.1 ms, total: 270 msWall time: 325 ms</code></pre><h4 id="高速方法-3"><a href="#高速方法-3" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">relu=<span class="keyword">lambda</span> x:np.where(x&gt;<span class="number">0</span>,x,<span class="number">0</span>)</span><br><span class="line">array_b=relu(array_a)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.86 ms, sys: 1e+03 µs, total: 5.86 msWall time: 4.36 ms</code></pre><h2 id="加速pandas"><a href="#加速pandas" class="headerlink" title="加速pandas"></a>加速pandas</h2><p>总结：</p><ul><li>运算时：使用<code>np.ufunc</code>函数代替<code>applymap</code></li><li>初始化dataframe时：使用<strong>预分配存储</strong>代替<strong>动态扩容</strong></li><li>读写文件时：使用<code>csv</code>文件代替<code>excel</code>文件读写</li><li>使用pandas多进程工具<code>pandarallel</code></li></ul><h3 id="使用np-ufunc函数代替applymap"><a href="#使用np-ufunc函数代替applymap" class="headerlink" title="使用np.ufunc函数代替applymap"></a>使用np.ufunc函数代替applymap</h3><h4 id="低速方法-使用applymap"><a href="#低速方法-使用applymap" class="headerlink" title="低速方法-使用applymap"></a>低速方法-使用applymap</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame(np.random.randint(<span class="number">-10</span>,<span class="number">11</span>,size=(<span class="number">100000</span>,<span class="number">26</span>)),</span><br><span class="line">               columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>...</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><th>0</th><td>-1</td><td>10</td><td>-6</td><td>7</td><td>1</td><td>8</td><td>3</td><td>0</td><td>4</td><td>-8</td><td>...</td><td>8</td><td>-7</td><td>-5</td><td>8</td><td>-8</td><td>-6</td><td>8</td><td>4</td><td>6</td><td>-4</td></tr><tr><th>1</th><td>7</td><td>-4</td><td>3</td><td>-9</td><td>0</td><td>-7</td><td>-10</td><td>3</td><td>-6</td><td>6</td><td>...</td><td>5</td><td>4</td><td>-5</td><td>10</td><td>2</td><td>-7</td><td>-1</td><td>-10</td><td>-7</td><td>0</td></tr><tr><th>2</th><td>-7</td><td>10</td><td>3</td><td>5</td><td>4</td><td>4</td><td>6</td><td>0</td><td>-8</td><td>-5</td><td>...</td><td>1</td><td>-1</td><td>0</td><td>2</td><td>4</td><td>-5</td><td>0</td><td>6</td><td>2</td><td>0</td></tr><tr><th>3</th><td>-8</td><td>10</td><td>-4</td><td>4</td><td>8</td><td>-9</td><td>-10</td><td>-10</td><td>2</td><td>-6</td><td>...</td><td>10</td><td>8</td><td>9</td><td>10</td><td>3</td><td>7</td><td>-1</td><td>2</td><td>0</td><td>5</td></tr><tr><th>4</th><td>4</td><td>3</td><td>3</td><td>9</td><td>-5</td><td>-1</td><td>4</td><td>1</td><td>3</td><td>-6</td><td>...</td><td>3</td><td>-1</td><td>-2</td><td>6</td><td>9</td><td>-1</td><td>0</td><td>2</td><td>-1</td><td>6</td></tr></tbody></table><br><p>5 rows × 26 columns</p><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time dfresult=df.applymap(<span class="keyword">lambda</span> x:np.sin(x)+np.cos(x))</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 9.28 s, sys: 72 ms, total: 9.36 sWall time: 9.35 s</code></pre><h4 id="高速方法-np-ufunc-1"><a href="#高速方法-np-ufunc-1" class="headerlink" title="高速方法-np.ufunc"></a>高速方法-np.ufunc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">dfresult=np.sin(df) + np.cos(df)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 256 ms, sys: 41.3 ms, total: 298 msWall time: 325 ms</code></pre><h3 id="使用预分配存储代替动态扩容"><a href="#使用预分配存储代替动态扩容" class="headerlink" title="使用预分配存储代替动态扩容"></a>使用预分配存储代替动态扩容</h3><h4 id="低速方法-动态扩容"><a href="#低速方法-动态扩容" class="headerlink" title="低速方法-动态扩容"></a>低速方法-动态扩容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df=pd.DataFrame(columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    df.loc[i,:]=range(i,i+<span class="number">26</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 12.5 s, sys: 0 ns, total: 12.5 sWall time: 12.5 s</code></pre><h4 id="高速方法-预分配存储"><a href="#高速方法-预分配存储" class="headerlink" title="高速方法-预分配存储"></a>高速方法-预分配存储</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df=pd.DataFrame(np.zeros((<span class="number">10000</span>,<span class="number">26</span>)),</span><br><span class="line">                columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    df.loc[i,:]=range(i,i+<span class="number">26</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 3.06 s, sys: 16.4 ms, total: 3.07 sWall time: 3 s</code></pre><h3 id="使用csv文件代替excel文件读写"><a href="#使用csv文件代替excel文件读写" class="headerlink" title="使用csv文件代替excel文件读写"></a>使用csv文件代替excel文件读写</h3><h4 id="低速方法-写入excel文件"><a href="#低速方法-写入excel文件" class="headerlink" title="低速方法-写入excel文件"></a>低速方法-写入excel文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df.to_excel(<span class="string">'data.xlsx'</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.64 s, sys: 37.4 ms, total: 4.68 sWall time: 4.86 s</code></pre><h4 id="高速方法-写入csv文件"><a href="#高速方法-写入csv文件" class="headerlink" title="高速方法-写入csv文件"></a>高速方法-写入csv文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">df.to_csv(<span class="string">'data.csv'</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 300 ms, sys: 1.9 ms, total: 302 msWall time: 300 ms</code></pre><h3 id="使用pandas多进程工具pandarallel"><a href="#使用pandas多进程工具pandarallel" class="headerlink" title="使用pandas多进程工具pandarallel"></a>使用pandas多进程工具pandarallel</h3><h4 id="低速方法-5"><a href="#低速方法-5" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame(np.random.randint(<span class="number">-10</span>,<span class="number">11</span>,size=(<span class="number">100000</span>,<span class="number">26</span>)),</span><br><span class="line">               columns=list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>...</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><th>0</th><td>-2</td><td>6</td><td>10</td><td>10</td><td>-1</td><td>6</td><td>-9</td><td>7</td><td>-3</td><td>1</td><td>...</td><td>-10</td><td>-8</td><td>5</td><td>8</td><td>-4</td><td>7</td><td>-3</td><td>9</td><td>9</td><td>4</td></tr><tr><th>1</th><td>4</td><td>1</td><td>-6</td><td>-1</td><td>-2</td><td>-5</td><td>-1</td><td>7</td><td>1</td><td>3</td><td>...</td><td>-10</td><td>10</td><td>7</td><td>3</td><td>0</td><td>3</td><td>1</td><td>-2</td><td>8</td><td>0</td></tr><tr><th>2</th><td>0</td><td>1</td><td>-2</td><td>-3</td><td>2</td><td>4</td><td>2</td><td>-7</td><td>8</td><td>3</td><td>...</td><td>4</td><td>10</td><td>-1</td><td>2</td><td>-7</td><td>-6</td><td>10</td><td>4</td><td>-4</td><td>-9</td></tr><tr><th>3</th><td>-4</td><td>5</td><td>-9</td><td>-8</td><td>-2</td><td>-7</td><td>-1</td><td>3</td><td>-2</td><td>-4</td><td>...</td><td>10</td><td>-9</td><td>-3</td><td>-8</td><td>-4</td><td>-3</td><td>-5</td><td>-3</td><td>-1</td><td>-2</td></tr><tr><th>4</th><td>8</td><td>3</td><td>-7</td><td>2</td><td>3</td><td>9</td><td>-10</td><td>0</td><td>0</td><td>-2</td><td>...</td><td>4</td><td>3</td><td>9</td><td>3</td><td>5</td><td>-2</td><td>-9</td><td>-5</td><td>-10</td><td>-4</td></tr></tbody></table><br><p>5 rows × 26 columns</p><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">result=df.apply(np.sum,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 11.1 s, sys: 0 ns, total: 11.1 sWall time: 11.1 s</code></pre><h4 id="高速方法-pandarallel"><a href="#高速方法-pandarallel" class="headerlink" title="高速方法-pandarallel"></a>高速方法-pandarallel</h4><p>参考链接：</p><ul><li>pandarallel的<a href="https://github.com/nalepae/pandarallel" target="_blank" rel="noopener">github</a></li><li><a href="https://nbviewer.jupyter.org/github/nalepae/pandarallel/blob/master/docs/examples.ipynb" target="_blank" rel="noopener">使用示例</a></li><li><a href="https://zhuanlan.zhihu.com/p/61746020" target="_blank" rel="noopener">用法的中文翻译</a></li></ul><p>支持的相关方法：</p><table><thead><tr><th>Without parallelisation</th><th>With parallelisation</th></tr></thead><tbody><tr><td><code>df.apply(func)</code></td><td><code>df.parallel_apply(func)</code></td></tr><tr><td><code>df.applymap(func)</code></td><td><code>df.parallel_applymap(func)</code></td></tr><tr><td><code>df.groupby(args).apply(func)</code></td><td><code>df.groupby(args).parallel_apply(func)</code></td></tr><tr><td><code>df.groupby(args1).col_name.rolling(args2).apply(func)</code></td><td><code>df.groupby(args1).col_name.rolling(args2).parallel_apply(func)</code></td></tr><tr><td><code>series.map(func)</code></td><td><code>series.parallel_map(func)</code></td></tr><tr><td><code>series.apply(func)</code></td><td><code>series.parallel_apply(func)</code></td></tr><tr><td><code>series.rolling(args).apply(func)</code></td><td><code>series.rolling(args).parallel_apply(func)</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> pandarallel <span class="keyword">import</span> pandarallel</span><br><span class="line">pandarallel.initialize(nb_workers=<span class="number">4</span>)</span><br><span class="line">result=df.parallel_apply(np.sum,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>New pandarallel memory created - Size: 2000 MBPandarallel will run on 4 workersCPU times: user 38.8 ms, sys: 58.8 ms, total: 97.6 msWall time: 3.3 s</code></pre><h2 id="使用dask进行加速"><a href="#使用dask进行加速" class="headerlink" title="使用dask进行加速"></a>使用dask进行加速</h2><p><a href="https://docs.dask.org/en/latest/why.html" target="_blank" rel="noopener">dask简介</a>：</p><blockquote><p>Dask provides ways to scale <code>Pandas</code>, <code>Scikit-Learn</code>, and <code>Numpy</code> workflows with minimal rewriting. It integrates well with these tools so that it copies most of their API and uses their data structures internally. Moreover, Dask is co-developed with these libraries to ensure that they evolve consistently, minimizing friction caused from transitioning from workloads on a local laptop, to a multi-core workstation, and to a distributed cluster. Analysts familiar with Pandas/Scikit-Learn/Numpy will be immediately familiar with their Dask equivalents, and have much of their intuition carry over to a scalable context.</p></blockquote><p><br></p><p><a href="https://docs.dask.org/en/latest/use-cases.html" target="_blank" rel="noopener">适用情形</a>：<br>Dask use cases can be roughly divided in the following two categories:</p><ul><li>Large <code>NumPy/Pandas/Lists</code> with <code>dask.array</code>, <code>dask.dataframe</code>, <code>dask.bag</code> to analyze large datasets with familiar techniques. This is similar to Databases, Spark, or big array libraries</li><li>Custom task scheduling. You submit a graph of functions that depend on each other for custom workloads. This is similar to Luigi, Airflow, Celery, or Makefiles</li></ul><p>学习教程:</p><ul><li><a href="https://cloud.tencent.com/developer/article/1010999" target="_blank" rel="noopener">python︱大规模数据存储与读取、并行计算：Dask库简述</a></li><li><a href="https://juejin.im/post/5c1feeaf5188257f9242b65c" target="_blank" rel="noopener">译|在 Python 中，如何运用 Dask 数据进行并行数据分析</a></li></ul><h3 id="使用dask加速dataframe"><a href="#使用dask加速dataframe" class="headerlink" title="使用dask加速dataframe"></a>使用dask加速dataframe</h3><h4 id="低速方法-6"><a href="#低速方法-6" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df=pd.DataFrame(np.random.randint(<span class="number">0</span>,<span class="number">6</span>,size=(<span class="number">100000000</span>,<span class="number">5</span>)),</span><br><span class="line">               columns=list(<span class="string">'abcde'</span>))</span><br><span class="line">%time df.groupby(<span class="string">'a'</span>).mean()</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 4.13 s, sys: 3.72 s, total: 7.85 sWall time: 8.03 s</code></pre><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>b</th><th>c</th><th>d</th><th>e</th></tr><tr><th>a</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>0</th><td>2.500325</td><td>2.499488</td><td>2.500634</td><td>2.500346</td></tr><tr><th>1</th><td>2.499725</td><td>2.499342</td><td>2.499707</td><td>2.500463</td></tr><tr><th>2</th><td>2.499565</td><td>2.499577</td><td>2.500171</td><td>2.499852</td></tr><tr><th>3</th><td>2.499790</td><td>2.499861</td><td>2.499205</td><td>2.500443</td></tr><tr><th>4</th><td>2.500874</td><td>2.499877</td><td>2.499486</td><td>2.499790</td></tr><tr><th>5</th><td>2.499937</td><td>2.499493</td><td>2.500126</td><td>2.500856</td></tr></tbody></table><br></div><h4 id="高速方法-dask"><a href="#高速方法-dask" class="headerlink" title="高速方法-dask"></a>高速方法-dask</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line">df_dask=dd.from_pandas(df,npartitions=<span class="number">40</span>)</span><br><span class="line">%time df_dask.groupby(<span class="string">'a'</span>).mean().compute()</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 12 s, sys: 6.58 s, total: 18.6 sWall time: 8.44 s</code></pre><div><br><style scoped></style><br><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>b</th><th>c</th><th>d</th><th>e</th></tr><tr><th>a</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>0</th><td>2.500325</td><td>2.499488</td><td>2.500634</td><td>2.500346</td></tr><tr><th>1</th><td>2.499725</td><td>2.499342</td><td>2.499707</td><td>2.500463</td></tr><tr><th>2</th><td>2.499565</td><td>2.499577</td><td>2.500171</td><td>2.499852</td></tr><tr><th>3</th><td>2.499790</td><td>2.499861</td><td>2.499205</td><td>2.500443</td></tr><tr><th>4</th><td>2.500874</td><td>2.499877</td><td>2.499486</td><td>2.499790</td></tr><tr><th>5</th><td>2.499937</td><td>2.499493</td><td>2.500126</td><td>2.500856</td></tr></tbody></table><br></div><h3 id="使用dask-delayed进行加速"><a href="#使用dask-delayed进行加速" class="headerlink" title="使用dask.delayed进行加速"></a>使用dask.delayed进行加速</h3><h4 id="低速方法-7"><a href="#低速方法-7" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">muchjob</span><span class="params">(x)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">result = [muchjob(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">result</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 22 ms, sys: 15.4 ms, total: 37.4 msWall time: 25 s[0, 1, 4, 9, 16]</code></pre><h4 id="高速方法-4"><a href="#高速方法-4" class="headerlink" title="高速方法"></a>高速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">from</span> dask <span class="keyword">import</span> delayed,compute</span><br><span class="line"><span class="keyword">from</span> dask <span class="keyword">import</span> threaded,multiprocessing</span><br><span class="line">values=[delayed(muchjob)(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">result=compute(*values,schediler=<span class="string">'multiprocessing'</span>)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 10.2 ms, sys: 2.93 ms, total: 13.1 msWall time: 5.01 s</code></pre><h2 id="应用多线程多进程加速"><a href="#应用多线程多进程加速" class="headerlink" title="应用多线程多进程加速"></a>应用多线程多进程加速</h2><p>总结：</p><ul><li>针对<code>IO密集型</code>任务：应用<code>多线程</code>加速</li><li>针对<code>CPU密集型</code>任务：应用<code>多进程</code>加速</li></ul><h3 id="应用多线程加速IO密集型任务"><a href="#应用多线程加速IO密集型任务" class="headerlink" title="应用多线程加速IO密集型任务"></a>应用多线程加速IO密集型任务</h3><h4 id="低速方法-串行"><a href="#低速方法-串行" class="headerlink" title="低速方法-串行"></a>低速方法-串行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(str(i)+ <span class="string">'.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s=(<span class="string">'hello %d'</span> %i)*<span class="number">10000000</span></span><br><span class="line">        f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 串行任务</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    writefile(i)</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 441 ms, sys: 971 ms, total: 1.41 sWall time: 1.4 s</code></pre><h4 id="高速方法-多线程"><a href="#高速方法-多线程" class="headerlink" title="高速方法-多线程"></a>高速方法-多线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(str(i)+ <span class="string">'.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s=(<span class="string">'hello %d'</span> %i)*<span class="number">10000000</span></span><br><span class="line">        f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程任务</span></span><br><span class="line">thread_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t=threading.Thread(target=writefile,args=(i,))</span><br><span class="line">    <span class="comment"># 设置守护线程</span></span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    thread_list.append(t)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">    <span class="comment"># 等待子线程结束</span></span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><pre><code>CPU times: user 527 ms, sys: 1.51 s, total: 2.04 sWall time: 3.97 s</code></pre><h3 id="应用多进程加速CPU密集型任务"><a href="#应用多进程加速CPU密集型任务" class="headerlink" title="应用多进程加速CPU密集型任务"></a>应用多进程加速CPU密集型任务</h3><h4 id="低速方法-8"><a href="#低速方法-8" class="headerlink" title="低速方法"></a>低速方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">muchjob</span><span class="params">(x)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 串行任务</span></span><br><span class="line">ans=[muchjob(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 4, 9, 16, 25, 36, 49]CPU times: user 38.3 ms, sys: 20.4 ms, total: 58.8 msWall time: 40 s</code></pre><h4 id="高速方法-多进程"><a href="#高速方法-多进程" class="headerlink" title="高速方法-多进程"></a>高速方法-多进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">data=range(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">muchjob</span><span class="params">(x)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> (x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程任务</span></span><br><span class="line">pool=multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">result=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    result.append(pool.apply_async(muchjob,(i,)))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line">ans=[res.get() <span class="keyword">for</span> res <span class="keyword">in</span> result]</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 4, 9, 16, 25, 36, 49]CPU times: user 18.5 ms, sys: 523 ms, total: 541 msWall time: 10.8 s</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTQzNTU2OA==&amp;mid=2247484946&amp;idx=1&amp;sn=b569829e5fef81be667847146ce65dfe&amp;chksm=fd676b4dca10e25bcaa96e3cf1244aaf290e195215136b5d34a6be0a7d1b951c1b7601ae9696&amp;token=647482703&amp;lang=zh_CN#rd" target="_blank" rel="noopener">24式加速你的Python</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决conda的依赖冲突问题</title>
      <link href="/posts/52735.html"/>
      <url>/posts/52735.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文记录了在conda升级到<code>4.7.10</code>版本后出现的<code>Solving environment: failed</code>问题以及解决方案。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在将实验室的conda版本升级到<code>4.7.10</code>之后就一直出现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collecting package metadata (current_repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed with current_repodata.json, will retry with next repodata <span class="built_in">source</span>.</span><br><span class="line">Collecting package metadata (repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed</span><br><span class="line">Initial quick solve with frozen env failed.  Unfreezing env and trying again.</span><br><span class="line">Solving environment: failed</span><br></pre></td></tr></table></figure><p></p><p>在网上找了很多，发现有很多和我相同的情况，比如<code>Stack Overflow</code>上的<a href="https://stackoverflow.com/questions/57117855/conda-4-7-7-4-6-collecting-package-metadata-current-repodata-json-chann" target="_blank" rel="noopener">这个问题</a>、<code>conda</code>中的这个<a href="https://github.com/conda/conda/issues/8967" target="_blank" rel="noopener">issue</a>，大部分的解决方案都是降低<code>conda</code>的版本，但是使用这种方法并没有解决我的问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="降低conda"><a href="#降低conda" class="headerlink" title="降低conda"></a>降低conda</h3><p>这个方法被证明在我的问题上是错误的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">conda update conda -c bioconda</span><br><span class="line">Collecting package metadata (current_repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed with current_repodata.json, will retry with next repodata <span class="built_in">source</span>.</span><br><span class="line">Collecting package metadata (repodata.json): <span class="keyword">done</span></span><br><span class="line">Solving environment: failed</span><br><span class="line">Initial quick solve with frozen env failed.  Unfreezing env and trying again.</span><br><span class="line">Solving environment: failed</span><br><span class="line"></span><br><span class="line">UnsatisfiableError: The following specifications were found to be incompatible with each other:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Package libssh2 conflicts <span class="keyword">for</span>:</span><br><span class="line">r=3.5.1 -&gt; mro-basics=3.5.1 -&gt; r-revoioq[version=<span class="string">'&gt;=10.0.0,&lt;10.0.1.0a0,&gt;=8.0.9,&lt;8.0.10.0a0'</span>] -&gt; r-runit[version=<span class="string">'&gt;=0.4.26'</span>] -&gt; mro-base[version=<span class="string">'3.4.3.*,3.5.0.*,3.5.1.*'</span>] -&gt; mro-base_impl==3.5.1=h9a62091_0 -&gt; curl[version=<span class="string">'&gt;=7.58.0'</span>] -&gt; libcurl==7.61.1=hbdb9355_2 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">jupyterhub -&gt; pycurl -&gt; libcurl[version=<span class="string">'&gt;=7.60.0,&lt;8.0a0,&gt;=7.63.0,&lt;8.0a0,&gt;=7.64.1,&lt;8.0a0'</span>] -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">git -&gt; curl[version=<span class="string">'&gt;=7.44.0,&lt;8,&gt;=7.59.0,&lt;8.0a0,&gt;=7.64.0,&lt;8.0a0'</span>] -&gt; libcurl==7.65.2=h20c2e04_0 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">rpy2 -&gt; r-dbplyr -&gt; r-dplyr[version=<span class="string">'&gt;=0.5.0.9004,&gt;=0.7.4,&gt;=0.8.0'</span>] -&gt; r-tidyselect[version=<span class="string">'&gt;=0.2.3,&gt;=0.2.5'</span>] -&gt; r-purrr -&gt; r-tibble -&gt; r-pillar[version=<span class="string">'&gt;=1.1.0,&gt;=1.3.1'</span>] -&gt; r-utf8[version=<span class="string">'&gt;=1.1.0,&gt;=1.1.3'</span>] -&gt; mro-base[version=<span class="string">'&gt;=3.4.3,&lt;3.5.0a0,&gt;=3.5.0,&lt;3.5.1.0a0,&gt;=3.5.1,&lt;3.5.2.0a0'</span>] -&gt; mro-base_impl==3.5.1=h9a62091_0 -&gt; curl[version=<span class="string">'&gt;=7.58.0'</span>] -&gt; libcurl==7.61.1=h20c2e04_0 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br><span class="line">rpy2 -&gt; r-dbplyr -&gt; r-dplyr[version=<span class="string">'&gt;=0.5.0.9004,&gt;=0.7.4,&gt;=0.8.0'</span>] -&gt; r-tidyselect[version=<span class="string">'&gt;=0.2.3,&gt;=0.2.5'</span>] -&gt; r-purrr -&gt; r-tibble -&gt; r-pillar[version=<span class="string">'&gt;=1.1.0,&gt;=1.3.1'</span>] -&gt; r-utf8[version=<span class="string">'&gt;=1.1.0,&gt;=1.1.3'</span>] -&gt; mro-base[version=<span class="string">'&gt;=3.4.3,&lt;3.5.0a0,&gt;=3.5.0,&lt;3.5.1.0a0,&gt;=3.5.1,&lt;3.5.2.0a0'</span>] -&gt; mro-base_impl==3.5.1=h9a62091_0 -&gt; curl[version=<span class="string">'&gt;=7.58.0'</span>] -&gt; libcurl==7.65.2=h20c2e04_0 -&gt; libssh2[version=<span class="string">'&gt;=1.8.0,&lt;1.9.0a0,&gt;=1.8.0,&lt;2.0a0,&gt;=1.8.2,&lt;1.9.0a0'</span>]</span><br></pre></td></tr></table></figure><p></p><p>虽然我发现使用不同的<code>channels</code>可以得到不同的依赖问题，给我了一种使用某个<code>channel</code>可以这个问题的错觉，但在尝试了诸如<code>bioconda</code>、<code>conda-canary</code>和<code>conda-forge</code>等几大常用的<code>channels</code>之后放弃了这种方法。</p><hr><h3 id="Unfreezing-env"><a href="#Unfreezing-env" class="headerlink" title="Unfreezing env"></a>Unfreezing env</h3><p>按照上面出现的错误提示：<code>Initial quick solve with frozen env failed. Unfreezing env and trying again.</code>，之前没见过这个<code>frozen env</code>，然后我就查找了<a href="https://github.com/conda/conda/issues/4864" target="_blank" rel="noopener">相关资料</a>：</p><blockquote><p>I have a new feature in mind for conda env: The ability to (temporarily) canonically disallow changing installed packages in an environment. The main use case I have in mind is when working in a shared user account that gets accessed by different people of potentially strongly varying degrees of conda-fu. The main goal is to avoid that people accidentally break background processing tasks because messing with supposed to be stable python anaconda environments.</p></blockquote><p>上面说可以使用如下命令进行<code>freeze</code>和<code>unfreeze env</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env freeze [name_of_environment]</span><br><span class="line">conda env unfreeze [name_of_environment]</span><br></pre></td></tr></table></figure><p></p><p>但是实际操作：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: conda-env [-h] &#123;create,<span class="built_in">export</span>,list,remove,update&#125; ...</span><br><span class="line">conda-env: error: invalid choice: <span class="string">'freeze'</span> (choose from <span class="string">'create'</span>, <span class="string">'export'</span>, <span class="string">'list'</span>, <span class="string">'remove'</span>, <span class="string">'update'</span>)</span><br></pre></td></tr></table></figure><p></p><p>遂作罢。</p><hr><h3 id="升级anaconda"><a href="#升级anaconda" class="headerlink" title="升级anaconda"></a>升级anaconda</h3><p>这个方法是<strong>偶然</strong>的方法，本来都准备将所有有冲突的包卸载掉进行重新安装，但是想着反正都要尝试，那就试试这个吧，结果没想到一下子<strong>成功</strong>了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure><p></p><p>虽然问题是解决了，但是<strong>想知道是怎么成功的</strong>，<strong>为什么需要升级anaconda？</strong>、<strong>升级conda和升级anaconda的区别是什么？</strong></p><p><a href="https://stackoverflow.com/questions/30034840/what-are-the-differences-between-conda-and-anaconda" target="_blank" rel="noopener">简单的解释</a>：</p><blockquote><p><code>conda</code> is the package manager. <code>Anaconda</code> is a set of about a hundred packages including <code>conda</code>, <code>numpy</code>, <code>scipy</code>, <code>ipython notebook</code>, and so on.</p></blockquote><p><a href="https://stackoverflow.com/questions/45421163/anaconda-vs-miniconda/45421527#45421527" target="_blank" rel="noopener">更官方的解释</a>：</p><blockquote><p>Note that <code>Conda</code> is the <strong>package manager</strong> (e.g. conda list displays all installed packages in the environment), whereas <code>Anaconda</code> and <code>Miniconda</code> are <strong>distributions</strong>. A <strong>software distribution</strong> is a collection of <code>packages</code>, <code>pre-built</code> and <code>pre-configured</code>, that can be installed and used on a system. A <strong>package manager</strong> is a <code>tool</code> that automates the process of <code>installing</code>, <code>updating</code>, and <code>removing</code> packages.</p></blockquote><p>上述两个说法很好地解释了conda和anaconda的区别，但是至于<strong>为什么需要升级anaconda？</strong>还没有想到或者找到比较合理的解释，先留个坑吧。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装R出现的问题汇总</title>
      <link href="/posts/27971.html"/>
      <url>/posts/27971.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了在<code>Linux(centos)</code>下从<strong>源码</strong>安装<code>R</code>以及安装<code>R package</code>出现的一些问题。</p></div><a id="more"></a><h2 id="–with-readline-yes"><a href="#–with-readline-yes" class="headerlink" title="–with-readline=yes"></a>–with-readline=yes</h2><p><strong>错误表现</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: --with-readline=yes (default) and headers/libs are not available</span><br></pre></td></tr></table></figure><p></p><p>在网上找了很多关于这个问题的解决方法，主要包括：</p><ul><li><code>--with-readline=no</code>：这个方法是最傻的办法，使用之后R代码可能不能补全以及鼠标不能左右移动，极大了降低了开发速度</li><li><code>yum install readline-devel</code>：因为我的系统是centos，所以很多都说需要这样安装一下就可以了，但是这并不能解决我的问题，系统提示我已经安装了这个package并且已经是最新版本了。</li></ul><p><strong>我的解决办法</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对已经安装了readline以及readline-devel</span></span><br><span class="line"><span class="comment"># 在config.site文件中指定CPPFLAGS、LDFLAGS</span></span><br><span class="line"><span class="comment"># 这两个目录包括了readline的相关文件</span></span><br><span class="line">CPPFLAGS=<span class="string">'-I/usr/include'</span></span><br><span class="line">LDFLAGS=<span class="string">'-L/usr/lib64'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在configure中加上LDFLAGS="-lncurses"接口</span></span><br><span class="line">./configure --prefix=`<span class="built_in">pwd</span>` --with-x=no --<span class="built_in">enable</span>-R-shlib=yes LDFLAGS=<span class="string">"-lncurses"</span></span><br></pre></td></tr></table></figure><p></p><p>关于<code>CPPFLAGS</code>、<code>LDFLAGS</code>可以查阅<a href="http://showteeth.tech/posts/62231.html">这篇文章</a>.</p><hr><h2 id="conda中R找不到zlib"><a href="#conda中R找不到zlib" class="headerlink" title="conda中R找不到zlib"></a>conda中R找不到zlib</h2><p>在安装<code>Rhdf5lib</code> package出现如下问题：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: either specify a valid zlib installation with --with-zlib=DIR or <span class="built_in">disable</span> zlib usage with --without-zlib</span><br></pre></td></tr></table></figure><p></p><p>和前面的<code>readline</code>相同，都是已经安装了相应的库，但仍然提示找不到，不过这个好像是<code>conda</code>中<code>R</code>的一个普遍问题：<a href="https://github.com/grimbough/Rhdf5lib/issues/21" target="_blank" rel="noopener">issue</a></p><p><strong>我的解决方法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 治标不治本，只能解决这次安装的需求</span></span><br><span class="line"><span class="comment"># step 1：下载源码文件</span></span><br><span class="line">wget https://bioconductor.org/packages/release/bioc/src/contrib/Rhdf5lib_1.6.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2：指定LDFLAGS</span></span><br><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-L/home/softwares/anaconda3/envs/r351/lib/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3：在命令行下安装</span></span><br><span class="line">/home/softwares/anaconda3/envs/r351/bin/R CMD INSTALL  Rhdf5lib_1.6.0.tar.gz</span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装软件报错：version ZLIB_1.2.9 not found</title>
      <link href="/posts/741.html"/>
      <url>/posts/741.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了由<code>/lib64/libz.so.1: version &#39;ZLIB_1.2.9&#39; not found</code>问题导致<code>Rstudio</code>中报错<code>Error in RStudioGD()</code>的解决方法。这里还给出了诸如<code>/lib64/libz.so.1: version &#39;ZLIB_1.2.9&#39; not found</code>问题的<strong>两种解决办法</strong>：在<strong>有<code>root</code>权限的情况</strong>下直接<strong>查找-替换</strong>对应的动态链接库文件即可，如果<strong>没有<code>root</code>权限</strong>可以<strong>直接修改动态链接库的搜索地址(<code>~/.bashrc</code>中的<code>LD_LIBRARY_PATH</code>)</strong>，后一种解决方法更为通用。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用<code>rstudio server</code>的时候忽然出现如下报错，并且<code>R</code>不能继续画图(R的优势所在，对我而言)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> RStudioGD() : </span><br><span class="line">  Shadow graphics device error: r error 4 (R code execution error)</span><br><span class="line">In addition: There were 50 or more warnings (use warnings() to see the first 50)</span><br></pre></td></tr></table></figure><p></p><p>在网上查了很多资料，大部分都说需要重装<code>R</code>语言，但是我觉得很不可思议啊，我啥也没做，为啥会需要重装R呢，这不科学，所以我还是先按照提示的信息使用<code>warnings()</code>查看了一下报错信息，前几个报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1: In grDevices:::png(<span class="string">"/tmp/Rtmp1WZiNp/1150e349a3c44bcfbf9fd2adc0969720.png"</span>,  ... :</span><br><span class="line">  unable to load shared object <span class="string">'/home/softwares/anaconda3/envs/r351/lib/R/library/grDevices/libs//cairo.so'</span>:</span><br><span class="line">  /lib64/libz.so.1: version `ZLIB_1.2.9<span class="string">' not found (required by /home/softwares/anaconda3/envs/r351/lib/R/library/grDevices/libs//../../../../libpng16.so.16)</span></span><br></pre></td></tr></table></figure><p>看到这个拨错信息我先松了一口气，<code>/lib64/libz.so.1: version &#39;ZLIB_1.2.9&#39; not found</code>这个错误不是常见的错误嘛，可能是这个导致的。</p><hr><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>报错提示表明在<code>/lib64/libz.so.1</code>中缺少<code>ZLIB_1.2.9</code>或更高版本，具体包含哪些版本可以使用如下命令查看：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libz.so.1 |grep <span class="string">"ZLIB*"</span></span><br><span class="line">  ZLIB_1.2.0</span><br><span class="line">  ZLIB_1.2.0.2</span><br><span class="line">  ZLIB_1.2.0.8</span><br><span class="line">  ZLIB_1.2.2</span><br><span class="line">  ZLIB_1.2.2.3</span><br><span class="line">  ZLIB_1.2.2.4</span><br><span class="line">  ZLIB_1.2.3.3</span><br><span class="line">  ZLIB_1.2.3.4</span><br><span class="line">  ZLIB_1.2.3.5</span><br><span class="line">  ZLIB_1.2.5.1</span><br><span class="line">  ZLIB_1.2.5.2</span><br></pre></td></tr></table></figure><p></p><p>通过输出结果发现缺少是没有相应的版本。</p><p>解决这个问题的方法非常简单，总的来说就是查找和替换，使用带有<code>ZLIB_1.2.9</code>或更高版本替换<code>/lib64/libz.so.1</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找</span></span><br><span class="line">find / -name <span class="string">"libz.so.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认其中的某一个libz.so.1含有ZLIB_1.2.9</span></span><br><span class="line">strings /home/softwares/anaconda3/lib/libz.so.1 |grep <span class="string">"ZLIB*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">rm /usr/lib64/libz.so.1</span><br><span class="line"><span class="comment"># 也可以使用ln -s来创建软连接</span></span><br><span class="line">cp /home/softwares/anaconda3/lib/libz.so.1 /usr/lib64/</span><br></pre></td></tr></table></figure><p></p><p>在解决这个问题之后，发现再次使用<code>R</code>，之前出现的问题也再没有出现，所以说<strong>还是要提前查看报错信息</strong>，<strong>不要一股脑地相信搜到的解决方案</strong>，对我的这个问题，即使重装R(很麻烦)也是不会得到解决的！</p><hr><h2 id="没有root权限"><a href="#没有root权限" class="headerlink" title="没有root权限"></a>没有root权限</h2><p>上面的解决办法是在<strong>有<code>root</code>权限下的操作</strong>，但<strong>大部分情况下使用集群都是没有<code>root</code>权限的</strong>，这里记录一下<strong>没有<code>root</code>权限如何解决这个问题</strong>，具体的做法其实就是参考<a href="http://showteeth.tech/posts/10801.html">Linux系列之添加动态链接库地址</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题表现</span></span><br><span class="line">  <span class="comment"># ./STAR: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by ./STAR)</span></span><br><span class="line">  <span class="comment"># ./STAR: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.8' not found (required by ./STAR)</span></span><br><span class="line">  <span class="comment"># ./STAR: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.26' not found (required by ./STAR)</span></span><br><span class="line">  <span class="comment"># ./STAR: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.18' not found (required by ./STAR)</span></span><br><span class="line">  <span class="comment">#./STAR: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by ./STAR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法</span></span><br><span class="line"><span class="comment">## 步骤一：在自己目录建立文件夹</span></span><br><span class="line">mkdir lib</span><br><span class="line"><span class="comment">## 步骤二：和有root权限相同：查找合适的动态库文件</span></span><br><span class="line"><span class="comment">## 步骤三：将合适的动态库文件移动到自己建立的文件夹下</span></span><br><span class="line"><span class="comment">## 步骤四：修改动态库的查找路径实现覆盖</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment">### 添加如下行进行覆盖老版本的动态链接库文件</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/your/path/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment">### 重新测试命令就可以成功</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在管理实验室集群过程中经常遇到这个问题，在安装一些软件或者更新一些系统文件的时候某些包含低版本函数的共享库(<code>so</code>后缀的文件)会自动替换之前设置好的包含高版本函数的共享库，比较常见的除了这里出现的<code>ZLIB_1.2.9</code>还有<code>GLIBCXX_3.4.15</code>等，所有这些问题的解决方法都是和上述类似的，<strong>查找-替换</strong>或者<strong>直接修改动态链接库的搜索地址(<code>LD_LIBRARY_PATH</code>)</strong>。</p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之itertools-Python内置迭代器模块</title>
      <link href="/posts/49907.html"/>
      <url>/posts/49907.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Python中的迭代器相关的库-<code>itertools</code>；主要学习了三类迭代器：<strong>无线迭代器</strong>(<code>count</code>、<code>cycle</code>、<code>repeat</code>)、<strong>有限迭代器</strong>(<code>accumulate</code>、<code>chain</code>、<code>compress</code>、<code>dropwhile</code>、<code>takewhile</code>、<code>filterfalse</code>、<code>groupby</code>、<code>islice</code>、<code>starmap</code>、<code>tee</code>、<code>zip_longest</code>)以及<strong>组合迭代器</strong>(<code>product</code>、<code>permutation</code>、<code>combination</code>)。</p></div><a id="more"></a><h2 id="itertools简介"><a href="#itertools简介" class="headerlink" title="itertools简介"></a>itertools简介</h2><p>迭代器的特点是：<strong>惰性求值（Lazy evaluation）</strong>，即只有当迭代至某个值时，它才会被计算，这个特点使得<strong>迭代器特别适合于遍历大文件或无限集合等</strong>，因为我们<strong>不用一次性将它们存储在内存中</strong>。</p><p>Python 内置的 <code>itertools</code> 模块包含了<strong>一系列用来产生不同类型迭代器的函数或类</strong>，这些函数的<strong>返回都是一个迭代器</strong>，我们可以通过 <code>for</code> 循环来遍历取值，也可以使用 <code>next()</code> 来取值。</p><p><code>itertools</code> 模块提供的迭代器函数有以下几种类型：</p><p><strong>无限迭代器</strong>：<strong>生成一个无限序列</strong>，比如自然数序列 1, 2, 3, 4, …；<br><strong>有限迭代器</strong>：<strong>接收一个或多个序列</strong>（sequence）作为参数，进行<strong>组合、分组和过滤</strong>等；<br><strong>组合生成器</strong>：序列的<strong>排列、组合，求序列的笛卡儿积</strong>等.</p><hr><h2 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a>无限迭代器</h2><p>itertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：</p><table><tr><th width="10%">迭代器</th><th width="10%">参数</th><th width="30%">说明</th><th width="30%">结果</th><th width="20%">示例</th></tr><tr><td>count()</td><td>start, [step]</td><td>接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1</td><td>start, start+step, start+2*step, …</td><td>count(10) --&gt; 10 11 12 13 14...</td></tr><tr><td>cycle()</td><td>p</td><td>接收一个参数，对该参数进行单个字符的拆分之后循环输出</td><td>p0, p1, … plast, p0, p1, …</td><td>cycle('ABCD') --&gt; A B C D A B CD ...</td></tr><tr><td>repeat()</td><td>elem [,n]</td><td>接收两个参数，一个是用于重复的对象，另一个是重复的次数</td><td>elem, elem, elem, … endlessly or up to n times</td><td>repeat(10, 3) --&gt; 10 10 10</td></tr></table><h3 id="count-等差数列"><a href="#count-等差数列" class="headerlink" title="count-等差数列"></a>count-等差数列</h3><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment"># 创建一个从0开始，步长为1的无限序列</span></span><br><span class="line">nums=itertools.count()</span><br><span class="line"><span class="comment"># 使用循环获取迭代器中的元素，然后输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> i &gt;<span class="number">20</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建从10开始，步长为2的无限序列</span></span><br><span class="line">nums_1=itertools.count(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums_1:</span><br><span class="line">    <span class="keyword">if</span> i &gt;<span class="number">20</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数形式的等差数列</span></span><br><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line"><span class="comment"># 得到分数形式的start和step</span></span><br><span class="line">start = fractions.Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">step = fractions.Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(itertools.count(start, step), [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(*i))</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,</span><br><span class="line"></span><br><span class="line">10,12,14,16,18,20,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数形式的输出结果</span></span><br><span class="line">1/3: a</span><br><span class="line">2/3: b</span><br><span class="line">1: c</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="cycle-循环"><a href="#cycle-循环" class="headerlink" title="cycle-循环"></a>cycle-循环</h3><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="comment"># cycle('ABCD') --&gt; A B C D A B C D A B C D ...</span></span><br><span class="line">    saved = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> element</span><br><span class="line">        saved.append(element)</span><br><span class="line">    <span class="keyword">while</span> saved:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> saved:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串也是可迭代对象</span></span><br><span class="line"><span class="comment"># 创建一个循环输出A、B、C的迭代器</span></span><br><span class="line">cycle_s=itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用for循环的方式输出</span></span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle_s:</span><br><span class="line">    flag+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag &gt;<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个循环暑促胡1，2，3的迭代器</span></span><br><span class="line">cycle_li=itertools.cycle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用for循环的方式输出</span></span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle_li:</span><br><span class="line">    flag+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag &gt;<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A,B,C,A,B,C,A,B,C,A,</span><br><span class="line"></span><br><span class="line">1,2,3,1,2,3,1,2,3,1,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="repeat-重复"><a href="#repeat-重复" class="headerlink" title="repeat-重复"></a>repeat-重复</h3><div class="note info"><p><strong>重复和前面的循环的区别在于</strong>：循环是针对<strong>可迭代对象的每个元素</strong>进行的循环输出，而重复则是<strong>对整个可迭代对象</strong>的重复输出。</p></div><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span><span class="params">(object, times=None)</span>:</span></span><br><span class="line">    <span class="comment"># repeat(10, 3) --&gt; 10 10 10</span></span><br><span class="line">    <span class="keyword">if</span> times <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> object</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(times):</span><br><span class="line">            <span class="keyword">yield</span> object</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个对hello world整个字符进行重复3次的迭代器</span></span><br><span class="line">repeat_s=itertools.repeat(<span class="string">"hello world"</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 使用for循环输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> repeat_s:</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表进行重复</span></span><br><span class="line">repeat_li=itertools.repeat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 使用for循环输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> repeat_li:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world,hello world,hello world,</span><br><span class="line"></span><br><span class="line">[1, 2, 3],[1, 2, 3],[1, 2, 3],</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="有限迭代器"><a href="#有限迭代器" class="headerlink" title="有限迭代器"></a>有限迭代器</h2><p>itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：</p><table><tr><th width="20%">迭代器</th><th width="10%">参数</th><th width="30%">说明</th><th width="20%">结果</th><th width="20%">示例</th></tr><tr><td>accumulate()</td><td>p [,func]</td><td>接收两个参数，第一个参数为迭代器对象，第二个参数为对迭代器对象进行的累计操作，默认的操作方式是求和，也就是累计求和</td><td>p0, p0+p1, p0+p1+p2, …</td><td>accumulate([1,2,3,4,5]) --&gt; 1 3 610 15</td></tr><tr><td>chain()</td><td>p, q, …</td><td>接收多个可迭代对象作为参数，将它们连接起来迭代输出</td><td>p0, p1, … plast, q0, q1, …</td><td>chain('ABC', 'DEF') --&gt; A B C D EF</td></tr><tr><td>chain.from_iterable()</td><td>iterable</td><td></td><td>p0, p1, … plast, q0, q1, …</td><td>chain.from_iterable(['ABC','DEF']) --&gt; A B C D E F</td></tr><tr><td>compress()</td><td>data, selectors</td><td>接收两个参数，第一个为可迭代对象，第二个为选择列表，用于对可迭代对象中的元素进行筛选</td><td>(d[0] if s[0]), (d[1] if s[1]), …</td><td>compress('ABCDEF', [1,0,1,0,1,1])--&gt; A C E F</td></tr><tr><td>dropwhile()</td><td>pred, seq</td><td>接收两个参数，第一个参数为函数，用来对可迭代对象进行筛选，保留使函数第一次为false的所有后续元素；第二个参数为可迭代对象</td><td>seq[n], seq[n+1], starting when pred fails</td><td>dropwhile(lambda x: x&lt;5,[1,4,6,4,1]) --&gt; 6 4 1</td></tr><tr><td>takewhile()</td><td>pred, seq</td><td>接收两个参数，第一个参数为函数，用来对可迭代对象进行筛选，保留使函数第一次为false的之前元素；第二个参数为可迭代对象；与前面的dropwhile功能恰恰相反</td><td>seq[0], seq[1], until pred fails</td><td>takewhile(lambda x: x&amp;lt;5,[1,4,6,4,1]) --&amp;gt; 1 4</td></tr><tr><td>filterfalse()</td><td>pred, seq</td><td>接收两个参数，第一个参数为函数(可以为None)，用来对可迭代对象进行筛选，丢弃所有使函数为True的结果，注意与dropwhile区分；第二个参数为可迭代对象</td><td>elements of seq where pred(elem) is false</td><td>filterfalse(lambda x: x%2,range(10)) --&gt; 0 2 4 6 8</td></tr><tr><td>groupby()</td><td>iterable[, key]</td><td>接收两个参数，第一个参数为可迭代对象，第二个参数为分组函数，默认情况下将可迭代对象中连续的相同元素归为一组，注意必须是连续</td><td>sub-iterators grouped by value of key(v)</td><td></td></tr><tr><td>islice()</td><td>seq, [start,] stop [, step]</td><td>接收三个参数，至少提供一个参数，且如果只提供一个参数则该参数代表stop</td><td>elements from seq[start:stop:step]</td><td>islice('ABCDEFG', 2, None) --&gt; CD E F G</td></tr><tr><td>starmap()</td><td>func, seq</td><td>接收两个参数，第一个参数为函数，第二个参数为可迭代对象，将可迭代对象中的每个元素作为参数元组传递给函数执行</td><td>func(*seq[0]), func(*seq[1]), …</td><td>starmap(pow, [(2,5), (3,2),(10,3)]) --&gt; 32 9 1000</td></tr><tr><td>tee()</td><td>it, n</td><td>接收两个参数，第一个参数为可迭代对象，第二个参数为可迭代对象需要重复的次数</td><td>it1, it2, … itn splits one iterator into n</td><td></td></tr><tr><td>zip_longest()</td><td>p, q, …</td><td>接收多个迭代器参数以及一个fillvalue<br>参数，主要是用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组组成一个迭代器，并返回</td><td>(p[0], q[0]), (p[1], q[1]), …</td><td>zip_longest('ABCD', 'xy',fillvalue='-') --&gt; Ax By C- D-</td></tr></table><h3 id="accumulate-迭代器对象的累计操作"><a href="#accumulate-迭代器对象的累计操作" class="headerlink" title="accumulate-迭代器对象的累计操作"></a>accumulate-迭代器对象的累计操作</h3><p><code>accumulate</code>接收两个参数，第一个参数为<strong>迭代器对象</strong>，第二个参数为<strong>对迭代器对象进行的累计操作</strong>，<strong>默认的操作方式是求和</strong>，也就是累计求和。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add)</span>:</span></span><br><span class="line">    <span class="string">'Return running totals'</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        total = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">data = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 默认的累加操作</span></span><br><span class="line">accumulate_add=itertools.accumulate(data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> accumulate_add:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累积操作</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">accumulate_mul=itertools.accumulate(data,operator.mul)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> accumulate_mul:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 累积求和</span></span><br><span class="line">3,7,13,15,16,25,25,32,37,45,</span><br><span class="line"><span class="comment"># 累积求积</span></span><br><span class="line">3,12,72,144,144,1296,0,0,0,0,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="chain-串联多个序列"><a href="#chain-串联多个序列" class="headerlink" title="chain-串联多个序列"></a>chain-串联多个序列</h3><p><code>chain</code>接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回.</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个将多个序列串联起来的迭代器</span></span><br><span class="line">chain=itertools.chain([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'ABC'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用for循环输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,A,B,C,</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>用于chain的iterables事先并不知道</strong>，可以使用<code>chain.from_iterable()</code>来和创建<code>chain</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_iterables_to_chain</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.chain.from_iterable(make_iterables_to_chain()):</span><br><span class="line">    print(i, end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> a b c</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="compress-通过序列筛选"><a href="#compress-通过序列筛选" class="headerlink" title="compress-通过序列筛选"></a>compress-通过序列筛选</h3><p><code>compress</code> 可用于对可迭代对象进行筛选，当 <code>selectors</code> 的某个元素为 <code>true</code> 时，则保留 <code>data</code> 对应位置的元素，否则去除。</p><p><strong>函数原型</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(data, selectors)</span>:</span></span><br><span class="line">    <span class="comment"># compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</span></span><br><span class="line">    <span class="keyword">return</span> (d <span class="keyword">for</span> d, s <span class="keyword">in</span> izip(data, selectors) <span class="keyword">if</span> s)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表进行筛选</span></span><br><span class="line">compress_li=itertools.compress([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 使用for循环输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> compress_li:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字符串进行筛选</span></span><br><span class="line">compress_s=itertools.compress(<span class="string">'ABC'</span>,[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 使用for循环输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> compress_s:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将迭代器对象转化为list</span></span><br><span class="line">list(compress_s)</span><br><span class="line">  [<span class="string">'A'</span>, <span class="string">'C'</span>]</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,3,</span><br><span class="line"></span><br><span class="line">A,C,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="dropwhile-丢弃第一次false之前的内容"><a href="#dropwhile-丢弃第一次false之前的内容" class="headerlink" title="dropwhile-丢弃第一次false之前的内容"></a>dropwhile-丢弃第一次false之前的内容</h3><p><code>dropwhile</code>接收两个参数，其中第一个参数为<code>predicate</code>，第二个参数为迭代对象。对于 <code>iterable</code> 中的元素，<strong>如果 <code>predicate(item)</code> 为 true</strong>，则<strong>丢弃</strong>该元素，否则返回该项及所有后续项。需要特别注意的是：<strong>在条件为false之后的第一次, 返回迭代器中剩下来的项(不管剩下的项中是否还会使条件为true)</strong></p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropwhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</span></span><br><span class="line">    iterable = iter(iterable)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">      <span class="comment"># 遇到使条件不成立的立马退出循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 将后续的元素迭代输出</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用函数对迭代器进行筛选</span></span><br><span class="line">dropwhile=itertools.dropwhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">1</span>,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 使用for循环调用</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile:</span><br><span class="line">    print(i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropwhile_filter</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="comment"># 使用for循环调用</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile:</span><br><span class="line">    print(i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次false之后的内容，不管后续会不会出现true</span></span><br><span class="line">dropwhile_1=itertools.dropwhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile_1:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1,2,</span><br><span class="line"></span><br><span class="line">1,2,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使后续的2、1小于5，但是在6之后</span></span><br><span class="line"><span class="comment"># 所以也会输出</span></span><br><span class="line">6,2,1,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="takewhile-获取第一次false之前的内容"><a href="#takewhile-获取第一次false之前的内容" class="headerlink" title="takewhile-获取第一次false之前的内容"></a>takewhile-获取第一次false之前的内容</h3><p><code>takewhile</code>和<code>dropwhile</code>用法相似(功能恰恰相反)，都是接收两个参数，其中第一个参数为<code>predicate</code>，第二个参数为迭代对象。对于 <code>iterable</code> 中的元素，如果 <code>predicate(item)</code> 为 <code>true</code>，则<strong>保留</strong>该元素，只要 <code>predicate(item)</code> 为 <code>false</code>，则<strong>立即停止迭代</strong>。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="comment"># 不满足函数，则直接为停止循环</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一次false之前的内容</span></span><br><span class="line">takewhile=itertools.takewhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">1</span>,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> takewhile:</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一次false之前的内容，不管之后会不会继续有true的结果</span></span><br><span class="line">takewhile_1=itertools.takewhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> takewhile_1:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line"></span><br><span class="line">1,3,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="filterfalse-丢弃所有的true的内容"><a href="#filterfalse-丢弃所有的true的内容" class="headerlink" title="filterfalse-丢弃所有的true的内容"></a>filterfalse-丢弃所有的true的内容</h3><p><code>filterfalse</code> 接收两个参数，第一个参数为<code>predicate</code>，第二个参数为迭代对象。将迭代器中 p<code>redicate(item)</code> 为 <code>False</code> 的元素组成一个迭代器返回，<strong>将<mark>所有</mark>的function(item) 为 True 的元素过滤</strong>，<strong>如果predicate为None(这在dropwhile中是不允许的)，则输出所有的false结果，如0</strong>。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterfalse</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</span></span><br><span class="line">    <span class="keyword">if</span> predicate <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        predicate = bool</span><br><span class="line">    <span class="comment"># 这里是对所有的迭代器元素，和前面的dropwhile的不同</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和前面的dropwhile不同，过滤掉所有的使函数为True结果</span></span><br><span class="line"><span class="comment"># 而不是过滤掉dropwhile中第一次false之前的内容</span></span><br><span class="line">filterfalse=itertools.filterfalse(<span class="keyword">lambda</span> x: x &lt; <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> filterfalse:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filterfalse的函数还支持None</span></span><br><span class="line"><span class="comment"># dropwhile不支持</span></span><br><span class="line">filterfalse_1=itertools.filterfalse(<span class="keyword">None</span>, [<span class="number">0</span>, <span class="number">6</span>,<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> filterfalse_1:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6,</span><br><span class="line"></span><br><span class="line"><span class="comment"># predicate为None</span></span><br><span class="line">0,0,</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>filterfalse</code>和<code>dropwhile</code>的区别：</p><ul><li><code>dropwhile</code>是返回第一次false之后的所有结果，不管第一次false之后的内容含不含true的结果；而<code>filterfalse</code>是对所有的true的结果都进行过滤；</li><li><code>filterfalse</code>的predicate可以是None，而<code>dropwhile</code>不可以</li></ul></div><hr><h3 id="groupby-分组"><a href="#groupby-分组" class="headerlink" title="groupby-分组"></a>groupby-分组</h3><p><code>groupby</code>可以接收两个参数，<strong>第一个参数为迭代器</strong>，第二个参数为<strong>对迭代器进行分组的key</strong>，如果<strong>key不指定</strong>，则默认对 <code>iterable</code> 中的<strong>连续相同项进行分组</strong>，返回一个 <strong>(key, sub-iterator) 的迭代器</strong>。<mark>需要特别注意的是：不管是默认还是自定义key函数，作用的都是相邻的，如果相邻的在函数上的值相同才会归为一类，如果不相邻，即使在函数上值相同也不会归为一类。</mark></p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">groupby</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B</span></span><br><span class="line">    <span class="comment"># [list(g) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable, key=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x</span><br><span class="line">        self.keyfunc = key</span><br><span class="line">        self.it = iter(iterable)</span><br><span class="line">        self.tgtkey = self.currkey = self.currvalue = object()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.currkey == self.tgtkey:</span><br><span class="line">            self.currvalue = next(self.it)    <span class="comment"># Exit on StopIteration</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br><span class="line">        self.tgtkey = self.currkey</span><br><span class="line">        <span class="keyword">return</span> (self.currkey, self._grouper(self.tgtkey))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_grouper</span><span class="params">(self, tgtkey)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.currkey == tgtkey:</span><br><span class="line">            <span class="keyword">yield</span> self.currvalue</span><br><span class="line">            self.currvalue = next(self.it)    <span class="comment"># Exit on StopIteration</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认地，将相邻连续的作为一组</span></span><br><span class="line">groupby=itertools.groupby(<span class="string">'aaabbbaaccd'</span>)</span><br><span class="line"><span class="comment"># 循环输出</span></span><br><span class="line"><span class="comment"># 将子迭代器转化为list输出</span></span><br><span class="line"><span class="keyword">for</span> key,sub_iter <span class="keyword">in</span> groupby:</span><br><span class="line">    <span class="keyword">print</span> (key,<span class="string">":"</span>,list(sub_iter)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用函数进行分组</span></span><br><span class="line">data = [<span class="string">'a'</span>, <span class="string">'bb'</span>, <span class="string">'ccc'</span>, <span class="string">'dd'</span>, <span class="string">'eee'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="comment"># 这里使用元素的长度进行分组</span></span><br><span class="line"><span class="keyword">for</span> key, value_iter <span class="keyword">in</span> itertools.groupby(data, len):</span><br><span class="line">    print(key,<span class="string">":"</span>,list(value_iter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先对可迭代的序列对象进行排序</span></span><br><span class="line">data=sorted(data,key=len)</span><br><span class="line"><span class="keyword">for</span> key, value_iter <span class="keyword">in</span> itertools.groupby(data, len):</span><br><span class="line">    print(key,<span class="string">":"</span>,list(value_iter))</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line">b : [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line">a : [<span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line">c : [<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line">d : [<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的分组并不是正常的分组结果</span></span><br><span class="line"><span class="comment"># 原因是没有排序</span></span><br><span class="line">1 : [<span class="string">'a'</span>]</span><br><span class="line">2 : [<span class="string">'bb'</span>]</span><br><span class="line">3 : [<span class="string">'ccc'</span>]</span><br><span class="line">2 : [<span class="string">'dd'</span>]</span><br><span class="line">3 : [<span class="string">'eee'</span>]</span><br><span class="line">1 : [<span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先对可迭代对象进行排序后的输出结果</span></span><br><span class="line">1 : [<span class="string">'a'</span>, <span class="string">'f'</span>]</span><br><span class="line">2 : [<span class="string">'bb'</span>, <span class="string">'dd'</span>]</span><br><span class="line">3 : [<span class="string">'ccc'</span>, <span class="string">'eee'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="islice-切片操作"><a href="#islice-切片操作" class="headerlink" title="islice()-切片操作"></a>islice()-切片操作</h3><p>islice接收参数参数：start, stop, step；start默认为0, stop默认为系统最大输出, step默认为1</p><ul><li>如果只提供一个参数（必须要提供一个），那么该参数会被当成stop(和平常见到的不同)，如果是None则表示输出全部</li><li>如果提供两个参数，那么第一个是start，第二个是stop</li><li>如果提供三个参数，那么分别对应start、stop、step</li></ul><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islice</span><span class="params">(iterable, *args)</span>:</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2) --&gt; A B</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, 4) --&gt; C D</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, None) --&gt; C D E F G</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 0, None, 2) --&gt; A C E G</span></span><br><span class="line">    s = slice(*args)</span><br><span class="line">    start, stop, step = s.start <span class="keyword">or</span> <span class="number">0</span>, s.stop <span class="keyword">or</span> sys.maxsize, s.step <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    it = iter(range(start, stop, step))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume *iterable* up to the *start* position.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(start), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(iterable):</span><br><span class="line">            <span class="keyword">if</span> i == nexti:</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">                nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume to *stop*.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(i + <span class="number">1</span>, stop), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只提供一个参数，为stop</span></span><br><span class="line">islice=itertools.islice(<span class="string">"abcdef"</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供两个参数，依次为start、stop</span></span><br><span class="line">islice_1=itertools.islice(<span class="string">"abcdef"</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice_1:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供两个参数，其中一个为None</span></span><br><span class="line">islice_2=itertools.islice(<span class="string">"abcdef"</span>,<span class="number">2</span>,<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice_2:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 提供三个参数</span></span><br><span class="line">islice_3=itertools.islice(<span class="string">"abcdef"</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice_3:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只提供一个参数</span></span><br><span class="line">a,b,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供两个参数</span></span><br><span class="line">c,d,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供两个参数，其中一个为None</span></span><br><span class="line">c,d,e,f,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供三个参数</span></span><br><span class="line">c,e,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="starmap-将iter作为参数元组传给函数"><a href="#starmap-将iter作为参数元组传给函数" class="headerlink" title="starmap-将iter作为参数元组传给函数"></a>starmap-将iter作为参数元组传给函数</h3><p><code>starmap</code>接收两个参数，第一个参数为<code>function</code>，第二个参数为<code>iterable</code>；对迭代器 <code>iterable</code> 中的每个元素<strong>作为 <code>function</code> 的参数列表</strong>执行，即 <code>function(*item)</code>。需要注意的是：<strong>只有当 <code>iterable</code> 生成的项适用于这种调用函数的方式时，此函数才有效</strong>。</p><p>需要注意的是原来使用较多的<code>map</code>、<code>imap</code>函数已经单独成了<a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">内建的函数</a>，不包含在<code>itertools</code>库中。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">starmap</span><span class="params">(function, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</span></span><br><span class="line">    <span class="keyword">for</span> args <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> function(*args)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">values = [(<span class="number">0</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">7</span>), (<span class="number">3</span>, <span class="number">8</span>), (<span class="number">4</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment"># 将(0,5)作为参数传递给函数，这点与map函数不同</span></span><br><span class="line"><span class="comment"># 返回0、5、0*5的结果</span></span><br><span class="line">starmap=itertools.starmap(<span class="keyword">lambda</span> x,y:(x, y, x*y), values)</span><br><span class="line"><span class="comment"># 注意这里的starmap中的每个元素都是一个三元组</span></span><br><span class="line"><span class="comment"># 直接使用三个%d就可以得出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> starmap:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%d * %d = %d'</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用内建的函数</span></span><br><span class="line">starmap_1=itertools.starmap(pow, values)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> starmap_1:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 * 5 = 0</span><br><span class="line">1 * 6 = 6</span><br><span class="line">2 * 7 = 14</span><br><span class="line">3 * 8 = 24</span><br><span class="line">4 * 9 = 36</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内建函数</span></span><br><span class="line">0,1,128,6561,262144,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="tee-将一个迭代器复制为多个迭代器"><a href="#tee-将一个迭代器复制为多个迭代器" class="headerlink" title="tee-将一个迭代器复制为多个迭代器"></a>tee-将一个迭代器复制为多个迭代器</h3><p><code>tee</code>接收两个参数，第一个是<strong>可迭代对象</strong>，第二个是可迭代对象<strong>被复制的次数</strong>，<strong>默认是2</strong>。该函数的用处在于：<mark>迭代器是一次性的，用过就无效了，需要在程序中多次使用某个迭代器，就用<code>tee</code>复制。</mark>需要注意的是：<strong>在新的复制得到的迭代器被使用后，原始的迭代器就失效了</strong>。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tee</span><span class="params">(iterable, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    deques = [collections.deque() <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(mydeque)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mydeque:             <span class="comment"># when the local deque is empty</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    newval = next(it)   <span class="comment"># fetch a new value and</span></span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> deques:        <span class="comment"># load it to all the deques</span></span><br><span class="line">                    d.append(newval)</span><br><span class="line">            <span class="keyword">yield</span> mydeque.popleft()</span><br><span class="line">    <span class="keyword">return</span> tuple(gen(d) <span class="keyword">for</span> d <span class="keyword">in</span> deques)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字符串作为可迭代对象</span></span><br><span class="line">iter1, iter2 = itertools.tee(<span class="string">'abcde'</span>)</span><br><span class="line"><span class="comment"># 输出复制的可迭代对象内容</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(iter1,iter2):</span><br><span class="line">    <span class="keyword">print</span> (i,<span class="string">":"</span>,j,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新的复制得到的迭代器被使用后，原始的迭代器就失效了</span></span><br><span class="line"><span class="comment"># 不会有输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r:</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自行创建可迭代对象</span></span><br><span class="line">r = itertools.islice(itertools.count(), <span class="number">5</span>)</span><br><span class="line">i1, i2 = itertools.tee(r)</span><br><span class="line"><span class="comment"># 输出复制的可迭代对象的内容</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(i1,i2):</span><br><span class="line">    <span class="keyword">print</span> (i,<span class="string">":"</span>,j,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出内容：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a : a,b : b,c : c,d : d,e : e,</span><br><span class="line"></span><br><span class="line">0 : 0,1 : 1,2 : 2,3 : 3,4 : 4,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="zip-longest-整合可迭代对象对应位置元素"><a href="#zip-longest-整合可迭代对象对应位置元素" class="headerlink" title="zip_longest-整合可迭代对象对应位置元素"></a>zip_longest-整合可迭代对象对应位置元素</h3><p><code>zip_longest</code>接收多个迭代器参数以及一个<code>fillvalue</code>参数，主要是用于<strong>将多个可迭代对象对应位置的元素作为一个元组，将所有元组组成一个迭代器，并返回</strong>；与经常使用的<code>zip</code>以<strong>最短的迭代器对象为标准</strong>不同，这里的<code>zip_longest</code>以<strong>最长的迭代器对象为标准</strong>，其他不足的迭代器对象默认使用<code>None</code>不足，这个<code>None</code>可以通过<code>fillvalue</code>参数修改。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_longest</span><span class="params">(*args, fillvalue=None)</span>:</span></span><br><span class="line">    <span class="comment"># zip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-</span></span><br><span class="line">    iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> args]</span><br><span class="line">    num_active = len(iterators)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        values = []</span><br><span class="line">        <span class="keyword">for</span> i, it <span class="keyword">in</span> enumerate(iterators):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = next(it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                num_active -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                iterators[i] = repeat(fillvalue)</span><br><span class="line">                value = fillvalue</span><br><span class="line">            values.append(value)</span><br><span class="line">        <span class="keyword">yield</span> tuple(values)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用的zip函数以最短的迭代器为标准</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=<span class="string">'ab'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(a,b):</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment"># zip_longest以最长的迭代器为标准</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.zip_longest(a,b):</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定filtervalue</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.zip_longest(a,b,fillvalue=<span class="string">'_'</span>):</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip输出结果</span></span><br><span class="line">(1, <span class="string">'a'</span>)</span><br><span class="line">(2, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># zip_longest输出结果</span></span><br><span class="line">(1, <span class="string">'a'</span>)</span><br><span class="line">(2, <span class="string">'b'</span>)</span><br><span class="line">(3, None)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定filtervalue</span></span><br><span class="line">(1, <span class="string">'a'</span>)</span><br><span class="line">(2, <span class="string">'b'</span>)</span><br><span class="line">(3, <span class="string">'_'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="组合生成器"><a href="#组合生成器" class="headerlink" title="组合生成器"></a>组合生成器</h2><p>itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：</p><table><tr><th width="35%">迭代器</th><th width="10%">参数</th><th width="30%">说明</th><th width="25%">结果</th></tr><tr><td>product()</td><td>p, q, … [repeat=1]</td><td>接收多个可迭代对象以及一个repeat参数，用于指定重复生成序列的次数，主要作用是求多个可迭代对象的笛卡尔积</td><td>cartesian product, equivalent to a nested for-loop</td></tr><tr><td>permutations()</td><td>p[, r]</td><td>接收两个参数，第一个参数为迭代器对象，第二个参数为排列的序列长度，如果不指定序列长度，那么默认为可迭代对象的元素长度，具体的排列结果计算公式为：A(n,m)</td><td>r-length tuples, all possible orderings, no repeated elements</td></tr><tr><td>combinations()</td><td>p, r</td><td>和前面的permutations参数相同，但是这里的序列长度参数不可以省略，并且combinations输出的是组合，结果数目为C(n,m)</td><td>r-length tuples, in sorted order, no repeated elements</td></tr><tr><td>combinations_with_replacement()</td><td>p, r</td><td>在combinations的基础上增加重复元素的项，如(A,A)</td><td>r-length tuples, in sorted order, with repeated elements</td></tr><tr><td>product('ABCD', repeat=2)</td><td></td><td></td><td>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DCDD</td></tr><tr><td>permutations('ABCD', 2)</td><td></td><td></td><td>AB AC AD BA BC BD CA CB CD DA DB DC</td></tr><tr><td>combinations('ABCD', 2)</td><td></td><td></td><td>AB AC AD BC BD CD</td></tr><tr><td>combinations_with_replacement('ABCD',2)</td><td></td><td></td><td>AA AB AC AD BB BC BD CC CD DD</td></tr></table><h3 id="product-笛卡尔积"><a href="#product-笛卡尔积" class="headerlink" title="product-笛卡尔积"></a>product-笛卡尔积</h3><p><code>product</code> 接收多个可迭代对象以及一个<code>repeat</code>参数，用于<strong>指定重复生成序列的次数</strong>，主要作用是<strong>求多个可迭代对象的笛卡尔积，和嵌套的 for 循环等价</strong>。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy</span></span><br><span class="line">    <span class="comment"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    result = [[]]</span><br><span class="line">    <span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">        result = [x+[y] <span class="keyword">for</span> x <span class="keyword">in</span> result <span class="keyword">for</span> y <span class="keyword">in</span> pool]</span><br><span class="line">    <span class="keyword">for</span> prod <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">yield</span> tuple(prod)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product((<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">1</span>)):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定repeat参数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(0, 0, 0),(0, 0, 1),(0, 1, 0),(0, 1, 1),(1, 0, 0),(1, 0, 1),(1, 1, 0),(1, 1, 1),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定repeat参数</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>),(<span class="string">'A'</span>, <span class="string">'B'</span>),(<span class="string">'A'</span>, <span class="string">'C'</span>),(<span class="string">'B'</span>, <span class="string">'A'</span>),(<span class="string">'B'</span>, <span class="string">'B'</span>),(<span class="string">'B'</span>, <span class="string">'C'</span>),(<span class="string">'C'</span>, <span class="string">'A'</span>),(<span class="string">'C'</span>, <span class="string">'B'</span>),(<span class="string">'C'</span>, <span class="string">'C'</span>),</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="permutations-排列"><a href="#permutations-排列" class="headerlink" title="permutations-排列"></a>permutations-排列</h3><p><code>permutations</code>接收两个参数，第一个参数为<strong>迭代器对象</strong>，第二个参数为<strong>排列的序列长度</strong>，如果<strong>不指定序列长度，那么默认为可迭代对象的元素长度</strong>，具体的排列结果计算公式为：<code>A(n,m)</code></p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    <span class="comment"># permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span></span><br><span class="line">    <span class="comment"># permutations(range(3)) --&gt; 012 021 102 120 201 210</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(n))</span><br><span class="line">    cycles = list(range(n, n-r, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            cycles[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cycles[i] == <span class="number">0</span>:</span><br><span class="line">                indices[i:] = indices[i+<span class="number">1</span>:] + indices[i:i+<span class="number">1</span>]</span><br><span class="line">                cycles[i] = n - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = cycles[i]</span><br><span class="line">                indices[i], indices[-j] = indices[-j], indices[i]</span><br><span class="line">                <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># product</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> product(range(n), repeat=r):</span><br><span class="line">        <span class="keyword">if</span> len(set(indices)) == r:</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定长度，默认为3</span></span><br><span class="line"><span class="comment"># A(3,3)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">'ABC'</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定长度为2</span></span><br><span class="line"><span class="comment"># A(3,2)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">'ABC'</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不指定长度</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>),(<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>),(<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>),(<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>),(<span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>),(<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>),</span><br><span class="line"><span class="comment"># 指定长度为2</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>),(<span class="string">'A'</span>, <span class="string">'C'</span>),(<span class="string">'B'</span>, <span class="string">'A'</span>),(<span class="string">'B'</span>, <span class="string">'C'</span>),(<span class="string">'C'</span>, <span class="string">'A'</span>),(<span class="string">'C'</span>, <span class="string">'B'</span>),</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="combinations-组合"><a href="#combinations-组合" class="headerlink" title="combinations-组合"></a>combinations-组合</h3><p>和前面的<code>permutations</code><strong>参数</strong>相同，但是这里的<strong>序列长度参数不可以省略</strong>，并且<code>combinations</code>输出的是组合，结果数目为<code>C(n,m)</code>。</p><p><strong>函数原型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="comment"># combinations('ABCD', 2) --&gt; AB AC AD BC BD CD</span></span><br><span class="line">    <span class="comment"># combinations(range(4), 3) --&gt; 012 013 023 123</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(r))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != i + n - r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, r):</span><br><span class="line">            indices[j] = indices[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合permutations</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> permutations(range(n), r):</span><br><span class="line">        <span class="keyword">if</span> sorted(indices) == list(indices):</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出长度为3的组合</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations(<span class="string">'ABC'</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出长度为2的组合</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations(<span class="string">'ABC'</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出长度为3的组合</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度为2的组合</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>),(<span class="string">'A'</span>, <span class="string">'C'</span>),(<span class="string">'B'</span>, <span class="string">'C'</span>),</span><br></pre></td></tr></table></figure><p></p><p><code>combinations_with_replacement</code> 和 <code>combinations</code> 类似，但它生成的组合包含自身元素：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果中包含重复元素的项</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>),(<span class="string">'A'</span>, <span class="string">'B'</span>),(<span class="string">'A'</span>, <span class="string">'C'</span>),(<span class="string">'B'</span>, <span class="string">'B'</span>),(<span class="string">'B'</span>, <span class="string">'C'</span>),(<span class="string">'C'</span>, <span class="string">'C'</span>),</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://funhacks.net/2017/02/13/itertools/" target="_blank" rel="noopener">高效的 itertools 模块</a></li><li><a href="http://wklken.me/posts/2013/08/20/python-extra-itertools.html" target="_blank" rel="noopener">Python-进阶-itertools模块小结</a></li><li><a href="https://pymotw.com/3/itertools/index.html" target="_blank" rel="noopener">itertools — Iterator Functions</a></li><li><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" target="_blank" rel="noopener">itertools — Functions creating iterators for efficient looping</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用技巧</title>
      <link href="/posts/57195.html"/>
      <url>/posts/57195.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章搜集整理了在学习中经常会使用的一些vim快捷键以及技巧。</p></div><a id="more"></a><h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p>vim 包括 <code>normal</code> 和 <code>insert</code> 两种模式：</p><ul><li><code>normal</code> 模式下所有按键都是<strong>功能键</strong>，直接vim打开文件就是normal模式。</li><li>在 <code>insert</code> 模式下可以<strong>正常的输入内容</strong>，打开文件之后需要输入<code>i</code>之后才会进入insert模式</li></ul><hr><h2 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h2><p>在home目录下创建一个<code>.vimrc</code>文件，添加如下代码来进行显示行号、代码缩进等配置，以后打开文件就不用额外输入来显示行号：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> number             <span class="comment"># 显示行号</span></span><br><span class="line"><span class="built_in">set</span> autoindent         <span class="comment"># 自动缩进</span></span><br><span class="line"><span class="built_in">set</span> nowrap             <span class="comment"># 不换行</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="连续打开文件"><a href="#连续打开文件" class="headerlink" title="连续打开文件"></a>连续打开文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开单个文件</span></span><br><span class="line">vim 1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件1.txt之后</span></span><br><span class="line"><span class="comment"># w：保存编辑后的文件内容</span></span><br><span class="line">esc + :w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤</span></span><br><span class="line">:open 2.txt</span><br></pre></td></tr></table></figure><hr><h2 id="打开快速定位"><a href="#打开快速定位" class="headerlink" title="打开快速定位"></a>打开快速定位</h2><p>直接定位到文本末尾：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim + test.txt</span><br></pre></td></tr></table></figure><p></p><p>定位到文本的第几行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接进入文本的第5行</span></span><br><span class="line">vim +5 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="退出保存"><a href="#退出保存" class="headerlink" title="退出保存"></a>退出保存</h2><ul><li><code>:wq</code>：保存并退出</li><li><code>ZZ</code>：保存并退出</li><li><code>:q!</code>：强制退出并忽略所有更改</li><li><code>:e!</code>：放弃所有修改，并打开原来文件。</li><li><code>:sav(eas) new.txt</code>：<strong>另存为一个新文件，退出原文件的编辑且不会保存</strong></li><li><code>:f(ile) new.txt</code>：<strong>新开一个文件，并不保存，退出原文件的编辑且不会保存</strong></li></ul><hr><h2 id="显示和取消行号"><a href="#显示和取消行号" class="headerlink" title="显示和取消行号"></a>显示和取消行号</h2><ul><li>显示行号：<code>normal</code>模式下输入<code>:set nu</code></li><li>取消显示行号：<code>normal</code>模式下输入<code>:set nonu</code></li></ul><hr><h2 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h2><h3 id="行内快速移动"><a href="#行内快速移动" class="headerlink" title="行内快速移动"></a>行内快速移动</h3><ul><li><code>0</code>：<strong>行头</strong></li><li><code>$</code>：<strong>行尾</strong></li><li><code>t.</code>：<strong>到’.’符号前的第一个字符</strong>，其中的<code>.</code>可以是<strong>任意字符</strong></li><li><code>f1</code>：到<strong>下一个’1’的位置</strong>，其中的1可以是<strong>任意字符</strong></li><li><code>w</code>：到<strong>下一个单词开头</strong>，各种<strong>分隔符</strong>也会被当成单词，如<code>-\%{&quot;</code></li><li><code>e</code>：到<strong>下一个单词结尾</strong>，各种<strong>分隔符</strong>也会被当成单词，如<code>-\%{&quot;</code></li></ul><h3 id="行间快速移动"><a href="#行间快速移动" class="headerlink" title="行间快速移动"></a>行间快速移动</h3><ul><li><code>:66</code>：<strong>移动到第几行</strong></li><li><code>gg</code>：到<strong>第一行</strong></li><li><code>G</code>：到<strong>最后一行</strong></li><li><code>5G</code>：到<strong>第5行</strong></li></ul><h3 id="屏幕瞬间移动"><a href="#屏幕瞬间移动" class="headerlink" title="屏幕瞬间移动"></a>屏幕瞬间移动</h3><p>这里的瞬间移动是<strong>视野的瞬间移动，光标是不会动的</strong>，不同于之前的两种瞬间移动：</p><ul><li><strong>后滚一屏</strong>：<code>ctrl+f</code></li><li><strong>前滚半屏</strong>：<code>ctrl+b</code></li><li><strong>定位屏幕中间</strong>：<code>zz</code></li><li>屏幕<strong>顶端</strong>：<code>zt</code></li><li>屏幕<strong>底部</strong>：<code>zb</code></li></ul><hr><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><code>normal</code>模式下：</p><ul><li><code>i</code>：在<strong>光标所在位置之前</strong>插入</li><li><code>I</code>：在当前<strong>行首插入</strong>，相当于<code>normal</code>模式下，先使用<code>0</code>回到行首，然后<code>i</code></li><li><code>a</code>：在<strong>光标所在位置之后</strong>插入</li><li><code>A</code>：在<strong>当前行尾</strong>插入，相当于<code>normal</code>模式下，先使用<code>$</code>回到行首，然后<code>i</code></li><li><code>o</code>：在<strong>当前行之后插入一行</strong></li><li><code>O</code>：在<strong>当前行之前插入一行</strong></li></ul><hr><h2 id="删除-剪切"><a href="#删除-剪切" class="headerlink" title="删除(剪切)"></a>删除(剪切)</h2><h3 id="以字符为单位"><a href="#以字符为单位" class="headerlink" title="以字符为单位"></a>以字符为单位</h3><p><code>normal</code>模式下：</p><ul><li><code>x</code>：<strong>删除</strong>字符</li><li><code>6x</code>：<strong>删除 6</strong> 个字符</li><li><code>d^</code>：删除<strong>当前字符到行首</strong></li><li><code>d$</code>：删除<strong>当前字符到行尾</strong></li></ul><hr><h3 id="以单词为单位"><a href="#以单词为单位" class="headerlink" title="以单词为单位"></a>以单词为单位</h3><p><code>normal</code>模式下：</p><ul><li><code>dw</code>：删除当<strong>前字符到单词尾</strong></li><li><code>daw</code>：删除<strong>当前字符所在单词</strong></li></ul><hr><h3 id="以行为单位"><a href="#以行为单位" class="headerlink" title="以行为单位"></a>以行为单位</h3><p><code>normal</code>模式下：</p><ul><li><code>dd</code>：<strong>删除所在行</strong></li><li><code>dj</code>：删除<strong>下一行</strong></li><li><code>dk</code>：删除<strong>上一行</strong></li><li><code>dgg</code>：删除<strong>当前行至文档首部</strong></li><li><code>dG</code>：删除<strong>当前行至文档尾部</strong></li><li><code>kdgg</code>：删除<strong>当前行之前所有行（不包括当前行）</strong></li><li><code>jdG</code>：删除<strong>当前行之后所有行（不包括当前行）</strong></li><li><code>:1,8d</code>：<strong>删除1-8行</strong></li><li><code>J</code>：删除两行之间的<code>\n</code>，实际上是<strong>合并两行</strong></li></ul><p><strong>删除完成后结合粘贴的命令可以实现剪切操作。</strong></p><hr><h2 id="复制与粘贴"><a href="#复制与粘贴" class="headerlink" title="复制与粘贴"></a>复制与粘贴</h2><p><code>normal</code>模式下：</p><ul><li><code>yy</code>：<strong>复制</strong>光标所在行(<strong>单行</strong>)</li><li><code>3yy</code>：表示<strong>从光标所在行开始复制3行</strong></li><li><strong>粘贴</strong>复制的内容：<ul><li><code>p</code>：将内容粘贴在<strong>光标后一行</strong></li><li><code>P</code>：将内容粘贴在<strong>光标前一行</strong></li></ul></li><li><strong>多行复制</strong>：<ul><li>step1：<code>V</code></li><li>step2：移动光标自由选择</li><li>step3：<code>y</code>为复制选择的多行内容，<code>d</code>为剪切选择的多行内容</li></ul></li></ul><hr><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h3><p><code>normal</code>模式下：</p><ul><li><code>/whatyouneed</code>：<strong>搜索whatyouneed</strong>，按<code>n</code>键查找<strong>下一个</strong>，按<code>N</code>键查找<strong>前一个</strong></li><li><code>?whatyouneed</code>：<strong>反向搜索whatyouneed</strong>，按<code>n</code>键查找<strong>下一个</strong>，按<code>N</code>键查找<strong>前一个</strong></li><li><code>:noh</code>：<strong>取消搜索的高亮</strong></li><li>vim中有一些特殊字符在<strong>搜索时需要转义</strong>：<code>.*[]^%/?~$</code></li></ul><hr><h3 id="快速搜索"><a href="#快速搜索" class="headerlink" title="快速搜索"></a>快速搜索</h3><p>这里的快速是指的不用输入需要搜索的单词，同样是在<code>normal</code>模式下：</p><ul><li><code>*</code>：向<strong>后（下）</strong>寻找<strong>光标所在处的单词</strong></li><li><code>#</code>：向<strong>前（上）</strong>寻找<strong>光标所在处的单词</strong></li></ul><p>以上两种查找，<code>n</code>,<code>N</code> 的继续查找命令依然可以适用</p><hr><h3 id="精准查找"><a href="#精准查找" class="headerlink" title="精准查找"></a>精准查找</h3><p>如果文本中有这三个单词<code>hello</code>、<code>helloworld</code>、<code>hellopython</code>，如果使用<code>/hello</code> ，这三个词都会匹配到，但是只想匹配<code>hello</code>该怎么做呢？同样是在<code>normal</code>模式下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hello\&gt;</span><br></pre></td></tr></table></figure><p></p><p>另外，如果想匹配出现在行首和行尾的hello：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello位于行首</span></span><br><span class="line">/^hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># hello位于行末</span></span><br><span class="line">/hello$</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><code>normal</code>模式下：</p><ul><li><code>r&lt;字母&gt;</code>：将<strong>当前字符</strong>替换为所写字母</li><li><code>R&lt;字母&gt;&lt;字母&gt;...</code>：<strong>连续替换</strong>字母</li><li><code>cc</code>：<strong>替换整行</strong>（就是删除当前行，并在下一行插入）</li><li><code>cw</code>：<strong>替换一个单词</strong>（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）</li><li><code>:s/a/b/</code>：替换当前行<strong>第一个</strong> a 为 b</li><li><code>:s/a/b/g</code>：替换当前行<strong>所有</strong> a 为 b</li><li><code>:10,20 s/^/ /g</code>：在<strong>第10行至第20行每行前面加空格</strong>，用于缩进</li><li><code>:%s/a/b/</code>：替换<strong>每行第一个</strong> a 为 b</li><li><code>:%s/a/b/g</code>：替换<strong>每行所有</strong> a 为 b</li><li><strong>反悔模式</strong>：<code>:%s/a/b/gc</code>，vim <strong>匹配文字高亮并询问</strong><ul><li><code>y</code>：表示<strong>替换当前</strong></li><li><code>n</code>：表示<strong>不替换当前</strong></li><li><code>a</code>：表示<strong>全部替换</strong></li><li><code>q</code>：表示<strong>退出</strong>不玩儿了</li><li><code>l</code>：表示<strong>把当前替换后就退出</strong>不玩儿了</li></ul></li></ul><hr><h2 id="重复与撤销"><a href="#重复与撤销" class="headerlink" title="重复与撤销"></a>重复与撤销</h2><ul><li><code>.</code>：<strong>重复此前</strong>的操作</li><li><code>u</code>：<strong>撤销此前</strong>的操作，可以多次使用，表示撤销</li><li><code>5u</code>：<strong>撤销此前的 5 个操作</strong></li><li><code>U</code>：撤销对整行的操作</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s/SQKqEPggz8NoQ5XqOTcfxw" target="_blank" rel="noopener">vim 操作应知应会 10 点</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-tip-vim/index.html" target="_blank" rel="noopener">技巧：快速提高 Vi/Vim 使用效率的原则与途径</a></li><li><a href="https://mp.weixin.qq.com/s/AoNHAXe1Z_c-2PY_OTJmVQ" target="_blank" rel="noopener">学会这21条，你离 Vim 大神就不远了！</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Python小技巧</title>
      <link href="/posts/45492.html"/>
      <url>/posts/45492.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要搜集了在日常学习中遇到的一些小的python使用技巧。</p></div><a id="more"></a><h2 id="使用-i运行python程序"><a href="#使用-i运行python程序" class="headerlink" title="使用-i运行python程序"></a>使用-i运行python程序</h2><p>在命令行中运行python脚本的典型方法是：<code>python hello.py</code>。但是，如果在运行相同的脚本文件时额外添加一个 <code>-i</code>，例如<code>python -i hello.py</code>，这会带来更多好处。我们来看看是怎么回事：</p><ul><li>首先，一旦程序结束，python不会退出编译器，因此，我们可以检查变量的值和程序中定义的函数的正确性</li><li>其次，我们可以轻松地调用python调试器，因为我们仍然在编译器中：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用python调试的包</span></span><br><span class="line"><span class="comment"># 这将把我们带到代码发生异常的位置，然后我们可以去处理代码。</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.pm()</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python_i_op.png" alt="python_i_op.png"></p><p><a href="https://mp.weixin.qq.com/s/n5yLhdtFmrxMQv6NNpZYCw" target="_blank" rel="noopener">参考链接</a></p><hr><h2 id="便捷运行Python程序"><a href="#便捷运行Python程序" class="headerlink" title="便捷运行Python程序"></a>便捷运行Python程序</h2><p>正常情况下运行python脚本需要使用<code>python hello.py</code>的形式，但是这样会比较麻烦，毕竟会多输入<code>python</code>这几个字符，为了便捷运行Python程序，可以使用如下方式：</p><h3 id="修改脚本权限"><a href="#修改脚本权限" class="headerlink" title="修改脚本权限"></a>修改脚本权限</h3><p>为了能够执行脚本，第一步就是需要将脚本改为可执行的文件，后续就可以直接通过<code>./hello.py</code>的形式运行脚本：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给脚本增加可执行权限</span></span><br><span class="line">chmod +x hello.py</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="增加程序运行标识"><a href="#增加程序运行标识" class="headerlink" title="增加程序运行标识"></a>增加程序运行标识</h3><p>在python脚本的第一行增加<code>#!/usr/bin/python</code>告诉系统这个脚本需要使用python程序执行，正如所有的bash脚本第一行都要加上<code>#!/bin/bash</code>一样:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>需要注意的是：<code>#!/usr/bin/python</code>指定的Python是<code>/usr/bin/python</code>，版本通常为2.7，而不是自己设置的环境变量中的python版本(可以通过<code>which python</code>查看)。</p></div><p>指定python为<strong>环境变量中指定的Python版本</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定使用环境变量中的python版本</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br></pre></td></tr></table></figure><p></p><p>上面命令调用的Python版本和在命令行中直接输入Python得到的版本相同(<code>which python</code>)</p><p>事实上也可以通过<code>#!/usr/bin/env</code>来指定Python<strong>搜索module的默认路径</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置Python module的默认搜索路径为/opt/webscripts/</span></span><br><span class="line"><span class="comment">#!/usr/bin/env PYTHONPATH=/opt/webscripts/ python</span></span><br></pre></td></tr></table></figure><p></p><p>参考链接：</p><ul><li><a href="http://www.bnikolic.co.uk/blog/python-running-cline.html" target="_blank" rel="noopener">Running Python Programs from the Command-line</a></li><li><a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" target="_blank" rel="noopener">PYTHONPATH</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编写更加鲁棒shell脚本</title>
      <link href="/posts/44703.html"/>
      <url>/posts/44703.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了编写robust bash脚本的一些技巧，包括<strong>使用<code>set -u</code>来在运行脚本之前检查变量传递</strong>、<strong>使用<code>set -e</code>在遇到命令的非零运行状态直接退出</strong>、<strong>变量和文件名记得使用引号</strong>、<mark>使用trap命令来清除临时或者需要更新的文件</mark>等方法，都是一些非常实用而且平常不太注意的技巧！</p></div><a id="more"></a><h2 id="set-u-运行脚本之前检查变量传递"><a href="#set-u-运行脚本之前检查变量传递" class="headerlink" title="set -u :运行脚本之前检查变量传递"></a>set -u :运行脚本之前检查变量传递</h2><p>在使用shell脚本过程中，常常需要给脚本传递变量，为了达到这个目的最简单的方法就是使用<code>test=$1</code>这种方式，表明除去脚本名之后的第一个命令行参数为需要传递给<code>test</code>的变量值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">test_1=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test_1&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>上面的脚本以为是直接输出传递的变量内容，所以如果没有给变量赋值就直接输出空白，不会影响程序运行。而如果需要对传入的变量进行一系列的操作的话，这种忘记传递变量的做法就会使得脚本运行结果与期望结果差异较大或者带来一些不可逆的影响，为了避免这种情况，shell提供了<code>set -u</code>，这个命令可以<strong>在运行脚本之前检查变量是否赋值完全，如果缺少变量就会停止运行，直接退出程序</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line">test_1=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test_1&#125;</span></span><br></pre></td></tr></table></figure><p>直接运行上述程序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 报错提示缺少变量</span></span><br><span class="line">./set_u.sh </span><br><span class="line">  ./set_u.sh: line 3: <span class="variable">$1</span>: unbound variable</span><br></pre></td></tr></table></figure><p></p><p>使用<code>set -o nounset</code>(more readable)也能达到<code>set -u</code>同样的目的。</p><hr><h2 id="set-e：非零运行状态直接退出"><a href="#set-e：非零运行状态直接退出" class="headerlink" title="set -e：非零运行状态直接退出"></a>set -e：非零运行状态直接退出</h2><p>建议在<strong>所有的shell脚本之前</strong>都加上<code>set -e</code>，其作用是使脚本<strong>在遇到任何一个non-zero返回值(未正确运行)的时候自动退出脚本，防止错误的叠加</strong>。与<code>set -e</code>相同的还有<code>set -o errexit</code>(more readable).</p><p>当然也可以<strong>手动检查</strong>一些程序的运行状态，使用<code>$?</code>，<code>$?</code>返回<strong>最后运行的命令的结束代码</strong>，<strong>正常运行的命令结束代码为0，出错或者出现异常结束代码不为0</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span>-ne 0]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"command failed"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>如果<strong>只关心程序的某一部分的命令退出状态</strong>，可以关闭这种error检查机制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> +e</span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"><span class="built_in">set</span> -e</span><br></pre></td></tr></table></figure><p></p><p>对于pipeline的话，默认情况下shell会返回pipeline中最后一个命令的运行状态，例如<code>false | true</code>会返回<code>true</code>，这可能不是我们想要的结果，如果想要这种不合理的pipeline直接停止，可以使用<code>set -o pipefail</code>。</p><hr><h2 id="变量和文件名记得使用引号"><a href="#变量和文件名记得使用引号" class="headerlink" title="变量和文件名记得使用引号"></a>变量和文件名记得使用引号</h2><p>在使用<code>if</code>操作时经常遇到的错误就是<code>-bash: [: too many arguments</code>，这就是因为用于test的<strong>变量可能含有空格</strong>，而如果没有给变量增加引号，那么就会得到两个参数，这种情况下就会报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量值存在空格</span></span><br><span class="line">file=<span class="string">"test hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$file</span> == <span class="string">"foo"</span> ];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">fi</span></span><br><span class="line">  -bash: [: too many arguments</span><br></pre></td></tr></table></figure><p></p><p>而如果增加空格之后就<a href="http://showteeth.tech/posts/58105.html">不会出现上述错误</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$file</span>"</span> == <span class="string">"foo"</span> ];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>同样的，在使用<code>find</code>、<code>xargs</code>命令时如果文件名中存在空格可能就会报错，<strong>正确的做法</strong>就是在find中使用<code>-print0</code>来separate filenames with a null character rather than new lines. 然后在xargs中使用<code>-0</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">touch <span class="string">"foo bar"</span></span><br><span class="line">find | xargs ls</span><br><span class="line">  ls: ./foo: No such file or directory</span><br><span class="line">  ls: bar: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在find中使用-print0，在xargs中使用-0</span></span><br><span class="line">find -print0 | xargs -0 ls</span><br><span class="line">./foo bar</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用trap命令来清除临时或者需要更新的文件"><a href="#使用trap命令来清除临时或者需要更新的文件" class="headerlink" title="使用trap命令来清除临时或者需要更新的文件"></a>使用trap命令来清除临时或者需要更新的文件</h2><p>trap命令可以在接收到退出信号的时候进行相应的操作来清除临时文件以及需要更新但是没有更新完成的文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -e <span class="variable">$lockfile</span> ]; <span class="keyword">then</span></span><br><span class="line">   touch <span class="variable">$lockfile</span></span><br><span class="line">   critical-section</span><br><span class="line">   rm <span class="variable">$lockfile</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"critical-section is already running"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>上述命令如果顺利执行，那么最开始如果没有<code>$lockfile</code>则会创建一个<code>$lockfile</code>，在<code>critical-section</code>中会对其进行调用，最后会删除这个文件，下一次继续运行<code>critical-section</code>的时候会通过检测<code>$lockfile</code>是不是存在从而决定是不是需要继续运行；如果在执行<code>critical-section</code>时遇到一些终止信号，例如<code>Ctrl + C</code>，那么就会直接退出，此时创建的<code>$lockfile</code>依旧存在，下次就不会继续运行<code>critical-section</code>；为了解决这种情况可以使用trap命令，在运行<code>critical-section</code>时如果遇到终止信号，会在退出时执行某种操作，如rm：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -e <span class="variable">$lockfile</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 遇到终止信号会先删除$lockfile，然后退出</span></span><br><span class="line">  <span class="comment"># 注意这里如要使用exit指定退出</span></span><br><span class="line">  <span class="comment"># 如果不指定就会继续执行</span></span><br><span class="line">  <span class="comment"># 脚本不会退出</span></span><br><span class="line">   <span class="built_in">trap</span> <span class="string">"rm -f <span class="variable">$lockfile</span>; exit"</span> INT TERM EXIT</span><br><span class="line">   touch <span class="variable">$lockfile</span></span><br><span class="line">   critical-section</span><br><span class="line">   rm <span class="variable">$lockfile</span></span><br><span class="line">   <span class="comment"># 个人理解是如果运行到这里就不用管最开始的trap了，因为前面一步就将$lockfile删除了</span></span><br><span class="line">   <span class="comment"># 重置trap</span></span><br><span class="line">   <span class="built_in">trap</span> - INT TERM EXIT</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"critical-section is already running"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>有很多信号都可以用来设置trap，这里只列举了三个常用的：<br><table><tr><th width="10%">Signal</th><th width="90%">Description</th></tr><tr><td>INT</td><td>Interrupt – This signal is sent when someone kills the script by pressing ctrl-c.</td></tr><tr><td>TERM</td><td>Terminate – this signal is sent when someone sends the TERM signal using the kill command.</td></tr><tr><td>EXIT</td><td>Exit – this is a pseudo-signal and is triggered when your script exits, either through reaching the end of the script, an exit command or by a command failing when usingset -e.</td></tr></table></p><p>关于trap命令进一步的阅读：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-usingtraps/index.html" target="_blank" rel="noopener">在脚本中使用 trap</a></li><li><a href="http://man.linuxde.net/trap" target="_blank" rel="noopener">trap命令</a></li></ul><hr><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.davidpashley.com/articles/writing-robust-shell-scripts/" target="_blank" rel="noopener">Writing Robust Bash Shell Scripts</a></li><li><a href="https://github.com/vsbuffalo/devnotes/wiki/Bash-Script-Tips" target="_blank" rel="noopener">Bash Script Tips</a></li></ul><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tr-转换、删除、压缩重复字符</title>
      <link href="/posts/46339.html"/>
      <url>/posts/46339.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<code>sed</code>命令的简化版<code>tr</code>命令，其可以实现<strong>替换</strong>、<strong>删除</strong>、<strong>压缩(去重)</strong>等操作。主要参数包括：<code>-d</code>删除、<code>-s</code>压缩、<code>-t</code>截断SET1、<code>-c</code>取补SET1。默认情况下，如果同时提供了<code>SET1</code>、<code>SET2</code>那么就会进行替换操作；<code>-c</code>取补SET1<strong>不能单独使用</strong>，可以结合<code>-d</code>或者<strong>增加SET2实现替换操作</strong>。</p></div><a id="more"></a><h2 id="tr命令简介"><a href="#tr命令简介" class="headerlink" title="tr命令简介"></a>tr命令简介</h2><p><code>tr</code>命令可以从标准输入删除或者替换字符，并将结果写到标准输出。</p><p>通过使用 <code>tr</code>，可以<strong>非常容易地实现 <code>sed</code> 的许多最基本功能</strong>，<strong>可以将 <code>tr</code> 看作为 <code>sed</code> 的（极其）简化的变体</strong>。它可以用一个字符来替换另一个字符，或者可以完全除去一些字符；也可以用它来除去重复字符。</p><hr><h2 id="tr命令格式"><a href="#tr命令格式" class="headerlink" title="tr命令格式"></a>tr命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  tr [OPTION]... SET1 [SET2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用说明</span></span><br><span class="line">Translate(替换), squeeze, and/or delete characters from standard input, writing to standard output.</span><br></pre></td></tr></table></figure><hr><h2 id="tr命令参数"><a href="#tr命令参数" class="headerlink" title="tr命令参数"></a>tr命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td>-c,-C</td><td>--complement</td><td>取SET1的补集</td></tr><tr><td>-d</td><td>--delete</td><td>删除所有属于SET1的字符</td></tr><tr><td>-s</td><td>--squeeze-repeats</td><td>把连续重复的字符(SET1中指定的)以单独一个字符表示</td></tr><tr><td>-t</td><td>--truncate-set1</td><td>截断SET1长度，使其与SET2等长</td></tr></table><hr><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table><tr><th width="10">字符</th><th width="40">说明</th><th width="10">字符</th><th width="40">说明</th></tr><tr><td>\NNN</td><td>八进制值的字符(1-3位8进制的数)</td><td>[:alnum:]</td><td>所有字母字符与数字</td></tr><tr><td>\\</td><td>反斜杠</td><td>[:alpha:]</td><td>所有字母字符</td></tr><tr><td>\a</td><td>Ctrl-G，铃声</td><td>[:blank:]</td><td>所有水平空格</td></tr><tr><td>\b</td><td>Ctrl-H，退格符</td><td>[:cntrl:]</td><td>所有控制字符</td></tr><tr><td>\f</td><td>Ctrl-L，走行换页</td><td>[:digit:]</td><td>所有数字</td></tr><tr><td>\n</td><td>Ctrl-J，新行</td><td>[:graph:]</td><td>所有可打印的字符(不包含空格符)</td></tr><tr><td>\r</td><td>Ctrl-M，回车</td><td>[:lower:]</td><td>所有小写字母</td></tr><tr><td>\t</td><td>Ctrl-I，tab键</td><td>[:print:]</td><td>所有可打印的字符(包含空格符)</td></tr><tr><td>\v</td><td>Ctrl-X，水平制表符</td><td>[:punct:]</td><td>所有标点字符</td></tr><tr><td>CHAR1-CHAR2</td><td>指定字符范围从 CHAR1 到 CHAR2 ，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小</td><td>[:space:]</td><td>所有水平与垂直空格符</td></tr><tr><td>[CHAR*]</td><td>这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</td><td>[:upper:]</td><td>所有大写字母</td></tr><tr><td>[CHAR*REPEAT]</td><td>这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止。除非其首位数字是 0，否则 Number 一律视为是十进制整数；如果首位数字是 0，那么视为八进制整数</td><td>[:xdigit:]</td><td>所有 16 进位制的数字</td></tr></table><hr><h2 id="tr命令使用实例"><a href="#tr命令使用实例" class="headerlink" title="tr命令使用实例"></a>tr命令使用实例</h2><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>如果<strong>同时指定</strong>了<code>SET1</code>和<code>SET2</code>，并且<strong>中间没有添加任何参数</strong>，那么tr命令就会<strong>从标准输入</strong>中<strong>将SET1中所包含的每一个字符替换</strong>为SET2中<strong>相同位置</strong>上的字符，需要注意的是：<strong>如果SET1中指定的字符在原始的字符中出现多次，那么就会使用SET2中对应位置的字符进行全部替换(全局替换)</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有的大写字母都替换为小写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO WORLD"</span> |tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span></span><br><span class="line">  hello world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方式实现</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO WORLD"</span> |tr [:upper:] [:lower:]</span><br><span class="line">  hello world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将空格转化为制表符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO WORLD"</span> |tr [:space:] <span class="string">'\t'</span></span><br><span class="line">  HELLO   WORLD </span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接修改文件内容</span></span><br><span class="line">cat test.txt </span><br><span class="line">  hello world</span><br><span class="line">  HELLO WORLD</span><br><span class="line">tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span> &lt; test.txt </span><br><span class="line">  hello world</span><br><span class="line">  hello world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果SET1中指定的字符在原始的字符中出现多次</span></span><br><span class="line"><span class="comment"># 那么就会使用SET2中对应位置的字符进行全部替换</span></span><br><span class="line"><span class="comment"># 指定的字符对应关系是将L替换为l，但是会将原始字符的所有都进行替换</span></span><br><span class="line"><span class="comment"># 相当于sed的g</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO"</span> |tr <span class="string">'HEL'</span> <span class="string">'hel'</span></span><br><span class="line">  hellO</span><br></pre></td></tr></table></figure><p><code>&#39;A-Z&#39;</code> 和 <code>&#39;a-z&#39;</code>都是集合，集合是可以自己制定的，例如：<code>&#39;ABD-}&#39;</code>、<code>&#39;bB.,&#39;</code>、<code>&#39;a-de-h&#39;</code>、<code>&#39;a-c0-9&#39;</code>都属于集合，集合里可以使用<code>&#39;\n&#39;</code>、<code>&#39;\t&#39;</code>，可以可以使用其他<code>ASCII</code>字符。</p><p><mark>使用tr命令进行替换的时候需要特别注意<code>SET1</code>、<code>SET2</code>的长度问题</mark>：</p><ul><li>如果<strong>SET1比SET2短</strong>，那么会自动<strong>忽略</strong>SET2中剩余的部分</li><li>如果<strong>SET1比SET2长</strong>，那么会将SET2中最后一个字符进行<strong>重复</strong>，这里可以结合-t参数进行截断SET1至于SET2等长</li><li>尽量保持SET1和SET2字符长度的统一</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SET1比SET2短，SET2中多余的部分会被去除掉</span></span><br><span class="line"><span class="comment"># 只会对H进行替换为h</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO"</span> |tr <span class="string">'H'</span> <span class="string">'he'</span></span><br><span class="line">  hELLO</span><br><span class="line"></span><br><span class="line"><span class="comment"># SET1比SET2长，SET2中的最后一个字符会重复</span></span><br><span class="line"><span class="comment"># HE被替换为hh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO"</span> |tr <span class="string">'HE'</span> <span class="string">'h'</span></span><br><span class="line">  hhLLO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然SET1比SET2长，但是使用了-t参数可以截断SET1至于SET2等长</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO"</span> |tr -t <span class="string">'HE'</span> <span class="string">'h'</span></span><br><span class="line">  hELLO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果SET1比SET2长，可以指定字符进行重复使得两者等长</span></span><br><span class="line"><span class="comment"># 指定重复h来使其等长，默认情况是重复e</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO"</span> |tr <span class="string">'HEL'</span> <span class="string">'[h*]e'</span></span><br><span class="line">  hheeO</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>SET1和SET2只是一个字符的<strong>对应关系</strong>，至于真正的替换是对应字符在原始字符串上的<strong>全局替换</strong></li><li>注意SET1和SET2长度不同的对应情况，总的来说就是<strong>以SET1为准</strong></li><li>这种替换的映射关系可以用于进行<strong>加密和解密操作</strong></li></ul></div><hr><h3 id="d：删除"><a href="#d：删除" class="headerlink" title="-d：删除"></a>-d：删除</h3><p>如果想要改变tr命令默认的替换行为，可以使用<code>-d</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有的数字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello 123 world 456"</span> | tr -d <span class="string">'0-9'</span></span><br><span class="line">  <span class="comment"># 注意这里有两个空格</span></span><br><span class="line">  hello  world</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="c：取补集"><a href="#c：取补集" class="headerlink" title="-c：取补集"></a>-c：取补集</h3><p>如果想删除指定字符集以外的字符(保留指定字符)，可以使用<code>-c</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除除了数字之外的所有字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello 123 world 456"</span> | tr -d -c <span class="string">'0-9'</span></span><br><span class="line">  123456</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是：<code>-c</code>参数不能够单独使用，如果单独使用会报错，需要<strong>结合<code>-d</code></strong>或者<strong>增加SET2来实现替换操作</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello 123 world 456"</span> | tr -c <span class="string">'0-9'</span></span><br><span class="line">  tr: missing operand after ‘0-9’</span><br><span class="line">  Two strings must be given when translating.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后的换行符也是ao的补集</span></span><br><span class="line"><span class="comment"># 所以最后的换行符也被替换为了y</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"abcdefo"</span>| tr -c <span class="string">"ao"</span> <span class="string">"y"</span></span><br><span class="line">  ayyyyyoy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果SET2指定了多个字符，那么将以最后一个字符进行替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"abcdefo"</span>| tr -c <span class="string">"ao"</span> <span class="string">"ym"</span></span><br><span class="line">  ammmmmom</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-c</code>参数不能单独使用，需要结合<code>-d</code>或者<strong>增加SET2来实现替换操作</strong></li><li>注意<code>\n</code>这种特殊的字符，取补集可能会造成一些不想发生的替换</li><li>如果SET2指定了多个字符，那么将以最后一个字符进行替换</li></ul></div><hr><h3 id="s：压缩重复字符"><a href="#s：压缩重复字符" class="headerlink" title="-s：压缩重复字符"></a>-s：压缩重复字符</h3><p>如果想将重复的字符只显示一个，可以使用<code>-s</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将重复出现的空格、s、n都压缩为单个的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"thissss is      a text linnnnnnne."</span> | tr -s <span class="string">' sn'</span></span><br><span class="line">  this is a text line.</span><br></pre></td></tr></table></figure><p></p><p><code>-s</code>参数压缩之后再进行替换操作：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先压缩得到this is a text line.</span></span><br><span class="line"><span class="comment"># 然后将空格、s、s都替换为H</span></span><br><span class="line"><span class="comment"># 同时对最后的H也进行了压缩，不会出现两个H同时出现</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"thissss is      a text linnnnnnne."</span> | tr -s <span class="string">' sn'</span> <span class="string">'H'</span></span><br><span class="line">  thiHiHaHtextHliHe.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的字符替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"thissss is      a text linnnnnnne."</span> | tr -s <span class="string">' s'</span> <span class="string">'HT'</span></span><br><span class="line">  thiTHiTHaHtextHlinnnnnnne.</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>如果不指定SET2，则仅只压缩，不做替换</li><li>如果指定了SET2，则压缩后还一一对应地进行替换，注意替换与压缩的对应关系：<strong>先压缩，然后再替换</strong></li></ul></div><hr><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="解决windows下的文件与linux下文件换行符的问题"><a href="#解决windows下的文件与linux下文件换行符的问题" class="headerlink" title="解决windows下的文件与linux下文件换行符的问题"></a>解决windows下的文件与linux下文件换行符的问题</h3><p>直接使用<code>vim</code>编辑器的快捷键：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim test.txt</span></span><br><span class="line"><span class="comment"># :set ff=unix</span></span><br><span class="line"><span class="comment"># esc + :wq</span></span><br></pre></td></tr></table></figure><p></p><p>使用<code>tr</code>命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tr -s <span class="string">"\r"</span> <span class="string">"\n"</span> &lt; file &gt; new_file</span><br><span class="line">或</span><br><span class="line">tr -d <span class="string">"\r"</span> &lt; file &gt; new_file</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用tr进行数学运算"><a href="#使用tr进行数学运算" class="headerlink" title="使用tr进行数学运算"></a>使用tr进行数学运算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算1-9的数字之和</span></span><br><span class="line"><span class="comment"># 之后补的0是必须的，不然得到的是1+2+3..+9+</span></span><br><span class="line"><span class="built_in">echo</span> 1 2 3 4 5 6 7 8 9 | xargs -n1 | <span class="built_in">echo</span> $(( $(tr <span class="string">'\n'</span> <span class="string">'+'</span>) 0 ))</span><br><span class="line">  45</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds5/tr.htm" target="_blank" rel="noopener">IBM tr 命令</a></li><li><a href="http://man.linuxde.net/tr" target="_blank" rel="noopener">tr命令</a></li><li><a href="https://www.jianshu.com/p/2c185f32999b" target="_blank" rel="noopener">Shell tr 命令简介</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7521506.html" target="_blank" rel="noopener">SHELL脚本–tr命令用法和特性全解</a></li><li><a href="https://www.jianshu.com/p/ae3f5994b0e3" target="_blank" rel="noopener">23. Linux tr命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux隔行输出文本信息</title>
      <link href="/posts/43739.html"/>
      <url>/posts/43739.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中隔行输出文本的方法，包括使用<code>sed</code>和<code>awk</code>命令，使用这两种方法都有一些较为通用的控制隔行输出的命令行，在<code>sed</code>中是<code>sed -n X~Np file</code>，在<code>awk</code>中是<code>awk &#39;NR%N==X&#39; test.txt</code>，其中<strong>N为隔的行数</strong>，<strong>X为输出的第几行</strong>。</p></div><a id="more"></a><h2 id="使用sed命令进行隔行输出"><a href="#使用sed命令进行隔行输出" class="headerlink" title="使用sed命令进行隔行输出"></a>使用sed命令进行隔行输出</h2><h3 id="输出奇数行和偶数行"><a href="#输出奇数行和偶数行" class="headerlink" title="输出奇数行和偶数行"></a>输出奇数行和偶数行</h3><p>输出<strong>奇数行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line"><span class="comment"># 先print，然后next</span></span><br><span class="line"><span class="comment"># 再进行print</span></span><br><span class="line">sed -n <span class="string">'p;n'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line"><span class="comment"># 每两行中的第一行输出</span></span><br><span class="line">sed -n <span class="string">'1~2p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出<strong>偶数行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line"><span class="comment"># 和上面的输出奇数行相反</span></span><br><span class="line"><span class="comment"># 先next，然后再print</span></span><br><span class="line">sed -n <span class="string">'n;p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line"><span class="comment"># 每两行中的第二行输出</span></span><br><span class="line">sed -n <span class="string">'2~2p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><h3 id="较为通用的方法"><a href="#较为通用的方法" class="headerlink" title="较为通用的方法"></a>较为通用的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出第10、20、30行</span></span><br><span class="line"><span class="comment"># Every tenth line (10, 20, 30, ...)</span></span><br><span class="line">sed -n 10~10p file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出第1、11、21行</span></span><br><span class="line"><span class="comment"># Every tenth line (1, 11, 21, ...)</span></span><br><span class="line">sed -n 1~10p file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-e参数来进行组合输出</span></span><br><span class="line"><span class="comment"># 增加某些没有规律的情况</span></span><br><span class="line"><span class="comment"># First plus every tenth (1, 10, 20, 30, ...)</span></span><br><span class="line">sed -n -e 1p -e 10~10p file</span><br></pre></td></tr></table></figure><p>其实使用前面<code>next和print</code>的方法也可以实现类似的效果，但<strong>比较麻烦</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔两行输出</span></span><br><span class="line">sed -n <span class="string">'p;n;n'</span> test.txt</span><br><span class="line">  1 4 7 10</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>使用<code>sed -n 1~10p file</code>方法来进行规律性地输出是比较通用的方法，这种方法的结构是：<strong>每个多少行(~之后的内容)输出第几行(~之前的内容)</strong></li><li>还可以结合<code>-e</code>参数来组合输出，指定多个<code>pattern</code></li></ul></div><hr><h2 id="使用awk命令来控制隔行输出"><a href="#使用awk命令来控制隔行输出" class="headerlink" title="使用awk命令来控制隔行输出"></a>使用awk命令来控制隔行输出</h2><h3 id="输出奇数行和偶数行-1"><a href="#输出奇数行和偶数行-1" class="headerlink" title="输出奇数行和偶数行"></a>输出奇数行和偶数行</h3><p>输出<strong>奇数行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用了NR这个内置变量</span></span><br><span class="line"><span class="comment"># 表示行号，当前处理文本行的行号</span></span><br><span class="line"><span class="comment"># 使用取余数的方法</span></span><br><span class="line">awk <span class="string">'NR%2==1'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出<strong>偶数行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'NR%2==0'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><h3 id="更为通用的方法"><a href="#更为通用的方法" class="headerlink" title="更为通用的方法"></a>更为通用的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每隔n行输出第p行</span></span><br><span class="line"><span class="comment"># n=10 and p=1, printing line 1,11,21,31,41</span></span><br><span class="line">awk <span class="string">'NR%n==p'</span> test.txt</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://stackoverflow.com/questions/9968916/print-every-nth-line-into-a-row-using-gawk" target="_blank" rel="noopener">print every nth line into a row using gawk</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之rpy2-在Python中使用R</title>
      <link href="/posts/63643.html"/>
      <url>/posts/63643.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了可以<strong>在Python中使用R的模块rpy2</strong>，具体的用法参见文章内容。</p></div><a id="more"></a><h2 id="rpy2简介"><a href="#rpy2简介" class="headerlink" title="rpy2简介"></a>rpy2简介</h2><p>本来我一直以为Python是完全可以替代R的。以前我一直以为R最强大的功能在于绘图，使用R语言可以绘制很漂亮的图片，然而自从Python的各种绘图包(eg：matplotlib、seabrn、plotly…)出现以来，R在这方面的优势在我看来就有些弱化，我开始将自己的工作重心转移到Python上，然而最近需要做一个非线性拟合的工作，查找的很多资料都是R的，这才让我意识到R在统计分析方面的优势是非常巨大的，Python虽然也有scipy这种包，但是相比于R来说还是太弱了，毕竟R就是搞统计使用的。</p><p>言归正传，Python和R两者是相互补充的，而不是相互竞争的，所以将这两种语言联合起来使用非常重要，因为自己还是使用Python比较顺手，所以这里就介绍能够在Python中调用R的rpy2包，关于R中使用Python的包这里就不做介绍了。</p><hr><h2 id="rpy2安装"><a href="#rpy2安装" class="headerlink" title="rpy2安装"></a>rpy2安装</h2><p><a href="https://rpy2.readthedocs.io/en/version_2.8.x/overview.html#easy-install-and-pip" target="_blank" rel="noopener">rpy2官方文档</a>提供了很多安装方法，其中最简单的当然是直接使用pip的方式进行安装，有其他需要的可以查看官方文档：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rpy2</span><br></pre></td></tr></table></figure><p></p><h2 id="rpy2使用准备"><a href="#rpy2使用准备" class="headerlink" title="rpy2使用准备"></a>rpy2使用准备</h2><h3 id="导入rpy2包"><a href="#导入rpy2包" class="headerlink" title="导入rpy2包"></a>导入rpy2包</h3><p><strong>rpy2提供了两种接口</strong>：</p><ul><li>low-level：<code>rpy2.rinterface</code></li><li>high-level：<code>rpy2.robjects</code>，<strong>高级的接口使得在Python中使用R更加的自然</strong></li></ul><p><strong>查看版本信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rpy2</span><br><span class="line"><span class="comment"># 输出版本信息</span></span><br><span class="line">print(rpy2.__version__)</span><br></pre></td></tr></table></figure><p></p><pre><code>3.0.4</code></pre><p><strong>查看使用的R信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!which R</span><br></pre></td></tr></table></figure><p></p><pre><code>/home/softwares/anaconda3/bin/R</code></pre><p><strong>导入高级接口</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import rpy2.robjects as robjects</span><br></pre></td></tr></table></figure><p></p><h3 id="导入R包"><a href="#导入R包" class="headerlink" title="导入R包"></a>导入R包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入引用R包的函数importr</span></span><br><span class="line">from rpy2.robjects.packages import importr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入base包</span></span><br><span class="line">base = importr(<span class="string">'base'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="安装R包"><a href="#安装R包" class="headerlink" title="安装R包"></a>安装R包</h3><p>正式开始安装R包之前的准备工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import rpy2's package module</span></span><br><span class="line"><span class="comment"># 可以用于判断相应的包是不是已经安装</span></span><br><span class="line"><span class="keyword">import</span> rpy2.robjects.packages <span class="keyword">as</span> rpackages</span><br><span class="line"><span class="comment"># import R's utility package</span></span><br><span class="line">utils = rpackages.importr(<span class="string">'utils'</span>)</span><br><span class="line"><span class="comment"># select a mirror for R packages</span></span><br><span class="line">utils.chooseCRANmirror(ind=<span class="number">1</span>) <span class="comment"># select the first mirror in the list</span></span><br></pre></td></tr></table></figure><pre><code>&lt;rpy2.rinterface.NULLType object at 0x7f14e864b7c8&gt; [RTYPES.NILSXP]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断相应的包是不是已经安装</span></span><br><span class="line">rpackages.isinstalled(<span class="string">'base'</span>)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>开始安装相应的R包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要安装的R包的名称</span></span><br><span class="line">packnames = (<span class="string">'ggplot2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入R的字符串向量函数</span></span><br><span class="line"><span class="keyword">from</span> rpy2.robjects.vectors <span class="keyword">import</span> StrVector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断需要安装R包是不是已经安装过，如果没有再进行安装</span></span><br><span class="line">names_to_install = [x <span class="keyword">for</span> x <span class="keyword">in</span> packnames <span class="keyword">if</span> <span class="keyword">not</span> rpackages.isinstalled(x)]</span><br><span class="line"><span class="keyword">if</span> len(names_to_install) &gt; <span class="number">0</span>:</span><br><span class="line">    utils.install_packages(StrVector(names_to_install))</span><br></pre></td></tr></table></figure><h2 id="The-r-instance"><a href="#The-r-instance" class="headerlink" title="The r instance"></a>The r instance</h2><h3 id="Getting-R-objects"><a href="#Getting-R-objects" class="headerlink" title="Getting R objects"></a>Getting R objects</h3><p>得到像在R console中一样的输出，如下使用<code>robjects.r[&#39;pi&#39;]</code>就相当于在R中直接输入pi一样，得到pi的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = robjects.r[<span class="string">'pi'</span>]</span><br><span class="line">pi</span><br></pre></td></tr></table></figure><span>FloatVector with 1 elements.</span><table><tbody><tr><td>3.141593</td></tr></tbody></table><p>需要注意的：</p><ul><li>上面的<strong>返回值是一个vector，而不是一个值</strong>，如果希望得到这个值，可以使用类似Python列表操作的方法</li><li>这里使用下标为0即可得到值，但是在<code>R console</code>中需要使用<code>pi[1]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>3.141592653589793</code></pre><h3 id="计算R代码的值"><a href="#计算R代码的值" class="headerlink" title="计算R代码的值"></a>计算R代码的值</h3><h4 id="运行单行代码"><a href="#运行单行代码" class="headerlink" title="运行单行代码"></a>运行单行代码</h4><p>前面使用<code>robjects.r[&#39;pi&#39;]</code>是直接调用了<code>__getitem__</code>方法，这里是使用了计算代码的值，两者的结果相同，但是实际的内部实现不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = robjects.r(<span class="string">'pi'</span>)</span><br><span class="line">pi</span><br></pre></td></tr></table></figure><span>FloatVector with 1 elements.</span><table><tbody><tr><td>3.141593</td></tr></tbody></table><p>和前面相同，上面返回的也是vector而不是具体的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>3.141592653589793</code></pre><h4 id="运行大段代码"><a href="#运行大段代码" class="headerlink" title="运行大段代码"></a>运行大段代码</h4><p>运行大段代码时<span class="mark">创建的变量和返回的结果保存在<code>Global Environment</code>中(也就是说是所有R代码的global variables，不是局部的变量)</span>，<code>Global Environment</code>就是Rstudio右上角的分栏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">robjects.r(<span class="string">'''</span></span><br><span class="line"><span class="string">        # create a function `f`</span></span><br><span class="line"><span class="string">        f &lt;- function(r, verbose=FALSE) &#123;</span></span><br><span class="line"><span class="string">            if (verbose) &#123;</span></span><br><span class="line"><span class="string">                cat("I am calling f().\n")</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            2 * pi * r</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        # call the function `f` with argument value 3</span></span><br><span class="line"><span class="string">        f(3)</span></span><br><span class="line"><span class="string">        '''</span>)</span><br></pre></td></tr></table></figure><span>FloatVector with 1 elements.</span><table><tbody><tr><td>18.849556</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为函数f已经存在于Global Environment</span></span><br><span class="line"><span class="comment"># 所有后面如果需要使用，可以直接调用，不用再次声明</span></span><br><span class="line">r_f = robjects.r[<span class="string">'f'</span>]</span><br><span class="line">r_f(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><span>FloatVector with 1 elements.</span><table><tbody><tr><td>31.415927</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robjects.r(<span class="string">'xx &lt;- seq(-.3, 5, len = 101)'</span>)</span><br></pre></td></tr></table></figure><span>FloatVector with 101 elements.</span><table><tbody><tr><td>-0.300000</td><td>-0.247000</td><td>-0.194000</td><td>...</td><td>4.894000</td><td>4.947000</td><td>5.000000</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仍然可以调用前面的xx变量结果</span></span><br><span class="line">robjects.r(<span class="string">'xx'</span>)</span><br></pre></td></tr></table></figure><span>FloatVector with 101 elements.</span><table><tbody><tr><td>-0.300000</td><td>-0.247000</td><td>-0.194000</td><td>...</td><td>4.894000</td><td>4.947000</td><td>5.000000</td></tr></tbody></table><h3 id="R向量"><a href="#R向量" class="headerlink" title="R向量"></a>R向量</h3><p>在R中，大部分的数据都是以vectors的形式保存的，即使有些可能看上去像是值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的pi其实就是一个长度为1的vector</span></span><br><span class="line">len(robjects.r[<span class="string">'pi'</span>])</span><br></pre></td></tr></table></figure><pre><code>1</code></pre><p></p><div class="mark"><br>如果直接使用R脚本得到一个vector然后再使用Python的<code>add()</code>操作，会相当于对R的vector进行了<code>concatenation</code>操作(<code>function c() in R</code>)：</div><i class="fa fa-lightbulb-o"></i><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">piplus2 = robjects.r(<span class="string">'pi'</span>) + <span class="number">2</span></span><br><span class="line">piplus2</span><br></pre></td></tr></table></figure><span>FloatVector with 2 elements.</span><table><tbody><tr><td>3.141593</td><td>2.000000</td></tr></tbody></table><p><strong>以R的形式显示vector(显示为c()的形式)</strong>，可以使用<code>vector.r_repr()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (piplus2.r_repr())</span><br></pre></td></tr></table></figure><pre><code>c(3.14159265358979, 2)</code></pre><h3 id="创建R向量"><a href="#创建R向量" class="headerlink" title="创建R向量"></a>创建R向量</h3><p>创建的向量可以是<code>字符串类型的(robjects.StrVector)</code>、<code>整型的(robjects.IntVector)</code>以及<code>浮点型的(robjects.FloatVector)</code>，不同的类型使用不用的方法创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串向量</span></span><br><span class="line">res = robjects.StrVector([<span class="string">'abc'</span>, <span class="string">'def'</span>])</span><br><span class="line">print(res.r_repr())</span><br></pre></td></tr></table></figure><pre><code>c(&quot;abc&quot;, &quot;def&quot;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整型向量</span></span><br><span class="line">res=robjects.IntVector([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> (res.r_repr())</span><br></pre></td></tr></table></figure><pre><code>1:3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点型向量</span></span><br><span class="line">res=robjects.FloatVector([<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> (res.r_repr())</span><br></pre></td></tr></table></figure><pre><code>c(1.1, 1.2, 1)</code></pre><p>创建矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = robjects.FloatVector([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>])</span><br><span class="line"><span class="comment"># 通过matrix函数来创建</span></span><br><span class="line">m = robjects.r[<span class="string">'matrix'</span>](v, nrow = <span class="number">2</span>)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><pre><code>     [,1] [,2] [,3][1,]  1.1  3.3  5.5[2,]  2.2  4.4  6.6</code></pre><h3 id="调用R函数"><a href="#调用R函数" class="headerlink" title="调用R函数"></a>调用R函数</h3><p><span class="mark">默认情况下，调用R函数返回的是R对象</span>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line">rsum = robjects.r[<span class="string">'sum'</span>]</span><br><span class="line"><span class="comment"># 计算vector的值</span></span><br><span class="line">rsum(robjects.IntVector([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># 返回的结果还是vector</span></span><br></pre></td></tr></table></figure><span>IntVector with 1 elements.</span><table><tbody><tr><td>6</td></tr></tbody></table><p>调用可以传递参数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rsort = robjects.r[<span class="string">'sort'</span>]</span><br><span class="line"><span class="comment"># 传递参数：是否降序排列</span></span><br><span class="line">res = rsort(robjects.IntVector([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), decreasing=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">print(res.r_repr())</span><br></pre></td></tr></table></figure><pre><code>3:1</code></pre><h3 id="获取帮助文档"><a href="#获取帮助文档" class="headerlink" title="获取帮助文档"></a>获取帮助文档</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rpy2.robjects.packages <span class="keyword">import</span> importr</span><br><span class="line">utils=importr(<span class="string">'utils'</span>)</span><br><span class="line">help_doc=utils.help(<span class="string">"help"</span>)</span><br><span class="line"><span class="comment"># 返回的仍然是vector</span></span><br><span class="line">help_doc</span><br></pre></td></tr></table></figure><span>StrVector with 1 elements.</span><table><tbody><tr><td>'/home/softwares/anaconda3/lib/R/library/utils/he...</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到具体的值</span></span><br><span class="line">help_doc[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>&apos;/home/softwares/anaconda3/lib/R/library/utils/help/help&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出完整的帮助文档，而不是帮助文档的位置</span></span><br><span class="line">str(help_doc)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(utils.help(<span class="string">"sum"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?importr</span><br></pre></td></tr></table></figure><h3 id="将pandas的dataframe转为R的dataframe"><a href="#将pandas的dataframe转为R的dataframe" class="headerlink" title="将pandas的dataframe转为R的dataframe"></a>将pandas的dataframe转为R的dataframe</h3><p>创建pandas的dataframe：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">pd_df = pd.DataFrame(&#123;<span class="string">'int_values'</span>: [1,2,3],</span><br><span class="line">                      <span class="string">'str_values'</span>: [<span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">pd_df</span><br></pre></td></tr></table></figure><p></p><p>转化为R的dataframe：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import rpy2.robjects as ro</span><br><span class="line">from rpy2.robjects.packages import importr</span><br><span class="line">from rpy2.robjects import pandas2ri</span><br><span class="line"></span><br><span class="line">from rpy2.robjects.conversion import localconverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体的转化过程</span></span><br><span class="line">with localconverter(ro.default_converter + pandas2ri.converter):</span><br><span class="line">  r_from_pd_df = ro.conversion.py2rpy(pd_df)</span><br><span class="line"></span><br><span class="line">r_from_pd_df</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (r_from_pd_df)</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://rpy2.readthedocs.io/en/version_2.8.x/getting-started.html" target="_blank" rel="noopener">rpy2官方文档</a></li><li><a href="https://rpy2.github.io/doc/v3.0.x/html/generated_rst/pandas.html" target="_blank" rel="noopener">dataframe之间的相互转换</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux解决软件缺失库文件</title>
      <link href="/posts/62465.html"/>
      <url>/posts/62465.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章记录了如何在<strong>没有root</strong>、<strong>不能直接安装缺失共享库</strong>的前提下<strong>如何补全缺失共享库</strong>的方法，主要是<strong>借助其他软件安装好的该共享库并建立软连接实现</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天使用<code>bgzip</code>命令的时候报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgzip: error <span class="keyword">while</span> loading shared libraries: libcrypto.so.1.0.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p></p><p>按照错误来说是缺失了共享库的信息，具体缺失的共享库为<code>libcrypto.so.1.0.0</code></p><hr><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="有root"><a href="#有root" class="headerlink" title="有root"></a>有root</h3><p>最简单粗暴的方法就是缺什么安装什么，但是这种共享库文件的安装肯定是需要root权限的，因为使用的是学校的集群，所以肯定没有权限，这种方法对于大部分用户来说都不是很适用，但还是列出来，万一是自家的集群呢：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu系统使用</span></span><br><span class="line"><span class="comment"># 重装libssl1.0.0</span></span><br><span class="line">sudo apt-get install libssl1.0.0</span><br><span class="line"></span><br><span class="line">sudo apt-get install apt-file</span><br><span class="line">sudo apt-file update</span><br><span class="line">apt-file search libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure><p></p><p>参考链接：<a href="https://unix.stackexchange.com/questions/283607/libraries-libcrypto-so-1-0-0-cannot-open-shared-object-file-no-such-file-or-d" target="_blank" rel="noopener">libraries: libcrypto.so.1.0.0: cannot open shared object file: No such file or directory</a></p><hr><h3 id="没有root权限"><a href="#没有root权限" class="headerlink" title="没有root权限"></a>没有root权限</h3><p>没有root权限下的解决是主要的解决方式(有root权限当然也可以使用这种做法)，也是今天想要记录的原因，之前没有这么解决过。</p><h4 id="使用ldd命令查看依赖"><a href="#使用ldd命令查看依赖" class="headerlink" title="使用ldd命令查看依赖"></a>使用ldd命令查看依赖</h4><p><code>ldd</code>命令是用来查看命令运行所需的共享库,常用来解决命令因缺少某个库文件而不能运行的一些问题。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看命令的绝对路径</span></span><br><span class="line"><span class="built_in">which</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命令的依赖信息</span></span><br><span class="line">ldd /usr/bin/<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 返回信息</span></span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffe16971000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fa91c0db000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fa91c4a9000)</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>不能找到相应的依赖</strong>会返回：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcrypto.so.1.0.0 =&gt; not found</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><mark>ldd命令一定要使用绝对路径</mark>，即使是linux系统自带的命令(built-in)，不然不会得到结果</li><li><strong>结果信息解读</strong>：<ul><li>第一列: <strong>程序需要依赖什么库</strong></li><li>第二列: <strong>系统提供的</strong>与程序需要的库所对应的库</li><li>第三列: 库加载的开始地址</li></ul></li></ul></div><hr><h4 id="直接在集群上查找丢失的共享库"><a href="#直接在集群上查找丢失的共享库" class="headerlink" title="直接在集群上查找丢失的共享库"></a>直接在集群上查找丢失的共享库</h4><p>很多共享库其他软件在安装的时候可能会自动安装，所以直接查找其他软件安装的共享库并使用是个不错的选择：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找丢失的共享库信息</span></span><br><span class="line">find ~ -name libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="建立软连接"><a href="#建立软连接" class="headerlink" title="建立软连接"></a>建立软连接</h4><p>将找到的共享库建立软连接到软件安装的lib目录中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看软件安装路径</span></span><br><span class="line"><span class="built_in">which</span> bgzip</span><br><span class="line"><span class="comment"># 软件是使用anaconda安装的</span></span><br><span class="line">  ~/usr/anaconda2/bin/bgzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立软连接</span></span><br><span class="line">ln -s /Share2/home/wangjb/usr/anaconda2/pkgs/openssl-1.0.2l-0/lib/libcrypto.so.1.0.0 /Share2/home/wangjb/usr/anaconda2/bin/../lib/libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：这的<code>/Share2/home/wangjb/usr/anaconda2/bin/../lib</code>目录其实就是<code>/Share2/home/wangjb/usr/anaconda2/lib</code>目录，但是看软件所有的依赖包都是这种写法，所以这里也采用了这种写法。</p></div><hr><h4 id="再次查看依赖包"><a href="#再次查看依赖包" class="headerlink" title="再次查看依赖包"></a>再次查看依赖包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ldd ~/usr/anaconda2/bin/bgzip</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffc36ddb000)</span><br><span class="line">        liblzma.so.5 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/liblzma.so.5 (0x00007fa05de85000)</span><br><span class="line">        libbz2.so.1.0 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/libbz2.so.1.0 (0x00007fa05dc73000)</span><br><span class="line">        libz.so.1 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/libz.so.1 (0x00007fa05da5b000)</span><br><span class="line">        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fa05d759000)</span><br><span class="line">        libcurl.so.4 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/libcurl.so.4 (0x00007fa05e220000)</span><br><span class="line">        <span class="comment"># 之前缺失的共享包这里有了</span></span><br><span class="line">        libcrypto.so.1.0.0 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/libcrypto.so.1.0.0 (0x00007fa05d322000)</span><br><span class="line"></span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fa05d106000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fa05cd43000)</span><br><span class="line">        librt.so.1 =&gt; /lib64/librt.so.1 (0x00007fa05cb3b000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fa05e0ab000)</span><br><span class="line">        libssh2.so.1 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libssh2.so.1 (0x00007fa05e1ed000)</span><br><span class="line">        libssl.so.1.1 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libssl.so.1.1 (0x00007fa05e157000)</span><br><span class="line">        libcrypto.so.1.1 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libcrypto.so.1.1 (0x00007fa05c843000)</span><br><span class="line">        libgssapi_krb5.so.2 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libgssapi_krb5.so.2 (0x00007fa05e107000)</span><br><span class="line">        libkrb5.so.3 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libkrb5.so.3 (0x00007fa05c767000)</span><br><span class="line">        libk5crypto.so.3 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libk5crypto.so.3 (0x00007fa05e0e8000)</span><br><span class="line">        libcom_err.so.3 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/./libcom_err.so.3 (0x00007fa05e0e1000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fa05c563000)</span><br><span class="line">        libkrb5support.so.0 =&gt; /Share2/home/wangjb/usr/anaconda2/bin/../lib/././libkrb5support.so.0 (0x00007fa05e0d1000)</span><br><span class="line">        libresolv.so.2 =&gt; /lib64/libresolv.so.2 (0x00007fa05c349000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次测试软件</span></span><br><span class="line">bgzip --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 正常使用</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html" target="_blank" rel="noopener">ldd 查看程序依赖库</a></li><li><a href="https://blog.csdn.net/littleblack201608/article/details/87252579" target="_blank" rel="noopener">WGS数据分析流程学习与开发过程全纪录（1）</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux没有root权限安装软件</title>
      <link href="/posts/62231.html"/>
      <url>/posts/62231.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了在<strong>没有root权限下如何下载安装软件</strong>，主要包括<strong>下载源码包(<code>yumdownloader</code>)</strong>、<strong>配置(<code>./configure</code>)</strong>、<strong>编译(<code>make</code>)</strong>和<strong>安装(<code>make install</code>)</strong>四步。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用集群的过程中难免会遇到需要root权限才能安装一些软件的问题，比如在centos上使用<code>yum install</code>这种包管理程序来安装软件就需要使用<code>sudo yum install</code>才能正确安装，但是作为一般的用户，哪里会有roo权限可以使用，但是有些软件又是必须的，所以才有了这篇文章。</p><hr><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里以nginx为例</span></span><br><span class="line">tar -zvxf nginx-1.2.3.tar.gz</span><br></pre></td></tr></table></figure><p><strong>关于如何下载源码</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载yum-utils，支持yumdownloader命令</span></span><br><span class="line">yum install yum-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载mypkg的源码</span></span><br><span class="line">yumdownloader --<span class="built_in">source</span> mypkg --destdir=DESTDIR</span><br><span class="line"><span class="comment"># --destdir=DESTDIR  指定下载目录，默认是当前目录 destination directory (defaults to current directory)</span></span><br><span class="line"><span class="comment"># --source operate on source packages</span></span><br></pre></td></tr></table></figure><p></p><p>参考链接：<a href="https://access.redhat.com/solutions/10154" target="_blank" rel="noopener">How to use yum to download a package without installing it</a></p><hr><h3 id="创建软件安装目录"><a href="#创建软件安装目录" class="headerlink" title="创建软件安装目录"></a>创建软件安装目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir nginx</span><br></pre></td></tr></table></figure><hr><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入第一步压缩包解压目录</span></span><br><span class="line"><span class="built_in">cd</span> source_code_folder</span><br><span class="line"><span class="comment"># 配置信息，prefix为软件安装目录</span></span><br><span class="line">./configure --prefix=/path/to/install/nginx</span><br></pre></td></tr></table></figure><div class="note info"><p>非root用户最重要的配置项是安装目录prefix，例如 <code>./configure –prefix=/path/to/bin</code>，在无法自动找到依赖库位置的情况下，用 <code>–with-xx-dir=xxx</code> 的形式<strong>配置依赖库位置</strong>.</p></div><hr><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><div class="note info"><p>make时指定 <code>-j</code> 参数并行编译，能<strong>显著减少编译耗时</strong></p></div><hr><h2 id="关于configure、make、make-install"><a href="#关于configure、make、make-install" class="headerlink" title="关于configure、make、make install"></a>关于configure、make、make install</h2><ul><li><code>./configure</code> 是用来<strong>检测你的安装平台的目标特征的，可以生成 <code>Makefile</code></strong>。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本；</li><li><code>make</code> 是用来编译的，它从<code>Makefile</code>中读取指令，然后<strong>编译</strong>；</li><li><code>make install</code>是用来安装的，它也从<code>Makefile</code>中读取指令，<strong>安装到指定的位置</strong>。</li></ul><h3 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h3><p><code>configure</code>命令一般用来生成 <code>Makefile</code>，为下一步的编译做准备，你可以通过在 <code>configure</code> 后加上参数来对安装进行控制，比如代码:<code>./configure –prefix=/usr</code> 意思是<strong>将该软件安装在 /usr 下面</strong>，<strong>执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin)</strong>，<strong>资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）</strong>。同时一些软件的配置文件你可以通过指定 <code>–sys-config=</code> 参数进行设定。有一些软件还可以加上 <code>–with</code>、<code>–enable</code>、<code>–without</code>、<code>–disable</code> 等等参数对编译加以控制，你可以通过允许 <code>./configure –help</code> 察看详细的说明帮助。</p><p>用了 <code>--prefix</code> 选项的好处：</p><ul><li><strong>方便维护</strong>，如果没有用这个选项，安装过程结束后，<strong>该软件所需的软件被复制到不同的系统目录下，很难弄清楚到底复制了那些文件、都复制到哪里去了—基本上是一塌糊涂</strong></li><li><strong>卸载软件或移植软件</strong>。当某个安装的软件不再需要时，<strong>只须简单的删除该安装目录</strong>，就可以把软件卸载得干干净净；<strong>移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统）</strong></li></ul><h4 id="LDFLAGS和CPPFLAGS"><a href="#LDFLAGS和CPPFLAGS" class="headerlink" title="LDFLAGS和CPPFLAGS"></a>LDFLAGS和CPPFLAGS</h4><ul><li><p><code>LDFLAGS</code>：<code>gcc</code> 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：<code>LDFLAGS=-L/usr/lib -L/path/to/your/lib</code>。每安装一个包都几乎一定的会在安装目录里建立一个<code>lib</code>目录。如果<strong>明明安装了某个包</strong>，而安装另一个包时，它<strong>愣是说找不到</strong>，可以将那个包的lib路径加入的<code>LDFALGS</code>中试一下。</p></li><li><p><code>CPPFLAGS</code>：<code>C</code>预处理器参数（ <code>C</code> 和 <code>Fortran</code> 编译器也会用到），用法：<code>CPPFLAGS=&quot;-I/usr/local/libtool-2.4.6/include -I/usr/local/gmp-6.1.0/include&quot;</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个LDFLAGS和CPPFLAGS可以使用空格分开</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/guile-2.2.4 LDFLAGS=<span class="string">"-L/usr/local/libtool-2.4.6/lib -L/usr/local/gmp-6.1.0/lib"</span> CPPFLAGS=<span class="string">"-I/usr/local/libtool-2.4.6/include -I/usr/local/gmp-6.1.0/include"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想将这当做configure的参数使用，可以在执行configure之前</span></span><br><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/libtool-2.4.6/lib -L/usr/local/gmp-6.1.0/lib"</span></span><br><span class="line"><span class="comment"># 那么执行configure以后，Makefile将会设置这个选项， 链接时会有这个参数，编译出来的可执行程序的库文件搜索路径就得到扩展了。</span></span><br></pre></td></tr></table></figure><p>更多相关参数：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/cppflags.png" alt="cppflags.png"></p><p><a href="https://www.cnblogs.com/taskiller/archive/2012/12/14/2817650.html" target="_blank" rel="noopener">参考链接</a></p><hr><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>这一步就是<strong>编译</strong>，大多数的源代码包都经过这一步进行编译（当然<strong>有些perl或python编写的软件需要调用perl或python来进行编译</strong>）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p><p><strong>可能遇到的错误</strong>：<strong>make *</strong> 没有指明目标并且找不到 makefile。 停止。问题很明了，<code>没有Makefile</code>，怎么办，原来是要<code>先./configure 一下，再make</code>**</p><hr><h3 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h3><p>这条命令来进行安装（当然<strong>有些软件需要先运行 <code>make check</code> 或 <code>make test</code> 来进行一些测试</strong>）。</p><p>如果安装失败可以使用<code>make clean</code>来<strong>清除编译产生的可执行文件及目标文件(object file，*.o)</strong>。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/qq_19004627/article/details/79090078" target="_blank" rel="noopener">linux无root权限安装软件</a></li><li><a href="https://www.tlanyan.me/work-with-linux-without-root-permission/" target="_blank" rel="noopener">linux下非root用户安装软件入门</a></li><li><a href="https://www.cnblogs.com/tinywan/p/7230039.html" target="_blank" rel="noopener">Linux 命令详解（三）./configure、make、make install 命令</a></li><li><a href="https://cnbin.github.io/blog/2015/06/22/linux-slash-configure-prefix-ming-ling/" target="_blank" rel="noopener">Linux ./configure –prefix 命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rename-批量修改文件名称</title>
      <link href="/posts/50712.html"/>
      <url>/posts/50712.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了用来<strong>修改文件名称的命令rename(不是系统自带的，需要下载)</strong>，相比于传统的<code>mv命令</code>，<code>rename</code>可以支持<strong>使用正则表达式来批量操作文件列表(可以使用通配符)</strong>；但是需要注意的是<strong>rename只能修改文件的名称，而不能修改目录的名称</strong>，但是<strong>mv却可以修改文件名称</strong>，只是不能支持批量操作而已，<strong>借助循环就可以达到批量替换的目的</strong>。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于课题的需要，要<strong>对很多文件的名称进行修改</strong>，然而每个单独进行修改会很麻烦，并且还希望<strong>只替代部分信息</strong>，比如<code>a_1.txt</code>，后面的<code>_1.txt</code>是还需要保留的信息。</p><hr><h2 id="mv命令修改"><a href="#mv命令修改" class="headerlink" title="mv命令修改"></a>mv命令修改</h2><p>mv命令是move的简写，原本是用来移动文件(相当于是剪切)，但是如果被移动文件和目标文件在同一个目录下就可以实现名称的修改，但是这个在单独修改每个文件名称时比较好用(也包括循环修改，其实也是每次只修改一个，只是加了循环而已)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前目录下的a_1.txt修改为b_1.txt</span></span><br><span class="line">mv ./a_1.txt ./b_1.txt</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="rename命令"><a href="#rename命令" class="headerlink" title="rename命令"></a>rename命令</h2><p>rename顾名思义就是直接修改名称的命令，这个命令是linux自带的命令，之前一直没有发现，最近遇到问题需要进行大规模修改的时候，直接搜索到这个命令可以更加方便地使用。</p><div class="note info"><p>rename有两个版本，一个是linux自带的，在功能不是很强大，在<code>/usr/bin/rename</code>中，和mv命令差不多，另一个是<code>perl语言的rename</code>，功能更加强大，但需要自己安装，后面使用的都是这个自己安装的rename命令。</p></div><h3 id="rename安装"><a href="#rename安装" class="headerlink" title="rename安装"></a>rename安装</h3><ul><li><p>下载安装包，从<a href="https://cpan.metacpan.org/authors/id/P/PE/PEDERST/" target="_blank" rel="noopener">这个链接下载</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载perl安装包</span></span><br><span class="line">wget https://cpan.metacpan.org/authors/id/P/PE/PEDERST/rename-1.9.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf rename-1.9.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"rename-1.9"</span></span><br><span class="line">perl <span class="string">"Makefile.PL"</span></span><br><span class="line">  Checking <span class="keyword">if</span> your kit is complete...</span><br><span class="line">  Looks good</span><br><span class="line">  Generating a Unix-style Makefile</span><br><span class="line">  Writing Makefile <span class="keyword">for</span> rename</span><br><span class="line">  Writing MYMETA.yml and MYMETA.json</span><br><span class="line">make</span><br><span class="line">  <span class="string">"/Share2/home/wangjb/usr/anaconda2/bin/perl"</span> <span class="string">"-Iblib/arch"</span> <span class="string">"-Iblib/lib"</span> bin/rename.PL bin/rename</span><br><span class="line">  Extracting rename</span><br><span class="line">  cp bin/rename blib/script/rename</span><br><span class="line">  <span class="string">"/Share2/home/wangjb/usr/anaconda2/bin/perl"</span> -MExtUtils::MY -e <span class="string">'MY-&gt;fixin(shift)'</span> -- blib/script/rename</span><br><span class="line">  Manifying 1 pod document</span><br><span class="line">make install</span><br><span class="line">  Manifying 1 pod document</span><br><span class="line">  Installing /Share2/home/wangjb/usr/anaconda2/man/man1/rename.1</span><br><span class="line">  Installing /Share2/home/wangjb/usr/anaconda2/bin/rename</span><br><span class="line">  Appending installation info to /Share2/home/wangjb/usr/anaconda2/lib/perl5/5.22.0/x86_64-linux-thread-multi/perllocal.pod</span><br></pre></td></tr></table></figure></li></ul><p>PS：<strong>安装直接将其安装在anaconda中了</strong></p><div class="note info"><ul><li>如果想<strong>指定安装路径</strong>可以在<code>perl &quot;Makefile.PL&quot;</code>的时候加上<code>INSTALL_BASE</code>( can be set to modify the base installation directory.)。eg: <code>perl &quot;Makefile.PL&quot; INSTALL_BASE=/usr/local</code></li><li>也可以直接使用cpan安装，具体的安装教程请参考<a href="https://stackoverflow.com/questions/22577767/get-the-perl-rename-utility-instead-of-the-built-in-rename" target="_blank" rel="noopener">这个链接</a></li></ul></div><hr><h3 id="rename格式"><a href="#rename格式" class="headerlink" title="rename格式"></a>rename格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  rename [OPTION]... PERLEXPR FILE...</span><br><span class="line">  Rename FILE(s) using PERLEXPR on each filename.</span><br><span class="line">  <span class="comment"># 另一种写法，感觉有点像sed命令的使用</span></span><br><span class="line">  rename [options] <span class="string">"s/oldname/newname/"</span> file</span><br></pre></td></tr></table></figure><ul><li>原字符串<code>oldname</code>：将要<strong>被替换的字符串</strong></li><li>目标字符串<code>newname</code>：原字符替换成的<strong>目标字符串</strong></li><li>文件<code>file</code>：指定要改变文件名的<strong>文件列表</strong></li></ul><div class="note info"><ul><li>上面的<code>oldname</code>和<code>newname</code>都支持<strong>正则表达式</strong></li><li><code>file</code>列表支持<strong>通配符</strong></li><li><a href="http://showteeth.tech/posts/37480.html">Linux通配符和正则表达式及其区别</a></li></ul></div><hr><h3 id="rename使用实例"><a href="#rename使用实例" class="headerlink" title="rename使用实例"></a>rename使用实例</h3><h4 id="替换文件名中特定字段"><a href="#替换文件名中特定字段" class="headerlink" title="替换文件名中特定字段"></a>替换文件名中特定字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_ab.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_ac.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_ad.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 2_aa.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件名中的a替换为b</span></span><br><span class="line"><span class="comment"># 后面语法的书写很像sed命令</span></span><br><span class="line"><span class="comment"># 默认只会替换第一个出现的字符，如2_aa.txt被修改为了2_ba.txt，第二个a没有被替换</span></span><br><span class="line">rename <span class="string">'s/a/b/'</span> *</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_bb.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_bc.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_bd.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 2_ba.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局替换</span></span><br><span class="line"><span class="comment"># 替换所有的模式</span></span><br><span class="line">rename <span class="string">'s/a/b/g'</span> *</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_bb.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_bc.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 1_bd.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  5 22:39 2_bb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合正则表达式进行替换</span></span><br><span class="line"><span class="comment"># 不仅将正则匹配的内容进行了替换，并且将1_也直接替换掉了</span></span><br><span class="line"><span class="comment"># 这里使用$1、$2表示匹配上的分组信息，而不是常规的\1、\2这种</span></span><br><span class="line">rename <span class="string">'s/1_(.)(.)/$2-$1/'</span> *</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 2_bb.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 b-b.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 c-b.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 d-b.txt</span><br></pre></td></tr></table></figure><div class="note info"><p>使用<strong>正则表达式</strong>进行替换的时候使用<code>$1`</code>$2<code>这种来**表示匹配上的分组信息**，这和之前常规的</code>\1<code>、</code>\2`不同，需要注意</p></div><hr><h4 id="修改文件后缀"><a href="#修改文件后缀" class="headerlink" title="修改文件后缀"></a>修改文件后缀</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件后缀由txt修改为sh</span></span><br><span class="line">rename <span class="string">'s/.txt/.sh/'</span> *</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 2_bb.sh</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 b-b.sh</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 c-b.sh</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 d-b.sh</span><br></pre></td></tr></table></figure><hr><h4 id="添加和删除后缀"><a href="#添加和删除后缀" class="headerlink" title="添加和删除后缀"></a>添加和删除后缀</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有文件的后缀删除</span></span><br><span class="line">rename <span class="string">'s/.sh//'</span> *</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 2_bb</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 b-b</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 c-b</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 d-b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给所有文件统一添加后缀txt</span></span><br><span class="line">rename <span class="string">'s/$/.txt/'</span> *</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 2_bb.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 b-b.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 c-b.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 0 Jun  6 05:52 d-b.txt</span><br></pre></td></tr></table></figure><hr><h2 id="修改文件夹"><a href="#修改文件夹" class="headerlink" title="修改文件夹"></a>修改文件夹</h2><p>关于文件夹的名称如果需要修改会比较麻烦，上面的<strong>rename支持修改文件的名称，但是不能支持修改目录的名称</strong>；而前面提到的<strong>mv不仅能够修改文件名称还能修目录名称(都是剪切然后粘贴的原理嘛)</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量修改文件夹的名称</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ls`;<span class="keyword">do</span> mv <span class="variable">$i</span> $(<span class="built_in">echo</span> <span class="variable">$i</span> |sed <span class="string">'s/LJ_mtDNA_590/LJ0590_fro_wbc_190310/'</span>);<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://einverne.github.io/post/2018/01/rename-files-batch.html" target="_blank" rel="noopener">每天学习一个命令: rename 批量修改文件名</a></li><li><a href="http://man.linuxde.net/rename" target="_blank" rel="noopener">rename命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter版的IGV之igv-jupyter</title>
      <link href="/posts/53124.html"/>
      <url>/posts/53124.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章<strong>初步探索了igv-jupyter的配置和使用</strong>，后续使用可以添加。</p></div><a id="more"></a><h2 id="IGV"><a href="#IGV" class="headerlink" title="IGV"></a>IGV</h2><p>整合基因组浏览器(IGV)是一种高性能的可视化工具，用来交互式地探索大型综合基因组数据。IGV一直以来就是一个桌面版的软件，使用需要下载安装，但是一般的bam文件都在服务器上，这样使用起来就比较麻烦，因此<a href="https://github.com/igvteam" target="_blank" rel="noopener">igvteam</a>相继推出了<a href="https://github.com/igvteam/igv.js" target="_blank" rel="noopener">igv.js</a>以及<a href="https://github.com/igvteam/igv-jupyter" target="_blank" rel="noopener">igv-jupyter</a>用于在线查看，方便快捷。这是一篇对igv-jupyter的使用进行探索的文章。</p><hr><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>使用如下命令进行安装和下载：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pip进行安装</span></span><br><span class="line">pip install igv-jupyter</span><br></pre></td></tr></table></figure><p></p><p>安装完成之后结合到nbextension作为插件使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To install to configuration in your home directory</span></span><br><span class="line">jupyter serverextension <span class="built_in">enable</span> --py igv</span><br><span class="line">jupyter nbextension install --py igv</span><br><span class="line">jupyter nbextension <span class="built_in">enable</span> --py igv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我用的是anaconda安装的，需要使用这个</span></span><br><span class="line"><span class="comment"># 实际上我都尝试了，使用上面的命令不管用</span></span><br><span class="line"><span class="comment"># If using a virtual environment</span></span><br><span class="line">jupyter serverextension <span class="built_in">enable</span> --py igv --sys-prefix</span><br><span class="line">jupyter nbextension install --py igv --sys-prefix</span><br><span class="line">jupyter nbextension <span class="built_in">enable</span> --py igv --sys-prefix</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于安装，还可以参考这篇文章：<a href="http://showteeth.tech/posts/42671.html">Python系列之从github源码安装python包</a></p></div><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>按照官网的示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入igv包</span></span><br><span class="line">import igv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个igv broswer对象</span></span><br><span class="line"><span class="comment"># 该对象会显示hg19的参考基因组</span></span><br><span class="line">b = igv.Browser(&#123;<span class="string">"genome"</span>: <span class="string">"hg19"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示这个对象</span></span><br><span class="line"><span class="comment"># 具体的显示出桌面版的界面</span></span><br><span class="line">b.show()</span><br></pre></td></tr></table></figure><p></p><p>创建对象时导入的信息可以查看<a href="https://github.com/igvteam/igv.js/wiki/Browser-Configuration-2.0" target="_blank" rel="noopener">igv.js documentation</a></p><hr><h3 id="track"><a href="#track" class="headerlink" title="track"></a>track</h3><p>实例的track：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b.load_track(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Segmented CN"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://data.broadinstitute.org/igvdata/test/igv-web/segmented_data_080520.seg.gz"</span>,</span><br><span class="line">        <span class="string">"format"</span>: <span class="string">"seg"</span>,</span><br><span class="line">        <span class="string">"indexed"</span>: False</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p></p><p>这一步正常情况下会出现<code>OK</code>，如果出错可能会出现<code>IGV Browser not ready</code>，出现这个问题是因为igv还没有完全配置好，可能是上面的结合nbextension作为插件使用这一步的问题，需要注意使用相对应的情况，如果实在不能解决可以查看<a href="https://github.com/igvteam/igv-jupyter/issues/23" target="_blank" rel="noopener">这个issue</a>中<strong>创建新的虚拟环境安装的过程，亲测可用</strong>。</p><div class="note info"><ul><li>注意：是<strong>先调用<code>b.show()</code>之后再<code>load track</code></strong>，然后就可以在前面<code>b.show()</code>的结果中看到新添加的track，不用新调用<code>b.show()</code></li><li>自定义track需要按照这个说明：<a href="https://github.com/igvteam/igv.js/wiki/Tracks-2.0" target="_blank" rel="noopener">igv.js documentation</a></li><li><a href="https://github.com/igvteam/igv-jupyter/tree/master/examples" target="_blank" rel="noopener">定义track的各种示例</a></li></ul></div><p>实际效果如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/igv_example.png" alt="igv_example.png"></p><hr><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>####放大或者缩小<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缩小</span></span><br><span class="line">b.zoom_in()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放大</span></span><br><span class="line">b.zoom_out()</span><br></pre></td></tr></table></figure><p></p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索chr1染色体的3000-4000区域</span></span><br><span class="line">b.search(<span class="string">'chr1:3000-4000'</span>)</span><br></pre></td></tr></table></figure><h4 id="跳转到特定的基因"><a href="#跳转到特定的基因" class="headerlink" title="跳转到特定的基因"></a>跳转到特定的基因</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.search(<span class="string">'myc'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>目前跳转到特定的基因目前只支持<code>hg38</code>、<code>hg19</code>、<code>mm10</code>，如果想自定义搜索服务需要查看<a href="https://github.com/igvteam/igv.js/wiki/Browser-Configuration-2.0#search-object-details" target="_blank" rel="noopener">igv.js documentation</a></p></div><h4 id="输出SVG"><a href="#输出SVG" class="headerlink" title="输出SVG"></a>输出SVG</h4><p>保存当前的视图到SVG<strong>需要如下两个命令</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.get_svg()</span><br><span class="line"></span><br><span class="line">b.display_svg()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/igvteam/igv-jupyter" target="_blank" rel="noopener">igv-jupyter的github</a></li><li><a href="https://github.com/igvteam/igv-jupyter/tree/master/examples" target="_blank" rel="noopener">定义track的各种示例</a></li><li><a href="https://github.com/igvteam/igv.js/wiki" target="_blank" rel="noopener">igv.js的wiki文档</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之从github源码安装python包</title>
      <link href="/posts/42671.html"/>
      <url>/posts/42671.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了<strong>使用github源码</strong>以及 <strong><code>setup.py</code>安装</strong>Python包的方法，主要是作为直接使用 <strong><code>pip install package name</code></strong>的补充。</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近想安装一个Python包：igv-jupyter，<a href="https://github.com/igvteam/igv-jupyter" target="_blank" rel="noopener">github链接</a>，github上提供的安装方法如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pip install igv-jupyter</span><br><span class="line"></span><br><span class="line"><span class="comment"># To install to configuration in your home directory</span></span><br><span class="line">jupyter serverextension <span class="built_in">enable</span> --py igv</span><br><span class="line">jupyter nbextension install --py igv</span><br><span class="line">jupyter nbextension <span class="built_in">enable</span> --py igv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># If using a virtual environment</span></span><br><span class="line">jupyter serverextension <span class="built_in">enable</span> --py igv --sys-prefix</span><br><span class="line">jupyter nbextension install --py igv --sys-prefix</span><br><span class="line">jupyter nbextension <span class="built_in">enable</span> --py igv --sys-prefix</span><br></pre></td></tr></table></figure><p></p><p>按照上述方法安装<strong>总是报错</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pip install igv-jupyter</span><br><span class="line">Collecting igv-jupyter</span><br><span class="line">  WARNING: Retrying (Retry(total=4, connect=None, <span class="built_in">read</span>=None, redirect=None, status=None)) after connection broken by <span class="string">'NewConnectionError('</span>&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x7f74f867a630&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable<span class="string">')'</span>: /simple/igv-jupyter/</span><br><span class="line">  WARNING: Retrying (Retry(total=3, connect=None, <span class="built_in">read</span>=None, redirect=None, status=None)) after connection broken by <span class="string">'NewConnectionError('</span>&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x7f74f867a6d8&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable<span class="string">')'</span>: /simple/igv-jupyter/</span><br><span class="line">  WARNING: Retrying (Retry(total=2, connect=None, <span class="built_in">read</span>=None, redirect=None, status=None)) after connection broken by <span class="string">'NewConnectionError('</span>&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x7f74f867a4a8&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable<span class="string">')'</span>: /simple/igv-jupyter/</span><br><span class="line">  WARNING: Retrying (Retry(total=1, connect=None, <span class="built_in">read</span>=None, redirect=None, status=None)) after connection broken by <span class="string">'NewConnectionError('</span>&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x7f74f867a518&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable<span class="string">')'</span>: /simple/igv-jupyter/</span><br><span class="line">  WARNING: Retrying (Retry(total=0, connect=None, <span class="built_in">read</span>=None, redirect=None, status=None)) after connection broken by <span class="string">'NewConnectionError('</span>&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x7f74f867a668&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable<span class="string">')'</span>: /simple/igv-jupyter/</span><br><span class="line">  ERROR: Could not find a version that satisfies the requirement igv-jupyter (from versions: none)</span><br><span class="line">ERROR: No matching distribution found <span class="keyword">for</span> igv-jupyter</span><br></pre></td></tr></table></figure><p></p><blockquote><p>后来发现是实验室的网坏掉了，不能上外网，所以下载不了。。。。。</p></blockquote><hr><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="通过pip安装"><a href="#通过pip安装" class="headerlink" title="通过pip安装"></a>通过pip安装</h3><div class="note info"><p>pip install 支持很多方式的安装，如git、svn等，具体的讲解说明<a href="https://pip.pypa.io/en/stable/reference/pip_install/#id18" target="_blank" rel="noopener">这个文档</a>都有</p></div><p>上述办法不能安装，但是源代码在github上啊，所以就想看看能不能<strong>直接使用github源码进行安装</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pip安装github源代码</span></span><br><span class="line">pip install git+git://github.com/igvteam/igv-jupyter.git</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>这里直接复制的github链接为<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:igvteam/igv-jupyter.git<code>，但是好像不能正确运行</code>ERROR: Invalid requirement: <a href="mailto:&#39;git+git@github.com" target="_blank" rel="noopener">&#39;git+git@github.com</a>:igvteam/igv-jupyter.git’<code>，需要将前面的修改为</code>git://github.com/`。</p></div><hr><h3 id="通过setup-py安装"><a href="#通过setup-py安装" class="headerlink" title="通过setup.py安装"></a>通过setup.py安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先clone到本地</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/igvteam/igv-jupyter.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行setup.py</span></span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><div class="note info"><p>注意不要使用<code>sudo</code>，因为<strong>使用<code>sudo</code>之后会使用系统自带的python版本</strong>，我的是2.7，但是我的2.7没有安装jupyter，所以会报错；<strong>不使用<code>sudo</code>就会使用自己安装的环境中的3.7</strong>。</p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/15268953/how-to-install-python-package-from-github" target="_blank" rel="noopener">How to install Python package from GitHub? [duplicate]</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之numpy-数组与矩阵运算(五)：常用函数汇总</title>
      <link href="/posts/15933.html"/>
      <url>/posts/15933.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章汇总了numpy中常用的方法，便于查询使用。</p></div><a id="more"></a><h2 id="按作用划分"><a href="#按作用划分" class="headerlink" title="按作用划分"></a>按作用划分</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul><li>arange</li><li>array</li><li>copy</li><li>empty</li><li>empty_like</li><li>eye</li><li>fromfile</li><li>fromfunction</li><li>identity</li><li>linspace</li><li>logspace</li><li>mgrid</li><li>ogrid</li><li>ones</li><li>ones_like</li><li>r</li><li>zeros</li><li>zeros_like</li></ul><div><br><a class="btn" href="http://showteeth.tech/posts/24507.html"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-数组创建</a><br></div><hr><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>array split</li><li>column stack</li><li>concatenate</li><li>diagonal</li><li>dsplit</li><li>dstack</li><li>hsplit</li><li>hstack</li><li>item</li><li>newaxis</li><li>ravel</li><li>repeat</li><li>reshape</li><li>resize</li><li>squeeze</li><li>swapaxes</li><li>take</li><li>transpose</li><li>vsplit</li><li>vstack</li></ul><div><br><a class="btn" href="http://showteeth.tech/posts/35386.html"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-切片、截取和堆叠</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/24353.html"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-广播、迭代以及数组相关操作</a><br></div><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>argmax</li><li>argmin</li><li>argsort</li><li>amax</li><li>amin</li><li>ptp</li><li>searchsorted</li><li>sort</li></ul><div><br><a class="btn" href="http://showteeth.tech/posts/54407.html"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-常用函数</a><br></div><hr><h3 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h3><ul><li>all</li><li>any</li><li>nonzero</li><li>where</li></ul><div><br><a class="btn" href="http://showteeth.tech/posts/54407.html"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-常用函数</a><br></div><hr><h3 id="基本统计"><a href="#基本统计" class="headerlink" title="基本统计"></a>基本统计</h3><table><thead><tr><th width="30%">统计函数</th><th width="70%">含义</th></tr></thead><tbody><tr><td>average/mean</td><td>平均值。其中 average 还可以用 weight 参数指定权重</td></tr><tr><td>median</td><td>中位数</td></tr><tr><td>diff</td><td>一阶差分</td></tr><tr><td>cumsum/cumprod</td><td>累和／累积</td></tr><tr><td>sum/prod</td><td>求和 / 求积</td></tr><tr><td>std/var</td><td>标准差 / 方差</td></tr></tbody></table><div><br><a class="btn" href="http://showteeth.tech/posts/54407.html"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-常用函数</a><br></div><hr><h3 id="基本线性代数"><a href="#基本线性代数" class="headerlink" title="基本线性代数"></a>基本线性代数</h3><ul><li>cross</li><li>dot</li><li>outer</li><li>svd</li><li>vdot</li></ul><hr><h2 id="按元素个数划分"><a href="#按元素个数划分" class="headerlink" title="按元素个数划分"></a>按元素个数划分</h2><h3 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h3><p>直接从元素操作中移植的函数，比如幂指函数等等。一元函数调用形式是 <code>np.function(arr)</code> 简表如下：</p><table><thead><tr><th width="50%">一元函数</th><th width="50%">含义</th></tr></thead><tbody><tr><td>abs/fabs</td><td>求模。对于非复数矩阵，fabs更快。</td></tr><tr><td>sqrt/square</td><td>平方根/平方</td></tr><tr><td>exp</td><td>指数</td></tr><tr><td>log/log10/log2/log1p</td><td>对数：自然对数/10/2为底，以及以2为底的log(1+x)</td></tr><tr><td>sign</td><td>正负号判断函数：返回 1, 0, 或者 -1</td></tr><tr><td>ceil/floor</td><td>向上取整/向下取整</td></tr><tr><td>rint</td><td>四舍五入到整数</td></tr><tr><td>isnan</td><td>返回关于非数值（np.nan）判断的布尔型数组</td></tr><tr><td>isfinite/isinf</td><td>判断非无限大值/无限大值</td></tr><tr><td>sin/cos/tan</td><td>三角函数</td></tr><tr><td>arcsin/arccos/arctan</td><td>反三角函数</td></tr><tr><td>sinh/cosh/tanh/arcsinh/arccosh/arctanh</td><td>以上三角函数的双曲形式</td></tr></tbody></table><hr><h3 id="二元函数"><a href="#二元函数" class="headerlink" title="二元函数"></a>二元函数</h3><p>以及矩阵的二元函数，调用形式是 <code>np.function(x, y)</code>:<br><table><thead><tr><th width="50%">二元函数</th><th width="50%">含义</th></tr></thead><tbody><tr><td>add/substract/multiply</td><td>对应元素相加/相减/相乘</td></tr><tr><td>divide/floor_divide</td><td>对应元素除法及向下整除法（弃余数）</td></tr><tr><td>power</td><td>计算 x(i,j)^y(i,j)</td></tr><tr><td>maximum/fmax</td><td>元素级的最大值。fmax 表示忽略 NaN</td></tr><tr><td>&nbsp;</td><td><em>注：在比较含有 NaN 的矩阵时可能出现问题，我尚不清楚 NumPy 做出了怎样的改变。</em></td></tr><tr><td>minimum/fmin</td><td>仿上</td></tr><tr><td>mod</td><td>取余</td></tr><tr><td>copysign</td><td>将y的符号传递给x中的对应元素</td></tr></tbody></table></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wklchris.github.io/Py3-numpy.html" target="_blank" rel="noopener">Python科学计算：numpy</a></li><li><a href="https://mp.weixin.qq.com/s/5TB0_7gcv5CHV5KyRHGD7Q" target="_blank" rel="noopener">Numpy详细教程</a></li></ul><h2><a href="#" class="headerlink"></a><br></h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-在字符串中查找所有子字符串</title>
      <link href="/posts/31648.html"/>
      <url>/posts/31648.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了如何使用python查找子串在字符串中所有出现位置的索引，主要是使用了迭代器<code>re.finditer</code>以及<code>find</code>函数；相比之下，<strong>使用迭代器</strong><code>re.finditer</code><strong>速度更快</strong>、<strong>代码更加简洁</strong>，但是<strong>移植性不强</strong>，不能将框架移植到shell中，而<code>find</code>函数比迭代器<code>re.finditer</code><strong>慢一点</strong>，但是<strong>框架移植性强</strong>。</p></div><a id="more"></a><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在字符串中<strong>查找所有子字符串</strong>，而不是第一次出现的字符串。</p><p>如果想使用python在字符串中查找符合条件的子字符串，可以使用的函数包括<a href="https://www.runoob.com/python/att-string-find.html" target="_blank" rel="noopener">find</a>、<a href="https://www.runoob.com/python/att-string-index.html" target="_blank" rel="noopener">index</a>。</p><p><code>index</code>方法和<code>find</code>方法基本相同，区别在于:<strong>使用index</strong>，如果子字符串不在字符串中，则会<strong>报错</strong>，而<strong>使用find</strong>方法这种情况会<strong>返回-1</strong>，两者返回的都是子字符串<strong>第一次出现的索引位置</strong>，这也是两个方法最大的缺点，不能<mark>直接</mark>查找所有符合条件的子字符串。</p><p><code>index</code>和<code>find</code>函数形式：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find函数形式</span></span><br><span class="line">S.find(sub[, start[, end]]) -&gt; int</span><br><span class="line"></span><br><span class="line"><span class="comment"># index函数形式</span></span><br><span class="line">S.index(sub[, start[, end]]) -&gt; int</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>find</code>和<code>index</code>虽然<strong>没有直接查找</strong>所有子字符串的方法，但是可以<mark>利用其中的start参数</mark>进行递归查找</p></div><hr><h2 id="使用re-finditer"><a href="#使用re-finditer" class="headerlink" title="使用re.finditer"></a>使用re.finditer</h2><p>作用和<code>re.findall</code>类似，但是<code>findall</code>会<strong>返回所有匹配的字符串</strong>，并将其<strong>存为一个列表</strong>，而<code>finditer</code>则并<strong>不直接返回这些字符串</strong>，而是返回一个迭代器，里面包括了<strong>匹配的字符串</strong>以及<strong>匹配的字符串开始和结束的索引位置</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">'aaaabbaaaabbaaaa'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(<span class="string">r'aaaa'</span> , s ):</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">4</span>), match=<span class="string">'aaaa'</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">6</span>, <span class="number">10</span>), match=<span class="string">'aaaa'</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">12</span>, <span class="number">16</span>), match=<span class="string">'aaaa'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出匹配上的字符串</span></span><br><span class="line">s=<span class="string">'aaaabbaaaabbaaaa'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(<span class="string">r'aaaa'</span> , s ):</span><br><span class="line">    <span class="keyword">print</span> (i.group())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别输出开始和结束索引</span></span><br><span class="line">s=<span class="string">'aaaabbaaaabbaaaa'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(<span class="string">r'aaaa'</span> , s ):</span><br><span class="line">    <span class="keyword">print</span> (i.start(),i.end())</span><br><span class="line"><span class="comment"># 输出索引位置</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">12</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p></p><p>如果需要允许<strong>滑动匹配</strong>，可以使用如下的方式：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">'aaaabbaaaabbaaaa'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(<span class="string">r'(?=aa)'</span> , s ):</span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 这时的匹配结果为空字符串</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">0</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">1</span>, <span class="number">1</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">2</span>, <span class="number">2</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">6</span>, <span class="number">6</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">7</span>, <span class="number">7</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">8</span>, <span class="number">8</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">12</span>, <span class="number">12</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">13</span>, <span class="number">13</span>), match=<span class="string">''</span>&gt;</span><br><span class="line">&lt;re.Match object; span=(<span class="number">14</span>, <span class="number">14</span>), match=<span class="string">''</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p><strong>缺点</strong>：</p><ul><li>依赖于python的re模块，如果不是在python中(shell中也有类似的函数)，拓展性不是很强</li></ul><p><strong>优点</strong>：</p><ul><li>速度快</li></ul><hr><h2 id="使用find函数递归查找"><a href="#使用find函数递归查找" class="headerlink" title="使用find函数递归查找"></a>使用find函数递归查找</h2><p><strong>函数形式</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find函数形式</span></span><br><span class="line">S.find(sub[, start[, end]]) -&gt; int</span><br></pre></td></tr></table></figure><p></p><p>可以通过不断更新start参数来实现递归查找：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">'bbaaaabbaaaabbaaaa'</span></span><br><span class="line">final_li=[]</span><br><span class="line">start=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    index=s.find(<span class="string">'aaaa'</span>,start)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    final_li.append(index)</span><br><span class="line">    start= index+len(<span class="string">'aaaa'</span>)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">final_li </span><br><span class="line">  [<span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要查询带有滑框的结果，可以修改每次start迭代的值</span></span><br><span class="line">s=<span class="string">'bbaaaabbaaaabbaaaa'</span></span><br><span class="line">final_li=[]</span><br><span class="line">start=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    index=s.find(<span class="string">'aa'</span>,start)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    final_li.append(index)</span><br><span class="line">    <span class="comment"># 这里修改为+1即可实现</span></span><br><span class="line">    start= index+<span class="number">1</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">final_li </span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure><p></p><p><strong>缺点</strong>：</p><ul><li>速度没有前面的<code>re.finditer</code>快</li></ul><p><strong>优点</strong>：</p><ul><li>可移植性强，可以很轻松地将框架移植到shell中</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/4664850/how-to-find-all-occurrences-of-a-substring" target="_blank" rel="noopener">How to find all occurrences of a substring?</a></li><li><a href="https://stackoverflow.com/questions/7172933/calculate-difference-between-adjacent-items-in-a-python-list" target="_blank" rel="noopener">Calculate difference between adjacent items in a python list</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之numpy-数组与矩阵运算(四)：常用函数</title>
      <link href="/posts/54407.html"/>
      <url>/posts/54407.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了numpy中常用的函数，主要包括<strong>四舍五入相关</strong>、<strong>统计函数</strong>、<strong>排序函数</strong>和<strong>查找函数</strong>。<code>np.around()</code>、<code>np.floor()</code>、<code>np.ceil()</code>、<code>np.amin()</code>、<code>np.argmin()</code>、<code>np.amax()</code>、<code>np.ptp()</code>、<code>np.percentile()</code>、<code>np.median()</code>、<code>np.average()</code>、<code>np.std()</code>、<code>np.sort()</code>、<code>np.argsort()</code>、<code>np.lexsort()</code>、<code>np.nonzero()</code>、<code>np.where()</code>、<code>np.extract()</code>。</p></div><a id="more"></a><h2 id="四舍五入相关"><a href="#四舍五入相关" class="headerlink" title="四舍五入相关"></a>四舍五入相关</h2><p>相关函数汇总：<br><table><tr><th width="50%">函数</th><th width="50%">说明</th></tr><tr><td><code>np.around(a, decimals=0, out=None)</code></td><td>四舍五入，注意如果是x.5这种情况就会约到最近的偶数，其他情况就是正常的四舍五入</td></tr><tr><td><code>np.floor(*args, **kwargs)</code></td><td>不进行四舍五入，直接向下取整，得到邻近的最小整数</td></tr><tr><td><code>np.ceil(*args, **kwargs)</code></td><td>不进行四舍五入，直接向上取整，得到邻近的最大整数</td></tr></table></p><h3 id="四舍五入-np-around"><a href="#四舍五入-np-around" class="headerlink" title="四舍五入-np.around()"></a>四舍五入-np.around()</h3><p><strong>作用</strong>：四舍五入，和round函数类似，但是需要注意<mark>如果是<code>x.5</code>这种情况就会<strong>约到最近的偶数</strong>，其他情况就是<strong>正常的四舍五入</strong></mark></p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.around(a, decimals=<span class="number">0</span>, out=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># a：数组或者列表等</span></span><br><span class="line"><span class="comment"># decimals：保留的小数点位数，默认为0, 如果为负，整数将四舍五入到小数点左侧的位置</span></span><br><span class="line"><span class="comment"># out：输出的数组</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对列表进行四舍五入</span></span><br><span class="line">np.around([<span class="number">0.37</span>, <span class="number">1.64</span>])</span><br><span class="line">  array([<span class="number">0.</span>, <span class="number">2.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留一位小数</span></span><br><span class="line">np.around([<span class="number">0.37</span>, <span class="number">1.64</span>], decimals=<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">0.4</span>, <span class="number">1.6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是.5结束，会约到最近的小数</span></span><br><span class="line"><span class="comment"># 这个需要注意</span></span><br><span class="line"><span class="comment"># 如果不是.5，就是正常的四舍五入</span></span><br><span class="line">np.around([<span class="number">.5</span>, <span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4.5</span>])</span><br><span class="line">  array([<span class="number">0.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">4.</span>, <span class="number">4.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将0.5改为0.6，正常的四舍五入</span></span><br><span class="line">np.around([<span class="number">.6</span>, <span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4.5</span>])</span><br><span class="line">  array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">4.</span>, <span class="number">4.</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="向下取整-np-floor"><a href="#向下取整-np-floor" class="headerlink" title="向下取整-np.floor()"></a>向下取整-np.floor()</h3><p><strong>作用</strong>：不进行四舍五入，得到数字邻近的最小整数</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.floor(*args, **kwargs)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接操作列表</span></span><br><span class="line">np.floor([<span class="number">-1.7</span>, <span class="number">-1.5</span>, <span class="number">-0.2</span>, <span class="number">0.2</span>, <span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">2.0</span>])</span><br><span class="line">  array([<span class="number">-2.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作数组</span></span><br><span class="line">a = np.array([<span class="number">-1.7</span>, <span class="number">-1.5</span>, <span class="number">-0.2</span>, <span class="number">0.2</span>, <span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">2.0</span>])</span><br><span class="line"><span class="comment"># 1.7向下取整之后得到1，而不是四舍五入得到2</span></span><br><span class="line">np.floor(a)</span><br><span class="line">  array([<span class="number">-2.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="向上取整-np-ceil"><a href="#向上取整-np-ceil" class="headerlink" title="向上取整-np.ceil()"></a>向上取整-np.ceil()</h3><p><strong>作用</strong>：也不进行四舍五入，直接向上取整，和floor作用相反</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.ceil(*args, **kwargs)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接操作列表</span></span><br><span class="line">np.ceil([<span class="number">-1.7</span>, <span class="number">-1.5</span>, <span class="number">-0.2</span>, <span class="number">0.2</span>, <span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">2.0</span>])</span><br><span class="line">  array([<span class="number">-1.</span>, <span class="number">-1.</span>, <span class="number">-0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作数组</span></span><br><span class="line">a = np.array([<span class="number">-1.7</span>, <span class="number">-1.5</span>, <span class="number">-0.2</span>, <span class="number">0.2</span>, <span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">2.0</span>])</span><br><span class="line"><span class="comment"># 不进行取整，而是得到邻近的最大整数</span></span><br><span class="line">np.ceil(a)</span><br><span class="line">  array([<span class="number">-1.</span>, <span class="number">-1.</span>, <span class="number">-0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>常用的统计函数汇总：<br><table><tr><th width="50%">函数</th><th width="50%">说明</th></tr><tr><td>np.amin(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;)</td><td>整个数组或者某一维的最小值</td></tr><tr><td>np.argmin(a, axis=None, out=None)</td><td>数组或者某一维最小值的索引</td></tr><tr><td>np.amax(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;)</td><td>整个数组或者某一维的最大值</td></tr><tr><td>np.argmax(a, axis=None, out=None)</td><td>数组或者某一维最大值的索引</td></tr><tr><td>np.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;)</td><td>整个数组或者某一维的极差</td></tr><tr><td>np.percentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=False)</td><td>整个数组或者某一维的百分位数</td></tr><tr><td>np.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)</td><td>数组或者某一维的中位数</td></tr><tr><td>np.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)</td><td>数组或者某一维的平均数</td></tr><tr><td>np.average(a, axis=None, weights=None, returned=False)</td><td>数组或者某一维的加权平均</td></tr><tr><td>np.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)</td><td>数组或者某一维的标准差</td></tr><tr><td>np.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)</td><td>数组或者某一维的方差</td></tr></table></p><h3 id="数组或者某一维的最小值-np-amin"><a href="#数组或者某一维的最小值-np-amin" class="headerlink" title="数组或者某一维的最小值-np.amin()"></a>数组或者某一维的最小值-np.amin()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.amin(a, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的最小值；0表示每一列的最小值；1表示每一行的最小值</span></span><br><span class="line"><span class="comment"># keepdims：保持原始数组的维度</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2行2列的数组</span></span><br><span class="line">a = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定axis，默认是这个数组最小</span></span><br><span class="line">np.amin(a)</span><br><span class="line">  <span class="number">0</span></span><br><span class="line"><span class="comment"># 指定axis=0，表示对每列取最小</span></span><br><span class="line">np.amin(a,axis=<span class="number">0</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 指定axis=1，表示对每行取最小</span></span><br><span class="line">np.amin(a,axis=<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="数组或者某一维最小值的索引-np-argmin"><a href="#数组或者某一维最小值的索引-np-argmin" class="headerlink" title="数组或者某一维最小值的索引-np.argmin()"></a>数组或者某一维最小值的索引-np.argmin()</h3><p>上面的函数<code>np.amin()</code>返回的是数组或某一维最小值的<strong>数值</strong>，这里则会返回数组或某一维最小值的<strong>索引</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.argmin(a, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的最小值；0表示每一列的最小值；1表示每一行的最小值</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3行2列的数组</span></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>) + <span class="number">10</span></span><br><span class="line">  array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">         [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=None，表示整个数组最小值的索引</span></span><br><span class="line">  <span class="number">0</span> <span class="comment"># 最小值为10，索引为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=0，表示每列</span></span><br><span class="line">np.argmin(a,axis=<span class="number">0</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=1，表示每行</span></span><br><span class="line">np.argmin(a,axis=<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="数组或者某一维的最大值-np-amax"><a href="#数组或者某一维的最大值-np-amax" class="headerlink" title="数组或者某一维的最大值-np.amax()"></a>数组或者某一维的最大值-np.amax()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.amax(a, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的最小值；0表示每一列的最小值；1表示每一行的最小值</span></span><br><span class="line"><span class="comment"># keepdims：保持原始数组的维度</span></span><br></pre></td></tr></table></figure><p></p><p>用法和前面的<a href="#%E6%95%B0%E7%BB%84%E6%88%96%E8%80%85%E6%9F%90%E4%B8%80%E7%BB%B4%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-npamin">np.amin</a>类似</p><hr><h3 id="数组或者某一维的极差-np-ptp"><a href="#数组或者某一维的极差-np-ptp" class="headerlink" title="数组或者某一维的极差-np.ptp()"></a>数组或者某一维的极差-np.ptp()</h3><p>如果想要得到 <strong>(整个或者某一维)数组最大值和最小值的差值(极差)</strong>，可以使用<code>np.ptp()</code></p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.ptp(a, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>, keepdims=&lt;no value&gt;)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的极差；0表示每一列的极差；1表示每一行的极差</span></span><br><span class="line"><span class="comment"># keepdims：保持原始数组的维度</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 整个数组的极差</span></span><br><span class="line">np.ptp(a)</span><br><span class="line">  <span class="number">3</span></span><br><span class="line"><span class="comment"># 每一列的极差</span></span><br><span class="line">np.ptp(a,axis=<span class="number">0</span>)</span><br><span class="line">  array([<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 每一行的极差</span></span><br><span class="line">np.ptp(a,axis=<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="数组或者某一维的百分位数-np-percentile"><a href="#数组或者某一维的百分位数-np-percentile" class="headerlink" title="数组或者某一维的百分位数-np.percentile()"></a>数组或者某一维的百分位数-np.percentile()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.percentile(a, q, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>, overwrite_input=<span class="keyword">False</span>, interpolation=<span class="string">'linear'</span>, keepdims=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># q：百分位数，0-100范围内的，不用写成百分比</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的百分位数；0表示每一列的百分位数；1表示每一行的百分位数</span></span><br><span class="line"><span class="comment"># keepdims：保持原始数组的维度</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">  array([[<span class="number">10</span>,  <span class="number">7</span>,  <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 50%分位数，相当于中位数</span></span><br><span class="line">np.percentile(a, <span class="number">50</span>)</span><br><span class="line">  <span class="comment"># 3 + 4 /2</span></span><br><span class="line">  <span class="number">3.5</span></span><br><span class="line"><span class="comment"># 对列求50%分位数</span></span><br><span class="line">np.percentile(a,<span class="number">50</span>,axis=<span class="number">0</span>)</span><br><span class="line">  array([<span class="number">6.5</span>, <span class="number">4.5</span>, <span class="number">2.5</span>])</span><br><span class="line"><span class="comment"># 对行求50%分位数</span></span><br><span class="line">np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">7.</span>, <span class="number">2.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持原始数组的维度</span></span><br><span class="line">np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>,keepdims=<span class="keyword">True</span>)</span><br><span class="line">  array([[<span class="number">7.</span>],</span><br><span class="line">         [<span class="number">2.</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="数组或者某一维的中位数-np-median"><a href="#数组或者某一维的中位数-np-median" class="headerlink" title="数组或者某一维的中位数-np.median()"></a>数组或者某一维的中位数-np.median()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.median(a, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>, overwrite_input=<span class="keyword">False</span>, keepdims=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的中位数；0表示每一列的中位数；1表示每一行的中位数</span></span><br><span class="line"><span class="comment"># keepdims：保持原始数组的维度</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">  array([[<span class="number">10</span>,  <span class="number">7</span>,  <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 整个函数的中位数，相当于50%百分位数</span></span><br><span class="line">np.median(a)</span><br><span class="line">  <span class="number">3.5</span></span><br><span class="line"><span class="comment"># 对列求中位数，和上面百分位数的结果相同</span></span><br><span class="line">np.median(a,axis=<span class="number">0</span>)</span><br><span class="line">  array([<span class="number">6.5</span>, <span class="number">4.5</span>, <span class="number">2.5</span>])</span><br><span class="line"><span class="comment"># 对行求中位数，和上面百分位数的结果相同</span></span><br><span class="line">np.median(a,axis=<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">7.</span>, <span class="number">2.</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="数组或者某一维的加权平均-np-average"><a href="#数组或者某一维的加权平均-np-average" class="headerlink" title="数组或者某一维的加权平均-np.average()"></a>数组或者某一维的加权平均-np.average()</h3><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。例如：考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和<strong>除以权重的和</strong>，来计算加权平均值。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.average(a, axis=<span class="keyword">None</span>, weights=<span class="keyword">None</span>, returned=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示对整个数组进行加权平均；0表示对每一列进行加权平均；1表示对每一行进行加权平均</span></span><br><span class="line"><span class="comment"># weights：权重，可以是数组，要和axis对应才行</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) </span><br><span class="line"><span class="comment"># weight数组</span></span><br><span class="line">wts = np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]) </span><br><span class="line"><span class="comment"># 以weight数组作为weight对数组进行加权平均 </span></span><br><span class="line">np.average(a,weights=wts)</span><br><span class="line">  <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">data = np.arange(<span class="number">6</span>).reshape((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="comment"># 对列赋予权值，得到行的加权平均</span></span><br><span class="line"><span class="comment"># 注意这里的列为2，所以传入的维度也是2</span></span><br><span class="line">np.average(data, axis=<span class="number">1</span>, weights=[<span class="number">1.</span>/<span class="number">4</span>, <span class="number">3.</span>/<span class="number">4</span>])</span><br><span class="line">  array([<span class="number">0.75</span>, <span class="number">2.75</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="comment"># 如果将传入维度修改为3，则会报错</span></span><br><span class="line">np.average(data,axis=<span class="number">1</span>,weights=[<span class="number">1.0</span>/<span class="number">4</span>,<span class="number">3.0</span>/<span class="number">4</span>,<span class="number">1.0</span>/<span class="number">4</span>])</span><br><span class="line">  ValueError: Length of weights <span class="keyword">not</span> compatible <span class="keyword">with</span> specified axis.</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>使用注意事项：</p><ul><li><strong>权重</strong>可以是数组，也可以是列表，但是<strong>维度一定要和axis对应</strong>，例如，对行加权，那么指定的权重数组或列表长度一定要和列的长度匹配，不然就会报错。</li></ul></div><hr><h3 id="数组或者某一维的标准差-np-std"><a href="#数组或者某一维的标准差-np-std" class="headerlink" title="数组或者某一维的标准差-np.std()"></a>数组或者某一维的标准差-np.std()</h3><p>函数形式：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.std(a, axis=<span class="keyword">None</span>, dtype=<span class="keyword">None</span>, out=<span class="keyword">None</span>, ddof=<span class="number">0</span>, keepdims=&lt;no value&gt;)</span><br><span class="line"><span class="comment"># a：array_like，可以为列表等</span></span><br><span class="line"><span class="comment"># axis：默认为None，表示整个数组的标准差；0表示每一列的标准差；1表示每一行的标准差</span></span><br><span class="line"><span class="comment"># ddof：Means Delta Degrees of Freedom.也就是样本对整体的有偏和无偏的问题</span></span><br><span class="line"><span class="comment"># 默认的是ddof=0，是有偏估计，ddof=1，表示N-1，是无偏估计</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 整个数组的标准差</span></span><br><span class="line">np.std(a)</span><br><span class="line">  <span class="number">1.1180339887498949</span></span><br><span class="line">np.std(a, axis=<span class="number">0</span>)</span><br><span class="line">  array([ <span class="number">1.</span>,  <span class="number">1.</span>])</span><br><span class="line">np.std(a, axis=<span class="number">1</span>)</span><br><span class="line">  array([ <span class="number">0.5</span>,  <span class="number">0.5</span>])</span><br><span class="line"><span class="comment"># 等同于这个，其中用到了广播的机制</span></span><br><span class="line">np.sqrt(((a- np.mean(a,axis=<span class="number">1</span>,keepdims=<span class="keyword">True</span>))**<span class="number">2</span>).mean(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置ddof</span></span><br><span class="line">np.std(a,ddof=<span class="number">1</span>)</span><br><span class="line">  <span class="number">1.2909944487358056</span></span><br><span class="line"><span class="comment"># 等同于如下</span></span><br><span class="line">np.sqrt(((a-np.mean(a))**<span class="number">2</span>).sum()/(a.size<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>使用注意事项</strong>：</p><ul><li><mark>ddof参数的使用需要注意</mark></li><li><code>np.var()</code>也类似，也有<code>ddof</code>参数</li></ul></div><hr><h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><table><tr><th width="50%">函数</th><th width="50%">说明</th></tr><tr><td>np.sort(a, axis=-1, kind='quicksort', order=None)</td><td>对整个数组或者某一维进行排序(升序)</td></tr><tr><td>np.argsort(a, axis=-1, kind='quicksort', order=None)</td><td>得到排序后的索引(升序)</td></tr><tr><td>lexsort(keys, axis=-1)</td><td>借助其他序列排序(升序)</td></tr></table><h3 id="对整个数组或者某一维进行排序-np-sort"><a href="#对整个数组或者某一维进行排序-np-sort" class="headerlink" title="对整个数组或者某一维进行排序-np.sort()"></a>对整个数组或者某一维进行排序-np.sort()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.sort(a, axis=<span class="number">-1</span>, kind=<span class="string">'quicksort'</span>, order=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># a：array_like</span></span><br><span class="line"><span class="comment"># axis：排序的axis，默认是-1(2维的是行)，which sorts along the last axis</span></span><br><span class="line"><span class="comment"># kind：排序的算法，&#123;'quicksort', 'mergesort', 'heapsort', 'stable'&#125;</span></span><br><span class="line"><span class="comment"># order： 如果数组包含字段，则是要排序的字段</span></span><br></pre></td></tr></table></figure><p></p><p><strong>三种排序算法比较</strong>：<br><table><thead><tr><th width="25%">种类</th><th width="10%">速度</th><th width="25%">最坏情况</th><th width="10%">工作空间</th><th width="30%">稳定性</th></tr></thead><tbody><tr><td><code>'quicksort'</code>（快速排序）</td><td>1</td><td><code>O(n^2)</code></td><td>0</td><td>否</td></tr><tr><td><code>'mergesort'</code>（归并排序）</td><td>2</td><td><code>O(n*log(n))</code></td><td>~n/2</td><td>是</td></tr><tr><td><code>'heapsort'</code>（堆排序）</td><td>3</td><td><code>O(n*log(n))</code></td><td>0</td><td>否</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])  </span><br><span class="line">  array([[<span class="number">3</span>, <span class="number">7</span>],</span><br><span class="line">         [<span class="number">9</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认排序，对行，最小的值放在各行的第一个</span></span><br><span class="line">np.sort(a)</span><br><span class="line">  array([[<span class="number">3</span>, <span class="number">7</span>],</span><br><span class="line">         [<span class="number">1</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整个数组进行排序</span></span><br><span class="line">np.sort(a,axis=<span class="keyword">None</span>)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列进行排序，最小的值放在各列的第一个</span></span><br><span class="line">np.sort(a,axis=<span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">9</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定order</span></span><br><span class="line"><span class="comment"># dtype相当于成了字典</span></span><br><span class="line">dt = np.dtype([(<span class="string">'name'</span>,  <span class="string">'S10'</span>),(<span class="string">'age'</span>,  int)]) </span><br><span class="line">  dtype([(<span class="string">'name'</span>, <span class="string">'S10'</span>), (<span class="string">'age'</span>, <span class="string">'&lt;i8'</span>)])</span><br><span class="line"></span><br><span class="line">a = np.array([(<span class="string">"raju"</span>,<span class="number">21</span>),(<span class="string">"anil"</span>,<span class="number">25</span>),(<span class="string">"ravi"</span>,  <span class="number">17</span>),  (<span class="string">"amar"</span>,<span class="number">27</span>)], dtype = dt)  </span><br><span class="line">  array([(<span class="string">b'raju'</span>, <span class="number">21</span>), (<span class="string">b'anil'</span>, <span class="number">25</span>), (<span class="string">b'ravi'</span>, <span class="number">17</span>), (<span class="string">b'amar'</span>, <span class="number">27</span>)],</span><br><span class="line">        dtype=[(<span class="string">'name'</span>, <span class="string">'S10'</span>), (<span class="string">'age'</span>, <span class="string">'&lt;i8'</span>)])</span><br><span class="line"><span class="comment"># 对name进行排序</span></span><br><span class="line">np.sort(a, order =  <span class="string">'name'</span>)</span><br><span class="line">  array([(<span class="string">b'amar'</span>, <span class="number">27</span>), (<span class="string">b'anil'</span>, <span class="number">25</span>), (<span class="string">b'raju'</span>, <span class="number">21</span>), (<span class="string">b'ravi'</span>, <span class="number">17</span>)],</span><br><span class="line">        dtype=[(<span class="string">'name'</span>, <span class="string">'S10'</span>), (<span class="string">'age'</span>, <span class="string">'&lt;i8'</span>)])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="得到排序后的索引-np-argsort"><a href="#得到排序后的索引-np-argsort" class="headerlink" title="得到排序后的索引-np.argsort()"></a>得到排序后的索引-np.argsort()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.argsort(a, axis=<span class="number">-1</span>, kind=<span class="string">'quicksort'</span>, order=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># a：array_like</span></span><br><span class="line"><span class="comment"># axis：排序的axis，默认是-1(2维的是行)，which sorts along the last axis</span></span><br><span class="line"><span class="comment"># kind：排序的算法，&#123;'quicksort', 'mergesort', 'heapsort', 'stable'&#125;</span></span><br><span class="line"><span class="comment"># order： 如果数组包含字段，则是要排序的字段</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 对列进行排序，也就是把每一列最小的放在第一行</span></span><br><span class="line"><span class="comment"># 返回的是对应数值的索引</span></span><br><span class="line">np.argsort(x, axis=<span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是对行进行排序</span></span><br><span class="line">np.argsort(x)</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整个数组排序</span></span><br><span class="line"><span class="comment"># 返回索引</span></span><br><span class="line">np.argsort(x,axis=<span class="keyword">None</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="借助其他序列排序-np-lexsort"><a href="#借助其他序列排序-np-lexsort" class="headerlink" title="借助其他序列排序-np.lexsort()"></a>借助其他序列排序-np.lexsort()</h3><p>如果一个数组或序列中存在多个相同的值，<strong>普通的排序会按照出现的先后顺序进行排序</strong>，<code>np.lexsort()</code>会<strong>借助其他数组或序列实现排序而不是按照默认的方式</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.lexsort((a,b), axis=<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># (a,b)：多个序列，会优先对后面的也就是b进行排序，b中相同的则会借助a中的信息对b进行排序</span></span><br><span class="line"><span class="comment"># axis：-1表示sort over the last axis.</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>] <span class="comment"># First column</span></span><br><span class="line">b = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>] <span class="comment"># Second column</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对a进行排序，返回排序后的数组</span></span><br><span class="line">np.sort(a)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接对a进行排序，返回索引值</span></span><br><span class="line"><span class="comment"># a中有2个1、3个4，默认使用argsort会按照出现的先后顺序</span></span><br><span class="line">np.argsort(a)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助序列b对a进行排序</span></span><br><span class="line"><span class="comment"># a中的两个1在b中分别对应9、0，所以后面的1排在前面的1之前</span></span><br><span class="line"><span class="comment"># 默认的0、2就变成了2、0</span></span><br><span class="line">np.lexsort((b,a))</span><br><span class="line">  array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h2><extract><br><table><br><tr><br><th width="50%">函数</th><br><th width="50%">说明</th><br></tr><br><tr><br><td>np.nonzero(a)</td><br><td>查找非零(True)元素索引</td><br></tr><br><tr><br><td>np.where(condition, [x, y])</td><br><td>类似三目运算符或相当于np.nonzero(a)，如果不指定x和y</td><br></tr><br><tr><br><td>np.extract(condition, arr)</td><br><td>从数组中以某个条件来抽取元素</td><br></tr><br></table><br></extract><h3 id="查找非零元素索引-np-nonzero"><a href="#查找非零元素索引-np-nonzero" class="headerlink" title="查找非零元素索引-np.nonzero()"></a>查找非零元素索引-np.nonzero()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.nonzero(a)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>]])</span><br><span class="line">  array([[<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 查找非0元素的索引</span></span><br><span class="line">np.nonzero(x)</span><br><span class="line">  (array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment"># 返回的是非零元素的索引</span></span><br><span class="line"><span class="comment"># 和切片中的整数索引切片相同，返回的是一一对应的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取非0元素的值</span></span><br><span class="line">x[np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]), np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])]</span><br><span class="line">  array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以结合判断语句</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">a &gt; <span class="number">3</span></span><br><span class="line">  array([[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>],</span><br><span class="line">         [ <span class="keyword">True</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>],</span><br><span class="line">         [ <span class="keyword">True</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找满足a&gt;3的索引</span></span><br><span class="line">np.nonzero(a&gt;<span class="number">3</span>)</span><br><span class="line">(array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="comment"># 获取对应的值</span></span><br><span class="line">a[np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]), np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])]</span><br><span class="line">  array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用布尔索引</span></span><br><span class="line">a[a&gt;<span class="number">3</span>]</span><br><span class="line">  array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="三目运算符或查找索引-np-where"><a href="#三目运算符或查找索引-np-where" class="headerlink" title="三目运算符或查找索引-np.where()"></a>三目运算符或查找索引-np.where()</h3><p>如果想在<strong>数组或列表</strong>等中进行类似<strong>三目运算符</strong>的操作，可以使用<code>np.where()</code>，同时<code>np.where()</code>还可以有<code>np.nonzero()</code>的功能。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where(condition, [x, y])</span><br><span class="line"><span class="comment"># condition：筛选条件</span></span><br><span class="line"><span class="comment"># x：条件成立时的选择</span></span><br><span class="line"><span class="comment"># y：条件不成立的选择</span></span><br><span class="line"><span class="comment"># 如果x、y不指定，就相当于np.nonzero()</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个一维数组</span></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果小于5，就设置为1，否则就设置为-1</span></span><br><span class="line">np.where(a &lt; <span class="number">5</span>, <span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">  array([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在二维数组中的应用</span></span><br><span class="line">x=np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">y=np.arange(<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>)[::<span class="number">-1</span>].reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">  array([[<span class="number">9</span>, <span class="number">8</span>],</span><br><span class="line">         [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">condition=np.array([[<span class="keyword">True</span>, <span class="keyword">False</span>], [<span class="keyword">True</span>, <span class="keyword">True</span>]])</span><br><span class="line">  array([[ <span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">         [ <span class="keyword">True</span>,  <span class="keyword">True</span>]])</span><br><span class="line"><span class="comment"># np.where还是一一对应的问题</span></span><br><span class="line"><span class="comment"># condition中(0,0)为true，对应地在x中取(0,0)，而不取y中的(0,0)</span></span><br><span class="line"><span class="comment"># condition中(0,1)为false，对应地不在x中取(0,1)，而取y中的(0,1)</span></span><br><span class="line"><span class="comment"># 以此类推得到下面的结果</span></span><br><span class="line">np.where(condition,x,y)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">8</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果condition为数组，而x、y为一个数字，那么就会被广播</span></span><br><span class="line"><span class="comment"># 相当于所有不满足条件的都设置为同一个值</span></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>],[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]])</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 小于4的都会被赋值-1</span></span><br><span class="line">np.where(a &lt; <span class="number">4</span>, a, <span class="number">-1</span>)</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">-1</span>],</span><br><span class="line">         [ <span class="number">0</span>,  <span class="number">3</span>, <span class="number">-1</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="抽取元素-np-extract"><a href="#抽取元素-np-extract" class="headerlink" title="抽取元素-np.extract()"></a>抽取元素-np.extract()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.extract(condition, arr)</span><br><span class="line"></span><br><span class="line">This <span class="keyword">is</span> equivalent to np.compress(ravel(condition), ravel(arr)).</span><br><span class="line"><span class="comment"># 返回的应该会是一维数组</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 设置条件</span></span><br><span class="line">condition = np.mod(arr, <span class="number">3</span>)==<span class="number">0</span></span><br><span class="line">  array([[ <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>],</span><br><span class="line">         [<span class="keyword">False</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">         [<span class="keyword">False</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>]])</span><br><span class="line"><span class="comment"># 抽取元素</span></span><br><span class="line">np.extract(condition, arr)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.runoob.com/numpy/numpy-mathematical-functions.html" target="_blank" rel="noopener">NumPy 数学函数</a></li><li><a href="https://www.runoob.com/numpy/numpy-statistical-functions.html" target="_blank" rel="noopener">NumPy 统计函数</a></li><li><a href="https://www.cnblogs.com/massquantity/p/8908859.html" target="_blank" rel="noopener">numpy.where() 用法详解</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之numpy-数组与矩阵运算(三)：广播、迭代以及数组相关操作</title>
      <link href="/posts/24353.html"/>
      <url>/posts/24353.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了numpy的<strong>广播</strong>、<strong>迭代</strong>以及<strong>数组相关操作</strong>；在<strong>广播</strong>中学习了<code>numpy广播的机制和原理</code>以及<code>进行广播的条件</code>；在<strong>迭代</strong>中学习了<code>普通的循环遍历数组元素</code>、使用numpy的迭代器对象 <code>numpy.nditer</code>进行数组元素的迭代、使用<code>np.ndenumerate</code>进行枚举迭代、使用<code>np.ndindex</code>迭代索引；在<strong>数组操作</strong>中学习了<code>修改数组形状</code>、<code>分割数组</code>、<code>数组元素的添加(append、insert)</code>和<code>删除(delete、unique)</code>等。</p></div><a id="more"></a><h2 id="numpy广播"><a href="#numpy广播" class="headerlink" title="numpy广播"></a>numpy广播</h2><p>numpy数组间的基础运算是<code>element-by-element</code>的，如<code>a+b</code>的结果就是a与b数组<strong>对应位进行相应的运算(不是矩阵运算，矩阵运算有特殊的方法)</strong>，必须满足<code>a.shape == b.shape</code>，也就是两个数组的<strong>维数相同</strong>，且<strong>各维度的长度相同</strong>，以下是<code>a.shape == b.shape</code>的一个示例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a为一维数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) </span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># b也为一维数组</span></span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) </span><br><span class="line">  array([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应位置元素相乘</span></span><br><span class="line">a * b </span><br><span class="line">  array([ <span class="number">10</span>,  <span class="number">40</span>,  <span class="number">90</span>, <span class="number">160</span>])</span><br></pre></td></tr></table></figure><p></p><p>如果运算中的2个数组的<strong>shape不同</strong>时，只有当他们的<code>trailing dimensions（尾部维度）`</code>compatible（兼容）<code>时才会触发广播，否则报错</code>ValueError: frames are not aligned exception`，这里面有两个概念需要理解，一个是<strong>尾部维度</strong>，另一个是<strong>兼容</strong>：</p><ul><li>关于<strong>尾部维度</strong>，简单来说就是使用<code>array.shape</code>之后得到的<strong>最后一个维度信息</strong></li><li>关于<strong>兼容</strong>，一下是两个基本条件：<ul><li><mark>尾部维度是相等的(见下面实例以及补充)</mark></li><li><mark>尾部维度其中有一方是1(见下面的实例和补充)</mark></li></ul></li></ul><p><strong>尾部维度相等使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个4行3列的数组</span></span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">              [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">              [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">a.shape</span><br><span class="line">  (<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个一维的数组</span></span><br><span class="line"><span class="comment"># 长度为3</span></span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b.shape</span><br><span class="line">  (<span class="number">3</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾部维度相同</span></span><br><span class="line"><span class="comment"># 满足广播机制</span></span><br><span class="line"><span class="number">4</span> x <span class="number">3</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a + b</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">         [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">         [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]])</span><br></pre></td></tr></table></figure><p></p><p><strong>不是所有的尾部维度相同的都可以进行广播</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上面的b修改为2行3列的数组</span></span><br><span class="line">b=np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾部维度相同</span></span><br><span class="line"><span class="comment"># 但是不满足广播机制</span></span><br><span class="line"><span class="number">4</span> x <span class="number">3</span></span><br><span class="line"><span class="number">2</span> x <span class="number">3</span></span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>广播一定要体会到<strong>维度较小的可以在某一个或者几个维度上存在拉伸和拓展</strong>的感觉，<strong>本质上还是满足数组按位一一对应进行运算</strong>，只是<strong>维度较小的复制成了和维度较大的一样的shape</strong>，比如上面的<code>4 x 3</code>和<code>3</code>，可以看成维度为<code>3</code>的先复制成了<code>4 x 3</code>的(每一行的内容相同)，然后按位一一对应进行运算，而后面将b改为<code>2 x 3</code>之后就不能进行类似的操作。</p></div><p><strong>其中一个尾部维度为1使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b=np.array([<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 尾部维度不同，但第二个的尾部维度为1</span></span><br><span class="line"><span class="comment"># 满足广播机制</span></span><br><span class="line"><span class="number">4</span> x <span class="number">3</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a + b</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>],</span><br><span class="line">         [<span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>],</span><br><span class="line">         [<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>],</span><br><span class="line">         [<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>]])</span><br></pre></td></tr></table></figure><p></p><p><strong>不是只要其中一个尾部维度为1就行</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">b=np.arange(<span class="number">6</span>).reshape((<span class="number">6</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 尾部维度不同，第二个的尾部维度为1</span></span><br><span class="line"><span class="comment"># 但是不满足广播机制</span></span><br><span class="line"><span class="number">4</span> x <span class="number">3</span></span><br><span class="line"><span class="number">6</span> x <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a + b</span><br><span class="line">  ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">6</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官网示例</span></span><br><span class="line"><span class="comment"># 倒数后三位，a和b总有一个为1</span></span><br><span class="line">A      (<span class="number">4</span>d array):  <span class="number">8</span> x <span class="number">1</span> x <span class="number">6</span> x <span class="number">1</span></span><br><span class="line">B      (<span class="number">3</span>d array):      <span class="number">7</span> x <span class="number">1</span> x <span class="number">5</span></span><br><span class="line">Result (<span class="number">4</span>d array):  <span class="number">8</span> x <span class="number">7</span> x <span class="number">6</span> x <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照官网实例修改</span></span><br><span class="line">a=np.arange(<span class="number">3</span>).reshape((<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">b=np.arange(<span class="number">6</span>).reshape((<span class="number">6</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维度相同，但在各个维度上a和b总有一个为1</span></span><br><span class="line"><span class="number">1</span> x <span class="number">3</span></span><br><span class="line"><span class="number">6</span> x <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a + b</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">         [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h2><h3 id="普通的循环遍历"><a href="#普通的循环遍历" class="headerlink" title="普通的循环遍历"></a>普通的循环遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双重for循环进行迭代</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="keyword">print</span> (cell,end=<span class="string">', '</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br></pre></td></tr></table></figure><hr><h3 id="使用迭代器对象迭代元素"><a href="#使用迭代器对象迭代元素" class="headerlink" title="使用迭代器对象迭代元素"></a>使用迭代器对象迭代元素</h3><p>NumPy 迭代器对象 <code>numpy.nditer</code> 提供了一种<strong>灵活访问一个或者多个数组元素的方式</strong>.</p><h4 id="默认迭代顺序"><a href="#默认迭代顺序" class="headerlink" title="默认迭代顺序"></a>默认迭代顺序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个2行3列的数组</span></span><br><span class="line">a=np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代数组中的元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="comment"># 修改默认是输出结束符为, </span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br></pre></td></tr></table></figure><div class="note info"><p>需要注意的<strong>是数组的存储是带有顺序的</strong>，即order设置；在迭代数组元素时，默认情况下选择的顺序是和数组内存布局一致的</p></div><p><strong>对数组进行转置后会不会影响迭代元素的顺序</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对数组进行转置操作</span></span><br><span class="line">a.T</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代数组中的元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>通过上述对转置后数组元素的迭代可以发现，两者的输出完全相同，也就是说<code>a</code> 和 <code>a.T</code> 的<strong>遍历顺序是一样的</strong>，即<strong>他们在内存中的存储顺序是一样的</strong>，转置只是改变了形态，而没有改变内部的存储顺序。</p></div><h4 id="控制迭代顺序"><a href="#控制迭代顺序" class="headerlink" title="控制迭代顺序"></a>控制迭代顺序</h4><ul><li><code>for x in np.nditer(a, order=&#39;F&#39;)</code>:Fortran order，即是<strong>列序优先</strong></li><li><code>for x in np.nditer(a.T, order=&#39;C&#39;)</code>:C order，即是<strong>行序优先</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列序优先迭代输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(a,order=<span class="string">'F'</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行序优先迭代输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(a,order=<span class="string">'C'</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br></pre></td></tr></table></figure><hr><h4 id="迭代过程中修改数组值"><a href="#迭代过程中修改数组值" class="headerlink" title="迭代过程中修改数组值"></a>迭代过程中修改数组值</h4><p><mark>默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only）</mark>，为了在遍历数组的同时，<strong>实现对数组元素值得修改</strong>，必须使用nditer 对象的可选参数 <code>op_flags</code>来指定 <code>read-write</code> 或者 <code>write-only</code> 的模式。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不设置op_flags进行直接修改</span></span><br><span class="line"><span class="comment"># 会报错显示read-only</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(a,order=<span class="string">'C'</span>):</span><br><span class="line">    <span class="comment"># 注意这里必须要使用i[...]进行赋值，不然不会起效</span></span><br><span class="line">    i[...] = <span class="number">2</span> * i</span><br><span class="line">a</span><br><span class="line">  ValueError: assignment destination <span class="keyword">is</span> read-only</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置op_flags为readwrite</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(a,op_flags=[<span class="string">'readwrite'</span>]):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        i[...] = <span class="number">2</span> * i</span><br><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="两个数组广播迭代"><a href="#两个数组广播迭代" class="headerlink" title="两个数组广播迭代"></a>两个数组广播迭代</h4><p>如果<strong>两个数组是可广播的</strong>，<strong>nditer 组合对象能够同时迭代它们</strong>。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'第一个数组为：'</span>)</span><br><span class="line"><span class="keyword">print</span> (a)</span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'第二个数组为：'</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>], dtype =  int)  </span><br><span class="line"><span class="keyword">print</span> (b)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改后的数组为：'</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> np.nditer([a,b]):  </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"%d:%d"</span>  %  (x,y), end=<span class="string">", "</span> )</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一个数组为：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组为：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数组为：</span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>, <span class="number">5</span>:<span class="number">2</span>, <span class="number">10</span>:<span class="number">3</span>, <span class="number">15</span>:<span class="number">4</span>, <span class="number">20</span>:<span class="number">1</span>, <span class="number">25</span>:<span class="number">2</span>, <span class="number">30</span>:<span class="number">3</span>, <span class="number">35</span>:<span class="number">4</span>, <span class="number">40</span>:<span class="number">1</span>, <span class="number">45</span>:<span class="number">2</span>, <span class="number">50</span>:<span class="number">3</span>, <span class="number">55</span>:<span class="number">4</span>,</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="枚举迭代"><a href="#枚举迭代" class="headerlink" title="枚举迭代"></a>枚举迭代</h3><p>类似于list的<code>enumerate</code>函数，numpy也专门有一个可以用来枚举元素的函数，可以同时得到每个元素的索引和value：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意函数只能返回两个值</span></span><br><span class="line"><span class="comment"># 一个是索引的元素，一个是value</span></span><br><span class="line"><span class="comment"># 不能写成x,y,value这种</span></span><br><span class="line"><span class="keyword">for</span> (x,y),value <span class="keyword">in</span> np.ndenumerate(a):</span><br><span class="line">    <span class="keyword">print</span> (x,y,value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="迭代索引"><a href="#迭代索引" class="headerlink" title="迭代索引"></a>迭代索引</h3><p>如果想单纯地迭代得到索引，可以使用<code>np.ndindex</code>函数，只用将array的shape传递给函数即可：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会直接遍历得到元素值</span></span><br><span class="line"><span class="comment"># 只会得到指定shape的索引</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> np.ndindex(a.shape):</span><br><span class="line">    <span class="keyword">print</span> (index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h3><p>主要使用的函数如下：<br><table><thead><tr><th width="50%">函数</th><th width="50%">描述</th></tr></thead><tbody><tr><td><code>np.reshape(a, newshape, order='C')</code></td><td>不改变数据的条件下修改形状</td></tr><tr><td><code>np.resize(a, new_shape)</code></td><td>修改数组形状</td></tr><tr><td><code>np.ndarray.flat</code></td><td>数组元素迭代器</td></tr><tr><td><code>numpy.ndarray.flatten(order='C')</code></td><td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td><code>np.ravel(a, order='C')</code></td><td>返回展开数组</td></tr></tbody></table></p><h4 id="np-reshape"><a href="#np-reshape" class="headerlink" title="np.reshape"></a>np.reshape</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.reshape(array, newshape, order=<span class="string">'C'</span>)</span><br><span class="line"><span class="comment"># array：需要转换形状的数组</span></span><br><span class="line"><span class="comment"># newshape：元组或者整数</span></span><br><span class="line"><span class="comment"># order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'k' -- 元素在内存中的出现顺序</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一维数组</span></span><br><span class="line">a=np.arange(<span class="number">8</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组的shape</span></span><br><span class="line">a.reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="np-resize"><a href="#np-resize" class="headerlink" title="np.resize"></a>np.resize</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.resize(a, new_shape)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="comment"># 原位修改</span></span><br><span class="line"><span class="comment"># 没有返回值</span></span><br><span class="line"><span class="comment"># 如果使用np.resize就不会原位修改</span></span><br><span class="line">a.resize((<span class="number">4</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数组a已经发生改变</span></span><br><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用reshape</span></span><br><span class="line"><span class="comment"># 返回reshape之后的数组</span></span><br><span class="line"><span class="comment"># 原始数组没有发生改变</span></span><br><span class="line">a.reshape((<span class="number">4</span>,<span class="number">2</span>))</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果新的shape比原始的大，默认不会报错，而会复制</span></span><br><span class="line"><span class="comment"># 这里只能使用np.resize，而不能使用a.resize</span></span><br><span class="line">np.resize(a,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">  <span class="comment"># 返回的结果中原始数组第一行重复了一次</span></span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 使用np.reshape进行类似的操作就会报错</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>np.reshape</code>和<code>np.resize</code>的<strong>区别</strong>：</p><ul><li><code>np.resize</code>没有<code>order</code>参数了，它只有跟<code>reshape</code>里面<code>order=&#39;C&#39;</code>的方式</li><li>当使用<code>a.resize</code>时可以进行<strong>原位修改</strong>，直接修改原始数组，不会返回修改的数组(<strong>使用np.resize时就不会有这个效果</strong>)，而<code>a.reshape</code>不会</li><li>假如要转换成的矩阵形状中的元素数量跟原矩阵不同，它会<strong>强制进行转换(重复)</strong>，而不报错(<strong>必须使用np.resize，不能使用a.resize</strong>)，<strong>reshape就会报错</strong></li></ul></div><hr><h4 id="flat和flatten"><a href="#flat和flatten" class="headerlink" title="flat和flatten()"></a>flat和flatten()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.ndarray.flat</span></span><br><span class="line">a.flat</span><br><span class="line">  &lt;numpy.flatiter at <span class="number">0x7faaf8ed9b60</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.flat:</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">', '</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用numpy.ndarray.flatten</span></span><br><span class="line">a.flatten()</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.flatten():</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">', '</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br></pre></td></tr></table></figure><hr><h4 id="np-ravel-展开数组"><a href="#np-ravel-展开数组" class="headerlink" title="np.ravel-展开数组"></a>np.ravel-展开数组</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.ravel(array, order=<span class="string">'C'</span>)</span><br><span class="line"><span class="comment"># array：需要转换形状的数组</span></span><br><span class="line"><span class="comment"># order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'k' -- 元素在内存中的出现顺序</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="comment"># ravel</span></span><br><span class="line">a.ravel()</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure><p></p><p>注意<code>np.ravel</code>和<code>numpy.ndarray.flatten</code>的区别：</p><ul><li><code>numpy.ndarray.flatten</code>返回的是数组的拷贝，而不是原始数组，<strong>对拷贝的修改不会影响原始数组</strong></li><li><code>np.ravel</code>则是<strong>直接会操作原始数组</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改flatten函数返回的数组的值</span></span><br><span class="line">a.flatten()[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">a</span><br><span class="line">  <span class="comment"># 原始的数组a并没有发生改变</span></span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改ravel函数返回的数组的值</span></span><br><span class="line">a.ravel()[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">a</span><br><span class="line">  <span class="comment"># 原始的数组已经发生改变</span></span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure><hr><h3 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h3><p>分割数组使用的函数如下：<br><table><thead><tr><th width="50%">函数</th><th width="50%">数组及操作</th></tr></thead><tbody><tr><td><code>np.split(ary, indices_or_sections, axis=0)</code></td><td>将一个数组分割为多个子数组</td></tr><tr><td><code>np.hsplit(ary, indices_or_sections)</code></td><td>将一个数组水平分割为多个子数组（按列）</td></tr><tr><td><code>np.vsplit(ary, indices_or_sections)</code></td><td>将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table></p><h4 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.split(array, indices_or_sections, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># indices_or_sections：索引列表或者sections数目</span></span><br><span class="line"><span class="comment"># 返回数组的列表</span></span><br><span class="line"><span class="comment"># axis：0表示对行进行划分(列不变，行划分)、1表示对列进行划分(行不变，列划分)</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个一维的数组</span></span><br><span class="line">x = np.arange(<span class="number">9.0</span>)</span><br><span class="line">  array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">7.</span>, <span class="number">8.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均分为3个</span></span><br><span class="line">np.split(x, <span class="number">3</span>)</span><br><span class="line">  [array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]), array([<span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>]), array([<span class="number">6.</span>, <span class="number">7.</span>, <span class="number">8.</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引划分</span></span><br><span class="line"><span class="comment"># 0-3、3-5、5-6、6-10</span></span><br><span class="line">np.split(x, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>])</span><br><span class="line">  [array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]),</span><br><span class="line">   array([<span class="number">3.</span>, <span class="number">4.</span>]),</span><br><span class="line">   array([<span class="number">5.</span>]),</span><br><span class="line">   array([<span class="number">6.</span>, <span class="number">7.</span>, <span class="number">8.</span>]),</span><br><span class="line">   array([], dtype=float64)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">a</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均分为2个</span></span><br><span class="line"><span class="comment"># 列不变，行划分</span></span><br><span class="line">np.split(a,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">  [array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]]), array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行不变，列划分</span></span><br><span class="line">np.split(a,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">[array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>]]), </span><br><span class="line"> array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">7</span>]])]</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="hsplit-分割列"><a href="#hsplit-分割列" class="headerlink" title="hsplit-分割列"></a>hsplit-分割列</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(ary, indices_or_sections)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 均分为2个</span></span><br><span class="line"><span class="comment"># 相当于np.split(a,2,1)</span></span><br><span class="line">np.hsplit(a,<span class="number">2</span>)</span><br><span class="line">  [array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">          [<span class="number">4</span>, <span class="number">5</span>]]), </span><br><span class="line">  array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">6</span>, <span class="number">7</span>]])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引划分</span></span><br><span class="line"><span class="comment"># 0-1、1-3、3-</span></span><br><span class="line">np.hsplit(a,[<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line">  [array([[<span class="number">0</span>],</span><br><span class="line">          [<span class="number">4</span>]]),</span><br><span class="line">   array([[<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">          [<span class="number">5</span>, <span class="number">6</span>]]), </span><br><span class="line">   array([[<span class="number">3</span>],</span><br><span class="line">          [<span class="number">7</span>]])]</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="vsplit-分割行"><a href="#vsplit-分割行" class="headerlink" title="vsplit-分割行"></a>vsplit-分割行</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.vsplit(ary, indices_or_sections)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对行进行划分</span></span><br><span class="line"><span class="comment"># 相当于np.split(a,2,0)</span></span><br><span class="line">np.vsplit(a,<span class="number">2</span>)</span><br><span class="line">  [array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]]), </span><br><span class="line">   array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><p>使用函数汇总：<br><table><thead><tr><th width="50%">函数</th><th width="50%">元素及描述</th></tr></thead><tbody><tr><td><code>append</code></td><td>将值添加到数组末尾</td></tr><tr><td><code>insert</code></td><td>沿指定轴将值插入到指定下标之前</td></tr><tr><td><code>delete</code></td><td>删掉某个轴的子数组，并返回删除后的新数组</td></tr><tr><td><code>unique</code></td><td>查找数组内的唯一元素</td></tr></tbody></table></p><h4 id="numpy-append-追加元素到末尾"><a href="#numpy-append-追加元素到末尾" class="headerlink" title="numpy.append-追加元素到末尾"></a>numpy.append-追加元素到末尾</h4><p><code>numpy.append</code> 函数在数组的<strong>末尾添加值</strong>，追加操作会分配整个数组，并把<strong>原来的数组复制到新数组中</strong>。此外，输入数组的<strong>维度必须匹配</strong>否则将生成<code>ValueError</code>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.append(arr, values, axis=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>axis</strong>:</p><ul><li><code>None(默认)</code>：是横向加成，返回<strong>总是为一维数组</strong></li><li><code>0</code>：<strong>列不变，行加成</strong></li><li><code>1</code>：<strong>行不变，列加成</strong></li></ul></div><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加axis</span></span><br><span class="line"><span class="comment"># 默认的axis=None，这样直接会变成一维的数组</span></span><br><span class="line">np.append(a,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意不能想列表一样使用li.append()这种</span></span><br><span class="line">a.append([<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">  AttributeError: <span class="string">'numpy.ndarray'</span> object has no attribute <span class="string">'append'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=0，列不变，行增加</span></span><br><span class="line">np.append(a,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],axis=<span class="number">0</span>)</span><br><span class="line">  ValueError: all the input arrays must have same number of dimensions</span><br><span class="line"><span class="comment"># 上面报错是因为a为二维数组，而用于append的是一维，两者维度不同，合并出错</span></span><br><span class="line"><span class="comment"># 使用下面的二维列表形式即可</span></span><br><span class="line">np.append(a,[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis=<span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">         [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=1，行不变，列增加</span></span><br><span class="line">np.append(a,[[<span class="number">1</span>],[<span class="number">2</span>]],axis=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>使用注意事项：</p><ul><li><strong>不能</strong>直接使用<code>array.append()</code>这种，<strong>必须使用<code>np.append()</code></strong>，不像列表一样</li><li><code>axis=0|1</code>需要注意append的<strong>维度要和原始数组的维度对应</strong>，不然会出错</li></ul></div><hr><h4 id="numpy-insert-插入到指定位置"><a href="#numpy-insert-插入到指定位置" class="headerlink" title="numpy.insert-插入到指定位置"></a>numpy.insert-插入到指定位置</h4><p>上面的append是将元素追加到数组的末尾，而如果想要把元素插入到数组的某个位置，可以使用<code>np.insert()</code>函数，该函数可以在<strong>给定索引之前</strong>，<strong>沿给定轴</strong>在输入数组中插入值，需要注意的是和append一样<strong>如果未提供轴，则输入数组会被展开</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.insert(arr, obj, values, axis=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># arr:待插入的数组</span></span><br><span class="line"><span class="comment"># obj：插入的索引，可以是数字、列表、slice、元组等</span></span><br><span class="line"><span class="comment"># value：插入的值</span></span><br><span class="line"><span class="comment"># axis和append的规则相同</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 在索引1之前插入数字5</span></span><br><span class="line"><span class="comment"># 没有指定axis，直接会展开</span></span><br><span class="line">np.insert(a,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定axis=1，列会拓展，行不变</span></span><br><span class="line"><span class="comment"># 这个会产生类似广播的机制</span></span><br><span class="line"><span class="comment"># 和append不同，不用插入相同维度的信息</span></span><br><span class="line">np.insert(a,<span class="number">1</span>,<span class="number">5</span>,axis=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定axis=0，行会拓展，列不变</span></span><br><span class="line"><span class="comment"># 这个会产生类似广播的机制</span></span><br><span class="line"><span class="comment"># 和append不同，不用插入相同维度的信息</span></span><br><span class="line">np.insert(a,<span class="number">1</span>,<span class="number">5</span>,axis=<span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想在一列或者一行插入相同的值，可以使用列表</span></span><br><span class="line"><span class="comment"># 在第二列之前插入一列，数值为1,2,3</span></span><br><span class="line">np.insert(a, <span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], axis=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内置的切片函数slice</span></span><br><span class="line"><span class="comment"># 在索引2和3之前分别插入5、6</span></span><br><span class="line"><span class="comment"># 这里的索引2、3是原始数组的索引，不是插入一个之后更新一遍</span></span><br><span class="line">np.insert(a, slice(<span class="number">2</span>, <span class="number">4</span>), [<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同的数据类型会进行强制统一</span></span><br><span class="line">np.insert(a, [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">7.13</span>, <span class="keyword">False</span>])</span><br><span class="line">  <span class="comment"># 在相同位置插入两个</span></span><br><span class="line">  array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>使用注意事项：</p><ul><li><strong>不需要像append一样</strong>，插入的维度要和原始数组维度相同，<strong>直接插入数字(数字会重复)或列表(每行或者每列插入内容不同)</strong></li><li>插入的<strong>index</strong>可以使用<strong>数字</strong>、<strong>列表</strong>、<strong>slice</strong>以及<strong>元组</strong>等</li><li><strong>axis</strong>的规则和<a href="#numpyappend-%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0%E5%88%B0%E6%9C%AB%E5%B0%BE">append</a>相同</li></ul></div><hr><h4 id="numpy-delete-删除元素"><a href="#numpy-delete-删除元素" class="headerlink" title="numpy.delete-删除元素"></a>numpy.delete-删除元素</h4><p>前面的<code>append</code>和<code>insert</code>都是在数组中增加元素，如果想要删除元素，可以使用<code>numpy.delete</code>函数，与前面的两个函数相同，如果<strong>不指定<code>axis</code>，则会将输入数组展开</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.delete(arr, obj, axis=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># arr：数组</span></span><br><span class="line"><span class="comment"># obj：索引位置，和insert的想听</span></span><br><span class="line"><span class="comment"># axis：和insert的相同</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有指定axis，数组先展开，然后删除指定索引</span></span><br><span class="line">np.delete(arr, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="keyword">None</span>)</span><br><span class="line">  array([ <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=0，删除行，1：索引为1的行</span></span><br><span class="line">np.delete(arr, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第二列和第四列</span></span><br><span class="line">np.delete(arr, [<span class="number">1</span>,<span class="number">3</span>], <span class="number">1</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="numpy-unique-去重"><a href="#numpy-unique-去重" class="headerlink" title="numpy.unique-去重"></a>numpy.unique-去重</h4><p><code>numpy.unique</code> 函数用于去除数组中的重复元素。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.unique(ar, return_index=<span class="keyword">False</span>, return_inverse=<span class="keyword">False</span>, return_counts=<span class="keyword">False</span>, axis=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>arr</code>：输入数组</li><li><code>return_index</code>：如果为<code>true</code>，返回<strong>去重后列表元素</strong>在<strong>原始列表中的首次出现索引(也就是返回的长度和去重后数组相同)</strong>以及去重后的数组</li><li><code>return_inverse</code>：如果为<code>true</code>，返回<strong>原始列表元素</strong>在<strong>去重后列表中的索引(也就是返回的长度和原始数组相同)</strong>以及去重后的数组</li><li><code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的<strong>出现次数</strong></li><li><code>axis</code>:<ul><li><code>默认(None)</code>：输入数组会被展开</li><li><code>0</code>：去除列上的重复</li><li><code>1</code>：去除行上的重复</li></ul></li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以直接对列表去重</span></span><br><span class="line"><span class="comment"># 返回去重之后的数组</span></span><br><span class="line">np.unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组去重</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 没有指定axis，数组会被展开，和前面的列表相同</span></span><br><span class="line">np.unique(a)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列去重</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="comment"># axis为0，表示列去重</span></span><br><span class="line">np.unique(a, axis=<span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回去重后数组元素在原始数组中首次出现的索引</span></span><br><span class="line">a = np.array([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>])</span><br><span class="line">u, indices = np.unique(a, return_index=<span class="keyword">True</span>)</span><br><span class="line">u</span><br><span class="line">  array([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], dtype=<span class="string">'&lt;U1'</span>)</span><br><span class="line">indices</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回原始列表元素在去重后列表中的索引</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">u, indices = np.unique(a, return_inverse=<span class="keyword">True</span>)</span><br><span class="line">u</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">indices</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://yiyang186.github.io/2017/11/09/numpy%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">Numpy广播机制小结</a></li><li><a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">Broadcasting官方</a></li><li><a href="https://www.runoob.com/numpy/numpy-array-manipulation.html" target="_blank" rel="noopener">Numpy 数组操作</a></li><li><a href="https://www.runoob.com/numpy/numpy-terating-over-array.html" target="_blank" rel="noopener">NumPy 迭代数组</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之numpy-数组与矩阵运算(二)：切片、截取和堆叠</title>
      <link href="/posts/35386.html"/>
      <url>/posts/35386.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了numpy中的<strong>切片</strong>、<strong>截取</strong>和<strong>堆叠</strong>等内容；在<strong>切片</strong>中主要学习了<code>常规切片</code>、<code>整数索引切片</code>、<code>布尔索引</code>以及<code>花式索引</code>；在<strong>截取操作</strong>中学习了<code>截取对角线</code>以及<code>截取上下三角阵</code>；在<strong>数组堆叠</strong>中主要学习了<code>纵向、横向堆叠</code>的各种不同的命令；最后学习了关于<code>np.r_</code>和<code>np.c_</code>的内容。</p></div><a id="more"></a><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><h3 id="常规切片"><a href="#常规切片" class="headerlink" title="常规切片"></a>常规切片</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ul><li><strong>连续切片</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个等差数列，从0-9，步长为1</span></span><br><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用冒号的切片操作，连续的切片</span></span><br><span class="line"><span class="comment"># 返回一个数组</span></span><br><span class="line">x[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">  array([<span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li>如果想要实现<strong>非连续切片</strong>，直接输入非连续切片组成的列表即可:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用非连续的索引进行切片操作，这个列表的很不同</span></span><br><span class="line"><span class="comment"># 但是在pandas的dataframe中可以进行这种类似的操作</span></span><br><span class="line">x[[<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">  array([<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表中就不能使用这种方法来得到非连续的索引</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a[[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="comment"># 会直接报错：</span></span><br><span class="line">  TypeError: list indices must be integers <span class="keyword">or</span> slices, <span class="keyword">not</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决列表中不能得到非连续索引的问题</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">itemgetter(<span class="number">2</span>,<span class="number">3</span>)(a)</span><br></pre></td></tr></table></figure><hr><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个三行三列的二维数组</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">a</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><ul><li><strong>连续切片</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取第二行到最后一行、所有列的内容</span></span><br><span class="line">a[<span class="number">1</span>:,]</span><br><span class="line">  array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取第二行、所有列的信息</span></span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line">  array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某一行的另一种方法</span></span><br><span class="line"><span class="comment"># 倒数第几行，这里-1是最后一行</span></span><br><span class="line">a[<span class="number">-1</span>,:]</span><br><span class="line">  array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第二行到最后一行，第三到最后一列</span></span><br><span class="line">a[<span class="number">1</span>:,<span class="number">2</span>:]</span><br><span class="line">  array([[<span class="number">5</span>],</span><br><span class="line">         [<span class="number">6</span>]])</span><br></pre></td></tr></table></figure><ul><li><strong>非连续切片</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取第1行和第三行、所有列的信息</span></span><br><span class="line">a[[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里不能在加上非连续的列索引，不然会进行后面整数索引提到的内容</span></span><br><span class="line">a[[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">  <span class="comment"># 得到的就不是第1行和第三行、第1列和第三列的内容</span></span><br><span class="line">  <span class="comment"># 而是0,0、2,2的内容</span></span><br><span class="line">  array([<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而列使用连续的则可以和非连续的行组合</span></span><br><span class="line">a[[<span class="number">0</span>,<span class="number">2</span>],<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure><div class="note info"><p>多维数组的非连续索引只能允许某一维是非连续的，如果两维都是非连续的则会进行<a href="#%E6%95%B4%E6%95%B0%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87">整数索引切片</a>内容，得不到想要的结果。</p></div><hr><h3 id="整数索引切片"><a href="#整数索引切片" class="headerlink" title="整数索引切片"></a>整数索引切片</h3><p>整数索引切片其实就是非连续索引进行切片。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个3行2列的数组</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line">x</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p></p><p><mark>通过<strong>各个维度离散索引的一一对应</strong>进行数组元素的筛选筛选，各个维度离散索引之间<strong>不会进行组合</strong></mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个维度分别指定了列表，以此来进行一一对应获取</span></span><br><span class="line"><span class="comment"># 这里得到的就是0,0、1,1、2,0的内容</span></span><br><span class="line">x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line">  array([<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用数组来进行离散索引的一一对应</span></span><br><span class="line"><span class="comment"># 得到3x3数组四个角落的元素</span></span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]]) </span><br><span class="line">x</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">         [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 行        </span></span><br><span class="line">rows=np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]]) </span><br><span class="line"><span class="comment"># 列</span></span><br><span class="line">cols=np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]) </span><br><span class="line"><span class="comment"># 通过数组进行一一对应的slice</span></span><br><span class="line"><span class="comment"># 获取四个角落的元素</span></span><br><span class="line">x[rows,cols]</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p><mark>布尔索引会将一个多维数组转化为一个一维数组</mark><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">         [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过布尔之后相当于直接展开了</span></span><br><span class="line"><span class="comment"># 将一个多维数组转化为了一维数组</span></span><br><span class="line">x[x &gt;  <span class="number">5</span>]</span><br><span class="line">  array([ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line">x[x != <span class="number">10</span>]</span><br><span class="line">  array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure><p></p><p><code>~</code>表示取补操作：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([np.nan,  <span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line">a</span><br><span class="line">  array([nan,  <span class="number">1.</span>,  <span class="number">2.</span>, nan,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ~表示的是取补</span></span><br><span class="line"><span class="comment"># 去掉数组中是nan的元素</span></span><br><span class="line">a[~np.isnan(a)]</span><br><span class="line">  array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>])</span><br><span class="line"></span><br><span class="line">~np.isnan(a)</span><br><span class="line">  array([<span class="keyword">False</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外~还有和-类似的结果，可以表示倒数第几行的元素</span></span><br><span class="line">x[~<span class="number">1</span>]</span><br><span class="line">  array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">x[<span class="number">-1</span>]</span><br><span class="line">  array([ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p>花式索引其实感觉和整数索引相差不多：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个8行4列的数组</span></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">x</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">         [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">         [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">         [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">         [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">         [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只提供一维信息的话就是另一维的信息全部保留</span></span><br><span class="line"><span class="comment"># 可以调整行的顺序</span></span><br><span class="line">x[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]]</span><br><span class="line">  array([[<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">         [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">         [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以从后面开始提取</span></span><br><span class="line"><span class="comment"># 提供负数就是从最后一行开始选取，最后一行表示-1，从上依次递推</span></span><br><span class="line">x[[<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-7</span>]]</span><br><span class="line">  array([[ <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">         [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">         [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">         [ <span class="number">8</span>, <span class="number">11</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p></p><p>前面提到如果二维数组中使用两个离散索引会进行一一对应地选取元素，不会进行组合，如果想要<strong>进行组合</strong>可以使用如下命令：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.ix_之后相当于是组合，两个维度之间进行组合</span></span><br><span class="line">x[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])]</span><br><span class="line">  array([[ <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">         [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">         [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">         [ <span class="number">8</span>, <span class="number">11</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为对比，下面的这个就只是一一对应的，不是上面的组合</span></span><br><span class="line">x[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">  array([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="截取操作"><a href="#截取操作" class="headerlink" title="截取操作"></a>截取操作</h2><h3 id="截取对角线元素"><a href="#截取对角线元素" class="headerlink" title="截取对角线元素"></a>截取对角线元素</h3><p>截取对角线元素其实就是前面<a href="http://showteeth.tech/posts/24507.html">创建对角矩阵</a>的反向操作：</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.diag(v, k=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># k：表示对角线的位置，默认为0，表示主对角线</span></span><br><span class="line"><span class="comment"># k可以指定对角线索引偏移</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个4x4的矩阵</span></span><br><span class="line">x=np.arange(<span class="number">1</span>,<span class="number">17</span>,<span class="number">1</span>).reshape((<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">x</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">         [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取主对角线元素</span></span><br><span class="line">np.diag(x)</span><br><span class="line">  array([ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>, <span class="number">16</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对角线向上偏移1</span></span><br><span class="line">np.diag(x,k=<span class="number">1</span>)</span><br><span class="line">  array([ <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># diagflat是创建对角矩阵，指定的是对角线的元素</span></span><br><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],k=<span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果数组不是标准的正方数组</span></span><br><span class="line">x=np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">x</span><br><span class="line">  array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 获取主对角线元素</span></span><br><span class="line">np.diag(x)</span><br><span class="line">  array([ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="截取上下三角阵"><a href="#截取上下三角阵" class="headerlink" title="截取上下三角阵"></a>截取上下三角阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建下三角矩阵，下三角内容的填充由array_like内容中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将上三角的内容设置为0</span></span><br><span class="line">np.tril(array_like, k=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建上三角矩阵，上三角内容的填充由array_like内容中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将下三角的内容设置为0</span></span><br><span class="line">np.triu(array_like, k=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建上三角矩阵，内容从指定的array_like中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将下三角的内容设置为0</span></span><br><span class="line">np.triu([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]], <span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建下三角矩阵，内容从指定的array_like中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将上三角的内容设置为0</span></span><br><span class="line">np.triu([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]], <span class="number">0</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组堆叠"><a href="#数组堆叠" class="headerlink" title="数组堆叠"></a>数组堆叠</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=np.arange(<span class="number">1</span>,<span class="number">7</span>,<span class="number">1</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">b=np.arange(<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">b</span><br><span class="line">  array([[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><h3 id="纵向堆叠"><a href="#纵向堆叠" class="headerlink" title="纵向堆叠"></a>纵向堆叠</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入元组</span></span><br><span class="line"><span class="comment"># 纵向堆叠多个数组</span></span><br><span class="line">np.vstack(tup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向堆叠多个数组</span></span><br><span class="line">np.row_stack(tup)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.vstack((a,b))</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">np.row_stack((a,b))</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="横向拓展"><a href="#横向拓展" class="headerlink" title="横向拓展"></a>横向拓展</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入元组</span></span><br><span class="line"><span class="comment"># 横向拓展</span></span><br><span class="line">np.hstack(tup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 横向拓展多个数组</span></span><br><span class="line">np.column_stack(tup)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a,b))</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">np.column_stack((a,b))</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用统一的函数"><a href="#使用统一的函数" class="headerlink" title="使用统一的函数"></a>使用统一的函数</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 横向或者纵向堆叠数组</span></span><br><span class="line"><span class="comment"># 传入的也是元组</span></span><br><span class="line">np.concatenate((a1, a2, ...), axis=<span class="number">0</span>, out=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沿列方向进行concat，就是列不变，行增加</span></span><br><span class="line"><span class="comment"># 和pandas的concat相同</span></span><br><span class="line">np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿行方向进行concat，就是行不变，列增加</span></span><br><span class="line"><span class="comment"># 和pandas的concat相同</span></span><br><span class="line">np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="关于np-r-和np-c"><a href="#关于np-r-和np-c" class="headerlink" title="关于np.r_和np.c_"></a>关于np.r_和np.c_</h2><p><code>np.r_</code>和<code>np.c_</code>可以将一系列的序列<strong>合并到一个数组</strong>中，调用是要用中括号<code>[]</code>,而不是<code>()</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传递两个列表，会对其进行拓展</span></span><br><span class="line">np.r_[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递两个列表，先变为列，然后进行列的拓展</span></span><br><span class="line">np.c_[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以指定合并后的维度以及维度提升的轴</span></span><br><span class="line">np.r_[<span class="string">'0,2,0'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">  array([[<span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>]])</span><br><span class="line">np.r_[<span class="string">'0,2,1'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 上面代码片段的第一个控制参数0表示将在第一个维度对后面的序列进行合并</span></span><br><span class="line"><span class="comment"># 第二个控制参数2表示：合并后的结果最少要2维，所以在合并前对维度较少的序列进行维度提升</span></span><br><span class="line"><span class="comment"># 提升的方式则是有第3个参数决定的，提升的具体方法是在原始序列的维度中添加1</span></span><br><span class="line"><span class="comment"># 关于这个1添加的位置，默认情况下，是放在维度元组的前面，np.array([1,2,3])的维度为(3,)，1放在前面就是(1,3)</span></span><br><span class="line"><span class="comment"># 如果指定了第三个参数为0，则会将1放在维度元组的后面，即(3,1)</span></span><br><span class="line"><span class="comment"># In other words the third integer allows you to specify </span></span><br><span class="line"><span class="comment"># where the 1's should be placed in the shape of the arrays that have their shapes upgraded</span></span><br><span class="line"><span class="comment"># By default, they are placed in the front of the shape tuple.</span></span><br><span class="line"><span class="comment"># a third argument of '0' would place the 1's at the end of the array shape.</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.runoob.com/numpy/numpy-ndexing-and-slicing.html" target="_blank" rel="noopener">NumPy 切片和索引</a></li><li><a href="https://www.runoob.com/numpy/numpy-advanced-indexing.html" target="_blank" rel="noopener">NumPy 高级索引</a></li><li><a href="https://wklchris.github.io/Py3-numpy.html#%E4%BB%8E%E5%B7%B2%E6%9C%89%E6%95%B0%E6%8D%AE%E6%88%AA%E5%8F%96--%E6%8B%BC%E6%8E%A5" target="_blank" rel="noopener">Python科学计算：numpy</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter NoteBook 的快捷键使用指南(转载)</title>
      <link href="/posts/36813.html"/>
      <url>/posts/36813.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要介绍了jupyter中常用的快捷键。jupyter中的快捷键主要包括两种：<strong>命令模式的快捷键</strong>和<strong>编辑模式的快捷键</strong>，两张模式之间的切换：从<strong>命令模式进入编辑模式</strong>需按 <code>Enter</code> 键，从<strong>编辑模式切换到命令模式</strong>需按 <code>Esc</code> 键。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Jupyter Notebook 有两种键盘输入模式：<strong>命令模式</strong>和<strong>编辑模式</strong>，这与 <code>Vim</code> 有些类似。</p><ul><li><strong>在编辑模式下</strong>，可以往单元中键入代码或文本，此时单元格被<strong>绿色的框线</strong>包围，且命令模式下的快捷键不生效</li><li><strong>在命令模式下</strong>，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时的单元格<strong>被蓝色的框线</strong>包围，且编辑模式下的快捷键不生效。</li></ul><p>从<strong>命令模式进入编辑模式</strong>需按 <code>Enter</code> 键，从<strong>编辑模式切换到命令模式</strong>需按 <code>Esc</code> 键。</p><p>以下两表分别是对命令和编辑两种模式下快捷键的简单说明.</p><hr><h2 id="命令模式快捷键（按-Esc-键开启）"><a href="#命令模式快捷键（按-Esc-键开启）" class="headerlink" title="命令模式快捷键（按 Esc 键开启）"></a>命令模式快捷键（按 Esc 键开启）</h2><p>注意要使用这里面的快捷键<mark>需要先使用ESC键开启命令模式快捷键</mark>：<br><table><thead><tr><th width="20%">快捷键</th><th width="20%">作用</th><th width="60%">说明</th></tr></thead><tbody><tr><td>Enter</td><td>转入编辑模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下个单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td><strong>Alt-Enter</strong></td><td>运行本单元，在其下插入新单元</td><td>新单元默认为编辑模式</td></tr><tr><td><strong>Y</strong></td><td>单元转入代码状态</td><td></td></tr><tr><td><strong>M</strong></td><td>单元转入 markdown 状态</td><td></td></tr><tr><td>R</td><td>单元转入 raw 状态</td><td></td></tr><tr><td><strong>ALT + UP</strong></td><td>单元格上移</td><td></td></tr><tr><td><strong>ALT + DOWN</strong></td><td>单元格下移</td><td></td></tr><tr><td>1</td><td>设定 1 级标题</td><td>仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态</td></tr><tr><td>2</td><td>设定 2 级标题</td><td></td></tr><tr><td>3</td><td>设定 3 级标题</td><td></td></tr><tr><td>4</td><td>设定 4 级标题</td><td></td></tr><tr><td>5</td><td>设定 5 级标题</td><td></td></tr><tr><td>6</td><td>设定 6 级标题</td><td></td></tr><tr><td>Up</td><td>选中上方单元</td><td></td></tr><tr><td>K</td><td>选中上方单元</td><td></td></tr><tr><td>Down</td><td>选中下方单元</td><td></td></tr><tr><td>J</td><td>选中下方单元</td><td></td></tr><tr><td><strong>Shift-K</strong></td><td>连续选择上方单元</td><td></td></tr><tr><td><strong>Shift-J</strong></td><td>连续选择下方单元</td><td></td></tr><tr><td>A</td><td>在上方插入新单元</td><td></td></tr><tr><td>B</td><td>在下方插入新单元</td><td></td></tr><tr><td>X</td><td>剪切选中的单元</td><td></td></tr><tr><td>C</td><td>复制选中的单元</td><td></td></tr><tr><td>Shift-V</td><td>粘贴到上方单元</td><td></td></tr><tr><td>V</td><td>粘贴到下方单元</td><td></td></tr><tr><td>Z</td><td>恢复删除的最后一个单元</td><td></td></tr><tr><td>D,D</td><td>删除选中的单元</td><td>连续按两个 D 键</td></tr><tr><td>Shift-M</td><td>合并选中的单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>L</td><td>开关行号</td><td>编辑框的行号是可以开启和关闭的</td></tr><tr><td>O</td><td>转换输出</td><td></td></tr><tr><td>Shift-O</td><td>转换输出滚动</td><td></td></tr><tr><td>Esc</td><td>关闭页面</td><td></td></tr><tr><td>Q</td><td>关闭页面</td><td></td></tr><tr><td>H</td><td>显示快捷键帮助</td><td></td></tr><tr><td>I,I</td><td>中断 NoteBook 内核</td><td></td></tr><tr><td>0,0</td><td>重启 NoteBook 内核</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Shift-Space</td><td>向上滚动</td><td></td></tr><tr><td>Space</td><td>向下滚动</td><td></td></tr></tbody></table></p><hr><h2 id="编辑模式快捷键（-按-Enter-键启动）"><a href="#编辑模式快捷键（-按-Enter-键启动）" class="headerlink" title="编辑模式快捷键（ 按 Enter 键启动）"></a>编辑模式快捷键（ 按 Enter 键启动）</h2><p>注意要使用这里面的快捷键<mark>需要先使用Enter键开启编辑模式快捷键</mark>：<br><table><thead><tr><th width="20%">快捷键</th><th width="40%">作用</th><th width="40%">说明</th></tr></thead><tbody><tr><td>Tab</td><td>代码补全或缩进</td><td></td></tr><tr><td>Shift-Tab</td><td>提示</td><td>输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 <code>?</code> 再运行会显示更加详细的帮助</td></tr><tr><td>Ctrl-]</td><td>缩进</td><td>向右缩进</td></tr><tr><td>Ctrl-[</td><td>解除缩进</td><td>向左缩进</td></tr><tr><td>Ctrl-A</td><td>全选</td><td></td></tr><tr><td>Ctrl-Z</td><td>撤销</td><td></td></tr><tr><td>Ctrl-Shift-Z</td><td>重做</td><td></td></tr><tr><td>Ctrl-Y</td><td>重做</td><td></td></tr><tr><td>Ctrl-Home</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-Up</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-End</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Down</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Left</td><td>跳到左边一个字首</td><td></td></tr><tr><td>Ctrl-Right</td><td>跳到右边一个字首</td><td></td></tr><tr><td>Ctrl-Backspace</td><td>删除前面一个字</td><td></td></tr><tr><td>Ctrl-Delete</td><td>删除后面一个字</td><td></td></tr><tr><td>Esc</td><td>切换到命令模式</td><td></td></tr><tr><td>Ctrl-M</td><td>切换到命令模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下一单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在下面插入一单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Ctrl-Shift--</td><td>分割单元</td><td>按光标所在行进行分割</td></tr><tr><td>Ctrl-Shift-Subtract</td><td>分割单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Up</td><td>光标上移或转入上一单元</td><td></td></tr><tr><td>Down</td><td>光标下移或转入下一单元</td><td></td></tr><tr><td>Ctrl-/</td><td>注释整行/撤销注释</td><td>仅代码状态有效</td></tr></tbody></table></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://opus.konghy.cn/ipynb/jupyter-notebook-keyboard-shortcut.html" target="_blank" rel="noopener">Jupyter NoteBook 的快捷键使用指南</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之numpy-数组与矩阵运算(一)：数组创建</title>
      <link href="/posts/24507.html"/>
      <url>/posts/24507.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用numpy<strong>创建数组的一些方法</strong>，包括 <strong><code>从列表或元组创建</code></strong>、<strong><code>创建特殊的数组(预分配数组、全0、全1、填充数组、单位矩阵、对角矩阵、上下三角矩阵)</code></strong>，期间也对numpy <strong><code>数组的属性</code></strong>以及 <strong><code>支持的数据类型</code></strong>进行了学习；还学习了 <strong>创建数列的方法</strong>，包括 <strong><code>指定步长的数列</code></strong>、<strong><code>指定数列长度的数列(等差、等比数列)</code></strong>；也学习了<strong>创建内容随机并且符合某种分布的numpy.random</strong>中的一些常见方法。</p></div><a id="more"></a><h2 id="numpy简介"><a href="#numpy简介" class="headerlink" title="numpy简介"></a>numpy简介</h2><p>NumPy 代表 “Numeric Python”，是一个由多维数组对象和用于处理数组的例程集合组成的库。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算，这类数值计算广泛用于以下任务：</p><ul><li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li><li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li><li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li></ul><hr><h2 id="由列表或者元组创建数组"><a href="#由列表或者元组创建数组" class="headerlink" title="由列表或者元组创建数组"></a>由列表或者元组创建数组</h2><p>使用的方法为<code>np.array(list or tuple)或者np.asarray(list or tuple)</code>，<strong>数据类型</strong>将由原序列中的元素类型推导而来。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = <span class="keyword">None</span>, copy = <span class="keyword">True</span>, order = <span class="string">'K'</span>, subok = <span class="keyword">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the input to an array.</span></span><br><span class="line">numpy.asarray(a, dtype = <span class="keyword">None</span>, order = <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>函数参数说明</strong>：<br><table><thead><tr><th width="10%">名称</th><th width="90%">描述</th></tr></thead><tbody><tr><td>object</td><td>数组或嵌套的数列</td></tr><tr><td>dtype</td><td>数组元素的数据类型，可选</td></tr><tr><td>copy</td><td>对象是否需要复制，可选</td></tr><tr><td>order</td><td>创建数组的样式(数据在内存中存储的方向)，C为行方向，F为列方向</td></tr><tr><td>subok</td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一维列表创建一维数组</span></span><br><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr1 = np.array(dt1)</span><br><span class="line">arr1  <span class="comment"># 一行六列的数组</span></span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维列表创建二维数组</span></span><br><span class="line">dt2=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">arr2=np.array(dt2)</span><br><span class="line">arr2</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最小维度为2</span></span><br><span class="line"><span class="comment"># dt1是一维的列表，设置最小维度为2</span></span><br><span class="line"><span class="comment"># 使得创建的数组是2维数组，和由二维列表创建的dt2维度相同</span></span><br><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr1 = np.array(dt1,ndmin=<span class="number">2</span>)</span><br><span class="line">arr1</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一维元组创建</span></span><br><span class="line">dt3 = np.array((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">dt3</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由二维元组创建</span></span><br><span class="line">dt4 = np.array(((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)))</span><br><span class="line">dt4</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p></p><p>注意：<strong>如果序列中的元素类型不统一，会将所有的转化为同一种类型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表中的元素类型不统一，包括字符串和数字</span></span><br><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'6'</span>]</span><br><span class="line">arr1 = np.array(dt1)</span><br><span class="line">arr1</span><br><span class="line">  <span class="comment"># 返回的结果是'&lt;U21'，数字和字符串的mix</span></span><br><span class="line">  array([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>], dtype=<span class="string">'&lt;U21'</span>)</span><br></pre></td></tr></table></figure><p></p><p>如果<strong>不想让数组自动推断序列的元素数据类型(防止出现上面那种不想看到的结果)</strong>，可以在数组创建时，<strong>直接指定数据类型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'6'</span>]</span><br><span class="line">arr1 = np.array(dt1,dtype=<span class="string">'int16'</span>)</span><br><span class="line">arr1</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], dtype=int16)</span><br></pre></td></tr></table></figure><p></p><p>关于可以指定的数据类型，可以参考<a href="#numpy%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">下面的numpy支持的数据类型</a></p><p>如果创建的时候没有指定数据类型，在<strong>也可以在后续通过<code>np.astype</code>来转换数据类型</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dt1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'6'</span>]</span><br><span class="line">arr1 = np.array(dt1)</span><br><span class="line">arr1</span><br><span class="line">  array([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>], dtype=<span class="string">'&lt;U21'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续数据类型的转换</span></span><br><span class="line"><span class="comment"># 这种转换方式是错的</span></span><br><span class="line">arr1.dtype=<span class="string">'int16'</span></span><br><span class="line">arr1</span><br><span class="line">  <span class="comment"># 输出结果和真是的结果相差较大</span></span><br><span class="line">  <span class="comment"># 实际上就是将上面的unicode转化为了int16，不会得到1,2,3,4,5,6这种结果</span></span><br><span class="line">  array([<span class="number">49</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        .............</span><br><span class="line">        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">      dtype=int16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用np.astype进行后续的转换，就可以得到正确的结果</span></span><br><span class="line">arr1=arr1.astype(np.int)</span><br><span class="line">arr1</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">arr1.dtype</span><br><span class="line">  dtype(<span class="string">'int64'</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>可以由其他的序列直接创建numpy数组，原始的序列是几维的，创建得到的数组就是几维的</li><li>如果序列中<strong>存在多种数据类型(尤其是数组中存在数字和字符这种mix)</strong>，最好的解决方法就是<strong>在创建数组的同时指定数据类型(默认创建时numpy会进行统一数据类型处理)</strong>，以免得到自己不想要的结果，影响后续的计算</li><li>上述两个函数将列表或元组转换为数组其实并没有什么差别，<code>numpy.asarray</code>是将输入转化为数组，而<code>np.array</code>是创建数组，还可以<strong>从可迭代对象中建立数组</strong>等，更多的方法请查看<a href="https://www.runoob.com/numpy/numpy-array-from-existing-data.html" target="_blank" rel="noopener">这个链接</a>.</li></ul></div><hr><h2 id="numpy中的数据类型"><a href="#numpy中的数据类型" class="headerlink" title="numpy中的数据类型"></a>numpy中的数据类型</h2><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型:<br><table><thead><tr><th width="15%">名称</th><th width="85%">描述</th></tr></thead><tbody><tr><td>bool_</td><td>布尔型数据类型（True 或者 False）</td></tr><tr><td>int_</td><td>默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr><td>intc</td><td>与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr><td>intp</td><td>用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr><td>int8</td><td>字节（-128 to 127）</td></tr><tr><td>int16</td><td>整数（-32768 to 32767）</td></tr><tr><td>int32</td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td>int64</td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td>uint8</td><td>无符号整数（0 to 255）</td></tr><tr><td>uint16</td><td>无符号整数（0 to 65535）</td></tr><tr><td>uint32</td><td>无符号整数（0 to 4294967295）</td></tr><tr><td>uint64</td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td>float_</td><td>float64 类型的简写</td></tr><tr><td>float16</td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td>float32</td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td>float64</td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td>complex_</td><td>complex128 类型的简写，即 128 位复数</td></tr><tr><td>complex64</td><td>复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td>complex128</td><td>复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table></p><p>有时候我们会看到一些特殊的情况，比如前面的<code>dtype=&#39;&lt;U21&#39;</code>，这个是什么含义呢？U其实代表的是Unicode类型，具体的每个内建类型都有一个唯一定义它的字符代码，如下：</p><table><thead><tr><th width="10%">字符</th><th width="90%">对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>(有符号) 整型</td></tr><tr><td>u</td><td>无符号整型 integer</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>(Python) 对象</td></tr><tr><td>S, a</td><td>(byte-)字符串</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据 (void)</td></tr></tbody></table><hr><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>在NumPy中维度(dimensions)叫做轴(axis)，轴的个数叫做秩(rank)。上面由一维列表或者元组创建的数组都是一个秩为1的数组，因为它们只有一个轴，如<code>array([1, 2, 3, 4, 5, 6])</code>，且这个轴的长度为6；而由二维列表或者元组创建的数组都是秩为2的数组。</p><p>在使用中的很多时候需要声明 <code>axis</code>：</p><ul><li><code>axis=0</code>，表示沿着第 0 轴进行操作，即<strong>对每一列进行操作</strong></li><li><code>axis=1</code>，表示沿着第1轴进行操作，即<strong>对每一行进行操作</strong></li></ul><p>NumPy的数组类被称作<code>ndarray</code>，通常被称作数组，相比于标准Python库类<code>array.array</code>，<code>ndarray</code>提供了更多的对象属性：<br><table><thead><tr><th width="20%">属性</th><th width="80%">说明</th></tr></thead><tbody><tr><td>ndarray.ndim</td><td>秩，即轴的数量或维度的数量，如二维数组的秩就是2</td></tr><tr><td>ndarray.shape</td><td>数组的维度，返回一个元组。一个n排m列的矩阵，它的shape属性将是(n,m)，这个元组的长度显然是秩，即ndim属性</td></tr><tr><td>ndarray.size</td><td>数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td>ndarray.dtype</td><td>ndarray 对象的元素类型</td></tr><tr><td>ndarray.itemsize</td><td>ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td>ndarray.flags</td><td>ndarray 对象的内存信息</td></tr><tr><td>ndarray.real</td><td>ndarray元素的实部</td></tr><tr><td>ndarray.imag</td><td>ndarray 元素的虚部</td></tr><tr><td>ndarray.data</td><td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dt4</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组的秩，即维度数目</span></span><br><span class="line">dt4.ndim</span><br><span class="line">  <span class="comment"># 返回2表示为2维数组</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组维度</span></span><br><span class="line">dt4.shape</span><br><span class="line"><span class="comment"># 返回的元组表示数组为二维数组，且每一维的长度分别为2和3</span></span><br><span class="line">  (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组大小</span></span><br><span class="line">dt4.size</span><br><span class="line">  <span class="comment"># 返回为6，上面的每一位长度的乘积 </span></span><br><span class="line">  <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组的数据类型</span></span><br><span class="line">dt4.dtype</span><br><span class="line">  dtype(<span class="string">'int64'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建特殊数组"><a href="#创建特殊数组" class="headerlink" title="创建特殊数组"></a>创建特殊数组</h2><p>通常，数组的元素开始都是未知的，但是它的大小已知。因此，<strong>NumPy提供了一些使用占位符创建数组的函数</strong>。</p><h3 id="创建预分配数组-np-empty-empty-like"><a href="#创建预分配数组-np-empty-empty-like" class="headerlink" title="创建预分配数组-np.empty()|empty_like()"></a>创建预分配数组-np.empty()|empty_like()</h3><p>预分配数组<strong>只是初始化了数组尺寸</strong>，但是不保证元素值为0或者1，<strong>其内容是随机并且依赖与内存状态的</strong>，<strong>默认创建得到的数据类型都为float</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = float, order = <span class="string">'C'</span>)</span><br><span class="line"><span class="comment"># shape为数组的维度，可以使用元组或者列表，为了和np.shape的返回值保持一致，使用元组最好</span></span><br><span class="line"><span class="comment"># order有"C"和"F"两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序</span></span><br><span class="line"><span class="comment"># order一般用不上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以a为模板，创建相同维度的预分配数组</span></span><br><span class="line">numpy.empty_like(a, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="comment"># 返回一个内容随机的数组</span></span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">         [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据模板创建</span></span><br><span class="line">dt3.shape</span><br><span class="line">  <span class="comment"># dt3是一个一维的数组</span></span><br><span class="line">  (<span class="number">3</span>,)</span><br><span class="line"><span class="comment"># 创建一个和dt3同shape的数组</span></span><br><span class="line">np.empty_like(dt4)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建全0-全1数组-np-zeros-ones"><a href="#创建全0-全1数组-np-zeros-ones" class="headerlink" title="创建全0|全1数组-np.zeros()|ones()"></a>创建全0|全1数组-np.zeros()|ones()</h3><p>和前面的<code>empty</code>函数不同的是，这里创建的数组的内容都为<code>0(np.zeros)</code>或<code>1(np.ones)</code>，而<strong>非随机</strong>，<strong>默认创建得到的数据类型都为float</strong>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = float, order = <span class="string">'C'</span>)</span><br><span class="line">numpy.ones(shape, dtype = <span class="keyword">None</span>, order = <span class="string">'C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以a为模板，创建相同维度的全1或0数组</span></span><br><span class="line">np.ones_like(a, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br><span class="line">np.zeros_like(a, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建全1数组</span></span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="comment"># 数组的内容全为1</span></span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全0数组</span></span><br><span class="line">np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="comment"># 数组的内容全为0 </span></span><br><span class="line">  array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以dt3为模板创建相同维度的全1数组</span></span><br><span class="line">np.ones_like(dt3)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 以dt3为模板创建相同维度的全0数组</span></span><br><span class="line">np.zeros_like(dt3)</span><br><span class="line">  array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建填充数组"><a href="#创建填充数组" class="headerlink" title="创建填充数组"></a>创建填充数组</h3><p>前面的几个创建数组的方式，要么内容是全随机的，要么是全为0或1的数组，如果希望使用指定的值来填充数组，得到全为指定值的数据可以使用np.full函数。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.full(shape, fill_value, dtype=<span class="keyword">None</span>, order=<span class="string">'C'</span>)</span><br><span class="line"></span><br><span class="line">np.full_like(a, fill_value, dtype=<span class="keyword">None</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个2行3列，内容全为0.2的数组</span></span><br><span class="line">np.full((<span class="number">2</span>,<span class="number">3</span>),<span class="number">0.2</span>)</span><br><span class="line">  <span class="comment"># 输出2行3列，内容全为0.2的数组</span></span><br><span class="line">  array([[<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">        [<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建单位矩阵-np-identity-eye"><a href="#创建单位矩阵-np-identity-eye" class="headerlink" title="创建单位矩阵-np.identity()|eye()"></a>创建单位矩阵-np.identity()|eye()</h3><p>单位矩阵是指<strong>对角线上元素全为1</strong>并且<strong>除此以外元素全都为0</strong>的矩阵，严格的单位阵使用 <code>np.identity()</code> 命令创建，非严格的单位矩阵可以使用<code>np.eye()</code>创建。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.identity(n, dtype=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">np.eye(N, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C')</span><br><span class="line"><span class="comment"># N：行数</span></span><br><span class="line"><span class="comment"># M：列数</span></span><br><span class="line"><span class="comment"># k：对角线的索引，默认是主对角线，大于0表示偏上的对角线，小于0表示偏下的对角线</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建3行3列的单位矩阵</span></span><br><span class="line">np.identity(<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建2行3列的单位矩阵</span></span><br><span class="line"><span class="comment"># 默认的对角线索引为0</span></span><br><span class="line">np.eye(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建2行3列的单位矩阵，对角线索引为1，向上平移</span></span><br><span class="line">np.eye(<span class="number">2</span>,<span class="number">3</span>,k=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建2行3列的单位矩阵，对角线索引为-1，向下平移</span></span><br><span class="line">np.eye(<span class="number">2</span>,<span class="number">3</span>,k=<span class="number">-1</span>)</span><br><span class="line">  array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>np.identity()</code>创建的是严格的单位矩阵，首先，<strong>矩阵是正方矩阵(行数和列数相同)</strong>，其次，只有<strong>主对角线的元素为1</strong></li><li><code>np.eye()</code>创建的是非严格的单位矩阵，对应地，矩阵<strong>不一定是正方矩阵</strong>，并且<strong>元素为1的对角线位置可以调整</strong></li></ul></div><hr><h3 id="创建对角矩阵-np-diagflat"><a href="#创建对角矩阵-np-diagflat" class="headerlink" title="创建对角矩阵-np.diagflat()"></a>创建对角矩阵-np.diagflat()</h3><p>对角矩阵是一个主对角线之外的元素皆为0的矩阵，对角线上的元素可以为0或其他值，单位矩阵就是对角矩阵的一种，其对角线上的元素为1。对角矩阵的创建使用<code>np.diagflat()</code>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.diagflat(array_like, k=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># array_like：类似数组的序列，可以是列表、数组、元组，序列的元素数目表示了矩阵的行数(在未指定k的前提下)</span></span><br><span class="line"><span class="comment"># 序列的每个元素依次填充在对角矩阵的每一行对应的位置</span></span><br><span class="line"><span class="comment"># k：对角线的索引位置</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建对角线元素为1,2,3,4的对角矩阵</span></span><br><span class="line"><span class="comment"># 列表元素数目为2，所以对角矩阵为4行4列</span></span><br><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 也可以使用二维的列表创建</span></span><br><span class="line">np.diagflat([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对角矩阵对角线填充位置开始于1</span></span><br><span class="line"><span class="comment"># 此时的元素数目为4，但是因为设置了k=1，所以行数和列数都变为了5</span></span><br><span class="line">np.diagflat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],k=<span class="number">1</span>)</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建上下三角矩阵"><a href="#创建上下三角矩阵" class="headerlink" title="创建上下三角矩阵"></a>创建上下三角矩阵</h3><p>下三角矩阵是指对角线上方的元素全部为0的矩阵，同样的，上三角矩阵是指对角线下方的元素全部为0的矩阵。创建这种矩阵，numpy提供了几种函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建下三角矩阵，且下三角中的元素全为1</span></span><br><span class="line">np.tri(N, M=<span class="keyword">None</span>, k=<span class="number">0</span>, dtype=&lt;<span class="class"><span class="keyword">class</span> '<span class="title">float</span>'&gt;)</span></span><br><span class="line"><span class="class"># <span class="title">N</span>：行数</span></span><br><span class="line"><span class="class"># <span class="title">M</span>：列数</span></span><br><span class="line"><span class="class"># <span class="title">k</span>：对角线的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 创建下三角矩阵，下三角内容的填充由<span class="title">array_like</span>内容中选取</span></span><br><span class="line"><span class="class"># 相当于先使用<span class="title">array_like</span>创建矩阵，然后将上三角的内容设置为0</span></span><br><span class="line"><span class="class"><span class="title">np</span>.<span class="title">tril</span><span class="params">(array_like, k=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 创建上三角矩阵，上三角内容的填充由<span class="title">array_like</span>内容中选取</span></span><br><span class="line"><span class="class"># 相当于先使用<span class="title">array_like</span>创建矩阵，然后将下三角的内容设置为0</span></span><br><span class="line"><span class="class"><span class="title">np</span>.<span class="title">triu</span><span class="params">(array_like, k=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建不严格的下三角矩阵，2行3列</span></span><br><span class="line"><span class="comment"># 且下三角矩阵的元素为1</span></span><br><span class="line">np.tri(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建严格的下三角矩阵，3行3列</span></span><br><span class="line">np.tri(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建上三角矩阵，内容从指定的array_like中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将下三角的内容设置为0</span></span><br><span class="line">np.triu([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]], <span class="number">0</span>)</span><br><span class="line">  array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建下三角矩阵，内容从指定的array_like中选取</span></span><br><span class="line"><span class="comment"># 相当于先使用array_like创建矩阵，然后将上三角的内容设置为0</span></span><br><span class="line">np.triu([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]], <span class="number">0</span>)</span><br><span class="line">  array([[ <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建数列"><a href="#创建数列" class="headerlink" title="创建数列"></a>创建数列</h2><h3 id="创建非等差或等比数列"><a href="#创建非等差或等比数列" class="headerlink" title="创建非等差或等比数列"></a>创建非等差或等比数列</h3><p>如果想要创建的数列<strong>不是等步长或者等比这种规律性比较明显的数列</strong>，可以使用如下方法创建：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内容完全是没有规律的</span></span><br><span class="line"><span class="comment"># 直接通过np.array对象创建</span></span><br><span class="line">np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一部分存在规律</span></span><br><span class="line"><span class="comment"># 比如得到1,2,3,7,9</span></span><br><span class="line">np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># 拼接两个列表得到数组</span></span><br><span class="line">np.r_[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建指定步长的数列"><a href="#创建指定步长的数列" class="headerlink" title="创建指定步长的数列"></a>创建指定步长的数列</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange([start,] stop[, step,], dtype=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong>：<br><table><thead><tr><th width="10%">参数</th><th width="90%">描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>起始值，默认为<code>0</code></td></tr><tr><td><code>stop</code></td><td>终止值（不包含）</td></tr><tr><td><code>step</code></td><td>步长，默认为<code>1</code></td></tr><tr><td><code>dtype</code></td><td>返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建从1开始，到5结束(不包括5)，步长为1的数列</span></span><br><span class="line">np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">  array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建指定长度的数组"><a href="#创建指定长度的数组" class="headerlink" title="创建指定长度的数组"></a>创建指定长度的数组</h3><h4 id="等差数组"><a href="#等差数组" class="headerlink" title="等差数组"></a>等差数组</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="keyword">True</span>, retstep=<span class="keyword">False</span>, dtype=<span class="keyword">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong>：<br><table><thead><tr><th width="10%">参数</th><th width="90%">描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>序列的起始值</td></tr><tr><td><code>stop</code></td><td>序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td><code>num</code></td><td>要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td><code>endpoint</code></td><td>该值为 <code>ture</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是True。</td></tr><tr><td><code>retstep</code></td><td>如果为 True 时，生成的数组中会显示间距，反之不显示。</td></tr><tr><td><code>dtype</code></td><td><code>ndarray</code> 的数据类型</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建从1到9，长度为10的等差数列</span></span><br><span class="line"><span class="comment"># 默认是包括9的</span></span><br><span class="line">np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">  array([<span class="number">1.</span>        , <span class="number">1.88888889</span>, <span class="number">2.77777778</span>, <span class="number">3.66666667</span>, <span class="number">4.55555556</span>,</span><br><span class="line">        <span class="number">5.44444444</span>, <span class="number">6.33333333</span>, <span class="number">7.22222222</span>, <span class="number">8.11111111</span>, <span class="number">9.</span>        ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置不包括9 </span></span><br><span class="line">np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>,endpoint=<span class="keyword">False</span>)</span><br><span class="line">  array([<span class="number">1.</span> , <span class="number">1.8</span>, <span class="number">2.6</span>, <span class="number">3.4</span>, <span class="number">4.2</span>, <span class="number">5.</span> , <span class="number">5.8</span>, <span class="number">6.6</span>, <span class="number">7.4</span>, <span class="number">8.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示间距</span></span><br><span class="line"><span class="comment"># 返回数组和间距构成的元组</span></span><br><span class="line">np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>,retstep=<span class="keyword">True</span>)</span><br><span class="line">  (array([<span class="number">1.</span>        , <span class="number">1.88888889</span>, <span class="number">2.77777778</span>, <span class="number">3.66666667</span>, <span class="number">4.55555556</span>,</span><br><span class="line">        <span class="number">5.44444444</span>, <span class="number">6.33333333</span>, <span class="number">7.22222222</span>, <span class="number">8.11111111</span>, <span class="number">9.</span>        ]),</span><br><span class="line"> <span class="number">0.8888888888888888</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>与前面的<code>np.arange()</code>相比：</p><ul><li><code>np.linspace()</code>：不能指定间距，但可以显示间距</li><li><code>np.linspace()</code>：可以设置长度；默认是包含endpoint(可以设置为不包含)，而<code>np.arange()</code>默认是不包含，并且不可以设置</li></ul></div><hr><h4 id="等比数组"><a href="#等比数组" class="headerlink" title="等比数组"></a>等比数组</h4><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="keyword">True</span>, base=<span class="number">10.0</span>, dtype=<span class="keyword">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong>：<br><table><thead><tr><th width="10%">参数</th><th width="90%">描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>序列的起始值，实际起始值为：base ** start</td></tr><tr><td><code>stop</code></td><td>序列的终止值为，实际起始值为：base ** stop。如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td><code>num</code></td><td>要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td><code>endpoint</code></td><td>该值为 <code>ture</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是True。</td></tr><tr><td><code>base</code></td><td>对数 log 的底数。</td></tr><tr><td><code>dtype</code></td><td><code>ndarray</code> 的数据类型</td></tr></tbody></table></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是以10为底</span></span><br><span class="line">np.logspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 实际上是从10^1-10^2，长度为10的等比数列</span></span><br><span class="line">  array([ <span class="number">10.</span>        ,  <span class="number">12.91549665</span>,  <span class="number">16.68100537</span>,  <span class="number">21.5443469</span> ,</span><br><span class="line">          <span class="number">27.82559402</span>,  <span class="number">35.93813664</span>,  <span class="number">46.41588834</span>,  <span class="number">59.94842503</span>,</span><br><span class="line">          <span class="number">77.42636827</span>, <span class="number">100.</span>        ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置以2为底</span></span><br><span class="line"><span class="comment"># 从2^0-2^9，长度为10的等比数列</span></span><br><span class="line">np.logspace(<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,base=<span class="number">2</span>)  </span><br><span class="line">  array([  <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">4.</span>,   <span class="number">8.</span>,  <span class="number">16.</span>,  <span class="number">32.</span>,  <span class="number">64.</span>, <span class="number">128.</span>, <span class="number">256.</span>, <span class="number">512.</span>])</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建随机且符合某种分布的数组-np-random"><a href="#创建随机且符合某种分布的数组-np-random" class="headerlink" title="创建随机且符合某种分布的数组-np.random"></a>创建随机且符合某种分布的数组-np.random</h2><p>在实际使用中，经常需要用到numpy的随机函数，由于随机函数random的功能比较多，经常会混淆或记不住，下面就学习和列举几种比较常用的。</p><h3 id="0-1-之间的随机数-numpy-random-rand"><a href="#0-1-之间的随机数-numpy-random-rand" class="headerlink" title="[0,1)之间的随机数-numpy.random.rand()"></a>[0,1)之间的随机数-numpy.random.rand()</h3><p><code>rand</code>函数根据给定维度生成<code>[0,1)</code>之间的数据，<strong>包含0，不包含1</strong>.</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.rand(d0, d1, ..., dn)</span><br><span class="line"><span class="comment"># dn表示维度信息</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生一个四行两列的随机数组</span></span><br><span class="line"><span class="comment"># 元素的取值范围为[0,1)</span></span><br><span class="line">np.random.rand(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">  array([[<span class="number">0.6126271</span> , <span class="number">0.84776825</span>],</span><br><span class="line">         [<span class="number">0.5572775</span> , <span class="number">0.02186394</span>],</span><br><span class="line">         [<span class="number">0.51725555</span>, <span class="number">0.76771822</span>],</span><br><span class="line">         [<span class="number">0.65649717</span>, <span class="number">0.80120975</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="N-0-1-的标准正态分布-numpy-random-randn"><a href="#N-0-1-的标准正态分布-numpy-random-randn" class="headerlink" title="N(0,1)的标准正态分布-numpy.random.randn()"></a>N(0,1)的标准正态分布-numpy.random.randn()</h3><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randn(d0, d1, ..., dn)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生一个3行2列的标准正太分布</span></span><br><span class="line">np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">  array([[ <span class="number">1.79853947</span>,  <span class="number">0.57042178</span>],</span><br><span class="line">         [<span class="number">-0.07007952</span>, <span class="number">-1.45797489</span>],</span><br><span class="line">         [ <span class="number">0.82423002</span>, <span class="number">-0.4111874</span> ]])</span><br></pre></td></tr></table></figure><p></p><p>如果想要产生的<strong>不是标准正太分布</strong>可以变换：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生一个N(3, 6.25)的正太分布</span></span><br><span class="line"><span class="comment"># 2.5 * 2.5 = 6.25</span></span><br><span class="line"><span class="number">2.5</span> * np.random.randn(<span class="number">2</span>, <span class="number">4</span>) + <span class="number">3</span></span><br><span class="line">  array([[ <span class="number">3.87050085</span>,  <span class="number">4.90415633</span>,  <span class="number">0.86676374</span>,  <span class="number">1.07284953</span>],</span><br><span class="line">         [ <span class="number">2.1834204</span> ,  <span class="number">1.54992813</span>, <span class="number">-2.60284824</span>,  <span class="number">3.54083072</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="low-high-范围内的随机整数-numpy-random-randint"><a href="#low-high-范围内的随机整数-numpy-random-randint" class="headerlink" title="[low,high)范围内的随机整数-numpy.random.randint()"></a>[low,high)范围内的随机整数-numpy.random.randint()</h3><p>前面几个函数得到的都是随机的浮点型数，如果想要得到随机整数，可以使用<code>numpy.random.randint()</code>函数。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randint(low, high=<span class="keyword">None</span>, size=<span class="keyword">None</span>, dtype=<span class="string">'l'</span>)</span><br><span class="line"><span class="comment"># size:shape</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生10个在0-3范围内的随机整数</span></span><br><span class="line">np.random.randint(<span class="number">3</span>,size=<span class="number">10</span>)</span><br><span class="line">  array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生一个2行3列的，元素在0-3范围内的随机整数</span></span><br><span class="line">np.random.randint(<span class="number">3</span>,size=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="固定随机数-numpy-random-seed"><a href="#固定随机数-numpy-random-seed" class="headerlink" title="固定随机数-numpy.random.seed()"></a>固定随机数-numpy.random.seed()</h3><p>默认情况下，每次运行一遍上面的几个函数，得到的结果都会和前一次的不同，需要需要每次运行得到的随机数相同，可以使用<code>numpy.random.seed()</code>。</p><p><strong>函数形式</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(seed=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首次运行</span></span><br><span class="line">np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">0.22489862</span>, <span class="number">0.53165975</span>, <span class="number">0.57325016</span>],</span><br><span class="line">         [<span class="number">0.75665698</span>, <span class="number">0.14746711</span>, <span class="number">0.7346116</span> ]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行</span></span><br><span class="line">  array([[<span class="number">0.51628755</span>, <span class="number">0.41312364</span>, <span class="number">0.3912831</span> ],</span><br><span class="line">         [<span class="number">0.92598188</span>, <span class="number">0.88553487</span>, <span class="number">0.22607687</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定seed，多次运行都不会变</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line">np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  array([[<span class="number">0.69646919</span>, <span class="number">0.28613933</span>, <span class="number">0.22685145</span>],</span><br><span class="line">         [<span class="number">0.55131477</span>, <span class="number">0.71946897</span>, <span class="number">0.42310646</span>]])</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/214798dd8f93" target="_blank" rel="noopener">为什么你用不好Numpy的random函数？</a></li><li><a href="https://segmentfault.com/a/1190000016097466" target="_blank" rel="noopener">numpy-random函数</a></li></ul><hr><h2 id="np-random函数总结"><a href="#np-random函数总结" class="headerlink" title="np.random函数总结"></a>np.random函数总结</h2><h3 id="简单的随机数据"><a href="#简单的随机数据" class="headerlink" title="简单的随机数据"></a>简单的随机数据</h3><table><tr><th width="20%">函数</th><th width="80%">说明</th></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand" target="_blank" rel="noopener">rand</a>(d0, d1, ..., dn)</td><td>[0,1)之间的随机值，dn表示维度信息</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn" target="_blank" rel="noopener">randn</a>(d0, d1, ..., dn)</td><td>标准正态分布，可以进行变换得到非标准正太分布</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint" target="_blank" rel="noopener">randint</a>(low[, high, size])</td><td>位于半开区间 [low, high)的随机整数，不指定high的情况下是从[0,low)</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_integers.html#numpy.random.random_integers" target="_blank" rel="noopener">random_integers</a>(low[, high, size])</td><td>位于闭区间 [low, high]的随机整数，不指定high的情况下是从[1,low]</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_sample.html#numpy.random.random_sample" target="_blank" rel="noopener">random_sample</a>([size])</td><td>在半开区间 [0.0, 1.0)的随机浮点数，可以变换(b - a) * random_sample() + a；与此类似的还有<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random.html#numpy.random.random" target="_blank" rel="noopener">random</a>([size])、<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf" target="_blank" rel="noopener">ranf</a>([size])、<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.sample.html#numpy.random.sample" target="_blank" rel="noopener">sample</a>([size])</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" target="_blank" rel="noopener">choice</a>(a[, size, replace, p])</td><td>从一个给定的一维数组生成一个随机样本</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.bytes.html#numpy.random.bytes" target="_blank" rel="noopener">bytes</a>(length)</td><td>返回随机字节</td></tr></table><hr><h3 id="重新排列数组"><a href="#重新排列数组" class="headerlink" title="重新排列数组"></a>重新排列数组</h3><table><tr><th width="15%">函数</th><th width="85%">说明</th></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html#numpy.random.shuffle" target="_blank" rel="noopener">shuffle</a>(array)</td><td>打乱array的顺序，原位修改</td></tr><tr><td><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.permutation.html#numpy.random.permutation" target="_blank" rel="noopener">permutation</a>(array)</td><td>返回array的一个随机排列</td></tr></table><hr><h3 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h3><table><tr><th width="30%">函数</th><th width="70%">说明</th></tr><tr><td>beta(a, b[, size])</td><td>贝塔分布样本，在 [0, 1]内。</td></tr><tr><td>binomial(n, p[, size])</td><td>二项分布的样本。</td></tr><tr><td>chisquare(df[, size])</td><td>卡方分布样本。</td></tr><tr><td>dirichlet(alpha[, size])</td><td>狄利克雷分布样本。</td></tr><tr><td>exponential([scale, size])</td><td>指数分布</td></tr><tr><td>f(dfnum, dfden[, size])</td><td>F分布样本。</td></tr><tr><td>gamma(shape[, scale, size])</td><td>伽马分布</td></tr><tr><td>geometric(p[, size])</td><td>几何分布</td></tr><tr><td>gumbel([loc, scale, size])</td><td>耿贝尔分布。</td></tr><tr><td>hypergeometric(ngood, nbad, nsample[, size])</td><td>超几何分布样本。</td></tr><tr><td>laplace([loc, scale, size])</td><td>拉普拉斯或双指数分布样本</td></tr><tr><td>logistic([loc, scale, size])</td><td>Logistic分布样本</td></tr><tr><td>lognormal([mean, sigma, size])</td><td>对数正态分布</td></tr><tr><td>logseries(p[, size])</td><td>对数级数分布。</td></tr><tr><td>multinomial(n, pvals[, size])</td><td>多项分布</td></tr><tr><td>multivariate_normal(mean, cov[, size])</td><td>多元正态分布</td></tr><tr><td>negative_binomial(n, p[, size])</td><td>负二项分布</td></tr><tr><td>noncentral_chisquare(df, nonc[, size])</td><td>非中心卡方分布</td></tr><tr><td>noncentral_f(dfnum, dfden, nonc[, size])</td><td>非中心F分布</td></tr><tr><td>normal([loc, scale, size])</td><td>正态(高斯)分布</td></tr><tr><td>pareto(a[, size])</td><td>帕累托（Lomax）分布</td></tr><tr><td>poisson([lam, size])</td><td>泊松分布</td></tr><tr><td>power(a[, size])</td><td>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</td></tr><tr><td>rayleigh([scale, size])</td><td>Rayleigh 分布</td></tr><tr><td>standard_cauchy([size])</td><td>标准柯西分布</td></tr><tr><td>standard_exponential([size])</td><td>标准的指数分布</td></tr><tr><td>standard_gamma(shape[, size])</td><td>标准伽马分布</td></tr><tr><td>standard_normal([size])</td><td>标准正态分布 (mean=0, stdev=1).</td></tr><tr><td>standard_t(df[, size])</td><td>Standard Student’s t distribution with df degrees of freedom.</td></tr><tr><td>triangular(left, mode, right[, size])</td><td>三角形分布</td></tr><tr><td>uniform([low, high, size])</td><td>均匀分布</td></tr><tr><td>vonmises(mu, kappa[, size])</td><td>von Mises分布</td></tr><tr><td>wald(mean, scale[, size])</td><td>瓦尔德（逆高斯）分布</td></tr><tr><td>weibull(a[, size])</td><td>Weibull 分布</td></tr><tr><td>zipf(a[, size])</td><td>齐普夫分布</td></tr></table><hr><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h3><table><tr><th width="15%">函数</th><th width="85%">说明</th></tr><tr><td>RandomState</td><td>Container for the Mersenne Twister pseudo-random number generator.</td></tr><tr><td>seed([seed])</td><td>Seed the generator.</td></tr><tr><td>get_state()</td><td>Return a tuple representing the internal state of the generator.</td></tr><tr><td>set_state(state)</td><td>Set the internal state of the generator from a tuple.</td></tr></table><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.cnblogs.com/hhh5460/p/4324967.html" target="_blank" rel="noopener">numpy的random模块</a></li></ul><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之jupyter中dataframe美化</title>
      <link href="/posts/62040.html"/>
      <url>/posts/62040.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了对jupyter中<strong>美化dataframe显示的语法</strong>，主要包括用于<strong>控制显示</strong>的<code>dataframe.style.apply()</code>、<code>dataframe.style.applymap()</code>以及<strong>控制显示格式</strong>的<code>dataframe.style.format()</code>以及一些<strong>内置的用法</strong>。</p></div><a id="more"></a><h2 id="styling"><a href="#styling" class="headerlink" title="styling"></a>styling</h2><p>在pandas 0.17.1之后的版本中出现了可以formatting以及displaying dataframe的Styler object，其主要是通过添加css样式达到的目的，接下来就学习一下吧。</p><hr><h2 id="pandas的apply相关函数"><a href="#pandas的apply相关函数" class="headerlink" title="pandas的apply相关函数"></a>pandas的apply相关函数</h2><p>pandas中<code>apply(func)</code>可以将函数<strong>作用于行或者列的数据</strong>，而<code>applymap(func)</code>可以<strong>作用于table中的单个数据</strong>，在这里也结合了appy相关的函数：</p><ul><li><code>Styler.applymap(func)</code> for elementwise styles</li><li><code>Styler.apply(func, axis=0)</code> for columnwise styles</li><li><code>Styler.apply(func, axis=1)</code> for rowwise styles</li><li><code>Styler.apply(func, axis=None)</code> for tablewise styles</li></ul><hr><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df=pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="通过阈值控制颜色"><a href="#通过阈值控制颜色" class="headerlink" title="通过阈值控制颜色"></a>通过阈值控制颜色</h2><ul><li><p>定义函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showColor</span><span class="params">(val)</span>:</span></span><br><span class="line">    color= <span class="string">'red'</span> <span class="keyword">if</span> val &gt;<span class="number">0</span> <span class="keyword">else</span> <span class="string">'green'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'color:%s'</span> %color</span><br></pre></td></tr></table></figure></li><li><p>应用函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.style.applymap(showColor)</span><br></pre></td></tr></table></figure></li><li><p>展示效果<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/20190509213357.png" alt="20190509213357.png"></p></li></ul><hr><h2 id="只对指定列进行操作"><a href="#只对指定列进行操作" class="headerlink" title="只对指定列进行操作"></a>只对指定列进行操作</h2><p>注意这里的<code>subset</code>以及<code>pd.IndexSlice</code>的用法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># applymap只作用于前五行的后五列</span></span><br><span class="line">df.style.applymap(showColor,subset=pd.IndexSlice[:<span class="number">5</span>,<span class="number">5</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># applymap只作用于第三行的第5到8列，注意是包括第八列</span></span><br><span class="line">df.style.applymap(showColor,subset=pd.IndexSlice[<span class="number">2</span>,<span class="number">5</span>:<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># applymap作用于第四行的不连续的列</span></span><br><span class="line">df.style.applymap(showColor,subset=pd.IndexSlice[<span class="number">3</span>,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]])</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_2.png" alt="dataframe_bautify_2.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_3.png" alt="dataframe_bautify_3.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_4.png" alt="dataframe_bautify_4.png"></p><hr><h2 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h2><ul><li><p>定义函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给每一列最低的添加黄色的背景色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_bg</span><span class="params">(col)</span>:</span></span><br><span class="line">    <span class="comment"># 涉及到运算符顺序</span></span><br><span class="line">    <span class="comment"># 赋值运算符优先级较低</span></span><br><span class="line">    c=col==col.max()</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'background-color:yellow'</span> <span class="keyword">if</span> v <span class="keyword">else</span> <span class="string">''</span> <span class="keyword">for</span> v <span class="keyword">in</span> c]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_bg_2</span><span class="params">(col)</span>:</span></span><br><span class="line">    <span class="comment"># np.sign为符号函数，大于0的为1，小于0的为0</span></span><br><span class="line">    s=np.sign(col)==np.sign(col.max())</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'background-color:blue'</span> <span class="keyword">if</span> v <span class="keyword">else</span> <span class="string">'background-color:red'</span> <span class="keyword">for</span> v <span class="keyword">in</span> s]</span><br></pre></td></tr></table></figure></li><li><p>应用函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.style.apply(show_bg)</span><br></pre></td></tr></table></figure></li><li><p>展示效果</p></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_5.png" alt="dataframe_bautify_5.png"></p><ul><li>使用内置的函数实现：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内置的方法实现对最大值上背景色</span></span><br><span class="line"><span class="comment"># 默认颜色为黄色，可以通过color设置</span></span><br><span class="line">df.style.highlight_max(color=<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_6.png" alt="dataframe_bautify_6.png"></p><hr><h2 id="组合上面的颜色以及背景色"><a href="#组合上面的颜色以及背景色" class="headerlink" title="组合上面的颜色以及背景色"></a>组合上面的颜色以及背景色</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apply函数的subset直接指定列就行</span></span><br><span class="line">df.style.applymap(showColor).apply(show_bg,subset=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_7.png" alt="dataframe_bautify_7.png"></p><hr><h2 id="实现百分比显示"><a href="#实现百分比显示" class="headerlink" title="实现百分比显示"></a>实现百分比显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的bar显示</span></span><br><span class="line">df.style.bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的bar显示</span></span><br><span class="line">df.style.bar(subset=[<span class="string">'A'</span>, <span class="string">'B'</span>], align=<span class="string">'mid'</span>, color=[<span class="string">'#d65f5f'</span>, <span class="string">'#5fba7d'</span>])</span><br></pre></td></tr></table></figure><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_8.png" alt="dataframe_bautify_8.png"></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_10.png" alt="dataframe_bautify_10.png"></p><hr><h2 id="设置数据格式"><a href="#设置数据格式" class="headerlink" title="设置数据格式"></a>设置数据格式</h2><p>和上面的使用<code>df.style.apply</code>等不同，这里使用<code>df.style.format</code>进行格式的控制，具体对格式的控制参考<a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" target="_blank" rel="noopener">format函数</a>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百分比显示，小数点后保留两位</span></span><br><span class="line"><span class="comment"># 但是不能写到文件</span></span><br><span class="line">df.style.format(<span class="string">"&#123;:.2%&#125;"</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/dataframe_bautify_9.png" alt="dataframe_bautify_9.png"></p><hr><h2 id="更多的用法"><a href="#更多的用法" class="headerlink" title="更多的用法"></a>更多的用法</h2><p>还支持想excel中的色阶操作以及鼠标滑动上去之后方法显示数据的效果等，具体请<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/style.html" target="_blank" rel="noopener">参考官方文档</a></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/style.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://blog.csdn.net/xiaodongxiexie/article/details/71202279" target="_blank" rel="noopener">jupyter notebook中美化pandas中DataFrame的输出</a></li><li><a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" target="_blank" rel="noopener">format函数</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter进一步配置和使用</title>
      <link href="/posts/21776.html"/>
      <url>/posts/21776.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录关于jupyter的一下小工具，包括<code>ipywidgets</code>、<code>qgrid</code>、<code>输出矢量图</code>、<code>管理conda环境</code>、<code>markdown设置锚定</code>、<code>加载网页源代码或者本地python程序</code>、<code>运行本地python程序</code>等.</p></div><a id="more"></a><h2 id="ipywidgets"><a href="#ipywidgets" class="headerlink" title="ipywidgets"></a>ipywidgets</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可以实现 jupyter notebook 笔记本的交互式控件操作，个人觉得在于matplotlib进行画图配合上具有比较好的效果。</p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用conda安装</span></span><br><span class="line">conda install -c conda-forge ipywidgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># jupyter安装在base的server</span></span><br><span class="line"><span class="comment"># kernel安装在py36</span></span><br><span class="line">conda install -n base -c conda-forge widgetsnbextension</span><br><span class="line">conda install -n py36 -c conda-forge ipywidgets</span><br></pre></td></tr></table></figure><hr><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">官方文档</a>上面有很多使用的示例，个人感觉这个插件与matplotlib结合起来进行绘图可能是比较好的选择，以下是一些示例：</p><ul><li><p><a href="https://stackoverflow.com/questions/40122837/interactive-matplotlib-using-ipywidgets" target="_blank" rel="noopener">通过调整w来调整图像的显示范围</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from ipywidgets import *</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">x = np.linspace(0, 2 * np.pi)</span><br><span class="line"><span class="comment">## 通过调整w来调整图像的显示范围</span></span><br><span class="line">def update(w = 1.0):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(1, 1, 1)</span><br><span class="line">    ax.plot(x, np.sin(w * x))</span><br><span class="line"></span><br><span class="line">    fig.canvas.draw()</span><br><span class="line"></span><br><span class="line">interact(update);</span><br></pre></td></tr></table></figure></li><li><p>调整直线的斜率和截距</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">from ipywidgets import interactive</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def f(m, b):</span><br><span class="line">    plt.figure(2)</span><br><span class="line">    x = np.linspace(-10, 10, num=1000)</span><br><span class="line">    plt.plot(x, m * x + b)</span><br><span class="line">    plt.ylim(-5, 5)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">interactive_plot = interactive(f, m=(-2.0, 2.0), b=(-3, 3, 0.5))     </span><br><span class="line"><span class="comment"># m代表范围</span></span><br><span class="line">output = interactive_plot.children[-1]</span><br><span class="line">output.layout.height = <span class="string">'350px'</span></span><br><span class="line">interactive_plot</span><br></pre></td></tr></table></figure></li><li><p><a href="https://ipython-books.github.io/33-mastering-widgets-in-the-jupyter-notebook/" target="_blank" rel="noopener">多个选框，包括颜色、线宽、grid等</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@widgets.interact_manual(</span><br><span class="line">    color=[<span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'green'</span>], lw=(1., 10.))</span><br><span class="line">def plot(freq=1., color=<span class="string">'blue'</span>, lw=2, grid=True):</span><br><span class="line">    t = np.linspace(-1., +1., 1000)</span><br><span class="line">    fig, ax = plt.subplots(1, 1, figsize=(8, 6))</span><br><span class="line">    ax.plot(t, np.sin(2 * np.pi * freq * t),</span><br><span class="line">            lw=lw, color=color)</span><br><span class="line">    ax.grid(grid)</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://blog.csdn.net/sinat_26917383/article/details/84345407" target="_blank" rel="noopener">Jupyter notebook最简原型界面设计 - ipywidgets与lineup_widget</a></li><li><a href="https://github.com/jupyter-widgets/ipywidgets" target="_blank" rel="noopener">github官网</a></li><li><a href="https://www.zhihu.com/question/59392251" target="_blank" rel="noopener">知乎展示</a></li></ul><hr><h2 id="qgrid"><a href="#qgrid" class="headerlink" title="qgrid"></a>qgrid</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>主要针对的是<strong>pandas的dataframe</strong>，可以通过直观的<strong>滚动</strong>、<strong>排序</strong>和<strong>过滤</strong>控件来探索DataFrame，以及通过双击单元格来<strong>编辑</strong>DataFrame。</p><hr><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用conda安装</span></span><br><span class="line">conda install qgrid</span><br></pre></td></tr></table></figure><p>安装之后在python中调用发现<code>ModuleNotFoundError: No module named &#39;qgrid&#39;</code>，然后使用pip重新安装：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install qgrid</span><br></pre></td></tr></table></figure><p></p><p>然后调用发现<code>AttributeError: module &#39;numpy&#39; has no attribute &#39;__version__&#39;</code>，搜索得知是numpy的问题，重新安装或者升级numpy：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip numpy</span><br></pre></td></tr></table></figure><p></p><p>设置在nbextension中使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jupyter nbextension <span class="built_in">enable</span> --py --sys-prefix qgrid</span><br><span class="line">  Enabling notebook extension qgrid/extension...</span><br><span class="line">        - Validating: OK</span><br></pre></td></tr></table></figure><p></p><p>配置完成之后可以尝试如下示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import qgrid</span><br><span class="line">randn = np.random.randn</span><br><span class="line">df_types = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'A'</span> : pd.Series([<span class="string">'2013-01-01'</span>, <span class="string">'2013-01-02'</span>, <span class="string">'2013-01-03'</span>, <span class="string">'2013-01-04'</span>,</span><br><span class="line">               <span class="string">'2013-01-05'</span>, <span class="string">'2013-01-06'</span>, <span class="string">'2013-01-07'</span>, <span class="string">'2013-01-08'</span>, <span class="string">'2013-01-09'</span>],index=list(range(9)),dtype=<span class="string">'datetime64[ns]'</span>),</span><br><span class="line">    <span class="string">'B'</span> : pd.Series(randn(9),index=list(range(9)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">    <span class="string">'C'</span> : pd.Categorical([<span class="string">"washington"</span>, <span class="string">"adams"</span>, <span class="string">"washington"</span>, <span class="string">"madison"</span>, <span class="string">"lincoln"</span>,<span class="string">"jefferson"</span>, <span class="string">"hamilton"</span>, <span class="string">"roosevelt"</span>, <span class="string">"kennedy"</span>]),</span><br><span class="line">    <span class="string">'D'</span> : [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"buzz"</span>, <span class="string">"bippity"</span>,<span class="string">"boppity"</span>, <span class="string">"foo"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"zoo"</span>] &#125;)</span><br><span class="line">df_types[<span class="string">'E'</span>] = df_types[<span class="string">'D'</span>] == <span class="string">'foo'</span></span><br><span class="line">qgrid_widget = qgrid.show_grid(df_types, show_toolbar=True)</span><br><span class="line">qgrid_widget</span><br></pre></td></tr></table></figure><p></p><p>如果没有显示可以刷新jupyter。</p><hr><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>默认情况下，jupyter的dataframe不会显示全部的dataframe，使用qgrid之后可以显示全部的数据，并且可以设置显示的数目，防止占据太大的空间，具体的<a href="https://hub.mybinder.org/user/quantopian-qgrid-notebooks-odradvv1/notebooks/index.ipynb" target="_blank" rel="noopener">各种示例集合</a>。</p><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/quantopian/qgrid" target="_blank" rel="noopener">官方github</a></li><li><a href="https://qgrid.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a></li></ul><hr><h2 id="输出矢量图"><a href="#输出矢量图" class="headerlink" title="输出矢量图"></a>输出矢量图</h2><p>默认情况下jupyter会得到png，看着非常不清晰，为了克服这种情况，可以使用如下配置，将输出设置为svg格式的矢量图(放大不会使其模糊)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jupyter中输出矢量图</span></span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = <span class="string">'svg'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为矢量图</span></span><br><span class="line">plt.savefig(<span class="string">'tmp.pdf'</span>, bbox_inches=<span class="string">'tight'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="管理conda环境"><a href="#管理conda环境" class="headerlink" title="管理conda环境"></a>管理conda环境</h2><p>使用的包为nb_conda，官方的介绍：Provides Conda environment and package access extension from within Jupyter.</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul><li>将使用conda创建的环境与Jupyter Notebook相关联，便于在Jupyter Notebook中使用不同的虚拟环境</li><li>可以在线管理(增加、删除、复制)虚拟环境以及安装package</li></ul><hr><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure><hr><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用界面和简要功能：<img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/nb_conda.png" alt="nb_conda.png"></p><hr><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>使用下面的命令卸载nb_conda包：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canda remove nb_conda</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/33105153" target="_blank" rel="noopener">Jupyter Notebook介绍、安装及使用教程</a></li></ul><hr><h2 id="Markdown在文中设置链接并定位"><a href="#Markdown在文中设置链接并定位" class="headerlink" title="Markdown在文中设置链接并定位"></a>Markdown在文中设置链接并定位</h2><p>在使用Markdown编辑文档时，难免会遇到<strong>需要在文中设定链接跳转查看</strong>，定位在文档中的其他位置便于查看，因为Markdown可以完美的兼容html语法，因此这种功能可以通过html语法当中“a标签”的索引用法来实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在跳转部位和和插入链接一样的形式</span></span><br><span class="line"><span class="comment"># 不过链接修改为锚定的形式</span></span><br><span class="line">[添加链接的正文](<span class="comment">#自定义索引词)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在需要跳转到的位置添加a标签</span></span><br><span class="line"><span class="comment"># id和前面的锚定#后面的相同</span></span><br><span class="line">&lt;a id=自定义索引词&gt;跳转提示&lt;/a&gt;</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="加载指定网页源代码或本地python文件"><a href="#加载指定网页源代码或本地python文件" class="headerlink" title="加载指定网页源代码或本地python文件"></a>加载指定网页源代码或本地python文件</h2><h3 id="加载网页源代码"><a href="#加载网页源代码" class="headerlink" title="加载网页源代码"></a>加载网页源代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load URL</span><br></pre></td></tr></table></figure><hr><h3 id="加载本地python文件"><a href="#加载本地python文件" class="headerlink" title="加载本地python文件"></a>加载本地python文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load Python文件的绝对路径</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Python文件的后缀为<code>.py</code></li><li><code>%load</code>后跟的是Python文件的<strong>绝对路径</strong></li><li>输入命令后，<strong>可以按CTRL 回车来执行命令</strong><ul><li><strong>第一次执行</strong>，是将本地的Python文件内容<strong>加载到单元格内</strong>。此时，Jupyter Notebook会自动将<code>%load</code>命令注释掉（即在前边加井号<code>#</code>），以便在执行已加载的文件代码时不重复执行该命令；</li><li><strong>第二次执行</strong>，则是执行已加载文件的代码</li></ul></li></ul><hr><h2 id="直接运行本地python文件"><a href="#直接运行本地python文件" class="headerlink" title="直接运行本地python文件"></a>直接运行本地python文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%run Python文件的绝对路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用shell命令的形式</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">!python3 Python文件的绝对路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">!python Python文件的绝对路径</span><br></pre></td></tr></table></figure><hr><h2 id="注释信息美化"><a href="#注释信息美化" class="headerlink" title="注释信息美化"></a>注释信息美化</h2><h3 id="蓝色提示框：注释"><a href="#蓝色提示框：注释" class="headerlink" title="蓝色提示框：注释"></a>蓝色提示框：注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-block alert-info"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Tip:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> Use blue boxes (alert-info) for tips and notes. </span><br><span class="line">If it’s a note, you don’t have to include the word “Note”.#提示框内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="黄色提示框：警告"><a href="#黄色提示框：警告" class="headerlink" title="黄色提示框：警告"></a>黄色提示框：警告</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-block alert-warning"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Example:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> Yellow Boxes are generally used to include additional examples or mathematical formulas.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="绿色提示框：成功"><a href="#绿色提示框：成功" class="headerlink" title="绿色提示框：成功"></a>绿色提示框：成功</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-block alert-success"</span>&gt;</span></span><br><span class="line">Use green box only when necessary like to display links to related content.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="红色提示框：高危"><a href="#红色提示框：高危" class="headerlink" title="红色提示框：高危"></a>红色提示框：高危</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-block alert-danger"</span>&gt;</span></span><br><span class="line">It is good to avoid red boxes but can be used to alert users to not delete some important part of code etc. </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h3><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/markdown_beautify.png" alt="markdown_beautify.png"></p><hr><h2 id="输出单个cell中的多个结果"><a href="#输出单个cell中的多个结果" class="headerlink" title="输出单个cell中的多个结果"></a>输出单个cell中的多个结果</h2><p>在使用jupyter的过程中经常会遇到一个单元格输出多个内容的情况，但是常规情况下，jupyter只会输出最后一行命令的内容，这里就介绍一下如何在单个单元格中同时输出多条命令的运行结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from IPython.core.interactiveshell import InteractiveShell  </span><br><span class="line"><span class="comment"># 输出所有结果</span></span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure><p></p><p>使用示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[1]: 10+5          </span><br><span class="line">       11+6</span><br><span class="line">       12+7</span><br><span class="line">Out[1]: 15</span><br><span class="line">Out[1]: 17</span><br><span class="line">Out[1]: 19</span><br></pre></td></tr></table></figure><p></p><p>如果想要恢复原始的设置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复到每个cell输出单个结果</span></span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"last_expr"</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h2><h3 id="使用markdown方式"><a href="#使用markdown方式" class="headerlink" title="使用markdown方式"></a>使用markdown方式</h3><p>使用markdown方式在jupyter中插入图片需要注意：<strong>插入的本地图片必须和notebook files在同一个文件夹下，不能插入其他路径的图片，即使是输入本地文件的绝对路径也不可以</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保本地图片和notebook在同一个文件夹下</span></span><br><span class="line"><span class="comment"># 插入方式和普通的插入图片没有区别</span></span><br><span class="line"><span class="comment"># 插入notebook文件夹下的img文件夹下的picture图片</span></span><br><span class="line">![title](img/picture.png)</span><br></pre></td></tr></table></figure><p></p><h3 id="使用jupyter命令的方式"><a href="#使用jupyter命令的方式" class="headerlink" title="使用jupyter命令的方式"></a>使用jupyter命令的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line">Image(filename=<span class="string">'img/picture.png'</span>)</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://stackoverflow.com/questions/32370281/how-to-embed-image-or-picture-in-jupyter-notebook-either-from-a-local-machine-o?rq=1" target="_blank" rel="noopener">How to embed image or picture in jupyter notebook, either from a local machine or from a web resource?</a></p><hr><h2 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.zhihu.com/question/59392251" target="_blank" rel="noopener">如何优雅地使用 Jupyter？</a></li><li><a href="http://clarkchen.github.io/2017/06/05/Jupyter%E5%8F%A6%E7%B1%BB%E5%85%A8%E5%AE%B6%E6%A1%B6/" target="_blank" rel="noopener">Jupyter DashBoards 另类全家桶</a></li><li><a href="https://zhuanlan.zhihu.com/p/33105153" target="_blank" rel="noopener">Jupyter Notebook介绍、安装及使用教程</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pv-命令执行的进度信息</title>
      <link href="/posts/6226.html"/>
      <url>/posts/6226.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中用于<strong>显示命令执行进度信息的命令pv</strong>，这个命令<strong>需要安装</strong>；该<strong>命令主要起到管道的作用，标准输入或文件流入，然后流出到标准输出，在这个过程中统计进度信息</strong>；主要学习了<code>-L</code>、<code>-n</code>、<code>匀速打印字符</code>、<code>结合gzip</code>、<code>结合grep</code>、<code>结合wc</code>等。</p></div><a id="more"></a><h2 id="pv命令简介"><a href="#pv命令简介" class="headerlink" title="pv命令简介"></a>pv命令简介</h2><p><code>pv</code>命令 <code>Pipe Viewer</code> 的简称，由Andrew Wood 开发，其作用是<strong>通过管道显示数据处理进度的信息</strong>，这些信息包括<strong>已经耗费的时间</strong>、<strong>完成的百分比(通过进度条显示)</strong>、<strong>当前的速度</strong>、<strong>全部传输的数据</strong>以及<strong>估计剩余的时间</strong>等。</p><p>为了实现上述功能<strong>需要将该命令插入到两个进程之间的管道中</strong>，并佐以合适的选项，<mark>它的<strong>标准输入</strong>经由它<strong>到达其标准输出</strong>, 同时<strong>进度信息会显示在标准错误上</strong></mark>，<code>pv</code>依次<strong>拷贝FILE中的数据到其标准输出</strong>( <code>-</code> 表示标准输入)，如果FILE未提供仅仅拷贝标准输入。<mark><strong>该命令行的行为与cat类似</strong></mark>。</p><hr><h2 id="pv安装"><a href="#pv安装" class="headerlink" title="pv安装"></a>pv安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在root目录下使用yum安装</span></span><br><span class="line">yum install pv</span><br></pre></td></tr></table></figure><hr><h2 id="pv命令格式"><a href="#pv命令格式" class="headerlink" title="pv命令格式"></a>pv命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方</span></span><br><span class="line">Usage: </span><br><span class="line">  pv [OPTION] [FILE]...</span><br><span class="line">Concatenate FILE(s), or standard input, to standard output,</span><br><span class="line">with monitoring.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line"><span class="comment"># 查看文件，并显示进度</span></span><br><span class="line">pv file</span><br><span class="line">pv [options] file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件进度</span></span><br><span class="line">pv file &gt; output_filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看command进行的进度</span></span><br><span class="line">pv [options] | <span class="built_in">command</span></span><br><span class="line">pv [options] | <span class="built_in">command</span> &gt; output_filename</span><br><span class="line">command1| pv | command2</span><br></pre></td></tr></table></figure><hr><h2 id="pv命令参数"><a href="#pv命令参数" class="headerlink" title="pv命令参数"></a>pv命令参数</h2><h3 id="信息显示开关"><a href="#信息显示开关" class="headerlink" title="信息显示开关"></a>信息显示开关</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-p</code></td><td><code>--progress</code></td><td>显示进度条</td></tr><tr><td><code>-t</code></td><td><code>--timer</code></td><td>打开计时器，这将显示pv的总耗用时间</td></tr><tr><td><code>-e</code></td><td><code>--eta</code></td><td>预测完成需要多长时间</td></tr><tr><td><code>-r</code></td><td><code>--rate</code></td><td>显示当前的数据传输速率</td></tr><tr><td><code>-a</code></td><td><code>--average-rate</code></td><td>显示当前的平均数据传输速率</td></tr><tr><td><code>-b</code></td><td><code>--bytes</code></td><td>显示到目前为止传输的数据总量</td></tr><tr><td><code>-F</code></td><td><code>--format FORMAT</code></td><td>设置输出样式</td></tr><tr><td><code>-n</code></td><td><code>--numeric</code></td><td>每行显示一个数字百分比(不带百分号)，用来替代通常的可视进度条，注意，如果使用-n，则不需要-f</td></tr><tr><td><code>-q</code></td><td><code>--quiet</code></td><td>不显示任何传输信息</td></tr></table><hr><h3 id="输出修饰符"><a href="#输出修饰符" class="headerlink" title="输出修饰符"></a>输出修饰符</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-W</code></td><td><code>--wait</code></td><td>等到第一个字节被转移后，才显示进展信息或计算任何ETAs</td></tr><tr><td><code>-s</code></td><td><code>--size SIZE</code></td><td>假设在计算百分比和ETAs时要传输的数据总量是SIZE字节</td></tr><tr><td><code>-l</code></td><td><code>--line-mode</code></td><td>不是计数字节，而是计数行(换行字符)</td></tr><tr><td><code>-i</code></td><td><code>--interval SEC</code></td><td>隔多久更新一次，默认设置是每秒钟更新一次，注意，这可以是小数，比如0.1</td></tr><tr><td><code>-w</code></td><td><code>--width WIDTH</code></td><td>设置终端宽</td></tr><tr><td><code>-H</code></td><td><code>--height HEIGHT</code></td><td>设置终端行高</td></tr><tr><td><code>-N</code></td><td><code>--name NAME</code></td><td>使用NAME作为输出信息的前缀</td></tr><tr><td><code>-f</code></td><td><code>--force</code></td><td>强制输出</td></tr><tr><td><code>-c</code></td><td><code>--cursor</code></td><td>使用游标定位转义序列而不是仅使用回车符</td></tr></table><hr><h3 id="数据传输修饰符"><a href="#数据传输修饰符" class="headerlink" title="数据传输修饰符"></a>数据传输修饰符</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-L</code></td><td><code>--rate-limit RATE</code></td><td>设置每秒传输最大字节数</td></tr><tr><td><code>-B</code></td><td><code>--buffer-size BYTES</code></td><td>设置传输缓冲区大小</td></tr><tr><td><code>-E</code></td><td><code>--skip-errors</code></td><td>skip read errors in input</td></tr><tr><td><code>-S</code></td><td><code>--stop-at-size</code></td><td>传输指定的大小后停止传输</td></tr><tr><td><code>-R</code></td><td><code>--remote PID</code></td><td>如果PID是已经在运行的pv的一个实例，那么-R PID将使该实例可以接收新的参数设置</td></tr></table><hr><h2 id="pv退出状态"><a href="#pv退出状态" class="headerlink" title="pv退出状态"></a>pv退出状态</h2><table><tr><th width="10%">退出状态</th><th width="90%">说明</th></tr><tr><td><code>0</code></td><td>没有问题</td></tr><tr><td><code>1</code></td><td><code>-R</code>或<code>-P</code>选项存在问题</td></tr><tr><td><code>2</code></td><td>无法访问</td></tr><tr><td><code>4</code></td><td>输入文件与输出文件相同</td></tr><tr><td><code>8</code></td><td>关闭文件或移动到下一个文件时发生内部错误</td></tr><tr><td><code>16</code></td><td>一个或多个输入文件传输数据时出错</td></tr><tr><td><code>32</code></td><td>捕获的信号导致提前退出</td></tr><tr><td><code>64</code></td><td>内存分配失败</td></tr></table><hr><h2 id="pv使用实例"><a href="#pv使用实例" class="headerlink" title="pv使用实例"></a>pv使用实例</h2><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><p>实际上pv命令就是相当于把文件打开，然后输出到标准输出，进入后面的管道：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pv B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart &gt;../rsync/test.txt</span><br><span class="line">  258MiB 0:00:00 [1.13GiB/s] [=======================================================================================================================&gt;] 100%</span><br></pre></td></tr></table></figure><p></p><p><strong>默认情况下</strong>：</p><ul><li><code>-p --progress</code>：带进度条的完成比例</li><li><code>-t --timer</code>：已消耗时间</li><li><code>-e --eta</code>：预估剩余时间</li><li><code>-r --rate</code>：已传输总量</li><li><code>-b --bytes</code>：数据量总量</li><li><code>-W --wait</code>：等到第一个字节被转移后，才显示进展信息或计算任何ETAs</li></ul><hr><h3 id="L-传输限速"><a href="#L-传输限速" class="headerlink" title="-L-传输限速"></a>-L-传输限速</h3><p>上面默认的传输速率是<code>1.13GiB/s</code>，很快，这里将其限制为<code>1m/s</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pv -L 1m B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart &gt;../rsync/test.txt</span><br><span class="line">  20MiB 0:00:20 [1.01MiB/s] [=======&gt;                                                                                                                 ]  7% ETA 0:03:58</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-每行显示一个数字百分比"><a href="#n-每行显示一个数字百分比" class="headerlink" title="-n-每行显示一个数字百分比"></a>-n-每行显示一个数字百分比</h3><p>默认情况下会显示传输进度条，如果不想显示传输进度条可以使用<code>-n</code>参数来输出传输的整数百分比，不带百分号的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pv -n -L 1m B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart &gt;../rsync/test.txt</span><br><span class="line">  0</span><br><span class="line">  0</span><br><span class="line">  1</span><br><span class="line">  1</span><br><span class="line">  1</span><br><span class="line">  2</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="匀速打印字符"><a href="#匀速打印字符" class="headerlink" title="匀速打印字符"></a>匀速打印字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置每秒打印5个字符，而不是一次全部显示</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Tecmint[dot]com is a community of Linux Nerds and Geeks"</span> | pv -qL 5</span><br><span class="line">  Tecmint[dot]com is a community of Linux Nerds and Geeks</span><br></pre></td></tr></table></figure><hr><h3 id="结合gzip"><a href="#结合gzip" class="headerlink" title="结合gzip"></a>结合gzip</h3><p>显示压缩进度：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pv B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart |gzip - &gt;test.log</span><br><span class="line">  127MiB 0:00:06 [21.6MiB/s] [==========================================================&gt;                                                              ] 49% ETA 0:00:06</span><br></pre></td></tr></table></figure><p></p><p><strong>使用管道的好处在于</strong>：<strong>不用指定参数来保留原始文件</strong>，因为处理的是标准输入而不是原始文件</p><hr><h3 id="结合grep"><a href="#结合grep" class="headerlink" title="结合grep"></a>结合grep</h3><p>查找内容时，对于较大的文件，可能会比较慢，并且没有任何输出也不知道进行了多少，加上pv命令可以显示查找进度：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">samtools view LJ_mt_677_1_paired.bam |pv |grep <span class="string">"ST-E00243:634:HYCT5CCXY:3:2117:20202:10996"</span></span><br><span class="line">  ST-E00243:634:HYCT5CCXY:3:2117:20202:10996..........YS:i:-16YT:Z:CP</span><br><span class="line">  ST-E00243:634:HYCT5CCXY:3:2117:20202:10996..........YS:i:0YT:Z:CP</span><br><span class="line">  3.5GiB 0:00:44 [79.7MiB/s] [                                                                                                                        &lt;=&gt;              ]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="结合wc"><a href="#结合wc" class="headerlink" title="结合wc"></a>结合wc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示统计行数的进度</span></span><br><span class="line">samtools view LJ_mt_677_1_paired.bam |pv |wc -l</span><br><span class="line">  3.5GiB 0:00:44 [79.9MiB/s] [                                                                                                                        &lt;=&gt;              ]</span><br><span class="line">  8981682</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.rootopen.com/command/bash/pv" target="_blank" rel="noopener">pv 通过管道监控数据的进度</a></li><li><a href="https://linux.cn/article-6734-1.html" target="_blank" rel="noopener">如何使用 pv 命令监控 linux 命令的执行进度</a></li><li><a href="https://juejin.im/entry/5862a9491b69e675fcd8b68d" target="_blank" rel="noopener">Linux 命令 PV 显示当前在命令行执行的进度信息，管道查看器</a></li><li><a href="https://www.jianshu.com/p/64becdd8927c" target="_blank" rel="noopener">利用pv命令监视数据的处理进度</a></li><li><a href="http://blog.topspeedsnail.com/archives/2748" target="_blank" rel="noopener">Linux：使用pv命令显示执行进度</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取时间日期格式和延时</title>
      <link href="/posts/52406.html"/>
      <url>/posts/52406.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中用于<strong>获取时间日期格式和延时的两个命令date和sleep</strong>；主要学习了<strong>date</strong>命令中的<code>-d</code>、<code>-u</code>、<code>-s</code>、<code>自定义显示日期和时间</code>、<code>-n</code>，<strong>sleep</strong>命令中的<code>常规用法</code>、<code>不同时间尺度的混用</code>、<code>浮点型时间设置</code>以及<code>usleep进行微秒级休眠</code>。</p></div><a id="more"></a><h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><h3 id="date命令简介"><a href="#date命令简介" class="headerlink" title="date命令简介"></a>date命令简介</h3><p><code>date</code>用于<strong>获取和设置操作系统的时间和日期</strong>，同时也能<strong>自定义日期和时间的显示格式</strong>。</p><hr><h3 id="date命令格式"><a href="#date命令格式" class="headerlink" title="date命令格式"></a>date命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义格式</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line"><span class="comment"># 使用已有的格式</span></span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">Display the current time <span class="keyword">in</span> the given FORMAT, or <span class="built_in">set</span> the system date.</span><br></pre></td></tr></table></figure><hr><h3 id="date命令参数"><a href="#date命令参数" class="headerlink" title="date命令参数"></a>date命令参数</h3><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-d</code></td><td><code>--date=STRING</code></td><td>显示字符串所指的日期与时间，字符串前后必须加上双引号<br></td></tr><tr><td><code>-f</code></td><td><code>--file=DATEFILE</code></td><td>和-d类似，一次读取DATEFILE的一行</td></tr><tr><td><code>-s</code></td><td><code>--set=STRING</code></td><td>根据字符串来设置日期与时间，字符串前后必须加上双引号</td></tr><tr><td><code>-u</code></td><td><code>--utc、--universal</code></td><td>显示或设置世界标准时间</td></tr><tr><td><code>-r</code></td><td><code>--reference=FILE</code></td><td>显示文件的最后修改时间</td></tr><tr><td><code>-R</code></td><td><code>--rfc-2822</code></td><td>输出RFC 2822格式日期或时间，格式为：星期, 日-月-年, 小时:分钟:秒 时区</td></tr><tr><td><code>-I[TIMESPEC]</code></td><td><code>--iso-8601[=TIMESPEC]</code></td><td>显示ISO 8601格式的日期或时间</td></tr></table><hr><h3 id="date自定义格式字段"><a href="#date自定义格式字段" class="headerlink" title="date自定义格式字段"></a>date自定义格式字段</h3><div align="center"><table><tbody><tr><th width="10%"><p>&nbsp;</p></th><th width="10%"><p align="center">符号</p></th><th width="20%"><p align="center">意义</p></th><th width="60%"><p align="center">描述</p></th></tr><tr><td rowspan="2"><p align="center">年</p></td><td><p>%y</p></td><td><p>年(后两位)</p></td><td><p>last two digits of year (00..99)</p></td></tr><tr><td><p><strong><span style="color:red">%Y</span></strong></p></td><td><p><strong><span style="color:red">年</span></strong></p></td><td><p>year</p></td></tr><tr><td rowspan="3"><p align="center">月</p></td><td><p><span style="color:red">%m</span></p></td><td><p><span style="color:red">月</span></p></td><td><p>month (01..12)</p></td></tr><tr><td><p><strong><span style="color:red">%h、%b</span></strong></p></td><td><p><strong><span style="color:red">月的简称</span></strong></p></td><td><p>month (Jan..Dec)</p></td></tr><tr><td><p><strong><span style="color:red">%B</span></strong></p></td><td><p><strong><span style="color:red">月的全称</span></strong></p></td><td><p>month (January..December)</p></td></tr><tr><td rowspan="6"><p align="center">&nbsp;</p><p align="center">日</p></td><td><p>%j</p></td><td><p>年中天</p></td><td><p>day of year (001..366)</p></td></tr><tr><td><p><strong><span style="color:red">%d</span></strong></p></td><td><p><strong><span style="color:red">月中天</span></strong></p></td><td><p>day of month (如01)</p></td></tr><tr><td><p>%w</p></td><td><p>周中天</p></td><td><p>day of week (0..6); 0 is Sunday</p></td></tr><tr><td><p>%u</p></td><td><p>周中天</p></td><td><p>day of week (1..7); 1 is Monday</p></td></tr><tr><td><p>%a</p></td><td><p>周中天,星期的简称</p></td><td><p>day of week (Sun..Sat)</p></td></tr><tr><td><p>%A</p></td><td><p>周中天,星期的全称</p></td><td><p>day of week (Sunday..Saturday)</p></td></tr><tr><td rowspan="2"><p align="center">周</p></td><td><p>%U</p></td><td><p>年中周(00-53)</p></td><td><p>week number of year with Sunday as first day</p></td></tr><tr><td><p>%W</p></td><td><p>年中周(00-53)</p></td><td><p>week number of year with Monday as first day</p></td></tr><tr><td rowspan="4"><p align="center">时</p></td><td><p><strong><span style="color:red">%H</span></strong></p></td><td><p><strong><span style="color:red">时(24时制)</span></strong></p></td><td><p>hour (00..23)</p></td></tr><tr><td><p>%I</p></td><td><p>时(12时制)</p></td><td><p>hour (01..12)</p></td></tr><tr><td><p>%k</p></td><td><p>时(24时制)</p></td><td><p>hour (0..23)</p></td></tr><tr><td><p>%l</p></td><td><p>时(12时制)</p></td><td><p>hour (1..12)</p></td></tr><tr><td><p align="center">分</p></td><td><p><strong><span style="color:red">%M</span></strong></p></td><td><p><strong><span style="color:red">分</span></strong></p></td><td><p>minute (00..59)</p></td></tr><tr><td rowspan="3"><p align="center">秒</p></td><td><p><strong><span style="color:red">%S</span></strong></p></td><td><p><strong><span style="color:red">秒</span></strong></p></td><td><p>second (00..60)</p></td></tr><tr><td><p><strong><span style="color:red">%N</span></strong></p></td><td><p><strong><span style="color:red">纳秒</span></strong></p></td><td><p>ns of current minute</p></td></tr><tr><td><p><strong><span style="color:red">%s</span></strong></p></td><td><p><strong><span style="color:red">秒</span></strong></p></td><td><p>从1970-01-01到目前时间的秒数总数</p></td></tr><tr><td><p align="center">上午</p><p align="center">下午</p></td><td><p><strong><span style="color:red">%p</span></strong></p></td><td><p><strong><span style="color:red">显示出AM或PM</span></strong></p></td><td><p>显示出AM或PM</p></td></tr><tr><td rowspan="4"><p align="center">完整</p><p align="center">格式</p></td><td><p><strong><span style="color:red">%T</span></strong></p></td><td><p><strong><span style="color:red">完整时间</span></strong></p></td><td><p>time; same as %H:%M:%S</p></td></tr><tr><td><p>%r</p></td><td><p>完整时间，12小时制</p></td><td><p>time; same as hh:mm:ss %p</p></td></tr><tr><td><p><strong><span style="color:red">%x、%D</span></strong></p></td><td><p><strong><span style="color:red">日期完整格式</span></strong></p></td><td><p>date; same as %m/%d/%y</p></td></tr><tr><td><p><strong><span style="color:red">%F</span></strong></p></td><td><p><strong><span style="color:red">日期完整格式</span></strong></p></td><td><p>date; same as %Y-%m-%d</p></td></tr><tr><td><p align="center">日期和时间</p></td><td><p><strong><span style="color:red">%c</span></strong></p></td><td><p><strong><span style="color:red">显示日期和时间</span></strong></p></td><td><p>Tue Nov 20 14:12:58 2012</p></td></tr><tr><td><p align="center">时区</p></td><td><p><strong><span style="color:red">%Z</span></strong></p></td><td><p><strong><span style="color:red">显示时区，日期域</span></strong></p></td><td><p>CST、EST</p></td></tr><tr><td rowspan="2"><p align="center">特殊</p><p align="center">格式</p></td><td><p>%n</p></td><td><p>换行</p></td><td><p>a newline</p></td></tr><tr><td><p>%t</p></td><td><p>tab键</p></td><td><p>a tab</p></td></tr></tbody></table></div><hr><h3 id="date使用实例"><a href="#date使用实例" class="headerlink" title="date使用实例"></a>date使用实例</h3><h4 id="u-显示世界标准时间"><a href="#u-显示世界标准时间" class="headerlink" title="-u-显示世界标准时间"></a>-u-显示世界标准时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -u</span><br><span class="line">  Fri May  3 23:15:35 UTC 2019</span><br></pre></td></tr></table></figure><hr><h4 id="d-显示指定的日期和时间"><a href="#d-显示指定的日期和时间" class="headerlink" title="-d-显示指定的日期和时间"></a>-d-显示指定的日期和时间</h4><p><code>-d</code>参数可以用来描述获取什么时候的时间，描述的方式非常开放，<strong>但不能使用”now”关键字</strong>，其他的如<strong>3天前”3 days ago”</strong>，<strong>3天后”3 days”</strong>，<strong>昨天”yesterday”</strong>，<strong>下周一”next Monday”</strong>等等：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示一天之前的此刻时间</span></span><br><span class="line">date -d <span class="string">"1 day ago"</span></span><br><span class="line">  Thu May  2 18:45:08 EDT 2019</span><br><span class="line"><span class="comment"># 显示一天之后的此刻时间</span></span><br><span class="line">date -d <span class="string">"1 day"</span></span><br><span class="line">  Sat May  4 18:47:44 EDT 2019</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2秒之后的时间</span></span><br><span class="line">date &amp;&amp; date -d <span class="string">"2 seconds"</span></span><br><span class="line">  Fri May  3 18:46:43 EDT 2019</span><br><span class="line">  Fri May  3 18:46:45 EDT 2019</span><br><span class="line"><span class="comment"># 2秒之前的时间</span></span><br><span class="line">date &amp;&amp; date -d <span class="string">"2 seconds ago"</span></span><br><span class="line">  Fri May  3 18:47:16 EDT 2019</span><br><span class="line">  Fri May  3 18:47:14 EDT 2019</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定时间之前的时间</span></span><br><span class="line">date -d <span class="string">"2018-02-19 3 days ago"</span></span><br><span class="line">  Fri Feb 16 00:00:00 EST 2018</span><br><span class="line">date -d <span class="string">"2018-02-19 - 3 days"</span></span><br><span class="line">  Fri Feb 16 00:00:00 EST 2018</span><br><span class="line"><span class="comment"># 指定时间之后的时间</span></span><br><span class="line">date -d <span class="string">"2018-02-19  3 days"</span></span><br><span class="line">  Thu Feb 22 00:00:00 EST 2018</span><br><span class="line">date -d <span class="string">"2018-02-19 + 3 days"</span></span><br><span class="line">  Thu Feb 22 00:00:00 EST 2018</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="s-设置时间和日期"><a href="#s-设置时间和日期" class="headerlink" title="-s-设置时间和日期"></a>-s-设置时间和日期</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置当前时间，只有root权限才能设置，其他只能查看</span></span><br><span class="line">date -s          </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置成20120523，这样会把具体时间设置成空00:00:00</span></span><br><span class="line">date -s 20120523   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置具体时间，不会对日期做更改</span></span><br><span class="line">date -s 01:01:01           </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样可以设置全部时间</span></span><br><span class="line">date -s <span class="string">"01:01:01 2012-05-23"</span>  </span><br><span class="line">date -s <span class="string">"01:01:01 20120523"</span>    </span><br><span class="line">date -s <span class="string">"2012-05-23 01:01:01"</span>  </span><br><span class="line">date -s <span class="string">"20120523 01:01:01"</span></span><br></pre></td></tr></table></figure><hr><h4 id="自定义输出格式"><a href="#自定义输出格式" class="headerlink" title="自定义输出格式"></a>自定义输出格式</h4><p><code>date [OPTION] [+format]</code>，其中<code>+</code>表示<strong>从前面的时间中获取其中的格式部分</strong>，如<code>date -d &quot;yesterday&quot; +&quot;%Y&quot;</code>获取的是昨天的年份部分：</p><h5 id="结合-d"><a href="#结合-d" class="headerlink" title="结合-d"></a>结合-d</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %F:%Y-%m-%d</span></span><br><span class="line">date -d <span class="string">"3 days ago"</span> +%F</span><br><span class="line">  2019-04-30</span><br><span class="line"></span><br><span class="line"><span class="comment"># %c：日期和时间</span></span><br><span class="line"><span class="comment"># 其中的时间是%r</span></span><br><span class="line">date -d <span class="string">"3 days ago"</span> +%c</span><br><span class="line">  Tue 30 Apr 2019 07:02:03 PM EDT</span><br><span class="line"></span><br><span class="line"><span class="comment"># %r：显示时间，12小时制（hh:mm:ss %p）</span></span><br><span class="line">date -d <span class="string">"3 days ago"</span> +%r</span><br><span class="line">  07:03:07 PM</span><br></pre></td></tr></table></figure><hr><h5 id="n-换行显示"><a href="#n-换行显示" class="headerlink" title="-n-换行显示"></a>-n-换行显示</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示完时间之后，日期换行显示</span></span><br><span class="line">date -d <span class="string">"2018-02-19  3 days"</span> +<span class="string">"%T%n%D"</span></span><br><span class="line">  00:00:00</span><br><span class="line">  02/22/18</span><br></pre></td></tr></table></figure><hr><h5 id="直接定义"><a href="#直接定义" class="headerlink" title="直接定义"></a>直接定义</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">"%F %T"</span></span><br><span class="line">  2019-05-03 19:11:15</span><br><span class="line"></span><br><span class="line">date +<span class="string">"%Y-%m-%d %H:%M:%S"</span></span><br><span class="line">  2019-05-03 19:10:58</span><br></pre></td></tr></table></figure><hr><h5 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h5><p>给定一个日期，计算该日期所在星期的星期一是几月几号，例如，2018-05-12是星期六，那么星期一是2018-05-07:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">src_date=<span class="string">"2018-05-12"</span></span><br><span class="line"><span class="comment"># 先判断给定的日期是星期几</span></span><br><span class="line">src_weekday=`date -d <span class="variable">$src_date</span> +%w`</span><br><span class="line"><span class="comment"># src_weekday=6</span></span><br><span class="line">Mon_date=`date -d <span class="string">"<span class="variable">$src_date</span> - <span class="variable">$(( src_weekday - 1 )</span>) days"</span> +%F`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$Mon_date</span></span><br><span class="line"><span class="comment"># 2018-05-07</span></span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="sleep命令"><a href="#sleep命令" class="headerlink" title="sleep命令"></a>sleep命令</h2><h3 id="sleep命令简介"><a href="#sleep命令简介" class="headerlink" title="sleep命令简介"></a>sleep命令简介</h3><p><code>sleep</code>命令可以用来<strong>将目前动作延迟一段时间</strong>，默认情况下，<code>sleep</code> 的进程是<strong>不占用 CPU 时间的</strong>.</p><hr><h3 id="sleep命令格式"><a href="#sleep命令格式" class="headerlink" title="sleep命令格式"></a>sleep命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: sleep NUMBER[SUFFIX]...</span><br><span class="line">  or:  sleep OPTION</span><br></pre></td></tr></table></figure><p><strong>suffix</strong>:</p><ul><li><code>s</code>：表示秒</li><li><code>m</code>：表示分钟</li><li><code>h</code>：表示小时</li><li><code>d</code>：表示天</li></ul><div class="note info"><ul><li><strong>最大支持的休眠单位为天</strong>，如果需要更大的单位如月，需要用天转化</li><li><strong>NUMBER可以是浮点型的数值</strong>，例如0.003s、0.1m表示的是6s</li></ul></div><h3 id="sleep使用实例"><a href="#sleep使用实例" class="headerlink" title="sleep使用实例"></a>sleep使用实例</h3><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠1s</span></span><br><span class="line">date ; sleep 1s ;date</span><br><span class="line">  Fri May  3 20:35:43 EDT 2019</span><br><span class="line">  Fri May  3 20:35:44 EDT 2019</span><br><span class="line"></span><br><span class="line"><span class="comment"># 休眠1分钟</span></span><br><span class="line">date ; sleep 1m ;date</span><br><span class="line">  Fri May  3 20:36:19 EDT 2019</span><br><span class="line">  Fri May  3 20:37:19 EDT 2019</span><br></pre></td></tr></table></figure><hr><h4 id="时间混用"><a href="#时间混用" class="headerlink" title="时间混用"></a>时间混用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠1分钟30s</span></span><br><span class="line">date ; sleep 1m 30s;date</span><br><span class="line">  Fri May  3 20:37:46 EDT 2019</span><br><span class="line">  Fri May  3 20:39:16 EDT 2019</span><br></pre></td></tr></table></figure><div class="note info"><p>不同的时间尺度连用时需要注意<strong>时间尺度之间一定要有空格隔开</strong></p></div><hr><h4 id="浮点型的时间"><a href="#浮点型的时间" class="headerlink" title="浮点型的时间"></a>浮点型的时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠半分钟</span></span><br><span class="line"><span class="comment"># 和30s的效果是相同的</span></span><br><span class="line">date ; sleep 0.5m;date</span><br><span class="line">  Fri May  3 20:41:24 EDT 2019</span><br><span class="line">  Fri May  3 20:41:54 EDT 2019</span><br></pre></td></tr></table></figure><hr><h4 id="usleep-微秒级的休眠命令"><a href="#usleep-微秒级的休眠命令" class="headerlink" title="usleep-微秒级的休眠命令"></a>usleep-微秒级的休眠命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠1000微秒，即1毫秒</span></span><br><span class="line">usleep 1000</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/date" target="_blank" rel="noopener">date命令</a></li><li><a href="https://www.cnblogs.com/peida/archive/2012/12/13/2815687.html" target="_blank" rel="noopener">每天一个linux命令（37）：date命令</a></li><li><a href="https://linux.cn/article-2406-1.html" target="_blank" rel="noopener">Linux date命令 - 显示和设置系统日期与时间</a></li><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7427262.html" target="_blank" rel="noopener">date、sleep和usleep命令</a></li><li><a href="http://c.biancheng.net/linux/sleep.html" target="_blank" rel="noopener">sleep命令_Linux sleep命令：让程序暂停或休眠一段时间</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>du-显示目录或文件大小</title>
      <link href="/posts/30062.html"/>
      <url>/posts/30062.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中用于<strong>统计目录或文件大小的命令du</strong>，主要学习了：<code>-h</code>、<code>-S</code>、<code>-s</code>、<code>-c</code>、<code>-a</code>、<code>--exclude</code>、<code>--max-depth</code>、<code>结合sort命令</code>、<code>-t</code>、<code>关于单位名称</code>、<code>与ls输出结果的差别原因</code>。</p></div><a id="more"></a><h2 id="du命令简介"><a href="#du命令简介" class="headerlink" title="du命令简介"></a>du命令简介</h2><p><code>du</code> 命令，全称是 disk usage，用来展示文件或者文件夹磁盘使用量的统计信息.</p><hr><h1 id="du命令格式"><a href="#du命令格式" class="headerlink" title="du命令格式"></a>du命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: du [OPTION]... [FILE]...</span><br><span class="line">  or:  du [OPTION]... --files0-from=F</span><br><span class="line">Summarize disk usage of each FILE, recursively <span class="keyword">for</span> directories.</span><br></pre></td></tr></table></figure><hr><h2 id="du命令参数"><a href="#du命令参数" class="headerlink" title="du命令参数"></a>du命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-a</code></td><td><code>-all</code></td><td>显示目录中单个文件的大小，而不是笼统的显示目录大小<br></td></tr><tr><td><code>-b</code></td><td><code>--bytes</code></td><td>显示目录或文件大小时，以byte为单位</td></tr><tr><td><code>-c</code></td><td><code>--total</code></td><td>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</td></tr><tr><td><code>-s</code></td><td><code>--summarize</code></td><td>仅显示总计，只列出最后加总的值</td></tr><tr><td><code>-k</code></td><td></td><td>以KB(1024bytes)为单位输出</td></tr><tr><td><code>-m</code></td><td></td><td>以MB为单位输出</td></tr><tr><td><code>-h</code></td><td><code>--human-readable</code></td><td>以K、M、G为单位，提高信息的可读性</td></tr><tr><td></td><td><code>--si</code></td><td>与<code>-h</code>参数相同，但是K、M、G是以1000为换算单位</td></tr><tr><td><code>-P</code></td><td><code>--no-dereference</code></td><td>不显示所有符号链接的源文件大小，这么默认情况</td></tr><tr><td><code>-L</code></td><td><code>--dereference</code></td><td>显示所有符号链接的源文件大小</td></tr><tr><td><code>-D</code></td><td><code>--dereference-args</code></td><td>显示指定符号链接的源文件大小</td></tr><tr><td><code>-S</code></td><td><code>--separate-dirs</code></td><td>显示个别目录的大小时，并不含其子目录的大小</td></tr><tr><td></td><td><code>--exclude=PATTERN</code></td><td>排除指定的目录或文件</td></tr><tr><td><code>-X</code></td><td><code>--exclude-from=FILE</code></td><td>从文件中读取排除的规则</td></tr><tr><td><code>-d</code></td><td>-<code>-max-depth=N</code></td><td>统计指定深度的目录大小，当<code>--max-depth=0</code>时，效果同<code>-s</code>相同</td></tr><tr><td><code>-t</code></td><td>-<code>--threshold=SIZE</code></td><td>只输出大小大于某个特定值的文件</td></tr></table><hr><h2 id="du命令使用实例"><a href="#du命令使用实例" class="headerlink" title="du命令使用实例"></a>du命令使用实例</h2><h3 id="目录信息"><a href="#目录信息" class="headerlink" title="目录信息"></a>目录信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -alh</span><br><span class="line">  total 259M</span><br><span class="line">  drwxrwxr-x. 3 user user 4.0K May  3 13:24 .</span><br><span class="line">  drwxrwxr-x. 4 user user 4.0K May  3 00:27 ..</span><br><span class="line">  -rw-rw-r--. 1 user user 259M May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  drwxrwxr-x. 3 user user   24 May  3 13:25 backup</span><br><span class="line">  -rw-rw-r--. 1 user user  14K May  3 00:16 test1.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  11K May  3 00:17 test2.txt</span><br><span class="line">  -rw-rw-r--. 1 user user   69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="默认用法"><a href="#默认用法" class="headerlink" title="默认用法"></a>默认用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计当前文件夹的大小</span></span><br><span class="line">du .</span><br><span class="line"><span class="comment"># 默认是以K为单位</span></span><br><span class="line">  264768./backup/backup_test</span><br><span class="line">  264768./backup</span><br><span class="line">  529572.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计指定文件大小</span></span><br><span class="line">du test1.txt </span><br><span class="line">  16test1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计多个文件大小</span></span><br><span class="line">du test1.txt test2.txt </span><br><span class="line">  16test1.txt</span><br><span class="line">  12test2.txt</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>默认会显示文件夹以及子文件夹大小</strong>，<strong>不会具体显示文件夹中文件的大小</strong></p></div><hr><h3 id="h-人性化显示大小"><a href="#h-人性化显示大小" class="headerlink" title="-h-人性化显示大小"></a>-h-人性化显示大小</h3><p>和<code>ls</code>命令一样，<code>du</code>命令也可以使用<code>-h</code>参数来以人类可读的形式展示磁盘使用量的单位名称(<code>K、M、G</code>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以人类可读的形式显示大小</span></span><br><span class="line">du -h .</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="S-统计目录但不包括子目录的大小"><a href="#S-统计目录但不包括子目录的大小" class="headerlink" title="-S-统计目录但不包括子目录的大小"></a>-S-统计目录但不包括子目录的大小</h3><p>默认情况下，du统计的目录大小会包括子目录的大小，这就会造成一种重复统计大小的情况，如果想只显示当前目录中除子目录以外文件的大小的大小，可以使用-S参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以与上面默认的情况对比</span></span><br><span class="line"><span class="comment"># backup目录只能自由子目录backup_test，所以除去子目录大小后，其大小为0</span></span><br><span class="line">du -Sh .</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  0./backup</span><br><span class="line">  259M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-只显示总和大小"><a href="#s-只显示总和大小" class="headerlink" title="-s-只显示总和大小"></a>-s-只显示总和大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与默认显示每个文件夹以及子文件夹的大小不同</span></span><br><span class="line"><span class="comment"># 只显示了总的大小</span></span><br><span class="line">du -sh .</span><br><span class="line">  518M.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示给定的文件大小</span></span><br><span class="line"><span class="comment"># 这个和默认的情况没啥区别</span></span><br><span class="line">du -sh B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart  test2.txt </span><br><span class="line">  259MB2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  12Ktest2.txt</span><br></pre></td></tr></table></figure><hr><h3 id="c-所有目录以及总大小"><a href="#c-所有目录以及总大小" class="headerlink" title="-c-所有目录以及总大小"></a>-c-所有目录以及总大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前目录所有目录以及总大小</span></span><br><span class="line">du -ch .</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br><span class="line">  518Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示给定的文件总和大小</span></span><br><span class="line">du -ch B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart  test2.txt </span><br><span class="line">  259MB2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  12Ktest2.txt</span><br><span class="line">  259Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示给定文件和目录的总和大小</span></span><br><span class="line">du -ch backup/ test1.txt </span><br><span class="line">  259Mbackup/backup_test</span><br><span class="line">  259Mbackup/</span><br><span class="line">  16Ktest1.txt</span><br><span class="line">  259Mtotal</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-c</code>参数相当于是一个加和的操作，先得到给定的文件或者目录的大小，然后将这些大小加和起来得到total</p></div><hr><h3 id="a-显示所有文件和目录大小"><a href="#a-显示所有文件和目录大小" class="headerlink" title="-a-显示所有文件和目录大小"></a>-a-显示所有文件和目录大小</h3><p><strong>默认情况下</strong>，du后面如果跟着文件夹，<strong>统计的只有文件夹或者子文件夹的大小</strong>，如果想要<strong>查看所有文件和文件夹的大小</strong>，可以使用<code>-a</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有文件和目录大小</span></span><br><span class="line">du -ah .</span><br><span class="line">  4.0K./test.txt</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–exclude-排除统计文件或目录"><a href="#–exclude-排除统计文件或目录" class="headerlink" title="–exclude-排除统计文件或目录"></a>–exclude-排除统计文件或目录</h3><p>如果使用了-a参数，那么指定目录下所有的文件和子目录大小都会显示，即使是隐藏文件或文件夹(以<code>.</code>开头)，如果不想显示这些文件，可以使用–exclude进行规则的限制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有的文件和目录大小</span></span><br><span class="line">du -ah .</span><br><span class="line">  6.8M    ./wordpress-4.4.1.tar.gz</span><br><span class="line">  3.4M    ./curl-7.34.0.tar.gz</span><br><span class="line">  980K    ./soft/redis-2.6.16.tar.gz</span><br><span class="line">  40M     ./soft/go1.1.2.Linux-amd64.tar.gz</span><br><span class="line">  120K    ./soft/.abc</span><br><span class="line">  0       ./.bbc/ddd</span><br><span class="line">  0       ./.bbc/.ccc</span><br><span class="line">  51M     .</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用--exclude结合通配符</span></span><br><span class="line"><span class="comment"># 将以.开头的文件或目录大小排除在外 </span></span><br><span class="line">du -ah --exclude=<span class="string">"*/.*"</span> .</span><br><span class="line">  6.8M    ./wordpress-4.4.1.tar.gz</span><br><span class="line">  3.4M    ./curl-7.34.0.tar.gz</span><br><span class="line">  980K    ./soft/redis-2.6.16.tar.gz</span><br><span class="line">  40M     ./soft/go1.1.2.Linux-amd64.tar.gz</span><br><span class="line">  41M     ./soft</span><br><span class="line">  51M     .</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–max-depth-限制统计深度"><a href="#–max-depth-限制统计深度" class="headerlink" title="–max-depth-限制统计深度"></a>–max-depth-限制统计深度</h3><p>文件夹是可以嵌套的，有的时候，我们只想展示第一级或第二级子文件夹的信息，而不希望 <code>du</code> 统计的层次太深，那么我们可以用 <code>--max-depth</code> 选项来进行控制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结合-c参数，--max-depth=0</span></span><br><span class="line"><span class="comment"># 相当于使用了-s参数</span></span><br><span class="line">du --max-depth=0 -ch .</span><br><span class="line">  518M.</span><br><span class="line">  518Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合-c参数，--max-depth=1</span></span><br><span class="line"><span class="comment"># 只会显示当前和子目录，不会显示子目录的子目录</span></span><br><span class="line">du --max-depth=1 -ch .</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br><span class="line">  518Mtotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合-a参数，--max-depth=1</span></span><br><span class="line"><span class="comment"># 显示了当前目录下所有的文件大小以及子目录大小</span></span><br><span class="line">du --max-depth=1 -ah .</span><br><span class="line">  4.0K./test.txt</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="结合sort命令"><a href="#结合sort命令" class="headerlink" title="结合sort命令"></a>结合sort命令</h3><p>按照文件或文件夹大小进行降序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">du -ah .  |sort -hr</span><br><span class="line">  518M.</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  4.0K./test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于<code>sort</code> <code>-n</code>和<code>-h</code>参数的区别：</p><ul><li><code>-n</code>选项，按<strong>数值进行比较</strong>，只会<strong>傻傻地比较数字</strong>，它会<strong>认为 98 K大于 2G</strong></li><li><code>-h</code>选项，会更加聪明，先<strong>优先比较单位（G&gt;M&gt;K）</strong>，然后<strong>再对数值进行比较</strong></li></ul></div><hr><h3 id="t-只输出大小大于某个特定值的文件"><a href="#t-只输出大小大于某个特定值的文件" class="headerlink" title="-t-只输出大小大于某个特定值的文件"></a>-t-只输出大小大于某个特定值的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只输出大于100m的文件</span></span><br><span class="line">du -ah . -t 100m</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  518M.</span><br></pre></td></tr></table></figure><hr><h3 id="关于单位名称"><a href="#关于单位名称" class="headerlink" title="关于单位名称"></a>关于单位名称</h3><p>默认的单位是K，当然也可以通过指定<code>-b</code>、<code>-k</code>、<code>-m</code>来分别设置以<code>bytes</code>、<code>KB</code>、<code>MB</code>为单位，其实这些<code>-k</code>、<code>-m</code>对单位的设置都是通过<code>--block-size</code>来控制的：</p><ul><li><code>--block-size=1(-b)</code>，则表示使用<code>bytes</code>为单位</li><li><code>--block-size=1K(-k)</code>，则表示使用<code>KB</code>为单位</li><li><code>--block-size=1M(-m)</code>，则表示使用<code>MB</code>为单位</li></ul><hr><h3 id="du和ls结果的差异"><a href="#du和ls结果的差异" class="headerlink" title="du和ls结果的差异"></a>du和ls结果的差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有一个文件, 里面只输入了a、b两个英文字母</span></span><br><span class="line">cat &lt;&lt; EOF &gt;test3.txt</span><br><span class="line">  &gt; ab</span><br><span class="line">  &gt; EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#用下面的方法, 我们可以把文件中的控制字符也展示出来, 发现除了a、b外还包括了一个结尾符</span></span><br><span class="line">cat -E test3.txt </span><br><span class="line">  ab$</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用ls来查看大小, 发现展示的是3字节</span></span><br><span class="line">ls -alh test3.txt </span><br><span class="line">  -rw-rw-r--. 1 user user 3 May  3 17:06 test3.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用du来查看大小, 竟然展示的是4KB字节</span></span><br><span class="line">du -h test3.txt </span><br><span class="line">  4.0Ktest3.txt</span><br></pre></td></tr></table></figure><p><code>du</code> 命令的作者也太粗心了吧，竟然连字母个数都数不清么？冤枉啊！其实，<code>du</code> 和 <code>ls</code> 在展示文件大小时，是<strong>存在着本质区别</strong>的：</p><ul><li><code>du</code> 展示的是<strong>磁盘空间占用量</strong></li><li><code>ls</code> 展示的是<strong>文件内容的大小</strong></li></ul><p>可能这两句话还不足以让你理解两者的区别，我们举一个形象的例子。中秋节时，中国人走亲访友时都会购买月饼礼盒，月饼的体积可以认为是文件内容大小，而加上包装礼盒的总体积可以认为是磁盘空间使用量。</p><p>那么，在 Linux 的世界里，每个文件也要有包装么？要想解答这个问题，我们就要<strong>简单介绍下 Linux 文件系统的原理了</strong>：文件系统进驻磁盘之初，就会<strong>将磁盘按照固定数据块（block）大小进行分隔切块，通常情况下每一个固定数据块大小会被设定为 4096bytes，也就是 4KB</strong>，与此同时，大部分文件系统规定：</p><ul><li>一个数据块中最多存放一个文件的内容，<strong>当没存满时，剩余的空间不得被其他文件使用</strong></li><li>当一个文件的内容较大时，则<strong>可以存储到多个数据块中</strong></li></ul><p><mark>文件 test3.txt 中<strong>只有三个字符，两个可见字符（ab）和一个控制字符（$）</strong>，因此，这个<strong>文件的内容大小就是 3bytes</strong>，但是<strong>由于 Linux 文件系统的限制，它需要占用一个数据块来存储这个文件，因此这个文件实际占用的磁盘空间就是 4KB 了</strong>。</mark></p><hr><p><br></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="ncdu-交互式"><a href="#ncdu-交互式" class="headerlink" title="ncdu-交互式"></a>ncdu-交互式</h3><p><a href="https://www.ostechnix.com/check-disk-space-usage-linux-using-ncdu/" target="_blank" rel="noopener">参考链接</a></p><hr><h3 id="tin-summer-速度快"><a href="#tin-summer-速度快" class="headerlink" title="tin-summer-速度快"></a>tin-summer-速度快</h3><p><a href="https://github.com/vmchale/tin-summer" target="_blank" rel="noopener">tin-summer</a> 的开发者认为它可以替代 <code>du</code>，因为它具有以下优势：</p><ul><li>在显示结果上默认采用易读格式；</li><li>在大目录的操作速度上比 <code>du</code> 更快；</li><li>可以使用正则表达式排除文件或目录；</li><li>可以对输出进行排序和着色处理；</li><li>可扩展，等等。</li></ul><p>感觉这个可以一试，<a href="https://linux.cn/article-10239-1.html" target="_blank" rel="noopener">参考链接</a></p><hr><h3 id="dust-树状显示"><a href="#dust-树状显示" class="headerlink" title="dust-树状显示"></a>dust-树状显示</h3><p><a href="https://github.com/bootandy/dust" target="_blank" rel="noopener">dust</a>是树状显示文件大小，但是<strong>速度有点慢</strong>。</p><blockquote><p>Dust is currently about 4 times slower than du.</p></blockquote><hr><h3 id="diskus-速度奇快"><a href="#diskus-速度奇快" class="headerlink" title="diskus-速度奇快"></a>diskus-速度奇快</h3><p>它的效果相当于 <code>du -sh</code> 或 <code>du -sh --bytes</code>，但其开发者表示 <code>diskus</code> 的运行速度是 <code>du -sh</code> 的 <code>9</code> 倍。</p><blockquote><p>A minimal, fast alternative to ‘du -sh’</p></blockquote><p><strong>使用范围有点窄。。。</strong></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/du.html" target="_blank" rel="noopener">du命令_Linux du命令：查看文件夹和文件的磁盘占用情况</a></li><li><a href="http://sunyongfeng.com/201412/shell/du.html" target="_blank" rel="noopener">Linux命令行查看目录及子目录大小 - du</a></li><li><a href="https://linux.cn/article-10239-1.html" target="_blank" rel="noopener">几个用于替代 du 命令的更好选择</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pgrep-使用进程名直接查找pid等信息</title>
      <link href="/posts/22799.html"/>
      <url>/posts/22799.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>直接通过进程名查找pid以及进程名和完整命令行的命令pgrep</strong>，其是<a href="http://showteeth.tech/posts/33990.html">ps</a>结合<code>awk</code>、<code>grep</code>命令查找信息的一个<strong>简写命令</strong>；主要学习了<code>-l</code>、<code>-a</code>、<code>-f</code>、<code>-x</code>等。</p></div><a id="more"></a><h2 id="pgrep命令简介"><a href="#pgrep命令简介" class="headerlink" title="pgrep命令简介"></a>pgrep命令简介</h2><p><code>pgrep</code>命令<strong>以名称为依据</strong>从运行进程队列中查找进程，并<strong>显示查找到的进程id</strong>。每一个进程ID以一个十进制数表示，通过一个分割字符串和下一个ID分开，默认的分割字符串是一个新行。</p><p>前面学习了<a href="http://showteeth.tech/posts/33990.html">查看静态进程信息的命令ps</a>，在实际使用中经常会遇到需要查看某个任务的pid信息，这个时候如果使用ps命令就需要结合awk和grep等命令，显得比较繁琐，如查看jupyterhub相关名称的pid需要使用<code>ps -auxf |grep &quot;jupyterhub&quot; |grep -v &quot;grep&quot; |awk &#39;{print $2}&#39;</code>，这么长的命令写着不是很方便，那么有没有可以简化的方法呢？pgrep就是为了解决这一问题而生的，pgrep相当于<code>ps -eo pid,cmd | awk &#39;{print $1,$2}&#39; | grep KeyWord</code>，可以直接得到命令的pid。</p><div class="note info"><p>pgrep是根据进程名来查找得到pid，并且其对匹配的字符数目也有限制，<strong>默认只能匹配进程的前15个字符</strong>:</p><blockquote><p>ps aux includes the full command line (path and parameters), while pgrep only looks at the first 15 characters of the executable’s names</p></blockquote><p>这个可以结合<strong>后面的参数<code>-f</code>进行全字符的匹配</strong></p></div><p>与<code>pgrep</code>相对应的还有一个<code>pkill</code>命令，<strong>和<code>pgrep</code>用法完全相同</strong>，不过个人感觉还是使用<code>pgrep</code>查找到<strong>想要的pid</strong>之后结合<code>xargs</code>和<code>kill</code>进行操作比较好。</p><hr><h2 id="pgrep命令格式"><a href="#pgrep命令格式" class="headerlink" title="pgrep命令格式"></a>pgrep命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> pgrep [options] &lt;pattern&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="pgrep命令参数"><a href="#pgrep命令参数" class="headerlink" title="pgrep命令参数"></a>pgrep命令参数</h2><table><thead><tr><th width="10%">选项</th><th width="90%">说明</th></tr></thead><tbody><tr><td>-<code>-d</code></td><td>定义输出的多个进程之间的分隔符（默认使用换行符）</td></tr><tr><td><code>-l</code></td><td>列出pid 和 进程名</td></tr><tr><td><code>-a</code></td><td>列出pid 和 完整的命令</td></tr><tr><td><code>-v</code></td><td>否定匹配，即列出除了查找的进程以外的其他进程</td></tr><tr><td><code>-w</code></td><td>列出所有的TID</td></tr><tr><td><code>-c</code></td><td>统计匹配到的所有进程数量</td></tr><tr><td><code>-f</code></td><td>用进程全名去匹配，包括参数</td></tr><tr><td><code>-g</code></td><td>匹配列出的进程组ID</td></tr><tr><td><code>-G</code></td><td>其后跟着一组group id，该命令在搜索时，仅考虑group列表中的进程。</td></tr><tr><td><code>-n</code></td><td>表示如果该程序有多个进程正在运行，则仅查找最新的，即最后启动的。</td></tr><tr><td><code>-o</code></td><td>表示如果该程序有多个进程正在运行，则仅查找最老的，即最先启动的（多个进程时即父进程PID）。</td></tr><tr><td><code>-P</code></td><td>根据父进程PID，找出所有子进程的pid</td></tr><tr><td><code>-s</code></td><td>匹配会话ID</td></tr><tr><td><code>-t</code></td><td>通过控制终端匹配</td></tr><tr><td><code>-u</code></td><td>其后跟着一组有效用户ID(effetive user id)，该命令在搜索时，仅考虑该effective user列表中的进程。</td></tr><tr><td><code>-U</code></td><td>其后跟着一组实际用户ID(real user id)，该命令在搜索时，仅考虑该real user列表中的进程。</td></tr><tr><td><code>-x</code></td><td>表示进程的名字必须完全匹配, 以上的选项均可以部分匹配。</td></tr><tr><td><code>-F</code></td><td>从文件中读取PID</td></tr><tr><td><code>-L</code></td><td>如果PID文件未锁定，则失败</td></tr></tbody></table><hr><h2 id="pgrep使用实例"><a href="#pgrep使用实例" class="headerlink" title="pgrep使用实例"></a>pgrep使用实例</h2><h3 id="ps查看命令信息"><a href="#ps查看命令信息" class="headerlink" title="ps查看命令信息"></a>ps查看命令信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -auxf |grep <span class="string">"jupyterhub"</span> |grep -v <span class="string">"grep"</span></span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user2"</span></span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   1:06 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:23  \_ /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user"</span></span><br></pre></td></tr></table></figure><p>可以发现输出结果中<strong>第三个为子进程</strong>。</p><hr><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下只会显示pid</span></span><br><span class="line">pgrep  jupyterhub</span><br><span class="line">  17668</span><br><span class="line">  30495</span><br></pre></td></tr></table></figure><p><mark>这里只会显示父进程的信息，<strong>不会显示子进程的pid</strong></mark></p><hr><h3 id="l-列出pid和进程名"><a href="#l-列出pid和进程名" class="headerlink" title="-l-列出pid和进程名"></a>-l-列出pid和进程名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出pid和进程名</span></span><br><span class="line"><span class="comment"># 但没有列出命令信息，不是很完善</span></span><br><span class="line">pgrep  -l jupyterhub</span><br><span class="line">  17668 jupyterhub-sing</span><br><span class="line">  30495 jupyterhub</span><br></pre></td></tr></table></figure><p><mark>这里只会显示父进程的信息，<strong>不会显示子进程的pid</strong></mark></p><hr><h3 id="a-列出pid和完整命令"><a href="#a-列出pid和完整命令" class="headerlink" title="-a-列出pid和完整命令"></a>-a-列出pid和完整命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示了pid和完整的命令，信息较全</span></span><br><span class="line">pgrep  -a jupyterhub</span><br><span class="line">  17668 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user2"</span></span><br><span class="line">  30495 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><p><mark>这里只会显示父进程的信息，<strong>不会显示子进程的pid</strong></mark></p><hr><h3 id="f-匹配整个命令行"><a href="#f-匹配整个命令行" class="headerlink" title="-f-匹配整个命令行"></a>-f-匹配整个命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现是使用-f参数可以得到三个pid</span></span><br><span class="line"><span class="comment"># 也就是包括了子进程的信息</span></span><br><span class="line">pgrep -f <span class="string">"jupyterhub"</span></span><br><span class="line">  17668</span><br><span class="line">  30495</span><br><span class="line">  30529</span><br></pre></td></tr></table></figure><p>结合<code>-a</code>使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pgrep -af <span class="string">"jupyterhub"</span></span><br><span class="line">  17668 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user2"</span></span><br><span class="line">  30495 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br><span class="line">  30529 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 --notebook-dir=<span class="string">"/"</span> --NotebookApp.default_url=<span class="string">"/tree/home/user"</span></span><br></pre></td></tr></table></figure><p></p><p><mark>使用-f参数既可以显示父进程pid，<strong>也会显示子进程的pid</strong></mark></p><hr><h3 id="x-精确匹配进程名"><a href="#x-精确匹配进程名" class="headerlink" title="-x-精确匹配进程名"></a>-x-精确匹配进程名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不包括子进程的进程名称</span></span><br><span class="line"><span class="comment"># 是模糊匹配</span></span><br><span class="line">pgrep -l <span class="string">"jupyterhub"</span></span><br><span class="line">  17668 jupyterhub-sing</span><br><span class="line">  30495 jupyterhub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确匹配进程名</span></span><br><span class="line"><span class="comment"># 排除了jupyterhub-sing的结果</span></span><br><span class="line">pgrep -ax <span class="string">"jupyterhub"</span></span><br><span class="line">  30495 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://xiaqunfeng.cc/2017/02/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94pgrep%E5%92%8Cpkill/" target="_blank" rel="noopener">Linux命令——pgrep和pkill</a></li><li><a href="http://www.361way.com/pgrep/3650.html" target="_blank" rel="noopener">pgrep无法匹配问题</a></li><li><a href="http://man.linuxde.net/pgrep" target="_blank" rel="noopener">pgrep命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ps-报告当前系统的进程状态</title>
      <link href="/posts/33990.html"/>
      <url>/posts/33990.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>查看静态进程信息的命令ps</strong>，主要学习了<code>-A</code>、<code>-u</code>、<code>-N</code>、<code>显示所有进程信息(-ef)</code>、<code>信息更多地显示所有进程信息(-aux)</code>、<code>依据进程信息进行排序</code>、<code>-C</code>、<code>-o</code>、<code>实时监控进程状态</code>等；如果希望直接得到<strong>进程的pid、命令行以及进程名等信息</strong>，可以直接使用<a href="http://showteeth.tech/posts/22799.html">pgrep命令</a>。</p></div><a id="more"></a><h2 id="ps命令简介"><a href="#ps命令简介" class="headerlink" title="ps命令简介"></a>ps命令简介</h2><p>Linux中的<code>ps</code>命令是<code>Process Status</code>的缩写，用来<strong>列出系统中当前运行的那些进</strong>程。<code>ps</code>命令列出的是<strong>当前那些进程的快照</strong>，就是<strong>执行ps命令的那个时刻的那些进程</strong>，是静态的，如果想要<strong>动态的显示进程信息，就可以使用top命令</strong>。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 <code>ps</code> 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p>linux上进程有5种状态以及在<code>ps</code>中对应的状态码：<br><table><tr><th width="30%">状态</th><th width="40%">说明</th><th width="30%">ps中的状态码</th></tr><tr><td>运行 runnable (on run queue)</td><td>正在运行或在运行队列中等待</td><td>R</td></tr><tr><td>中断 sleeping</td><td>休眠中, 受阻, 在等待某个条件的形成或接受到信号</td><td>S</td></tr><tr><td>不可中断 uninterruptible sleep (usually IO)</td><td>收到信号不唤醒和不可运行, 进程必须等待直到有中断发生</td><td>D</td></tr><tr><td>僵死 a defunct (”zombie”) process</td><td>进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放</td><td>Z</td></tr><tr><td>停止 traced or stopped</td><td>进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行</td><td>T</td></tr></table></p><hr><h2 id="ps命令参数"><a href="#ps命令参数" class="headerlink" title="ps命令参数"></a>ps命令参数</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>a</code></td><td>显示所有进程(with tty)，包括其他其他用户的进程<br></td></tr><tr><td><code>-a</code></td><td>显示所有进程(with tty)，但不包括会话的领导进程(session leaders)</td></tr><tr><td><code>-A, -e</code></td><td>显示所有进程</td></tr><tr><td><code>c</code></td><td>显示进程的真实名称</td></tr><tr><td><code>-N</code></td><td>反向选择，相当于！</td></tr><tr><td><code>e</code></td><td>命令之后显示环境，user、name、path等</td></tr><tr><td><code>-f</code></td><td>信息全部列出，通常和其他选项联用</td></tr><tr><td><code>-H</code></td><td>显示树状结构</td></tr><tr><td><code>r</code></td><td>显示当前终端正在运行的进程</td></tr><tr><td><code>T</code></td><td>显示当前终端的所有进程</td></tr><tr><td><code>-u</code></td><td>指定用户的所有进程</td></tr><tr><td><code>-k、--sort</code></td><td>对进程信息进行排序，+表示升序，-表示降序</td></tr><tr><td><code>-C</code></td><td>根据command名称进行过滤</td></tr></table><hr><h2 id="ps输出结果说明"><a href="#ps输出结果说明" class="headerlink" title="ps输出结果说明"></a>ps输出结果说明</h2><ul><li><code>UID、USER</code>：该命令是由哪个用户产生的。</li><li><code>PID</code>：进程的ID号。</li><li><code>%CPU</code>：该进程占用CPU资源的百分比。</li><li><code>%MEM</code>：该进城占用物理内存的百分比。</li><li><code>VSZ</code>：该进程占用虚拟内存的大小，单位KB。</li><li><code>RSS</code>：该进程占用实际物理内存的大小，单位KB。</li><li><code>TTY</code>：该进程在哪个终端中运行。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地字符界面终端，tty7是图形终端。pst/0-255代表虚拟终端。</li><li><code>STAT</code>：由两个字符组成的状态码，用于表示当前进程的状态：<ul><li>第一个字符：<ul><li><code>R</code>：运行</li><li><code>S</code>：睡眠</li><li><code>T</code>：停止状态</li><li><code>Z</code>：僵死</li></ul></li><li>第二个字符：<ul><li><code>s</code>：包含<strong>子进程</strong></li><li><code>+</code>：位于<strong>前台</strong></li><li><code>&lt;</code>：进程正以<strong>高优先级</strong>运行</li><li><code>N</code>：进程正以<strong>低优先级</strong>运行</li><li><code>L</code>：进程在内存中存在锁定页面</li><li><code>s</code>：进程是<strong>会话领导者（session leader）</strong></li><li><code>l</code>：进程是<strong>多线程</strong>的</li></ul></li></ul></li><li><code>START</code>：该进程的启动时间</li><li><code>TIME</code>：该进程占用CPU的运算时间，注意不是系统时间</li><li><code>COMMAND</code>：产生此进程的命令</li></ul><hr><h2 id="ps使用实例"><a href="#ps使用实例" class="headerlink" title="ps使用实例"></a>ps使用实例</h2><h3 id="A-显示所有进程信息"><a href="#A-显示所有进程信息" class="headerlink" title="-A-显示所有进程信息"></a>-A-显示所有进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -A</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:10:40 systemd</span><br><span class="line">    2 ?        00:00:01 kthreadd</span><br><span class="line">    3 ?        00:00:01 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 kworker/0:0H</span><br><span class="line">    7 ?        00:00:03 migration/0</span><br></pre></td></tr></table></figure><hr><h3 id="u-显示指定用户信息"><a href="#u-显示指定用户信息" class="headerlink" title="-u-显示指定用户信息"></a>-u-显示指定用户信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示root的进程信息</span></span><br><span class="line">ps -u root u</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  root         1  0.0  0.0  52096  4584 ?        Ss    2018  10:41 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line">  root         8  0.0  0.0      0     0 ?        S     2018   0:00 [rcu_bh]</span><br><span class="line">  root         9  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/0]</span><br><span class="line">  root        10  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/1]</span><br></pre></td></tr></table></figure><p>说明：最后的<code>u</code>参数用来<strong>决定以针对用户的格式输出</strong>，由<code>User</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>VSZ</code>, <code>RSS</code>, <code>TTY</code>, <code>STAT</code>, <code>START</code>, <code>TIME</code> 和 <code>COMMAND</code>这几列组成.</p><hr><h3 id="N-反向选择"><a href="#N-反向选择" class="headerlink" title="-N-反向选择"></a>-N-反向选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非root用户的进程信息</span></span><br><span class="line">ps -u root u -N</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  dbus       784  0.0  0.0  35048  1036 ?        Ssl   2018   0:50 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">  polkitd    915  0.0  0.0 632008  2000 ?        Ssl   2018   0:13 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">  user+  3453  0.0  0.0 145612  2300 ?        S    May02   0:00 sshd: user@pts/1</span><br><span class="line">  user+  3454  0.0  0.0 115508  2272 pts/1    Ss   May02   0:01 -bash</span><br><span class="line">  user+ 15238  0.0  0.0 145612  2172 ?        S    00:31   0:00 sshd: user@pts/2</span><br><span class="line">  user+ 15239  0.0  0.0 115508  2228 pts/2    Ss+  00:31   0:00 -bash</span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 </span><br><span class="line">  user+ 17931  0.0  0.0 155268  1860 pts/1    R+   01:07   0:00 ps -u root u -N</span><br><span class="line">  rstudio+ 21690  0.0  0.0 212740  5480 ?        Ssl  Apr10   4:41 /usr/lib/rstudio-server/bin/rserver</span><br></pre></td></tr></table></figure><hr><h3 id="显示所有进程信息"><a href="#显示所有进程信息" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h3><p>显示完整的命令信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">  UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">  root         1     0  0  2018 ?        00:10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2     0  0  2018 ?        00:00:01 [kthreadd]</span><br><span class="line">  root         3     2  0  2018 ?        00:00:01 [ksoftirqd/0]</span><br><span class="line">  root         5     2  0  2018 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">  root         7     2  0  2018 ?        00:00:03 [migration/0]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="显示所有进程信息，信息更多"><a href="#显示所有进程信息，信息更多" class="headerlink" title="显示所有进程信息，信息更多"></a>显示所有进程信息，信息更多</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  root         1  0.0  0.0  52096  4624 ?        Ss    2018  10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line">  root         8  0.0  0.0      0     0 ?        S     2018   0:00 [rcu_bh]</span><br><span class="line">  root         9  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/0]</span><br><span class="line">  root        10  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/1]</span><br><span class="line">  root        11  0.0  0.0      0     0 ?        S     2018   0:00 [rcuob/2]</span><br></pre></td></tr></table></figure><div class="note info"><p>与<code>ps -ef</code>相比，<code>ps -aux</code>信息更多，包括了<code>%CPU</code>、<code>%MEM</code>等信息，两者的<code>cmd</code>和<code>command</code>是相同的</p></div><hr><h3 id="依据进程信息进行排序"><a href="#依据进程信息进行排序" class="headerlink" title="依据进程信息进行排序"></a>依据进程信息进行排序</h3><p>参数说明：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">k,    --sort        specify sort order as: [+|-]key[,[+|-]key[,...]]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>多个key之间使用<strong>逗号分隔</strong></li><li><code>+</code>表示<strong>升序</strong>，<code>-</code>表示<strong>降序</strong></li><li>支持的sort key可以查看<a href="http://linuxcommand.org/lc3_man_pages/ps1.html" target="_blank" rel="noopener">这个链接中的STANDARD FORMAT SPECIFIERS</a></li></ul></div><hr><h4 id="依据进程的CPU使用排序"><a href="#依据进程的CPU使用排序" class="headerlink" title="依据进程的CPU使用排序"></a>依据进程的CPU使用排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降序排列，+pcpu</span></span><br><span class="line">ps -aux --sort +pcpu</span><br><span class="line">  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 15072  118  2.5 1890184 1247420 pts/2 R+   00:28   0:02 sh test.sh</span><br><span class="line">  root         1  0.0  0.0  52096  4624 ?        Ss    2018  10:40 /usr/lib/systemd/systemd --system --deserialize 23</span><br><span class="line">  root         2  0.0  0.0      0     0 ?        S     2018   0:01 [kthreadd]</span><br><span class="line">  root         3  0.0  0.0      0     0 ?        S     2018   0:01 [ksoftirqd/0]</span><br><span class="line">  root         5  0.0  0.0      0     0 ?        S&lt;    2018   0:00 [kworker/0:0H]</span><br><span class="line">  root         7  0.0  0.0      0     0 ?        S     2018   0:03 [migration/0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升序排列，+pcpu</span></span><br><span class="line">ps -aux --sort +pcpu</span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 </span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 15072  100 22.5 11214456 11102608 pts/2 R+ 00:28   0:46 sh test.sh</span><br></pre></td></tr></table></figure><hr><h4 id="依据进程的内存使用排序"><a href="#依据进程的内存使用排序" class="headerlink" title="依据进程的内存使用排序"></a>依据进程的内存使用排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据内存使用进行降序排列</span></span><br><span class="line">ps -aux --sort -pmem </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783 </span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460 </span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  root     15933  0.0  0.0 341804 13380 ?        Ssl   2018   0:01 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br></pre></td></tr></table></figure><hr><h3 id="C-通过command名称过滤"><a href="#C-通过command名称过滤" class="headerlink" title="-C-通过command名称过滤"></a>-C-通过command名称过滤</h3><p>使用 -C 参数，后面跟你要找的进程的名字:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -fC jupyterhub</span><br><span class="line">  root     30495     1  0 Apr30 ?        00:00:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>参数是带有顺序的</strong>，不能使用<code>-Cf</code>，使用<code>-fC</code>是正确的</p></div><hr><h3 id="o-指定输出字段"><a href="#o-指定输出字段" class="headerlink" title="-o-指定输出字段"></a>-o-指定输出字段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出字段</span></span><br><span class="line">ps -o pid,ppid,pgrp,session,tpgid,comm</span><br><span class="line">    PID  PPID  PGRP  SESS TPGID COMMAND</span><br><span class="line">  3454  3453  3454  3454 13946 bash</span><br><span class="line">  13946  3454 13946  3454 13946 ps</span><br></pre></td></tr></table></figure><p>支持的输出字段可以查看<a href="http://linuxcommand.org/lc3_man_pages/ps1.html" target="_blank" rel="noopener">这个链接中的STANDARD FORMAT SPECIFIERS</a></p><hr><h3 id="实时监控进程状态"><a href="#实时监控进程状态" class="headerlink" title="实时监控进程状态"></a>实时监控进程状态</h3><p>ps 命令会显示你系统当前的进程状态，但是这个结果是静态的，如果我们需要像上面提到的通过CPU和内存的使用率来筛选进程，并且我们希望结果能够每秒刷新一次，我们可以将<code>ps</code>命令和<code>watch</code>命令结合起来：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每10秒更新一次</span></span><br><span class="line">watch -n 10 <span class="string">'ps -aux --sort -pmem | head -n 20'</span></span><br><span class="line">  Every 10.0s: ps -aux --sort -pmem | head -n 20                                                                                                 Fri May  3 00:53:36 2019</span><br><span class="line"></span><br><span class="line">  USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783</span><br><span class="line">  user2+ 17668  0.0  0.1 292476 55356 ?        Ssl  Apr29   0:00 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=54460</span><br><span class="line">  root     30495  0.0  0.1 272996 49736 ?        Sl   Apr30   0:54 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub -f /etc/jupyterhub/jupyt</span><br><span class="line">  root     30508  0.0  0.0 566792 35008 ?        Ssl  Apr30   0:03 node /usr/bin/configurable-http-proxy --ip 192.168.1.231 --port 8000 --api-ip 127.0.0.1 --api-port 800</span><br><span class="line">  root     15933  0.0  0.0 341804 12992 ?        Ssl   2018   0:01 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line">  rstudio+ 21690  0.0  0.0 212740  5480 ?        Ssl  Apr10   4:41 /usr/lib/rstudio-server/bin/rserver</span><br><span class="line">  root  3448  0.0  0.0 145612  5156 ?        Ss   May02   0:00 sshd: user [priv]</span><br></pre></td></tr></table></figure><p></p><p><mark>这里的动态查看<strong>并不像<code>top</code>或者<code>htop</code>命令</strong>一样，使用<code>ps</code>的好处是你能够<strong>自定义显示你想查看的字段</strong></mark>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定用户的信息，并按照内存使用进行降序排序</span></span><br><span class="line">watch -n 10 <span class="string">'ps -u user u --sort -pmem | head -n 20'</span></span><br><span class="line">  Every 10.0s: ps -u user u --sort -pmem | head -n 20                                                                                     Fri May  3 00:56:12 2019</span><br><span class="line"></span><br><span class="line">  USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">  user+ 30575  0.0  0.1 1015552 96128 ?       Ssl  Apr30   0:06 /home/softwares/anaconda3/bin/python -m ipykernel_launcher -f /home/user/.<span class="built_in">local</span>/share/jupyter/ru</span><br><span class="line">  user+ 30529  0.0  0.1 476772 86504 ?        Ssl  Apr30   0:20 /home/softwares/anaconda3/bin/python /home/softwares/anaconda3/bin/jupyterhub-singleuser --port=60783</span><br><span class="line">  user+ 17081  0.0  0.0 157560  2528 pts/1    S+   00:55   0:00 watch -n 10 ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+  3453  0.0  0.0 145612  2300 ?        S    May02   0:00 sshd: user@pts/1</span><br><span class="line">  user+  3454  0.0  0.0 115508  2272 pts/1    Ss   May02   0:01 -bash</span><br><span class="line">  user+ 15239  0.0  0.0 115508  2228 pts/2    Ss+  00:31   0:00 -bash</span><br><span class="line">  user+ 15238  0.0  0.0 145612  2172 ?        S    00:31   0:00 sshd: user@pts/2</span><br><span class="line">  user+ 17120  0.0  0.0 155264  1832 pts/1    R+   00:56   0:00 ps -U user -u --sort -pmem</span><br><span class="line">  user+ 17119  0.0  0.0 113124  1364 pts/1    S+   00:56   0:00 sh -c ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+ 17118  0.0  0.0 157556   936 pts/1    S+   00:56   0:00 watch -n 10 ps -U user -u --sort -pmem | head -n 20</span><br><span class="line">  user+ 17121  0.0  0.0 107904   672 pts/1    S+   00:56   0:00 head -n 20</span><br></pre></td></tr></table></figure><p></p><p>说明：最后的<code>u</code>参数用来<strong>决定以针对用户的格式输出</strong>，由<code>User</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>VSZ</code>, <code>RSS</code>, <code>TTY</code>, <code>STAT</code>, <code>START</code>, <code>TIME</code> 和 <code>COMMAND</code>这几列组成.</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="noopener">每天一个linux命令（41）：ps命令</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" target="_blank" rel="noopener">4. ps 进程查看器</a></li><li><a href="https://www.jianshu.com/p/784d594a78aa" target="_blank" rel="noopener">Linux命令-5 ps</a></li><li><a href="https://linux.cn/article-4743-1.html" target="_blank" rel="noopener">10个重要的Linux ps命令实战</a></li><li><a href="https://segmentfault.com/a/1190000014730535#articleHeader1" target="_blank" rel="noopener">Linux 进程管理（1）- 查看进程：ps,pstree,top,htop,bg,fg,jobs</a></li><li><a href="http://os.51cto.com/art/201101/244090.htm" target="_blank" rel="noopener">如何在Linux中查看所有正在运行的进程</a></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/es-unix-sysadmin1.html" target="_blank" rel="noopener">进程管理技巧</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsnyc-远程数据同步</title>
      <link href="/posts/8376.html"/>
      <url>/posts/8376.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中进行<strong>远程数据同步的命令rsync</strong>，相比于功能相近的<a href="http://showteeth.tech/posts/2539.html">scp命令</a>，其可以实现<strong>增量同步</strong>；主要学习了<code>本地目录之间的同步</code>、<code>本地与远程之间的同步</code>、<code>-t</code>、<code>-a</code>、<code>-r</code>、<code>-R</code>、<code>-l</code>、<code>-L</code>、<code>--backup</code>、<code>--backup-dir</code>、<code>--existing</code>、<code>--ignore-existing</code>、<code>--remove-source-files</code>、<code>--exclude</code>、<code>--delete</code>、<code>--max-size</code>等参数。</p></div><a id="more"></a><h2 id="rsync命令简介"><a href="#rsync命令简介" class="headerlink" title="rsync命令简介"></a>rsync命令简介</h2><p><code>rsync</code>是可以<strong>实现增量备份</strong>的工具。配合任务计划，<code>rsync</code>能实现<strong>定时或间隔同步</strong>，配合<code>inotify</code>或<code>sersync</code>，可以实现<strong>触发式的实时同步</strong>。</p><p><code>rsync</code>可以实现<a href="http://showteeth.tech/posts/2539.html">scp</a>的远程拷贝(<strong><code>rsync</code>不支持远程到远程的拷贝，但<code>scp</code>支持</strong>)、<code>cp</code>的本地拷贝、<code>rm</code>删除和<code>&quot;ls -l&quot;</code>显示文件列表等功能。但需要注意的是，<code>rsync</code>的最终目的或者说其<strong>原始目的是实现两端主机的文件同步</strong>，因此实现的<code>scp/cp/rm</code>等功能仅仅只是同步的辅助手段，且<code>rsync</code>实现这些功能的方式和这些命令是不一样的。本篇文章将简单介绍rsync的使用方法和它常用的功能。</p><hr><h2 id="rsync同步说明"><a href="#rsync同步说明" class="headerlink" title="rsync同步说明"></a>rsync同步说明</h2><p><code>rsync</code>的目的是<strong>实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步(scp可以实现)</strong>。</p><p>不考虑rsync的实现细节，就文件同步而言，涉及了<strong>源文件和目标文件</strong>的概念，还涉及了<strong>以哪边文件为同步基准</strong>。例如，想让目标主机上的文件和本地文件保持同步，则是以本地文件为同步基准，将本地文件作为源文件推送到目标主机上。反之，如果想让本地主机上的文件和目标主机上的文件保持同步，则目标主机上的文件为同步基准，实现方式是将目标主机上的文件作为源文件拉取到本地。当然，要保持本地的两个文件相互同步，rsync也一样能实现，这就像Linux中cp命令一样，以本地某文件作为源，另一文件作为目标文件，但请注意，虽然rsync和cp能达到相同的目的，但它们的实现方式是不一样的。实际上，如果<strong>简单理解的话，可以将其当成复制命令来理解</strong>：</p><ul><li><strong>本地和远程同步</strong>，就是将<strong>远程的文件复制到本地</strong>，覆盖本地原有文件的内容</li><li><strong>远程和本地同步</strong>，就是将<strong>本地的文件复制到远程</strong>，覆盖远程原有文件的内容</li></ul><p>既然是文件同步，在同步过程中必然会涉及到源和目标两文件之间<strong>版本控制</strong>的问题，例如是否要删除源主机上没有但目标上多出来的文件，目标文件比源文件更新(newer than source)时是否仍要保持同步，遇到软链接时是拷贝软链接本身还是拷贝软链接所指向的文件，目标文件已存在时是否要先对其做个备份等等。</p><p><code>rsync</code>同步过程中由<strong>两部分模式</strong>组成：<strong>决定哪些文件需要同步的检查模式</strong>以及<strong>文件同步时的同步模式</strong>：</p><ul><li><p><strong>检查模式是指按照指定规则来检查哪些文件需要被同步</strong>，例如哪些文件是明确被排除不传输的。<strong>默认情况下</strong>，<code>rsync</code>使用<code>&quot;quick check&quot;</code>算法快速检查源文件和目标文件的<strong>大小</strong>、<strong>mtime(修改时间)是否一致</strong>，如果<strong>不一致则需要传输</strong>。当然，也可以通过在<code>rsync</code>命令行中指定某些选项来<strong>改变quick check的检查模式</strong>，比如<code>&quot;--size-only&quot;</code>选项表示<code>&quot;quick check&quot;</code>将仅检查文件大小不同的文件作为待传输文件。rsync支持非常多的选项，其中检查模式的自定义性是非常有弹性的。</p></li><li><p><strong>同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作</strong>。例如上文所说的是否要先删除源主机上没有但目标主机上有的文件，是否要先备份已存在的目标文件，是否要追踪链接文件等额外操作。rsync也提供非常多的选项使得同步模式变得更具弹性。</p></li><li><p>相对来说，<strong>为<code>rsync</code>手动指定同步模式的选项更常见一些</strong>，只有在有特殊需求时才指定检查模式，因为大多数检查模式选项都可能会影响<code>rsync</code>的性能。</p></li></ul><hr><h2 id="rsync命令格式"><a href="#rsync命令格式" class="headerlink" title="rsync命令格式"></a>rsync命令格式</h2><h3 id="通用命令格式"><a href="#通用命令格式" class="headerlink" title="通用命令格式"></a>通用命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync options <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><hr><h3 id="本地路径之间的同步"><a href="#本地路径之间的同步" class="headerlink" title="本地路径之间的同步"></a>本地路径之间的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地路径之间的同步</span></span><br><span class="line">Local:  rsync [OPTION...] SRC... [DEST]</span><br></pre></td></tr></table></figure><hr><h3 id="本地和远程的同步"><a href="#本地和远程的同步" class="headerlink" title="本地和远程的同步"></a>本地和远程的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地和远程的同步 </span></span><br><span class="line">Access via remote shell:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br></pre></td></tr></table></figure><hr><h3 id="本地和远程的同步-rsync-daemon"><a href="#本地和远程的同步-rsync-daemon" class="headerlink" title="本地和远程的同步(rsync daemon)"></a>本地和远程的同步(rsync daemon)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access via rsync daemon:</span><br><span class="line">  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]</span><br><span class="line">        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]</span><br><span class="line">  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST</span><br><span class="line">        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</span><br></pre></td></tr></table></figure><div class="note info"><ul><li><strong>前两者</strong>的本质是<strong>通过管道通信，即使是远程shell</strong>；而<strong>第三种方式</strong>则是<strong>让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接</strong>。</li><li>命令中的<strong>第一个路径参数</strong>一定是源文件路径，即<strong>作为同步基准的一方</strong>，<strong>可以同时指定多个源文件路径</strong>。<strong>最后一个路径参数则是目标文件路径</strong>，也就是<strong>待同步方</strong>。路径的格式可以是<code>本地路径</code>，也可以是使用<code>user@host:path</code>或<code>user@host::path</code>的远程路径，如果主机和path路径之间使用<strong>单个冒号</strong>隔开，表示使用的是<strong>远程shell通信方式</strong>，而使用<strong>双冒号</strong>隔开的则表示的是连接<code>rsync daemon</code>。另外，连接<code>rsync daemon</code>时，还提供了<strong>URL格式</strong>的路径表述方式<code>rsync://user@host/path</code>。</li><li>如果<strong>仅有一个SRC或DEST参数</strong>，则将以类似于<code>&quot;ls -l&quot;</code>的方式<strong>列出源文件列表(只有一个路径参数，总会认为是源文件)，而不是复制文件</strong>。</li><li>另外，使用<code>rsync</code>一定要注意的一点是，源路径如果是一个目录的话，<strong>带上尾随斜线</strong>和<strong>不带尾随斜线</strong>是<strong>不一样</strong>的，<strong>不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身</strong>。</li></ul></div><hr><h2 id="rsync参数说明"><a href="#rsync参数说明" class="headerlink" title="rsync参数说明"></a>rsync参数说明</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-v</code></td><td><code>--verbose</code></td><td>显示rsync过程中详细信息，可以使用"-vvvv"获取更详细信息</td></tr><tr><td><code>-P</code></td><td></td><td>显示文件传输的进度信息(实际上"-P"="--partial --progress"，其中的"--progress"才是显示进度信息的)</td></tr><tr><td><code>-n</code></td><td><code>--dry-run</code></td><td>仅测试传输，而不实际传输，常和"-vvvv"配合使用来查看rsync是如何工作的</td></tr><tr><td><code>-a</code></td><td><code>--archive</code></td><td>归档模式，表示递归传输并保持文件属性，等同于"-rtopgDl"(不带-H,-A,-X)</td></tr><tr><td><code>-r</code></td><td><code>--recursive</code></td><td>递归</td></tr><tr><td><code>-t</code></td><td><code>--times</code></td><td>保持mtime属性。强烈建议任何时候都加上"-t"，否则目标文件mtime会设置为系统时间，导致下次更新检查出mtime不同从而导致增量传输无效</td></tr><tr><td><code>-o</code></td><td><code>--owner</code></td><td>保持owner属性(属主)</td></tr><tr><td><code>-g</code></td><td><code>--group</code></td><td>保持group属性(属组)</td></tr><tr><td><code>-p</code></td><td><code>--perms</code></td><td>保持perms属性(权限，不包括特殊权限)</td></tr><tr><td><code>-D</code></td><td></td><td>是"--device --specials"选项的组合，即也拷贝设备文件和特殊文件</td></tr><tr><td><code>-l</code></td><td><code>--links</code></td><td>如果文件是软链接文件，则会拷贝软链接，默认情况下会忽略链接的同步</td></tr><tr><td><code>-L</code></td><td><code>--copy-links</code></td><td>如果文件是软链接文件，则会拷贝软链接指向的文件或目录，而不是单纯的保留软链接形式，默认情况下会忽略链接的同步</td></tr><tr><td><code>-z</code></td><td></td><td>传输时进行压缩提高效率</td></tr><tr><td><code>-R</code></td><td><code>--relative</code></td><td>使用相对路径，意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例</td></tr><tr><td></td><td><code>--size-only</code></td><td>默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。</td></tr><tr><td><code>-u</code></td><td><code>--update</code></td><td>仅在源mtime比目标已存在文件的mtime新时才拷贝，注意，该选项是接收端判断的，不会影响删除行为</td></tr><tr><td><code>-d</code></td><td><code>--dirs</code></td><td>以不递归的方式拷贝目录本身，默认递归时，如果源为"dir1/file1"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1</td></tr><tr><td></td><td><code>--max-size</code></td><td>限制rsync传输的最大文件大小，可以使用单位后缀，还可以是一个小数值(例如："--max-size=1.5m")</td></tr><tr><td></td><td><code>--min-size</code></td><td>限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件</td></tr><tr><td></td><td><code>--exclude</code></td><td>指定排除规则来排除不需要传输的文件</td></tr><tr><td></td><td><code>--delete</code></td><td>以SRC为主，对DEST进行同步。多则删之，少则补之。注意"--delete"是在接收端执行的，所以它是在exclude/include规则生效之后才执行的</td></tr><tr><td><code>-b</code></td><td><code>--backup</code></td><td>对目标上已存在的文件做一个备份，备份的文件名后默认使用"~"做后缀</td></tr><tr><td></td><td><code>--backup-dir</code></td><td>指定备份文件的保存路径，不指定时默认和待备份文件保存在同一目录下</td></tr><tr><td><code>-e</code></td><td></td><td>指定所要使用的远程shell程序，默认为ssh，可以用来指定端口号</td></tr><tr><td></td><td><code>--port</code></td><td>连接daemon时使用的端口号，默认为873端口</td></tr><tr><td></td><td><code>--password-file</code></td><td>daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码</td></tr><tr><td><code>-W</code></td><td><code>--whole-file</code></td><td>rsync将不再使用增量传输，而是全量传输，在网络带宽高于磁盘带宽时，该选项比增量传输更高效</td></tr><tr><td></td><td><code>--existing</code></td><td>要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。</td></tr><tr><td></td><td><code>--ignore-existing</code></td><td>要求只更新目标端不存在的文件，和"--existing"结合使用有特殊功能，见下文示例</td></tr><tr><td></td><td><code>--remove-source-files</code></td><td>要求删除源端已经成功传输的文件</td></tr></table><hr><h2 id="rsync使用实例"><a href="#rsync使用实例" class="headerlink" title="rsync使用实例"></a>rsync使用实例</h2><h3 id="本地之间的同步"><a href="#本地之间的同步" class="headerlink" title="本地之间的同步"></a>本地之间的同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将scp目录下的test.txt同步到当前目录中</span></span><br><span class="line"><span class="comment"># 默认是不会显示进度信息的，和scp不同</span></span><br><span class="line">rsync /home/user/learn/linux_learn/scp/test.txt ./</span><br></pre></td></tr></table></figure><div class="note info"><p>注意事项：</p><ul><li>只要目的端文件内容和源端不一样，就会触发数据同步，<code>rsync</code>会确保两边的文件内容一样</li><li>默认情况下，<strong><code>rsync</code>不会同步文件的“modify time”</strong>，凡是有数据同步的文件，<strong>目的端的文件的“modify time”总是会被修改为最新时刻的时间(同步发生的时间)</strong>，而默认情况下rsync会检查<strong>源文件和目标文件的大小</strong>、<strong>mtime(修改时间)是否一致，如果不一致则需要传输</strong>，这样时间发生改变会使得源文件和目的端文件内容总是不同，<strong>导致增量同步无效</strong></li><li><code>rsync</code><strong>不会太关注目的端文件的<code>rwx</code>权限</strong>，如果目的端<strong>没有</strong>此文件，那么权限会保持<strong>与源端一致</strong>；如果目的端<strong>有此文件</strong>，则权限<strong>不会随着源端变更</strong></li></ul></div><hr><h3 id="t-保持mtime属性"><a href="#t-保持mtime属性" class="headerlink" title="-t-保持mtime属性"></a>-t-保持mtime属性</h3><p>为了解决默认情况下rsync会将目的端同步文件的modify time修改为当前时间从而导致增量同步无效的问题，可以使用-t来在同步文件时保留mtime属性：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步，保留mtime属性</span></span><br><span class="line">rsync -r -v -t /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 时间和远程文件的保持一致</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行同步</span></span><br><span class="line"><span class="comment"># 因为时间戳是相同的，且文件内容也是相同的，所以不会进行再次同步</span></span><br><span class="line">rsync -r -v -t  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 129 bytes  received 13 bytes  284.00 bytes/sec</span><br><span class="line">total size is 271119920  speedup is 1909295.21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用-t参数</span></span><br><span class="line">rsync -r -v  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"><span class="comment"># 这里的时间就是当前时间</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 21:50 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 21:50 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次运行同步</span></span><br><span class="line"><span class="comment"># 因为时间戳是不同的，所以还会进行同步</span></span><br><span class="line">rsync -r -v  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"></span><br><span class="line">sent 271153227 bytes  received 51 bytes  180768852.00 bytes/sec</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意事项：</p><ul><li><code>-t</code>参数会保留远程(源端)文件的modify time属性，下次再进行同步时，如果远程文件没有修改，就不会再次同步，真正的增量同步</li><li>不加<code>-t</code>参数会使得当前文件的modify time为同步操作发生的时间，从而使得远程文件和当前文件的modify time一直不同，重复运行会一直同步，即使远程文件没有修改，这使得增量同步无效</li><li><strong>为了防止文件时间戳和大小一致，但是内容不一致的情况</strong>，可以使用<code>-I</code>参数：<strong>don’t skip files that match in size and mod-time</strong>，但是这<strong>会影响rsync的性能</strong></li></ul></div><hr><h3 id="a-归档模式"><a href="#a-归档模式" class="headerlink" title="-a-归档模式"></a>-a-归档模式</h3><p>rsync的<code>-a</code>选项是archive的意思，加了之后有以下作用：</p><ul><li>递归模式</li><li>同步软链接</li><li>同步权限</li><li>同步时间戳</li><li>同步属主和属组</li></ul><hr><h3 id="本地和远程同步"><a href="#本地和远程同步" class="headerlink" title="本地和远程同步"></a>本地和远程同步</h3><p>和<code>scp</code>命令一样，<code>rsync</code>也是<strong>默认使用的是22端口连接远程服务器</strong>，如果想要<strong>指定服务器端口</strong>需要使用<code>-e</code>来<strong>指定ssh连接参数</strong>，如<code>端口</code>、<code>连接的用户</code>、<code>ssh选项</code>等：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定端口为12000</span></span><br><span class="line">rsync -r -v -e <span class="string">"ssh -p 12000 "</span> wangjb@166.111.152.116:/Share/home/wangjb/user/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./</span><br><span class="line">wangjb@166.111.152.116<span class="string">'s password: </span></span><br><span class="line"><span class="string">receiving incremental file list</span></span><br><span class="line"><span class="string">B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sent 115306 bytes  received 66000 bytes  10988.24 bytes/sec</span></span><br><span class="line"><span class="string">total size is 271119851  speedup is 1495.37</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="r-递归同步文件夹内容"><a href="#r-递归同步文件夹内容" class="headerlink" title="-r-递归同步文件夹内容"></a>-r-递归同步文件夹内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将scp目录下的test目录及其内容递归地复制到当前目录中的test目录</span></span><br><span class="line">rsync -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><div class="note info"><p>使用<code>-r</code>选项，<code>rsync</code>会进入到文件夹里去检查，而<strong>不会只对文件夹本身做“quick check”的(检查文件夹的大小和时间戳)</strong></p></div><hr><h3 id="R-保留目录结构"><a href="#R-保留目录结构" class="headerlink" title="-R-保留目录结构"></a>-R-保留目录结构</h3><p>默认情况下，同步只是针对的最后指定的文件或者目录，上层目录不会进行同步，如果有时需要保留目录结构，可以使用-R参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-R会保留目录结构</span></span><br><span class="line">rsync -R -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能使用相对路径，如果使用会报错</span></span><br><span class="line">rsync -R -r ../scp/<span class="built_in">test</span> ./</span><br><span class="line">found <span class="string">".."</span> dir <span class="keyword">in</span> relative path: ../scp/<span class="built_in">test</span></span><br><span class="line">rsync error: syntax or usage error (code 1) at flist.c(2130) [sender=3.0.9]</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终生成的路径</span></span><br><span class="line">/home/user/learn/linux_learn/rsync/(当前目录)home/user/learn/linux_learn/scp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>由于不能使用相对路径，有时候我们并不需要从根目录进行保留目录结构，只希望<strong>保留一部分目录结构</strong>，这是<strong>可以使用<code>.</code>表示保留目录结构的起始位置</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从linux_learn开始保留目录结构</span></span><br><span class="line">rsync -R -r /home/user/learn/./linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终生成的路径</span></span><br><span class="line">/home/user/learn/linux_learn/rsync/(当前目录)linux_learn/scp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-R</code>参数表示<strong>使用相对路径</strong>，此<strong>相对路径是以目标目录为根的</strong>，例如<code>/home/user/learn/linux_learn/scp/test ./</code>表示使用当前目录来替换最开始的<code>/</code>目录</li><li><code>-R</code>指定的<strong>source目录必须使用绝对路径</strong>，不能使用相对路径</li><li><code>-R</code>可以指定<strong>保留部分目录结构</strong>，在完整的绝对路径中想要保留的目录结构之前加上<code>./</code>即可</li></ul></div><hr><h3 id="l-保留原始链接形式"><a href="#l-保留原始链接形式" class="headerlink" title="-l-保留原始链接形式"></a>-l-保留原始链接形式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程文件</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">lrwxrwxrwx. 1 user user        12 May  2 22:10 test2.txt -&gt; ../test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -v -t -r /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 默认会跳过链接文件</span></span><br><span class="line">skipping non-regular file <span class="string">"test/test2.txt"</span></span><br><span class="line"></span><br><span class="line">sent 271153253 bytes  received 54 bytes  180768871.33 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步，保留软连接</span></span><br><span class="line">rsync -v -t -r -l /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 保留软链接形式</span></span><br><span class="line"><span class="built_in">test</span>/test2.txt -&gt; ../test2.txt</span><br><span class="line"></span><br><span class="line">sent 271153269 bytes  received 57 bytes  180768884.00 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程文件</span></span><br><span class="line"><span class="comment"># 得到了和当前文件相同的软连接，相对路径的软连接会失效</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">lrwxrwxrwx. 1 user user        12 May  2 22:10 test2.txt -&gt; ../test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="L-复制链接指向的文件或目录"><a href="#L-复制链接指向的文件或目录" class="headerlink" title="-L-复制链接指向的文件或目录"></a>-L-复制链接指向的文件或目录</h3><p>上述的参数-l虽会保留软链接，但如果不是同一台机器以及链接不是使用的绝对路径都会使得链接失效，较为有效地做法是复制链接指向的文件，可以使用-L参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步，复制链接指向的文件或目录</span></span><br><span class="line">rsync -v -t -r -L /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 直接复制了链接指向的文件</span></span><br><span class="line"><span class="built_in">test</span>/test2.txt</span><br><span class="line"></span><br><span class="line">sent 271153307 bytes  received 73 bytes  180768920.00 bytes/sec</span><br><span class="line">total size is 271119935  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前文件</span></span><br><span class="line"><span class="comment"># 不再是链接，而是文件</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        15 May  2 22:09 test2.txt</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–backup-已存在的目录备份"><a href="#–backup-已存在的目录备份" class="headerlink" title="–backup-已存在的目录备份"></a>–backup-已存在的目录备份</h3><p>如果在<strong>进行同步时希望保留当前的文件</strong>，可以使用<code>--backup</code>来进行备份，默认的备份文件使用”<code>~</code>“做后缀，可以使用<code>--suffix</code>指定备份后缀：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步的同时进行备份</span></span><br><span class="line">rsync -r --backup /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost <span class="built_in">test</span>]$ ll</span><br><span class="line">total 529536</span><br><span class="line"><span class="comment"># 默认的原始的文件使用了~</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:09 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 12:35 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart~</span><br></pre></td></tr></table></figure><p></p><p>指定原始文件的备份后缀：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--suffix指定备份文件的后缀</span></span><br><span class="line">rsync -r --backup --suffix <span class="string">".backup"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost <span class="built_in">test</span>]$ ll</span><br><span class="line">total 794304</span><br><span class="line"><span class="comment"># 设置了备份文件后缀为backup</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:11 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 12:35 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart~</span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:09 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.backup</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–backup-dir-指定备份目录"><a href="#–backup-dir-指定备份目录" class="headerlink" title="–backup-dir-指定备份目录"></a>–backup-dir-指定备份目录</h3><p>将<strong>当前的文件备份到指定的目录中</strong>，而不是默认的当前目录，<strong>默认是不会给文件增加后缀的</strong>，可以<strong>使用<code>--suffix</code>指定备份后缀</strong>，注意<strong>必须和<code>--backup</code>一同使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前文件备份到backup目录下，如果目录不存在就创建</span></span><br><span class="line">rsync -r --backup --backup-dir ./backup /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定备份文件后缀</span></span><br><span class="line">rsync -r --backup --backup-dir ./backup --suffix <span class="string">".test"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–existing-只更新目标端存在的文件"><a href="#–existing-只更新目标端存在的文件" class="headerlink" title="–existing-只更新目标端存在的文件"></a>–existing-只更新目标端存在的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只更新当前目录下存在文件</span></span><br><span class="line">rsync -r --existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><p>输出结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为当前目录下没有和test目录下共有的文件，所以没有进行同步</span></span><br></pre></td></tr></table></figure><p></p><p>在当前目录下创建一个和远程目录中相同的文件test.txt，并在远程的test.txt中写入内容，而当前目录的test.txt为空：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  1 23:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -r --existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现了相同文件的同步</span></span><br><span class="line">-rw-rw-r--. 1 user user 69 May  2 13:35 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–ignore-existing-只更新目标端不存在的文件"><a href="#–ignore-existing-只更新目标端不存在的文件" class="headerlink" title="–ignore-existing-只更新目标端不存在的文件"></a>–ignore-existing-只更新目标端不存在的文件</h3><p>和上面的<code>--existing</code>参数相反，<code>--ignore-existing</code>只更新当面不存在的文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:43 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line">rsync -r --ignore-existing  /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 已存在的test.txt没有更新</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:44 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user         0 May  2 13:43 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–remove-source-files-删除远程文件"><a href="#–remove-source-files-删除远程文件" class="headerlink" title="–remove-source-files-删除远程文件"></a>–remove-source-files-删除远程文件</h3><p>使用该选项后，<strong>远程已经更新成功的文件都会被删除</strong>，远程所有<strong>未传输或未传输成功的文件都不会被移除</strong>。未传输成功的原因有多种，如<code>exclude</code>排除了，<code>&quot;quick check&quot;</code>未选项该文件，传输中断等等。总之，显示在<code>&quot;rsync -v&quot;</code>被传输列表中的文件<strong>都会被移除</strong>。如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 13:43 test.txt</span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  1 23:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 同步完成之后删除远程已经同步好的文件</span></span><br><span class="line">rsync -r -v --ignore-existing --remove-source-files /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:50 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user         0 May  2 13:43 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line"><span class="comment"># 同步完成的文件被删除了</span></span><br><span class="line">-rw-rw-r--. 1 user user 69 May  2 13:32 test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–exclude-指定排除规则"><a href="#–exclude-指定排除规则" class="headerlink" title="–exclude-指定排除规则"></a>–exclude-指定排除规则</h3><p>上面使用<code>--existing</code>和<code>--ignore-existing</code>来仅对已经存在或者不存在的文件进行更新，实际上就是一种排除规则，如果希望对某一类文件的同步进行排除可以使用<code>--exclude</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 排除所有txt后缀文件</span></span><br><span class="line">rsync -r -v --exclude <span class="string">"*.txt"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"></span><br><span class="line">sent 271153093 bytes  received 32 bytes  180768750.00 bytes/sec</span><br><span class="line">total size is 271119851  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:01 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>一个<code>--exclude</code>只能指定一条规则</strong>，要<strong>指定多条排除规则</strong>，需要<strong>使用多个<code>--exclude</code>选项</strong>，或者将排除规则<strong>写入到文件中</strong>，然后使用<code>--exclude-from</code>选项读取该规则文件</li><li>除了<code>--exclude</code>排除规则，还有<code>--include</code>包含规则，顾名思义，它就是<strong>筛选出要进行传输的文件</strong>，所以<code>include</code>规则也称为传输规则。它的使用方法和<code>--exclude</code>一样。<strong>如果一个文件即能匹配排除规则，又能匹配包含规则，则先匹配到的立即生效，生效后就不再进行任何匹配</strong></li><li>最重要的一点是它的<strong>作用时间</strong>。当发送端敲出rsync命令后，rsync将立即扫描命令行中给定的文件和目录(扫描过程中还会按照目录进行排序，将同一个目录的文件放在相邻的位置)，这称为拷贝树(copy tree)，扫描完成后将待传输的文件或目录记录到文件列表中，然后将文件列表传输给接收端。而<strong>筛选规则的作用时刻是在扫描拷贝树时</strong>，所以会<strong>根据规则来匹配并决定文件是否记录到文件列表中(严格地说是会记录到文件列表中的，只不过排除的文件会被标记为hide隐藏起来)</strong>，只有记录到了文件列表中的文件或目录才是真正需要传输的内容。换句话说，<strong>筛选规则的生效时间在rsync整个同步过程中是非常靠前的，它会影响很多选项的操作对象，最典型的如<code>--delete</code></strong>。</li></ul></div><hr><h3 id="rsync中的匹配规则"><a href="#rsync中的匹配规则" class="headerlink" title="rsync中的匹配规则"></a>rsync中的匹配规则</h3><p>以下是rsync中的规则种类，不解之处请结合下文的<code>--delete</code>分析：</p><ul><li><p><code>exclude规则</code>：即<strong>排除规则</strong>，只作用于<strong>发送端</strong>，<strong>被排除的文件不会进入文件列表</strong>(实际上是加上隐藏规则进行隐藏)</p></li><li><p><code>include规则</code>：即<strong>包含规则</strong>，也称为传输规则，<strong>只作用于发送端</strong>，被包含的文件将明确记录到文件列表中</p></li><li><p><code>hide规则</code>：即<strong>隐藏规则</strong>，<strong>只作用于发送端</strong>，隐藏后的文件对于接收端来说是看不见的，<strong>也就是说接收端会认为它不存在于源端</strong></p></li><li><p><code>show规则</code>：即<strong>显示规则</strong>，<strong>只作用于发送端</strong>，<strong>是隐藏规则的反向规则</strong></p></li><li><p><code>protect规则</code>：即<strong>保护规则</strong>，该规则<strong>只作用于接收端</strong>，<strong>被保护的文件不会被删除掉</strong></p></li><li><p><code>risk规则</code>：即<strong>取消保护规则</strong>，<strong>是protect的反向规则</strong></p></li></ul><p>除此之外，还有一种规则是<code>clear规则</code>，作用是<strong>删除include/exclude规则列表</strong></p><hr><h3 id="–delete-得到和远程目录完全相同的目录"><a href="#–delete-得到和远程目录完全相同的目录" class="headerlink" title="–delete-得到和远程目录完全相同的目录"></a>–delete-得到和远程目录完全相同的目录</h3><p>使用”–delete”选项后，接收端的rsync会先删除目标目录(当前目录)下已经存在，但源端(远程)目录不存在的文件，也就是”多则删之，少则补之”：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 0 May  2 14:17 test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 先删除当前目录中存在但是远程目录不存在的文件，然后进行同步</span></span><br><span class="line">rsync -r --delete -v /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line">deleting <span class="built_in">test</span>/test2.txt</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"></span><br><span class="line">sent 271153227 bytes  received 51 bytes  108461311.20 bytes/sec</span><br><span class="line">total size is 271119920  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># test2.txt已经被删除</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:19 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br></pre></td></tr></table></figure><p></p><p><code>--delete</code>与<code>--exclude</code>联用，<code>--exclude</code>可以将某些文件排除在同步文件之外，而这些文件在被排除在同步文件之外后，当前目录存在的这些被排除的文件会不会被<code>--delete</code>删除是关键？结果是<mark><code>--exclude</code>排除的文件不会被<code>--delete</code>删除</mark>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 14:19 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目录</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 13:59 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 13:32 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步</span></span><br><span class="line"><span class="comment"># 排除所有txt后缀的文件</span></span><br><span class="line"><span class="comment"># 也就是说不会对当前目录中的txt文件依据远程文件进行同步</span></span><br><span class="line">rsync -v -r --delete --exclude <span class="string">"*.txt"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line"></span><br><span class="line">sent 271153093 bytes  received 32 bytes  180768750.00 bytes/sec</span><br><span class="line">total size is 271119851  speedup is 1.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录</span></span><br><span class="line"><span class="comment"># 虽然txt文件没有没同步， 但是也没有被删除</span></span><br><span class="line">-rw-rw-r--. 1 user user 271119851 May  2 18:37 B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">-rw-rw-r--. 1 user user        69 May  2 14:19 test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于<code>--exclude</code>排除的文件不会被<code>--delete</code>删除的原理请参考<a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">这篇文章</a></p></div><p><code>--delete</code>与<code>--existing</code>和<code>--ignore-existing</code>结合使用时，<strong>文件不会被传输</strong>，<strong>但会删除receiver端额外多出的文件</strong>，<u>个人理解其过程可能是先<code>--existing</code>得到的传输文件列表中都是当前文件和远程共有的文件，再次使用<code>--ignore-existing</code>时是仅传输不存在的文件，此时的文件列表不包含当前目录不存在的文件，所以不会进行传输，<code>--delete</code>会进行删除操作</u>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">$ mkdir a b</span><br><span class="line">$ touch a/&#123;1..4&#125;.txt</span><br><span class="line">$ touch b/a.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--delete</span></span><br><span class="line">$ rsync -nrv --delete a/ b/</span><br><span class="line">sending incremental file list</span><br><span class="line">deleting a.log</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"> </span><br><span class="line">sent 118 bytes  received 33 bytes  302.00 bytes/sec</span><br><span class="line">total size is 0  speedup is 0.00 (DRY RUN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--delete并结合--existing、--ignore-existing</span></span><br><span class="line">$ rsync -nrv --existing --ignore-existing --delete a/ b/</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="comment"># 只进行了删除操作</span></span><br><span class="line">deleting a.log</span><br><span class="line"> </span><br><span class="line">sent 106 bytes  received 21 bytes  254.00 bytes/sec</span><br><span class="line">total size is 0  speedup is 0.00 (DRY RUN)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–max-size-不传输大文件"><a href="#–max-size-不传输大文件" class="headerlink" title="–max-size-不传输大文件"></a>–max-size-不传输大文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同步大于100M的文件</span></span><br><span class="line">rsync -v -t -r --max-size <span class="string">"100m"</span> /home/user/learn/linux_learn/scp/<span class="built_in">test</span> ./</span><br><span class="line">sending incremental file list</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/test.txt</span><br><span class="line"><span class="comment"># 忽略了链接文件</span></span><br><span class="line">skipping non-regular file <span class="string">"test/test2.txt"</span></span><br><span class="line"></span><br><span class="line">sent 267 bytes  received 35 bytes  604.00 bytes/sec</span><br><span class="line">total size is 271119932  speedup is 897748.12</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">第2章 rsync(一)：基本命令和用法</a></li><li><a href="http://man.linuxde.net/rsync" target="_blank" rel="noopener">rsync命令</a></li><li><a href="http://roclinux.cn/?p=2643" target="_blank" rel="noopener">《rsync同步的艺术》–linux命令五分钟系列之四十二</a></li><li><a href="https://www.linuxprobe.com/rsync-use-sample.html" target="_blank" rel="noopener">rsync 使用示例</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp-跨平台复制命令</title>
      <link href="/posts/2539.html"/>
      <url>/posts/2539.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中用于<strong>远程复制命令scp</strong>，其主要功能包括：<strong>复制远程文件到当前服务器文件或目录</strong>、<strong>复制远程目录到当前服务器目录</strong>、<strong>复制当前文件到远程服务器文件或目录</strong>、<strong>复制当前目录到远程目录</strong>，其中重要和常用的参数是<code>-P</code>、<code>-r</code>；<strong>需要特别注意<code>scp</code>和<code>cp</code>以及<code>rsnyc</code>命令的区别</strong>。</p></div><a id="more"></a><h2 id="scp命令简介"><a href="#scp命令简介" class="headerlink" title="scp命令简介"></a>scp命令简介</h2><p><code>scp</code>是<code>secure copy</code>的简写，用于在Linux下进行<strong>远程拷贝文件</strong>的命令，和它类似的命令有<code>cp</code>，不过 <strong><code>cp</code>只是在本机进行拷贝不能跨服务器</strong>，而且<strong>scp传输是加密的</strong>。当<strong>你服务器硬盘变为只读 <code>read only system</code>时，用scp可以帮你把文件移出来</strong>。</p><p>与<code>scp</code>命令类似的工具有<a href="http://showteeth.tech/posts/8376.html">rsync</a>，两者的功能类似，但是<strong>区别主要表现在资源占用和速度上</strong>：</p><ul><li><strong><code>scp</code>消耗资源少，不会提高多少系统负荷</strong>，在这一点上，<code>rsync</code>就远远不及它了</li><li><strong><code>rsync</code>比<code>scp</code>会快一点，但当小文件多的情况下，<code>rsync</code>会导致硬盘<code>I/O</code>非常高，而<code>scp</code>基本不影响系统正常使用</strong></li></ul><hr><h2 id="scp命令格式"><a href="#scp命令格式" class="headerlink" title="scp命令格式"></a>scp命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">Usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure><hr><h2 id="scp参数说明"><a href="#scp参数说明" class="headerlink" title="scp参数说明"></a>scp参数说明</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>-1</code></td><td>强制scp命令使用协议ssh1</td></tr><tr><td><code>-2</code></td><td>强制scp命令使用协议ssh2</td></tr><tr><td><code>-4</code></td><td>强制scp命令只使用IPv4寻址</td></tr><tr><td><code>-6</code></td><td>强制scp命令只使用IPv6寻址</td></tr><tr><td><code>-B</code></td><td>使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td><code>-C</code></td><td>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</td></tr><tr><td><strong><code>-p</code></strong></td><td>保留原文件的修改时间，访问时间和访问权限</td></tr><tr><td><code>-q</code></td><td>不显示传输进度条</td></tr><tr><td><strong><code>-r</code></strong></td><td>递归复制整个目录</td></tr><tr><td><strong><code>-v</code></strong></td><td>详细方式显示输出，scp和ssh(1)会显示出整个过程的调试信息，这些信息用于调试连接，验证和配置问题</td></tr><tr><td><code>-c</code></td><td><code>cipher</code> 以cipher将数据传输进行加密，这个选项将直接传递给ssh</td></tr><tr><td><code>-F</code></td><td><code>ssh_config</code> 指定一个替代的ssh配置文件，此参数直接传递给ssh</td></tr><tr><td><code>-i</code></td><td><code>identity_file</code> 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</td></tr><tr><td><code>-l</code></td><td><code>limit</code> 限定用户所能使用的带宽，以Kbit/s为单位</td></tr><tr><td><code>-o</code></td><td><code>ssh_option</code> 如果习惯于使用ssh_config(5)中的参数传递方式</td></tr><tr><td><code>-S</code></td><td><code>program</code> 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项</td></tr><tr><td><strong><code>-P</code></strong></td><td><code>port</code> 注意是大写的P, port是指定数据传输用到的端口号</td></tr></table><hr><h2 id="scp具体使用"><a href="#scp具体使用" class="headerlink" title="scp具体使用"></a>scp具体使用</h2><h3 id="本地到远程"><a href="#本地到远程" class="headerlink" title="本地到远程"></a>本地到远程</h3><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p><strong>命令形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用形式</span></span><br><span class="line">scp [可选参数] source_file remote_username@remote_ip:target_file_or_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中指定传输目的服务器username</span></span><br><span class="line"><span class="comment"># 复制到文件夹，文件名称保持不变</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_username@remote_ip:remote_folder</span><br><span class="line"><span class="comment"># 复制到文件，复制并改名</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_username@remote_ip:remote_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中不指定传输目的服务器username</span></span><br><span class="line"><span class="variable">$scp</span> local_file remote_ip:remote_folder</span><br><span class="line"><span class="variable">$scp</span> local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>如果<strong>在命令中指定了目的服务器的用户名</strong>，命令执行后只需要<strong>输入对应的用户密码</strong>；</li><li>如果在命令中<strong>不指定目的服务器的用户名</strong>，命令执行后<strong>默认的用户名和当前服务器的用户名相同</strong>，<strong>输入密码</strong></li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接这么写会报错</span></span><br><span class="line">scp B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp</span><br></pre></td></tr></table></figure><p>直接按照上面的写法会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host 166.111.152.101 port 22: Connection refused</span><br><span class="line">lost connection</span><br></pre></td></tr></table></figure><p></p><p>出错原因是没有指定port，而<mark>scp默认的port是22，如果端口号不是22的话就会出错</mark>，可以<strong>使用<code>-P</code>来指定端口号</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-P指定端口</span></span><br><span class="line"><span class="comment"># 如果端口不是22</span></span><br><span class="line"><span class="comment"># 复制到文件夹，文件名称保持不变</span></span><br><span class="line">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp </span><br><span class="line"><span class="comment"># 需要输入目的服务器username的密码</span></span><br><span class="line">username@166.111.152.101<span class="string">'s password:  </span></span><br><span class="line"><span class="string"># 显示传输进度 </span></span><br><span class="line"><span class="string">B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart                                                                         100%  259MB   8.6MB/s   00:30</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 复制到文件，相当于复制并且修改文件名称</span></span><br><span class="line"><span class="string">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart username@166.111.152.101:/home/username/learn/linux_learn/scp/test.txt</span></span><br></pre></td></tr></table></figure><p></p><p><strong>不指定目的服务器的用户名，那么默认目的服务器用户名和当前服务器用户名相同</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令中没有指定用户名</span></span><br><span class="line">scp -P 18231  B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart 166.111.152.101:/home/username/learn/linux_learn/scp/test.txt</span><br><span class="line"><span class="comment"># 默认的用户名和当前服务器用户名相同</span></span><br><span class="line">local_username@166.111.152.101<span class="string">'s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># local_username和username不同，导致了权限错误</span></span><br><span class="line"><span class="string">scp: /home/username/learn/linux_learn/scp/test.txt: Permission denied</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h4><p>使用<code>-r</code>参数来进行递归复制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令中指定目的服务器的username</span></span><br><span class="line"><span class="variable">$scp</span> -r local_folder remote_username@remote_ip:remote_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在命令中指定目的服务器的username，默认和当前服务器的username相同</span></span><br><span class="line"><span class="variable">$scp</span> -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure><p></p><h3 id="远程到本地"><a href="#远程到本地" class="headerlink" title="远程到本地"></a>远程到本地</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用形式</span></span><br><span class="line"><span class="comment"># 其实就是将前面的scp后面接着的远程和本地文件换个位置</span></span><br><span class="line">scp [可选参数] remote_username@remote_ip:source_file target_file_or_folder</span><br></pre></td></tr></table></figure><h4 id="复制文件-1"><a href="#复制文件-1" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制到本地目录</span></span><br><span class="line">scp -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到本地文件，相当于复制并改名</span></span><br><span class="line">scp -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span>/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart ./test.txt</span><br></pre></td></tr></table></figure><hr><h4 id="复制目录-1"><a href="#复制目录-1" class="headerlink" title="复制目录"></a>复制目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-r参数来进行递归复制</span></span><br><span class="line">scp -r -P 12000 wangjb@166.111.152.116:/Share/home/wangjb/username/data/<span class="built_in">test</span> ./</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html" target="_blank" rel="noopener">scp 跨机远程拷贝</a></li><li><a href="https://www.cnblogs.com/peida/archive/2013/03/15/2960802.html" target="_blank" rel="noopener">每天一个linux命令（60）：scp命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>read-从键盘或文件中获取输入</title>
      <link href="/posts/59492.html"/>
      <url>/posts/59492.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p><code>read</code>是linux中<strong>获取键盘或文件输入</strong>并将<strong>结果保存在若干变量或数组中的命令</strong>，其主要参数包括：<code>-p</code>、<code>-a</code>、<code>-d</code>、<code>-e</code>、<code>-i</code>、<code>-s</code>、<code>-t</code>、<code>-n</code>、<code>-r</code>、<code>-u</code>；需要特别注意这里学习的关于<strong>使用管道符读取文件</strong>时涉及到的<strong>自定义变量生命周期</strong>的问题。</p></div><a id="more"></a><h2 id="read命令简介"><a href="#read命令简介" class="headerlink" title="read命令简介"></a>read命令简介</h2><p><code>read</code>命令可以<strong>获取键盘或者文件输入</strong>并<strong>赋值给变量或数组</strong>。</p><hr><h2 id="read命令格式"><a href="#read命令格式" class="headerlink" title="read命令格式"></a>read命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage: </span><br><span class="line">  <span class="built_in">read</span> [-ers] [-a array] [-d delim] </span><br><span class="line">       [-i text] [-n nchars] [-N nchars] </span><br><span class="line">       [-p prompt] [-t timeout] [-u fd] [name ...]</span><br></pre></td></tr></table></figure><hr><h2 id="read参数说明"><a href="#read参数说明" class="headerlink" title="read参数说明"></a>read参数说明</h2><table><tr><th width="10%">参数</th><th width="90%">说明</th></tr><tr><td><code>-a</code></td><td>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符</td></tr><tr><td><code>-d</code></td><td>后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。</td></tr><tr><td><code>-p</code></td><td>后面跟提示信息，即在输入前打印提示信息。</td></tr><tr><td><code>-e</code></td><td>在输入的时候可以使用命令补全功能。</td></tr><tr><td><code>-i</code></td><td>设置默认用于补全的prefix，必须和前面的<code>-e</code>一同使用才有用</td></tr><tr><td><code>-n</code></td><td>后跟一个数字，定义输入文本的长度，很实用。</td></tr><tr><td><code>-r</code></td><td>屏蔽<code>\</code>，如果没有该选项，则<code>\</code>作为一个转义字符(续行)，有的话<code>\</code>就是个正常的字符了。</td></tr><tr><td><code>-s</code></td><td>安静模式，在输入字符时不在屏幕上显示，例如login时输入密码。</td></tr><tr><td><code>-t</code></td><td>后面跟秒数，定义输入字符的等待时间。</td></tr><tr><td><code>-u</code></td><td>后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</td></tr></table><hr><h2 id="read用法实例"><a href="#read用法实例" class="headerlink" title="read用法实例"></a>read用法实例</h2><h3 id="默认读取"><a href="#默认读取" class="headerlink" title="默认读取"></a>默认读取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下echo输出内容之后会换行</span></span><br><span class="line"><span class="comment"># -n参数可以不换行</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"please input your name:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取键盘输入，并保存在name变量中</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出变量并正常退出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line">  please input your name:<span class="built_in">test</span></span><br><span class="line">  welcome !!! <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>如果在read之后<strong>没有使用参数进行接收键盘输入</strong>，则读取的值会<strong>存放在一个叫作 <code>$REPLY</code> 的环境变量中</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 没有指定接收键盘输入的变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name and place:"</span></span><br><span class="line"><span class="comment"># 默认会存放在$REPLY中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome <span class="variable">$REPLY</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh test_2.sh </span><br><span class="line"><span class="comment"># 还是能正常输出</span></span><br><span class="line">please input your name and place:<span class="built_in">test</span></span><br><span class="line">welcome <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="p-输入提示语"><a href="#p-输入提示语" class="headerlink" title="-p-输入提示语"></a>-p-输入提示语</h3><p>上面为了达到输入提示语的效果借助了<code>echo</code>命令，其实<code>read</code>命令的参数<code>-p</code>可以起到<strong>输入提示语</strong>的效果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo  -n "please input your name:"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p参数替换echo进行输入提示</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name:"</span>  name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 效果和使用echo是一样的</span></span><br><span class="line">  please input your name:<span class="built_in">test</span></span><br><span class="line">  welcome !!! <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="一次读入多个变量"><a href="#一次读入多个变量" class="headerlink" title="一次读入多个变量"></a>一次读入多个变量</h3><p>变量的数目是根据read定义的变量数目决定的：</p><ul><li>read后面变量数目等于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read后面有两格变量name和city，所以可以读取两个变量</span></span><br><span class="line"><span class="comment"># 使用空格分隔变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your name and city: "</span>  name city</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span> from <span class="variable">$city</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入两个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 传递给name和city变量</span></span><br><span class="line">  please input your name and city: <span class="built_in">test</span> beijing</span><br><span class="line">  welcome !!! <span class="built_in">test</span> from beijing</span><br></pre></td></tr></table></figure><p></p><ul><li>read后面变量数目小于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入三个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 第一个空格分隔的字符传递给name，剩下的传递给另一个变量</span></span><br><span class="line">please input your name and city: <span class="built_in">test</span> beijing haidian</span><br><span class="line">welcome !!! <span class="built_in">test</span> from beijing haidian</span><br></pre></td></tr></table></figure><ul><li>read后面变量数目大于空格分隔的键盘输入数目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test.sh </span><br><span class="line"><span class="comment"># 键盘输入一个使用空格分隔的字符</span></span><br><span class="line"><span class="comment"># 字符传递给第一个变量name，剩下的变量为空</span></span><br><span class="line">please input your name and city: <span class="built_in">test</span></span><br><span class="line">welcome !!! <span class="built_in">test</span> from</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>如果read后面的参数数目<strong>等于</strong>键盘输入的空格分隔的字符数目，则<strong>参数和输入一一对应</strong></li><li>如果read后面的参数数目<strong>大于</strong>键盘输入的空格分隔的字符数目，则<strong>不足的参数为空</strong></li><li>如果read后面的参数数目<strong>小于</strong>键盘输入的空格分隔的字符数目，则<strong>多余的空格分隔的字符赋值在最后一个变量</strong></li></ul></div><hr><h3 id="a-数组变量"><a href="#a-数组变量" class="headerlink" title="-a-数组变量"></a>-a-数组变量</h3><p>默认情况下，read将读取的字符存储在不同的变量中，如果想要储存在<a href="http://showteeth.tech/posts/46714.html">数组</a>中，可以使用-a参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -a参数后面是指定的存储数组的变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"get var by array: "</span> -a  array</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"print <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh a.sh </span><br><span class="line">  get var by array: as ad af</span><br><span class="line">  <span class="built_in">print</span> as</span><br><span class="line">  <span class="built_in">print</span> ad</span><br><span class="line">  <span class="built_in">print</span> af</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="d-指定读取结束字符"><a href="#d-指定读取结束字符" class="headerlink" title="-d-指定读取结束字符"></a>-d-指定读取结束字符</h3><p>如果希望使用特定的字符来控制读取停止位置，可以使用-d参数，注意之后-d后面指定字符的第一个字符有用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里-d参数指定了end字符</span></span><br><span class="line"><span class="comment"># 其实只有开头的e起到作用了</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"get var by array: "</span> -d end -a array</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"print <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh d.sh </span><br><span class="line"><span class="comment"># 输入的时候遇到e字符就会停止接收</span></span><br><span class="line"><span class="comment"># 然后直接执行后面的输出</span></span><br><span class="line">get var by array: ads ada eprint ads</span><br><span class="line"><span class="built_in">print</span> ada</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="t-输入等待时间"><a href="#t-输入等待时间" class="headerlink" title="-t-输入等待时间"></a>-t-输入等待时间</h3><p>设置输入等待时间，如果长时间不输入，read命令返回一个<strong>非零退出状态</strong>，可以结合<code>if</code>命令进行处理：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -t 5 -p <span class="string">"please input your name within 5s:"</span> name</span><br><span class="line"><span class="comment"># 输出read命令的退出状态</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"></span><br><span class="line"><span class="comment"># if命令本来就是判断条件测试语句的退出状态</span></span><br><span class="line"><span class="comment"># 如果非零则执行else的结果</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">"please input your name within 5s:"</span> name</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"sorry, too slow"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./test_t.sh </span><br><span class="line"><span class="comment"># 不进行输入，返回退出状态为142</span></span><br><span class="line">please input your name within 5s:142</span><br><span class="line"><span class="comment"># 使用if条件测试进行处理，输出自定义的内容</span></span><br><span class="line">please input your name within 5s:sorry, too slow</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-输入内容不显示"><a href="#s-输入内容不显示" class="headerlink" title="-s-输入内容不显示"></a>-s-输入内容不显示</h3><p>默认的read会将输入显示在屏幕上，而在输入时可能会遇到一些信息不希望被人看到，这时可以使用<code>-s</code>参数(实际上，数据是显示的，只是 read 命令将<strong>文本颜色设置成与背景相同的颜色</strong>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 使用-s参数来不显示屏幕输入内容</span></span><br><span class="line"><span class="built_in">read</span> -s -p <span class="string">"please input your code:"</span> password</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hehe, your password is <span class="variable">$password</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test_s.sh </span><br><span class="line"><span class="comment"># 注意这里不会换行</span></span><br><span class="line">please input your code:hehe, your password is <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-输入字符长度"><a href="#n-输入字符长度" class="headerlink" title="-n-输入字符长度"></a>-n-输入字符长度</h3><p>read可以使用-n参数来控制读取的输入字符长度，当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -n 1 -p <span class="string">"Do you want to continue [Y/N]?"</span> answer</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span></span><br><span class="line">Y | y)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"fine ,continue"</span>;;</span><br><span class="line">N | n)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"ok,good bye"</span>;;</span><br><span class="line">*)</span><br><span class="line">     <span class="built_in">echo</span> <span class="string">"error choice"</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./n.sh </span><br><span class="line"><span class="comment"># 本来准备输入yes，但是输入y之后就默认指定后面的echo命令</span></span><br><span class="line"><span class="comment"># 压根没有给输入yes的可能性</span></span><br><span class="line">Do you want to <span class="built_in">continue</span> [Y/N]?yfine ,<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>输入长度达到<code>-n</code>指定的长度之后<strong>立即停止接受输入</strong>，并<strong>执行后续的命令</strong>，<strong>不管是不是还在输入</strong>.</p></div><hr><h3 id="u-读取文件内容"><a href="#u-读取文件内容" class="headerlink" title="-u-读取文件内容"></a>-u-读取文件内容</h3><p>读取文件内容常常使用在循环中：</p><ul><li>使用文件操作符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成了编号为 3 的文件描述符</span></span><br><span class="line"><span class="comment"># 这个编号可以自定义，默认的1和2分别为标准输出和标准错误输出</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt; test.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用-u 3来读取文件内容</span></span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -u 3 var</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 使用了命令计算并赋值</span></span><br><span class="line">        <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭3号文件描述符</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&amp;-</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./u_1.sh </span><br><span class="line">  Line 1:19248</span><br><span class="line">  Line 2:19247</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 3</span><br></pre></td></tr></table></figure><p></p><ul><li>使用管道：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="comment"># 这里使用了管道而不是上面的文件描述符</span></span><br><span class="line"><span class="comment"># 使用更为简单</span></span><br><span class="line">cat test.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sh u_2.sh </span><br><span class="line">  Line 1:19248</span><br><span class="line">  Line 2:19247</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  <span class="comment"># 注意这里的line的计数为1，而不是3</span></span><br><span class="line">  Line no is 1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>上面最后<strong>输出的line计数为1而不是实际的3</strong>是由于管道导致的。我们知道，<strong>管道的两边一般需要新建进程</strong>，当执行完 while 语句后，新进程也就结束了，而脚本中 count 是新进程中的自定义变量，<strong>进程结束后该变量也就消失了（自定义变量的生命周期结束）</strong>。当脚本<strong>执行 echo 时，显示的 count 变量是脚本中第一行定义的变量的值，而不是 while 语句中的那个 count 变量了</strong>，因而输出的结果当然就是 1 了。</p></div><ul><li>重定向：</li></ul><p>为了使用简单(不使用文件描述符)，而又需要避免管道带来的问题，可以使用重定向：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line"><span class="comment"># 这里使用了重定向，形式为cmd &lt; file</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line 1:19248</span><br><span class="line">Line 2:19247</span><br><span class="line">Line 3:19246</span><br><span class="line">finished</span><br><span class="line"><span class="comment"># 这里输出了正确的结果3</span></span><br><span class="line">Line no is 3</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="r-屏蔽转移和续行"><a href="#r-屏蔽转移和续行" class="headerlink" title="-r-屏蔽转移和续行"></a>-r-屏蔽转移和续行</h3><p>常规情况下，在文件中使用<code>\</code>可以表示续行操作，这样在读取文件的时候也会将其当做续行符，从而将多行文本当成一行文本：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改test.txt文件，加入续行符</span></span><br><span class="line">cat test.txt </span><br><span class="line">  19248 \</span><br><span class="line">  19247 \</span><br><span class="line">  19246</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行前面的读取文件命令</span></span><br><span class="line">sh u_3.sh </span><br><span class="line">  <span class="comment"># 读取的结果都在同一行</span></span><br><span class="line">  Line 1:19248 19247 19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 1</span><br></pre></td></tr></table></figure><p></p><p>如果需要忽略续行符<code>\</code>，可以使用read的<code>-r</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=0</span><br><span class="line"><span class="comment"># 加入-r参数表示忽略续行符</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>:<span class="variable">$line</span>"</span></span><br><span class="line"><span class="comment"># 这里使用了重定向，形式为cmd &lt; file</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finished"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Line no is <span class="variable">$count</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sh u_4.sh </span><br><span class="line">  <span class="comment"># 忽略了续行符</span></span><br><span class="line">  <span class="comment"># 当做3行读取</span></span><br><span class="line">  Line 1:19248 \</span><br><span class="line">  Line 2:19247 \</span><br><span class="line">  Line 3:19246</span><br><span class="line">  finished</span><br><span class="line">  Line no is 3</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="e-输入补全"><a href="#e-输入补全" class="headerlink" title="-e-输入补全"></a>-e-输入补全</h3><p>在输入时进行tab补全功能：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -e -p <span class="string">"输入文件名:"</span> str </span><br><span class="line">输入文件名:<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 上面输入test之后按下两次tab键就可以输出当前目录下匹配test的文件信息</span></span><br><span class="line">test.sh    test_s.sh  test_t.sh  test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="i-设置默认用于补全的prefix"><a href="#i-设置默认用于补全的prefix" class="headerlink" title="-i-设置默认用于补全的prefix"></a>-i-设置默认用于补全的prefix</h3><p>如果需要给变量设置<strong>默认用于补全的prefix</strong>，自动进行填充，需要使用read的<code>-i</code>参数，注意这<strong>个必须结合<code>-e</code>参数进行使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认的prefix</span></span><br><span class="line"><span class="comment"># 自动填充到输入，再结合tab进行补全</span></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"test"</span></span><br><span class="line"><span class="comment"># -i必须结合-e参数一同使用</span></span><br><span class="line"><span class="built_in">read</span> -e -i <span class="string">"<span class="variable">$test</span>"</span> -p <span class="string">"please input your name: "</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome !!! <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh i.sh </span><br><span class="line"><span class="comment"># 与前面单独使用-e不同的是，这里的test是自动填充的prefix</span></span><br><span class="line">please input your name: <span class="built_in">test</span></span><br><span class="line">test.sh    test_s.sh  test_t.sh  test.txt</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.runoob.com/linux/linux-comm-read.html" target="_blank" rel="noopener">Linux read 命令</a></li><li><a href="http://c.biancheng.net/linux/read.html" target="_blank" rel="noopener">read命令_Linux read命令：读取从键盘或文件输入的数据</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time-计算命令执行花费的时间</title>
      <link href="/posts/21450.html"/>
      <url>/posts/21450.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>计算命令执行花费的时间</strong>的命令<code>time</code>，其输出包括三个时间<code>real</code>、<code>user</code> 和 <code>sys</code>，其中real是最终花费的时间；一般情况下<code>real=user+sys</code>，但如果命令是多核执行，也有可能是<code>real_time&lt;user_time+sys_time</code>，同时由于<code>usr time+sys time</code><strong>不包括其他进程的执行时间和进程阻塞时间的</strong>，所以<code>real_time&gt;user_time+sys_time</code>也是非常有可能的；最后<strong>前后两次执行同一个命令，输出的时间可能不同</strong>，这是因为<strong>第一次执行命令系统会建立缓存</strong>使得第二次执行的时间缩短。</p></div><a id="more"></a><h2 id="time命令简介"><a href="#time命令简介" class="headerlink" title="time命令简介"></a>time命令简介</h2><p>time命令用于统计执行指定命令所花费的总时间。</p><hr><h2 id="time命令格式"><a href="#time命令格式" class="headerlink" title="time命令格式"></a>time命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time <span class="built_in">command</span></span><br></pre></td></tr></table></figure><hr><h2 id="time使用讲解"><a href="#time使用讲解" class="headerlink" title="time使用讲解"></a>time使用讲解</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time ls</span><br><span class="line">test1.txt  test2.txt</span><br><span class="line"></span><br><span class="line">real0m0.002s</span><br><span class="line">user0m0.001s</span><br><span class="line">sys0m0.001s</span><br></pre></td></tr></table></figure><p>执行<code>time ls</code>之后会得到三个输出，<code>real</code>、<code>user</code> 和 <code>sys</code>，它们都代表什么含义呢？哪个才是 <code>ls</code> 命令的执行时间呢？下面我们就一起来看看这三个统计时间：</p><ul><li><code>real</code>：<strong>从进程 <code>ls</code> 开始执行到完成所耗费的 CPU 总时间</strong>。该时间包括 <strong><code>ls</code> 进程执行时实际使用的 CPU 时间</strong>，<strong><code>ls</code> 进程耗费在阻塞上的时间（如等待完成 I/O 操作）</strong>和<strong>其他进程所耗费的时间（Linux 是多进程系统，ls 在执行过程中，可能会有别的进程抢占 CPU）</strong>。</li><li><code>user</code>：进程 <code>ls</code> 执行<mark>用户态</mark>代码所耗费的 CPU 时间。该时间<strong>仅指 ls 进程执行时实际使用的 CPU 时间</strong>，而<strong>不包括其他进程所使用的时间和本进程阻塞的时间</strong>。</li><li><code>sys</code>：进程 <code>ls</code> 在<mark>内核态</mark>运行所耗费的 CPU 时间，即<strong>执行内核系统调用所耗费的 CPU 时间</strong>。</li></ul><div class="note info"><p>关于<strong>用户态</strong>和<strong>内核态</strong>：</p><ul><li>在内核态，代码拥有完全的，不受任何限制的访问底层硬件的能力。可以执行任意的CPU指令，访问任意的内存地址。内核态通常情况下，都是为那些最底层的，由操作系统提供的，可信可靠的代码来运行的。内核态的代码崩溃将是灾难性的，它会影响到整个系统。</li><li>在用户态，代码不具备直接访问硬件或者访问内存的能力，而必须借助操作系统提供的可靠的，底层的APIs来访问硬件或者内存。由于这种隔离带来的保护作用，用户态的代码崩溃（Crash），系统是可以恢复的。我们大多数的代码都是运行在用户态的。</li></ul></div><p>现在，我们应该对这三个时间非常清楚了吧。<code>ls</code> 命令的真正执行时间是多少？答案就是 <code>user+sys</code> 的时间，但<mark>一般情况下</mark>，<code>real=user+sys</code>，因而我们就<strong>使用 <code>real</code> 的时间作为 <code>ls</code> 的执行时间了</strong>（注意，<strong>这里会有几个坑，我们将在后面进行介绍</strong>）。</p><hr><h2 id="几个误区及解释"><a href="#几个误区及解释" class="headerlink" title="几个误区及解释"></a>几个误区及解释</h2><h3 id="real-time-user-time-sys-time"><a href="#real-time-user-time-sys-time" class="headerlink" title="real_time=user_time+sys_time"></a>real_time=user_time+sys_time</h3><p>如果你认为上面的等式一定成立的话，那么请你再理解一下前面关于 <code>real</code>、<code>user</code>和 <code>sys</code> 的介绍。在前面的表述中，<code>real time</code> 是<strong>包含了其他进程的执行时间和进程阻塞时间的</strong>，而 <code>usr time+sys time</code> 显然是<strong>不包括其他进程的执行时间和进程阻塞时间的</strong>。因此，<code>real_time&gt;user_time+sys_time</code>是非常有可能的。</p><hr><h3 id="real-time-gt-user-time-sys-time"><a href="#real-time-gt-user-time-sys-time" class="headerlink" title="real_time&gt;user_time+sys_time"></a>real_time&gt;user_time+sys_time</h3><p>根据上面的分析，这个关系式应该是成立的吧？嘿嘿，不一定哟。一般来说，在<strong>单核 CPU 系统</strong>中，<strong>这个关系式是成立的</strong>，但如果我们的系统是<strong>多核 CPU</strong> 的话，而有些程序是能够<strong>同时利用到多核 CPU 的计算能力的</strong>，在这种情况下这个关系式就不成立了。</p><p>程序利用<strong>多核 CPU 的计算能力</strong>，可以并行地处理多项事务。就像一件工作，原来是一个 CPU 核去做，现在是两个 CPU 核并行做，那么完成同样工作所花费的总时间是 <code>user_time+sys_time</code>，而两个人并行做却能够在更短的时间内完成，耗时为 <code>real_time</code>。因此，这种情况下，便出现了 <code>real_time&lt;user_time+sys_time</code> 的情况。</p><hr><h3 id="real-time-lt-user-time-sys-time"><a href="#real-time-lt-user-time-sys-time" class="headerlink" title="real_time&lt;user_time+sys_time"></a>real_time&lt;user_time+sys_time</h3><p>多核情况下，<code>real_time&lt;user_time+sys_time</code> 是成立的，那单核呢？显然<code>real_time&gt;user_time+sys_time</code>是有可能成立的。</p><p>上面的三个误区有点绕，但结论很重要，就是 <code>real_time</code> 和 <code>user_time+sys_time</code> 的<strong>大小关系不是恒久不变的</strong>，你需要了解你的 Linux 服务器，<strong>是单核</strong>，<strong>还是多核</strong>，这样才能正确地确定它们的关系。</p><hr><h2 id="前后执行同样命令时间不同"><a href="#前后执行同样命令时间不同" class="headerlink" title="前后执行同样命令时间不同"></a>前后执行同样命令时间不同</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次执行</span></span><br><span class="line">[roc@roclinux ~]$ time sudo find / -name mysql.sh</span><br><span class="line">  /etc/profile.d/mysql.sh</span><br><span class="line">  </span><br><span class="line">  real    0m6.776s</span><br><span class="line">  user    0m1.101s</span><br><span class="line">  sys 0m1.363s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次执行</span></span><br><span class="line">[roc@roclinux ~]$ time sudo find / -name mysql.sh</span><br><span class="line">/etc/profile.d/mysql.sh</span><br><span class="line"> </span><br><span class="line">  real    0m3.059s</span><br><span class="line">  user    0m1.189s</span><br><span class="line">  sys 0m1.435s</span><br></pre></td></tr></table></figure><p>咦，怎么 <code>real</code> 的时间缩减到了 3.059 秒了，生生<strong>少了 3 秒多钟</strong>，这又是怎么回事呢？<strong>为什么同样的命令在第二次执行时快这么多呢？</strong></p><p>这个现象<strong>跟 Linux 操作系统的运行原理有关</strong>，<mark><code>find</code> 命令在第一次执行后，系统会对一些文件做缓存，在第二次执行时，就正好使用到了这些缓存中的数据，因此执行速度就变快了很多</mark>。</p><hr><h2 id="usr-bin-time—另一个计时命令"><a href="#usr-bin-time—另一个计时命令" class="headerlink" title="/usr/bin/time—另一个计时命令"></a>/usr/bin/time—另一个计时命令</h2><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/time  sleep 3s</span><br><span class="line">  0.00user 0.00system 0:03.00elapsed 0%CPU (0avgtext+0avgdata 2416maxresident)k</span><br><span class="line">  0inputs+0outputs (0major+183minor)pagefaults 0swaps</span><br></pre></td></tr></table></figure><p>通过上述命令可以发现这个命令的输出结果更加完善，不仅包括前面的time输出的user、sys、real等信息，还输出了关于CPU使用、文件读写的情况，所以比time更加实用.</p><hr><h3 id="自定义输出内容"><a href="#自定义输出内容" class="headerlink" title="自定义输出内容"></a>自定义输出内容</h3><ul><li><code>%E</code>: Elapsed real time (in <strong><code>[hours:]minutes:seconds</code></strong>).</li><li><code>%e</code>：(Not in tcsh.) Elapsed real time (<code>in seconds</code>).</li><li>更多参数的说明信息：<a href="https://gist.github.com/tkuchiki/4b77005cc64426b28c3d" target="_blank" rel="noopener">github</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出时间</span></span><br><span class="line">/usr/bin/time --format=<span class="string">'download took %E seconds'</span> sleep 3s</span><br><span class="line">  download took 0:03.00 seconds</span><br><span class="line"></span><br><span class="line">/usr/bin/time --format=<span class="string">'download took %e seconds'</span> sleep 3s</span><br><span class="line">  download took 3.00 seconds</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/time.html" target="_blank" rel="noopener">time命令_Linux time命令：测量命令的执行时间或者系统资源的使用情况</a></li><li><a href="https://codingstandards.iteye.com/blog/798788" target="_blank" rel="noopener">我使用过的Linux命令之time - 测定一个命令的资源使用情况</a></li><li><a href="http://man.linuxde.net/time" target="_blank" rel="noopener">time命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xargs-给其他命令传递参数</title>
      <link href="/posts/30003.html"/>
      <url>/posts/30003.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了非常强大的能<strong>给其他命令传递参数的命令</strong><code>xargs</code>，需要特别注意的是<code>xargs</code><strong>传递的是后一个命令的参数</strong>，而<code>管道符</code><strong>传递的是前一个命令的结果，一个字符串而已</strong>；主要学习了<code>-a</code>、<code>-d</code>、<code>-n</code>、<code>-I</code>、<code>-t</code>、<code>-p</code>、<code>-L</code>等参数，同时也学习了<strong>其与<code>find</code>命令结合进行很多很强大的操作</strong>！</p></div><a id="more"></a><h2 id="xargs命令简介"><a href="#xargs命令简介" class="headerlink" title="xargs命令简介"></a>xargs命令简介</h2><ul><li><code>xargs</code> 是<strong>给命令传递参数</strong>的一个过滤器，也是<strong>组合多个命令</strong>的一个工具，其能够捕获一个命令的输出，然后传递给另外一个命令</li><li><code>xargs</code> 可以<strong>将管道或标准输入（stdin）数据转换成命令行参数</strong>，也<strong>能够从文件的输出中读取数据</strong></li><li><code>xargs</code> 也可以<strong>将单行或多行文本输入转换为其他格式</strong>，例如<strong>多行变单行</strong>，<strong>单行变多行</strong></li><li><code>xargs</code> 默认的命令是 <code>echo</code>，这意味着通过管道传递给 <code>xargs</code> 的输入将会包含换行和空白，不过通过 <code>xargs</code> 的处理，换行和空白将被空格取代</li><li><code>xargs</code> 一般是和管道一起使用</li></ul><hr><h2 id="xargs和管道符"><a href="#xargs和管道符" class="headerlink" title="xargs和管道符"></a>xargs和管道符</h2><p>通过上述功能的总结可以发现其实xargs命令和管道符的作用比较类似，两者都能够组合命令，但是两者在有些地方也存在区别或者不适用的地方，下面以cat命令为例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"><span class="comment"># 测试文件1 </span></span><br><span class="line">  I am test1 file</span><br><span class="line">cat test2.txt </span><br><span class="line"><span class="comment"># 测试文件2</span></span><br><span class="line">  I am test2 file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用管道查看test1.txt的内容</span></span><br><span class="line"><span class="built_in">echo</span> test1.txt |cat -</span><br><span class="line"><span class="comment"># 输出的就是前面echo的结果</span></span><br><span class="line">  test1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而使用xargs</span></span><br><span class="line"><span class="built_in">echo</span> test1.txt |xargs cat -</span><br><span class="line"><span class="comment"># 可以查看test.txt的具体内容</span></span><br><span class="line">  I am test1 file</span><br></pre></td></tr></table></figure><p></p><p>总结一下关于管道符和<code>xargs</code>：</p><ul><li><strong>管道符</strong>：把前一个命令<strong>原本要输出到屏幕的标准正常数据</strong>当作是<strong>后一个命令的标准输入</strong></li><li><code>xargs</code>:将前一个命令的标准输出传递给下一个命令，<strong>作为它的参数</strong></li><li>可以发现，<mark>两者最主要的区别是，管道符处理的是直接前一个命令的结果(字符串)，而xargs是将前一个命令的结果作为参数</mark>，可以通过上面的示例感受一下</li><li>一些需要<strong>处理文件名的命令</strong>，如<code>rm</code>、<code>cp</code>、<code>mv</code>等命令就需要使用<code>xargs</code>，而另一些可以<strong>直接处理具体文本内容的</strong>，就可以直接使用管道符，例如<code>grep</code></li></ul><hr><h2 id="xargs命令格式"><a href="#xargs命令格式" class="headerlink" title="xargs命令格式"></a>xargs命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  xargs [OPTION]... COMMAND INITIAL-ARGS...</span><br><span class="line">  <span class="comment"># 注意，后面的command是在xargs的参数后面</span></span><br><span class="line">  front-command | xargs -option later-command</span><br><span class="line"></span><br><span class="line">Run COMMAND with arguments INITIAL-ARGS and more arguments <span class="built_in">read</span> from input.</span><br></pre></td></tr></table></figure><hr><h2 id="xargs命令参数"><a href="#xargs命令参数" class="headerlink" title="xargs命令参数"></a>xargs命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-0</code></td><td><code>--null</code></td><td>Items are separated by a null(<code>'\0'</code>), not whitespace</td></tr><tr><td><code>-a</code></td><td><code>--arg-file=FILE</code></td><td>从文件读取参数，而不是标准输入</td></tr><tr><td><code>-d</code></td><td><code>--delimiter=CHARACTER</code></td><td>自定义参数定界符</td></tr><tr><td><code>-E END</code></td><td></td><td>END出现位置之后的参数都会被忽略</td></tr><tr><td><code>-I R</code></td><td></td><td>same as --replace=R (R must be specified)</td></tr><tr><td><code>-i</code></td><td><code>--replace=[R]</code></td><td>当xargs command 后有多个参数时，调整参数位置，R默认是<code>{}</code></td></tr><tr><td><code>-L,-l</code></td><td><code>--max-lines=MAX-LINES</code></td><td>从标准输入一次读取 num 行送给 command 命令</td></tr><tr><td><code>-n</code></td><td><code>--max-args=MAX-ARGS</code></td><td>指定一次处理的参数个数</td></tr><tr><td><code>-P</code></td><td><code>--max-procs=MAX-PROCS</code></td><td>修改最大的进程数，默认是1，为0时候为as many as it can</td></tr><tr><td><code>-p</code></td><td><code>--interactive</code></td><td>当每次执行一个argument的时候询问一次用户</td></tr><tr><td><code>-r</code></td><td>--no-run-if-empty</td><td>当xargs的输入为空的时候则停止xargs，不加这个参数会至少执行一次</td></tr><tr><td><code>-s</code></td><td><code>--max-chars=MAX-CHARS</code></td><td>xargs 后面那个命令的最大命令行字符数(包括命令的长度、参数的长度等)</td></tr><tr><td></td><td><code>--show-limits</code></td><td>Show limits on command-line length.</td></tr><tr><td><code>-t</code></td><td><code>--verbose</code></td><td>Print commands before executing them</td></tr></table><hr><h2 id="xargs使用实例"><a href="#xargs使用实例" class="headerlink" title="xargs使用实例"></a>xargs使用实例</h2><h3 id="a-从文件中读取参数"><a href="#a-从文件中读取参数" class="headerlink" title="-a-从文件中读取参数"></a>-a-从文件中读取参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">""</span> |xargs -a test1.txt </span><br><span class="line"><span class="comment"># 从文件中读取参数</span></span><br><span class="line">I am test1 file</span><br></pre></td></tr></table></figure><hr><h3 id="d-设置参数定界符"><a href="#d-设置参数定界符" class="headerlink" title="-d-设置参数定界符"></a>-d-设置参数定界符</h3><p>默认情况下<code>xargs</code>将其标准输入中的内容以<strong>空白(包括空格、Tab、回车换行等)分割</strong>成多个之后当作命令行参数传递给其后面的命令，也可以通过<code>-d</code>参数指定：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'11@22@33'</span> | xargs</span><br><span class="line"><span class="comment"># xargs默认命令是echo</span></span><br><span class="line"><span class="comment"># 等同于echo '11@22@33' | xargs echo</span></span><br><span class="line">  11@22@33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置定界符为@</span></span><br><span class="line"><span class="comment"># 注意echo命令要在xargs参数的后面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'11@22@33'</span> | xargs -d <span class="string">"@"</span> <span class="built_in">echo</span></span><br><span class="line">11 22 33</span><br><span class="line"><span class="comment"># 这个会有一个空行，不知道为什么</span></span><br><span class="line"><span class="comment"># 如果不加-d参数就不会出现空行</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-每次处理的参数个数"><a href="#n-每次处理的参数个数" class="headerlink" title="-n-每次处理的参数个数"></a>-n-每次处理的参数个数</h3><p>默认情况下，<code>xargs</code>后面的命令一次会处理所有的参数，可以通过-n参数指定每次处理的参数个数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1 2 3 4 5 6 7 8 9"</span> |xargs -n 3</span><br><span class="line"><span class="comment"># 每次输出3个</span></span><br><span class="line">  1 2 3</span><br><span class="line">  4 5 6</span><br><span class="line">  7 8 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的执行过程等价于</span></span><br><span class="line"><span class="built_in">echo</span> 1 2 3</span><br><span class="line"><span class="built_in">echo</span> 4 5 6</span><br><span class="line"><span class="built_in">echo</span> 7 8 9</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="E-指定停止解析参数字符"><a href="#E-指定停止解析参数字符" class="headerlink" title="-E-指定停止解析参数字符"></a>-E-指定停止解析参数字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定停止解析参数字符为33</span></span><br><span class="line"><span class="comment"># 包括33在内的后续字符都不会作为参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 33 44"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22</span><br></pre></td></tr></table></figure><p>注意，是完全以<code>-E</code>指定的停止解析字符<strong>完全相同</strong>才可以：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含233以及33，最终会在33的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 233 44 33 55 66"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22 233 44</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含332以及33，最终会在33的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 332 44 33 55 66"</span> |xargs -E <span class="string">"33"</span></span><br><span class="line">  11 22 332 44</span><br></pre></td></tr></table></figure><p></p><p>注意，如果<strong>同时指定了<code>-d</code>参数</strong>，<strong>则<code>-E</code>参数会失效</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定-d的同时指定-E</span></span><br><span class="line"><span class="comment"># -E失效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11 22 33 44 "</span> | xargs -d <span class="string">" "</span> -E <span class="string">"33"</span></span><br><span class="line">11 22 33 44 </span><br><span class="line"><span class="comment"># 这里会出现一个空行</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="I-调整参数位置"><a href="#I-调整参数位置" class="headerlink" title="-I-调整参数位置"></a>-I-调整参数位置</h3><p>如果<code>xargs</code>后面的命令需要多个参数时，可以使用<code>-I</code>来<strong>指定替换字符串</strong>，并<strong>将其放在合适的位置</strong>，这个<strong>替换字符串在 <code>xargs</code> 扩展时会被替换掉</strong>，当 <code>-I</code> 与 <code>xargs</code> 结合使用，<strong>每一个参数命令都会被执行一次</strong>，例如将当前目录下所有的文件复制到另一个目录：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先这个任务直接使用管道符是不能完成的</span></span><br><span class="line">ls *.txt|cp - ../csplit/</span><br><span class="line">  cp: cannot <span class="built_in">stat</span> ‘-’: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果直接使用xargs会报错</span></span><br><span class="line"><span class="comment"># 默认是将前一个参数的结果放在了最后，而txt不是一个目录</span></span><br><span class="line"><span class="comment"># 所以报错</span></span><br><span class="line">ls *.txt|xargs cp  ../csplit/</span><br><span class="line">  cp: target ‘test2.txt’ is not a directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的用法</span></span><br><span class="line"><span class="comment"># 使用-I参数指定&#123;&#125;为替换字符串</span></span><br><span class="line"><span class="comment"># 在cp命令中使用&#123;&#125;指代xargs传递给cp的参数</span></span><br><span class="line">ls *.txt | xargs -I &#123;&#125;  cp &#123;&#125; ../csplit/</span><br><span class="line"><span class="comment"># 指定@为替换字符串</span></span><br><span class="line">ls *.txt | xargs -I @  cp @ ../csplit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令之前先显示命令</span></span><br><span class="line">ls *.txt | xargs -t -I @  cp @ ../csplit/</span><br><span class="line">cp test1.txt ../csplit/ </span><br><span class="line">cp test2.txt ../csplit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于使用-i，只是-i有默认值，而-I没有默认值，必须要指定</span></span><br><span class="line"><span class="comment"># -i默认就是&#123;&#125;，但是使用-I一定要加上&#123;&#125;</span></span><br><span class="line">ls *.txt | xargs -i  cp &#123;&#125; ../csplit/</span><br></pre></td></tr></table></figure><p></p><p><strong>还可以使用多次替换符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给所有的文件重命名</span></span><br><span class="line"><span class="comment"># 加上后缀</span></span><br><span class="line">ls *.txt |xargs -I &#123;&#125; mv &#123;&#125; &#123;&#125;.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上前缀</span></span><br><span class="line">ls *.bak |xargs -I &#123;&#125; mv &#123;&#125; test_&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>-I(-i)</code>参数在命令需要多个参数且参数位置有限制时很适用，例如<code>cp</code>、<code>mv</code>命令</li><li><code>-I(-i)</code>指定的替换字符串用于表示<code>xargs</code>传递给命令的参数使用的位置</li><li><code>-I</code>没有默认值，必须要指定替换字符串，而<code>-i</code>有默认值为<code>{}</code>，可以不用指定</li><li>当 <code>-I</code> 与 <code>xargs</code> 结合使用，<strong>每一个参数命令都会被执行一次</strong>，正如上面的<code>ls *.txt | xargs -t -I @ cp @ ../csplit/</code>是进行了两次的cp，而不是一次全部cp</li></ul></div><hr><h3 id="t-在执行命令之前先输出命令"><a href="#t-在执行命令之前先输出命令" class="headerlink" title="-t-在执行命令之前先输出命令"></a>-t-在执行命令之前先输出命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt | xargs -t -I @  cp @ ../csplit/</span><br><span class="line"><span class="comment"># 显示会执行的命令</span></span><br><span class="line">  cp test1.txt ../csplit/ </span><br><span class="line">  cp test2.txt ../csplit/</span><br></pre></td></tr></table></figure><hr><h3 id="p-执行命令之前询问"><a href="#p-执行命令之前询问" class="headerlink" title="-p-执行命令之前询问"></a>-p-执行命令之前询问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls *.txt | xargs -p -I @  cp @ ../csplit/</span><br><span class="line"><span class="comment"># 进行询问</span></span><br><span class="line">  cp test1.txt ../csplit/ ?...y</span><br><span class="line">  cp test2.txt ../csplit/ ?...y</span><br></pre></td></tr></table></figure><hr><h3 id="L-每次读取多少行作为输入"><a href="#L-每次读取多少行作为输入" class="headerlink" title="-L-每次读取多少行作为输入"></a>-L-每次读取多少行作为输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"><span class="comment"># 测试文件 </span></span><br><span class="line">  I am test1 file</span><br><span class="line">  test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs -L 1 <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 每次读取一行作为输入</span></span><br><span class="line">  I am test1 file</span><br><span class="line">  test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs -L 2 <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 每次读取二行作为输入</span></span><br><span class="line"><span class="comment"># 两行的文本会合并</span></span><br><span class="line">  I am test1 file test2 test2</span><br><span class="line"></span><br><span class="line">cat test1.txt |xargs  <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 默认是所有行作为输入</span></span><br><span class="line">  I am test1 file test2 test2</span><br></pre></td></tr></table></figure><div class="note info"><p>注意：<code>-L</code> 和 <code>-n</code> 参数是互相排斥的</p></div><hr><h3 id="结合find命令"><a href="#结合find命令" class="headerlink" title="结合find命令"></a>结合find命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">"*.txt"</span></span><br><span class="line"><span class="comment"># find命令默认输出结果以\n进行换行</span></span><br><span class="line">  ./test1.txt</span><br><span class="line">  ./test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-print0表示在每条结果后面加上 '\0' 而不是换行</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0</span><br><span class="line">  ./test1.txt./test2.txt(base) [user@localhost xargs]$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># -print0参数刚好可以与xargs的-0参数对应</span></span><br><span class="line"><span class="comment"># -0参数表示使用\0分割参数</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0 |xargs -0 </span><br><span class="line">  ./test1.txt ./test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-d参数也能达到一样的效果</span></span><br><span class="line">find ./ -name <span class="string">"*.txt"</span> -print0 |xargs -d <span class="string">"\0"</span></span><br><span class="line">  ./test1.txt ./test2.txt</span><br></pre></td></tr></table></figure><p>指定<code>-print0</code>以及设置<code>-0</code>参数的意义在于：如果查找到的文件名中包含空格，不使用<code>-print0</code>那么<code>find</code>命令会将结果使用<code>\n</code>隔开并输出，而<code>xargs</code>对空白进行分割，换行、空格、tab都属于空白，所以会将<code>find</code>文件名分成两部分，这样会出错；而使用<code>-print0</code>结合<code>-0</code>参数后，前后都是使用<code>&#39;\0&#39;</code>分割不同的文件名，这样可以保证文件名不被分割。下面是一个示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们创建了3个日志文件, 且故意让文件名称中都含有空格</span></span><br><span class="line">[roc@roclinux ~]$ <span class="keyword">for</span>((i=0;i&lt;3;i++)); <span class="keyword">do</span> touch <span class="string">"test <span class="variable">$&#123;i&#125;</span>.log"</span>;<span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们列出创建的文件</span></span><br><span class="line">[roc@roclinux ~]$ ls -1F</span><br><span class="line"><span class="built_in">test</span> 0.log</span><br><span class="line"><span class="built_in">test</span> 1.log</span><br><span class="line"><span class="built_in">test</span> 2.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们来运行xargs命令, 发现报错了</span></span><br><span class="line"><span class="comment"># 因为xargs将test 0.log文件分割为了test和0.log文件，然后根本不存在这两个文件</span></span><br><span class="line">[roc@roclinux ~]$  find . -name <span class="string">'*.log'</span> -<span class="built_in">print</span> | xargs rm</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘1.log’: No such file or directory</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘0.log’: No such file or directory</span><br><span class="line">rm: cannot remove ‘./<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">rm: cannot remove ‘2.log’: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-print0和-0结合可以完美解决问题</span></span><br><span class="line">find . -name <span class="string">'*.log'</span> -print0 | xargs -0 rm -f</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>xargs</code> 的<code>-0</code>选项<strong>不仅可以将分隔符从默认的空格变成 NULL</strong>，还会<strong>将单引号、双引号、反斜线等统统默认为是普通字符</strong>。所以说，<strong><code>-0</code>选项特别适合处理命令参数中含有引号、空格、反斜线的情况</strong>。</p></div><hr><h3 id="结合rm命令"><a href="#结合rm命令" class="headerlink" title="结合rm命令"></a>结合rm命令</h3><p>如果一次删除的文件太多，使用<code>rm *.file</code>可能会遇到<code>Argument list too long</code>错误，这是因为<code>rm</code> 可接受的参数长度达到了极限，这其实并非 <code>rm</code>的错，而是系统限制了参数的长度，通过下面的命令可以查看到系统的参数长度限制值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统对参数长度的限制</span></span><br><span class="line">getconf ARG_MAX</span><br><span class="line">  2097152</span><br></pre></td></tr></table></figure><p></p><p>解决办法可以是：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.file'</span> -<span class="built_in">print</span> | xargs rm -rf</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><h4 id="在所有文件中查找字符串"><a href="#在所有文件中查找字符串" class="headerlink" title="在所有文件中查找字符串"></a>在所有文件中查找字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ <span class="string">"*.log"</span> |xargs grep -ri <span class="string">"test"</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/wangqiguo/p/6464234.html" target="_blank" rel="noopener">xargs命令详解，xargs与管道的区别</a></li><li><a href="http://c.biancheng.net/linux/xargs.html" target="_blank" rel="noopener">xargs命令_Linux xargs命令：一个给其他命令传递参数的过滤器</a></li><li><a href="http://www.runoob.com/linux/linux-comm-xargs.html" target="_blank" rel="noopener">Linux xargs 命令</a></li><li><a href="https://blog.csdn.net/tommy_wxie/article/details/77715203" target="_blank" rel="noopener">linux 管道传递参数xargs 用法</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf-格式化输出字符串</title>
      <link href="/posts/47162.html"/>
      <url>/posts/47162.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中进行格式化输出字符串的命令printf，除了<strong>格式化输出之外</strong>还能对其进行修饰，<strong>这些修饰包括</strong>：<code>指定输出宽度</code>、<code>填充不足位数</code>、<code>指定精度</code>、<code>使用多个格式替换符</code>、<code>对齐输出</code>、<code>输出正负值</code>等。</p></div><a id="more"></a><h2 id="printf命令简介"><a href="#printf命令简介" class="headerlink" title="printf命令简介"></a>printf命令简介</h2><p><code>printf</code>命令可以进行<strong>格式化输出字符串</strong>，这是其与<code>echo</code>命令不同的地方，也是其特征；<code>printf</code> 由 <code>POSIX</code>标准所定义，因此<strong>使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好</strong>；具体的功能包括：</p><ul><li><strong>指定输出宽度</strong></li><li><strong>填充不足位数</strong></li><li><strong>指定精度</strong></li><li><strong>使用多个格式替换符</strong></li><li><strong>对齐输出</strong></li><li><strong>输出正负值</strong></li></ul><hr><h2 id="printf命令格式"><a href="#printf命令格式" class="headerlink" title="printf命令格式"></a>printf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> %[输出最少宽度][．精度][类型] 字符或数字1 字符或数字2 ....</span><br></pre></td></tr></table></figure><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="http://showteeth.tech/posts/39761.html">echo</a>可以用来进行<strong>字符串的输出</strong>，还可以用来<strong>输出转义字符</strong>，同时还可以用来进行<strong>带颜色的文字和背景输出</strong>，看到这里不禁要问：echo已经可以进行这么多的输出，<strong>为什么这里还要学习printf命令呢？</strong>其实原因很简单：</p><ul><li>学习<code>csplit</code>时，其中的<code>-b</code>参数指定前缀时也需要使用<code>printf</code>的格式输出</li><li>使用seq命令产生序列时可以指定<code>-f</code>参数来进行格式化的输出</li></ul><p>这么多命令需要使用<code>printf</code>命令足以见得其重要性，其实<code>printf</code>的<strong>主要作用就是用来进行格式化输出</strong>，这是其区别于<code>echo</code>的最主要的特征，也是其存在的意义。在有些应用情境下，使用printf比使用echo命令更便捷：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个字符串换行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用echo</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"abc\ndef\nghi\njkl"</span></span><br><span class="line"><span class="comment"># 需要在每个字符串后面添加\n转义字符</span></span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line">  ghi</span><br><span class="line">  jkl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用printf</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line"><span class="comment"># 可以直接使用"%s\n"为所有的字符串添加相同的格式</span></span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line">  ghi</span><br><span class="line">  jkl</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="printf格式替换符"><a href="#printf格式替换符" class="headerlink" title="printf格式替换符"></a>printf格式替换符</h2><h3 id="格式替换符的作用"><a href="#格式替换符的作用" class="headerlink" title="格式替换符的作用"></a>格式替换符的作用</h3><p>前面使用了<code>&quot;%s\n&quot;</code>来对每个输出进行格式化，那么<code>&quot;%s\n&quot;</code>是什么呢，为什么能够用来进行标准化呢？</p><p><code>&quot;%s&quot;</code>相当于一个<strong>替身演员</strong>，我们使用<code>&quot;%s&quot;</code><strong>代替传入的参数</strong>，也就是说， <code>&quot;%s&quot;</code>代替了命令3中的<code>abc</code>，代替了<code>def</code>，代替了<code>ghi</code>，<strong>代替了每一个传入的参数</strong>，在我们指定的”格式”中，它代表了每一个传入的参数，所以，如果我们指定的格式为<code>&quot;%s\n&quot;</code>，当abc被当做参数传入printf命令时，printf就会把<code>&quot;%s\n&quot;</code>中的<code>%s</code>替换成<code>abc</code>，于是，abc就变成了我们指定的格式”abc\n”，最终printf输出的就是格式化后的”abc\n”，以此类推，每一段文本都被当做一个参数传入printf命令，然后按照指定的格式输出了，具体的工作机制可以使用参考下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/格式替换符.png" alt="格式替换符.png"></p><p>了解上面<strong>替身演员</strong>的作用机制之后，我们可以进行随心所欲的输出格式自定义，例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"(%s)\n"</span> <span class="string">"abc"</span> <span class="string">"def"</span>  <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line">  (abc)</span><br><span class="line">  (def)</span><br><span class="line">  (ghi)</span><br><span class="line">  (jkl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意，默认情况下，printf输出的字符不会换行，如需换行需要指定\n</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"(%s)\t"</span> <span class="string">"abc"</span> <span class="string">"def"</span>  <span class="string">"ghi"</span> <span class="string">"jkl"</span></span><br><span class="line">(abc)(def)(ghi)(jkl)(base) [user@localhost seq]</span><br></pre></td></tr></table></figure><p></p><p>而 <strong>“替身演员”只是我给<code>&quot;%s&quot;</code>起的一个外号</strong>，它的真名叫 <strong>“格式替换符”</strong>，而printf中，”格式替换符”不只有”%s”一种，<strong>“%s”代替了每一个传入的参数，并将他们转化成了”字符串类型”</strong>，<strong>针对不同的需求，我们可以设置不同的格式替换符</strong>，例如，如果需要指定<strong>浮点型</strong>，可以使用<code>%f</code>，如果需要<strong>指定整数</strong>，可以使用<code>%d</code>。</p><hr><h3 id="常用的格式替换符"><a href="#常用的格式替换符" class="headerlink" title="常用的格式替换符"></a>常用的格式替换符</h3><table><tr><th width="20%">格式替换符</th><th width="80%">说明</th></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%f</code></td><td>浮点格式（也就是我们概念中的float或者double）</td></tr><tr><td><code>%e(%E)</code></td><td>浮点格式，使用的是科学计数法，大小写e、E区别在于科学计数法的e是大写还是小写</td></tr><tr><td><code>%g(%G)</code></td><td>浮点数不显无意义的0</td></tr><tr><td><code>%d、%i</code></td><td>有符号十进制整数</td></tr><tr><td><code>%b</code></td><td>相对应的参数中包含转义字符时，可以使用此替换符进行替换，对应的转义字符会被转义</td></tr><tr><td><code>%c</code></td><td>ASCII字符，显示相对应参数的第一个字符</td></tr><tr><td><code>%o</code></td><td>不带正负号的八进制值</td></tr><tr><td><code>%u</code></td><td>不带正负号的十进制值</td></tr><tr><td><code>%x</code></td><td>不带正负号的十六进制值，使用a至f表示10至15</td></tr><tr><td><code>%X</code></td><td>不带正负号的十六进制值，使用A至F表示10至15</td></tr><tr><td><code>%%</code></td><td>表示"%"本身</td></tr></table><hr><h2 id="printf转义字符"><a href="#printf转义字符" class="headerlink" title="printf转义字符"></a>printf转义字符</h2><p>关于转义字符的内容直接参考echo命令中的转义字符，两者基本上是一样的，<a href="http://showteeth.tech/posts/39761.html">具体链接</a></p><hr><h2 id="printf格式替换符修饰信息"><a href="#printf格式替换符修饰信息" class="headerlink" title="printf格式替换符修饰信息"></a>printf格式替换符修饰信息</h2><h3 id="指定输出位数"><a href="#指定输出位数" class="headerlink" title="指定输出位数"></a>指定输出位数</h3><p><strong>使用形式</strong>：<code>&quot;m%f\n&quot;</code>，其中m表示输出的位数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认情况下，浮点会保留小数点后6位</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%1f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 如果指定位数为1，默认输出还是原始长度</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%10f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 如果指定位数为10，则会使用空格填充两个</span></span><br><span class="line">    1.000000</span><br><span class="line">    2.000000</span><br><span class="line">    3.000000</span><br><span class="line">    4.000000</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>通过上面的实例可以得出如下结论：</p><ul><li>如果指定的位数<strong>小于</strong>原始输出位数，则会<strong>保留原始长度</strong></li><li>如果指定的位数<strong>大于</strong>原始输出位数，<strong>默认会使用空格填充不足的位数</strong></li></ul></div><hr><h3 id="填充不足位数"><a href="#填充不足位数" class="headerlink" title="填充不足位数"></a>填充不足位数</h3><p><strong>使用形式</strong>：<code>&quot;0m%f\n&quot;</code>，其中m表示输出的位数，0表示不足位数使用0填充<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%10f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认在输出位数没有达到指定时，会使用空格进行填充</span></span><br><span class="line">    1.000000</span><br><span class="line">    2.000000</span><br><span class="line">    3.000000</span><br><span class="line">    4.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%010f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 可以指定使用0来填充不足的位数</span></span><br><span class="line">  001.000000</span><br><span class="line">  002.000000</span><br><span class="line">  003.000000</span><br><span class="line">  004.000000</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%010s\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 好像不会对字符串进行填充0</span></span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">          4</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>只能使用<code>0</code>或<code>空格</code>来进行填充</li><li>对字符串<code>&quot;%s&quot;</code>好像不能使用0填充</li></ul></div><hr><h3 id="指定精度"><a href="#指定精度" class="headerlink" title="指定精度"></a>指定精度</h3><p><strong>使用形式</strong>：<code>&quot;.n%f\n&quot;</code>，其中<code>.n</code>表示精度，也就是小数点后保留的位数；<code>&quot;.n%d\n&quot;</code>，如果用在整数上，会使用0填充<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%.4f\n"</span> 1 2 3 4</span><br><span class="line"><span class="comment"># 默认情况是保留六位小数</span></span><br><span class="line"><span class="comment"># 这里指定保留四位小数</span></span><br><span class="line">  1.0000</span><br><span class="line">  2.0000</span><br><span class="line">  3.0000</span><br><span class="line">  4.0000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对整数使用精度则会达到填充0的效果</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%.4d\n"</span> 1 2 3 4</span><br><span class="line">  0001</span><br><span class="line">  0002</span><br><span class="line">  0003</span><br><span class="line">  0004</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>可以和前面的指定输出位数联合使用</li><li>对整数使用精度则会达到填充0的效果</li></ul></div><p><strong>对字符串使用精度信息</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定精度为0，那么后续的字符就不会输出，只会输出前面的，</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">',%.0s'</span> &#123;1..10&#125;</span><br><span class="line">  ,,,,,,,,,,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定精度为1，那么后续的字符就只会输出一位</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">',%.1s'</span> &#123;1..10&#125;</span><br><span class="line">  ,1,2,3,4,5,6,7,8,9,1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>对字符串使用精度会<strong>设置字符串的输出长度</strong>，<strong>指定为0时使用可以输出某个序列的重复</strong></li></ul></div><hr><h3 id="使用多个格式替换符"><a href="#使用多个格式替换符" class="headerlink" title="使用多个格式替换符"></a>使用多个格式替换符</h3><p><strong>使用形式</strong>：<code>&quot;%s %s\n&quot;</code>，多个格式替换符连用，每个格式替换符代表一个参数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s\n"</span> a b c d e f</span><br><span class="line"><span class="comment"># 每两个进行一次换行</span></span><br><span class="line">  a b</span><br><span class="line">  c d</span><br><span class="line">  e f</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s%s\n"</span> a b c d e f</span><br><span class="line"><span class="comment"># 每个参数之间的间隔取决于格式替换符之间的间隔</span></span><br><span class="line">  ab</span><br><span class="line">  <span class="built_in">cd</span></span><br><span class="line">  ef</span><br></pre></td></tr></table></figure><p></p><p>如果指定的”格式”中包含<strong>两个”格式替换符”</strong>，那么printf每次进行”格式化”操作时，就会<strong>传入两个参数</strong>，然后<strong>前一个参数对应第一个替换符</strong>，<strong>后一个参数对应第二个替换符</strong>，当本次格式化操作完成以后，再传入下一波参数，具体的工作机制如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/多个格式替换符.png" alt="多个格式替换符.png"></p><hr><h3 id="对齐输出"><a href="#对齐输出" class="headerlink" title="对齐输出"></a>对齐输出</h3><p><strong>使用形式</strong>：<code>&quot;%-s&quot;</code>，<code>-</code>表示左对齐，不加表示右对齐<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s %s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># 输出上述信息得到的结果会存在错位现象</span></span><br><span class="line"><span class="comment"># 原因：第一行宽度与后面每行对应的宽度不一致</span></span><br><span class="line"><span class="comment"># 指定的话需要结合系统编码，utf-8中文是3个字节</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果 男 18 60 </span><br><span class="line">  香蕉 男 18 80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%6s %6s %4s %4s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># 输出也没有对齐</span></span><br><span class="line"><span class="comment"># 第二行的男字节宽度为3，会填补3个空格</span></span><br><span class="line"><span class="comment"># 默认是右对齐</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果    男   18   60 </span><br><span class="line">  香蕉    男   18   80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-4s \n"</span> 姓名 性别 年龄 体重 苹果 男 18 60 香蕉 男 18 80</span><br><span class="line"><span class="comment"># "-"表示左对齐</span></span><br><span class="line"><span class="comment"># 不加的时候表示右对齐</span></span><br><span class="line">  姓名 性别 年龄 体重 </span><br><span class="line">  苹果 男    18   60   </span><br><span class="line">  香蕉 男    18   80</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="输出正负值"><a href="#输出正负值" class="headerlink" title="输出正负值"></a>输出正负值</h3><p><strong>使用形式</strong>：<code>&quot;%+d&quot;</code>，<code>+</code>表示在正值前面加上<code>+</code>符号<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-4d \n"</span> 苹果 男 18 60 香蕉 男 18 -80</span><br><span class="line">苹果 男    18   60   </span><br><span class="line">香蕉 男    18   -80</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-6s %-6s %-4s %-+4d \n"</span> 苹果 男 18 60 香蕉 男 18 -80</span><br><span class="line"><span class="comment"># 加了+使得整数会显示+，可以个负数的输出保持对齐</span></span><br><span class="line">苹果 男    18   +60  </span><br><span class="line">香蕉 男    18   -80</span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/1411" target="_blank" rel="noopener">printf命令详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/48666563" target="_blank" rel="noopener">C语言 printf详解</a></li><li><a href="http://man.linuxde.net/printf" target="_blank" rel="noopener">printf命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seq-产生固定步长整数</title>
      <link href="/posts/1152.html"/>
      <url>/posts/1152.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中常用的用来产生等间隔序列的命令<code>seq</code>，主要参数包括<code>-w</code>、<code>-f</code>、<code>-s</code>。</p></div><a id="more"></a><h2 id="seq命令简介"><a href="#seq命令简介" class="headerlink" title="seq命令简介"></a>seq命令简介</h2><p><code>seq</code>命令可以<strong>用来产生从指定起始位点到终止位点固定步长的数字序列</strong>，这个序列<strong>可以是整数也可以是小数</strong>，在输出结果时，可以进行<strong>等宽输出</strong>、<strong>格式化输出</strong>、<strong>指定分隔符输出</strong>。</p><hr><h2 id="seq命令格式"><a href="#seq命令格式" class="headerlink" title="seq命令格式"></a>seq命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><hr><h2 id="seq命令参数"><a href="#seq命令参数" class="headerlink" title="seq命令参数"></a>seq命令参数</h2><table><thead><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr></thead><tbody><tr><td><code>-f</code></td><td><code>--format=FORMAT</code></td><td>使用printf 样式的浮点格式来进行格式化输出，不能和<code>-w</code>一起用</td></tr><tr><td><code>-s</code></td><td><code>--separator=STRING</code></td><td>指定输出分隔符，默认是换行符<code>\n</code></td></tr><tr><td><code>-w</code></td><td><code>--equal-width</code></td><td>输出等宽的结果，默认使用0来补全，不能和<code>-f</code>一起用</td></tr></tbody></table><hr><h2 id="seq使用实例"><a href="#seq使用实例" class="headerlink" title="seq使用实例"></a>seq使用实例</h2><h3 id="seq默认行为"><a href="#seq默认行为" class="headerlink" title="seq默认行为"></a>seq默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5</span><br><span class="line"><span class="comment"># 如果给定两个数字，则一个为起始，一个为终止，步长为1</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">seq 2 1</span><br><span class="line"><span class="comment"># 没有输出结果，步长还是默认为1</span></span><br><span class="line"><span class="comment"># 即使起始大于终止</span></span><br><span class="line"></span><br><span class="line">seq 5</span><br><span class="line"><span class="comment"># 如果只指定一个数字，则这个数字是终止数字，起始和步长都为1</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">seq 1 0.5 2</span><br><span class="line"><span class="comment"># 步长可以为小数</span></span><br><span class="line"><span class="comment"># 起始和终止都可以为小数</span></span><br><span class="line">  1.0</span><br><span class="line">  1.5</span><br><span class="line">  2.0</span><br></pre></td></tr></table></figure><p>可以设置负的<code>INCREMENT</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 2 -1 1</span><br><span class="line"><span class="comment"># 生成递减的序列</span></span><br><span class="line">  2</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="s-设置序列输出间隔符"><a href="#s-设置序列输出间隔符" class="headerlink" title="-s-设置序列输出间隔符"></a>-s-设置序列输出间隔符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq 1 4</span><br><span class="line"><span class="comment"># 默认是通过换行符隔开</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line"></span><br><span class="line">seq -s <span class="string">','</span> 1 4</span><br><span class="line"><span class="comment"># 指定分隔符为逗号</span></span><br><span class="line">  1,2,3,4</span><br></pre></td></tr></table></figure><p>如果想<strong>要指定带有特殊意义的字符作为分隔符，就需要结合<code>echo</code>输出转义字符</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq -s <span class="string">"\t"</span> 1 4</span><br><span class="line"><span class="comment"># 如果直接指定\t，输出结果不能达到理想的效果</span></span><br><span class="line">  1\t2\t3\t4</span><br><span class="line"></span><br><span class="line">seq -s <span class="string">"<span class="variable">$(echo -e "\t")</span>"</span> 1 4</span><br><span class="line"><span class="comment"># 使用echo -e输出结果进行指定</span></span><br><span class="line">  1234</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>指定<strong>转义字符</strong>时需要<strong>借助<code>echo -e</code>进行输出</strong>，直接指定会出错</p></div><hr><h3 id="w-设置等宽输出"><a href="#w-设置等宽输出" class="headerlink" title="-w-设置等宽输出"></a>-w-设置等宽输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">seq 5 10</span><br><span class="line"><span class="comment"># 默认行为</span></span><br><span class="line">  5</span><br><span class="line">  6</span><br><span class="line">  7</span><br><span class="line">  8</span><br><span class="line">  9</span><br><span class="line">  10</span><br><span class="line"></span><br><span class="line">seq -w 5 10</span><br><span class="line"><span class="comment"># 设置输出的序列等宽</span></span><br><span class="line"><span class="comment"># 宽度由最大数字的宽度决定</span></span><br><span class="line">  05</span><br><span class="line">  06</span><br><span class="line">  07</span><br><span class="line">  08</span><br><span class="line">  09</span><br><span class="line">  10</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-w</code>参数不能和<code>-f</code>参数连用</p></div><hr><h3 id="f-进行格式化输出"><a href="#f-进行格式化输出" class="headerlink" title="-f-进行格式化输出"></a>-f-进行格式化输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5</span><br><span class="line"><span class="comment"># 默认情况</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">seq -f <span class="string">"%g"</span> 1 5</span><br><span class="line"><span class="comment"># %g表示浮点数不显无意义的零"0"</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而真正的浮点数</span></span><br><span class="line">seq -f <span class="string">"%f"</span> 1 5</span><br><span class="line"><span class="comment"># 后面有很多没有意义的0</span></span><br><span class="line">  1.000000</span><br><span class="line">  2.000000</span><br><span class="line">  3.000000</span><br><span class="line">  4.000000</span><br><span class="line">  5.000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 科学计数法</span></span><br><span class="line">seq -f <span class="string">"%e"</span> 1 5</span><br><span class="line">  1.000000e+00</span><br><span class="line">  2.000000e+00</span><br><span class="line">  3.000000e+00</span><br><span class="line">  4.000000e+00</span><br><span class="line">  5.000000e+00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出位宽</span></span><br><span class="line">seq -f <span class="string">"%3g"</span> 5 10</span><br><span class="line"><span class="comment"># 输出的位宽为3，宽度不足3的使用空格填充</span></span><br><span class="line">    5</span><br><span class="line">    6</span><br><span class="line">    7</span><br><span class="line">    8</span><br><span class="line">    9</span><br><span class="line">  10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0填充位宽不足的</span></span><br><span class="line">seq -f <span class="string">"%03g"</span> 5 10</span><br><span class="line"><span class="comment"># 这个如果将位宽设置为2，就和-w参数相同</span></span><br><span class="line"><span class="comment"># 但是-w参数可以自动识别最大宽度</span></span><br><span class="line">  005</span><br><span class="line">  006</span><br><span class="line">  007</span><br><span class="line">  008</span><br><span class="line">  009</span><br><span class="line">  010</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加前缀输出</span></span><br><span class="line">seq -f <span class="string">"dir%g"</span> 1 5</span><br><span class="line"><span class="comment"># 添加前缀为dir</span></span><br><span class="line">  dir1</span><br><span class="line">  dir2</span><br><span class="line">  dir3</span><br><span class="line">  dir4</span><br><span class="line">  dir5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合其他命令使用</span></span><br><span class="line">mkdir $(seq -f <span class="string">'dir%g'</span> 1 5)</span><br></pre></td></tr></table></figure><div class="note info"><p>更多关于<code>printf</code>格式化输出的内容请参考<a href="http://showteeth.tech/posts/47162.html">这篇文章</a></p></div><hr><h3 id="其他可以得到指定步长整数的方法"><a href="#其他可以得到指定步长整数的方法" class="headerlink" title="其他可以得到指定步长整数的方法"></a>其他可以得到指定步长整数的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 使用花括号进行拓展</span></span><br><span class="line"><span class="comment"># 默认步长为1 </span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  4</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 指定步长为2</span></span><br><span class="line">  1</span><br><span class="line">  3 </span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..f..2&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 还可以对字母进行指定步长输出</span></span><br><span class="line">  a</span><br><span class="line">  c</span><br><span class="line">  e</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/128" target="_blank" rel="noopener">seq命令详解</a></li><li><a href="http://man.linuxde.net/seq" target="_blank" rel="noopener">seq命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shuf-随机打乱文件</title>
      <link href="/posts/50731.html"/>
      <url>/posts/50731.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了linux中<strong>对文件以及命令行输入进行随机打乱的命令<code>shuf</code></strong>，主要参数包括<code>-e</code>、<code>-i</code>、<code>-n</code>、<code>-o</code>、<code>-r</code>等。</p></div><a id="more"></a><h2 id="shuf简介"><a href="#shuf简介" class="headerlink" title="shuf简介"></a>shuf简介</h2><p><code>shuf</code>命令可以<strong>对文件或者命令行输入进行随机打乱并输出到标准输出或者指定的文件中</strong>，还<strong>可以指定<code>shuf</code>的随机模式(有放回地抽取)</strong></p><hr><h2 id="shuf命令格式"><a href="#shuf命令格式" class="headerlink" title="shuf命令格式"></a>shuf命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: shuf [OPTION]... [FILE]</span><br><span class="line">  or:  shuf -e [OPTION]... [ARG]...</span><br><span class="line">  or:  shuf -i LO-HI [OPTION]...</span><br><span class="line"></span><br><span class="line">Write a random permutation of the input lines to standard output.</span><br></pre></td></tr></table></figure><hr><h2 id="shuf参数"><a href="#shuf参数" class="headerlink" title="shuf参数"></a>shuf参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-e</code></td><td><code>--echo</code></td><td>将参数作为输入信息进行随机打乱</td></tr><tr><td><code>-i</code></td><td><code>--input-range=LO-HI</code></td><td>在特定范围内生成随机数</td></tr><tr><td><code>-n</code></td><td><code>--head-count=COUNT</code></td><td>最大输出行数</td></tr><tr><td><code>-o</code></td><td><code>--output=FILE</code></td><td>指定输出文件</td></tr><tr><td></td><td><code>--random-source=FILE</code></td><td>get random bytes from FILE</td></tr><tr><td><code>-r</code></td><td><code>--repeat</code></td><td>有放回地抽取，需要结合<code>-n</code>参数一同使用</td></tr><tr><td><code>-z</code></td><td><code>--zero-terminated</code></td><td>以0 结束行而非换行符</td></tr></table><hr><h2 id="shuf使用实例"><a href="#shuf使用实例" class="headerlink" title="shuf使用实例"></a>shuf使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line6</span><br><span class="line">  line7</span><br><span class="line">  line8</span><br><span class="line">  line9</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="shuf默认行为"><a href="#shuf默认行为" class="headerlink" title="shuf默认行为"></a>shuf默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shuf test.txt</span><br><span class="line"><span class="comment"># 将test.txt随机打乱 </span></span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line7</span><br><span class="line">  line5</span><br><span class="line">  line10</span><br><span class="line">  line6</span><br><span class="line">  line8</span><br><span class="line">  line3</span><br><span class="line">  line4</span><br><span class="line">  line1</span><br></pre></td></tr></table></figure><hr><h3 id="e-将参数作为输入信息进行随机打乱"><a href="#e-将参数作为输入信息进行随机打乱" class="headerlink" title="-e-将参数作为输入信息进行随机打乱"></a>-e-将参数作为输入信息进行随机打乱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shuf -e <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"mbc"</span></span><br><span class="line">  mbc</span><br><span class="line">  abc</span><br><span class="line">  def</span><br><span class="line"></span><br><span class="line">a=badad</span><br><span class="line">b=asdf</span><br><span class="line">c=sadfa</span><br><span class="line">shuf -e <span class="variable">$a</span> <span class="variable">$b</span> <span class="variable">$c</span></span><br><span class="line"><span class="comment"># 变量拓展</span></span><br><span class="line">  badad</span><br><span class="line">  sadfa</span><br><span class="line">  asdf</span><br></pre></td></tr></table></figure><hr><h3 id="i-在指定范围内生成随机数"><a href="#i-在指定范围内生成随机数" class="headerlink" title="-i-在指定范围内生成随机数"></a>-i-在指定范围内生成随机数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成1-10范围内的随机数</span></span><br><span class="line"><span class="comment"># 包括1和10</span></span><br><span class="line">shuf -i 1-10</span><br><span class="line">  3</span><br><span class="line">  7</span><br><span class="line">  4</span><br><span class="line">  6</span><br><span class="line">  1</span><br><span class="line">  9</span><br><span class="line">  2</span><br><span class="line">  5</span><br><span class="line">  10</span><br><span class="line">  8</span><br></pre></td></tr></table></figure><hr><h3 id="n-最大输出行数"><a href="#n-最大输出行数" class="headerlink" title="-n-最大输出行数"></a>-n-最大输出行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出随机打乱后结果的其中3行</span></span><br><span class="line">shuf -n 3 test.txt</span><br><span class="line">  line4</span><br><span class="line">  line5</span><br><span class="line">  line9</span><br></pre></td></tr></table></figure><hr><h3 id="o-指定输出文件"><a href="#o-指定输出文件" class="headerlink" title="-o-指定输出文件"></a>-o-指定输出文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机打乱并将结果输出到shuf.txt</span></span><br><span class="line">shuf test.txt -o shuf.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">cat shuf.txt </span><br><span class="line">  line7</span><br><span class="line">  line1</span><br><span class="line">  line4</span><br><span class="line">  line6</span><br><span class="line">  line2</span><br><span class="line">  line9</span><br><span class="line">  line3</span><br><span class="line">  line5</span><br><span class="line">  line8</span><br><span class="line">  line10</span><br></pre></td></tr></table></figure><hr><h3 id="r-有放回地抽取"><a href="#r-有放回地抽取" class="headerlink" title="-r-有放回地抽取"></a>-r-有放回地抽取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有放回的抽取15行结果</span></span><br><span class="line">shuf -n 15 -r test.txt </span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line6</span><br><span class="line">  line9</span><br><span class="line">  line8</span><br><span class="line">  line1</span><br><span class="line">  line6</span><br><span class="line">  line1</span><br><span class="line">  line2</span><br><span class="line">  line1</span><br><span class="line">  line10</span><br><span class="line">  line7</span><br><span class="line">  line10</span><br><span class="line">  line10</span><br><span class="line">  line8</span><br></pre></td></tr></table></figure><div class="note info"><p><strong><code>-r</code>参数一定要结合<code>-n</code>参数一同使用</strong>，不然会一直运行有放回地抽取，<strong>相当于死循环</strong>，一直输出</p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.cn/article-9635-1.html" target="_blank" rel="noopener">给初学者看的 shuf 命令教程</a></li><li><a href="https://www.howtoforge.com/linux-shuf-command/" target="_blank" rel="noopener">Linux shuf Command Tutorial for Beginners (with Examples)</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell中的float问题</title>
      <link href="/posts/61435.html"/>
      <url>/posts/61435.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了shell中<strong>处理浮点比较</strong>相关的内容，主要学习了<strong>使用<code>awk</code>以及<code>bc</code>命令来进行浮点比较和运算</strong>，此前还有一篇<a href="http://showteeth.tech/posts/28430.html">相关的文章</a></p></div><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在编写shell脚本的时候<strong>发现shell中使用浮点的比较</strong>会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 0.1 -lt 1 ]];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  -bash: [[: 0.1: syntax error: invalid arithmetic operator (error token is <span class="string">".1"</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>shell是不支持浮点的，不管是浮点的运算还是浮点的比较</p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="使用awk"><a href="#使用awk" class="headerlink" title="使用awk"></a>使用awk</h3><p>awk是支持浮点，包括运算以及比较：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点运算</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2/3&#125;'</span></span><br><span class="line">  0.666667</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&lt;3&#125;'</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br><span class="line">awk <span class="string">'BEGIN&#123;print 2&gt;3&#125;'</span></span><br><span class="line"><span class="comment"># 假则不输出结果</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="使用bc"><a href="#使用bc" class="headerlink" title="使用bc"></a>使用bc</h3><p>bc是shell中支持浮点相关方法的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点计算，如果结果小于0，会省略0，这里使用方法加上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br><span class="line"><span class="comment"># 输出结果，保留两位小数</span></span><br><span class="line">  0.66</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点的比较</span></span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &gt;= 0.3"</span></span><br><span class="line"><span class="comment"># 假值返回0</span></span><br><span class="line">  0</span><br><span class="line">bc &lt;&lt;&lt; <span class="string">"0.2 &lt;= 0.3"</span></span><br><span class="line"><span class="comment"># 真值返回1</span></span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>注意<code>&lt;&lt;&lt;</code>、<code>&lt;&lt;</code>、<code>&lt;</code>的区别</strong>：</p><ul><li><code>&lt;</code>：表示从文件file中读取</li><li><code>&lt;&lt;</code>：表示从命令行读取到指定的结束字符</li><li><code>&lt;&lt;&lt;</code>：读取后面紧接的字符串</li><li>具体的用法实例参考<a href="http://showteeth.tech/posts/55603.html">文章</a><br><br></li></ul><p>关于浮点运算可以参考之前的<a href="http://showteeth.tech/posts/28430.html">文章</a></p></div><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/2424770/floating-point-comparison-in-shell-script" target="_blank" rel="noopener">Floating Point Comparison in Shell Script</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据竞赛Top解决方案开源整理</title>
      <link href="/posts/49396.html"/>
      <url>/posts/49396.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了机器学习中一些竞赛获奖者的经验总结或者代码(讲解)。</p></div><a id="more"></a><h2 id="纯数据竞赛"><a href="#纯数据竞赛" class="headerlink" title="纯数据竞赛"></a>纯数据竞赛</h2><h3 id="2018科大讯飞AI营销算法大赛"><a href="#2018科大讯飞AI营销算法大赛" class="headerlink" title="2018科大讯飞AI营销算法大赛"></a>2018科大讯飞AI营销算法大赛</h3><ul><li><strong>Rank1</strong>：<a href="https://zhuanlan.zhihu.com/p/47807544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47807544</a></li></ul><hr><h3 id="2018-IJCAI-阿里妈妈搜索广告转化预测"><a href="#2018-IJCAI-阿里妈妈搜索广告转化预测" class="headerlink" title="2018 IJCAI 阿里妈妈搜索广告转化预测"></a>2018 IJCAI 阿里妈妈搜索广告转化预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/plantsgo/ijcai-2018" target="_blank" rel="noopener">https://github.com/plantsgo/ijcai-2018</a></li><li><strong>Rank2</strong>：<ul><li><a href="https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution" target="_blank" rel="noopener">https://github.com/YouChouNoBB/ijcai-18-top2-single-mole-solution</a></li><li><a href="https://blog.csdn.net/Bryan__/article/details/80600189" target="_blank" rel="noopener">https://blog.csdn.net/Bryan__/article/details/80600189</a></li></ul></li><li><strong>Rank3</strong>: <a href="https://github.com/luoda888/2018-IJCAI-top3" target="_blank" rel="noopener">https://github.com/luoda888/2018-IJCAI-top3</a></li><li><strong>Rank8</strong>: <a href="https://github.com/fanfanda/ijcai_2018" target="_blank" rel="noopener">https://github.com/fanfanda/ijcai_2018</a></li><li><strong>Rank8</strong>: <a href="https://github.com/Gene20/IJCAI-18" target="_blank" rel="noopener">https://github.com/Gene20/IJCAI-18</a></li><li><strong>Rank9（第一赛季）</strong>：<a href="https://github.com/yuxiaowww/IJCAI-18-TIANCHI" target="_blank" rel="noopener">https://github.com/yuxiaowww/IJCAI-18-TIANCHI</a></li><li><strong>Rank29</strong>: <a href="https://github.com/bettenW/IJCAI18_Tianchi_Rank29" target="_blank" rel="noopener">https://github.com/bettenW/IJCAI18_Tianchi_Rank29</a></li><li><strong>Rank41</strong>: <a href="https://github.com/cmlaughing/IJCAI-18" target="_blank" rel="noopener">https://github.com/cmlaughing/IJCAI-18</a></li><li><strong>Rank48</strong>: <a href="https://github.com/YunaQiu/IJCAI-18alimama" target="_blank" rel="noopener">https://github.com/YunaQiu/IJCAI-18alimama</a></li><li><strong>Rank53</strong>: <a href="https://github.com/altmanWang/IJCAI-18-CVR" target="_blank" rel="noopener">https://github.com/altmanWang/IJCAI-18-CVR</a></li><li><strong>Rank60</strong>: <a href="https://github.com/Chenyaorui/ijcai_2018" target="_blank" rel="noopener">https://github.com/Chenyaorui/ijcai_2018</a></li><li><strong>Rank81</strong>: <a href="https://github.com/wzp123456/IJCAI_18" target="_blank" rel="noopener">https://github.com/wzp123456/IJCAI_18</a></li><li><strong>Rank94</strong>: <a href="https://github.com/Yangtze121/-IJCAI-18-" target="_blank" rel="noopener">https://github.com/Yangtze121/-IJCAI-18-</a></li></ul><hr><h3 id="2018腾讯广告算法大赛"><a href="#2018腾讯广告算法大赛" class="headerlink" title="2018腾讯广告算法大赛"></a>2018腾讯广告算法大赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/DiligentPanda/Tencent_Ads_Algo_2018" target="_blank" rel="noopener">https://github.com/DiligentPanda/Tencent_Ads_Algo_2018</a></li><li><strong>Rank6</strong>: <a href="https://github.com/nzc/tencent-contest" target="_blank" rel="noopener">https://github.com/nzc/tencent-contest</a></li><li><strong>Rank7</strong>: <a href="https://github.com/guoday/Tencent2018_Lookalike_Rank7th" target="_blank" rel="noopener">https://github.com/guoday/Tencent2018_Lookalike_Rank7th</a></li><li><strong>Rank9</strong>: <a href="https://github.com/ouwenjie03/tencent-ad-game" target="_blank" rel="noopener">https://github.com/ouwenjie03/tencent-ad-game</a></li><li><strong>Rank10</strong>: <a href="https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th" target="_blank" rel="noopener">https://github.com/keyunluo/Tencent2018_Lookalike_Rank10th</a></li><li><strong>rank10（初赛）</strong>: <a href="https://github.com/ShawnyXiao/2018-Tencent-Lookalike" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-Tencent-Lookalike</a></li><li><strong>Rank11</strong>:<ul><li><a href="https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest" target="_blank" rel="noopener">https://github.com/liupengsay/2018-Tencent-social-advertising-algorithm-contest</a></li><li><a href="https://my.oschina.net/xtzggbmkk/blog/1865680" target="_blank" rel="noopener">https://my.oschina.net/xtzggbmkk/blog/1865680</a></li></ul></li><li><strong>Rank26</strong>: <a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="noopener">https://github.com/zsyandjyhouse/TencentAD_contest</a></li><li><strong>Rank33</strong>: <a href="https://github.com/John-Yao/Tencent_Social_Ads2018" target="_blank" rel="noopener">https://github.com/John-Yao/Tencent_Social_Ads2018</a></li><li><strong>Rank69</strong>: <a href="https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest" target="_blank" rel="noopener">https://github.com/BladeCoda/Tencent2018_Final_Phrase_Prest</a></li></ul><hr><h3 id="2018高校大数据挑战赛-快手活跃用户预测"><a href="#2018高校大数据挑战赛-快手活跃用户预测" class="headerlink" title="2018高校大数据挑战赛-快手活跃用户预测"></a>2018高校大数据挑战赛-快手活跃用户预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://github.com/drop-out/RNN-Active-User-Forecast" target="_blank" rel="noopener">https://github.com/drop-out/RNN-Active-User-Forecast</a></li><li><a href="https://zhuanlan.zhihu.com/p/42622063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42622063</a></li></ul></li><li><strong>Rank4</strong>: <a href="https://github.com/chantcalf/2018-Rank4-" target="_blank" rel="noopener">https://github.com/chantcalf/2018-Rank4-</a></li><li><strong>Rank13(初赛 a榜rank2 b榜rank5)</strong>: <a href="https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions" target="_blank" rel="noopener">https://github.com/luoda888/2018-KUAISHOU-TSINGHUA-Top13-Solutions</a></li><li><strong>Rank15</strong>: <a href="https://github.com/sunwantong/Kuaishou-Active-User" target="_blank" rel="noopener">https://github.com/sunwantong/Kuaishou-Active-User</a></li><li><strong>Rank20</strong>: <a href="https://github.com/bigzhao/Kuaishou_2018_rank20th" target="_blank" rel="noopener">https://github.com/bigzhao/Kuaishou_2018_rank20th</a></li><li><strong>Rank28(初赛 a榜rank1 b榜rank2)</strong>：<ul><li><a href="https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-" target="_blank" rel="noopener">https://github.com/YangKing0834131/2018-KUAISHOU-TSINGHUA-Top28-Solutions-</a></li><li><a href="https://github.com/FNo0/2018-KUAISHOU-Top28" target="_blank" rel="noopener">https://github.com/FNo0/2018-KUAISHOU-Top28</a></li></ul></li></ul><hr><h3 id="2018JDATA-用户购买时间预测"><a href="#2018JDATA-用户购买时间预测" class="headerlink" title="2018JDATA 用户购买时间预测"></a>2018JDATA 用户购买时间预测</h3><ul><li><strong>Rank9</strong>：<a href="https://zhuanlan.zhihu.com/p/45141799" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45141799</a></li></ul><hr><h3 id="2018-DF风机叶片开裂预警"><a href="#2018-DF风机叶片开裂预警" class="headerlink" title="2018 DF风机叶片开裂预警"></a>2018 DF风机叶片开裂预警</h3><ul><li><strong>Rank2</strong>：<a href="https://github.com/SY575/DF-Early-warning-of-the-wind-power-system" target="_blank" rel="noopener">https://github.com/SY575/DF-Early-warning-of-the-wind-power-system</a></li></ul><hr><h3 id="2018-DF光伏发电量预测"><a href="#2018-DF光伏发电量预测" class="headerlink" title="2018 DF光伏发电量预测"></a>2018 DF光伏发电量预测</h3><ul><li><strong>Rank1</strong>：<ul><li><a href="https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44755488?utm_source=qq&amp;utm_medium=social&amp;utm_oi=623925402599559168</a></li><li><a href="https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Yix0xVp2SiqaAcuS6Q049g</a></li></ul></li></ul><hr><h3 id="AI全球挑战者大赛-违约用户风险预测"><a href="#AI全球挑战者大赛-违约用户风险预测" class="headerlink" title="AI全球挑战者大赛-违约用户风险预测"></a>AI全球挑战者大赛-违约用户风险预测</h3><ul><li><strong>Rank1</strong>：<a href="https://github.com/chenkkkk/User-loan-risk-prediction" target="_blank" rel="noopener">https://github.com/chenkkkk/User-loan-risk-prediction</a></li></ul><hr><h3 id="2016融360-用户贷款风险预测"><a href="#2016融360-用户贷款风险预测" class="headerlink" title="2016融360-用户贷款风险预测"></a>2016融360-用户贷款风险预测</h3><ul><li><strong>Rank7</strong>：<a href="https://github.com/hczheng/Rong360" target="_blank" rel="noopener">https://github.com/hczheng/Rong360</a></li></ul><hr><h3 id="2016-CCF-020优惠券使用预测"><a href="#2016-CCF-020优惠券使用预测" class="headerlink" title="2016 CCF-020优惠券使用预测"></a>2016 CCF-020优惠券使用预测</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="noopener">https://github.com/wepe/O2O-Coupon-Usage-Forecast</a></li></ul><hr><h3 id="2016-ccf-农产品价格预测"><a href="#2016-ccf-农产品价格预测" class="headerlink" title="2016 ccf-农产品价格预测"></a>2016 ccf-农产品价格预测</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/xing89qs/CCF_Product" target="_blank" rel="noopener">https://github.com/xing89qs/CCF_Product</a></li><li><strong>Rank35</strong>: <a href="https://github.com/wqlin/ccf-price-prediction" target="_blank" rel="noopener">https://github.com/wqlin/ccf-price-prediction</a></li></ul><hr><h3 id="2016-ccf-客户用电异常"><a href="#2016-ccf-客户用电异常" class="headerlink" title="2016 ccf-客户用电异常"></a>2016 ccf-客户用电异常</h3><ul><li><strong>Rank4</strong>: <a href="https://github.com/AbnerYang/2016CCF-StateGrid" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-StateGrid</a></li></ul><hr><h3 id="2016-ccf-搜狗的用户画像比赛"><a href="#2016-ccf-搜狗的用户画像比赛" class="headerlink" title="2016 ccf-搜狗的用户画像比赛"></a>2016 ccf-搜狗的用户画像比赛</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/hengchao0248/ccf2016_sougou" target="_blank" rel="noopener">https://github.com/hengchao0248/ccf2016_sougou</a></li><li><strong>Rank3</strong>: <a href="https://github.com/AbnerYang/2016CCF-SouGou" target="_blank" rel="noopener">https://github.com/AbnerYang/2016CCF-SouGou</a></li><li><strong>Rank5</strong>:<ul><li><a href="https://github.com/dhdsjy/2016_CCFsougou" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou</a></li><li><a href="https://github.com/dhdsjy/2016_CCFsougou2" target="_blank" rel="noopener">https://github.com/dhdsjy/2016_CCFsougou2</a></li><li><a href="https://github.com/prozhuchen/2016CCF-sougou" target="_blank" rel="noopener">https://github.com/prozhuchen/2016CCF-sougou</a></li><li><a href="https://github.com/coderSkyChen/2016CCF_BDCI_Sougou" target="_blank" rel="noopener">https://github.com/coderSkyChen/2016CCF_BDCI_Sougou</a></li></ul></li></ul><hr><h3 id="2016-ccf-联通的用户轨迹"><a href="#2016-ccf-联通的用户轨迹" class="headerlink" title="2016 ccf-联通的用户轨迹"></a>2016 ccf-联通的用户轨迹</h3><ul><li><strong>RankX</strong>: <a href="https://github.com/xuguanggen/2016CCF-unicom" target="_blank" rel="noopener">https://github.com/xuguanggen/2016CCF-unicom</a></li></ul><hr><h3 id="2016-ccf-Human-or-Robots"><a href="#2016-ccf-Human-or-Robots" class="headerlink" title="2016 ccf-Human or Robots"></a>2016 ccf-Human or Robots</h3><ul><li><strong>Rank6</strong>: <a href="https://github.com/pickou/ccf_human_or_robot" target="_blank" rel="noopener">https://github.com/pickou/ccf_human_or_robot</a></li></ul><hr><h3 id="菜鸟-需求预测与分仓规划"><a href="#菜鸟-需求预测与分仓规划" class="headerlink" title="菜鸟-需求预测与分仓规划"></a>菜鸟-需求预测与分仓规划</h3><ul><li><strong>Rank6</strong>:<a href="https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning" target="_blank" rel="noopener">https://github.com/wepe/CaiNiao-DemandForecast-StoragePlaning</a></li><li><strong>Rank10</strong>: <a href="https://github.com/xing89qs/TianChi_CaiNiao_Season2" target="_blank" rel="noopener">https://github.com/xing89qs/TianChi_CaiNiao_Season2</a></li></ul><hr><p><br></p><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="2018-DC达观-文本智能处理挑战"><a href="#2018-DC达观-文本智能处理挑战" class="headerlink" title="2018 DC达观-文本智能处理挑战"></a>2018 DC达观-文本智能处理挑战</h3><ul><li><strong>Rank1</strong>: <a href="https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess" target="_blank" rel="noopener">https://github.com/ShawnyXiao/2018-DC-DataGrand-TextIntelProcess</a></li><li><strong>Rank4</strong>: <a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li><li><strong>Rank10</strong>: <a href="https://github.com/moneyDboat/data_grand" target="_blank" rel="noopener">https://github.com/moneyDboat/data_grand</a></li><li><strong>Rank18</strong>: <a href="https://github.com/nlpjoe/daguan-classify-2018" target="_blank" rel="noopener">https://github.com/nlpjoe/daguan-classify-2018</a></li><li><strong>RankX</strong>: <a href="https://github.com/yanqiangmiffy/daguan" target="_blank" rel="noopener">https://github.com/yanqiangmiffy/daguan</a></li></ul><hr><h3 id="智能客服问题相似度算法设计——第三届魔镜杯大赛"><a href="#智能客服问题相似度算法设计——第三届魔镜杯大赛" class="headerlink" title="智能客服问题相似度算法设计——第三届魔镜杯大赛"></a>智能客服问题相似度算法设计——第三届魔镜杯大赛</h3><ul><li><strong>rank6</strong>：<a href="https://github.com/qrfaction/paipaidai" target="_blank" rel="noopener">https://github.com/qrfaction/paipaidai</a></li><li><strong>rank12</strong>：<a href="https://www.jianshu.com/p/827dd447daf9" target="_blank" rel="noopener">https://www.jianshu.com/p/827dd447daf9</a> <a href="https://github.com/LittletreeZou/Question-Pairs-Matching" target="_blank" rel="noopener">https://github.com/LittletreeZou/Question-Pairs-Matching</a></li><li><strong>Rank16</strong>：<a href="https://github.com/guoday/PaiPaiDai2018_rank16" target="_blank" rel="noopener">https://github.com/guoday/PaiPaiDai2018_rank16</a></li><li><strong>Rank29</strong>: <a href="https://github.com/wangjiaxin24/daguan_NLP" target="_blank" rel="noopener">https://github.com/wangjiaxin24/daguan_NLP</a></li></ul><hr><h3 id="2018JD-Dialog-Challenge-任务导向型对话系统挑战赛"><a href="#2018JD-Dialog-Challenge-任务导向型对话系统挑战赛" class="headerlink" title="2018JD Dialog Challenge 任务导向型对话系统挑战赛"></a>2018JD Dialog Challenge 任务导向型对话系统挑战赛</h3><ul><li><strong>Rank3</strong>: <a href="https://github.com/zengbin93/jddc_solution_4th" target="_blank" rel="noopener">https://github.com/zengbin93/jddc_solution_4th</a></li></ul><hr><h3 id="2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛"><a href="#2018CIKM-AnalytiCup-–-阿里小蜜机器人跨语言短文本匹配算法竞赛" class="headerlink" title="2018CIKM AnalytiCup  – 阿里小蜜机器人跨语言短文本匹配算法竞赛"></a>2018CIKM AnalytiCup – 阿里小蜜机器人跨语言短文本匹配算法竞赛</h3><ul><li><strong>Rank2</strong>: <a href="https://github.com/zake7749/Closer" target="_blank" rel="noopener">https://github.com/zake7749/Closer</a></li><li><strong>Rank12</strong>：<a href="https://github.com/Leputa/CIKM-AnalytiCup-2018" target="_blank" rel="noopener">https://github.com/Leputa/CIKM-AnalytiCup-2018</a></li><li><strong>Rank18</strong>: <a href="https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018" target="_blank" rel="noopener">https://github.com/VincentChen525/Tianchi/tree/master/CIKM%20AnalytiCup%202018</a></li></ul><hr><p><br></p><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h3 id="Kaggle-TGS"><a href="#Kaggle-TGS" class="headerlink" title="Kaggle-TGS"></a>Kaggle-TGS</h3><ul><li><strong>Rank56</strong>：<a href="https://github.com/Gary-Deeplearning/TGS-Sal" target="_blank" rel="noopener">https://github.com/Gary-Deeplearning/TGS-Sal</a></li></ul><hr><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><h3 id="经验文章"><a href="#经验文章" class="headerlink" title="经验文章"></a>经验文章</h3><ul><li><p><strong>介绍featexp 一个帮助理解特征的工具包</strong>：<a href="http://www.sohu.com/a/273552971_129720" target="_blank" rel="noopener">http://www.sohu.com/a/273552971_129720</a></p></li><li><p>Ask Me Anything session with a Kaggle Grandmaster Vladimir I. Iglovikov PDF：<a href="https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XkFwko_YrI5TfjjIai7ONQ</a></p></li></ul><hr><h3 id="大佬的Github"><a href="#大佬的Github" class="headerlink" title="大佬的Github"></a>大佬的Github</h3><ul><li><strong>植物</strong> ：<a href="https://github.com/plantsgo" target="_blank" rel="noopener">https://github.com/plantsgo</a></li><li><strong>wepon</strong> ：<a href="https://github.com/wepe" target="_blank" rel="noopener">https://github.com/wepe</a></li><li><strong>Snake</strong>：<a href="https://github.com/luoda888" target="_blank" rel="noopener">https://github.com/luoda888</a></li><li><strong>Drop-out</strong>：<a href="https://github.com/drop-out" target="_blank" rel="noopener">https://github.com/drop-out</a></li><li><strong>金老师的知乎</strong>：<a href="https://zhuanlan.zhihu.com/jlbookworm" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/jlbookworm</a></li><li><strong>渣大</strong>：<a href="https://github.com/nzc" target="_blank" rel="noopener">https://github.com/nzc</a></li><li><strong>郭大</strong>：<a href="https://github.com/guoday" target="_blank" rel="noopener">https://github.com/guoday</a></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>数据比赛资讯</strong>：<a href="https://github.com/iphysresearch/DataSciComp" target="_blank" rel="noopener">https://github.com/iphysresearch/DataSciComp</a></li><li><strong>ApacheCN 的kaggle资料链接</strong>：<a href="https://github.com/apachecn/kaggle" target="_blank" rel="noopener">https://github.com/apachecn/kaggle</a></li><li><strong>Kaggle top方案整理</strong>：<a href="https://github.com/EliotAndres/kaggle-past-solutions" target="_blank" rel="noopener">https://github.com/EliotAndres/kaggle-past-solutions</a></li></ul><hr><h3 id="团队联系方式"><a href="#团队联系方式" class="headerlink" title="团队联系方式"></a>团队联系方式</h3><ul><li><strong>Smile</strong> qq:240485545 Email:<a href="mailto:smile.xuhc@gmail.com" target="_blank" rel="noopener">smile.xuhc@gmail.com</a></li><li><strong>PUSH</strong> qq:1471386635 Email：<a href="mailto:1471386635@qq.com" target="_blank" rel="noopener">1471386635@qq.com</a></li><li><strong>dive2space</strong> qq: 1124361357 Email:<a href="mailto:dive2space@qq.com" target="_blank" rel="noopener">dive2space@qq.com</a></li></ul><hr><h2 id="来源链接"><a href="#来源链接" class="headerlink" title="来源链接"></a>来源链接</h2><p><a href="https://mp.weixin.qq.com/s/_4QG0dWhh784lF0n1wymcw" target="_blank" rel="noopener">竞赛|数据竞赛Top解决方案开源整理</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda管理软件和环境</title>
      <link href="/posts/42087.html"/>
      <url>/posts/42087.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><ul><li>印象笔记里面的两篇文章</li><li>斌斌师兄的脚本看看(里面有2和3兼容的问题)</li></ul><p>主要想解决的问题：</p><ul><li>环境备份的问题—多台集群环境如何管理</li><li>软件冲突时如何将软件安装在另一个环境中，使用的时候是怎么使用的呢？—直接找到环境的bin目录，然后将给软件指定alias指定到这个目录？</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csplit-根据文本内容切割文件</title>
      <link href="/posts/1958.html"/>
      <url>/posts/1958.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux常用的按照文件内容来对文件进行分割的命令csplit，前面学习的split主要是根据文件的外部信息进行的分割；主要学习了利用pattern模式分割以及参数使用；patern方面主要学习了<code>INTEGER</code>、<code>/REGEXP/[OFFSET]</code>、<code>{INTEGER}</code>、<code>{*}</code>以及<code>%REGEXP%[OFFSET]</code>；参数主要学习了<code>-f</code>、<code>-b</code>、<code>-n</code>、<code>-z</code>、<code>-k</code>和<code>-s</code>。</p></div><a id="more"></a><h2 id="csplit简介"><a href="#csplit简介" class="headerlink" title="csplit简介"></a>csplit简介</h2><p><code>csplit</code>主要是依据<strong>文件内容</strong>来进行切割文件，与<code>split</code>不同，<code>split</code>只是<strong>依据文件外部的信息</strong>，包括<strong>大小</strong>、<strong>行数</strong>以及<strong>分割得到的文件数目</strong>来进行限制。</p><hr><h2 id="csplit命令格式"><a href="#csplit命令格式" class="headerlink" title="csplit命令格式"></a>csplit命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  csplit [OPTION]... FILE PATTERN...</span><br></pre></td></tr></table></figure><p><strong>默认输出</strong>：</p><ul><li>每个小文件的字节数目</li><li>文件名为xx00、xx01这种</li></ul><h2 id="csplit-options参数"><a href="#csplit-options参数" class="headerlink" title="csplit options参数"></a>csplit options参数</h2><table><thead><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td><code>-suffix-format=FORMAT</code></td><td>预预设的输出格式其文件名称为xx00，xx01等，用户可以通过改变format来改变输出的文件名；</td></tr><tr><td><code>-f</code></td><td><code>--prefix=PREFIX</code></td><td>设置输出文件名的前缀，替换默认的xx</td></tr><tr><td><code>-k</code></td><td><code>--keep-files</code></td><td>就算发生错误或者终止运行，也不删除已经输出的文件</td></tr><tr><td><code>-n</code></td><td><code>--digits=DIGITS</code></td><td>默认输出的文件后缀为两位数字，这个参数可以修改后缀数字的数目，默认为2</td></tr><tr><td><code>-s</code></td><td><code>--quiet, --silent</code></td><td>静默输出，不显示执行过程</td></tr><tr><td><code>-z</code></td><td><code>--elide-empty-files</code></td><td>删除(不输出)空的输出文件</td></tr></tbody></table><hr><h2 id="csplit-匹配模式"><a href="#csplit-匹配模式" class="headerlink" title="csplit 匹配模式"></a>csplit 匹配模式</h2><p><escepe></escepe></p><p><table><br><thead><br><tr><br><th width="15%">参数</th><br><th width="85%">说明</th><br></tr><br></thead><br><tbody><br><tr><br><td><code>INTEGER</code></td><br><td>使用行数来分割文件(不包括指定的行数)</td><br></tr><br><tr><br><td><code>/REGEXP/[OFFSET]</code></td><br><td>使用REGEXP来分割文件(不包含REGEXP行)</td><br></tr><br><tr><br><td><code>%REGEXP%[OFFSET]</code></td><br><td>跳过REGEXP之前的行，从之后的行开始输出</td><br></tr><br><tr><br><td><code>{INTEGER}</code></td><br><td>重复前面的pattern指定的次数</td><br></tr><br><tr><br><td><code>{*}</code></td><br><td>尽可能多地重复前面的pattern</td><br></tr><br></tbody><br></table><br></p><hr><p><br></p><h2 id="csplit匹配模式使用实例"><a href="#csplit匹配模式使用实例" class="headerlink" title="csplit匹配模式使用实例"></a>csplit匹配模式使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat server.log </span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-3</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><hr><h3 id="INTEGER-按行划分"><a href="#INTEGER-按行划分" class="headerlink" title="INTEGER-按行划分"></a>INTEGER-按行划分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件分割为前一行 和 剩余的行</span></span><br><span class="line"><span class="comment"># 注意是不包括数字指定的行</span></span><br><span class="line">csplit server.log 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出划分得到的小文件的字节大小</span></span><br><span class="line">  9</span><br><span class="line">  273</span><br></pre></td></tr></table></figure><p><strong>输出内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user   9 Apr 13 16:15 xx00</span><br><span class="line">-rw-rw-r--. 1 user user 273 Apr 13 16:15 xx01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不包括第二行</span></span><br><span class="line">cat xx00</span><br><span class="line">  SERVER-1</span><br></pre></td></tr></table></figure><p></p><p>也可以指定<strong>多个整数</strong>来分割：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定多行文本进行划分</span></span><br><span class="line"><span class="comment"># 分别得到0-1、2-4、5-6、7-最后的文件</span></span><br><span class="line">csplit server.log 2 5 7</span><br><span class="line">  9</span><br><span class="line">  63</span><br><span class="line">  30</span><br><span class="line">  180</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user   9 Apr 13 16:20 xx00</span><br><span class="line">-rw-rw-r--. 1 user user  63 Apr 13 16:20 xx01</span><br><span class="line">-rw-rw-r--. 1 user user  30 Apr 13 16:20 xx02</span><br><span class="line">-rw-rw-r--. 1 user user 180 Apr 13 16:20 xx03</span><br><span class="line"></span><br><span class="line"><span class="comment"># server.log的第2、3、4行</span></span><br><span class="line">cat xx01</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="REGEXP-OFFSET-匹配分割文件"><a href="#REGEXP-OFFSET-匹配分割文件" class="headerlink" title="/REGEXP/[OFFSET]-匹配分割文件"></a>/REGEXP/[OFFSET]-匹配分割文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以SERVER-2为模式进行分割</span></span><br><span class="line"><span class="comment"># 不包括模式匹配上的这一行</span></span><br><span class="line">csplit server.log /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 16:43 xx00</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 16:43 xx01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不包括SERVER-2这一行</span></span><br><span class="line">cat xx00</span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br></pre></td></tr></table></figure><p></p><p><strong>匹配的是pattern第一次出现的位置</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上述测试文件的SERVER-3修改为SERVER-2</span></span><br><span class="line">csplit server.log /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第一次出现SERVER的位置分割</span></span><br><span class="line"><span class="comment"># 因为SERVER出现在第一行，所以第一个文件大小为0</span></span><br><span class="line">csplit server.log /SERVER*/ </span><br><span class="line">  0</span><br><span class="line">  282</span><br></pre></td></tr></table></figure><p></p><p><strong>第一次匹配输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从第一次匹配到SERVER-2的位置进行分割</span></span><br><span class="line">more xx01</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><p><strong>指定模式之后的偏移</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以SERVER-2为模式进行分割</span></span><br><span class="line"><span class="comment">#  并且向下移一行，这样就包括了模式匹配上的那一行</span></span><br><span class="line"><span class="comment"># 偏移+表示向下多输出一行</span></span><br><span class="line"><span class="comment"># -表示向上少输出一样</span></span><br><span class="line">csplit server.log /SERVER-2/+1</span><br><span class="line">  102</span><br><span class="line">  180</span><br></pre></td></tr></table></figure><p></p><p><strong>偏移后的输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SERVER-1</span><br><span class="line">[con] 10.10.10.1 suc</span><br><span class="line">[con] 10.10.10.2 fai</span><br><span class="line">[dis] 10.10.10.3 pen</span><br><span class="line">[con] 10.10.10.4 suc</span><br><span class="line">SERVER-2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>REGEXP</code>匹配的是第一次出现的位置，只会在<strong>第一次出现位置</strong>处切割</li><li>可以设置<code>[OFFSET]</code>来进行匹配行的上下偏移</li></ul></div><hr><h3 id="INTEGER-和-重复前面的pattern"><a href="#INTEGER-和-重复前面的pattern" class="headerlink" title="{INTEGER}和{*}-重复前面的pattern"></a>{INTEGER}和{*}-重复前面的pattern</h3><p>前面的<code>/REGEXP/[OFFSET]</code>只会在第一次出现pattern的位置进行切割，如果想要在所有的pattern匹配位置进行切割，可以借助<code>{INTEGER}</code>和<code>{*}</code>分别进行<strong>指定次数的重复</strong>pattern以及<strong>任意次数的重复</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复前面的pettern一次</span></span><br><span class="line"><span class="comment"># 是重复一次，原本中有2个SERVER-2，只用重复一次即可</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;1&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置重复两次会出错</span></span><br><span class="line"><span class="comment"># 这种情况不会有结果输出</span></span><br><span class="line"><span class="comment"># 可以借助后面的-k参数来保留结果</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复任意次数</span></span><br><span class="line"><span class="comment"># 这样可以避免出现不知道pettern出现几次而出现错误</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;*&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  96</span><br></pre></td></tr></table></figure><p></p><p><strong>结果输出</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) [user@localhost csplit]$ cat xx00 </span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br><span class="line">(base) [user@localhost csplit]$ cat xx01</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">(base) [user@localhost csplit]$ cat xx02</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>{INTEGER}</code>和<code>{*}</code>可以有效<strong>解决<code>/REGEXP/[OFFSET]</code>只会对第一次出现的pattern进行分割的问题</strong>，<strong>重复指定的次数</strong>或者<strong>任意多次</strong>的pattern来对文件进行分割，从而达到<strong>将文件从所有出现pattern的位置进行切割的目的</strong>；</p></div><hr><h3 id="REGEXP-OFFSET-逃过模式之前的行"><a href="#REGEXP-OFFSET-逃过模式之前的行" class="headerlink" title="%REGEXP%[OFFSET]-逃过模式之前的行"></a>%REGEXP%[OFFSET]-逃过模式之前的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过SERVER-2之前的行</span></span><br><span class="line"><span class="comment"># 这里剩下的部分会包含模式这一行</span></span><br><span class="line"><span class="comment"># 相当于把按模式分割的前面几个文件给删掉了</span></span><br><span class="line">csplit server.log %SERVER-2%</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat xx00</span><br><span class="line">  SERVER-2</span><br><span class="line">  [con] 10.10.10.5 suc</span><br><span class="line">  [con] 10.10.10.6 fai</span><br><span class="line">  [dis] 10.10.10.7 pen</span><br><span class="line">  [con] 10.10.10.8 suc</span><br><span class="line">  SERVER-3</span><br><span class="line">  [con] 10.10.10.9 suc</span><br><span class="line">  [con] 10.10.10.10 fai</span><br><span class="line">  [dis] 10.10.10.11 pen</span><br><span class="line">  [con] 10.10.10.12 suc</span><br></pre></td></tr></table></figure><p></p><p>这个和前面的<code>/REGEXP/[OFFSET]</code>相同，都可以指定<code>[OFFSET]</code>偏移量。</p><hr><h2 id="csplit参数使用实例"><a href="#csplit参数使用实例" class="headerlink" title="csplit参数使用实例"></a>csplit参数使用实例</h2><h3 id="f-设置输出前缀"><a href="#f-设置输出前缀" class="headerlink" title="-f-设置输出前缀"></a>-f-设置输出前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出文件前缀为test</span></span><br><span class="line"><span class="comment"># 以SERVER-2为分割</span></span><br><span class="line">csplit server.log -f <span class="built_in">test</span> /SERVER-2/</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 16:09 test00</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 16:09 test01</span><br><span class="line"></span><br><span class="line">cat test00 </span><br><span class="line"><span class="comment"># 输出内容不包含匹配行</span></span><br><span class="line">  SERVER-1</span><br><span class="line">  [con] 10.10.10.1 suc</span><br><span class="line">  [con] 10.10.10.2 fai</span><br><span class="line">  [dis] 10.10.10.3 pen</span><br><span class="line">  [con] 10.10.10.4 suc</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="b-设置输出文件名称格式"><a href="#b-设置输出文件名称格式" class="headerlink" title="-b-设置输出文件名称格式"></a>-b-设置输出文件名称格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置输出文件名格式之后加上.log后缀</span></span><br><span class="line"><span class="comment"># 设置文件名称等宽，并使用0填充 --&gt; 02d</span></span><br><span class="line">csplit server.log -f <span class="built_in">test</span> -b <span class="string">"%02d.log"</span> /SERVER-2/</span><br><span class="line">  93</span><br><span class="line">  189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况是两位的数字后缀，并且指定输出格式一定要是02d，用0填充</span></span><br><span class="line"><span class="comment"># 如果不加0表示用0填充，那么会出现空格填充的情况</span></span><br><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:22 test00.log</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 18:22 test01.log</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-设置后缀数字数目"><a href="#n-设置后缀数字数目" class="headerlink" title="-n-设置后缀数字数目"></a>-n-设置后缀数字数目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csplit server.log -f <span class="built_in">test</span> -b <span class="string">"%03d.log"</span> -n 3 /SERVER-2/</span><br><span class="line">93</span><br><span class="line">189</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:28 test000.log</span><br><span class="line">-rw-rw-r--. 1 user user 189 Apr 13 18:28 test001.log</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="k-保留运行错误的结果文件"><a href="#k-保留运行错误的结果文件" class="headerlink" title="-k-保留运行错误的结果文件"></a>-k-保留运行错误的结果文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的这个示例</span></span><br><span class="line"><span class="comment"># 因为存在错误，所以不会得到结果文件</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125;</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上-k参数来避免这种情况</span></span><br><span class="line"><span class="comment"># 依然后提示错误信息</span></span><br><span class="line"><span class="comment"># 但是会得到能够正确分割的文件</span></span><br><span class="line">csplit server.log /SERVER-2/ &#123;2&#125; -k</span><br><span class="line">  93</span><br><span class="line">  93</span><br><span class="line">  csplit: ‘/SERVER-2/’: match not found on repetition 2</span><br><span class="line">  96</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:33 xx00</span><br><span class="line">-rw-rw-r--. 1 user user  93 Apr 13 18:33 xx01</span><br><span class="line">-rw-rw-r--. 1 user user  96 Apr 13 18:33 xx02</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="z-不输出空文件"><a href="#z-不输出空文件" class="headerlink" title="-z-不输出空文件"></a>-z-不输出空文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下会输出文件大小为0的文件</span></span><br><span class="line">csplit server.log /SERVER/</span><br><span class="line">  0</span><br><span class="line">  282</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-z参数就不会输出空文件</span></span><br><span class="line">csplit server.log /SERVER/ -z</span><br><span class="line">  282</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds1/csplit.htm" target="_blank" rel="noopener">csplit 命令</a></li><li><a href="http://man.linuxde.net/csplit" target="_blank" rel="noopener">csplit命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看CPU型号、内存、硬盘、版本等信息</title>
      <link href="/posts/9853.html"/>
      <url>/posts/9853.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习和总结了Linux中查看CPU型号、内存、硬盘、版本等信息的命令，便于日常使用查询。</p></div><a id="more"></a><h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><p>CPU相关的信息都保存在<code>/proc/cpuinfo</code>文件中</p><h3 id="查看CPU个数"><a href="#查看CPU个数" class="headerlink" title="查看CPU个数"></a>查看CPU个数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="查看CPU核数"><a href="#查看CPU核数" class="headerlink" title="查看CPU核数"></a>查看CPU核数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">cpu cores: 6</span><br></pre></td></tr></table></figure><hr><h3 id="查看CPU型号"><a href="#查看CPU型号" class="headerlink" title="查看CPU型号"></a>查看CPU型号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">'model name'</span> |uniq</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz</span><br></pre></td></tr></table></figure><hr><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><p>内存信息保存在<code>/proc/meminfo</code>中</p><h3 id="查看内存大小"><a href="#查看内存大小" class="headerlink" title="查看内存大小"></a>查看内存大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo | grep MemTotal</span><br><span class="line"><span class="comment"># 输出内存大小，Kb为单位</span></span><br><span class="line"><span class="comment"># 大小为49G</span></span><br><span class="line">MemTotal:       49219420 kB</span><br></pre></td></tr></table></figure><hr><h3 id="查看内存条数"><a href="#查看内存条数" class="headerlink" title="查看内存条数"></a>查看内存条数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dmidecode |grep -A16 <span class="string">"Memory Device$"</span></span><br><span class="line"><span class="comment"># 实验室集群安装了6个8G的，还有8个卡槽没有安装内存条</span></span><br><span class="line">  Memory Device</span><br><span class="line">    Array Handle: 0x002F</span><br><span class="line">    Error Information Handle: Not Provided</span><br><span class="line">    Total Width: 72 bits</span><br><span class="line">    Data Width: 64 bits</span><br><span class="line">    Size: 8192 MB      <span class="comment"># 这里安装了一个8G的内存</span></span><br><span class="line">    Form Factor: DIMM</span><br><span class="line">    Set: None</span><br><span class="line">    Locator: DIMM1_CPU1</span><br><span class="line">    Bank Locator: Not Specified</span><br><span class="line">    Type: Other</span><br><span class="line">    Type Detail: Synchronous</span><br><span class="line">    Speed: 2400 MHz</span><br><span class="line">    Manufacturer: Undefined</span><br><span class="line">    Serial Number: 131087AA</span><br><span class="line">    Asset Tag: DIMM1_CPU1_AssetTag</span><br><span class="line">    Part Number: KHX2400C15/8G</span><br></pre></td></tr></table></figure><hr><h2 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h2><h3 id="查看硬盘大小"><a href="#查看硬盘大小" class="headerlink" title="查看硬盘大小"></a>查看硬盘大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l | grep Disk</span><br><span class="line"><span class="comment"># 输出的硬盘信息</span></span><br><span class="line">  Disk /dev/sda: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00097e63</span><br><span class="line">  Disk /dev/sdb: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00091a2b</span><br><span class="line">  Disk /dev/sdc: 4000.8 GB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x00000000</span><br><span class="line">  Disk /dev/sdd: 2000.4 GB, 2000398934016 bytes, 3907029168 sectors</span><br><span class="line">  Disk label <span class="built_in">type</span>: dos</span><br><span class="line">  Disk identifier: 0x4120a342</span><br><span class="line">  Disk /dev/mapper/centos-root: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">  Disk /dev/mapper/centos-swap: 8388 MB, 8388608000 bytes, 16384000 sectors</span><br><span class="line">  Disk /dev/mapper/centos-home: 1937.7 GB, 1937730699264 bytes, 3784630272 sectors</span><br></pre></td></tr></table></figure><hr><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><h3 id="查看当前操作系统版本信息"><a href="#查看当前操作系统版本信息" class="headerlink" title="查看当前操作系统版本信息"></a>查看当前操作系统版本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">  Linux version 3.10.0-327.18.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) ) <span class="comment">#1 SMP Thu May 12 11:03:55 UTC 2016</span></span><br></pre></td></tr></table></figure><hr><h3 id="查看版本当前操作系统内核信息"><a href="#查看版本当前操作系统内核信息" class="headerlink" title="查看版本当前操作系统内核信息"></a>查看版本当前操作系统内核信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line">Linux localhost.localdomain 3.10.0-327.18.2.el7.x86_64 <span class="comment">#1 SMP Thu May 12 11:03:55 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><hr><h3 id="查看当前操作系统发行信息"><a href="#查看当前操作系统发行信息" class="headerlink" title="查看当前操作系统发行信息"></a>查看当前操作系统发行信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">cat /etc/centos-release</span><br><span class="line">  CentOS Linux release 7.2.1511 (Core)</span><br></pre></td></tr></table></figure><hr><h3 id="查看硬盘使用情况"><a href="#查看硬盘使用情况" class="headerlink" title="查看硬盘使用情况"></a>查看硬盘使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df -hl</span><br><span class="line">  Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">  /dev/mapper/centos-root   50G   48G  2.8G  95% /</span><br><span class="line">  devtmpfs                  24G     0   24G   0% /dev</span><br><span class="line">  tmpfs                     24G     0   24G   0% /dev/shm</span><br><span class="line">  tmpfs                     24G   17M   24G   1% /run</span><br><span class="line">  tmpfs                     24G     0   24G   0% /sys/fs/cgroup</span><br><span class="line">  /dev/mapper/centos-home  1.8T  1.3T  519G  72% /home</span><br><span class="line">  /dev/sdd1                1.8T  1.6T  156G  92% /datastore_2</span><br><span class="line">  /dev/sdc1                3.6T  419G  3.0T  13% /workstation</span><br><span class="line">  /dev/sda1                494M  172M  323M  35% /boot</span><br><span class="line">  tmpfs                    4.7G     0  4.7G   0% /run/user/0</span><br><span class="line">  tmpfs                    4.7G     0  4.7G   0% /run/user/1021</span><br></pre></td></tr></table></figure><p>关于结果：最后一列表示挂载点，也就是哪些目录使用的什么盘，<strong>第一个根目录是除了后面几个挂载点之外的剩余目录的大小</strong>，这里的比较小只有50G，并且占用比较大，可能经常会出现<code>OSError: [Errno 28] No space left on device</code>的问题，腾点空间就好了。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/97157.htm" target="_blank" rel="noopener">Linux下查看CPU型号,内存大小,硬盘空间的命令(详解)</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>split-按大小分割文件</title>
      <link href="/posts/41178.html"/>
      <url>/posts/41178.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux中用于按照<strong>指定的需求(大小、行数、文件数目)拆分文件的命令</strong><code>split</code>，是<code>cat</code>命令合并文件功能的反向操作；主要参数包括：<code>-l</code>、<code>-b(K、M、T，默认是bytes)</code>、<code>-d(--numeric-suffixes=num)</code>、<code>文件前缀</code>、<code>-a(默认为2)</code>、<code>--additional-suffix=str</code>、<code>-n(N、K/N、l/N、l/K/N)</code>、<code>-e</code>等参数；最后可以通过<code>md5sum</code>命令检查split之后cat命令合并得到的文件和原始文件相比<strong>是否完整</strong>。</p></div><a id="more"></a><h2 id="split简介"><a href="#split简介" class="headerlink" title="split简介"></a>split简介</h2><p><code>Linux split</code>命令可以将一个大文件分割成指定大小的很多个小文件，并且拆分速度非常的快，可以看成是<code>cat</code>命令合并文件功能的反操作，其主要<strong>特点</strong>：</p><ul><li>可以指定子文件的行数、大小以及子文件的数目</li><li>指定大小以及子文件数目(默认情况)会对一行甚至是一个单词的内容进行切割，指定子文件数目中可以读这种情况进行调整</li><li>指定的文件前缀名需要放在split文件之后，不然会报错，前缀默认为x</li><li>可以指定文件的后缀(数字、字符)以及后缀的数目，后缀默认是从aa开始递增的两位字符</li><li>可以文件添加统一的后缀(作为文件的拓展名)</li></ul><h2 id="split命令格式"><a href="#split命令格式" class="headerlink" title="split命令格式"></a>split命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  split [OPTION]... [INPUT [PREFIX]]</span><br></pre></td></tr></table></figure><ul><li>Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ..</li><li><strong>default size</strong> is 1000 lines</li><li><strong>default PREFIX</strong> is ‘x’</li><li><strong>With no INPU</strong>T, or when INPUT is <code>-</code>, read standard input</li></ul><hr><h2 id="split参数"><a href="#split参数" class="headerlink" title="split参数"></a>split参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-l</code></td><td><code>--lines=NUMBER</code></td><td>指定每多少行切成一个小文件</td></tr><tr><td><code>-b</code></td><td><code>--bytes=SIZE</code></td><td>指定每多少字节切成一个小文件，单位可以是K、M、G</td></tr><tr><td><code>-d</code></td><td><code>--numeric-suffixes[=FROM]</code></td><td>使用数字作为小文件名称的后缀，默认从0开始(使用from调节)</td></tr><tr><td></td><td><code>--additional-suffix=SUFFIX</code></td><td>小文件名称的后缀，默认从 aa 开始</td></tr><tr><td><code>-n</code></td><td><code>--number=CHUNKS</code></td><td>分得的文件(CHUNKS)数目</td></tr><tr><td><code>-a</code></td><td><code>--suffix-length=N</code></td><td>后缀长度，默认是2，也就是按 aa、ab、ac 这样的格式依次编号</td></tr><tr><td><code>-C</code></td><td><code>--line-bytes=SIZE</code></td><td>put at most SIZE bytes of lines per output file</td></tr><tr><td><code>-e</code></td><td><code>--elide-empty-files</code></td><td>在使用-n参数的时候不产生空的文件</td></tr><tr><td></td><td><code>--verbose</code></td><td>显示分割进度</td></tr></table><p><strong>CHUNKS</strong>:</p><table><tr><th width="15%">参数</th><th width="85%">说明</th></tr><tr><td><code>N</code></td><td>分割为N个文件</td></tr><tr><td><code>K/N</code></td><td>将N个文件中的第K个输出到标准输出</td></tr><tr><td><code>l/N</code></td><td><strong>在不分割行</strong>的情况下分割为N个文件</td></tr><tr><td><code>l/K/N</code></td><td>将<strong>在不分割行</strong>的情况下得到的N个文件中的第K个输出到标准输出</td></tr><tr><td><code>r/N</code></td><td>like 'l' but use round robin distribution</td></tr><tr><td><code>r/K/N</code></td><td>likewise but only output Kth of N to stdout</td></tr></table><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="l-指定每个文件的行数"><a href="#l-指定每个文件的行数" class="headerlink" title="-l-指定每个文件的行数"></a>-l-指定每个文件的行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件的行数</span></span><br><span class="line">wc -l test.txt </span><br><span class="line">  51 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个文件10行</span></span><br><span class="line">split -l 10 test.txt</span><br><span class="line">  <span class="comment"># 生成6个文件</span></span><br><span class="line">  <span class="comment"># 其中最后一个文件只有一行</span></span><br><span class="line">-rw-rw-r--. 1 user user 5779 Apr 12 00:10 test.txt</span><br><span class="line">-rw-rw-r--. 1 user user  338 Apr 12 00:12 xaa</span><br><span class="line">-rw-rw-r--. 1 user user 1900 Apr 12 00:12 xab</span><br><span class="line">-rw-rw-r--. 1 user user 1513 Apr 12 00:12 xac</span><br><span class="line">-rw-rw-r--. 1 user user 1523 Apr 12 00:12 xad</span><br><span class="line">-rw-rw-r--. 1 user user  432 Apr 12 00:12 xae</span><br><span class="line">-rw-rw-r--. 1 user user   73 Apr 12 00:12 xaf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="comment"># 空行也算行</span></span><br><span class="line"><span class="comment"># 换行算一行，不进行切割</span></span><br><span class="line">cat -n xac</span><br><span class="line">     1</span><br><span class="line">     2In particular, Anaconda Distribution contains re-distributable, run-time, shared-library files from the Intel(TM) Math Kernel Library (<span class="string">"MKL binaries"</span>). You are specifically authorized to use the MKL binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the MKL binaries with Anaconda Distribution or <span class="keyword">in</span> the conda package that contains them. Use and redistribution of the MKL binaries are subject to the licensing terms located at https://software.intel.com/en-us/license/intel-simplified-software-license. If needed, instructions <span class="keyword">for</span> removing the MKL binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line">     3</span><br><span class="line">     4Anaconda Distribution also contains cuDNN software binaries from NVIDIA Corporation (<span class="string">"cuDNN binaries"</span>). You are specifically authorized to use the cuDNN binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the cuDNN binaries with an Anaconda Distribution package that contains them. If needed, instructions <span class="keyword">for</span> removing the cuDNN binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line">     5</span><br><span class="line">     6</span><br><span class="line">     7Anaconda Distribution also contains Visual Studio Code software binaries from Microsoft Corporation (<span class="string">"VS Code"</span>). You are specifically authorized to use VS Code with your installation of Anaconda Distribution. Use of VS Code is subject to the licensing terms located at https://code.visualstudio.com/License.</span><br><span class="line">     8</span><br><span class="line">     9Cryptography Notice</span><br><span class="line">    10===================</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>不足指定行数的也放在一个文件中</li><li>空行也算行</li><li>一行文本太长换行的话算一行，不进行切割</li></ul></div><hr><h3 id="b-指定分割文件大小"><a href="#b-指定分割文件大小" class="headerlink" title="-b-指定分割文件大小"></a>-b-指定分割文件大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认单位是b</span></span><br><span class="line">split -b 1000 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 可以和前面-l的输出结果对比</span></span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xab</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xac</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xad</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:35 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:35 xaf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看输出文件内容</span></span><br><span class="line"><span class="comment"># 会对一行的内容甚至的一个单词进行切割</span></span><br><span class="line">cat xab</span><br><span class="line">  DING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANACONDA, INC. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"></span><br><span class="line">  Notice of Third Party Software Licenses</span><br><span class="line">  =======================================</span><br><span class="line"></span><br><span class="line">  Anaconda Distribution contains open <span class="built_in">source</span> software packages from third parties. These are available on an <span class="string">"as is"</span> basis and subject to their individual license agreements. These licenses are available <span class="keyword">in</span> Anaconda Distribution or at http://docs.anaconda.com/anaconda/pkg-docs. Any binary packages of thes</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>不同于<code>-l</code>参数会<strong>保留行的完整性</strong>，<code>-b</code>参数<strong>会对同一行甚至同一个单词进行切割</strong></li><li><code>-b</code>参数可以指定的单位包括<code>K</code>、<code>M</code>、<code>G</code>，<strong>默认是字节</strong></li></ul></div><hr><h3 id="指定文件名前缀"><a href="#指定文件名前缀" class="headerlink" title="指定文件名前缀"></a>指定文件名前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件的前缀需要放在split文件之后</span></span><br><span class="line"><span class="comment"># 不然会报错</span></span><br><span class="line">split <span class="built_in">test</span> -b 1000 test.txt</span><br><span class="line">  split: cannot open ‘<span class="built_in">test</span>’ <span class="keyword">for</span> reading: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割得到的文件的前缀为test</span></span><br><span class="line"><span class="comment"># 替换默认的前缀x</span></span><br><span class="line">split -b 1000 test.txt <span class="built_in">test</span></span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testab</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testac</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testad</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:38 testae</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:38 testaf</span><br></pre></td></tr></table></figure><hr><h3 id="d-指定数字后缀"><a href="#d-指定数字后缀" class="headerlink" title="-d-指定数字后缀"></a>-d-指定数字后缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的后缀的aa开始的</span></span><br><span class="line"><span class="comment"># 这里指定以数字作为后缀</span></span><br><span class="line"><span class="comment"># 默认后缀从0开始</span></span><br><span class="line">split -b 1000 -d test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x00</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x01</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x02</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x03</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:45 x04</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:45 x05</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置后缀从10开始</span></span><br><span class="line"><span class="comment"># 注意这里只能使用完整的参数形式，不能使用-d这种简写的</span></span><br><span class="line">split -b 1000 --numeric-suffixes=10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x10</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x11</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x12</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x13</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:49 x14</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:49 x15</span><br></pre></td></tr></table></figure><hr><h3 id="a-设置后缀的长度"><a href="#a-设置后缀的长度" class="headerlink" title="-a-设置后缀的长度"></a>-a-设置后缀的长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置数字后缀的长度为3</span></span><br><span class="line">split -b 1000 -a 3 -d test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x000</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x001</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x002</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x003</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 00:47 x004</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 00:47 x005</span><br></pre></td></tr></table></figure><hr><h3 id="在文件名最后添加额外的后缀"><a href="#在文件名最后添加额外的后缀" class="headerlink" title="在文件名最后添加额外的后缀"></a>在文件名最后添加额外的后缀</h3><p>这里额外的后缀和前面的数字和默认字符串后缀不同，这个后缀是统一的(<strong>可以用来指定文件格式</strong>)，所有文件的都相同，而前面的数字和默认字符串后缀会随着文件数目而变化：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定额外的后缀为test</span></span><br><span class="line">split -b 1000 --numeric-suffixes=10 --additional-suffix=<span class="string">'.txt'</span>  test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x10.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x11.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x12.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x13.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1000 Apr 12 01:33 x14.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  779 Apr 12 01:33 x15.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="n-设置文件的数目"><a href="#n-设置文件的数目" class="headerlink" title="-n-设置文件的数目"></a>-n-设置文件的数目</h3><h4 id="N-分割为N个文件"><a href="#N-分割为N个文件" class="headerlink" title="N-分割为N个文件"></a>N-分割为N个文件</h4><p><strong>以文件大小为依据平均分割为N个文件</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定分割的文件数目为10</span></span><br><span class="line"><span class="comment"># 注意和前面的-b、-l区分，这里的数目是固定的</span></span><br><span class="line"><span class="comment"># 每个文件的大小是相同的，最后一个文件可能大或者小</span></span><br><span class="line">split -n 10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xad</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  577 Apr 12 00:55 xai</span><br><span class="line">  -rw-rw-r--. 1 user user  586 Apr 12 00:55 xaj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看其中一个文件内容，发现有些行被中间截断了</span></span><br><span class="line">cat xaf</span><br><span class="line">  n are available at http://www.anaconda.com.</span><br><span class="line"></span><br><span class="line">  Anaconda Distribution also contains cuDNN software binaries from NVIDIA Corporation (<span class="string">"cuDNN binaries"</span>). You are specifically authorized to use the cuDNN binaries with your installation of Anaconda Distribution. You are also authorized to redistribute the cuDNN binaries with an Anaconda Distribution package that contains them. If needed, instructions <span class="keyword">for</span> removing the cuDNN binaries after installation of Anaconda Distribution are available at http://www.anaconda.com.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Anaconda Distribution also contains Visual Studio Code softw</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>前面的<code>-l</code>、<code>-b</code>参数是按照<strong>指定行数或者大小来分割文件</strong>，<strong>文件数目不可控</strong>；而<code>-n</code>指定<strong>分割得到的文件数目</strong>，<strong>数目多少是可控的</strong>，并且<strong>除最后一个文件外，大小是相同的</strong>；</li><li><code>-n</code>参数会依据文件大小<strong>严格分割</strong>得到n个文件，<strong>可能会对同一行甚至是一个单词的内容进行切割</strong>，这个<strong>和<code>-b</code>参数类似</strong>;</li></ul></div><hr><h4 id="K-N-将N个文件中的第K个输出到标准输出"><a href="#K-N-将N个文件中的第K个输出到标准输出" class="headerlink" title="K/N-将N个文件中的第K个输出到标准输出"></a>K/N-将N个文件中的第K个输出到标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在屏幕输出分割得到的10个文件中的第1个</span></span><br><span class="line"><span class="comment"># 不会得到分割的文件</span></span><br><span class="line"><span class="comment"># 还是会对行进行分割</span></span><br><span class="line">split -n 1/10 test.txt </span><br><span class="line">  ===================================</span><br><span class="line">  Anaconda End User License Agreement</span><br><span class="line">  ===================================</span><br><span class="line"></span><br><span class="line">  Copyright 2015, Anaconda, Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">  Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of <span class="built_in">source</span> code must retain the above copyright notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright notice, this list of conditions and the</span><br></pre></td></tr></table></figure><hr><h4 id="l-N-在不分割行的情况下分割为N个文件"><a href="#l-N-在不分割行的情况下分割为N个文件" class="headerlink" title="l/N-在不分割行的情况下分割为N个文件"></a>l/N-在不分割行的情况下分割为N个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不分割行的情况下分割为10个文件</span></span><br><span class="line"><span class="comment"># 分割得到10个文件，保持了行的连续性</span></span><br><span class="line"><span class="comment"># 可能会得到大小为0的文件，不一定在最后</span></span><br><span class="line">split -n l/10 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  674 Apr 12 01:21 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  940 Apr 12 01:21 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  624 Apr 12 01:21 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  691 Apr 12 01:21 xad</span><br><span class="line">  -rw-rw-r--. 1 user user    0 Apr 12 01:21 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  781 Apr 12 01:21 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  535 Apr 12 01:21 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  650 Apr 12 01:21 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  378 Apr 12 01:21 xai</span><br><span class="line">  -rw-rw-r--. 1 user user  506 Apr 12 01:21 xaj</span><br></pre></td></tr></table></figure><div class="note info"><p><code>-n l/N</code>：在<strong>指定分割得到的文件数目</strong>的<strong>同时保留了每个文件中行的完整性</strong></p></div><hr><h4 id="e-在使用-n参数的时候不产生空的文件"><a href="#e-在使用-n参数的时候不产生空的文件" class="headerlink" title="-e-在使用-n参数的时候不产生空的文件"></a>-e-在使用-n参数的时候不产生空的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不输出空的文件</span></span><br><span class="line"><span class="comment"># 对比前面的-n l/10，这里不产生空的文件(前面的xae)</span></span><br><span class="line">split -n l/10 -e test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user  674 Apr 12 01:30 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user  940 Apr 12 01:30 xab</span><br><span class="line">  -rw-rw-r--. 1 user user  624 Apr 12 01:30 xac</span><br><span class="line">  -rw-rw-r--. 1 user user  691 Apr 12 01:30 xad</span><br><span class="line">  -rw-rw-r--. 1 user user  781 Apr 12 01:30 xae</span><br><span class="line">  -rw-rw-r--. 1 user user  535 Apr 12 01:30 xaf</span><br><span class="line">  -rw-rw-r--. 1 user user  650 Apr 12 01:30 xag</span><br><span class="line">  -rw-rw-r--. 1 user user  378 Apr 12 01:30 xah</span><br><span class="line">  -rw-rw-r--. 1 user user  506 Apr 12 01:30 xai</span><br></pre></td></tr></table></figure><hr><h4 id="l-K-N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出"><a href="#l-K-N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出" class="headerlink" title="l/K/N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出"></a>l/K/N-将在不分割行的情况下得到的N个文件中的第K个输出到标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类似于前面的K/N</span></span><br><span class="line"><span class="comment"># 直接在屏幕输出分割得到的10个文件中的第1个</span></span><br><span class="line"><span class="comment"># 只是保留了行的完整性</span></span><br><span class="line">split -n l/1/10 test.txt </span><br><span class="line">  ===================================</span><br><span class="line">  Anaconda End User License Agreement</span><br><span class="line">  ===================================</span><br><span class="line"></span><br><span class="line">  Copyright 2015, Anaconda, Inc.</span><br><span class="line"></span><br><span class="line">  All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">  Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of <span class="built_in">source</span> code must retain the above copyright notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer <span class="keyword">in</span> the documentation and/or other materials provided with the distribution.</span><br></pre></td></tr></table></figure><hr><h3 id="cat合并并校验文件"><a href="#cat合并并校验文件" class="headerlink" title="cat合并并校验文件"></a>cat合并并校验文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先拆分为3个文件</span></span><br><span class="line">split -n 3 test.txt</span><br><span class="line">  -rw-rw-r--. 1 user user 1926 Apr 12 09:37 xaa</span><br><span class="line">  -rw-rw-r--. 1 user user 1926 Apr 12 09:37 xab</span><br><span class="line">  -rw-rw-r--. 1 user user 1927 Apr 12 09:37 xac</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看原始的md5值</span></span><br><span class="line">md5sum test.txt </span><br><span class="line">  27272b6fb8e9e0b22f8f0f5afc6e1346  test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并文件</span></span><br><span class="line">cat xa&#123;a..c&#125; &gt;merged.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看合并后文件的md5值</span></span><br><span class="line">md5sum merged.txt </span><br><span class="line">  27272b6fb8e9e0b22f8f0f5afc6e1346  merged.txt</span><br></pre></td></tr></table></figure><div class="note info"><p>对<strong>split之后的文件</strong>进行<strong>cat操作得到的文件md5值和原始文件相同</strong></p></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://c.biancheng.net/linux/split.html" target="_blank" rel="noopener">split命令_Linux split命令：切割（拆分）文件</a></li><li></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paste-合并文件</title>
      <link href="/posts/22454.html"/>
      <url>/posts/22454.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux中常用的<strong>合并文件命令</strong><code>paste</code>，主要参数包括<code>-s</code>、<code>-d</code>，这个参数与<code>cut</code>命令的功能相反；<strong>与<code>cat</code>命令相比</strong>，<code>paste</code><strong>默认按行合并</strong>，如果指定<code>-s</code>参数之后进行<strong>先在一个文件内部按指定的分隔符将所有的行合并</strong>，<strong>然后在所有的文件之间按列合并</strong>。</p></div><a id="more"></a><h2 id="paste简介"><a href="#paste简介" class="headerlink" title="paste简介"></a>paste简介</h2><p><code>paste</code>命令主要用来将多个文件的内容合并(<strong>按行或者按列合并</strong>)，与<code>cut</code>命令完成的功能刚好相反。<br>特点：</p><ul><li>可以指定分隔符</li><li>可以先在一个文件内部按指定的分隔符将所有的行合并，然后在所有的文件之间按列合并</li><li>注意与cat命令合并文件的区别：<ul><li>cat只能按列合并文件</li><li>paste默认按行合并，如果指定-s参数之后进行先在一个文件内部按指定的分隔符将所有的行合并，然后在所有的文件之间按列合并</li></ul></li></ul><h2 id="paste命令格式"><a href="#paste命令格式" class="headerlink" title="paste命令格式"></a>paste命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  paste [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p>Write lines consisting of the sequentially corresponding lines from each FILE, separated by TABs, to standard output.<br>With <strong>no FILE</strong>, or when FILE is <code>-</code>, <strong>read standard input</strong>.</p><hr><h2 id="paste命令参数"><a href="#paste命令参数" class="headerlink" title="paste命令参数"></a>paste命令参数</h2><table><tr><th width="10%">参数</th><th width="20%">完整参数</th><th width="70%">说明</th></tr><tr><td><code>-d</code></td><td><code>--delimiters=LIST</code></td><td>设置分割字符，默认为tab</td></tr><tr><td><code>-s</code></td><td><code>--serial</code></td><td>先在文件内部按指定的分隔符合并行，然后所有的文件之间按列合并</td></tr></table><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat test1.txt<br>1<br>2<br>3</p></blockquote><blockquote><p>cat test2.txt<br>a<br>b<br>c</p></blockquote><blockquote><p>cat test3.txt<br>d<br>e<br>f<br>g</p></blockquote><blockquote><p>cat test4.txt<br>a<br>c<br>b</p></blockquote><hr><h3 id="默认连接文件"><a href="#默认连接文件" class="headerlink" title="默认连接文件"></a>默认连接文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下以tab分隔两个不同的文件内容</span></span><br><span class="line">paste test1.txt test2.txt |cat -T</span><br><span class="line"><span class="comment"># cat -T显示tab为^I</span></span><br><span class="line">  1^Ia</span><br><span class="line">  2^Ib</span><br><span class="line">  3^Ic</span><br></pre></td></tr></table></figure><hr><h3 id="d-设置分隔符"><a href="#d-设置分隔符" class="headerlink" title="-d-设置分隔符"></a>-d-设置分隔符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置分隔符为$</span></span><br><span class="line">paste -d <span class="string">'$'</span> test1.txt test2.txt</span><br><span class="line">1<span class="variable">$a</span></span><br><span class="line">2<span class="variable">$b</span></span><br><span class="line">3<span class="variable">$c</span></span><br></pre></td></tr></table></figure><hr><h3 id="s-设置按列合并"><a href="#s-设置按列合并" class="headerlink" title="-s-设置按列合并"></a>-s-设置按列合并</h3><p><code>-s</code>参数相当于<strong>先将每一个文件内部按照指定的分隔符进行合并</strong>，然后<strong>再和另一个文件按列进行合并</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paste -d <span class="string">'$'</span> -s test1.txt test2.txt </span><br><span class="line">  <span class="comment"># 先在文件内部合并为一行，然后两个文件按列合并</span></span><br><span class="line">  1<span class="variable">$2</span><span class="variable">$3</span></span><br><span class="line">  a<span class="variable">$b</span><span class="variable">$c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独的一个文件内部合并为一行</span></span><br><span class="line">paste -d <span class="string">'$'</span> -s test1.txt </span><br><span class="line">1<span class="variable">$2</span><span class="variable">$3</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="行数不同"><a href="#行数不同" class="headerlink" title="行数不同"></a>行数不同</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于合并的文件如果行数不同，则会空行</span></span><br><span class="line"><span class="comment"># 不会报错</span></span><br><span class="line">paste test1.txt test3.txt </span><br><span class="line">  1d</span><br><span class="line">  2e</span><br><span class="line">  3f</span><br><span class="line">    g</span><br></pre></td></tr></table></figure><hr><h3 id="文件未排序"><a href="#文件未排序" class="headerlink" title="文件未排序"></a>文件未排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paste test1.txt test4.txt </span><br><span class="line"><span class="comment"># 文件未排序也能正常合并</span></span><br><span class="line">  1a</span><br><span class="line">  2c</span><br><span class="line">  3b</span><br></pre></td></tr></table></figure><hr><h3 id="cat-按列合并"><a href="#cat-按列合并" class="headerlink" title="cat-按列合并"></a>cat-按列合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt test2.txt </span><br><span class="line"><span class="comment"># 按列合并</span></span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br></pre></td></tr></table></figure><hr><h3 id="标准输出的特殊用法"><a href="#标准输出的特殊用法" class="headerlink" title="标准输出的特殊用法"></a>标准输出的特殊用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[user@localhost paste]$ cat test1.txt |paste -</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"><span class="comment"># 一个-表示从前面读取一行用于合并</span></span><br><span class="line"><span class="comment"># 可以将一行看做一个文件</span></span><br><span class="line">[user@localhost paste]$ cat test1.txt |paste - -</span><br><span class="line">12</span><br><span class="line">3</span><br><span class="line">[user@localhost paste]$ cat test1.txt |paste - - -</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows和Linux下使用tree命令</title>
      <link href="/posts/15686.html"/>
      <url>/posts/15686.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p><code>tree</code>命令可以<strong>以树的形式显示文件夹的结构</strong>，便于观察，这里记录了在<code>windows</code>和<code>linux</code>平台上安装和使用<code>tree</code>命令的过程。</p></div><a id="more"></a><h2 id="windows下简便用法"><a href="#windows下简便用法" class="headerlink" title="windows下简便用法"></a>windows下简便用法</h2><p>在<code>git bash</code>中使用命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd //c tree</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文件夹 PATH 列表</span><br><span class="line">卷序列号为 AC83-2977</span><br><span class="line">D:.</span><br><span class="line">├─docs</span><br><span class="line">│  ├─css</span><br><span class="line">│  ├─img</span><br><span class="line">│  ├─js</span><br><span class="line">│  ├─projects</span><br><span class="line">│  ├─resource</span><br><span class="line">│  └─software</span><br><span class="line">└─site</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：这个在<code>cmd</code>中<strong>不能使用</strong></p></div><hr><h2 id="windows下安装使用"><a href="#windows下安装使用" class="headerlink" title="windows下安装使用"></a>windows下安装使用</h2><ul><li><p>从<a href="http://gnuwin32.sourceforge.net/packages/tree.htm" target="_blank" rel="noopener">这个链接</a>中下载<a href="http://downloads.sourceforge.net/gnuwin32/tree-1.5.2.2-setup.exe" target="_blank" rel="noopener">tree-1.5.2.2-setup.exe</a>文件，然后进行常规的<strong>安装步骤</strong>，<strong>得到</strong><code>tree.exe</code>文件;</p></li><li><p>然后将<strong>安装得到</strong>的<code>tree.exe</code>文件<strong>复制到Git的安装目录</strong>：<code>C:\Program Files\Git\usr\bin</code>，注意<strong>一定要是usr下的这个目录</strong>，<strong>不能直接放在git下的bin目录</strong>;</p></li><li><p>最后在<code>git bash</code>下就可以使用tree命令了，<code>cmd</code>下在执行tree-1.5.2.2-setup.exe安装之后就可以使用，<strong>不过使用局限较大，只有两个参数，默认显示所有的文件夹，可以使用<code>/F</code>显示所有的文件</strong>:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd下使用</span></span><br><span class="line"><span class="comment"># 不加参数，直接指定文件夹</span></span><br><span class="line">tree chIA-drop</span><br><span class="line">  文件夹 PATH 列表</span><br><span class="line">  卷序列号为 CC05-4904</span><br><span class="line">  C:\USERS\user\DESKTOP\CHIA-DROP</span><br><span class="line">  └─scripts</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd下查看命令帮助</span></span><br><span class="line">tree /?</span><br><span class="line">以图形显示驱动器或路径的文件夹结构。</span><br><span class="line"></span><br><span class="line">TREE [drive:][path] [/F] [/A]</span><br><span class="line"><span class="comment"># 可以发现cmd下只有两个参数</span></span><br><span class="line">   /F   显示每个文件夹中文件的名称。</span><br><span class="line">   /A   使用 ASCII 字符，而不使用扩展字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># git bash下可以正常使用</span></span><br></pre></td></tr></table></figure><hr><h2 id="Linux下安装使用"><a href="#Linux下安装使用" class="headerlink" title="Linux下安装使用"></a>Linux下安装使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要管理员权限</span></span><br><span class="line">yum install tree -y</span><br></pre></td></tr></table></figure><hr><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree命令行参数：</span><br><span class="line"></span><br><span class="line">-a 显示所有文件和目录。</span><br><span class="line">-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span><br><span class="line">-C 在文件和目录清单加上色彩，便于区分各种类型。</span><br><span class="line">-d 显示目录名称而非内容。</span><br><span class="line">-D 列出文件或目录的更改时间。</span><br><span class="line">-f 在每个文件或目录之前，显示完整的相对路径名称。</span><br><span class="line">-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"="</span>,<span class="string">"@"</span>,<span class="string">"|"</span>号。</span><br><span class="line">-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span><br><span class="line">-i 不以阶梯状列出文件或目录名称。</span><br><span class="line">-I 不显示符合范本样式的文件或目录名称。</span><br><span class="line">-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span><br><span class="line">-n 不在文件和目录清单加上色彩。</span><br><span class="line">-N 直接列出文件和目录名称，包括控制字符。</span><br><span class="line">-p 列出权限标示。</span><br><span class="line">-P 只显示符合范本样式的文件或目录名称。</span><br><span class="line">-q 用<span class="string">"?"</span>号取代控制字符，列出文件和目录名称。</span><br><span class="line">-s 列出文件或目录大小。</span><br><span class="line">-t 用文件和目录的更改时间排序。</span><br><span class="line">-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span><br><span class="line">-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.computerhope.com/unix/tree.htm" target="_blank" rel="noopener">Linux tree command</a></li><li><a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener">tree(1) - Linux man page</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网</title>
      <link href="/posts/43102.html"/>
      <url>/posts/43102.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了<strong>使用xx-net进行科学上网的过程，包括安装、配置以及在使用中遇到的问题和解决</strong>；最后采取的科学上网策略是在蓝灯流量没使用完之前<strong>先使用蓝灯</strong>，蓝灯流量用完之后<strong>再使用xx-net</strong>。</p></div><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>XX-net</strong>：</p><ul><li><strong>下载地址</strong>：<a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="noopener">地址</a></li><li><strong>使用chrome浏览器的配置</strong>：<a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">Chrome</a></li></ul><p><strong>优点</strong>：</p><ul><li><strong>免费</strong></li><li>操作简单</li><li><strong>速度还可以</strong></li><li><strong>比较稳定</strong></li></ul><p><strong>蓝灯</strong>：</p><ul><li>下载地址：<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">地址</a></li><li><strong>优点</strong>：<ul><li>稳定</li><li>速度很快</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>免费</strong>的只有500M流量每个月</li><li><strong>专业版</strong>的每年要差不多180RMB(好贵。。。)</li></ul></li></ul><div class="note info"><p>所以可以<strong>先使用蓝灯(快)</strong>啊，然后等蓝灯<strong>流量用完之后再使用xx-net(免费、慢)</strong>，感觉自己有点小机灵~~~~</p></div><p>接下来<strong>主要介绍自己安装配置xx-net的步骤和遇到的问题</strong>，<strong>蓝灯的使用非常简单，直接下载安装就可以使用了</strong>。</p><hr><h2 id="安装配置过程"><a href="#安装配置过程" class="headerlink" title="安装配置过程"></a>安装配置过程</h2><h3 id="运行start-bat"><a href="#运行start-bat" class="headerlink" title="运行start.bat"></a>运行start.bat</h3><p>通过执行start.bat来完成xx-net的相关配置，我在这一步遇到了<code>运行之后浏览器不能上网，并且出现错误</code>，具体的解决方案见出现的问题及解决章节。</p><p>正常运行完成之后就会得到一个<strong>XX-NET的快捷方式</strong>，以后只用<strong>双击这个快捷方式</strong>就可以运行xx-net。</p><hr><h3 id="设置ipv6"><a href="#设置ipv6" class="headerlink" title="设置ipv6"></a>设置ipv6</h3><p>按照xx-net的说明，其主要有<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener"><code>GAE_proxy</code>和<code>X-Tunnel</code></a>，其中的<strong>GAE_proxy是免费</strong>的，有免费的当然使用免费的呀，但是其需要<code>开启IPV6</code>，可以按照官方给定的教程来来开启，官方提供了<a href="https://github.com/XX-net/XX-Net/wiki/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFIPv6" target="_blank" rel="noopener">mac、windows(7、10)、Linux的不同开启说明</a>，我这里选择了<a href="https://github.com/XX-net/XX-Net/wiki/IPv6-Win10" target="_blank" rel="noopener">win10教程</a>，其中有个简单的开启方法：运行<code>code\default\gae_proxy\local\ipv6_tunnel</code>目录下的<code>enable_ipv6.bat</code>文件即可开启，当然<strong>也可以手动开启</strong>，具体按照上面的教程。</p><hr><h3 id="设置自动代理"><a href="#设置自动代理" class="headerlink" title="设置自动代理"></a>设置自动代理</h3><p>ipv6开启之后再按照<a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">官方设置代理教程</a>的简单方法就可以访问谷歌等国外网站，但是<strong>这的缺点是</strong>：<strong>访问国内网站(不用科学上网的网站)也会很慢</strong>，这个时候就可以<strong>使用谷歌的浏览器插件来进行自动代理切换</strong>，这个在官方的设置代理教程中也有给出。</p><p><a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8#%E6%96%B9%E6%A1%88%E4%BA%8C%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E5%88%87%E6%8D%A2%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener">具体步骤</a></p><ul><li>建议在谷歌浏览器插件中下载安装<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a></li></ul><hr><h2 id="出现的问题以及解决"><a href="#出现的问题以及解决" class="headerlink" title="出现的问题以及解决"></a>出现的问题以及解决</h2><h3 id="启动start-bat之后浏览器不能上网，并且出现错误"><a href="#启动start-bat之后浏览器不能上网，并且出现错误" class="headerlink" title="启动start.bat之后浏览器不能上网，并且出现错误"></a>启动start.bat之后浏览器不能上网，并且出现错误</h3><p>错误信息如下：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/xx-net错误.png" alt="xx-net错误.png"></p><ul><li>首先，<strong>解决浏览器不能上网</strong>：chrome浏览器设置—&gt;高级设置—&gt;系统(打开代理设置)—&gt;局域网(LAN)设置按下图修改</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/xx-net不能上网.png" alt="xx-net不能上网.png"></p><ul><li><p>接下来，<strong>修改xx-net配置文件</strong>：<code>XX-Net-3.13.1\data\launcher\config.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules:</span><br><span class="line">  gae_proxy: &#123;auto_start: 1&#125;</span><br><span class="line">  launcher: &#123;allow_remote_connect: 0, control_port: 8085, last_run_version: 3.13.1,</span><br><span class="line">    proxy: pac&#125;</span><br><span class="line">  smart_router: &#123;auto_start: 1&#125;</span><br><span class="line">  <span class="comment"># 将这里的1改为0</span></span><br><span class="line">  x_tunnel: &#123;auto_start: 1&#125;</span><br><span class="line">update: &#123;last_path: <span class="string">'C:\Users\user\Desktop\XX-Net-3.13.1\XX-Net-3.13.1\code\default\launcher'</span>,</span><br><span class="line">  postUpdateStat: noChange, uuid: a58ace84-79fb-4dd5-bcc8-8c36e7cde706&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>然后再次执行start.bat即可</strong></p></li></ul><hr><h2 id="其他工具和方法"><a href="#其他工具和方法" class="headerlink" title="其他工具和方法"></a>其他工具和方法</h2><ul><li>youtube上的这个视频介绍了一种使用<strong>shadowsocks</strong>的方法，使用免费的ip和密码来实现翻墙，具体的<a href="https://www.youtube.com/watch?v=D81vP_o0-6o" target="_blank" rel="noopener">视频链接</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之subprocess-子进程管理</title>
      <link href="/posts/57519.html"/>
      <url>/posts/57519.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python常用模块<code>subprocess</code>，这是一个<strong>子进程管理的模块</strong>，用来<strong>在Python代码中执行操作系统级别的命令</strong>(如linux下的命令行命令)；主要学习了其中的两大API：<code>subprocess.run()</code>和<code>subprocess.Popen()</code>，学习了如何<strong>传递要执行的命令</strong>、如何<strong>获取命令的退出状态码(returncode)</strong>、<strong>输出(stdout)</strong>、<strong>错误(stderr)</strong>以及<strong>如何与进程交互</strong>等。</p></div><a id="more"></a><h2 id="subprocess模块简介"><a href="#subprocess模块简介" class="headerlink" title="subprocess模块简介"></a>subprocess模块简介</h2><p><code>subprocess</code>模块主要用于<strong>创建</strong>子进程，并<strong>连接它们的输入、输出和错误管道</strong>，<strong>获取它们的返回状态</strong>。通俗地说就是通过这个模块，你可以<strong>在Python的代码里执行操作系统级别的命令</strong>，比如<code>ipconfig</code>、<code>du -sh</code>等等。<code>subprocess</code>模块替代了一些老的模块(<code>os</code>模块)和函数，比如：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system</span><br><span class="line">os.spawn*</span><br></pre></td></tr></table></figure><p></p><p><code>subprocess</code>过去版本中的<code>call()</code>，<code>check_call()</code>和<code>check_output()</code>已经被<code>run()</code>方法取代了，<code>run()</code>方法为3.5版本新增。</p><p><strong>大多数情况下</strong>，<strong>推荐使用<code>run()</code>方法调用子进程，执行操作系统命令</strong>。在<strong>更高级</strong>的使用场景，你还可以使用<code>Popen</code>接口。<strong>其实run()方法在底层调用的就是Popen接口。</strong></p><hr><h2 id="运行外部命令-subprocess-run"><a href="#运行外部命令-subprocess-run" class="headerlink" title="运行外部命令-subprocess.run()"></a>运行外部命令-subprocess.run()</h2><h3 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.run(args, *, stdin=<span class="keyword">None</span>, input=<span class="keyword">None</span>,\</span><br><span class="line">               stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, shell=<span class="keyword">False</span>, \</span><br><span class="line">               timeout=<span class="keyword">None</span>, check=<span class="keyword">False</span>, \</span><br><span class="line">               encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>执行<code>args</code>参数所表示的命令，等待命令结束，并返回一个<code>CompletedProcess</code>实例，可以获取其属性的值。</p><hr><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>args</code>：表示<strong>要执行的命令</strong>，必须是<strong>一个字符串</strong>或者<strong>字符串参数列表</strong>；<strong>推荐使用字符串列表</strong>的形式，这样可以处理任何必要的转义和引用参数(例如，允许文件名中的空格)，如果传递<strong>单个字符串</strong>，则<code>shell</code>必须为True，<strong>或者</strong>字符串必须简单地命名要执行的程序而不指定任何参数</li><li><code>stdin</code>、<code>stdout</code>和<code>stderr</code>：<strong>子进程的标准输入</strong>、<strong>输出</strong>和<strong>错误</strong>；其值可以是：<ul><li><code>subprocess.PIPE</code>：表示为子进程创建新的管道</li><li><code>subprocess.DEVNULL</code>：表示使用<code>os.devnull</code>，类似于Linux下的/dev/nulls</li><li><strong>一个已经存在的文件描述符</strong></li><li><strong>已经打开的文件对象</strong></li><li><strong>None</strong>，这是<strong>默认的设置</strong>，表示什么都不做，结果输出到父进程上(如控制台)</li><li>另外，<code>stderr</code>可以合并到<code>stdout</code>里一起输出</li></ul></li><li><code>timeout</code>：<strong>设置命令超时时间</strong>；如果<strong>命令执行时间超时</strong>，<strong>子进程将被杀死</strong>，并弹出<code>TimeoutExpired</code>异常</li><li><code>check</code>：如果该参数设置为<code>True</code>，并且进程<strong>退出状态码不是0</strong>，则弹出<code>CalledProcessError</code>异常</li><li><code>encoding</code>：如果<strong>指定了该参数</strong>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>可以接收或输出<strong>字符串</strong>数据，并以该编码方式编码，<strong>否则只接收或输出bytes类</strong>型的数据</li><li><code>shell</code>：如果该参数为True，将<strong>通过操作系统的shell执行指定的命令</strong></li></ul><div class="note info"><p>关于<a href="https://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">文件描述符和文件对象的区别</a>：</p><ul><li><strong>文件描述符</strong>是Linux内核为了<strong>高效管理已被打开的文件或其他输入输出资源所创建的索引</strong>，其是一个非负整数(通常是小整数)，<strong>用于指代被打开的文件或其他输入输出资源</strong>，<strong>所有执行I/O操作的系统调用都通过文件描述符</strong>；常见的，<strong>0(标准输入)</strong>、<strong>1(标准输出)</strong>、<strong>2(标准错误输出)</strong>都是文件描述符(程序开始时这三个就已经存在，然后打开的第一个文件的文件描述符就是3)。(In <strong>Unix and related</strong> computer operating systems, a <strong>file descriptor (FD, less frequently fildes)</strong> is an abstract indicator (handle) <strong>used to access a file</strong> or <strong>other input/output resource</strong>, such as a pipe or network socket.)</li><li><strong>每一个文件描述符会与一个打开文件相对应</strong>，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为<strong>每一个进程</strong>维护了一个<strong>文件描述符表</strong>，该表的<strong>值都是从0开始的</strong>，所以<strong>在不同的进程中你会看到相同的文件描述符</strong>，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。</li><li><strong>文件对象</strong>是在文件被打开时创建的一个<code>file</code>结构组成，Python的<code>open()</code>方法就是打开并创建一个文件对象</li></ul></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="args参数使用-字符串和字符串列表"><a href="#args参数使用-字符串和字符串列表" class="headerlink" title="args参数使用-字符串和字符串列表"></a>args参数使用-字符串和字符串列表</h4><p><code>args</code>参数表示<strong>要执行的命令</strong>，必须是<strong>一个字符串</strong>或者<strong>字符串参数列表</strong>；<strong>推荐使用字符串列表</strong>的形式，这样可以<strong>避免转义以及其他会被 shell 解析的特殊字符</strong>，如果传递<strong>单个字符串</strong>，则<code>shell</code>必须为True，<strong>或者</strong>字符串必须简单地命名要执行的程序而不指定任何参数:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单个字符串</span></span><br><span class="line">subprocess.run(<span class="string">"ls"</span>)</span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls'</span>, returncode=<span class="number">0</span>)</span><br><span class="line">subprocess.run(<span class="string">'ls'</span>)</span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls'</span>, returncode=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 当单个字符串中间有空格时会出错</span></span><br><span class="line"><span class="comment"># 这样会导致命令不能传递参数</span></span><br><span class="line">subprocess.run(<span class="string">'ls -l'</span>) <span class="keyword">or</span> subprocess.run(<span class="string">"ls -l"</span>)</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">472</span>, <span class="keyword">in</span> run</span><br><span class="line">      <span class="keyword">with</span> Popen(*popenargs, **kwargs) <span class="keyword">as</span> process:</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">775</span>, <span class="keyword">in</span> __init__</span><br><span class="line">      restore_signals, start_new_session)</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">1522</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">      <span class="keyword">raise</span> child_exception_type(errno_num, err_msg, err_filename)</span><br><span class="line">  FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'ls -l'</span>: <span class="string">'ls -l'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单个字符串传递参数，并且制定shell=True</span></span><br><span class="line"><span class="comment"># 就可以传递参数了</span></span><br><span class="line">subprocess.run(<span class="string">"ls -l"</span>,shell=<span class="keyword">True</span>)</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line">  CompletedProcess(args=<span class="string">'ls -l'</span>, returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用的是字符串列表，针对上面不能传递参数的行为就可以改善</span></span><br><span class="line"><span class="comment"># 避免转义引号以及其他会被 shell 解析的特殊字符</span></span><br><span class="line"><span class="comment"># 如果需要传递参数不需要指定shell=True</span></span><br><span class="line">subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>])</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-l'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在使用字符串列表之后还指定了shell=True</span></span><br><span class="line"><span class="comment"># 只会执行字符串列表的第一个</span></span><br><span class="line"><span class="comment"># 字符串列表剩余部分会被舍弃</span></span><br><span class="line">subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>],shell=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 只输出了ls的结果</span></span><br><span class="line">  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt</span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-l'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的返回结果都是CompletedProcess 实例，包含进程退出码以及输出等信息</span></span><br><span class="line"><span class="comment"># 可以通过属性的方式获取其值</span></span><br><span class="line">test=subprocess.run(<span class="string">"ls -l"</span>,shell=<span class="keyword">True</span>)</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br><span class="line"><span class="comment"># 获取命令的退出状态码</span></span><br><span class="line">test.returncode</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>总结一下args参数的用法：</p><ul><li>如果命令是<strong>字符串</strong>，并且<strong>中间存在空格(给命令传递了参数)</strong>，<strong>必须</strong>加上参数<code>shell=True</code>，不然运行会出错，<strong>或者</strong>就<strong>是运行不加参数的命令(命令不能带空格)</strong></li><li>命令是<strong>字符串列表</strong>时，<strong>可以使用带参数的命令</strong>，这个时候就<strong>不能添加参数</strong><code>shell=True</code>，如果加上了<strong>不会出错</strong>，但是<strong>参数就会失效，只会运行单独的命令</strong></li><li>在<strong>不加</strong><code>shell=True</code>参数运行命令时，<strong>字符串不能存在空格(如<code>[&quot;ls&quot; &quot;-l &quot;]</code>、<code>&quot;ls &quot;</code>)</strong>，运行会报错</li><li>以上均为linux上的情况，<strong>windows下使用更加随意</strong>，<code>subprocess.run(&quot;ls -l&quot;)</code>、<code>subprocess.run(&quot;ls -l&quot;,shell=True)</code>、<code>subprocess.run([&quot;ls&quot;,&quot;-l&quot;])</code>、<code>subprocess.run([&quot;ls&quot;,&quot;-l&quot;],shell=True)</code><strong>运行结果都是一样的</strong>，都是<strong>正确</strong>答案。</li></ul></div><hr><h4 id="stdin、stdout和stderr-控制子进程的输入、输出和错误"><a href="#stdin、stdout和stderr-控制子进程的输入、输出和错误" class="headerlink" title="stdin、stdout和stderr-控制子进程的输入、输出和错误"></a>stdin、stdout和stderr-控制子进程的输入、输出和错误</h4><p><code>stdin</code>、<code>stdout</code>和<code>stderr</code>：<strong>子进程的标准输入</strong>、<strong>输出</strong>和<strong>错误</strong>；其值可以是：</p><ul><li><code>subprocess.PIPE</code>：表示为子进程创建新的管道</li><li><code>subprocess.DEVNULL</code>：表示使用<code>os.devnull</code></li><li><strong>一个已经存在的文件描述符</strong></li><li><strong>已经打开的文件对象</strong></li><li><strong>None</strong>，这是<strong>默认的设置</strong>，表示什么都不做，结果输出到父进程上</li><li>另外，<code>stderr</code>可以合并到<code>stdout</code>里一起输出</li></ul><p>默认情况下，由 <code>run()</code> 启动的进程的<strong>标准输入输出渠道绑定在了父进程上</strong>，那就意味着<strong>调用程序不能捕获命令的输出(前面实例中直接输出在控制台上)</strong>，给 <code>stdout</code> 和 <code>stderr</code> 参数传递 <code>PIPE</code> 可以捕获输出用于后续处理:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子进程创建新的管道</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE)</span><br><span class="line">completed</span><br><span class="line">  <span class="comment"># 看到返回的这个实例中间的stdout中有结果</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-1'</span>], returncode=<span class="number">0</span>, stdout=<span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不创建管道作为对比</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>])</span><br><span class="line">  test1.txt</span><br><span class="line">  test2.txt</span><br><span class="line">  test3.txt</span><br><span class="line">  test4.txt</span><br><span class="line">  test5.txt</span><br><span class="line">completed</span><br><span class="line">  <span class="comment"># 这个返回的实例中不包含结果，结果被输出在上面的屏幕上</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'ls'</span>, <span class="string">'-1'</span>], returncode=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要输出子进程的返回值</span></span><br><span class="line"><span class="comment"># 同样是通过获取属性的值</span></span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 可以看到返回的结果是byte类型的</span></span><br><span class="line">  <span class="comment"># 这是以为我们没有设置encoding参数</span></span><br><span class="line">  <span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用utf-8进行解码</span></span><br><span class="line">completed.stdout.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接设置encoding参数就不用进行decode操作</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 直接返回字符串，不用进行decode操作</span></span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="stdin-使用文件与进程交互"><a href="#stdin-使用文件与进程交互" class="headerlink" title="stdin-使用文件与进程交互"></a>stdin-使用文件与进程交互</h4><p>前面提到<code>stdin</code>可以传入一个文件对象，这里将需要<strong>执行的命令</strong>写入文件，从而达到<strong>与进程通信的目的</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux下，先进入Python环境，然后执行文件中的命令</span></span><br><span class="line">fd = open(<span class="string">"cmd.txt"</span>,<span class="string">'r'</span>)</span><br><span class="line">ret = subprocess.run(<span class="string">"python"</span>, stdin=fd, stdout=subprocess.PIPE,shell=<span class="keyword">True</span>)</span><br><span class="line">print(ret.stdout)</span><br><span class="line">  <span class="comment"># 输出结果</span></span><br><span class="line">  <span class="string">b'hello world\\!\n'</span></span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="check-检查退出码"><a href="#check-检查退出码" class="headerlink" title="check-检查退出码"></a>check-检查退出码</h4><p><code>check</code>：如果该参数设置为<code>True</code>，并且进程<strong>退出状态码(<code>CompletedProcess</code> 的 <code>returncode</code> 属性)不是0</strong>，则弹出<code>CalledProcessError</code>异常:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不使用check=True，即使命令错误了，也不会报错</span></span><br><span class="line">subprocess.run([<span class="string">'false'</span>])</span><br><span class="line">  <span class="comment"># 命令执行不成功，返回状态码为1</span></span><br><span class="line">  CompletedProcess(args=[<span class="string">'false'</span>], returncode=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加check=True</span></span><br><span class="line"><span class="comment"># 会对命令的执行状态码进行检查，如果执行失败(不为0)，就报错</span></span><br><span class="line">subprocess.run([<span class="string">'false'</span>], check=<span class="keyword">True</span>)</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"/home/user/miniconda3/envs/learn/lib/python3.7/subprocess.py"</span>, line <span class="number">487</span>, <span class="keyword">in</span> run</span><br><span class="line">      output=stdout, stderr=stderr)</span><br><span class="line">  subprocess.CalledProcessError: Command <span class="string">'['</span>false<span class="string">']'</span> returned non-zero exit status <span class="number">1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subprocess.run([<span class="string">'false'</span>], check=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  ERROR: Command <span class="string">'['</span>false<span class="string">']'</span> returned non-zero exit status <span class="number">1.</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="encoding-输入、输出、错误编码方式"><a href="#encoding-输入、输出、错误编码方式" class="headerlink" title="encoding-输入、输出、错误编码方式"></a>encoding-输入、输出、错误编码方式</h4><p><code>encoding</code>：如果<strong>指定了该参数</strong>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>可以接收或输出<strong>字符串</strong>数据，并以该编码方式编码，<strong>否则只接收或输出bytes类</strong>型的数据:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子进程创建新的管道</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要输出子进程的返回值</span></span><br><span class="line"><span class="comment"># 同样是通过获取属性的值</span></span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 可以看到返回的结果是byte类型的</span></span><br><span class="line">  <span class="comment"># 这是以为我们没有设置encoding参数</span></span><br><span class="line">  <span class="string">b'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用utf-8进行解码</span></span><br><span class="line">completed.stdout.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接设置encoding参数就不用进行decode操作</span></span><br><span class="line">completed = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-1'</span>],stdout=subprocess.PIPE,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">completed.stdout</span><br><span class="line">  <span class="comment"># 直接返回字符串，不用进行decode操作</span></span><br><span class="line">  <span class="string">'test1.txt\ntest2.txt\ntest3.txt\ntest4.txt\ntest5.txt\n'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="CompletedProcess类"><a href="#CompletedProcess类" class="headerlink" title="CompletedProcess类"></a>CompletedProcess类</h3><p><code>run()</code>方法的返回值，表示<strong>一个进程结束了</strong>，<code>CompletedProcess</code>类有下面这些属性：</p><table><tr><th width="20%">属性</th><th width="80%">说明</th></tr><tr><td><code>args</code></td><td>进程运行的命令，通常是个字符串列表或字符串</td></tr><tr><td><code>returncode</code></td><td>进程结束状态返回码，0表示命令成功状态，非0表示不成功</td></tr><tr><td><code>stdout</code></td><td>获取子进程的stdout，通常为bytes类型序列(可以通过<code>ecoding</code>参数调整)，None表示没有捕获值。如果在调用run()方法时，设置了参数<code>stderr=subprocess.STDOUT</code>，则错误信息会和stdout一起输出，此时stderr的值是None</td></tr><tr><td><code>stderr</code></td><td>获取子进程的错误信息，通常为bytes类型序列，None表示没有捕获值</td></tr><tr><td><code>check_returncode()</code></td><td>用于检查返回码。如果返回状态码不为零，弹出<code>CalledProcessError</code>异常</td></tr></table><hr><h3 id="subprocess-DEVNULL-抑制输出"><a href="#subprocess-DEVNULL-抑制输出" class="headerlink" title="subprocess.DEVNULL-抑制输出"></a>subprocess.DEVNULL-抑制输出</h3><p>某些情况下，<strong>输出不应该被展示和捕获</strong>，使用 <code>subprocess.DEVNULL</code> 抑制输出流(Linux下的/dev/null)：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span></span><br><span class="line"><span class="comment"># 上述命令会有一个错误输出to stderr</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    completed = subprocess.run(</span><br><span class="line">        <span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>,</span><br><span class="line">        shell=<span class="keyword">True</span>,</span><br><span class="line">        stdout=subprocess.DEVNULL,</span><br><span class="line">        stderr=subprocess.DEVNULL,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'returncode:'</span>, completed.returncode)</span><br><span class="line">    print(<span class="string">'stdout is &#123;!r&#125;'</span>.format(completed.stdout))</span><br><span class="line">    print(<span class="string">'stderr is &#123;!r&#125;'</span>.format(completed.stderr))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行结果不会输出到控制台，应为设置了stdout和stderr</span></span><br><span class="line"><span class="comment"># 同时也不会被捕获，因为设置的值为subprocess.DEVNULL，相当于是无底洞</span></span><br><span class="line">returncode: <span class="number">1</span></span><br><span class="line">stdout <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line">stderr <span class="keyword">is</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="subprocess-STDOUT-合并标准错误和输出"><a href="#subprocess-STDOUT-合并标准错误和输出" class="headerlink" title="subprocess.STDOUT-合并标准错误和输出"></a>subprocess.STDOUT-合并标准错误和输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    completed = subprocess.run(</span><br><span class="line">        <span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>,</span><br><span class="line">        shell=<span class="keyword">True</span>,</span><br><span class="line">        stdout=subprocess.PIPE,</span><br><span class="line">        stderr=subprocess.STDOUT,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'ERROR:'</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'returncode:'</span>, completed.returncode)</span><br><span class="line">    print(<span class="string">'stdout is &#123;!r&#125;'</span>.format(completed.stdout))</span><br><span class="line">    print(<span class="string">'stderr is &#123;!r&#125;'</span>.format(completed.stderr))</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CompletedProcess类</span></span><br><span class="line">CompletedProcess(args=<span class="string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span>, returncode=<span class="number">1</span>, stdout=<span class="string">b'to stdout\nto stderr\n'</span>)</span><br><span class="line"></span><br><span class="line">returncode: <span class="number">1</span></span><br><span class="line"><span class="comment"># stdout合并了stderr的输出</span></span><br><span class="line">stdout <span class="keyword">is</span> <span class="string">b'to stdout\nto stderr\n'</span></span><br><span class="line"><span class="comment"># 输出在了stdout中，所以这里就成了空值</span></span><br><span class="line">stderr <span class="keyword">is</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：错误输出合并输出在了<code>stdout</code>中之后，<code>CompletedProcess</code>实例中的 <strong><code>stderr</code>属性就成了空值</strong></p></div><hr><p><br></p><h2 id="更高级的使用场景-subprocess-Popen"><a href="#更高级的使用场景-subprocess-Popen" class="headerlink" title="更高级的使用场景-subprocess.Popen()"></a>更高级的使用场景-subprocess.Popen()</h2><h3 id="命令形式-1"><a href="#命令形式-1" class="headerlink" title="命令形式"></a>命令形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.Popen(args, bufsize=<span class="number">-1</span>, executable=<span class="keyword">None</span>, \</span><br><span class="line">                 stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, preexec_fn=<span class="keyword">None</span>, \</span><br><span class="line">                 close_fds=<span class="keyword">True</span>, shell=<span class="keyword">False</span>, cwd=<span class="keyword">None</span>, env=<span class="keyword">None</span>, \</span><br><span class="line">                 universal_newlines=<span class="keyword">None</span>, startupinfo=<span class="keyword">None</span>, \</span><br><span class="line">                 creationflags=<span class="number">0</span>, restore_signals=<span class="keyword">True</span>, \</span><br><span class="line">                 start_new_session=<span class="keyword">False</span>, pass_fds=(), *, \</span><br><span class="line">                 encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, text=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>功能与<code>run()</code>方法基本类同，但是它的<strong>返回值是一个<code>Popen</code>实例</strong>，而<strong>不是<code>CompletedProcess</code>实例</strong></p><hr><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><p>大部分的参数都和<code>subprocess.run()</code>中的用法相同，这里列出几个这里特有的参数：</p><ul><li><code>cwd</code>： 如果该参数值<strong>不是None</strong>，则该函数将会在执行这个子进程之前<strong>改变当前工作目录</strong></li><li><code>env</code>： 用于<strong>指定子进程的环境变量</strong>，如果<code>env=None</code>，那么子进程的环境变量将<strong>从父进程中继承</strong>；如果<code>env!=None</code>，它的值必须是一个<strong>映射对象</strong></li></ul><hr><h3 id="可调用方法"><a href="#可调用方法" class="headerlink" title="可调用方法"></a>可调用方法</h3><table><tr><th width="30%">方法</th><th width="70%">描述</th></tr><tr><td><code>Popen.poll()</code></td><td>用于检查子进程（命令）是否已经执行结束，没结束返回None，结束后返回状态码</td></tr><tr><td><code>Popen.wait(timeout=None)</code></td><td>等待子进程结束，并返回状态码；如果在timeout指定的秒数之后进程还没有结束，将会抛出一个TimeoutExpired异常</td></tr><tr><td><code>Popen.communicate(input=None, timeout=None)</code></td><td>该方法可用来与进程进行交互，比如发送数据到stdin，从stdout和stderr读取数据，直到到达文件末尾</td></tr><tr><td><code>Popen.send_signal(signal)</code></td><td>发送指定的信号给这个子进程</td></tr><tr><td><code>Popen.terminate()</code></td><td>停止该子进程</td></tr><tr><td><code>Popen.kill()</code></td><td>杀死该子进程</td></tr></table><div class="note info"><p>关于<code>Popen.communicate()</code>方法的说明：</p><ul><li>该方法中的可选参数 <code>input</code> 应该是将<strong>被发送给子进程的数据</strong>，或者如没有数据发送给子进程，该参数应该是None。<code>input</code>参数的数据类型必须是<strong>字节串</strong>，如果<code>universal_newlines</code>参数值为<code>True</code>(或者<strong>设置<code>encoding</code>参数</strong>)，则<code>input</code>参数的数据类型<strong>必须是字符串</strong></li><li>该方法返回一个<code>元组(stdout_data, stderr_data)</code>，这些数据将会是<strong>字节串或字符串(如果<code>universal_newlines</code>的值为<code>True</code>,或者设置<code>encoding</code>参数)</strong></li><li>如果在<code>timeout</code>指定的秒数后该进程还没有结束，将会抛出一个<code>TimeoutExpired</code>异常，<strong>捕获这个异常</strong>，然后<strong>重新尝试通信不会丢失任何输出的数据</strong>，但是超时之后子进程并没有被杀死，为了合理的清除相应的内容，一个好的应用应该手动杀死这个子进程来结束通信</li><li>需要注意的是，这里读取的数据是<strong>缓冲在内存中</strong>的，所以，如果<strong>数据大小非常大或者是无限的，就不应该使用这个方法</strong></li></ul></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="获取命令结果"><a href="#获取命令结果" class="headerlink" title="获取命令结果"></a>获取命令结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p = subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">"ls"</span>,<span class="string">"-l"</span>], stdout=subprocess.PIPE)</span><br><span class="line"><span class="comment"># 返回的p和前面的不同</span></span><br><span class="line">p</span><br><span class="line">  &lt;subprocess.Popen object at <span class="number">0x7fcddff8a710</span>&gt;</span><br><span class="line"><span class="comment"># 使用属性的read方法获取结果</span></span><br><span class="line"><span class="comment"># read()只能读取一次，再读取一次结果就为空(读取一遍后文件指针到最后了)</span></span><br><span class="line">p.stdout.read()</span><br><span class="line">  <span class="string">b'total 4\n-rw-rw-r-- 1 user user 23 Apr  4 15:26 cmd.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test1.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test2.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test3.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test4.txt\n-rw-rw-r-- 1 user user  0 Apr  4 10:44 test5.txt\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用decode将输出的字节串解码为utf-8，并输出结果</span></span><br><span class="line">print(p.stdout.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">  total <span class="number">4</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">23</span> Apr  <span class="number">4</span> <span class="number">15</span>:<span class="number">26</span> cmd.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test2.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test3.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test4.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user  <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">44</span> test5.txt</span><br></pre></td></tr></table></figure><hr><h4 id="修改工作目录"><a href="#修改工作目录" class="headerlink" title="修改工作目录"></a>修改工作目录</h4><p><code>cwd</code>： 如果该参数值<strong>不是None</strong>，则该函数将会在执行这个子进程之前<strong>改变当前工作目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>,cwd=<span class="string">"./test"</span>)</span><br><span class="line"><span class="comment"># 使用decode将输出的字节串解码为utf-8，并输出结果</span></span><br><span class="line">print(p.stdout.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">  total <span class="number">0</span></span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">46</span> cwd1.txt</span><br><span class="line">  -rw-rw-r-- <span class="number">1</span> user user <span class="number">0</span> Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">46</span> cwd2.txt</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="Popen-communicate-使用"><a href="#Popen-communicate-使用" class="headerlink" title="Popen.communicate()使用"></a>Popen.communicate()使用</h4><ul><li>该方法返回一个<code>元组(stdout_data, stderr_data)</code>，这些数据将会是<strong>字节串或字符串(如果<code>universal_newlines</code>的值为<code>True</code>,或者设置<code>encoding</code>参数)</strong></li></ul><p><strong>与进程交互实例一</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj.stdin.write(<span class="string">'print(1)'</span>)</span><br><span class="line">  <span class="comment"># 直接输入字符会报错</span></span><br><span class="line">  <span class="comment"># 只能输入字节串</span></span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  TypeError: a bytes-like object <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="string">'str'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用encoding或者universal_newlines</span></span><br><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,\</span><br><span class="line">                        encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">obj = subprocess.Popen([<span class="string">"python"</span>], stdin=subprocess.PIPE, \</span><br><span class="line">                       stdout=subprocess.PIPE, stderr=subprocess.PIPE,\</span><br><span class="line">                       universal_newlines=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用obj.stdin.write来传递命令</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(1)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(2)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">obj.stdin.write(<span class="string">'print(3)'</span>)</span><br><span class="line">  <span class="comment"># 输出写入的字符长度，Python3新增的功能</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取返回的输出值和错误</span></span><br><span class="line">out,err = obj.communicate()</span><br><span class="line">out</span><br><span class="line">  <span class="string">'1\n2\n'</span></span><br><span class="line">err</span><br><span class="line">  <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用obj.communicate()的input参数来传递命令</span></span><br><span class="line">out,err = obj.communicate(input=<span class="string">'print(1)'</span>)</span><br><span class="line">out</span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  <span class="string">'1\n'</span></span><br><span class="line">err</span><br><span class="line">  <span class="string">''</span></span><br></pre></td></tr></table></figure><p></p><p><strong>与进程交互实例二</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'cat -; echo "to stderr" 1&gt;&amp;2'</span></span><br><span class="line"><span class="comment"># 获取标准输入</span></span><br><span class="line"><span class="comment"># 并且得到标准错误输出</span></span><br><span class="line">proc = subprocess.Popen(</span><br><span class="line">    <span class="string">'cat -; echo "to stderr" 1&gt;&amp;2'</span>,</span><br><span class="line">    shell=<span class="keyword">True</span>,</span><br><span class="line">    stdin=subprocess.PIPE,</span><br><span class="line">    stdout=subprocess.PIPE,</span><br><span class="line">    stderr=subprocess.PIPE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前面没有设置encoding参数以及universal_newlines参数</span></span><br><span class="line"><span class="comment"># 这使用encode来将字符串编码为字节串</span></span><br><span class="line">msg = <span class="string">'through stdin to stdout'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">stdout_value, stderr_value = proc.communicate(msg)</span><br><span class="line"><span class="comment"># 使用decode来将字节串解码为字符串</span></span><br><span class="line">print(<span class="string">'pass through:'</span>, repr(stdout_value.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">  <span class="comment"># 输出标准输出，cat -的运行结果</span></span><br><span class="line">  <span class="keyword">pass</span> through: <span class="string">'through stdin to stdout'</span></span><br><span class="line">print(<span class="string">'stderr      :'</span>, repr(stderr_value.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">  <span class="comment"># 输出标准错误，echo "to stderr" 1&gt;&amp;2的运行结果</span></span><br><span class="line">  <span class="comment"># 1&gt;&amp;2将标准输出重定向到标准错误输出</span></span><br><span class="line">  stderr      : <span class="string">'to stderr\n'</span></span><br></pre></td></tr></table></figure><p></p><p><strong>实现shell中管道符的实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">p1 = subprocess.Popen([<span class="string">'ls'</span>, <span class="string">'-l'</span>], stdout=subprocess.PIPE)</span><br><span class="line"><span class="comment"># 这里设置p2的输入为p1的输出</span></span><br><span class="line">p2 = subprocess.Popen([<span class="string">'grep'</span>, <span class="string">'cmd'</span>], stdin=p1.stdout, stdout=subprocess.PIPE)</span><br><span class="line">out,err = p2.communicate()</span><br><span class="line">out</span><br><span class="line">  <span class="string">b'-rw-rw-r-- 1 user user 23 Apr  4 15:26 cmd.txt\n'</span></span><br><span class="line">err</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果<strong>不想将结果输出在控制台上</strong>，可以设置<code>stdout</code>和<code>stderr</code>来<strong>捕获输出</strong></li><li>如果希望命令的运行不成功(退出状态码不为0)就爆出异常，可以设置<code>check=True</code>以及异常捕获</li><li>在使用<strong>字符串与进程通信</strong>以及<strong>输出结果</strong>的时候，需要注意设置<code>encoding</code>以及<code>universal_newlines</code>参数，不然<strong>命令会报错</strong>或者<strong>输出得到的是字节串</strong></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" target="_blank" rel="noopener">subprocess — Subprocess management</a></li><li><a href="http://www.liujiangblog.com/course/python/55" target="_blank" rel="noopener">subprocess</a></li><li><a href="https://www.cnblogs.com/yyds/p/7288916.html#4179829" target="_blank" rel="noopener">Python之系统交互（subprocess）</a></li><li><a href="https://learnku.com/docs/pymotw/subprocess-spawning-additional-processes/3419" target="_blank" rel="noopener">11.2. subprocess — 生成多余进程</a></li><li><a href="https://www.cnblogs.com/vamei/archive/2012/09/23/2698014.html" target="_blank" rel="noopener">Python标准库06 子进程 (subprocess包)</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之字符串与字符编码(转载)</title>
      <link href="/posts/59082.html"/>
      <url>/posts/59082.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，围绕Python中的字符串与字符编码<strong>比较了Python2和Python3在字节与字符串默认行为上的不同</strong>、<strong>结合Python源代码执行过程讲解了设置字符编码的作用</strong>以及<strong>不同字符编码之间的转换</strong>，是一篇非常实用和重要的文章。</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>Python中的字符编码是个老生常谈的话题，同行们都写过很多这方面的文章。有的人云亦云，也有的写得很深入。近日看到某知名培训机构的教学视频中再次谈及此问题，讲解的还是不尽人意，所以才想写这篇文字。一方面，梳理一下相关知识，另一方面，希望给其他人些许帮助。</p><blockquote><p><code>Python2</code>的 <strong><em>默认编码</em></strong> 是<code>ASCII</code>，<strong>不能识别中文字符</strong>，<strong>需要显式指定字符编码</strong>；<code>Python3</code>的 <strong><em>默认编码</em></strong> 为<code>Unicode</code>，<strong>可以识别中文字符</strong>。</p></blockquote><p>相信大家在很多文章中都看到过类似上面这样“对Python中中文处理”的解释，也相信大家在最初看到这样的解释的时候确实觉得明白了。可是时间久了之后，再重复遇到相关问题就会觉得貌似理解的又不是那么清楚了。如果我们了解上面说的默认编码的作用是什么，我们就会更清晰的明白那句话的含义。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><hr><h3 id="字符与字节"><a href="#字符与字节" class="headerlink" title="字符与字节"></a>字符与字节</h3><p><strong>一个字符不等价于一个字节</strong>，字符是人类能够识别的符号，而这些符号要保存到计算的存储中就需要用计算机能够识别的字节来表示。一个字符往往有多种表示方法，不同的表示方法会使用不同的字节数。这里所说的不同的表示方法就是指字符编码，比如字母<code>A-Z</code>都可以用<code>ASCII</code>码表示（占用一个字节），也可以用<code>UNICODE</code>表示（占两个字节），还可以用<code>UTF-8</code>表示（占用一个字节）。<strong>字符编码的作用就是将人类可识别的字符转换为机器可识别的字节码，以及反向过程</strong>。</p><p><strong><em>UNICDOE才是真正的字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串</em></strong> 。关于这点，我们可以在Python的官方文档中经常可以看到这样的描述<code>&quot;Unicode string&quot; , &quot; translating a Unicode string into a sequence of bytes&quot;</code></p><p>我们写代码是写在文件中的，而字符是以字节形式保存在文件中的，因此当我们在文件中定义个字符串时被当做字节串也是可以理解的。但是，我们需要的是字符串，而不是字节串。一个优秀的编程语言，应该严格区分两者的关系并提供巧妙的完美的支持。JAVA语言就很好，以至于了解Python和PHP之前我从来没有考虑过这些不应该由程序员来处理的问题。遗憾的是，很多编程语言试图混淆“字符串”和“字节串”，他们把字节串当做字符串来使用，PHP和Python2都属于这种编程语言。最能说明这个问题的操作就是取一个包含中文字符的字符串的长度：</p><ul><li>对字符串取长度，结果应该是所有字符的个数，无论中文还是英文</li><li>对字符串对应的字节串取长度，就跟编码(encode)过程使用的字符编码有关了(比如：UTF-8编码，一个中文字符需要用3个字节来表示；GBK编码，一个中文字符需要2个字节来表示)</li></ul><p><strong>注意</strong>：<code>Windows</code>的cmd终端字符编码默认为<code>GBK</code>，因此在cmd输入的中文字符需要用两个字节表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'Hello,中国'</span>  <span class="comment"># 字节串，长度为字节个数 = len('Hello,')+len('中国') = 6+2*2 = 10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">u'Hello,中国'</span>  <span class="comment"># 字符串，长度为字符个数 = len('Hello,')+len('中国') = 6+2 = 8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = unicode(a, <span class="string">'gbk'</span>)  <span class="comment"># 其实b的定义方式是c定义方式的简写，都是将一个GBK编码的字节串解码（decode）为一个Uniocde字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(a), len(a))</span><br><span class="line">(&lt;type <span class="string">'str'</span>&gt;, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(b), len(b))</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(c), len(c))</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">8</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>Python3中对字符串的支持做了很大的改动，具体内容会在下面介绍。</p><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>先做下科普：UNICODE字符编码，也是一张字符与数字的映射，但是这里的数字被称为<code>代码点(code point)</code>, <strong>实际上就是十六进制的数字</strong>。</p><p>Python官方文档中对Unicode字符串、字节串与编码之间的关系有这样一段描述：</p><blockquote><p>Unicode字符串是一个代码点（code point）序列，代码点取值范围为0到0x10FFFF（对应的十进制为1114111）。这个代码点序列在存储（包括内存和物理磁盘）中需要被表示为一组字节(0到255之间的值)，而将<strong>Unicode字符串转换为字节序列的规则称为编码</strong>。</p></blockquote><p>这里说的编码不是指字符编码，而是指编码的过程以及这个过程中所使用到的 <strong><em>Unicode字符的代码点与字节的映射规则</em></strong> 。这个映射不必是简单的一对一映射，因此编码过程也不必处理每个可能的Unicode字符，例如：</p><p><strong>将<code>Unicode字符串</code>转换为<code>ASCII编码</code></strong>的规则很简单–对于每个代码点：</p><ul><li>如果代码点数值&lt;128，则每个字节与代码点的值相同</li><li>如果代码点数值&gt;=128，则Unicode字符串无法在此编码中进行表示（这种情况下，Python会引发一个UnicodeEncodeError异常）</li></ul><p><strong>将<code>Unicode字符串</code>转换为<code>UTF-8编码</code></strong>使用以下规则：</p><ul><li>如果代码点数值&lt;128，则由相应的字节值表示（与Unicode转ASCII字节一样）</li><li>如果代码点数值&gt;=128，则将其转换为一个2个字节，3个字节或4个字节的序列，该序列中的每个字节都在128到255之间。</li></ul><div class="note info"><p>简单总结：</p><ul><li><strong><em>编码(encode)</em></strong> ：将Unicode<strong>字符串</strong>（中的代码点)<strong>转换</strong>特定字符编码对应的<strong>字节串</strong>的过程和规则</li><li><strong><em>解码(decode)</em></strong> ：将特定字符编码的<strong>字节串转换</strong>为对应的Unicode<strong>字符串</strong>(中的代码点)的过程和规则</li></ul></div><p>可见，无论是编码还是解码，都需要一个重要因素，就是 <strong><em>特定的字符编码</em></strong> 。因为一个字符用不同的字符编码进行编码后的字节值以及字节个数大部分情况下是不同的，反之亦然。</p><h2 id="Python中的默认编码"><a href="#Python中的默认编码" class="headerlink" title="Python中的默认编码"></a>Python中的默认编码</h2><hr><h3 id="Python源代码文件的执行过程"><a href="#Python源代码文件的执行过程" class="headerlink" title="Python源代码文件的执行过程"></a>Python源代码文件的执行过程</h3><p>我们都知道，<strong>磁盘上的文件都是以二进制格式存放的</strong>，其中<strong>文本文件都是以某种特定编码的字节形式存放的</strong>。对于<strong>程序源代码文件的字符编码是由<code>编辑器指定</code>的</strong>，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为<code>UTF-8</code>，那么Python代码被保存到磁盘时就会被转换为<code>UTF-8</code>编码对应的字节（<strong>encode过程</strong>）后写入磁盘。当<strong>执行Python代码</strong>文件中的代码时，<strong>Python解释器</strong>在读取Python代码文件中的字节串之后，需要<strong>将其转换为UNICODE字符串</strong>（<strong>decode过程</strong>）之后才执行后续操作。</p><p>上面已经解释过，这个<strong>转换过程（decode，解码）需要我们指定文件中保存的字节使用的字符编码是什么</strong>，才能知道这些字节在UNICODE这张万国码和统一码中找到其对应的代码点是什么。这里指定字符编码的方式大家都很熟悉，如下所示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用来指示Python解释器使用什么字符编码来将读取的字节串如何转化为字符串</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python字符编码过程_1.png" alt="Python字符编码过程_1.png"></p><h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><p>那么，如果我们<strong>没有在代码文件开始的部分指定字符编码</strong>，Python解释器就会使用哪种字符编码把从代码文件中读取到的字节转换为UNICODE代码点呢？就像我们配置某些软件时，有很多默认选项一样，需要在<strong>Python解释器内部设置默认的字符编码来解决这个问题</strong>，这就是文章开头所说的“默认编码”。因此大家所说的Python中文字符问题就可以总结为一句话： <strong><em>当无法通过默认的字符编码对字节进行转换时，就会出现解码错误(UnicodeEncodeError)</em></strong> 。</p><p><code>Python2</code>和<code>Python3</code>的解释器使用的<strong>默认编码是不一样</strong>的，我们可以通过<code>sys.getdefaultencoding()</code>来获取默认编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">'ascii'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><p>因此，对于<code>Python2</code>来讲，<strong>Python解释器</strong>在读取到中文字符的字节码尝试解码操作时，会<strong>先查看当前代码文件头部</strong>是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果<strong>没有指定则使用默认字符编码<code>&quot;ASCII&quot;</code>进行解码</strong>导致解码<strong>失败，导致如下错误</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p></p><p>对于<code>Python3</code>来讲，<strong>执行过程是一样的</strong>，只是Python3的<strong>解释器以<code>&quot;UTF-8&quot;</code>作为默认编码</strong>，但是这<strong>并不表示可以完全兼容中文问题</strong>。比如我们<strong>在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的</strong>。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，导致如下错误：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure><p></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>创建一个工程之后<strong>先确认该工程的字符编码是否已经设置为UTF-8(编辑器设置中设置)</strong> —&gt;<strong>用于指示代码会使用什么字符编码方式保存为字节串</strong></li><li>为了兼容Python2和Python3，在<strong>代码头部声明字符编码：<code>-*- coding:utf-8 -*-</code></strong> —&gt;<strong>用于指示Python解释器使用什么字符编码将读取的字节串转化为字符串</strong></li><li>另外地，在<strong>读写文件内容的时候也需要指定正确的文件字符的编码方式</strong>，这部分在<a href="http://showteeth.tech/posts/57951.html">Python系列之文件读写(转载)</a>中有所讲解。</li></ul><h2 id="Python2与Python3中对字符串的支持"><a href="#Python2与Python3中对字符串的支持" class="headerlink" title="Python2与Python3中对字符串的支持"></a>Python2与Python3中对字符串的支持</h2><hr><p>其实Python3中对字符串支持的改进，不仅仅是更改了默认编码，而是重新进行了字符串的实现，而且它已经实现了对UNICODE的内置支持，从这方面来讲Python已经和JAVA一样优秀。下面我们来看下 <strong><code>Python2</code>与<code>Python3</code>中对字符串的支持有什么区别</strong>：</p><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><p><code>Python2</code>中对字符串的支持由以下三个类提供:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">str</span><span class="params">(basestring)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">unicode</span><span class="params">(basestring)</span></span></span><br></pre></td></tr></table></figure><p></p><p>执行<code>help(str)</code>和<code>help(bytes)</code>会发现结果<strong>都是str类的定义</strong>，这也说明<code>Python2</code>中 <strong><code>str</code>就是字节串</strong>，而后来的 <strong><code>unicode</code>对象对应才是真正的字符串</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'你好'</span></span><br><span class="line">b = <span class="string">u'你好'</span></span><br><span class="line"></span><br><span class="line">print(type(a), len(a))</span><br><span class="line">print(type(b), len(b))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;type <span class="string">'str'</span>&gt;, <span class="number">6</span>)</span><br><span class="line">(&lt;type <span class="string">'unicode'</span>&gt;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><p><code>Python3</code>中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可以认为<code>Python3</code>中的<code>str</code>和<code>unicode</code><strong>合二为一</strong>了。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(object)</span></span></span><br></pre></td></tr></table></figure><p></p><p>实际上，Python3中已经意识到之前的错误，开始明确的区分字符串与字节。因此<code>Python3</code>中的 <strong><code>str</code>已经是真正的字符串</strong>，而<strong>字节是用单独的<code>bytes</code>类来表示</strong>。也就是说，<strong><code>Python3</code>默认定义的就是字符串，实现了对<code>UNICODE</code>的内置支持</strong>，减轻了程序员对字符串处理的负担。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'你好'</span></span><br><span class="line">b = <span class="string">u'你好'</span></span><br><span class="line">c = <span class="string">'你好'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line"></span><br><span class="line">print(type(a), len(a))</span><br><span class="line">print(type(b), len(b))</span><br><span class="line">print(type(c), len(c))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt; 2</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt; 4</span></span><br></pre></td></tr></table></figure><p></p><h2 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h2><hr><p>上面提到，<strong>UNICODE<code>字符串</code></strong>可以与<strong>任意字符编码的<code>字节</code></strong>进行<strong>相互转换</strong>，如图：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python字符串与字节的转换.png" alt="Python字符串与字节的转换.png"></p><p>那么大家很容易想到一个问题，就是不同的字符编码的字节可以通过Unicode相互转换吗？答案是肯定的。</p><h3 id="Python2中的字符串进行字符编码转换"><a href="#Python2中的字符串进行字符编码转换" class="headerlink" title="Python2中的字符串进行字符编码转换"></a>Python2中的字符串进行字符编码转换</h3><p><strong>转换过程</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节串--&gt;decode('原来的字符编码')--&gt;Unicode字符串--&gt;encode('新的字符编码')--&gt;字节串</span><br></pre></td></tr></table></figure><p></p><p><strong>转换实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python2中的utf_8_a为字节串</span></span><br><span class="line">utf_8_a = <span class="string">'我爱中国'</span></span><br><span class="line"><span class="comment"># 先将字节串decode为字符串，然后再将字符串encode为字节串</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gbk'</span>)</span><br><span class="line"><span class="comment"># 再使用decode转化为字符串输出</span></span><br><span class="line">print(gbk_a.decode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我爱中国</span><br></pre></td></tr></table></figure><h3 id="Python3中的字符串进行字符编码转换"><a href="#Python3中的字符串进行字符编码转换" class="headerlink" title="Python3中的字符串进行字符编码转换"></a>Python3中的字符串进行字符编码转换</h3><p>因为Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码，其过程为：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串--&gt;encode('新的字符编码')--&gt;字节串</span><br></pre></td></tr></table></figure><p></p><p><strong>转换实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">utf_8_a = <span class="string">'我爱中国'</span></span><br><span class="line">gbk_a = utf_8_a.encode(<span class="string">'gbk'</span>)</span><br><span class="line">print(gbk_a.decode(<span class="string">'gbk'</span>))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我爱中国</span><br></pre></td></tr></table></figure><p></p><p><strong>最后需要说明的是</strong>，<strong>Unicode不是有道词典</strong>，也不是google翻译器，它<strong>并不能把一个中文翻译成一个英文</strong>。正确的字符编码的转换过程只是把<strong>同一个字符的字节表现形式改变</strong>了，而<strong>字符本身的符号是不应该发生变化</strong>的，因此并不是所有的字符编码之间的转换都是有意义的。怎么理解这句话呢？比如GBK编码的“中国”转成UTF-8字符编码后，仅仅是由4个字节变成了6个字节来表示，但其字符表现形式还应该是“中国”，而不应该变成“你好”或者“China”。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">Python中的字符串与字符编码</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之覆盖之前输出的内容</title>
      <link href="/posts/38536.html"/>
      <url>/posts/38536.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用Python输出时进行<strong>覆盖输出(覆盖上一次的运行结果)</strong>，关键点在于：<strong>在要输出的字符前加上<code>carriage return symbol &#39;\r&#39;</code></strong>、<strong>写入操作的时候不能有换行操作</strong>、<strong>字符串后增加一定的空格字符</strong>。</p></div><a id="more"></a><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>在学习<a href="http://showteeth.tech/posts/38877.html"><code>sys</code>模块</a>中的<code>sys.stdout.write()</code>方法时，看别人的博客提供了一个实现百分比进度条的程序，其实现如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>结果输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果在输出的时候后面的输出会覆盖之前的输出</span></span><br><span class="line"><span class="comment"># 而不是重新一行显示</span></span><br><span class="line">[====================================================================================================]<span class="number">100</span>%</span><br></pre></td></tr></table></figure><p></p><p>而当我使用print()进行输出时：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    print(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现没有进行覆盖，虽然功能差不多，但是这样很占空间</span></span><br><span class="line">[                                                                                                    ]<span class="number">0</span>%</span><br><span class="line">[=                                                                                                   ]<span class="number">1</span>%</span><br></pre></td></tr></table></figure><p></p><p>鉴于上述两种输出模式的差别，我就想知道<strong>是什么控制了这种覆盖的输出</strong>。</p><hr><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>问题的原因在于：</p><ul><li><code>r = &#39;\r[%s%s]%d%%&#39; % (&quot;=&quot;*num, &quot; &quot;*(100-num), rate_num, )</code>中的<code>\r</code></li><li>写入操作的时候没有换行：<code>sys.stdout.write(r)</code>最后没有<code>+&#39;\n&#39;</code></li><li><strong>字符串后增加一定的空格字符</strong></li></ul><p><strong>解释</strong>：<br><strong>Prefix</strong> your output with <strong>carriage return symbol ‘\r’</strong> and <strong>do not end it with line feed symbol ‘\n’</strong>. This will place cursor at the beginning of the current line, so output will overwrite previous its content. <strong>Pad it with some trailing blank space to guarantee overwrite</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.stdout.write(<span class="string">'\r'</span> + str(hpi) + <span class="string">' '</span> * <span class="number">20</span>)</span><br><span class="line">sys.stdout.flush() <span class="comment"># important</span></span><br></pre></td></tr></table></figure><p></p><p>所以我上面直接使用<code>print(r)</code>的<strong>错误在于写入操作的时候有了换行操作</strong>，这是 <strong><code>print()</code>的默认行为</strong>，关于print()请参考这篇文章</p><p><strong>正确写法</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    <span class="comment"># sys.stdout.write(r)</span></span><br><span class="line">    <span class="comment"># 或者使用</span></span><br><span class="line">    print(r,end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/9860680/python-overwrite-previous-line" target="_blank" rel="noopener">python overwrite previous line</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之Python3的sys.stdout.write()返回字符长度</title>
      <link href="/posts/23402.html"/>
      <url>/posts/23402.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了自己在<code>Python3</code>中使用<code>sys.stdout.write()</code>时<strong>发现会返回写入的字符长度</strong>，进而了解到<code>Python3</code>中<strong>文件对象的写入操作File.write()</strong>都会<strong>返回写入的字符长度</strong>，同时针对这种问题提出了自己的<strong>解决方法</strong>，<strong>将字符长度赋值给另一个变量</strong>，不让其输出即可。</p></div><a id="more"></a><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>在学习<a href="http://showteeth.tech/posts/38877.html"><code>sys</code>模块</a>中的<code>sys.stdout.write()</code>方法时，看别人的博客提供了一个实现百分比进度条的程序，其实现如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># \r会影响flush()</span></span><br><span class="line">    <span class="comment"># 不加的话输出结果不会显示在同一行，也不会对齐</span></span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    <span class="comment"># 这里使用的是sys.stdout.write(r)</span></span><br><span class="line">    <span class="comment"># 也可以使用print(i,end='')</span></span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>) </span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[====================================================================================================]<span class="number">100</span>%</span><br></pre></td></tr></table></figure><p></p><p>我觉得有些复杂，想将其改为不使用函数的形式，具体如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), num)</span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><p></p><p>结果输出如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=                                                                                                   ]<span class="number">1</span>%<span class="number">105</span></span><br></pre></td></tr></table></figure><p></p><p>发现后面多了一个105，想了半天，发现这个原来就是输出的字符的长度：100 + 4 + 1(<code>\r</code>)，关于这个<code>\r</code>的作用在<a href="http://showteeth.tech/posts/38536.html">另一篇文章</a>中有所讲解。</p><p><strong>也就是说我在输出我想打印的字符时还显示了这个字符的长度！</strong></p><hr><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>后来发现这是<code>Python3</code>的<code>sys.stdout.write()</code>以及<code>sys.stderr.write()</code>的(<strong>准确的说是File.write()</strong>)新功能，<strong>可以返回写入的字符数目</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'./test.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello world!'</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="comment"># 上面就返回了写入的字符的数目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sys.stdout.write()和sys.stderr.write()也是一样的效果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">"foo"</span>)</span><br><span class="line">foo3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">"bar"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：Python2中<code>File.write()</code>的返回值是<code>None</code></p></div><hr><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>找到问题的原因之后解决起来就非常简单了，只需要<strong>将返回的值赋值给另一个变量，不让它直接输出</strong>即可：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), num)</span><br><span class="line">    test=sys.stdout.write(r)</span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[==============                                                                                      ]<span class="number">14</span>%</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/27311509/strange-behavior-in-python-3-using-the-sys-module" target="_blank" rel="noopener">Strange behavior in Python 3 using the sys module</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之文件读写(转载)</title>
      <link href="/posts/57951.html"/>
      <url>/posts/57951.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要包括<code>I/O操作概述</code>、<code>文件读写实现原理与操作步骤</code>、<strong><code>文件打开模式及其区别</code></strong>、<code>Python文件操作步骤示例</code>、<code>Python文件读取相关方法</code>以及 <strong><code>文件读写与字符编码</code></strong>。</p></div><a id="more"></a><h2 id="I-O操作概述"><a href="#I-O操作概述" class="headerlink" title="I/O操作概述"></a>I/O操作概述</h2><hr><p>I/O在计算机中是指Input/Output，也就是Stream(流)的输入和输出。这里的输入和输出是相对于内存来说的，Input Stream(输入流)是指数据从外(磁盘、网络)流进内存，Output Stream是数据从内存流出到外面(磁盘、网络)。程序运行时，数据都是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方(通常是磁盘、网络操作)就需要IO接口。</p><p><strong><em>那么这个IO接口是由谁提供呢？高级编程语言中的IO操作是如何实现的呢？</em></strong></p><p>操作系统是个通用的软件程序，其通用目的如下：</p><ul><li>硬件驱动</li><li>进程管理</li><li>内存管理</li><li>网络管理</li><li>安全管理</li><li>I/O管理</li></ul><p>操作系统屏蔽了底层硬件，向上提供通用接口。因此，操作I/O的能力是由操作系统的提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来供开发者使用，Python也不例外。</p><h2 id="文件读写实现原理与操作步骤"><a href="#文件读写实现原理与操作步骤" class="headerlink" title="文件读写实现原理与操作步骤"></a>文件读写实现原理与操作步骤</h2><hr><h3 id="文件读写实现原理"><a href="#文件读写实现原理" class="headerlink" title="文件读写实现原理"></a>文件读写实现原理</h3><p>文件读写就是一种常见的IO操作。那么根据上面的描述，可以推断python也应该封装操作系统的底层接口，直接提供了文件读写相关的操作方法。事实上，也确实如此，而且Java、PHP等其他语言也是。</p><p><strong><em>那么我们要操作的对象是什么呢？我们又如何获取要操作的对象呢？</em></strong></p><p>由于操作I/O的能力是由操作系统提供的，且现代操作系统不允许普通程序直接操作磁盘，所以读写文件时需要请求操作系统打开一个对象(通常被称为文件描述符–<code>file descriptor</code>, 简称<code>fd</code>)，这就是我们在程序中要操作的文件对象。</p><p>通常高级编程语言中会提供一个内置的函数，通过接收”文件路径”以及“文件打开模式”等参数来打开一个文件对象，并返回该文件对象的文件描述符。因此通过这个函数我们就可以获取要操作的文件对象了。这个内置函数在Python中叫<code>open()</code>, 在PHP中叫<code>fopen()</code>,</p><h3 id="文件读写操作步骤"><a href="#文件读写操作步骤" class="headerlink" title="文件读写操作步骤"></a>文件读写操作步骤</h3><p>不同的编程语言读写文件的操作步骤大体都是一样的，都分为以下几个步骤：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)打开文件，获取文件描述符</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)操作文件描述符--读/写</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)关闭文件</span><br></pre></td></tr></table></figure><p></p><p>只是不同的编程语言提供的读写文件的api是不一样的，有些提供的功能比较丰富，有些比较简陋。</p><div class="note info"><p>需要注意的是： <strong><em>文件读写操作完成后，应该及时关闭</em></strong> 。一方面，<strong>文件对象会占用操作系统的资源</strong>；另外一方面，<strong>操作系统对同一时间能打开的文件描述符的数量是有限制的</strong>，在Linux操作系统上可以通过<code>ulimit -n</code> 来查看这个显示数量。如果<strong>不及时关闭文件，还可能会造成数据丢失</strong>。因为我将数据写入文件时，操作系统<strong>不会立刻把数据写入磁盘</strong>，而是先把数据放到内存缓冲区异步写入磁盘。当调用close方法时，操作系统会保证把没有写入磁盘的数据全部写到磁盘上，否则可能会丢失数据。</p></div><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><hr><p>我们先来看下在Python、PHP和C语言中打开文件的函数定义</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource fopen ( string $filename , string $mode [, bool $use_include_path = <span class="keyword">false</span> [, resource $context ]] )</span><br></pre></td></tr></table></figure><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>会发现以上3种编程语言内置的打开文件的方法接收的参数中，除了都包含一个“文件路径名称”，还会包含一个mode参数(C语言的open函数中的flags参数作用相似)。这么mode参数定义的是打开文件时的模式，常见的文件打开模式有：只读、只写、可读可写、只追加。不同的编程语言中对文件打开模式的定义有些微小的差别，我们来看下Python中的文件打开模式有哪些。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>文件打开模式</th><th>描述</th></tr></thead><tbody><tr><td><code>r</code></td><td>以<strong>只读模式</strong>打开文件，并将<strong>文件指针指向文件头</strong>；如果<strong>文件不存在会报错</strong></td></tr><tr><td><code>w</code></td><td>以<strong>只写模式</strong>打开文件，并将<strong>文件指针指向文件头</strong>；如果<strong>文件存在则将其内容清空</strong>，如果文件<strong>不存在则创建</strong></td></tr><tr><td><code>a</code></td><td>以<strong>只追加可写模式</strong>打开文件，并将<strong>文件指针指向文件尾部</strong>；如果<strong>文件不存在则创建</strong></td></tr><tr><td><code>r+</code></td><td>在<code>r</code>的基础上增加了可写功能</td></tr><tr><td><code>w+</code></td><td>在<code>w</code>的基础上增加了可读功能</td></tr><tr><td><code>a+</code></td><td>在<code>a</code>的基础上增加了可读功能</td></tr><tr><td><code>b</code></td><td><strong>读写二进制文件(默认是t，表示文本)</strong>，需要与上面几种模式搭配使用，如<code>ab</code>，<code>wb</code>, <code>ab</code>, <code>ab+</code>(POSIX系统，包括Linux都会忽略该字符)</td></tr></tbody></table><div class="note info"><p><strong><em>思考1：</em></strong> <code>r+</code>、<code>w+</code>和<code>a+</code>都可以实现对文件的读写，那么他们有什么区别呢？</p><ul><li><code>r+</code>会<strong>覆盖当前文件指针所在位置的字符</strong>，如原来文件内容是”<code>Hello，World</code>“，打开文件后写入”<code>hi</code>“则文件内容会变成”<code>hillo, World</code>“(因为 <strong><code>r</code>模式打开文件时文件指针指向文件头</strong>)</li><li><code>w+</code>与<code>r+</code>的不同是，<code>w+</code>在打开文件时就会<strong>先将文件内容清空</strong>，不知道它有什么用(<strong>感觉和单独的使用<code>w</code>模式没什么差别</strong>)</li><li><code>a+</code>与<code>r+</code>的不同是，<strong><code>a+</code>只能写到文件末尾</strong>(无论当前文件指针在哪里)</li></ul><p><br></p><p><strong><em>思考2：</em></strong> 为什么要定义这些模式呢？为什么不能像我们用word打开一篇文档一样既可以读，又可以写，还可修改呢？<br>关于这个问题，我查了很多资料，也没找到很权威的说明。在跟同行朋友交流过程中，发现大家主要有两种观点：</p><ul><li><strong>跟安全有关</strong> ，有这种观点的大部分是做运维的朋友，他们认为这就像linux上的rwx(读、写、执行)权限。</li><li><strong>跟操作系统内核管理I/O的机制有关</strong> ，有这种观点的大部分是做C开发的，特别是与内核相关的开发人员。为了提高读写速度，要写入磁盘的数据会先放进内存缓冲区，之后再回写。由于可能会同时打开很多文件，当要回写数据时，需要遍历以打开的文件判断是否需要回写。他们认为如果打开文件时指定了读写模式，那么需要回写时，只要去查找以“可写模式”打开的文件就可以了。</li></ul></div><h2 id="Python文件操作步骤示例"><a href="#Python文件操作步骤示例" class="headerlink" title="Python文件操作步骤示例"></a>Python文件操作步骤示例</h2><hr><p>我们来读取这样一个文本文件：song.txt，该文件的字符编码为<code>utf-8</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br></pre></td></tr></table></figure><h3 id="菜鸟实现-只是实现功能"><a href="#菜鸟实现-只是实现功能" class="headerlink" title="菜鸟实现(只是实现功能)"></a>菜鸟实现(只是实现功能)</h3><p>Python3实现：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：(以只读模式)打开文件</span></span><br><span class="line">f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：读取文件内容</span></span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p></p><p>这里说下Python2的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：(以只读模式)打开文件</span></span><br><span class="line">f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：读取文件内容</span></span><br><span class="line">print(f.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>Python3中已经内置对Unicode的支持，字符串str已经是真正的Unicode字符串。也就是说Python3中的文件读取方法已经自动完成了解码处理，因此无需再手动进行解码，可以直接将读取的文件中的内容进行打印；Python2中的字符串str是字节串，读取文件得到的也是字节串，在打印之前应该手动将其解码成Unicode字符串。关于这部分的说明，可以参考之前这篇文章<a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">&lt;&gt;</a>。</p><h3 id="中级实现"><a href="#中级实现" class="headerlink" title="中级实现"></a>中级实现</h3><p>在实现基本功能的前提下，考虑一些可能的意外因素。因为文件读写时都有可能产生IO错误(IOError)，一旦出错，后面包括<code>f.close()</code>在内的所有代码都不会执行了。因此我们要保证文件无论如何都能被关闭。那么可以用<code>try...finally</code>来实现，这实际上就是<code>try...except..finally</code>的简化版(我们只用Python3来进行示例演示)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">''</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;finally'</span>)</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;<span class="keyword">finally</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>输出结果说明，尽管with代码块中出现了异常，但是”&gt;&gt;&gt;&gt;&gt;&gt;finally“ 信息还是被打印了，说明finally代码块被执行，即文件关闭操作被执行。但是结果中错误信息还是被输出了，因此还是建议用一个完成的<code>try...except...finally</code>语句对异常信息进行捕获和处理。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免忘记或者为了避免每次都要手动关闭文件，我们可以使用<code>with</code>语句(一种语法糖，语法糖语句通常是为了简化某些操作而设计的)。with语句会在其代码块执行完毕之后自动关闭文件。因此我们可以这样来改写上面的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line">print(f.closed)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>是不是变得简介多了，代码结构也比较清晰了。<code>with</code>之后打印的<code>f.closed</code>属性值为<code>True</code>，说明文件确实被关闭了。</p><blockquote><p><strong>思考:</strong><br><strong>with语句会帮我们自动处理异常信息吗</strong>？</p></blockquote><p>要回答这个问题就要提到“上下文管理器” 和 with语句的工作流程。</p><p>with语句不仅仅可以用于文件操作，它实际上是一个很通用的结构，允许使用所谓的上下文管理器(context manager)。上下文管理器是一种支持<code>__enter__()</code>和<code>__exit__()</code>这两个方法的对象。<code>__enter__()</code>方法不带任何参数，它在进入with语句块的时候被调用，该方法的返回值会被赋值给as关键字之后的变量。<code>__exit__()</code>方法带有3个参数：<code>type(异常类型)</code>, <code>value(异常信息)</code>, <code>trace(异常栈)</code>，当<code>with</code>语句的代码块执行完毕或执行过程中因为异常而被终止都会调用<code>__exit__()</code>方法。正常退出时该方法的3个参数都为None，异常退出时该方法的3个参数会被分别赋值。如果<code>__exit__()</code>方法返回值(真值测试结果)为True则表示异常已经被处理，命令执行结果中就不会抛出异常信息了；反之，如果<code>__exit__()</code>方法返回值(真值测试结果)为False，则表示异常没有被处理并且会向外抛出该异常。</p><p>现在我们应该明白了，异常信息会不会被处理是由with后的语句返回对象的<code>__exit__()</code>方法决定的。文件可以被用作上下文管理器。它的<code>__enter__</code>方法返回文件对象本身，<code>__exit__</code>方法会关闭文件并返回None。我们看下file类中关于这两个方法的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">""" __enter__() -&gt; self. """</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *excinfo)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">""" __exit__(*excinfo) -&gt; None.  Closes the file. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可见，file类的<code>__exit__()</code>方法的返回值为None，None的真值测试结果为False，因此用于文件读写的with语句代码块中的异常信息还是会被抛出来，需要我们自己去捕获并处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line">只有等别人兑现</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面所说的<code>__exit__()</code>方法返回值(真值测试结果)为True则表示异常已经被处理，指的是<code>with</code>代码块中出现的异常。它对于<code>with</code>关键字之后的代码中出现的异常是不起作用的，因为还没有进入上下文管理器就已经发生异常了。<strong>因此，无论如何，还是建议在必要的时候在with语句外面套上一层<code>try...except</code>来捕获和处理异常</strong>。</p><p>有关“上下文管理器”这个强大且高级的特性的更多信息，请参看Python参考手册中的上下文管理器部分。或者可以在Python库参考中查看上下文管理器和contextlib部分。</p><h2 id="Python文件读取相关方法"><a href="#Python文件读取相关方法" class="headerlink" title="Python文件读取相关方法"></a>Python文件读取相关方法</h2><hr><p>我们知道，对文件的读取操作需要将文件中的数据加载到内存中，而上面所用到的read()方法会一次性把文件中所有的内容全部加载到内存中。这明显是不合理的，当遇到一个几个G的的文件时，必然会耗光机器的内存。这里我们来介绍下Python中读取文件的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>read()</code></td><td><strong>一次读取文件所有内容</strong>，返回一个<strong>str</strong></td></tr><tr><td><code>read(size)</code></td><td>每次最多读取指定长度的内容，返回一个<strong>str</strong>；在Python2中size指定的是字节长度，在Python3中size指定的是字符长度</td></tr><tr><td><code>readlines()</code></td><td>一次读取文件<strong>所有内容</strong>，按行返回一个<strong>list</strong></td></tr><tr><td><code>readline()</code></td><td>每次<strong>只读取一行</strong>内容</td></tr></tbody></table><p>此外，还要两个与<strong>文件指针位置相关的方法</strong>:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>seek(n)</code></td><td>将文件指针移动到指定字节的位置</td></tr><tr><td><code>tell()</code></td><td>获取当前文件指针所在字节位置</td></tr></tbody></table><p>下面来看下操作实例</p><h3 id="读取指定长度的内容"><a href="#读取指定长度的内容" class="headerlink" title="读取指定长度的内容"></a>读取指定长度的内容</h3><p><strong>Python2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">12</span>).decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年</span><br></pre></td></tr></table></figure><blockquote><p>结果说明：Python2中<code>read(size)</code>方法的size参数指定的要读取的字节数，而song.txt文件是<code>UTF-8</code>编码的内容，一个汉字占3个字节，因此12个字节刚好是4个汉字。</p></blockquote><p><strong>Python3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说</span><br></pre></td></tr></table></figure><blockquote><p>结果说明：Python3中read(size)方法的size参数指定的要读取的字符数，这与文件的字符编码无关，就是返回12个字符。</p></blockquote><h3 id="读取文件中的一行内容"><a href="#读取文件中的一行内容" class="headerlink" title="读取文件中的一行内容"></a>读取文件中的一行内容</h3><p><strong>Python2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readline())</span><br></pre></td></tr></table></figure><p><strong>Python3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readline().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>输出结果都一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br></pre></td></tr></table></figure><h3 id="遍历打印一个文件中的每一行"><a href="#遍历打印一个文件中的每一行" class="headerlink" title="遍历打印一个文件中的每一行"></a>遍历打印一个文件中的每一行</h3><p>这里我们只以Python3来进行实例操作，Python2仅仅是需要在读取到内容后进行手动解码而已，上面已经有示例。</p><p><strong>方式一：先一次性读取所有行到内存，然后再遍历打印</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line"></span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line"></span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line"></span><br><span class="line">只有等别人兑现</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这种方式的缺点与read()方法是一样的，都是会消耗大量的内存空间。</span><br><span class="line"></span><br><span class="line">**方式二：通过迭代器一行一行的读取并打印**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匆匆那年我们 究竟说了几遍 再见之后再拖延</span><br><span class="line"></span><br><span class="line">可惜谁有没有 爱过不是一场 七情上面的雄辩</span><br><span class="line"></span><br><span class="line">匆匆那年我们 一时匆忙撂下 难以承受的诺言</span><br><span class="line"></span><br><span class="line">只有等别人兑现</span><br></pre></td></tr></table></figure><p>另外，发现上面的输出结果中行与行之间多了一个空行。这是因为文件每一行的默认都有换行符，而print()方法也会输出换行，因此就多了一个空行。去掉空行也比较简单：可以用<code>line.rstrip()</code>去除字符串右边的换行符，也可以通过print(line, end=’’)避免print方法造成的换行。</p><h3 id="将缓存区数据立刻写入文件-flush"><a href="#将缓存区数据立刻写入文件-flush" class="headerlink" title="将缓存区数据立刻写入文件-flush()"></a>将缓存区数据立刻写入文件-flush()</h3><p><code>flush()</code>方法的<strong>主要作用</strong>是刷新缓冲区数据，将<strong>缓冲区</strong>中的数据<strong>立刻写入</strong>文件或控制台；在我们平常当调用<code>write()</code>进行文件写入操作时，<strong>默认情况下，并没有立即将信息写入文件</strong>，而是<strong>先写入了缓冲区</strong>，当<strong>缓冲区满了以后才会写到文件中</strong>(<strong>这样可以保护磁盘</strong>，如果每次执行write就直接对磁盘进行操作，会缩短磁盘的寿命)，这就<strong>涉及到一个问题</strong>就是如果<strong>缓冲区没写满</strong>那存在缓冲区的数据怎么办？一种方法是直接调用<code>flush()</code>方法，将缓冲区的数据写入磁盘；另一种方法是执行文件的<code>close()</code>操作(前面的文件操作步骤也有提及)，这样可以把没有写入磁盘的数据全部写到磁盘上，这种方法实质上也是调用了<code>flush()</code>刷新缓存区数据。</p><p>接下来结合<code>print()</code>实例来对<code>flush()</code>进行进一步的学习，在学习之前还需要介绍一下Python的<code>print()</code>函数：</p><ul><li>其完整形式是<code>print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code></li><li>其中的<code>end</code>参数表示在字符串末尾增加的字符，默认情况下使用的是<code>&#39;\n&#39;</code>，也就是换行<br><strong>* 默认的输出位置</strong>是<code>sys.stdout</code>也就是控制台，<strong>可以将其设置为文件对象，那就是将结果输出到文件对象</strong></li><li><strong>默认情况下是不刷新缓存区数据的</strong>，即<code>flush=False</code></li></ul><p>所以实际上，在Python中使用<code>print()</code>输出到控制台实际上就是使用了<code>sys.stdout.write(str+&#39;\n&#39;)</code>(注意这里的<code>+&#39;\n&#39;</code>是和print的end是一致参数的)，其中也使用了<code>write()</code>方法，这也就说明其也涉及到了缓冲区(事实上<code>print()</code>还专门有flush参数).</p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 实时刷新，因为print输出的字符串以\n结束</span></span><br><span class="line">    <span class="comment"># sys.stdout检测到缓冲区内容以换行符结尾，它就会直接将缓冲区内容输出</span></span><br><span class="line">    <span class="keyword">print</span> (i)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>理想情况</strong>下，上述实例开始并不会输出任何内容，而在程序运行完成之后会<strong>一次性输出0、1、2、3、4(程序正常结束，刷新缓冲区)</strong>，但是实际上在程序运行过程中就会刷新，这是因为<code>sys.stdout</code>检测到缓冲区内容<strong>以换行符结尾，它就会直接将缓冲区内容输出</strong>，不需要显式调用<code>sys.stdout.flush()</code>方法；接下来我们将print的end设置为空或者其他字符：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 设置字符串在结尾为不添加换行符</span></span><br><span class="line">    <span class="comment"># 防止自动刷新缓冲区</span></span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">''</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p>这次和预想的一样，在程序运行完成之后才会刷新缓冲区，<strong>一次性输出0、1、2、3、4</strong>，接下来设置<code>sys.stdout.flush()</code>进行强制的刷新缓冲区：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">print</span> (i,end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># 强制刷新缓冲区</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p>这此和预期的结果也是相同的，随着程序的运行，一步一步的输出0、1、2、3、4.</p><div class="note success"><p><strong>总结一下缓冲区刷新的方式</strong>：</p><ul><li><code>flush()</code>强制刷新缓存区</li><li><strong>缓冲区满</strong>时，自动刷新</li><li><strong>文件关闭</strong>或者是<strong>程序结束</strong>自动刷新</li><li><strong>缓冲区中遇到换行符(<code>\n</code>)</strong>也会刷新</li></ul></div><hr><h3 id="file类的其他方法"><a href="#file类的其他方法" class="headerlink" title="file类的其他方法"></a>file类的其他方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>flush()</code></td><td>刷新缓冲区数据，将<strong>缓冲区</strong>中的数据<strong>立刻写入</strong>文件</td></tr><tr><td><code>next()</code></td><td>返回文件下一行，这个方法也是file对象实例可以被当做迭代器使用的原因</td></tr><tr><td><code>truncate([size])</code></td><td>截取文件中指定字节数的内容，并覆盖保存到文件中，如果不指定size参数则文件将被清空; Python2无返回值，Python3返回新文件的内容字节数</td></tr><tr><td><code>write(str)</code></td><td>将<strong>字符串写入文件</strong>，没有返回值</td></tr><tr><td><code>writelines(sequence)</code></td><td>向文件<strong>写入一个字符串</strong>或<strong>一个字符串列表</strong>，如果字符串列表中的元素需要换行要自己加入换行符</td></tr><tr><td><code>fileno()</code></td><td>返回一个整型的文件描述符，可以用于一些底层IO操作上(如，os模块的read方法)</td></tr><tr><td><code>isatty()</code></td><td>判断文件是否被连接到一个虚拟终端，是则返回True，否则返回False</td></tr></tbody></table><h2 id="文件读写与字符编码"><a href="#文件读写与字符编码" class="headerlink" title="文件读写与字符编码"></a>文件读写与字符编码</h2><hr><p>前面已经写过一篇介绍Python中字符编码的相关文件<a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">&lt;&gt;</a> 里面花了很大的篇幅介绍Python中字符串与字符编码的关系以及转换过程。其中谈到过两个指定的字符编码的地方，及其作用：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/Python两个指定编码位置.png" alt="Python两个指定编码位置.png"></p><ul><li><strong><em>PyCharm等IDE开发工具指定的项目工程和文件的字符编码：</em></strong> 它的主要作用是告诉Pycharm等IDE开发工具保存文件时应该将字符转换为怎样的字节表示形式，以及打开并展示文件内容时应该以什么字符编码将字节码转换为人类可识别的字符。</li><li><strong><em>Python源代码文件头部指定的字符编码，如<code>*-* coding:utf-8 -*-</code>：</em></strong> 它的主要作用是告诉Python解释器当前python代码文件保存时所使用的字符编码，Python解释器在执行代码之前，需要先从磁盘读取该代码文件中的字节然后通过这里指定的字符编码将其解码为unicode字符。Python解释器执行Python代码的过程与IDE开发工具是没有什么关联性的。</li></ul><p><strong>那么这里为什么又要谈起字符编码的问题呢？</strong></p><p>或者换个问法，既然从上面已经指定了字符编码，为什么对文件进行读写时还要指定字符编码呢？从前面的描述可以看出：上面两个地方指定的是Python代码文件的字符编码，是给Python解释器和Pycharm等程序软件用的；而<strong>被读写文件的字符编码与Python代码文件的字符编码没有必然联系，读写文件时指定的字符编码是给我们写的程序软件用的</strong>。这是不同的主体和过程，希望我说明白了。</p><p><strong>读写文件时怎样指定字符编码呢？</strong></p><p>上面解释了读写文件为什么要指定字符编码，这里要说下怎样指定字符编码(其实这里主要讨论是读取外部数据时的情形)。这个问题其实在上面的文件读取示例中已经使用过了，这里我们再详细的说一下。</p><p>首先，再次看一下Python2和Python3中open函数的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>可以看到，Python3的open函数中多了几个参数，其中包括一个encoding参数。是的，这个encoding就是用来指定被操作文件的字符编码的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.write(<span class="string">'你好'</span>))</span><br></pre></td></tr></table></figure><p>那么Python2中怎样指定呢？<strong>Python2中的对文件的read和write操作都是字节</strong>，也就说Python2中文件的read相关方法读取的是字节串(如果包含中文字符，会发现len()方法的结果不等于读取到的字符个数，而是字节数)。<strong>如果我们要得到正确的字符串</strong>，需要手动将读取到的结果<code>decode(解码)</code>为字符串；相反，要以特定的字符编码保存要写入的数据时，需要手动<code>encode(编码)</code>为字节串。这个<code>encode()</code>和<code>decode()</code>函数可以接收一个字符编码参数。<strong>Python3中read和write操作的都是字符串</strong>，实际上是Python解释器帮我们自动完成了写入时的<code>encode(编码)</code>和读取时的<code>decode(解码)</code>操作，因此我们只需要在打开文件(open函数)时指定字符编码就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'song2.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># f.write(u'你好'.encode('utf-8'))</span></span><br><span class="line">    <span class="comment"># f.write('你好'.decode('utf-8').encode('utf-8'))</span></span><br><span class="line">    f.write(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure><p><strong>文件读写时有没有默认编码呢？</strong></p><p>Python3中<code>open</code>函数的<code>encoding</code>参数显然是可以不指定的，这时候就会用一个“默认字符编码”。<br>看下Python3中open函数文档对<code>encoding</code>参数的说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoding <span class="keyword">is</span> the name of the encoding used to decode <span class="keyword">or</span> encode the</span><br><span class="line">file. This should only be used <span class="keyword">in</span> text mode. The default encoding <span class="keyword">is</span></span><br><span class="line">platform dependent, but any encoding supported by Python can be</span><br><span class="line">passed.  See the codecs module <span class="keyword">for</span> the list of supported encodings.</span><br></pre></td></tr></table></figure><p>也就是说，<code>encoding</code>参数的默认值是与平台有关的，比如<code>Window</code>上默认字符编码为<code>GBK</code>，<code>Linux</code>上默认字符编码为<code>UTF-8</code>。</p><p>而对于Python2来说，在进行文件写操作时，字节会被直接保存；在进行文件读操作时，如果不手动进行来<code>decode</code>操作自然也就用不着默认字符编码了。但是这时候在不同的字符终端打印的时候，会用当前平台的字符编码自动将字节解码为字符，此时可能会出现乱码。如song.txt文件时<code>UTF-8</code>编码的，在<code>windows(字符编码为GBK)</code>的命令行终端进行如下操作就会出现乱码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'song.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    print(f.read())</span><br><span class="line">...</span><br><span class="line">鍖嗗寙閭ｅ勾鎴戜滑 绌剁珶璇翠簡鍑犻亶 鍐嶈涔嬪悗鍐嶆嫋寤?</span><br><span class="line">鍙儨璋佹湁娌℃湁 鐖辫繃涓嶆槸涓€鍦?涓冩儏涓婇潰鐨勯泟杈?</span><br><span class="line">鍖嗗寙閭ｅ勾鎴戜滑 涓€鏃跺寙蹇欐拏涓?闅句互鎵垮彈鐨勮瑷€</span><br><span class="line">鍙湁绛夊埆浜哄厬鐜</span><br></pre></td></tr></table></figure><p>我们应该尽可能的获取被操作文件的字符编码，并明确指定<code>encoding</code>参数的值。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a href="https://www.cnblogs.com/yyds/p/6186621.html" target="_blank" rel="noopener">Python之文件读写</a></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之sys-程序与python解释器的交互</title>
      <link href="/posts/38877.html"/>
      <url>/posts/38877.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python的sys模块，其作用是<strong>程序与python解释器</strong>的交互；主要学习了其中的sys.argv、sys.modules、sys.path、sys.platform、sys.stdin、sys.stdout(附带一个实现百分比进度条的实例)以及sys.exit()</p></div><a id="more"></a><h2 id="sys模块简介"><a href="#sys模块简介" class="headerlink" title="sys模块简介"></a>sys模块简介</h2><p>sys模块主要是针对<strong>与Python解释器相关的变量和方法</strong>，<strong>不是主机操作系统(与os模块不同)</strong>。</p><hr><h2 id="主要属性和方法"><a href="#主要属性和方法" class="headerlink" title="主要属性和方法"></a>主要属性和方法</h2><table><thead><tr><th width="30%">属性及方法</th><th width="70%">使用说明</th></tr></thead><tbody><tr><td><code>sys.argv</code></td><td>获取命令行参数列表，第一个元素是程序本身</td></tr><tr><td><code>sys.exit(n)</code></td><td>退出Python程序，<strong>exit(0)表示正常退出</strong>。当参数非0时，会引发一个<code>SystemExit</code>异常，可以在程序中捕获该异常</td></tr><tr><td><code>sys.version</code></td><td>获取Python解释程器的版本信息</td></tr><tr><td><code>sys.maxsize</code></td><td>最大的Int值，64位平台是<code>2**63 - 1</code></td></tr><tr><td><code>sys.path</code></td><td>返回<strong>模块的搜索路径</strong>，初始化时使用PYTHONPATH环境变量的值</td></tr><tr><td><code>sys.platform</code></td><td>返回操作系统平台名称</td></tr><tr><td><code>sys.stdin</code></td><td>输入相关</td></tr><tr><td><code>sys.stdout</code></td><td>输出相关</td></tr><tr><td><code>sys.stderr</code></td><td>错误相关</td></tr><tr><td><code>sys.exc_info()</code></td><td>返回异常信息三元元组</td></tr><tr><td><code>sys.getdefaultencoding()</code></td><td><strong>获取系统当前编码，默认为utf-8</strong></td></tr><tr><td><code>sys.setdefaultencoding()</code></td><td><strong>设置系统的默认编码</strong></td></tr><tr><td><code>sys.getfilesystemencoding()</code></td><td><strong>获取文件系统使用编码方式，默认是utf-8</strong></td></tr><tr><td><code>sys.modules</code></td><td><strong>以字典的形式返回所有当前Python环境中已经导入的模块</strong></td></tr><tr><td><code>sys.builtin_module_names</code></td><td>返回一个列表，包含所有已经编译到Python解释器里的模块的名字</td></tr><tr><td><code>sys.copyright</code></td><td>当前Python的版权信息</td></tr><tr><td><code>sys.flags</code></td><td>命令行标识状态信息列表。只读。</td></tr><tr><td><code>sys.getrefcount(object)</code></td><td>返回对象的引用数量</td></tr><tr><td><code>sys.getrecursionlimit()</code></td><td>返回Python最大递归深度，默认1000</td></tr><tr><td><code>sys.getsizeof(object[, default])</code></td><td>返回对象的大小</td></tr><tr><td><code>sys.getswitchinterval()</code></td><td>返回线程切换时间间隔，默认0.005秒</td></tr><tr><td><code>sys.setswitchinterval(interval)</code></td><td>设置线程切换的时间间隔，单位秒</td></tr><tr><td><code>sys.getwindowsversion()</code></td><td>返回当前windwos系统的版本信息</td></tr><tr><td><code>sys.hash_info</code></td><td>返回Python默认的哈希方法的参数</td></tr><tr><td><code>sys.implementation</code></td><td>当前正在运行的Python解释器的具体实现，比如CPython</td></tr><tr><td><code>sys.thread_info</code></td><td>当前线程信息</td></tr></tbody></table><hr><p><br></p><h2 id="常用属性和方法实例"><a href="#常用属性和方法实例" class="headerlink" title="常用属性和方法实例"></a>常用属性和方法实例</h2><h3 id="脚本参数-sys-argv"><a href="#脚本参数-sys-argv" class="headerlink" title="脚本参数-sys.argv"></a>脚本参数-sys.argv</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,arg <span class="keyword">in</span> enumerate(sys.argv):</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"第%d个参数是：%s"</span> %(index,arg))</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python argv.py <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">  第<span class="number">0</span>个参数是：argv.py</span><br><span class="line">  第<span class="number">1</span>个参数是：<span class="number">1</span></span><br><span class="line">  第<span class="number">2</span>个参数是：<span class="number">2</span></span><br><span class="line">  第<span class="number">3</span>个参数是：<span class="number">3</span></span><br><span class="line">  第<span class="number">4</span>个参数是：<span class="number">4</span></span><br><span class="line">  第<span class="number">5</span>个参数是：<span class="number">5</span></span><br><span class="line">  第<span class="number">6</span>个参数是：<span class="number">6</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>该方法已经被<code>argparse</code>方法替换，<code>argparse</code>更加强大和简单易用，关于<code>argparse</code>可以参考<a href="http://showteeth.tech/posts/19941.html">这篇文章</a></li><li>不过这个<strong>获取任意数目参数的方法也还挺实用的</strong>，在<code>argparse</code>中可以使用<code>nargs=argparse.REMAINDER</code>将剩余的参数利用列表收集起来</li></ul></div><hr><h3 id="查看已经导入的模块-sys-modules"><a href="#查看已经导入的模块-sys-modules" class="headerlink" title="查看已经导入的模块-sys.modules"></a>查看已经导入的模块-sys.modules</h3><p><code>sys.modules</code><strong>保存有当前Python环境中已经导入的模块记录，这是一个全局字典，当Python启动后就加载在内存中</strong>。每当导入新的模块，<code>sys.modules</code>将自动记录该模块，当第二次试图再次导入该模块时，Python会先到这个字典中查找是否曾经导入过该模块，是则忽略，否则导入，从而<strong>加快了程序运行的速度</strong>。同时，它<strong>拥有字典的基本方法</strong>，例如<code>sys.modules.keys()</code><strong>查看字典的所有键</strong>，<code>sys.modules.values()</code>查看<strong>字典的所有值</strong>，<code>sys.modules[&#39;sys&#39;]</code><strong>查看sys键对应的值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有已经导入的模块</span></span><br><span class="line">sys.modules</span><br><span class="line">  <span class="comment"># 输出结果中会有很多模块，但是我只导入了sys模块</span></span><br><span class="line">  <span class="comment"># 可能是在python启动时就已经默认导入了很多必须的模块</span></span><br><span class="line">  &#123;<span class="string">'builtins'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'sys'</span>: &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'_frozen_importlib'</span>: &lt;module <span class="string">'_frozen_importlib'</span> (frozen)&gt;, ....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有的模块名</span></span><br><span class="line">sys.modules.keys()</span><br><span class="line">  <span class="comment"># 输出模块名</span></span><br><span class="line">  dict_keys([<span class="string">'builtins'</span>, <span class="string">'sys'</span>, <span class="string">'_frozen_importlib'</span>, <span class="string">'_imp'</span>, <span class="string">'_warnings'</span>, <span class="string">'_thread'</span>, <span class="string">'_weakref'</span>, <span class="string">'_frozen_importlib_external'</span>, <span class="string">'_io'</span>, <span class="string">'marshal'</span>, <span class="string">'posix'</span>, <span class="string">'zipimport'</span>, <span class="string">'encodings'</span>, <span class="string">'codecs'</span>, <span class="string">'_codecs'</span>...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有模块信息</span></span><br><span class="line">sys.modules.values()</span><br><span class="line">  <span class="comment"># 返回所有的模块信息</span></span><br><span class="line">  dict_values([&lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'_frozen_importlib'</span> (frozen)&gt;, &lt;module <span class="string">'_imp'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'_warnings'</span> (built-<span class="keyword">in</span>)&gt;, &lt;module <span class="string">'_thread'</span> (built-<span class="keyword">in</span>)&gt;, ...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  得到具体某个模块的信息</span></span><br><span class="line">sys.modules[<span class="string">'sys'</span>]</span><br><span class="line">  <span class="comment"># 查看sys模块的信息 </span></span><br><span class="line">  &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="模块搜索路径-sys-path"><a href="#模块搜索路径-sys-path" class="headerlink" title="模块搜索路径-sys.path"></a>模块搜索路径-sys.path</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path</span><br><span class="line">  <span class="comment"># 得到模块搜索路径 </span></span><br><span class="line">  [<span class="string">''</span>, <span class="string">'/home/user/miniconda3/lib/python36.zip'</span>, <span class="string">'/home/user/miniconda3/lib/python3.6'</span>, <span class="string">'/home/user/miniconda3/lib/python3.6/lib-dynload'</span>, <span class="string">'/home/user/miniconda3/lib/python3.6/site-packages'</span>]</span><br></pre></td></tr></table></figure><div class="note info"><p><code>sys.path</code>本质上是一个列表，可以进行<code>append</code>、<code>insert</code>、<code>pop</code>、<code>remove</code>等各种列表相关的操作，但<strong>通常都进行<code>append</code>操作，添加自己想要的查找路径</strong>.</p></div><hr><h3 id="操作系统平台名称-sys-platform"><a href="#操作系统平台名称-sys-platform" class="headerlink" title="操作系统平台名称-sys.platform"></a>操作系统平台名称-sys.platform</h3><table><thead><tr><th width="20%">操作系统</th><th width="80%">返回值</th></tr></thead><tbody><tr><td>Linux</td><td>'linux'</td></tr><tr><td>Windows</td><td>'win32'</td></tr><tr><td>Windows/Cygwin</td><td>'cygwin'</td></tr><tr><td>Mac OS X</td><td>'darwin'</td></tr></tbody></table><hr><h3 id="交互式输入-sys-stdin"><a href="#交互式输入-sys-stdin" class="headerlink" title="交互式输入-sys.stdin"></a>交互式输入-sys.stdin</h3><p><code>sys.stdin</code>返回一个”文件类型”对象，支持<code>read()</code>、<code>readline()</code>和<code>readlines()</code>等与文件读取相关的操作，就像使用<code>open()</code>打开的文件对象一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ctrl + d结束输入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=sys.stdin.read()</span><br><span class="line">asdfa</span><br><span class="line">asdfasd</span><br><span class="line">af</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'asdfa\nasdfasd\naf\n\n\n'</span></span><br></pre></td></tr></table></figure><p><strong><code>sys.stdin</code> 与 <code>input()</code></strong>：<br>当我们用<code>input(&#39;Please input something！&#39;)</code>时，事实上是<strong>先输出提示信息</strong>，<strong>然后捕获输入</strong>。 <strong>以下两组等价</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用input</span></span><br><span class="line">s = input(<span class="string">'Please input something！'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sys.stdin</span></span><br><span class="line">print(<span class="string">'Please input something！'</span>) </span><br><span class="line"><span class="comment"># -1 可以抛弃输入流中的'\n' 换行符</span></span><br><span class="line"><span class="comment"># 默认</span></span><br><span class="line">s = sys.stdin.readline()[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="打印输出-sys-stdout"><a href="#打印输出-sys-stdout" class="headerlink" title="打印输出-sys.stdout"></a>打印输出-sys.stdout</h3><p><strong><code>sys.stdout</code> 与 <code>print()</code></strong>:当我们<code>print(obj)</code>的时候，事实上是调用了<code>sys.stdout.write(obj+&#39;\n&#39;)</code>，将内容打印到控制台（默认是显示器），然后<strong>追加一个换行符</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两种方式等价的</span></span><br><span class="line">sys.stdout.write(<span class="string">'hello'</span>+<span class="string">'\n'</span>) </span><br><span class="line">print(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>从控制台重定向到文件</strong>：<strong>默认情况下<code>sys.stdout</code>指向控制台</strong>，如果把<strong>文件对象赋值给<code>sys.stdout</code></strong>，那么 <strong><code>print ()</code>调用的就是文件对象的<code>write()</code>方法</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件对象</span></span><br><span class="line">f_handler = open(<span class="string">'out.log'</span>, <span class="string">'w'</span>) </span><br><span class="line"><span class="comment"># 将文件对象赋值给sys.stdout</span></span><br><span class="line">sys.stdout = f_handler </span><br><span class="line"><span class="comment"># 调用print()实际上就是sys.stdout.write('hello'+'\n') </span></span><br><span class="line"><span class="comment"># 从而直接写入了文件中</span></span><br><span class="line">print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你无法在屏幕上看到hello</span></span><br><span class="line"><span class="comment"># 因为它被写到out.log文件里了</span></span><br></pre></td></tr></table></figure><p></p><p>如果你还想<strong>同时在控制台打印</strong>的话，最好<strong>先将原始的控制台对象引用保存下来</strong>，向<strong>文件中打印之后再恢复 <code>sys.stdout</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__console__ = sys.stdout    <span class="comment"># 保存控制台</span></span><br><span class="line"><span class="comment"># redirection start #       # 去干点别的，比如写到文件里</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="comment"># redirection end           # 干完别的了，恢复原来的控制台</span></span><br><span class="line">sys.stdout = __console__</span><br></pre></td></tr></table></figure><p></p><h3 id="利用sys-stdout实现百分比进度条"><a href="#利用sys-stdout实现百分比进度条" class="headerlink" title="利用sys.stdout实现百分比进度条"></a>利用sys.stdout实现百分比进度条</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># \r会影响flush()</span></span><br><span class="line">    <span class="comment"># 不加的话输出结果不会显示在同一行，也不会对齐</span></span><br><span class="line">    r = <span class="string">'\r[%s%s]%d%%'</span> % (<span class="string">"="</span>*num, <span class="string">" "</span>*(<span class="number">100</span>-num), rate_num, )</span><br><span class="line">    <span class="comment"># 这里使用的是sys.stdout.write(r)</span></span><br><span class="line">    <span class="comment"># 也可以使用print(r,end='')</span></span><br><span class="line">    sys.stdout.write(r)</span><br><span class="line">    <span class="comment"># 使用flush将缓存区数据立即写入</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sys.stdout.write(r)</span></span><br><span class="line"><span class="comment"># 或者print(i,end='')</span></span><br><span class="line">[====================================================================================================]<span class="number">100</span>%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用print(i)</span></span><br><span class="line"><span class="comment"># sys.stdout.write(i+'\n') </span></span><br><span class="line">[                                                                                                    ]<span class="number">0</span>%</span><br><span class="line">[=                                                                                                   ]<span class="number">1</span>%</span><br><span class="line">[==                                                                                                  ]<span class="number">2</span>%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述两种输出结果的区别是换行和不换行的问题，print会默认打印换行，也就是end='\n'</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>这里涉及到了一个<code>flush()</code>的用法，具体讲解参考<a href="http://showteeth.tech/posts/57951.html">这篇文章</a></li><li>还涉及到<a href="http://showteeth.tech/posts/23402.html">Python3的<code>sys.stdout.write()</code>返回字符长度问题</a></li><li>也涉及到了<a href="http://showteeth.tech/posts/38536.html">Python覆盖之前输出的内容的问题</a></li></ul></div><hr><h3 id="程序退出状态-sys-exit-n"><a href="#程序退出状态-sys-exit-n" class="headerlink" title="程序退出状态-sys.exit(n)"></a>程序退出状态-sys.exit(n)</h3><ul><li><code>sys.exit(0)</code>：表示<strong>程序正常退出</strong></li><li><code>sys.exit(n)</code>：<strong>其中n不等于0</strong>表示<strong>程序非正常退出</strong></li><li>大部分的系统都要求n的取值范围是0-127</li></ul><p><strong>执行到主程序末尾，解释器自动退出(正常退出<code>sys.exit(0)</code>)</strong>；但是如果<strong>遇到异常</strong>需要<strong>中途退出程序</strong>，可以调用<code>sys.exit(n)</code>函数(其中的n不为0)，比如在运行之前先进行检查参数，如果不满足要求直接<code>sys.exit(1)</code>退出程序；如果<strong>不是遇到异常</strong>，而是普通的终止程序，可以使用<code>sys.exit(0)</code>正常退出程序。</p><p><strong>注意</strong>：可以传递给<code>sys.exit()</code>不仅仅是数字，<code>None</code>可以对应于上面的<code>0</code>，而其他可以<strong>输出内容</strong>或者<strong>标准错误输出</strong>的都可以对应于上面的<code>1</code>，例如 <code>sys.exit(&quot;some error message&quot;)</code>。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/54" target="_blank" rel="noopener">sys</a></li><li><a href="https://www.cnblogs.com/Archie-s/p/6860301.html" target="_blank" rel="noopener">python之sys模块详解</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之glob-文件名规则匹配</title>
      <link href="/posts/24468.html"/>
      <url>/posts/24468.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Python中的常用模块<code>glob</code>，其作用是<strong>查找特定目录中符合匹配规则的文件(或目录)</strong>，主要包括三个函数：<code>glob.glob()</code>、<code>glob.iglob()</code>和<code>glob.escape()</code>，其中最主要的函数是<code>glob.glob()</code>，<code>glob.iglob()</code>和<code>glob.glob()</code>功能相似，但是<strong>返回的不再是列表而是迭代器对象</strong>，而<code>glob.escape()</code>主要是<strong>用来生成特殊字符匹配的pattern</strong>；在使用中<strong>需要注意通配符和正则表达式的区别</strong>。</p></div><a id="more"></a><h2 id="glob模块简介"><a href="#glob模块简介" class="headerlink" title="glob模块简介"></a>glob模块简介</h2><p><code>glob</code>模块是使用 <code>Unix shell</code> 规则去<strong>查找匹配模式的文件</strong>，<strong>返回的结果是无序的</strong>；在进行匹配时使用的是shell的通配符而不是正则表达式，关于正则表达式与通配符的区别，之前有过<a href="http://showteeth.tech/posts/37480.html">一篇文章</a>，如果忘记的话可以查看一下。</p><p><code>glob</code>模块其实也可以看做是<code>os</code>模块的补充，<code>os</code>模块中的<code>os.listdir()</code>可以列出某个目录下所有的文件和目录，但是这种列出是没有筛选性的，这在某些情况下并不是很适用，比如我想挑选出符合某个命名规则的文件，而<code>glob</code>模块就可以达到这个目的。</p><hr><h2 id="通配符规则"><a href="#通配符规则" class="headerlink" title="通配符规则"></a>通配符规则</h2><p>这里列出了glob模块支持的通配符规则(和shell的通配符规则有细微差别)：</p><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td><code>?</code></td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td><code>[char]</code></td><td>匹配<strong>原始字符char，相当于转义操作</strong></td><td>a[?]b：a与b之间<strong>只有一个字符且为<code>?</code></strong>,此时的<code>?</code>已经不再具有匹配任意一个字符的功能 如: a?b.txt</td></tr><tr><td><code>[list]</code></td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td><code>[!list]</code></td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr></tbody></table><hr><h2 id="返回所有匹配文件名-glob-glob"><a href="#返回所有匹配文件名-glob-glob" class="headerlink" title="返回所有匹配文件名-glob.glob()"></a>返回所有匹配文件名-glob.glob()</h2><p><strong>命令</strong>：<code>glob.glob(pathname, *, recursive=False)</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>pathname</code></strong>：绝对路径或者相对路径，可以包含通配符</li><li><strong><code>recursive</code></strong>：如果<code>recursive</code>是True，<strong>模式`</strong><code>会匹配任何文件以及0个或多个目录和子目录**；如果模式是</code>os.sep`，只有目录和子目录会被匹配；<strong>可以用于递归匹配目录和子目录的内容</strong></li></ul><h3 id="与os模块对比使用"><a href="#与os模块对比使用" class="headerlink" title="与os模块对比使用"></a>与os模块对比使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用os模块列出所有的文件</span></span><br><span class="line">os.listdir(<span class="string">'full_path'</span>)</span><br><span class="line">  [<span class="string">'a?c.txt'</span>, <span class="string">'abc.txt'</span>, <span class="string">'acc.txt'</span>, <span class="string">'adc.txt'</span>, <span class="string">'a[*]c.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用glob模块列出所有的文件</span></span><br><span class="line">glob.glob(<span class="string">'full_path/'</span>)</span><br><span class="line">  <span class="comment"># 没得到正确结果</span></span><br><span class="line">  [<span class="string">'full_path/'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'full_path/*'</span>)</span><br><span class="line">  [<span class="string">'full_path/a?c.txt'</span>, <span class="string">'full_path/abc.txt'</span>, \</span><br><span class="line">    <span class="string">'full_path/acc.txt'</span>, <span class="string">'full_path/adc.txt'</span>, <span class="string">'full_path/a[*]c.txt'</span>]</span><br></pre></td></tr></table></figure><div class="note info"><p>通过上面的示例我们可以看出<code>glob.glob()</code>和<code>os.listdir()</code>在使用和返回结果的区别：</p><ul><li><strong>使用方面</strong>：<code>os.listdir()</code>更为简单，<strong>只需要列出路径</strong>即可；而<code>glob.glob()</code>还<strong>需要设置通配符</strong>来达到匹配的目的</li><li><strong>返回结果方面</strong>：<code>os.listdir()</code>返回<strong>文件名称(不带路径)</strong>，而<code>glob.glob()</code>会返回<strong>文件名称+路径</strong>(和指定的路径相同模式，指定时使用绝对路径，返回结果前也是绝对路径，指定时使用相对路径，返回结果前也是相对路径)</li></ul></div><hr><h3 id="匹配任意一个或多个字符"><a href="#匹配任意一个或多个字符" class="headerlink" title="*-匹配任意一个或多个字符"></a>*-匹配任意一个或多个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配任意一个或多个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a*c.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回只要是以a开头、以c结尾的文件名，具体中间字符的数量没有限制</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abbc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配任意单个字符"><a href="#匹配任意单个字符" class="headerlink" title="?-匹配任意单个字符"></a>?-匹配任意单个字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配任意单个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 如果不想输出以a开头、以c结尾并且中间包含两个以上字符的文件名，可以使用?</span></span><br><span class="line">  <span class="comment"># 表示中间只有任意一个字符，abbc.txt就不符合条件了</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="[]-匹配特殊字符"></a>[]-匹配特殊字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配单个特殊字符</span></span><br><span class="line">glob.glob(<span class="string">'./a[?]c.txt'</span>)</span><br><span class="line"> <span class="comment"># 如果文件名中含有特殊字符，比如这里的?</span></span><br><span class="line"> <span class="comment"># 对其进行匹配可以使用[] </span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'./a\?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 不同于shell可以使用\进行转义，这里转义后不能正确匹配</span></span><br><span class="line">  []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里是单个字符，不能匹配得到多个的情况</span></span><br><span class="line"><span class="comment"># 如果需要匹配多个，可以重复使用</span></span><br><span class="line">glob.glob(<span class="string">'./a[?][?]c.txt'</span>)</span><br><span class="line">  [<span class="string">'./a??c.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配得到单个和多个特殊字符的</span></span><br><span class="line">glob.glob(<span class="string">'./a[?]*c.txt'</span>)</span><br><span class="line">  <span class="comment"># 注意这的*不是任意多个前一个字符(正则表达式中的定义)</span></span><br><span class="line">  <span class="comment"># 因为*可以匹配任意字符，?也不例外，前面使用了[?]作为限制</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./a??c.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="匹配字符范围"><a href="#匹配字符范围" class="headerlink" title="[]-匹配字符范围"></a>[]-匹配字符范围</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配字符范围，同样是单个字符</span></span><br><span class="line">glob.glob(<span class="string">'./a[b-d]c.txt'</span>)</span><br><span class="line">  <span class="comment"># a和c之间存在一个字符，且该字符的范围是b-d</span></span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不能表示为范围，可以单独列出字符的范围</span></span><br><span class="line">glob.glob(<span class="string">'./a[bcd]c.txt'</span>)</span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="char-排除字符"><a href="#char-排除字符" class="headerlink" title="[!char]-排除字符"></a>[!char]-排除字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配中间字符不为b的文件</span></span><br><span class="line">glob.glob(<span class="string">'./a[!b]c.txt'</span>)</span><br><span class="line">  <span class="comment"># 排除了abc.txt</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="递归匹配子目录内容"><a href="#递归匹配子目录内容" class="headerlink" title="递归匹配子目录内容"></a>递归匹配子目录内容</h3><p>上述方法都是常用的匹配当前目录文件名的方法，如果<strong>还想要匹配子目录的内容</strong>，上述方法是显然不行的：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建子目录sub_dir，包含如下几个文件</span></span><br><span class="line">abbc.txt  abc.txt  acc.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果也想匹配出上面列出的文件</span></span><br><span class="line"><span class="comment"># 单纯的使用如下命令是不行的</span></span><br><span class="line">glob.glob(<span class="string">'./*'</span>)</span><br><span class="line">  [<span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abcd.txt'</span>, <span class="string">'./wre.txt'</span>, <span class="string">'./abbc.txt'</span>, <span class="string">'./a??c.txt'</span>, <span class="string">'./sub_dir'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样使用如下命令也不行</span></span><br><span class="line">glob.glob(<span class="string">'./*/*'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 只会得到子目录下的文件</span></span><br><span class="line">  [<span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>, <span class="string">'./sub_dir/abbc.txt'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是真正的做法就需要使用前面提到的recursive参数</span></span><br><span class="line">glob.glob(<span class="string">'./**'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"> <span class="comment"># 得到当前目录和子目录下所有文件</span></span><br><span class="line">  [<span class="string">'./'</span>, <span class="string">'./a?c.txt'</span>, <span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./abcd.txt'</span>, <span class="string">'./wre.txt'</span>, <span class="string">'./abbc.txt'</span>, <span class="string">'./a??c.txt'</span>, <span class="string">'./sub_dir'</span>, <span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>, <span class="string">'./sub_dir/abbc.txt'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'./**/a[b-d]c.txt'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 得到当前目录和子目录下所有符合pattern的文件</span></span><br><span class="line">  [<span class="string">'./abc.txt'</span>, <span class="string">'./acc.txt'</span>, <span class="string">'./adc.txt'</span>, <span class="string">'./sub_dir/abc.txt'</span>, <span class="string">'./sub_dir/acc.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到所有的目录和子目录</span></span><br><span class="line">glob.glob(<span class="string">'./**/'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line">  [<span class="string">'./'</span>, <span class="string">'./sub_dir/'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="开头文件的匹配"><a href="#开头文件的匹配" class="headerlink" title=".开头文件的匹配"></a>.开头文件的匹配</h3><p><strong>如果目录中包含以<code>.</code>开头的文件，默认情况下不会对其进行匹配(使用<code>*</code>也达不到目的)，如果想要匹配需要显式指定<code>.</code></strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">  <span class="comment"># 不会匹配出.开头的 </span></span><br><span class="line">  [<span class="string">'card.gif'</span>]</span><br><span class="line"></span><br><span class="line">glob.glob(<span class="string">'.c*'</span>)</span><br><span class="line">  <span class="comment"># 显式指定.，匹配出以.开头的文件</span></span><br><span class="line">  [<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="返回所有匹配文件名的迭代器-glob-iglob"><a href="#返回所有匹配文件名的迭代器-glob-iglob" class="headerlink" title="返回所有匹配文件名的迭代器-glob.iglob()"></a>返回所有匹配文件名的迭代器-glob.iglob()</h2><p><strong>命令</strong>：glob.iglob(pathname, *, recursive=False)</p><p><strong>参数</strong>：和前面的glob.glob()相同</p><p><strong>使用实例</strong>：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和glob的用法相同，只是会返回一个迭代器</span></span><br><span class="line">glob.iglob(<span class="string">'./*.txt'</span>)</span><br><span class="line">  <span class="comment"># 输出一个迭代器对象</span></span><br><span class="line">  &lt;generator object _iglob at <span class="number">0x7fa8dd9022b0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到具体的结果可以使用循环</span></span><br><span class="line">f=glob.iglob(<span class="string">'./*.txt'</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">   <span class="comment"># 遍历这个迭代器对象</span></span><br><span class="line">   <span class="keyword">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  ./a?c.txt</span><br><span class="line">  ./abc.txt</span><br><span class="line">  ./acc.txt</span><br><span class="line">  ./adc.txt</span><br><span class="line">  ./abcd.txt</span><br><span class="line">  ./wre.txt</span><br><span class="line">  ./abbc.txt</span><br><span class="line">  ./a??c.txt</span><br></pre></td></tr></table></figure><p></p><p>其他用法参考<code>glob.glob()</code>。</p><hr><p><br></p><h2 id="转义元字符-glob-escape"><a href="#转义元字符-glob-escape" class="headerlink" title="转义元字符-glob.escape()"></a>转义元字符-glob.escape()</h2><p>前面提到了如果想要<strong>匹配一些特殊字符</strong>，如<code>?</code>可以<strong>使用<code>[]</code>将其括起来的方式表示原始字符</strong>，不进行通配，这里glob还专门提供了一个方法<code>glob.escape()</code>来达到上述的目的，其<strong>返回的是一个构造好的pattern，其中的特殊字符都会被<code>[]</code>括起来</strong>。</p><p>特殊的字符主要包括三个：<code>?</code>、<code>*</code>和<code>[</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回构造好的pattern</span></span><br><span class="line">glob.escape(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">  <span class="comment"># 和自己加[]效果是一样的 </span></span><br><span class="line">  <span class="string">'./a[?]c.txt'</span></span><br><span class="line"></span><br><span class="line">pattern=glob.escape(<span class="string">'./a?c.txt'</span>)</span><br><span class="line">glob.glob(pattern)</span><br><span class="line">  <span class="comment"># 输出</span></span><br><span class="line">  [<span class="string">'./a?c.txt'</span>]</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/glob.html" target="_blank" rel="noopener">glob — Unix style pathname pattern expansion</a></li><li><a href="https://learnku.com/docs/pymotw/glob-file-name-rule-matching/3393" target="_blank" rel="noopener">7.4. glob — 文件名规则匹配</a></li><li><a href="https://www.jianshu.com/p/542e55b29324" target="_blank" rel="noopener">[Python] glob 模块(查找文件路径)</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Python系列之shutil-高级文件操作</title>
      <link href="/posts/51574.html"/>
      <url>/posts/51574.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python中用来进行<strong>高级文件操作</strong>的模块<code>shutil</code>，其主要包括文件或者目录的<strong>赋值</strong>、<strong>删除</strong>、<strong>剪切</strong>以及<strong>压缩和解压缩操作</strong>，是对上一个学习的<a href="http://showteeth.tech/posts/24368.html">os模块</a>功能的补充。</p></div><a id="more"></a><h2 id="shutil简介"><a href="#shutil简介" class="headerlink" title="shutil简介"></a>shutil简介</h2><p>前面已经学习了<strong>os模块中的常用目录及文件操作</strong>，虽然其中有很多非常强大的功能，但是<strong>其中也有一些需要补足的地方</strong>，比如<strong>删除非空文件夹(这个是os模块不能直接做到的)、文件复制</strong>等，基于上述的补足，这里学习一下Python中高级文件操作的模块shutil，注意高级文件操作是Python官方给的名称，不是我直接编出来的，所以可见这个模块的强大。从主要功能上来看<strong>shutil模块是对os模块的补充</strong>，主要针对文件的<code>拷贝</code>、<code>删除</code>、<code>移动</code>、<code>压缩</code>和<code>解压</code>操作。</p><hr><h2 id="高级文件目录管理"><a href="#高级文件目录管理" class="headerlink" title="高级文件目录管理"></a>高级文件目录管理</h2><h3 id="复制文件内容到另一个文件"><a href="#复制文件内容到另一个文件" class="headerlink" title="复制文件内容到另一个文件"></a>复制文件内容到另一个文件</h3><p><strong>命令</strong>：<code>shutil.copyfileobj(fsrc, fdst[, length=16*1024])</code>，其中的<code>fsrc</code>和<code>fdst</code>都是<code>file-like object</code>(使用<code>open()</code>方法打开后的文件对象)。</p><p><strong>功能</strong>：copy文件内容(部分或全部)到另一个文件(<strong>从fsrc复制到fdst中</strong>)，<strong>可以copy指定大小的内容</strong>，默认的大小为<code>16*1024</code>；<strong>如果length设置为负值</strong>，则会<strong>读取整个文件内容</strong>，而不是以块的方式进行迭代读取；<mark>fdst文件是清空重写还是追加写入需要开文件的打开模式</mark></p><p><strong>程序的源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyfileobj</span><span class="params">(fsrc, fdst, length=<span class="number">16</span>*<span class="number">1024</span>)</span>:</span></span><br><span class="line">    <span class="string">"""copy data from file-like object fsrc to file-like object fdst"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 程序的核心是这个read()</span></span><br><span class="line">        buf = fsrc.read(length)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buf:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        fdst.write(buf)</span><br></pre></td></tr></table></figure><p></p><p>看了上述源码，发现很多问题就很简单了，包括从什么写入什么，read()参数的理解等等，所以说<strong>看源码才是王道啊</strong>！</p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source文件内容</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"><span class="comment"># destination文件内容</span></span><br><span class="line">this <span class="keyword">is</span> destination file!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># source文件使用mode r读取打开</span></span><br><span class="line">s =open(<span class="string">'source.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># destination文件使用mode w写入打开</span></span><br><span class="line"><span class="comment"># w模式打开会清空文件内容</span></span><br><span class="line"><span class="comment"># 如果需要写入文件，可以使用a模式打开</span></span><br><span class="line">d=open(<span class="string">'target.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，从source文件复制到destination文件</span></span><br><span class="line">shutil.copyfileobj(s,d,length=<span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 由于前面使用了w模式打开文件，所以文件内容被清空了</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用追加模式打开destination文件</span></span><br><span class="line">d=open(<span class="string">'target.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line">shutil.copyfileobj(s,d,length=<span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 由于前面使用了a模式打开文件，所以source文件内容是追加在后面</span></span><br><span class="line">this <span class="keyword">is</span> target file!</span><br><span class="line">this <span class="keyword">is</span> source file!</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>部分或者全部复制</strong>：Note that if the <strong>current file position of the fsrc object is not 0</strong>, <strong>only the contents from the current file position to the end of the file will be copied</strong>.</li><li><code>fdst</code>文件是<strong>清空重写(w模式)</strong>还是<strong>追加写入(a模式)</strong>需要开文件的打开模式</li></ul></div><hr><h3 id="复制整个文件内容到另一个文件"><a href="#复制整个文件内容到另一个文件" class="headerlink" title="复制整个文件内容到另一个文件"></a>复制整个文件内容到另一个文件</h3><p><strong>命令</strong>：<code>shutil.copyfile(src, dst)</code>，和上一个命令比较相似，<strong>不同于上一个命令的是src和dst是字符串形式的文件路径而不是文件对象</strong>，也就是说使用之前不用open()。</p><p><strong>功能</strong>：拷贝整个文件(src)内容到另一个文件(dst)；如果source文件和destination<strong>文件是相同</strong>的，则会<strong>产生错误</strong>，同时<strong>destination文件必须是可写</strong>的，<strong>不然也会报错</strong>；同时<mark>需要注意如果目标文件destination中有内容，执行操作后会覆盖</mark>。</p><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyfile</span><span class="params">(src, dst, *, follow_symlinks=True)</span>:</span></span><br><span class="line">    <span class="string">"""Copy data from src to dst.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If follow_symlinks is not set and src is a symbolic link, a new</span></span><br><span class="line"><span class="string">    symlink will be created instead of copying the file it points to.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断文件是否相同，如果相同就报错</span></span><br><span class="line">    <span class="keyword">if</span> _samefile(src, dst):</span><br><span class="line">        <span class="keyword">raise</span> SameFileError(<span class="string">"&#123;!r&#125; and &#123;!r&#125; are the same file"</span>.format(src, dst))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> [src, dst]:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            st = os.stat(fn)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="comment"># File most likely does not exist</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># XXX What about other special files? (sockets, devices...)</span></span><br><span class="line">            <span class="keyword">if</span> stat.S_ISFIFO(st.st_mode):</span><br><span class="line">                <span class="keyword">raise</span> SpecialFileError(<span class="string">"`%s` is a named pipe"</span> % fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks <span class="keyword">and</span> os.path.islink(src):</span><br><span class="line">        os.symlink(os.readlink(src), dst)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(src, <span class="string">'rb'</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">            <span class="comment"># 这里的打开模式需要注意，会清空原始的target的文件内容</span></span><br><span class="line">            <span class="keyword">with</span> open(dst, <span class="string">'wb'</span>) <span class="keyword">as</span> fdst:</span><br><span class="line">                <span class="comment"># 调用了前面提到的shutil.copyfileobj</span></span><br><span class="line">                copyfileobj(fsrc, fdst)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source文件内容</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br><span class="line"><span class="comment"># destination文件内容</span></span><br><span class="line">this <span class="keyword">is</span> destination file!</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 先修改工作目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，从source文件复制到destination文件</span></span><br><span class="line">shutil.copyfile(<span class="string">'source.txt'</span>,<span class="string">'target.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到的destination文件内容</span></span><br><span class="line"><span class="comment"># 可见原始的文件内容被清空了</span></span><br><span class="line">this <span class="keyword">is</span> source file!</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><strong>全部复制</strong>，<strong>目标文件的原有内容会被清空</strong>，可以从源码中文件的打开模式看出</li><li><strong>传递的是表示文件地址的字符串</strong>，而不是像前面的<code>shutil.copyfileobj(fsrc, fdst[, length=16*1024])</code>传递的是文件对象</li></ul></div><hr><h3 id="仅复制权限"><a href="#仅复制权限" class="headerlink" title="仅复制权限"></a>仅复制权限</h3><p><strong>命令</strong>：<code>shutil.copymode(src, dst)</code>：<strong>仅拷贝权限</strong>，内容、组、用户均不变；<strong>src和dst是字符串形式的文件路径而不是文件对象</strong></p><hr><h3 id="仅复制状态信息"><a href="#仅复制状态信息" class="headerlink" title="仅复制状态信息"></a>仅复制状态信息</h3><p><strong>命令</strong>：<code>shutil.copystat(src, dst)</code>：<strong>仅复制所有的状态信息，包括权限，组，用户，修改时间等</strong>；<strong>src和dst是字符串形式的文件路径而不是文件对象</strong></p><h3 id="复制文件内容和权限"><a href="#复制文件内容和权限" class="headerlink" title="复制文件内容和权限"></a>复制文件内容和权限</h3><p><strong>命令</strong>：<code>shutil.copy(src,dst)</code>：</p><ul><li><strong>同时复制文件的内容以及权限</strong></li><li><strong>相当于先copyfile()然后copymode()</strong></li><li>如果<strong>dst是一个目录</strong>，一个和src文件的basename相同的文件会被创建(或重写)；</li><li><strong>src和dst是字符串形式的文件路径而不是文件对象</strong></li></ul><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(src, dst, *, follow_symlinks=True)</span>:</span></span><br><span class="line">    <span class="string">"""Copy data and mode bits ("cp src dst"). Return the file's destination.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The destination may be a directory.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If follow_symlinks is false, symlinks won't be followed. This</span></span><br><span class="line"><span class="string">    resembles GNU's "cp -P src dst".</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If source and destination are the same file, a SameFileError will be</span></span><br><span class="line"><span class="string">    raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断，如果dst是一个目录，就使用src的basename创建文件</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(dst):</span><br><span class="line">        dst = os.path.join(dst, os.path.basename(src))</span><br><span class="line">    copyfile(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">    copymode(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 先修改工作目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行复制操作，其中的dst为目录</span></span><br><span class="line">shutil.copy(<span class="string">'source.txt'</span>,<span class="string">'old_name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在old_name目录下生成了source.txt文件，和src名称相同，而且内容也相同</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="复制文件内容和状态"><a href="#复制文件内容和状态" class="headerlink" title="复制文件内容和状态"></a>复制文件内容和状态</h3><p><strong>命令</strong>：<code>shutil.copy2(src, dst)</code>：与copy函数功能大部分一致，<strong>只是会把所有的文件元数据()都复制(copymode-&gt;copystat)</strong>；同时<strong>复制文件的内容</strong>以及<strong>文件的所有状态信息</strong>；相当于先<code>copyfile()</code>后<code>copystat()</code>；元数据的复制是通过<code>shutil.copystat(src, dst)</code>来完成；</p><p><strong>补充(元数据的定义)</strong>：主要是<strong>描述数据属性(property)的信息</strong>，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能，<strong>是一种数据的数据</strong>，更多关于元数据可以看<a href="https://www.cnblogs.com/XWShuai/p/5936531.html" target="_blank" rel="noopener">这篇文章</a>。</p><hr><h3 id="排除指定的文件"><a href="#排除指定的文件" class="headerlink" title="排除指定的文件"></a>排除指定的文件</h3><p><strong>命令</strong>：<code>shutil.ignore_patterns(*patterns)</code>：接收<strong>一个或多个通配符字符串</strong>，然后<strong>创建</strong>一个可以被<strong>传递给shutil.copytree()方法的’ignore’参数</strong>的<strong>函数</strong>；当文件名与指定的通配符匹配时，则不会被赋值，也就是<strong>排除指定的文件</strong>。</p><hr><h3 id="递归复制目录和子目录"><a href="#递归复制目录和子目录" class="headerlink" title="递归复制目录和子目录"></a>递归复制目录和子目录</h3><p><strong>命令</strong>：<code>shutil.copytree(src, dst, symlinks=False, ignore=None)</code>：</p><ul><li><strong>递归</strong>地复制<strong>src目录及其子目录</strong>的<strong>文件</strong>和<strong>状态信息</strong>到目标<strong>目录dst</strong></li><li><strong>目标目录dst必须是不存在的</strong></li><li>如果目标目录的<strong>父目录不存在</strong>，则会<strong>一同创建</strong></li><li>目录的<strong>权限和时间</strong>通过<code>shutil.copystat()</code>来拷贝，<strong>单个文件</strong>通过<code>shutil.copy2()</code>来拷贝</li></ul><p><strong>参数</strong>：</p><ul><li><strong><code>symlinks</code>参数</strong>：指定是否复制软链接(小心陷入死循环)，<strong>如果为true</strong>，则以链接的形式进行复制；<strong>如果为false或者默认情况下</strong>，则会将链接文件的内容进行复制</li><li><strong><code>ignore</code>参数</strong>：指定<strong>不参与复制的文件</strong>，其值应该是一个<code>ignore_patterns()</code>方法；也是<strong>递归的ignore</strong>，每个目录下的符合ignore的都会被忽略，因为这个参数是传递给<code>copytree</code>的，而<code>copytree</code>是递归调用的</li></ul><p><strong>源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False, ignore=None, copy_function=copy2,</span></span></span><br><span class="line"><span class="function"><span class="params">             ignore_dangling_symlinks=False)</span>:</span></span><br><span class="line">    <span class="string">"""Recursively copy a directory tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The destination directory must not already exist.</span></span><br><span class="line"><span class="string">    If exception(s) occur, an Error is raised with a list of reasons.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the optional symlinks flag is true, symbolic links in the</span></span><br><span class="line"><span class="string">    source tree result in symbolic links in the destination tree; if</span></span><br><span class="line"><span class="string">    it is false, the contents of the files pointed to by symbolic</span></span><br><span class="line"><span class="string">    links are copied. If the file pointed by the symlink doesn't</span></span><br><span class="line"><span class="string">    exist, an exception will be added in the list of errors raised in</span></span><br><span class="line"><span class="string">    an Error exception at the end of the copy process.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can set the optional ignore_dangling_symlinks flag to true if you</span></span><br><span class="line"><span class="string">    want to silence this exception. Notice that this has no effect on</span></span><br><span class="line"><span class="string">    platforms that don't support os.symlink.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The optional ignore argument is a callable. If given, it</span></span><br><span class="line"><span class="string">    is called with the `src` parameter, which is the directory</span></span><br><span class="line"><span class="string">    being visited by copytree(), and `names` which is the list of</span></span><br><span class="line"><span class="string">    `src` contents, as returned by os.listdir():</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        callable(src, names) -&gt; ignored_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Since copytree() is called recursively, the callable will be</span></span><br><span class="line"><span class="string">    called once for each directory that is copied. It returns a</span></span><br><span class="line"><span class="string">    list of names relative to the `src` directory that should</span></span><br><span class="line"><span class="string">    not be copied.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The optional copy_function argument is a callable that will be used</span></span><br><span class="line"><span class="string">    to copy each file. It will be called with the source path and the</span></span><br><span class="line"><span class="string">    destination path as arguments. By default, copy2() is used, but any</span></span><br><span class="line"><span class="string">    function that supports the same signature (like copy()) can be used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># names中存储了目录所有文件的列表---不能区分文件或者目录</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    <span class="keyword">if</span> ignore <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        ignored_names = ignore(src, names)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ignored_names = set()</span><br><span class="line">    <span class="comment"># 这里是os.makedirs，所以是递归创建目录的，也就是可以创建父目录</span></span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="comment"># 判断是不是复制ignore的条件，符合就直接进行下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> ignored_names:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                <span class="comment"># 函数传递的参数</span></span><br><span class="line">                <span class="keyword">if</span> symlinks:</span><br><span class="line">                    <span class="comment"># We can't just leave it to `copy_function` because legacy</span></span><br><span class="line">                    <span class="comment"># code with a custom `copy_function` may rely on copytree</span></span><br><span class="line">                    <span class="comment"># doing the right thing.</span></span><br><span class="line">                    os.symlink(linkto, dstname)</span><br><span class="line">                    copystat(srcname, dstname, follow_symlinks=<span class="keyword">not</span> symlinks)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># ignore dangling symlink if the flag is on</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(linkto) <span class="keyword">and</span> ignore_dangling_symlinks:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># otherwise let the copy occurs. copy2 will raise an error</span></span><br><span class="line">                    <span class="keyword">if</span> os.path.isdir(srcname):</span><br><span class="line">                        <span class="comment"># 这部分是递归复制</span></span><br><span class="line">                        copytree(srcname, dstname, symlinks, ignore,</span><br><span class="line">                                 copy_function)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        copy_function(srcname, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks, ignore, copy_function)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Will raise a SpecialFileError for unsupported file types</span></span><br><span class="line">                copy_function(srcname, dstname)</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># Copying file access times may fail on Windows</span></span><br><span class="line">        <span class="keyword">if</span> getattr(why, <span class="string">'winerror'</span>, <span class="keyword">None</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            errors.append((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略pyc文件和tmp文件</span></span><br><span class="line"><span class="comment"># 注意destination肯定是不存在的</span></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br><span class="line">copytree(<span class="string">'folder1'</span>, <span class="string">'folder2'</span>, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制链接，不是复制链接指向文件的内容</span></span><br><span class="line">copytree(<span class="string">'f1'</span>, <span class="string">'f2'</span>, symlinks=<span class="keyword">True</span>, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="递归删除"><a href="#递归删除" class="headerlink" title="递归删除"></a>递归删除</h3><p><strong>命令</strong>：<code>shutil.rmtree(path[, ignore_errors[, onerror]])</code>，<strong>递归地删除目录(path，不能为链接目录)及子目录内的文件</strong>。注意！该方法不会询问yes或no，被删除的文件也不会出现在回收站里，<strong>请务必小心</strong>！</p><p><strong>参数</strong>：</p><ul><li><strong><code>path</code></strong>：指定目录，但不能是链接指向的目录，传递的是<strong>字符串形式的文件路径而不是文件对象</strong></li><li><strong><code>ignore_errors</code></strong>：设置为true，删除过程中的出错不会被抛出，会被忽略；如果为false或者忽略这个参数，删除过程中的错误会调用onerror中的错误处理方式进行处理，如果<code>onerror</code>中没有定义处理方式，就会抛出错误。</li><li><strong>onerror</strong>：一旦提供这个参数，就必须有三个参数<code>function</code>、<code>path</code>和<code>excinfo</code>.<ul><li><code>function</code>：抛出异常的函数，是<code>os.path.islink()</code>、<code>os.listdir()</code>、 <code>os.remove()</code>或者<code>os.rmdir()</code></li><li><code>path</code>：传递给function参数的path名</li><li><code>excinfo</code>：<code>sys.exc_info()</code>返回的异常信息</li><li><code>onerror</code>的异常不会被捕获</li></ul></li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="comment"># 去除文件的只读属性，尝试再次删除</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    <span class="comment"># 这里的func是针对前面抛出异常的操作</span></span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>需要注意的方面</strong>：<br><strong>删除路径的最后一个目录，而不是整个路径</strong>，例如<code>shutil.rmtree(&#39;user/tester/noob&#39;)</code>只会删除最后的<code>noob</code>目录的所有内容，而不会将整个路径<code>&#39;user/tester/noob&#39;</code>包含的文件夹都删除，参考<a href="https://stackoverflow.com/questions/10873364/shutil-rmtree-clarification" target="_blank" rel="noopener">这个链接</a>。</p></div><hr><h3 id="剪切目录"><a href="#剪切目录" class="headerlink" title="剪切目录"></a>剪切目录</h3><p><strong>命令</strong>：<code>shutil.move(src, dst)</code>，递归地移动文件或者目录，类似<code>mv</code>命令；如果destination是一个已经存在的目录，src会直接移动到这个目录中；如果destination已经存在但不是一个目录，destination将会被重写；如果是同一个文件或者目录，重命名。</p><hr><h3 id="查找文件路径"><a href="#查找文件路径" class="headerlink" title="查找文件路径"></a>查找文件路径</h3><p><strong>命令</strong>：<code>which(cmd, mode=os.F_OK | os.X_OK, path=None)</code>，返回文件路径，类似Linux的<code>which</code>命令</p><p><strong>参数讲解</strong>：</p><ul><li><strong><code>cmd</code></strong>：需要查找的内容-字符串形式</li><li><strong><code>mode</code></strong>：查找内容的权限，默认情况<code>os.F_OK</code>：path是否存在以及<code>os.X_OK</code>：path是否可执行</li><li><strong><code>path</code></strong>：在指定路径中查找</li></ul><p><strong>使用场景</strong>：典型的使用场景是在环境变量 <code>PATH</code> 定义的路径中查找<strong>可执行程序</strong>的位置，如果<strong>没有找到文件</strong>，<code>which()</code> 返回 <code>None</code></p><hr><p><br></p><h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><h3 id="查看支持的压缩文件格式"><a href="#查看支持的压缩文件格式" class="headerlink" title="查看支持的压缩文件格式"></a>查看支持的压缩文件格式</h3><p><strong>命令</strong>：<code>shutil.get_archive_formats()</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> format, description <span class="keyword">in</span> shutil.get_archive_formats():</span><br><span class="line">    print(<span class="string">'&#123;:&lt;5&#125;: &#123;&#125;'</span>.format(format, description))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    bztar: bzip2<span class="string">'ed tar-file</span></span><br><span class="line"><span class="string">    gztar: gzip'</span>ed tar-file</span><br><span class="line">    tar  : uncompressed tar file</span><br><span class="line">    xztar: xz<span class="string">'ed tar-file</span></span><br><span class="line"><span class="string">    zip  : ZIP file</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建归档或压缩文件"><a href="#创建归档或压缩文件" class="headerlink" title="创建归档或压缩文件"></a>创建归档或压缩文件</h3><p><strong>命令</strong>：<code>shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>base_name</code></strong>：<strong>压缩后的文件名(不包含拓展名)</strong>；如果不指定绝对路径，则压缩文件保存在当前目录下；<strong>这个参数必须指定</strong></li><li><strong><code>format</code></strong>：<strong>压缩格式</strong>，可以是<code>zip</code>、<code>tar</code>、<code>bztar(tar.bz2)</code>、<code>gztar(tar.gz)</code>、<code>xztar</code>中的一种；<strong>这个参数也必须指定</strong></li><li><strong><code>root_dir</code></strong>：<strong>设置压缩包里的根目录</strong>，即在创建归档之前先切换到它指定的目录，一般使用默认值，不特别指定</li><li><strong><code>base_dir</code></strong>：要<strong>进行压缩的源文件或目录</strong>，如果<strong>没有提供</strong>则<strong>对root_dir目录下的所有文件进行归档压缩</strong></li><li><strong><code>dry_run</code></strong>：如果值为Ture表示不会创建归档，但是操作输出会被记录到logger中，<strong>可用于测试</strong></li><li><strong><code>owner</code></strong>：<strong>用户</strong>，默认当前用户</li><li><strong><code>group</code></strong>：<strong>组</strong>，默认当前组</li><li><strong><code>logger</code></strong>：用于<strong>记录日志</strong>，通常是logging.Logger对象</li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供base_dir</span></span><br><span class="line">shutil.make_archive(base_name=<span class="string">"test"</span>, format=<span class="string">"gztar"</span>,  base_dir=<span class="string">"./cat"</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    <span class="string">'test.tar.gz'</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 注意文件中显示的路径，如果前面设置的是全路径，会创建全路径的文件夹</span></span><br><span class="line">    drwxrwxr-x user/user     <span class="number">0</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./cat/</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">13</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">28</span> ./cat/test1.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">7</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./cat/test2.txt</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">20</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./cat/test3.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">14</span> ./cat/filename</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./cat/test4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只提供root_dir</span></span><br><span class="line">shutil.make_archive(base_name=<span class="string">"test2"</span>, format=<span class="string">"gztar"</span>,  root_dir=<span class="string">"./cat"</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    <span class="string">'absolute_path/test2.tar.gz'</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    drwxrwxr-x user/user     <span class="number">0</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">13</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">28</span> ./test1.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">7</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./test2.txt</span><br><span class="line">    -rw-rw-r-- user/user    <span class="number">20</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">05</span> ./test3.txt</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">14</span> ./filename</span><br><span class="line">    -rw-rw-r-- user/user     <span class="number">8</span> <span class="number">2019</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">29</span> ./test4.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>设置<code>base_dir</code>之后</strong>会在压缩的文件中会出现设置的<code>base_dir</code>路径(<strong>保留了原始路径信息</strong>)，这个需要特别注意，如果设置的是全路径指向某一个文件，解压的结果中也会包含那个全路径；<strong>如果设置的是<code>root_dir</code>，不设置<code>base_dir</code></strong>，默认对<code>root_dir</code>中的进行压缩，则不会有上述麻烦，生成的文件解压后直接可以看到内容，<strong>不会出现全路径</strong>。</p></div><hr><h3 id="解压缩后缀与格式的对应"><a href="#解压缩后缀与格式的对应" class="headerlink" title="解压缩后缀与格式的对应"></a>解压缩后缀与格式的对应</h3><p><strong>命令</strong>：<code>shutil.get_unpack_formats()</code></p><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> format, exts, description <span class="keyword">in</span> shutil.get_unpack_formats():</span><br><span class="line">    print(<span class="string">'&#123;:&lt;5&#125;: &#123;&#125;, names ending in &#123;&#125;'</span>.format(</span><br><span class="line">        format, description, exts))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">    bztar: bzip2<span class="string">'ed tar-file, names ending in ['</span>.tar.bz2<span class="string">', '</span>.tbz2<span class="string">']</span></span><br><span class="line"><span class="string">    gztar: gzip'</span>ed tar-file, names ending <span class="keyword">in</span> [<span class="string">'.tar.gz'</span>, <span class="string">'.tgz'</span>]</span><br><span class="line">    tar  : uncompressed tar file, names ending <span class="keyword">in</span> [<span class="string">'.tar'</span>]</span><br><span class="line">    xztar: xz<span class="string">'ed tar-file, names ending in ['</span>.tar.xz<span class="string">', '</span>.txz<span class="string">']</span></span><br><span class="line"><span class="string">    zip  : ZIP file, names ending in ['</span>.zip<span class="string">']</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="解压缩或解包源文件"><a href="#解压缩或解包源文件" class="headerlink" title="解压缩或解包源文件"></a>解压缩或解包源文件</h3><p><strong>命令</strong>：<code>shutil.unpack_archive(filename[, extract_dir[, format]])</code></p><p><strong>参数说明</strong>：</p><ul><li><strong><code>filename</code></strong>：是压缩文档的<strong>完整路径</strong></li><li><strong><code>extract_dir</code></strong>：是<strong>解压缩路径</strong>，默认为当前目录</li><li><strong><code>format</code></strong>：是<strong>压缩格式</strong>，<strong>默认使用文件后缀名代码的压缩格式</strong>，可以是<code>zip</code>、<code>tar</code>、<code>bztar(tar.bz2)</code>、<code>gztar(tar.gz)</code>、<code>xztar</code>中的一种；如果<strong>不提供这个参数</strong>，程序会<strong>根据filename的后缀名</strong>来自动选择方法。</li></ul><p><strong>使用实例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># filename是全路径</span></span><br><span class="line">shutil.unpack_archive(<span class="string">"full_path/test.tar.gz"</span>, <span class="string">"./test"</span>, <span class="string">'gztar'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/61" target="_blank" rel="noopener">shutil</a></li><li><a href="https://www.cnblogs.com/yyds/p/6427349.html" target="_blank" rel="noopener">Python之文件与目录操作（os、zipfile、tarfile、shutil）</a></li><li><a href="https://docs.python.org/3/library/shutil.html" target="_blank" rel="noopener">shutil — High-level file operations</a></li><li><a href="https://learnku.com/docs/pymotw/shutil-high-order-file-operation/3397" target="_blank" rel="noopener">实例教程</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之os-使用操作系统相关功能</title>
      <link href="/posts/24368.html"/>
      <url>/posts/24368.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python使用操作系统相关功能的os模块，其主要功能包括：<strong>系统相关</strong>、<strong>目录及文件操作</strong>、<strong>执行命令和管理进程</strong>，这里主要学习了<strong>常用的目录及文件操作</strong>，其中涉及到的功能非常多，需要时可以查看使用，最后还学习了<strong>系统相关中的查看和新增环境变量操作</strong>，较为实用。</p></div><a id="more"></a><h2 id="os模块简介"><a href="#os模块简介" class="headerlink" title="os模块简介"></a>os模块简介</h2><ul><li><code>os</code>模块是Python标准库中的一个用于<strong>访问操作系统相关功能</strong>的模块，<code>os</code>模块提供了一种<strong>可移植</strong>的使用操作系统功能的方法</li><li>使用<code>os</code>模块中提供的接口，可以<strong>实现跨平台访问</strong>，但是，<strong>并不是所有的</strong><code>os</code>模块中的接口在全平台都通用，<strong>有些接口的实现是依赖特定平台</strong>的，比如linux相关的文件权限管理和进程管理</li><li><code>os</code>模块的<strong>主要功能</strong>：<strong>系统相关</strong>、<strong>目录及文件操作</strong>、<strong>执行命令和管理进程</strong></li><li>在使用<code>os</code>模块的时候，如果出现了问题，会抛出<code>OSError</code>异常，表明<strong>无效的路径名或文件名</strong>，<strong>或者路径名(文件名)无法访问</strong>，<strong>或者当前操作系统不支持该操作</strong></li></ul><hr><h2 id="目录及文件操作"><a href="#目录及文件操作" class="headerlink" title="目录及文件操作"></a>目录及文件操作</h2><p>因为平常使用<code>os</code>模块一般也就是文件以及目录操作，所以这里先学习文件及目录相关操作的命令。<br><code>os</code>模块中包含了一系列文件操作相关的函数，<strong>其中有一部分是Linux平台专用方法</strong>(Linux是用C写的，底层的<code>libc</code>库和系统调用的接口都是<code>C API</code>，Python的<code>os</code>模块中包括了对这些接口的Python实现，通过Python的<code>os</code>模块，可以调用Linux系统的一些底层功能，进行系统编程，关于Linux的相关方法，内容较为复杂，可根据需要自行查阅官方文档），这里只介绍一些<strong>常用的，各平台通用</strong>的方法(包括了<code>os</code>模块和<code>os.path</code>模块):</p><table><thead><tr><th width="30%">方法和变量</th><th width="70%">用途</th></tr></thead><tbody><tr><td><code>os.getcwd()</code></td><td>获取当前工作目录，即当前python脚本工作的目录路径</td></tr><tr><td><code>os.chdir("dirname")</code></td><td>改变当前脚本工作目录；相当于shell下cd</td></tr><tr><td><code>os.curdir</code></td><td>返回当前目录: ('.')</td></tr><tr><td><code>os.pardir</code></td><td>获取当前目录的父目录字符串名：('..')</td></tr><tr><td><code>os.makedirs('dir1/dir2')</code></td><td>可生成<strong>多层递归目录</strong></td></tr><tr><td><code>os.removedirs(‘dirname1’)</code></td><td><strong>递归删除空</strong>目录（要小心）</td></tr><tr><td><code>os.mkdir('dirname')</code></td><td>生成<strong>单级</strong>目录</td></tr><tr><td><code>os.rmdir('dirname')</code></td><td><strong>删除单级空</strong>目录，若目录不为空则无法删除并报错</td></tr><tr><td><code>os.listdir('dirname')</code></td><td>列出指定目录下的所有文件和子目录，<strong>包括隐藏文件</strong></td></tr><tr><td><code>os.scandir('dirname')</code></td><td>更详细地列出所有文件和子目录，相当于<code>os.listdir('dirname')</code>的升级版</td></tr><tr><td><code>os.remove('filename')</code></td><td>删除一个文件</td></tr><tr><td><code>os.rename("oldname","new")</code></td><td>重命名文件/目录</td></tr><tr><td><code>os.stat('path/filename')</code></td><td>获取文件/目录信息</td></tr><tr><td><code>os.access(path, mode)</code></td><td>检测文件或目录的访问权限</td></tr><tr><td><code>os.chmod(path, mode)</code></td><td>修改文件权限</td></tr><tr><td><code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code></td><td>遍历整个目录结构，对每一个目录都返回一个三元元组(dirpath, dirnames, filenames)</td></tr><tr><td><code>os.path.abspath(path)</code></td><td>返回path规范化的<strong>绝对路径</strong></td></tr><tr><td><code>os.path.split(path)</code></td><td>将path分割成<strong>目录和文件名二元组返回</strong></td></tr><tr><td><code>os.path.splitext(path)</code></td><td>分割路径为后缀名(eg:.txt)和之前部分</td></tr><tr><td><code>os.path.dirname(path)</code></td><td>返回path的目录。其实就是<code>os.path.split(path)</code>的第一个元素</td></tr><tr><td><code>os.path.basename(path)</code></td><td>返回path最后的文件名。如果path以<code>／</code>或<code>\</code>结尾，那么就会返回空值。</td></tr><tr><td><code>os.path.exists(path或者file)</code></td><td>如果path存在，返回True；如果path不存在，返回False</td></tr><tr><td><code>os.path.isabs(path)</code></td><td>如果path是绝对路径，返回True</td></tr><tr><td><code>os.path.isfile(path)</code></td><td>如果path是一个存在的文件，返回True。否则返回False</td></tr><tr><td><code>os.path.isdir(path)</code></td><td>如果path是一个存在的目录，则返回True。否则返回False</td></tr><tr><td><code>os.path.join(path1[, path2[, ...]])</code></td><td>将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</td></tr><tr><td><code>os.path.getatime(path)</code></td><td>返回path所指向的文件或者目录的最后存取时间</td></tr><tr><td><code>os.path.getmtime(path)</code></td><td>返回path所指向的文件或者目录的最后修改时间</td></tr><tr><td><code>os.path.relpath(path, start)</code></td><td>返回path<strong>相对于start(比如os.curdir)的相对路径,start默认为根目录</strong></td></tr><tr><td><code>os.path.realpath(path)</code></td><td>获取path的真实、绝对路径(<strong>可用于获取软链接文件指向的文件路径</strong>)</td></tr><tr><td><code>os.path.samefile(path1, path2)</code></td><td>判断path1和path2是否为同一个文件</td></tr><tr><td><code>os.path.getsize(filename)</code></td><td>返回文件包含的字符数量</td></tr></tbody></table><h3 id="获取当前工作目录-os-getcwd"><a href="#获取当前工作目录-os-getcwd" class="headerlink" title="获取当前工作目录-os.getcwd()"></a>获取当前工作目录-os.getcwd()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回当前工作目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python文件地址：</span></span><br><span class="line"><span class="comment"># "c:\FastFolder\learn_test\os_learn.py"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出工作目录而不是python文件所在的目录</span></span><br><span class="line"><span class="comment"># 如果需要得到文件所在目录，后续有专门的命令</span></span><br><span class="line">c:\FastFolder</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="改变当前工作目录-os-chdir"><a href="#改变当前工作目录-os-chdir" class="headerlink" title="改变当前工作目录-os.chdir()"></a>改变当前工作目录-os.chdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变工作目录</span></span><br><span class="line"><span class="comment"># 将工作目录改变到py文件所在的目录</span></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变工作目录之后输出当前工作目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现此时的工作目录已经改变</span></span><br><span class="line">c:\FastFolder\learn_test</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="创建单层目录-os-mkdir"><a href="#创建单层目录-os-mkdir" class="headerlink" title="创建单层目录-os.mkdir()"></a>创建单层目录-os.mkdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先返回当前目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层目录-相对路径</span></span><br><span class="line">mk_dir=<span class="string">'test_single_dir'</span></span><br><span class="line">os.mkdir(mk_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层目录-绝对路径</span></span><br><span class="line">mk_dir=<span class="string">r'c:\FastFolder\learn_test\python_test\test_single_dir'</span></span><br><span class="line">os.mkdir(mk_dir)</span><br></pre></td></tr></table></figure><div class="note info"><p>os.mkdir()还可以设置创建的目录的mode权限，具体参考<a href="https://docs.python.org/3/library/os.html#os.mkdir" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="删除单层空目录-os-rmdir"><a href="#删除单层空目录-os-rmdir" class="headerlink" title="删除单层空目录-os.rmdir()"></a>删除单层空目录-os.rmdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除单层目录，相对路径和绝对路径均可</span></span><br><span class="line">os.rmdir(mk_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录非空会报错</span></span><br><span class="line"><span class="comment"># OSError: [WinError 145] 目录不是空的。</span></span><br><span class="line">os.rmdir(mk_dir)</span><br></pre></td></tr></table></figure><hr><h3 id="递归创建目录-os-makedirs"><a href="#递归创建目录-os-makedirs" class="headerlink" title="递归创建目录-os.makedirs()"></a>递归创建目录-os.makedirs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先返回当前目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录-相对路径</span></span><br><span class="line">mk_dirs=<span class="string">'test_dir/test'</span></span><br><span class="line">os.makedirs(mk_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录-绝对路径</span></span><br><span class="line">mk_dirs=<span class="string">r'c:\FastFolder\learn_test\python_test\test_dir\test'</span></span><br><span class="line">os.makedirs(mk_dirs)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line"><span class="string">'c:\FastFolder'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录创建了test_dir/test目录</span></span><br><span class="line"><span class="comment"># 在指定的绝对路径下创建了test_dir/test目录</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>os.makedirs()还可以设置创建的目录的mode权限，具体参考<a href="https://docs.python.org/3/library/os.html#os.makedirs" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="递归删除多级空目录-os-removedirs"><a href="#递归删除多级空目录-os-removedirs" class="headerlink" title="递归删除多级空目录-os.removedirs()"></a>递归删除多级空目录-os.removedirs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归删除多级目录-绝对或者相对路径均可</span></span><br><span class="line">os.removedirs(mk_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除也需要</span></span><br><span class="line"><span class="comment"># 如果目录非空会报错：</span></span><br><span class="line"><span class="comment"># OSError: [WinError 145] 目录不是空的。: 'test_dir'</span></span><br><span class="line">os.removedirs(<span class="string">'test_dir'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>关于创建和删除单层、多层目录：</p><ul><li>创建单层和删除单层可以使用：<code>os.mkdir()</code>、<code>os.rmdir()</code></li><li>创建多层和删除多层可以使用：<code>os.makedirs()</code>、<code>os.removedirs()</code></li><li>两者之间不仅仅是<code>dirs</code>和<code>dir</code>的区别，还有<code>make</code>和<code>mk</code>、<code>remove</code>和<code>rm</code>的区别<br><br><br>Python删除目录os.removedirs()的过程：If the <strong>leaf directory is succesfully removed</strong>, removedirs <strong>tries to successively remove every parent directory displayed in path</strong>.</li></ul></div><hr><h3 id="列出所有文件和子目录-os-listdir"><a href="#列出所有文件和子目录-os-listdir" class="headerlink" title="列出所有文件和子目录-os.listdir()"></a>列出所有文件和子目录-os.listdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下的所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># 不会显示子目录内容</span></span><br><span class="line">os.listdir(<span class="string">'.'</span>)</span><br><span class="line">os.listdir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定目录下的所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># 这里使用了相对路径，使用绝对路径也是可以的</span></span><br><span class="line">os.listdir(<span class="string">'./python_test'</span>)</span><br><span class="line">os.listdir(<span class="string">'python_test'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下所有文件和目录，返回列表</span></span><br><span class="line"><span class="comment"># python_test为目录，os_learn.py为文件</span></span><br><span class="line">[<span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">'all.log'</span>, <span class="string">'argparse_parent_with_group.py'</span>, <span class="string">'argparse_test.py'</span>, <span class="string">'error.log'</span>, <span class="string">'log.txt'</span>, <span class="string">'logging_learn.py'</span>, <span class="string">'main'</span>, <span class="string">'my.log'</span>, <span class="string">'myapp.log'</span>, <span class="string">'test_dir'</span>, <span class="string">'__pycache__'</span>]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>os.listdir()</code>的缺点在于返回值为字符串组成的列表，<strong>不能从返回值中分辨它们是文件、目录还是符号连接</strong></p></div><hr><h3 id="更详细地列出所有文件和子目录-os-scandir"><a href="#更详细地列出所有文件和子目录-os-scandir" class="headerlink" title="更详细地列出所有文件和子目录-os.scandir()"></a>更详细地列出所有文件和子目录-os.scandir()</h3><p>针对上面<code>os.listdir()</code>不能从返回值中分辨它们是文件、目录还是符号连接，使用<code>os.scandir()</code>扫描目录时，返回目录中每一个项目 <code>DirEntry</code> 实例的序列，这种对象有<strong>几种属性和方法(是否为目录、文件或者链接)</strong>，可以用于访问文件的元数据：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir():</span><br><span class="line">    <span class="comment"># 判断是否为目录</span></span><br><span class="line">    <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">        typ = <span class="string">'dir'</span></span><br><span class="line">    <span class="comment"># 判断是否为文件</span></span><br><span class="line">    <span class="keyword">elif</span> entry.is_file():</span><br><span class="line">        typ = <span class="string">'file'</span></span><br><span class="line">      <span class="comment"># 判断是否为链接</span></span><br><span class="line">    <span class="keyword">elif</span> entry.is_symlink():</span><br><span class="line">        typ = <span class="string">'link'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        typ = <span class="string">'unknown'</span></span><br><span class="line">    print(<span class="string">'&#123;name&#125; &#123;typ&#125;'</span>.format(</span><br><span class="line">        name=entry.name,</span><br><span class="line">        typ=typ,</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_name.txt file</span><br><span class="line">old_name dir</span><br><span class="line">os_learn.py file</span><br><span class="line">python_test dir</span><br><span class="line">tempCodeRunnerFile.py file</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="删除文件-os-remove"><a href="#删除文件-os-remove" class="headerlink" title="删除文件-os.remove()"></a>删除文件-os.remove()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下的文件</span></span><br><span class="line">os.remove(<span class="string">'to_remove.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定目录下的文件</span></span><br><span class="line">os.remove(<span class="string">r"c:\FastFolder\learn_test\to_remove.txt"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="重命名文件或目录-os-rename"><a href="#重命名文件或目录-os-rename" class="headerlink" title="重命名文件或目录-os.rename()"></a>重命名文件或目录-os.rename()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录所有文件</span></span><br><span class="line">os.listdir()</span><br><span class="line">  <span class="comment"># old_name为文件夹，old_name.txt为文件</span></span><br><span class="line">  [<span class="string">'old_name'</span>, <span class="string">'old_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名目录</span></span><br><span class="line">os.rename(<span class="string">'old_name'</span>,<span class="string">'new_name'</span>)</span><br><span class="line">  <span class="comment"># 不管目录是否为空，都可以正常重命名</span></span><br><span class="line">  [<span class="string">'new_name'</span>, <span class="string">'old_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命令文件</span></span><br><span class="line">os.rename(<span class="string">'old_name.txt'</span>,<span class="string">'new_name.txt'</span>)</span><br><span class="line">  [<span class="string">'new_name'</span>, <span class="string">'new_name.txt'</span>, <span class="string">'os_learn.py'</span>, <span class="string">'python_test'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="获取文件或目录信息-os-stat"><a href="#获取文件或目录信息-os-stat" class="headerlink" title="获取文件或目录信息-os.stat()"></a>获取文件或目录信息-os.stat()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与os.listdir()不同，必须要指定目录</span></span><br><span class="line">os.stat(<span class="string">'.'</span>)</span><br><span class="line">  os.stat_result(st_mode=<span class="number">16895</span>, st_ino=<span class="number">1688849860706458</span>, st_dev=<span class="number">3422898436</span>, st_nlink=<span class="number">1</span>, st_uid=<span class="number">0</span>, st_gid=<span class="number">0</span>, st_size=<span class="number">0</span>, st_atime=<span class="number">1554014658</span>, st_mtime=<span class="number">1554014658</span>, st_ctime=<span class="number">1553005707</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="检测文件或目录的访问权限-os-access-path-mode"><a href="#检测文件或目录的访问权限-os-access-path-mode" class="headerlink" title="检测文件或目录的访问权限-os.access(path, mode)"></a>检测文件或目录的访问权限-os.access(path, mode)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#  __file__：当前脚本的路径</span></span><br><span class="line">print(<span class="string">'Testing:'</span>, __file__)</span><br><span class="line">print(<span class="string">'Exists:'</span>, os.access(__file__, os.F_OK))</span><br><span class="line">print(<span class="string">'Readable:'</span>, os.access(__file__, os.R_OK))</span><br><span class="line">print(<span class="string">'Writable:'</span>, os.access(__file__, os.W_OK))</span><br><span class="line">print(<span class="string">'Executable:'</span>, os.access(__file__, os.X_OK))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为True或者False</span></span><br></pre></td></tr></table></figure><div class="note info"><p>mode包含<code>F_OK</code>、<code>R_OK</code>、<code>W_OK</code>和<code>X_OK</code>：</p><ul><li><code>os.F_OK</code>：作为access()的mode参数，测试<strong>path是否存在</strong></li><li><code>os.R_OK</code>：包含在access()的mode参数中 ， 测试<strong>path是否可读</strong></li><li><code>os.W_OK</code>：包含在access()的mode参数中 ， 测试<strong>path是否可写</strong></li><li><code>os.X_OK</code>：包含在access()的mode参数中 ，测试<strong>path是否可执行</strong></li></ul></div><hr><h3 id="修改文件权限-os-chmod-path-mode"><a href="#修改文件权限-os-chmod-path-mode" class="headerlink" title="修改文件权限-os.chmod(path, mode)"></a>修改文件权限-os.chmod(path, mode)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> stat</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'os_stat_chmod_example.txt'</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(filename):</span><br><span class="line">    os.unlink(filename)</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'contents'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 函数判断文件当前的权限</span></span><br><span class="line"><span class="comment"># stat.S_IMODE：返回文件权限的chmod格式</span></span><br><span class="line">existing_permissions = stat.S_IMODE(os.stat(filename).st_mode)</span><br><span class="line"><span class="comment"># 得到的是类似438这种的code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.access(filename, os.X_OK):</span><br><span class="line">    print(<span class="string">'Adding execute permission'</span>)</span><br><span class="line">    <span class="comment"># stat.S_IXUSR：拥有者具有执行权限</span></span><br><span class="line">    new_permissions = existing_permissions | stat.S_IXUSR</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Removing execute permission'</span>)</span><br><span class="line">    <span class="comment"># 使用 xor 异或清除用户的执行权限</span></span><br><span class="line">    <span class="comment"># 异或操作：属于A或B，但不属于A交B---&gt;(A-B)∪(B-A)</span></span><br><span class="line">    new_permissions = existing_permissions ^ stat.S_IXUSR</span><br><span class="line"></span><br><span class="line">os.chmod(filename, new_permissions)</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>权限分组(分为三组)</strong>：</p><ul><li><strong>第一组</strong>：文件或目录所有者的权限</li><li><strong>第二组</strong>：与文件或目录所有者同一组的用户的权限</li><li><strong>第三组</strong>：不与文件或目录所有者同组的其他用户(系统中其他用户)的权限</li></ul><p><strong>使用Python的<code>os.chmod</code>修改权限时需要注意进制转换</strong>：<br>如果像在Linux中修改权限为<strong>664(八进制)</strong>，在Python中需要为<strong>0664</strong>，原因：If you’re wondering why that leading zero is important, it’s because <strong>permissions are set as an octal integer(八进制整数)</strong>, and <strong>Python automagically treats any integer with a leading zero as octal(Python会将带0的视为八进制数)</strong>. So <strong>os.chmod(“file”, 436) (in decimal-十进制)</strong>would give the same result.</p><p>进制转换参考<a href="https://stackoverflow.com/questions/15607903/python-module-os-chmodfile-664-does-not-change-the-permission-to-rw-rw-r-bu" target="_blank" rel="noopener">这个链接</a></p><p>关于<code>stat</code>模块和<code>os.stat()</code>参考<a href="https://www.cnblogs.com/maseng/p/3386140.html" target="_blank" rel="noopener">这个链接</a></p></div><hr><h3 id="返回绝对路径-os-path-abspath"><a href="#返回绝对路径-os-path-abspath" class="headerlink" title="返回绝对路径-os.path.abspath()"></a>返回绝对路径-os.path.abspath()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回绝对路径</span></span><br><span class="line"><span class="comment"># 注意和os.stat()相同，必须要指定目录</span></span><br><span class="line">os.path.abspath(<span class="string">'.'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回文件的绝对路径</span></span><br><span class="line">os.path.abspath(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割路径为目录和文件名-os-path-split"><a href="#分割路径为目录和文件名-os-path-split" class="headerlink" title="分割路径为目录和文件名-os.path.split()"></a>分割路径为目录和文件名-os.path.split()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果指定的path是相对路径，目录则会返回相对路径</span></span><br><span class="line">os.path.split(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回元组，第一个元素为目录，第二个元素为文件名</span></span><br><span class="line">  (<span class="string">'.'</span>, <span class="string">'new_name.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最后是以/结尾，返回的文件名为空</span></span><br><span class="line">os.path.split(<span class="string">'./'</span>) )</span><br><span class="line">  (<span class="string">'.'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定的路径为绝对路径，返回绝对路径的目录和文件名</span></span><br><span class="line">os.path.split(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回元组，第一个元素为目录，第二个元素为文件名</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test'</span>, <span class="string">'new_name.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果最后是以/结尾，返回的文件名为空</span></span><br><span class="line">os.path.split(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 感觉应该就是直接从最后一个/号进行了分割，前面的返回目录，后面的作为文件名</span></span><br><span class="line"><span class="comment"># 如果path中没有/，则目录会为空，文件名不为空</span></span><br><span class="line">os.path.split(<span class="string">'test.sh'</span>)</span><br><span class="line">  (<span class="string">''</span>, <span class="string">'test.sh'</span>)</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>感觉应该就是直接<strong>从最后一个<code>/</code>号进行了分割</strong>，<strong>前面的返回目录</strong>，<strong>后面的作为文件名</strong></li><li>如果最后<strong>是以<code>/</code>结尾</strong>，返回的<strong>文件名为空</strong></li><li>如果path中<strong>没有<code>/</code></strong>，则<strong>目录会为空</strong>，<strong>文件名不为空</strong></li></ul></div><hr><h3 id="分割路径为后缀名-eg-txt-和之前部分-os-path-splitext"><a href="#分割路径为后缀名-eg-txt-和之前部分-os-path-splitext" class="headerlink" title="分割路径为后缀名(eg:.txt)和之前部分-os.path.splitext()"></a>分割路径为后缀名(eg:.txt)和之前部分-os.path.splitext()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本和上面的os.path.split()差不多</span></span><br><span class="line"><span class="comment"># 唯一的区别是返回的二元组是后缀名和前部分</span></span><br><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">os.path.splitext(<span class="string">"./new_name.txt"</span>)</span><br><span class="line">  <span class="comment"># 返回的元组是后缀名和前部分</span></span><br><span class="line">  (<span class="string">'./new_name'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">os.path.splitext(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="comment"># 返回的元组是后缀名和前部分</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有后缀名，返回空字符</span></span><br><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">os.path.splitext(<span class="string">"./new_name"</span>)</span><br><span class="line">  <span class="comment"># 没有后缀，返回的是空字符</span></span><br><span class="line">  (<span class="string">'./new_name'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">os.path.splitext(<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>)</span><br><span class="line">  <span class="comment"># 没有后缀，返回的是空字符</span></span><br><span class="line">  (<span class="string">'c:\\FastFolder\\learn_test\\new_name'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不含\也和上面相同</span></span><br><span class="line">os.path.splitext(<span class="string">'test.sh'</span>)</span><br><span class="line">  (<span class="string">'test'</span>, <span class="string">'.sh'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="得到路径的目录-os-path-dirname"><a href="#得到路径的目录-os-path-dirname" class="headerlink" title="得到路径的目录-os.path.dirname()"></a>得到路径的目录-os.path.dirname()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径得到的也是相对路径</span></span><br><span class="line">os.path.dirname(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径得到的也是绝对路径</span></span><br><span class="line">os.path.dirname(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第一个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="返回文件名-os-path-basename"><a href="#返回文件名-os-path-basename" class="headerlink" title="返回文件名-os.path.basename()"></a>返回文件名-os.path.basename()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第二个元素</span></span><br><span class="line">os.path.basename(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="string">'new_name.txt'</span></span><br><span class="line">  </span><br><span class="line">os.path.basename(<span class="string">'./'</span>)</span><br><span class="line">  <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于就是上面os.path.split()得到的元组的第二个元素</span></span><br><span class="line">os.path.basename(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="string">'new_name.txt'</span></span><br><span class="line"></span><br><span class="line">os.path.basename(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="string">''</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断文件和目录是否存在-os-path-exists"><a href="#判断文件和目录是否存在-os-path-exists" class="headerlink" title="判断文件和目录是否存在-os.path.exists()"></a>判断文件和目录是否存在-os.path.exists()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line">os.path.exists(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">os.path.exists(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断目录是否存在</span></span><br><span class="line">os.path.exists(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为绝对路径-os-path-isabs"><a href="#判断是否为绝对路径-os-path-isabs" class="headerlink" title="判断是否为绝对路径-os.path.isabs()"></a>判断是否为绝对路径-os.path.isabs()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径返回false</span></span><br><span class="line">os.path.isabs(<span class="string">'./'</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line">os.path.isabs(<span class="string">'./new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径返回true</span></span><br><span class="line">os.path.isabs(<span class="string">'c:\\FastFolder\\learn_test\\'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line">os.path.isabs(<span class="string">'c:\\FastFolder\\learn_test\\new_name.txt'</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为存在的文件-os-path-isfile"><a href="#判断是否为存在的文件-os-path-isfile" class="headerlink" title="判断是否为存在的文件-os.path.isfile()"></a>判断是否为存在的文件-os.path.isfile()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在的文件返回true</span></span><br><span class="line">os.path.isfile(<span class="string">"./new_name.txt"</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不存在的文件返回false</span></span><br><span class="line">os.path.isfile(<span class="string">"./new_namdsfae.txt"</span>)</span><br><span class="line">  <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h3 id="判断是否为存在的目录-os-path-isdir"><a href="#判断是否为存在的目录-os-path-isdir" class="headerlink" title="判断是否为存在的目录-os.path.isdir()"></a>判断是否为存在的目录-os.path.isdir()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.path.isdir(<span class="string">"c:\\FastFolder\\learn_test"</span>)</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path.isfile()和os.path.isdir()感觉可以使用os.path.exists()替换</span></span><br><span class="line"><span class="comment"># 特殊情况，比如通过判断是文件和目录来进行选择性的删除所有的文件，保留目录</span></span><br></pre></td></tr></table></figure><hr><h3 id="连接目录与文件名或目录-os-path-join"><a href="#连接目录与文件名或目录-os-path-join" class="headerlink" title="连接目录与文件名或目录-os.path.join()"></a>连接目录与文件名或目录-os.path.join()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将若干个目录或文件连接起来</span></span><br><span class="line"><span class="comment"># 不管目录或文件存不存在</span></span><br><span class="line">os.path.join(<span class="string">'c:\\FastFolder\\learn_test'</span>,<span class="string">'test'</span>,<span class="string">'test2'</span>)</span><br><span class="line">  <span class="string">'c:\\FastFolder\\learn_test\\test\\test2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果根目录在第二个或者更后面，之前的路径将会忽略掉</span></span><br><span class="line">os.path.join(<span class="string">'/root'</span>, <span class="string">'/usr/local'</span>, <span class="string">'test.sh'</span>)</span><br><span class="line">  <span class="comment"># 因为第二个参数'/usr/local'是从根目录开始，第一个/root会被忽略</span></span><br><span class="line">  <span class="string">'/usr/local/test.sh'</span></span><br><span class="line"><span class="comment"># 作为对比</span></span><br><span class="line">os.path.join(<span class="string">'/root'</span>, <span class="string">'usr/local'</span>, <span class="string">'test.sh'</span>)</span><br><span class="line">  <span class="comment">#作为对比，第二个参数'usr/local'没有从根目录开始</span></span><br><span class="line">  <span class="comment"># 最后的结果中会包含第一个参数的内容，不管第一个参数是不是从根目录开始</span></span><br><span class="line"> <span class="string">'/root/usr/local/test.sh'</span></span><br></pre></td></tr></table></figure><hr><h3 id="遍历整个文件结构-os-walk"><a href="#遍历整个文件结构-os-walk" class="headerlink" title="遍历整个文件结构-os.walk()"></a>遍历整个文件结构-os.walk()</h3><p>walk方法是os模块中非常重要和强大的一个方法(<code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code>)。可以帮助我们非常便捷地以<strong>递归方式**</strong>自顶向下<strong>或者</strong>自底向上的方式遍历目录树<strong>，对</strong>每一个目录都返回一个三元元组<code>(dirpath, dirnames, filenames)</code>**:</p><ul><li><code>dirpath</code>：遍历所在目录树的位置，是一个<strong>字符串对象</strong></li><li><code>dirnames</code>：目录树中的<strong>子目录</strong>组成的<strong>列表</strong>，不包括(“.”和”..”)</li><li><code>filenames</code>：目录树中的<strong>文件</strong>组成的<strong>列表</strong></li></ul><p>如果可选参数t<code>opdown = True</code>或者<strong>没有指定</strong>，则采用<strong>自顶向下</strong>的方式进行目录遍历，也就是<strong>从父目录向子目录逐步深入遍历</strong>，如果<code>topdown = False</code>，则采用<strong>自底向上</strong>的方式遍历目录，也就是<strong>先打印子目录再打印父目录</strong>的方式。</p><p>如果可选参数<code>onerror</code>被指定，则<code>onerror</code>必须是一个<strong>函数</strong>，该函数有一个OSError实例的参数，这样可以允许在运行的时候即使出现错误的时候不会打断os.walk()的执行，或者抛出一个异常并终止os.walk()的运行。通俗的讲，<strong>就是定义这个参数用于指定当发生了错误时的处理方法</strong>。</p><p><strong>默认情况下</strong>，<code>os.walk()</code>遍历的时候<strong>不会进入符号链接</strong>，如果设置了可选参数<code>followlinks = True</code>，<strong>则会进入符号链接</strong>。注意，这<strong>可能会出现遍历死循环</strong>，因为符号链接可能会出现自己链接自己的情况，而os.walk()没有那么高的智商，无法发现这一点。</p><p><strong>只遍历输出根目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">r"./"</span>):</span><br><span class="line">        print(root)</span><br><span class="line">        <span class="comment"># for directory in dirs:</span></span><br><span class="line">        <span class="comment">#     print( directory)</span></span><br><span class="line">        <span class="comment"># for file in files:</span></span><br><span class="line">        <span class="comment">#     print(file)</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在遍历过程中，所有的目录都可能成为根目录</span></span><br><span class="line">./</span><br><span class="line">./old_name</span><br><span class="line">./python_test</span><br><span class="line">./python_test\main</span><br><span class="line">./python_test\main\__pycache__</span><br><span class="line">./python_test\__pycache__</span><br></pre></td></tr></table></figure><p></p><p><strong>遍历输出根目录及其下面的目录</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">os.chdir(<span class="string">r"c:\FastFolder\learn_test"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">r"./"</span>):</span><br><span class="line">        print(root)</span><br><span class="line">        <span class="keyword">for</span> directory <span class="keyword">in</span> dirs:</span><br><span class="line">            print( directory)</span><br><span class="line">        <span class="comment"># for file in files:</span></span><br><span class="line">        <span class="comment">#     print(file)</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">old_name</span><br><span class="line">python_test</span><br><span class="line">./old_name</span><br><span class="line">./python_test</span><br><span class="line">main</span><br><span class="line">__pycache__</span><br><span class="line">./python_test\main</span><br><span class="line">__pycache__</span><br><span class="line">./python_test\main\__pycache__</span><br><span class="line">./python_test\__pycache__</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="总结以及注意事项"><a href="#总结以及注意事项" class="headerlink" title="总结以及注意事项"></a>总结以及注意事项</h3><div class="note info"><ul><li>除了<code>os.listdir()和os.scandir()</code>可以<strong>不指定path表示当前目录</strong>之外，<strong>基本所有的都必须要指定path</strong>，即使是当前目录，也要用类似<code>&#39;.&#39;</code>的方法指定，<strong>如果不指定会报错</strong>，所以<strong>保险起见，还是都指定path吧，以免出错</strong>。<br><br></li><li>使用windows的文件路径时一定要小心，比如你要引用d盘下的1.txt文件，那么路径要以字符串的形式写成<code>&#39;d:\\1.txt&#39;</code>或者<code>r&#39;d:\1.txt‘</code>。前面的方式是使用windwos的<strong>双斜杠</strong>作为路径分隔符，后者是使用<strong>原生字符串</strong>的形式，以r开始的字符串都被认为是原始字符串，表示字符串里所有的特殊符号都以本色出演，<strong>不进行转义</strong>，此时可以使用普通windows下的路径表示方式。<strong>这两种方法使用哪种都可以，但不可混用</strong>。<br><br></li><li><code>os.path.exists()</code>可以<strong>判断文件或者目录是否存在</strong>，而具体的<code>os.path.isfile()</code>和<code>os.path.isdir()</code>可以<strong>分别判断文件和目录是否存在</strong>，从而进行单独的操作，如删除所有目录中的文件，保留目录。<br><br></li><li><code>os.rmdir()</code>、<code>os.removedirs()</code>都<mark>只能删除空的目录</mark>，而<code>os.remove()</code>只能<strong>删除单个的文件</strong>，所以如果<mark>需要删除一个带文件的目录需要结合os.listdir() os.remove() os.rmdir()等，比较麻烦</mark>。<br><br></li><li>Python删除目录os.removedirs()的过程：If the <strong>leaf directory is succesfully removed</strong>, removedirs <strong>tries to successively remove every parent directory displayed in path</strong>.</li></ul></div><hr><p><br></p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p>系统相关的一系列命令在实际使用中用的比较少，所以这里只是列出，便于在后面使用时查询，并不进行深入的学习，后续需要时再学习。<br>os模块提供了一些操作系统相关的变量，可以在跨平台的时候提供支持，<strong>便于编写移植性高，可用性好的代码</strong>。所以在<strong>涉及操作系统相关的操作</strong>时，请<strong>尽量使用本模块提供的方法</strong>，而<strong>不要使用当前平台特定的用法或格式</strong>，否则一旦移植到其他平台，可能会造成难以解决的困扰。</p><table><thead><tr><th width="20%">方法和变量</th><th width="80%">用途</th></tr></thead><tbody><tr><td><code>os.name</code></td><td>查看当前操作系统的名称。windows平台下返回‘nt’，Linux则返回‘posix’。</td></tr><tr><td><code>os.environ</code></td><td>获取系统环境变量</td></tr><tr><td><code>os.sep</code></td><td>当前平台的路径分隔符。在windows下，为‘\’，在POSIX系统中，为‘/’。</td></tr><tr><td><code>os.altsep</code></td><td>可替代的路径分隔符，在Windows中为‘/’。</td></tr><tr><td><code>os.extsep</code></td><td>文件名和文件扩展名之间分隔的符号，在Windows下为‘.’。</td></tr><tr><td><code>os.pathsep</code></td><td>PATH环境变量中的分隔符，在POSIX系统中为‘:’，在Windows中为‘;’。</td></tr><tr><td><code>os.linesep</code></td><td>行结束符。在不同的系统中行尾的结束符是不同的，例如在Windows下为‘\r\n’。</td></tr><tr><td><code>os.devnull</code></td><td>在不同的系统上null设备的路径，在Windows下为‘nul’，在POSIX下为‘/dev/null’。</td></tr><tr><td><code>os.defpath</code></td><td>当使用exec函数族的时候，如果没有指定PATH环境变量，则默认会查找os.defpath中的值作为子进程PATH的值。</td></tr></tbody></table><h3 id="环境变量-os-environ"><a href="#环境变量-os-environ" class="headerlink" title="环境变量-os.environ()"></a>环境变量-os.environ()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到目前的环境变量</span></span><br><span class="line"><span class="comment"># 返回类似字典的具有映射关系的对象</span></span><br><span class="line">print(os.environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查HOME是不是在环境变量中</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'HOME'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    print(<span class="string">'HOME environment variable is already defined. Value ='</span>, os.environ[<span class="string">'HOME'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'HOME environment variable is not defined.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，和操作字典类似</span></span><br><span class="line"><span class="comment"># 注意环境变量的值必须要是字符串，不能为数字或其他</span></span><br><span class="line">os.environ[<span class="string">'MYSQL_VERSION'</span>] = <span class="string">'5.7.18'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取环境变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用常规的这种字典操作的方式</span></span><br><span class="line"><span class="comment"># 这种方式存在的问题是如果环境变量中不存在这个MYSQL_VERSION，则会报错，显示KeyError</span></span><br><span class="line">os.environ[<span class="string">'MYSQL_VERSION'</span>]</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"C:\Users\14910\Anaconda3\lib\os.py"</span>, line <span class="number">678</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">      <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="keyword">None</span></span><br><span class="line">  KeyError: <span class="string">'MYSQL_VERSION'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用另一种方式get()</span></span><br><span class="line"><span class="keyword">print</span> (os.environ.get(<span class="string">'DATA'</span>))</span><br><span class="line">  <span class="comment"># 环境变量不存在，返回None </span></span><br><span class="line">  <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 还可以设置环境变量不存在时候的默认值</span></span><br><span class="line">print(os.environ.get(<span class="string">'DATA'</span>, <span class="string">'TXT'</span>))</span><br><span class="line"> <span class="comment"># 环境变量不存在，返回默认值</span></span><br><span class="line">  TXT</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="执行命令和管理进程"><a href="#执行命令和管理进程" class="headerlink" title="执行命令和管理进程"></a>执行命令和管理进程</h2><p>在早期的Python版本中，通常使用<code>os</code>模块的<code>system</code>或者<code>popen</code>等方法执行操作系统的命令。但是，最近Python官方逐渐弃用了这些命令，而是改用内置的<code>subprocess</code>模块执行操作系统相关命令。鉴于上述原因，这里就不对这个方面进行更深入的学习，以后详细学习<code>subprocess</code>模块。</p><p><strong>该部分主要包括两个命令</strong>：</p><ul><li><code>os.system(command)</code>：运行操作系统命令，<strong>直接显示结果</strong>；但<strong>返回值是0或-1</strong>，<strong>不能获得显示在屏幕上的数据</strong>；command是要执行的命令字符串；除非显式在后台运行该命令，否则 <code>system()</code> 的调用将阻塞，直到它完成.</li><li><code>os.popen(command, [mode, [bufsize]])</code>：该方法<strong>返回一个文件对象，可以对这个文件对象进行读或写</strong>，取决于<strong>参数mode</strong>，如果mode指定了只读，那么只能对文件对象进行读，如果mode参数指定了只写，那么只能对文件对象进行写操作。简而言之，<strong><code>popen</code>也可以运行操作系统命令</strong>，并<strong>通过<code>read()</code>方法将命令的结果返回</strong>，<strong>不像system只能看不能存，这个能存</strong>！</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.liujiangblog.com/course/python/53" target="_blank" rel="noopener">很详细的教程</a></li><li><a href="https://learnku.com/docs/pymotw/os-portable-access-to-operating-system-specific-features/3481" target="_blank" rel="noopener">使用实例教程</a></li><li><a href="https://www.cnblogs.com/yyds/p/6427349.html" target="_blank" rel="noopener">Python之文件与目录操作（os、zipfile、tarfile、shutil）</a></li><li><a href="https://docs.python.org/3/library/os.html#module-os" target="_blank" rel="noopener">os — Miscellaneous operating system interfaces</a></li><li><a href="https://www.cnblogs.com/maseng/p/3386140.html" target="_blank" rel="noopener">python os.stat() 和 stat模块详解</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中常用的解压缩命令</title>
      <link href="/posts/29022.html"/>
      <url>/posts/29022.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习和总结了Linux中常用的解压缩命令，主要针对<code>tar.gz</code>、<code>tar.bz2</code>、<code>gz</code>、<code>bz2</code>和<code>zip</code>文件格式进行解压，分别学习了<code>tar命令(打包命令)</code>、<code>gzip命令</code>、<code>bzip2命令</code>以及<code>zip命令</code>和<code>对应的解压命令</code>来完成对上述文件格式的解压。</p></div><a id="more"></a><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p><strong><code>tar</code>命令是打包命令而不是解压命令</strong>，所谓的打包是指可以把<strong>一大堆的文件和目录</strong>全部打包<strong>成一个文件</strong>，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。我们在<strong>平常使用时都是使用<code>tar</code>结合相应参数对文件进行解压，但实际上其并不是解压缩命令，其实现解压需要结合特定的参数</strong>。</p><p><strong>这里我们很有必要了解一下打包和解压的区别</strong>：</p><ul><li><strong>打包</strong>是指将<strong>一大堆文件或目录</strong>变成一个<strong>总的文件</strong></li><li><strong>压缩</strong>则是将<strong>一个大的文件</strong>通过一些压缩算法变成一个<strong>小文件</strong></li></ul><p>我们平常解压时面对的文件名大多是<code>tar.gz</code>格式文件，其产生过程和原因是：Linux中<strong>很多压缩程序只能针对一个文件进行压缩</strong>，这样当你想要<strong>压缩一大堆文件时</strong>，你得先<strong>将这一大堆文件先打成一个包</strong>（<code>tar命令</code>），然后<strong>再用压缩程序进行压缩</strong>（<code>gzip、bzip2命令</code>）。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在学习如何解压<code>tar.gz</code>格式文件之前，先学习使用tar命令进行打包并进行压缩，知道来源再去学习针对性的解压命令.</p><p><strong>命令格式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 输入文件可以有多个，将其统一打包成输出文件</span></span><br><span class="line">  tar option out_file in_file in_file_2</span><br></pre></td></tr></table></figure><p></p><p><strong>相关参数说明</strong>：</p><ul><li><code>-c</code>：建立新的打包文件</li><li><code>-v</code>：显示指令执行过程</li><li><code>-r</code>：向已经打包的文件中<strong>追加**</strong>文件<strong>(</strong>不能向已经压缩的<code>bz2</code>、<code>gz</code>文件中添加<strong>，</strong>需要和<code>-f</code>参数一同使用**)</li><li><code>-u</code>：<strong>更新</strong>已经打包的文件中的<strong>文件</strong>(<strong>不能向已经压缩的<code>bz2</code>、<code>gz</code>文件中添加</strong>，<strong>需要和<code>-f</code>参数一同使用</strong>)</li><li><code>-A</code>：将<strong>tar文件中的文件**</strong>追加到已经打包的文件(tar文件)中**，相当于是文件的追加，而不是将整个tar文件追加进去</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li></ul><p><strong>打包实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅打包，不压缩</span></span><br><span class="line">tar -cvf Homo_sapiens.GRCh38.95.chr.gff3.tar Homo_sapiens.GRCh38.95.chr.gff3 test.txt </span><br><span class="line">  <span class="comment"># 生成tar格式文件，tar格式文件比原始文件大</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中添加test2.txt文件</span></span><br><span class="line">tar -rvf Homo_sapiens.GRCh38.95.chr.gff3.tar test2.txt</span><br><span class="line">  <span class="comment"># 生成的还是原来的tar文件，只是其中多了test2.txt</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中更新test2.txt文件</span></span><br><span class="line">tar -uvf Homo_sapiens.GRCh38.95.chr.gff3.tar test2.txt</span><br><span class="line">  <span class="comment"># tar文件中的test2.txt已经更新了</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上述打包的文件中添加tar打包文件</span></span><br><span class="line">tar -Avf Homo_sapiens.GRCh38.95.chr.gff3.tar Homo_sapiens.GRCh38.95.chr.gff3_2.tar</span><br><span class="line">  <span class="comment"># 生成的还是原来的tar文件，只是将tar中的文件追加到前面的tar文件中</span></span><br><span class="line">  <span class="comment"># 不是将整个tar文件追加进去，如果使用-r选项就是将整个tar文件追加进去</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包后，以 gzip 压缩 </span></span><br><span class="line">tar -zcvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz Homo_sapiens.GRCh38.95.chr.gff3 test.txt</span><br><span class="line">  <span class="comment"># 生成tar.gz格式文件</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包后，以 bzip2 压缩(这个花费时间较长) </span></span><br><span class="line">tar -jcvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2  Homo_sapiens.GRCh38.95.chr.gff3 test.txt</span><br><span class="line">  <span class="comment"># 生成tar.bz2格式文件</span></span><br><span class="line">  <span class="comment"># 原始文件依旧保留</span></span><br><span class="line">  Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>打包参数是<code>-cvf</code></li><li><code>bz2</code>格式的文件对应的参数就是<code>j</code>，<strong>打包所需时间长，压缩包的大小比较小，压缩比高</strong></li><li><code>gz</code>格式的文件对应的参数就是<code>z</code>，<strong>打包所需时间较短，压缩包的大小比较大，压缩比低</strong></li><li><strong>tar格式文件比原始文件大</strong></li></ul><p><strong>上述的文件格式和参数的对应关系很关键，在接下来的所有命令中，只要是针对这两种不同格式的包都需要加上对应的参数</strong>。</p></div><hr><h3 id="查看包的内容"><a href="#查看包的内容" class="headerlink" title="查看包的内容"></a>查看包的内容</h3><p><strong>相关参数说明</strong>：</p><ul><li><code>-t</code>：列出打包文件内容</li><li><code>-v</code>：显示指令执行过程</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li></ul><p><strong>查看包的内容实例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看打包文件</span></span><br><span class="line">tar -tvf Homo_sapiens.GRCh38.95.chr.gff3.tar</span><br><span class="line">  <span class="comment"># 输出包的内容 </span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tar.gz格式文件内容</span></span><br><span class="line">tar -ztvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line">  <span class="comment"># 输出tar.gz格式文件内容 </span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tar.bz2格式文件内容</span></span><br><span class="line">tar -jtvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br><span class="line">  <span class="comment"># 输出tar.bz2格式文件内容</span></span><br><span class="line">  -rw-rw-r-- user/user 430456714 2019-03-30 18:07 Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line">  -rw-rw-r-- user/user         0 2019-03-30 18:07 test.txt</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>查看包的基础参数是<code>-tvf</code></li><li><code>bz2</code>格式的文件对应的参数就是<code>j</code></li><li><code>gz</code>格式的文件对应的参数就是<code>z</code></li></ul></div><hr><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><strong>相关参数说明</strong>：</p><ul><li><code>-x</code>：提取(解压)打包文件内容</li><li><code>-v</code>：显示指令执行过程</li><li><code>-f</code>：指定打包文件，<strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li><li><code>-z</code>：通过<code>gzip指令</code>处理打包文件</li><li><code>-j</code>：通过<code>bzip2指令</code>处理打包文件</li><li><code>-C</code>：<strong>指定解压文件的输出目录</strong></li></ul><h4 id="解压整个文件"><a href="#解压整个文件" class="headerlink" title="解压整个文件"></a>解压整个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取tar格式文件内容</span></span><br><span class="line">tar -xvf Homo_sapiens.GRCh38.95.chr.gff3.tar</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.gz格式文件内容</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar.gz格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.bz2格式文件内容</span></span><br><span class="line">tar -jxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2</span><br><span class="line">  <span class="comment"># 输出在当前文件夹下，tar.bz2格式文件依旧保留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定解压的输出文件夹</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz -C <span class="built_in">test</span></span><br><span class="line">  <span class="comment"># 解压的文件输出在test目录中</span></span><br><span class="line">  <span class="comment"># test目录必须存在，不然会报错</span></span><br></pre></td></tr></table></figure><hr><h4 id="解压部分文件"><a href="#解压部分文件" class="headerlink" title="解压部分文件"></a>解压部分文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取tar.gz格式文件中的test.txt文件</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取tar.bz2格式文件中的test.txt文件</span></span><br><span class="line">tar -jxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.bz2 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定解压的输出文件夹</span></span><br><span class="line">tar -zxvf Homo_sapiens.GRCh38.95.chr.gff3.tar.gz test.txt -C <span class="built_in">test</span></span><br><span class="line">  <span class="comment"># 解压的文件输出在test目录中</span></span><br><span class="line">  <span class="comment"># test目录必须存在，不然会报错</span></span><br></pre></td></tr></table></figure><div class="note info"><ul><li><strong>tar可解压压缩文件的部分内容</strong>，所以可以先通过<code>-t</code>来<strong>查看</strong>压缩包内容，然后<strong>选取自己需要</strong>的进行<strong>解压</strong>，或者直接解压整个包。</li><li><strong>可以使用<code>-C</code>参数指定解压文件的输出目录</strong></li></ul></div><hr><h2 id="gz文件"><a href="#gz文件" class="headerlink" title="gz文件"></a>gz文件</h2><p>这个没啥可以说的，就是使用gzip命令压缩得到的文件(<strong>默认情况下压缩后会使原文件消失</strong>)，对于这个命令的解压可以使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看压缩文件信息</span></span><br><span class="line"><span class="comment"># -l：list compressed file contents</span></span><br><span class="line">gzip -l Homo_sapiens.GRCh38.95.chr.gff3.gz </span><br><span class="line">  compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">    38793139           430456714  91.0% Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip -d解压</span></span><br><span class="line"><span class="comment"># -d：decompress</span></span><br><span class="line">gzip -d Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">  <span class="comment"># 解压缩后原始的gz格式文件将不会存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip解压</span></span><br><span class="line">gunzip Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">  <span class="comment"># 解压缩后原始的gz格式文件将不会存在</span></span><br></pre></td></tr></table></figure><p></p><p>如果想<strong>保留原始文件</strong>就需要使用<code>-c</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c：--stdout  write on standard output, keep original files unchanged</span></span><br><span class="line"><span class="comment"># -c：将文件输出到标准输出，并且保留原始gz格式文件不变</span></span><br><span class="line"><span class="comment"># 输出到标准输出，然后进行重定向到文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩过程如果想保留原始文件也可以使用-c参数</span></span><br><span class="line">gzip -c Homo_sapiens.GRCh38.95.chr.gff3 &gt;Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip进行解压缩并保留原始文件</span></span><br><span class="line">gunzip -c Homo_sapiens.GRCh38.95.chr.gff3.gz &gt;Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip -d解压并保留原始文件</span></span><br><span class="line">gzip -d -c Homo_sapiens.GRCh38.95.chr.gff3.gz &gt;Homo_sapiens.GRCh38.95.chr.gff3</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="bz2文件"><a href="#bz2文件" class="headerlink" title="bz2文件"></a>bz2文件</h2><p>bz2是由bzip2命令压缩得到的文件，<strong>默认情况下和<code>gzip</code>相同<code>bzip2</code>也不会保留解压缩前的原始文件</strong>，对这种格式的文件进行解压缩可以使用如下命令:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和gzip不同，bzip2命令没有能够列出压缩文件内容的选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip2 -d进行解压</span></span><br><span class="line"><span class="comment"># -d：--decompress  force decompression</span></span><br><span class="line">bzip2 -d Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br><span class="line">  <span class="comment"># 解压缩后原始的bz2格式文件将不会存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2解压</span></span><br><span class="line">bunzip2 Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br><span class="line">  <span class="comment"># 解压缩后原始的bz2格式文件将不会存在</span></span><br></pre></td></tr></table></figure><p></p><p>如果想<strong>保留原始文件</strong>就需要使用<code>-k</code>参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -k：--keep   keep (don't delete) input files</span></span><br><span class="line"><span class="comment"># -k：保留原始的输入文件</span></span><br><span class="line"><span class="comment"># 这里bzip2也有-c选项，但是也专门提供了-k选项来保留原始文件，所以就不需要进行-c然后重定向</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩时保留原始文件</span></span><br><span class="line">bzip2 -k Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2解压并保留原始文件</span></span><br><span class="line">bunzip2 -k Homo_sapiens.GRCh38.95.chr.gff3.bz2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip2 -d进行解压并保留原始文件</span></span><br><span class="line">bzip2 -d -k Homo_sapiens.GRCh38.95.chr.gff3.bz2</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="zip格式文件"><a href="#zip格式文件" class="headerlink" title="zip格式文件"></a>zip格式文件</h2><p>zip格式文件是通过zip命令压缩得到的文件，对其的解压使用unzip命令即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用zip命令进行压缩，与前面两个gzip和bzip2不同的是可以保留原始文件</span></span><br><span class="line"><span class="comment"># 需要自定义输出文件名</span></span><br><span class="line">zip Homo_sapiens.GRCh38.95.chr.gff3.zip Homo_sapiens.GRCh38.95.chr.gff3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新zip文件中的问价，使用-u参数</span></span><br><span class="line">zip -u Homo_sapiens.GRCh38.95.chr.gff3.zip test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件添加到zip文件中，使用-m参数</span></span><br><span class="line">zip -m Homo_sapiens.GRCh38.95.chr.gff3.zip  test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用unzip进行解压</span></span><br><span class="line"><span class="comment"># 解压也和前面的gzip和bzip2不同，能够保留原始文件</span></span><br><span class="line">unzip Homo_sapiens.GRCh38.95.chr.gff3.zip</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关于tar命令"><a href="#关于tar命令" class="headerlink" title="关于tar命令"></a>关于tar命令</h3><ul><li><strong>tar可解压压缩文件的部分内容</strong>，所以可以先通过<code>-t</code>来<strong>查看</strong>压缩包内容，然后<strong>选取自己需要</strong>的进行<strong>解压</strong>，或者直接解压整个包。</li><li><strong>可以使用<code>-C</code>参数指定解压文件的输出目录</strong></li><li><strong><code>-f</code>参数一定要在最后，紧接着文件的</strong></li></ul><hr><h3 id="关于压缩比"><a href="#关于压缩比" class="headerlink" title="关于压缩比"></a>关于压缩比</h3><p><strong><code>bzip2</code>的压缩比最高、其次是<code>gzip</code>、接着是<code>zip</code>、最后是打包<code>tar</code></strong>，可以看看这个示例：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/压缩比.png" alt="压缩比.png"></p><hr><h3 id="原始文件"><a href="#原始文件" class="headerlink" title="原始文件"></a>原始文件</h3><ul><li><strong><code>tar</code>和<code>zip</code>都会保留原始文件</strong></li><li><strong><code>bzip2</code>和<code>gzip</code>都不会保留原始文件</strong><ul><li><code>gzip</code>需要使用<code>-c</code>参数将结果<strong>输出到标准输出</strong>，然后<strong>重定向</strong>来保留文件(解压或者压缩)</li><li><code>bzip2</code>可以使用<code>-k</code>参数来<strong>直接保留</strong>原始文件(解压或者压缩)，也可以使用上面的<code>-c</code>参数</li></ul></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>tar</code>和<code>zip</code>进行压缩或者打包时都是先跟着输出文件(tar、zip格式文件)，再跟着输入的需要打包和压缩的文件，这个需要注意一下</li><li><code>bzip2</code>和<code>gzip</code>直接跟着需要压缩的文件即可<br><br></li><li><code>bzip2</code>和<code>gzip</code>只能针对文件，不能针对目录</li><li><code>tar</code>可以<strong>支持对目录和文件的打包</strong></li><li><code>zip</code>命令<strong>需要使用<code>-r</code>参数</strong>来支持对目录的压缩</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/tar" target="_blank" rel="noopener">tar命令</a></li><li><a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip命令</a></li><li><a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2命令</a></li><li><a href="http://man.linuxde.net/zip" target="_blank" rel="noopener">zip命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之打印彩色字符串</title>
      <link href="/posts/9708.html"/>
      <url>/posts/9708.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章是Linux中<a href="http://showteeth.tech/posts/39761.html">使用echo -e进行彩色输出</a>的后续，Python也可以进行输出样式更改，包括<strong>字体颜色</strong>、<strong>背景颜色</strong>、<strong>其他输出样式更改(字体闪烁、下划线和加粗等)</strong>。</p></div><a id="more"></a><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>昨天学习了<code>Linux</code>中使用<code>echo</code>命令来进行彩色字符串的输出，后来发现<code>Python</code>也可以进行彩色字符串的输出，但是<strong>需要注意的是只能在服务器上使用才可以，在<code>Python IDE</code>或者<code>cmd</code>中支持都不是很完善(<code>IDE</code>压根不能输出而<code>CMD</code>不会出现闪烁效果)</strong>，具体的展示效果如下：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python彩色输出.png" alt="python彩色输出.png"></p><hr><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>和<code>echo</code>命令中学习的相同，控制颜色输出的由两部分构成：<code>\033[xx;xxm</code>和<code>\033[0m</code>(<strong>ANSI控制码</strong>)：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印红色字体</span></span><br><span class="line"><span class="comment"># 31m表示红色</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"\033[31mTEST\033[0m"</span>)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li><code>\033[xxxm</code>：表示<strong>开始样式(字体、背景、闪烁等)渲染</strong>，<strong><code>m</code>前面可以跟着多种样式渲染的数字表示(不同类型以分号<code>;</code>分隔，不用再加<code>m</code>，否则会出错)</strong>，例如：<code>print (&quot;\033[42;37mTEST\033[0m&quot;)</code>可正确输出绿底白字，而<code>print (&quot;\033[42m;37mTEST\033[0m&quot;)</code>输出结果和正确的存在差异</li><li><code>\033[0m</code>表示<strong>样式(字体、背景、闪烁等)渲染结束</strong>，<strong>这个不管是在什么样式输出情况下都是固定的</strong></li></ul></div><hr><h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><p>和<code>echo</code>命令中学习的相同，只需要将<code>echo -e</code>替换为<code>print()</code>即可，<strong>具体颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">颜色</th><th width="60%">完整命令</th></tr><tr><td>30</td><td><strong>黑色</strong></td><td><code>print ("\033[30mTEST\033[0m")</code></td></tr><tr><td>31</td><td><strong>红色</strong></td><td><code>print ("\033[31mTEST\033[0m")</code></td></tr><tr><td>32</td><td><strong>绿色</strong></td><td><code>print ("\033[32mTEST\033[0m")</code></td></tr><tr><td>33</td><td><strong>黄色</strong></td><td><code>print ("\033[33mTEST\033[0m")</code></td></tr><tr><td>34</td><td><strong>蓝色</strong></td><td><code>print ("\033[34mTEST\033[0m")</code></td></tr><tr><td>35</td><td><strong>紫色</strong></td><td><code>print ("\033[35mTEST\033[0m")</code></td></tr><tr><td>36</td><td><strong>浅蓝色</strong></td><td><code>print ("\033[36mTEST\033[0m")</code></td></tr><tr><td>37</td><td><strong>白色</strong></td><td><code>print ("\033[37mTEST\033[0m")</code></td></tr></table><p><strong>输出效果展示</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python彩色输出.png" alt="python彩色输出.png"></p><hr><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><p><strong>具体背景颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">背景颜色</th><th width="60%">完整命令(字体颜色为红色)</th></tr><tr><td>40</td><td><strong>黑色</strong></td><td><code>print ("\033[40;31mTEST\033[0m")</code></td></tr><tr><td>41</td><td><strong>红色</strong></td><td><code>print ("\033[41;31mTEST\033[0m")</code></td></tr><tr><td>42</td><td><strong>绿色</strong></td><td><code>print ("\033[42;31mTEST\033[0m")</code></td></tr><tr><td>43</td><td><strong>黄色</strong></td><td><code>print ("\033[43;31mTEST\033[0m")</code></td></tr><tr><td>44</td><td><strong>蓝色</strong></td><td><code>print ("\033[44;31mTEST\033[0m")</code></td></tr><tr><td>45</td><td><strong>紫色</strong></td><td><code>print ("\033[45;31mTEST\033[0m")</code></td></tr><tr><td>46</td><td><strong>浅蓝色</strong></td><td><code>print ("\033[46;31mTEST\033[0m")</code></td></tr><tr><td>47</td><td><strong>白色</strong></td><td><code>print ("\033[47;31mTEST\033[0m")</code></td></tr></table><p><strong>输出效果展示</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python彩色背景输出.png" alt="python彩色背景输出.png"></p><hr><h2 id="ansi控制码总结"><a href="#ansi控制码总结" class="headerlink" title="ansi控制码总结"></a>ansi控制码总结</h2><p>ansi控制码中不仅有控制颜色的控制码，还有一些提供其他功能的控制码，如闪烁、加粗、下划线等，我们来总结一下：</p><table><tr><th width="20%">ANSI控制码</th><th width="40%">说明</th><th width="40%">完整命令示例</th></tr><tr><td><code>\033[0m</code></td><td>关闭所有属性，也就是说此控制码前面的控制码将会失效。</td><td><code>print ("\033[31;0;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[1m</code></td><td><strong>设置高亮度(加粗)</strong></td><td><code>print ("\033[1;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[4m</code></td><td><strong>下划线</strong></td><td><code>print ("\033[4;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[5m</code></td><td><strong>闪烁</strong></td><td><code>print ("\033[5;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[7m</code></td><td>反显，撞色显示，显示为白底黑字，或者显示为黑底白字，也可以和字体、背景颜色搭配</td><td><code>print ("\033[7mTEST\033[0m")</code></td></tr><tr><td><code>\033[8m</code></td><td>消隐，字符颜色将会与背景颜色相同，<strong>忽略设置的字体颜色</strong></td><td><code>print ("\033[8;31;42mTEST\033[0m")</code></td></tr><tr><td><code>\033[30m--\33[37m</code></td><td>设置字符颜色</td><td><code>print ("\033[31mTEST\033[0m")</code></td></tr><tr><td><code>\033[40m--\33[47m</code></td><td>设置背景色</td><td><code>print ("\033[41mTEST\033[0m")</code></td></tr></table><p><strong>实际效果</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python-ansi控制码总结.png" alt="python-ansi控制码总结.png"></p><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echo-字符串的输出</title>
      <link href="/posts/39761.html"/>
      <url>/posts/39761.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Linux中<strong>非常常用的输出字符串命令<code>echo</code></strong>，包括使用<strong>参数<code>-n</code>来不换行输出</strong>、使用<strong>参数<code>-e</code>来支持各种转义字符</strong>、<strong>字符串不加或加单或加双引号的区别和使用范围</strong>以及最后还学习了<strong>非常强大的使用<code>-e</code>参数来进行输出样式更改(字体颜色、背景颜色、字体闪烁、下划线和加粗等)</strong>。</p></div><a id="more"></a><p>命令 echo 是用来将字符串写到标准输出，在平时工作中非常常用，这里对其进行详细的学习。</p><h2 id="echo命令格式"><a href="#echo命令格式" class="headerlink" title="echo命令格式"></a>echo命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="built_in">echo</span> [选项] [输出内容]</span><br><span class="line"><span class="comment"># echo默认会在最后一个字符后面添加换行符</span></span><br></pre></td></tr></table></figure><div class="note info"><p>注意<strong>单引号、双引号</strong>在<strong>变量替换</strong>、<strong>字符拓展</strong>以及<strong>转义符解析</strong>等方面的区别，同样适用于<code>echo</code>命令：</p><ul><li><strong>双引号允许变量和命令替换，以及转义符的解析</strong>，保护特殊元字符和通配符不被shell解析</li><li><strong>单引号不允许任何变量、元字符、通配符、转义符的解析</strong></li></ul><p><strong>字符串加不加引号的问题</strong>:</p><ul><li>不加引号：<strong>变量替换和命令替换可以正常进行</strong>，但是<strong>转义字符解析就不可以了</strong>，<strong>默认会将转义字符直接去掉(可以用来保留原始字符，去除其后紧跟的元字符或通配符的特殊意义)</strong>，例如<code>echo -e hello\nworld</code>输出结果为<code>hellonworld</code>，直接把转义字符<code>\</code>去掉了，但是<code>n</code>还是保留了下来(这种可以适用于输出原本字符，比如<code>echo \&quot;hello\&quot;</code>就可以保留双引号输出<code>&quot;hello&quot;</code>)</li></ul><p><strong>根据上面的分析建议</strong>：</p><ul><li><strong>尽量使用双引号将字符包围起来</strong>(一般情况下肯定也不会希望字符不允许任何解析)</li><li>平常使用，如<strong>变量替换、命令替换这种简单的可以使用不加引号的方法，简单，同时也可支持简单的转义(保留原始字符，去除其后紧跟的元字符或通配符的特殊意义)</strong>，比如<code>echo \&quot;hello\&quot;</code>就可以保留双引号输出<code>&quot;hello&quot;</code>，<strong>实例可见下面字体颜色中的代码</strong>。</li></ul></div><hr><h2 id="echo支持的选项"><a href="#echo支持的选项" class="headerlink" title="echo支持的选项"></a>echo支持的选项</h2><ul><li><code>-e</code>：<strong>输出转义字符</strong>（具体参见下表）</li><li><code>-n</code>：取消输出后行末的换行符号（<strong>内容输出后不换行</strong>）</li></ul><hr><h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><p>注意<a href="http://showteeth.tech/posts/55603.html">单引号、双引号特殊字符</a>的作用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line"><span class="comment"># 单引号防止任何变量替换、通配符拓展、转移符解析等</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$x'</span></span><br><span class="line">  <span class="variable">$x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号允许变量和命令替换，以及转义符的解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$x</span>"</span></span><br><span class="line">  10</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>在实际使用过程中经常需要进行命令替换也就是打印出命令执行的结果，但是<strong>需要注意打印出来的格式和真实格式是否一致</strong>：<br><strong>不使用引号，格式发生改变</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `cmp --<span class="built_in">help</span>`</span><br><span class="line">  Usage: cmp [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]] Compare two files byte by byte. -b --<span class="built_in">print</span>-bytes Print differing bytes. -i SKIP --ignore-initial=SKIP Skip the first SKIP bytes of input. -i SKIP1:SKIP2 --ignore-initial=SKIP1:SKIP2 Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2. -l --verbose Output byte numbers and values of all differing bytes. -n LIMIT --bytes=LIMIT Compare at most LIMIT bytes. -s --quiet --silent Output nothing; yield <span class="built_in">exit</span> status only. -v --version Output version info. --<span class="built_in">help</span> Output this <span class="built_in">help</span>. SKIP1 and SKIP2 are the number of bytes to skip <span class="keyword">in</span> each file. SKIP values may be followed by the following multiplicative suffixes: kB 1000, K 1024, MB 1,000,000, M 1,048,576, GB 1,000,000,000, G 1,073,741,824, and so on <span class="keyword">for</span> T, P, E, Z, Y. If a FILE is `-<span class="string">' or missing, read standard input. Report bugs to &lt;bug-gnu-utils@gnu.org&gt;.</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用引号，格式没有发生改变</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"`cmp --help`"</span></span><br><span class="line">  Usage: cmp [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]</span><br><span class="line">  Compare two files byte by byte.</span><br><span class="line"></span><br><span class="line">    -b  --<span class="built_in">print</span>-bytes  Print differing bytes.</span><br><span class="line">    -i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input.</span><br><span class="line">    -i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2</span><br><span class="line">      Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2.</span><br><span class="line">    -l  --verbose  Output byte numbers and values of all differing bytes.</span><br><span class="line">    -n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes.</span><br><span class="line">    -s  --quiet  --silent  Output nothing; yield <span class="built_in">exit</span> status only.</span><br><span class="line">    -v  --version  Output version info.</span><br><span class="line">    --<span class="built_in">help</span>  Output this <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">  SKIP1 and SKIP2 are the number of bytes to skip <span class="keyword">in</span> each file.</span><br><span class="line">  SKIP values may be followed by the following multiplicative suffixes:</span><br><span class="line">  kB 1000, K 1024, MB 1,000,000, M 1,048,576,</span><br><span class="line">  GB 1,000,000,000, G 1,073,741,824, and so on <span class="keyword">for</span> T, P, E, Z, Y.</span><br><span class="line"></span><br><span class="line">  If a FILE is `-<span class="string">' or missing, read standard input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Report bugs to &lt;bug-gnu-utils@gnu.org&gt;.</span></span><br></pre></td></tr></table></figure><p></p><hr><hr><h2 id="n-不换行输出"><a href="#n-不换行输出" class="headerlink" title="-n-不换行输出"></a>-n-不换行输出</h2><p>取消最后行末尾末尾的换行符(每行末尾会自动添加换行符)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常输出，默认在"hello world"后面有换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line">  hello world</span><br><span class="line">  [user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span></span><br><span class="line">  hello world[user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span> ;<span class="built_in">echo</span> <span class="string">"hello c"</span></span><br><span class="line">  hello world</span><br><span class="line">  hello c</span><br><span class="line">  [user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第一个-n</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span> ;<span class="built_in">echo</span> <span class="string">"hello c"</span></span><br><span class="line">  hello worldhello c</span><br><span class="line">  [user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个-n</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span> ;<span class="built_in">echo</span> -n <span class="string">"hello c"</span></span><br><span class="line">  hello worldhello c[user@C-login04 <span class="built_in">echo</span>]$</span><br></pre></td></tr></table></figure><p></p><p>可以<strong>与read命令相结合</strong>使用，具体的示例查看<a href="http://showteeth.tech/posts/59492.html">read命令</a></p><hr><h2 id="e-输出转义字符"><a href="#e-输出转义字符" class="headerlink" title="-e-输出转义字符"></a>-e-输出转义字符</h2><p>命令 <code>echo</code> 加上<code>-e</code>参数能够输出如下转义字符:</p><table><tr><th width="10%">字符转换</th><th width="90%">说明</th></tr><tr><td><code>\字符</code></td><td><strong>输出<code>字符</code>本身<strong></strong></strong></td></tr><tr><td><code>\a</code></td><td>输出警告音(输出时叮咚一声)</td></tr><tr><td><code>\b</code></td><td><strong>退格键，也就是向左删除一个字符<strong></strong></strong></td></tr><tr><td><code>\c</code></td><td>所有跟在<code>\c</code>序列后的字符都被忽略，同时取消输出行末的换行符</td></tr><tr><td><code>\f</code></td><td>换行，但是换行后的新行的开头位置连接着上一行的行尾</td></tr><tr><td><code>\n</code></td><td><strong>换行符<strong></strong></strong></td></tr><tr><td><code>\r</code></td><td>使用<code>\r</code>后面的字符覆盖<code>\r</code>之前的同等长度的字符</td></tr><tr><td><code>\t</code></td><td><strong>制表符，也就是Tab键<strong></strong></strong></td></tr><tr><td><code>\v</code></td><td>垂直制表符(和<code>-f</code>相同)</td></tr><tr><td><code>\0nnn</code></td><td>按照<strong>八进制<strong> ASCII 码表输出字符，其中 0 为数字 0，nnn 是三位八进制数</strong></strong></td></tr><tr><td><code>\xhh</code></td><td>按照<strong>十六进制<strong> ASCH 码表输出字符，其中 hh 是两位十六进制数</strong></strong></td></tr></table><h3 id="字符-输出字符"><a href="#字符-输出字符" class="headerlink" title="\字符-输出字符"></a>\字符-输出字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出\本身</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\\world"</span></span><br><span class="line">  hello\world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出双引号</span></span><br><span class="line"> <span class="built_in">echo</span> -e <span class="string">"\"helloworld\""</span></span><br><span class="line">  <span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然这里不加-e选项也能正确输出</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"\\helloworld\""</span></span><br><span class="line">  \helloworld<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 不加双引号也能正确输出</span></span><br><span class="line"><span class="string">echo  \\helloworld\"</span></span><br><span class="line"><span class="string">  \helloworld"</span></span><br></pre></td></tr></table></figure><hr><h3 id="b-退格键"><a href="#b-退格键" class="headerlink" title="\b-退格键"></a>\b-退格键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有当\b后面存在字符的时候才会删除前一个字符，否则不会删除</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\b"</span></span><br><span class="line">  hello </span><br><span class="line"></span><br><span class="line"><span class="comment"># 向左删除一个</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\bworld"</span></span><br><span class="line">  <span class="comment"># 删除了字母o</span></span><br><span class="line">  hellworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># \b可以叠加使用，向前删除多个</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\b\bworld"</span></span><br><span class="line">  <span class="comment"># 删除了字母o和l</span></span><br><span class="line">  helworld</span><br></pre></td></tr></table></figure><hr><h3 id="c-去掉后续字符和换行符"><a href="#c-去掉后续字符和换行符" class="headerlink" title="\c-去掉后续字符和换行符"></a>\c-去掉后续字符和换行符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去掉\c后续的字符和换行符</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\cworld"</span></span><br><span class="line">  hello[user@C-login04 <span class="built_in">echo</span>]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当\c后面不存在字符时，相当于echo -n</span></span><br></pre></td></tr></table></figure><hr><h3 id="f和-v-换行并缩进"><a href="#f和-v-换行并缩进" class="headerlink" title="\f和\v-换行并缩进"></a>\f和\v-换行并缩进</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \f换行缩进</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\fworld"</span></span><br><span class="line">  hello</span><br><span class="line">       world</span><br><span class="line"></span><br><span class="line"><span class="comment"># \v换行缩进</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\vworld"</span></span><br><span class="line">  hello</span><br><span class="line">       world</span><br></pre></td></tr></table></figure><hr><h3 id="n-换行符"><a href="#n-换行符" class="headerlink" title="\n-换行符"></a>\n-换行符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换行</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\nworld"</span></span><br><span class="line">  hello</span><br><span class="line">  world</span><br></pre></td></tr></table></figure><hr><h3 id="t-制表符"><a href="#t-制表符" class="headerlink" title="\t-制表符"></a>\t-制表符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 制表符</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\tworld"</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><hr><h3 id="r-等长覆盖"><a href="#r-等长覆盖" class="headerlink" title="\r-等长覆盖"></a>\r-等长覆盖</h3><p>使用<code>\r</code>后面的字符覆盖<code>\r</code>之前的同等长度的字符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等长覆盖，前后长度相同</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\rworld"</span></span><br><span class="line">  world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等长覆盖，前面长于后面字符</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hellooo\rworld"</span></span><br><span class="line">  worldoo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等长覆盖，前面短于后面字符()</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"heo\rworld"</span></span><br><span class="line">  world</span><br><span class="line"></span><br><span class="line"><span class="comment"># \r后没字符，不被覆盖</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"hello\r"</span></span><br><span class="line">  hello</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="e-彩色输出"><a href="#e-彩色输出" class="headerlink" title="-e-彩色输出"></a>-e-彩色输出</h2><p>使用echo命令的<code>-e</code>选项，除了<strong>能够输出转义字符</strong>，还能够在命令行中<strong>输出彩色的字符</strong>，或者<strong>带有彩色背景的字符</strong>，先来一个示例感受一下:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印红色字体</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果见下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo彩色打印.png" alt="echo彩色打印.png"></p><p>不仅可以显示红色，还可以设置背景、闪烁灯效果，是不是觉得很炫酷，接下来就对这个用法进行学习。</p><h3 id="颜色输出命令格式"><a href="#颜色输出命令格式" class="headerlink" title="颜色输出命令格式"></a>颜色输出命令格式</h3><p>如果排除上述命令中的需要红色标注的字串TEST，可以发现控制颜色输出的由两部分构成：<code>\033[31m</code>和<code>\033[0m</code>(<strong>ANSI控制码</strong>)，完整代码见下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>具体两部分的作用</strong>：</p><ul><li><code>\033[31m</code>表明开始对字符进行颜色渲染</li><li><code>\033[0m</code>表明停止对字符进行渲染，如果不加的话后续的整个终端都会变成红色</li></ul><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo终止颜色渲染.png" alt="echo终止颜色渲染.png"></p><hr><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>通过上面的学习，我们已经知道是什么在控制颜色的输出，然而在实际应用中肯定也不会只想输出红色的内容，当然bash shell也允许更多颜色的支持，接下来我们就来了解什么控制了具体的字体颜色以及支持的字体颜色包括哪些。</p><p>还是前面用到的命令，其中<code>31m</code>中的<code>31</code>是用来控制颜色输出的，表明输出字体为红色：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>具体各个字体颜色</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 3&#123;0..7&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 输出原始命令，注意不能使用单引号，不能进行变量替换</span></span><br><span class="line">  <span class="comment"># 也不能使用双引号，不然直接输出颜色了</span></span><br><span class="line">  <span class="comment"># 刚好不加引号可以进行简单的转义以及变量替换</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="built_in">echo</span> -e \<span class="string">"\\033[<span class="variable">$&#123;i&#125;</span>mTEST\\033[0m\"</span></span><br><span class="line"><span class="string">  echo -e "</span>\033[<span class="variable">$&#123;i&#125;</span>mTEST\033[0m<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出结果：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo各种颜色输出.png" alt="echo各种颜色输出.png"></p><p><strong>具体颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">颜色</th><th width="60%">完整命令</th></tr><tr><td>30</td><td><strong>黑色</strong></td><td><code>echo -e "\033[30mTEST\033[0m"</code></td></tr><tr><td>31</td><td><strong>红色</strong></td><td><code>echo -e "\033[31mTEST\033[0m"</code></td></tr><tr><td>32</td><td><strong>绿色</strong></td><td><code>echo -e "\033[32mTEST\033[0m"</code></td></tr><tr><td>33</td><td><strong>黄色</strong></td><td><code>echo -e "\033[33mTEST\033[0m"</code></td></tr><tr><td>34</td><td><strong>蓝色</strong></td><td><code>echo -e "\033[34mTEST\033[0m"</code></td></tr><tr><td>35</td><td><strong>紫色</strong></td><td><code>echo -e "\033[35mTEST\033[0m"</code></td></tr><tr><td>36</td><td><strong>浅蓝色</strong></td><td><code>echo -e "\033[36mTEST\033[0m"</code></td></tr><tr><td>37</td><td><strong>白色</strong></td><td><code>echo -e "\033[37mTEST\033[0m"</code></td></tr></table><hr><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>除了能够修改字体颜色之外，bash shell还支持对背景颜色的修改以及与字体颜色的组合：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 黄色背景，红色字体</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[43;31mTEST\033[0m"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>具体各个背景颜色(固定字体为红色)</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用sed命令将之前的代码注释</span></span><br><span class="line">sed -i <span class="string">'2,$s/^/#/'</span> color.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 4&#123;0..7&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="built_in">echo</span> -e \<span class="string">"\\033[<span class="variable">$&#123;i&#125;</span>\;31mTEST\\033[0m\"</span></span><br><span class="line"><span class="string">  echo -e "</span>\033[<span class="variable">$&#123;i&#125;</span>;31mTEST\033[0m<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/echo各种背景颜色输出.png" alt="echo各种背景颜色输出.png"></p><p><strong>具体背景颜色表格对照</strong>:</p><table><tr><th width="20%">颜色代码</th><th width="20%">背景颜色</th><th width="60%">完整命令(字体颜色为红色)</th></tr><tr><td>40</td><td><strong>黑色</strong></td><td><code>echo -e "\033[40;31mTEST\033[0m"</code></td></tr><tr><td>41</td><td><strong>红色</strong></td><td><code>echo -e "\033[41;31mTEST\033[0m"</code></td></tr><tr><td>42</td><td><strong>绿色</strong></td><td><code>echo -e "\033[42;31mTEST\033[0m"</code></td></tr><tr><td>43</td><td><strong>黄色</strong></td><td><code>echo -e "\033[43;31mTEST\033[0m"</code></td></tr><tr><td>44</td><td><strong>蓝色</strong></td><td><code>echo -e "\033[44;31mTEST\033[0m"</code></td></tr><tr><td>45</td><td><strong>紫色</strong></td><td><code>echo -e "\033[45;31mTEST\033[0m"</code></td></tr><tr><td>46</td><td><strong>浅蓝色</strong></td><td><code>echo -e "\033[46;31mTEST\033[0m"</code></td></tr><tr><td>47</td><td><strong>白色</strong></td><td><code>echo -e "\033[47;31mTEST\033[0m"</code></td></tr></table><div class="note info"><p>上述的字体颜色固定为了红色，实际使用过程中背景颜色和字体颜色可以组合，形成多种输出样式。</p></div><hr><h3 id="ansi控制码总结"><a href="#ansi控制码总结" class="headerlink" title="ansi控制码总结"></a>ansi控制码总结</h3><p>ansi控制码中不仅有控制颜色的控制码，还有一些提供其他功能的控制码，如闪烁、加粗、下划线等，我们来总结一下：</p><table><tr><th width="20%">ANSI控制码</th><th width="40%">说明</th><th width="40%">完整命令示例</th></tr><tr><td><code>\033[0m</code></td><td>关闭所有属性，也就是说此控制码前面的控制码将会失效。</td><td><code>echo -e "\033[31;0;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[1m</code></td><td><strong>设置高亮度(加粗)</strong></td><td><code>echo -e "\033[1;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[4m</code></td><td><strong>下划线</strong></td><td><code>echo -e "\033[4;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[5m</code></td><td><strong>闪烁</strong></td><td><code>echo -e "\033[5;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[7m</code></td><td>反显，撞色显示，显示为白底黑字，或者显示为黑底白字，也可以和字体、背景颜色搭配</td><td><code>echo -e "\033[7mTEST\033[0m"</code></td></tr><tr><td><code>\033[8m</code></td><td>消隐，字符颜色将会与背景颜色相同，<strong>忽略设置的字体颜色</strong></td><td><code>echo -e "\033[8;31;42mTEST\033[0m"</code></td></tr><tr><td><code>\033[30m--\33[37m</code></td><td>设置字符颜色</td><td><code>echo -e "\033[31mTEST\033[0m"</code></td></tr><tr><td><code>\033[40m--\33[47m</code></td><td>设置背景色</td><td><code>echo -e "\033[41mTEST\033[0m"</code></td></tr></table><p><strong>实际效果</strong>：</p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/ansi控制码总结.png" alt="ansi控制码总结.png"></p><div class="note info"><p>上述是<strong>常用的</strong>ansi控制码总结，还有一些与<strong>光标相关(位置、移动和显隐)</strong>以及<strong>清屏相关的</strong>ansi控制码个人感觉用的很少就没有在这里列出，需要的话后续在补充学习，可以参考<a href="http://www.mamicode.com/info-detail-2555216.html" target="_blank" rel="noopener">这个链接</a>。</p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.zsythink.net/archives/96" target="_blank" rel="noopener">echo命令详解 （一） 真的很详细</a></li><li><a href="http://www.zsythink.net/archives/111" target="_blank" rel="noopener">echo命令详解 （二） 真的很详细</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nohup、disown和&amp;-任务管理</title>
      <link href="/posts/19305.html"/>
      <url>/posts/19305.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要围绕任务管理，包括<code>不挂断地运行(nohup命令)</code>、<code>补救命令(disown命令)</code>和<code>&amp;</code>后台运行，学习了<strong>如何使用nohup</strong>、<strong>在没使用nohup的情况下如何补救</strong>、<strong>如何将任务放在后台运行</strong>以及<strong>前后台切换相关操作</strong>。</p></div><a id="more"></a><h2 id="nohup简介"><a href="#nohup简介" class="headerlink" title="nohup简介"></a>nohup简介</h2><p><strong>背景问题</strong>：我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何<strong>让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？</strong></p><p><strong>原因</strong>：当用户注销(logout)或者网络断开时，<strong>终端会收到 HUP(hangup)信号从而关闭其所有子进程</strong>；对应到上面的背景问题，当本地终端窗口关闭或者网络连接断开后，终端收到信号导致所有的任务(子进程)都被关闭，具体的过程如下：</p><ul><li>用户退出 session(终端)</li><li>系统向该 session 发出HUP信号</li><li>session 将HUP信号发给所有子进程</li><li>子进程收到HUP信号后，自动退出</li></ul><p><strong>解决办法</strong>：针对上面的问题和原因，很容易想到<strong>如果我们可以让终端忽略HUP(hangup)信号是不是就可以完美解决本地终端窗口关闭或者网络连接断开对任务的影响</strong>，这正是今天要学习的命令<code>nohup</code>的功能。</p><p><code>nohup</code>虽然一直在使用，但是关于其和<code>&amp;</code>的关系一直有些困惑，这里对<code>nohup</code>命令进行详细的学习，希望能够解决我的困惑。</p><hr><h2 id="nohup用法"><a href="#nohup用法" class="headerlink" title="nohup用法"></a>nohup用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: nohup COMMAND [ARG]...</span><br><span class="line">  or:  nohup OPTION</span><br></pre></td></tr></table></figure><p><strong>Run COMMAND, ignoring hangup signals.</strong></p><div class="note info"><p><strong>nohup命令具体作用</strong>：</p><ul><li><strong>阻止HUP信号</strong>发到session下的子进程</li><li><strong>关闭标准输入</strong>，该进程不再能够接收任何输入，<strong>即使运行在前台</strong></li><li>重定向标准输出和标准错误到文件nohup.out(默认，可以指定)</li></ul></div><hr><h2 id="nohup实例"><a href="#nohup实例" class="headerlink" title="nohup实例"></a>nohup实例</h2><h3 id="默认用法"><a href="#默认用法" class="headerlink" title="默认用法"></a>默认用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略挂起信号</span></span><br><span class="line">nohup ./test.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，会将标准输出和标准错误结果重定向到当前文件夹下的nohup.out中</span></span><br><span class="line">nohup: ignoring input and appending output to `nohup.out<span class="string">'</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>nohup</code><strong>只是可以忽略挂起信号</strong>，也就是<strong>不管终端或者网络是不是正常，都会继续运行(退出终端然后重新登录可发现<code>nohup.out</code>文件大小还在变大，程序还在运行)</strong>，但是<strong>仍然是在<u>前台运行</u></strong>，当前的窗口会一直等待命令运行结束才会允许输入下一个命令。</p></div><div class="note warning"><p>既然忽略挂起信号之后，退出终端命令还可以执行，那这和后台的区别在哪里呢？后台仅仅是解放了当前窗口吗？—&gt;后面会有解答</p></div><hr><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出重定向</span></span><br><span class="line"><span class="comment"># 标准输出重定向到文件test.log，标准错误输出(2)重定向等同于标准输出(1)</span></span><br><span class="line">nohup ./test.sh &gt;test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><hr><h3 id="终端进程与其子进程"><a href="#终端进程与其子进程" class="headerlink" title="终端进程与其子进程"></a>终端进程与其子进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略挂起信息</span></span><br><span class="line">nohup ./test.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找通过top得到的nohup命令的pid</span></span><br><span class="line"><span class="comment"># 第二列为命令的pid，第三列为命令的父进程号(这里是终端)</span></span><br><span class="line"><span class="comment"># 由于nhup命令是在一个终端上提交的，而grep是在另一个终端上执行的</span></span><br><span class="line"><span class="comment"># 所以两个命令的第三列不同，有不同的父进程号，两者属于不同的父进程</span></span><br><span class="line">ps -ef|grep 72502</span><br><span class="line">  user    72502  68858 98 17:34 pts/2    00:00:33 /bin/sh ./test.sh</span><br><span class="line">  user    72568  68932  0 17:35 pts/3    00:00:00 grep 72502</span><br></pre></td></tr></table></figure><p><strong>通过上面的命令可以知道，如果终端关闭(也就是第三列的父进程关闭)，该父进程所有的子进程(也就是第二列，在该终端上执行的所有命令)都会被关闭。</strong></p><hr><h3 id="nohup之后命令还是随终端退出"><a href="#nohup之后命令还是随终端退出" class="headerlink" title="nohup之后命令还是随终端退出"></a>nohup之后命令还是随终端退出</h3><p>这个问题我也没遇到过，但是学习的时候发现有人遇到过类似的问题，为了方便以后可能问题的解决，这里记录一下：</p><blockquote><p>有时候在nohup会有问题，当把终端关闭后，进程会自动被关闭，察看nohup.out可以看到在关闭终端瞬间服务自动关闭；咨询红旗Linux工程师后，他也不得其解，在我的终端上执行后，他启动的进程竟然在关闭终端后依然运行；在第二遍给我演示时，我才发现我和他<strong>操作终端时的一个细节不同</strong>：他是在当shell中提示了<strong>nohup成功后</strong>还需要按终端上键盘任意键<strong>退回到shell输入命令窗口</strong>，然后通过在shell中<strong>输入exit来退出终端</strong>；而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端.。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。</p></blockquote><hr><p><br></p><h2 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h2><p>前面提到的<strong>终端收到 HUP(hangup)信号从而关闭其所有子进程关闭</strong>，<strong>一种解决方法是使用nohup让终端忽略HUP(hangup)信号</strong>，<strong>另一种想法就是让提交的任务不属于当前终端的子进程(相当于上面的第三列不同)，这种做法对应的命令是<code>setsid</code>，但是感觉这是治标不治本的方法，并不是很实用</strong>，如果想了解可查看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="noopener">这个链接</a>。</p><hr><h2 id="nohup和-amp-命令的困惑"><a href="#nohup和-amp-命令的困惑" class="headerlink" title="nohup和&amp;命令的困惑"></a>nohup和&amp;命令的困惑</h2><p><strong>困惑来源</strong>：<strong>放在后台之后命令即使关闭了当前的终端，命令还是可以在后台运行，这是为啥？</strong></p><p>针对上述困惑，我在网上查找了各种资源，大多都是说<code>nohup</code>负责忽略挂起信号，而<code>&amp;</code>负责将命令放在后台运行，这与我的实际实践不符合(感觉网上很多资源都是相互复制，并没有做到自己实践，当然也有可能和自己的服务器配置相关)，随后我查找了<a href="https://stackoverflow.com/questions/15595374/whats-the-difference-between-nohup-and-ampersand" target="_blank" rel="noopener">英文资料</a>，根据文中提示的命令<code>shopt | grep hupon</code>发现我的服务器的设置为<code>huponexit off</code>，按照文中的说法是不会将HUP(hangup)信号发给所有子进程，但是前面自己实践发现退出终端后命令会直接停止，表明还是有将HUP(hangup)信号发给所有子进程，基于此，我只能继续<a href="https://www.cnblogs.com/0616--ataozhijia/p/8037887.html" target="_blank" rel="noopener">查找资料</a>，发现<strong>区别在于前台和后台</strong>：</p><ul><li><mark>前台任务会随着 session 的退出而退出：因为它收到了HUP(hangup)信号(参考文章开头的流程)</mark></li><li><mark>后台任务是否也会收到HUP(hangup)信号才是由上面的命令<code>shopt | grep hupon</code>决定的，也就是<code>huponexit off</code>，不会收到这个信号</mark></li></ul><p>自此，困惑我许久的问题得到了解决，感觉真好(网上资料非常多，自己还是要实践才能辨别好坏啊！！)</p><hr><p><br></p><h2 id="补救措施"><a href="#补救措施" class="headerlink" title="补救措施"></a>补救措施</h2><p><strong>问题背景</strong>：经过前面的学习，我们已经知道了<strong>事先在命令前加上 <code>nohup</code> 或者 <code>setsid</code> 就可以避免 HUP 信号的影响</strong>，但是<strong>如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？</strong></p><p><strong>解决方法</strong>：针对上面的问题，可以使用Linux的<code>disown</code>命令</p><h3 id="disown用法"><a href="#disown用法" class="headerlink" title="disown用法"></a>disown用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  <span class="built_in">disown</span> [-h] [-ar] [jobspec ...]</span><br></pre></td></tr></table></figure><ul><li><strong>Without options</strong>, <u>each jobspec is removed from the table of active jobs</u>.</li><li>If the <strong>-h option is given</strong>, each jobspec is not removed from the table, but is marked so that <u>SIGHUP is not sent to the job if the shell receives a SIGHUP</u>.</li><li>If <strong>no jobspec is present</strong>, <strong>and neither the -a nor the -r option is supplied</strong>, the <u>current job is used</u>.</li><li><strong>If no jobspec is supplied</strong>, <u>the -a option means to remove or mark all jobs</u>; <u>the -r option without a jobspec argument restricts operation to running jobs</u>.</li><li>The <strong>return value</strong> is 0 unless a jobspec does not specify a valid job.</li></ul><p>通过上面英文的说明，我们可以这么使用：</p><ul><li>用<code>disown -h jobspec</code>来使<strong>某个作业忽略HUP信号</strong></li><li>用<code>disown -ah</code> 来使<strong>所有的作业都忽略HUP信号</strong></li><li>用<code>disown -rh</code> 来使<strong>正在运行的作业忽略HUP信号</strong></li></ul><p>需要注意的是：<strong>当使用过 <code>disown</code> 之后，会将把目标作业从作业列表中移除，我们将不能再使用<code>jobs</code>来查看它，但是依然能够用<code>ps -ef</code>查找到它</strong>。</p><p><strong>但是还有一个问题</strong>，这种方法的<strong>操作对象是作业</strong>，如果我们在运行命令时在结尾加了<code>&quot;&amp;&quot;</code>来<strong>使它成为一个作业并在后台运行</strong>，那么就万事大吉了，我们可以通过<code>jobs</code>命令来得到所有作业的列表。但是<strong>如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？</strong>答案就是用 <code>CTRL-z</code>(按住Ctrl键的同时按住z键)了！<code>CTRL-z</code> 的用途就是<strong>将当前进程挂起(Suspend)</strong>，<strong>然后我们就可以用jobs命令来查询它的作业号</strong>，再用<code>bg jobspec</code>来<strong>将它放入后台并继续运行</strong>，<strong>需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</strong></p><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="命令已在后台运行"><a href="#命令已在后台运行" class="headerlink" title="命令已在后台运行"></a>命令已在后台运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令先放在后台运行</span></span><br><span class="line"><span class="comment"># 按照前面对我困惑的解答，其实这里已经不需要在将其设置nohup了</span></span><br><span class="line"><span class="comment"># 但是为了以防万一，以及严谨性，还是学习一番</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br><span class="line">  [1] 101367</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用jobs查看后台命令</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Running                 ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用disown命令</span></span><br><span class="line"><span class="built_in">disown</span> -h %1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程ID和父进程ID</span></span><br><span class="line">ps -ef |grep 101367</span><br><span class="line">  user   101367  91326 96 00:15 pts/4    00:00:45 bash</span><br><span class="line">  user   101426  91326  0 00:16 pts/4    00:00:00 grep 101367</span><br></pre></td></tr></table></figure><hr><h4 id="命令未放在后台"><a href="#命令未放在后台" class="headerlink" title="命令未放在后台"></a>命令未放在后台</h4><p>如果提交命令时未使用<code>&amp;</code>将命令放入后台运行，可使用 <code>CTRL-z</code> 和<code>bg jobspec</code>将其放入后台，再结合<code>jobs</code>使用<code>disown</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不放在后台的命令</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># CTRL-z挂起</span></span><br><span class="line">^Z</span><br><span class="line">  [1]+  Stopped                 ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放在后台</span></span><br><span class="line"><span class="built_in">bg</span> %1</span><br><span class="line">  [1]+ ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看后台任务</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再使用disown命令</span></span><br><span class="line"><span class="built_in">disown</span> -h %1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程ID和父进程ID</span></span><br><span class="line">ps -ef |grep 101496</span><br><span class="line">  user   101496  91326 88 00:17 pts/4    00:00:27 bash</span><br><span class="line">  user   101508  91326  0 00:17 pts/4    00:00:00 grep 101496</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h2><p>screen命令也可以让进程免受 HUP 信号的影响，与上面不同的是如果有大量这种命令需要在稳定的后台里运行，其可避免对每条命令都做这样的操作。由于screen命令是一个功能非常强大的命令，这里很难将其搞清楚，后续会专门学习这个命令，具体请参考<a href="http://showteeth.tech/posts/33882.html">screen-远程会话管理工具</a></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在几种方法已经介绍完毕，我们可以<strong>根据不同的场景来选择不同的方案</strong>：</p><ul><li><code>nohup/setsid</code> 无疑是临时需要时最方便的方法</li><li><code>disown</code> 能帮助我们来<strong>事后补救</strong>当前已经在运行了的作业</li><li><code>screen</code> 则是在<strong>大批量操作</strong>时不二的选择了</li></ul><hr><p><br></p><h2 id="amp-后台运行"><a href="#amp-后台运行" class="headerlink" title="&amp;后台运行"></a>&amp;后台运行</h2><p>前面其实已经提到和使用过后台运行任务的用法：在命令之后增加<code>&amp;</code>，同时也解决了我再<code>nohup</code>和<code>&amp;</code>之间存在的困惑，这里就再对<code>&amp;</code>进行更加全面的学习。</p><p>之所以需要学习后台运行任务的命令，是因为当我们在终端或控制台工作时，不希望由于运行一个作业而占住了屏幕，而常规的添加或者不添加nohup都会使得任务占据当前终端或控制台，想要进行下一步操作只能等待当前工作结束，这个非常耽误时间，而使用<code>&amp;</code>来将任务放入后台后，就可在当前终端或工作台进行更多的操作，非常方便(<strong>需要注意如果没有使用nohup、并且没有将输出重定向，屏幕会显示大量输出结果</strong>)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用nohup不挂断地运行任务，并将输出重定向到默认的nohup.out</span></span><br><span class="line">nohup ./test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行，输出结果显示在屏幕上(那种正在操作其他命令，忽然输出结果的这种)</span></span><br><span class="line">./test.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行，指定输出重定向文件(屏幕不再有输出内容)</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nohup加上&amp;</span></span><br><span class="line"><span class="comment">#其实根据我上面困惑的解答，在我这台服务器上对于后台任务使不使用nohup都可以</span></span><br><span class="line">nohup ./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p></p><h3 id="后台任务的两个特点"><a href="#后台任务的两个特点" class="headerlink" title="后台任务的两个特点"></a>后台任务的两个特点</h3><ul><li><strong>继承当前 session (对话)的标准输出(stdout)和标准错误(stderr)</strong>，因此，<strong>后台任务的所有输出依然会同步地在命令行下显示</strong></li><li><strong>不再继承当前 session 的标准输入(stdin)</strong>，你<strong>无法向这个任务输入指令了</strong>，如果它试图读取标准输入，就会暂停执行(halt)</li></ul><p><strong><code>后台任务</code>与<code>前台任务</code>的<code>本质区别</code>只有一个：是否继承标准输入</strong></p><hr><h3 id="监控杀死后台任务"><a href="#监控杀死后台任务" class="headerlink" title="监控杀死后台任务"></a>监控杀死后台任务</h3><p>前面提交后台任务之后会返回得到任务的进程号，依据这个进程号我们可以监控(<code>ps -ef |grep job进程号</code>)或者杀死(<code>kill -9 job进程号或者kill %job序号</code>)后台的任务：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交后台任务</span></span><br><span class="line">nohup ./test.sh &gt;test.log 2&gt;&amp;1 &amp;</span><br><span class="line">  [1] 138837</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控后台任务</span></span><br><span class="line">ps -ef |grep 138837</span><br><span class="line">  songyb   138837  91326 96 09:19 pts/4    00:00:16 /bin/sh ./test.sh</span><br><span class="line">  songyb   138912  91326  0 09:20 pts/4    00:00:00 grep 138837</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉任务</span></span><br><span class="line"><span class="built_in">kill</span> -9 138837</span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Killed                  nohup ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉任务</span></span><br><span class="line"><span class="built_in">kill</span> %1</span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">[1]+  Terminated              nohup ./test.sh &gt; test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>如果当时没有记下进程号，可以使用<code>echo $!</code>得到<strong>当前终端</strong>提交的<strong>最后一个后台任务</strong>的进程号，注意是<strong>当前终端，不能在其他终端进行查找</strong></p></div><hr><h3 id="切换前后台相关命令"><a href="#切换前后台相关命令" class="headerlink" title="切换前后台相关命令"></a>切换前后台相关命令</h3><ul><li><code>ctrl+z</code>：將前台任务丟到后台中暂停，配合<code>bg %job序号</code>使用</li><li><code>jobs</code>：查看后台的工作状态</li><li><code>bg %job序号</code>：将任务放到后台中去处理</li><li><code>fg %job序号</code>：将后台的任务拿到前台来处理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先提交一个前台的任务，终端会等待命令运行结束</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl+z挂起命令，將前台任务丟到后台中暂停</span></span><br><span class="line">^Z</span><br><span class="line">  [1]+  Stopped                 ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># jobs查看工作状态</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Stopped                 ./test.sh &gt; test.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># bg %job序号：将任务放入后台</span></span><br><span class="line"><span class="built_in">bg</span> %1</span><br><span class="line">  [1]+ ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看任务状态</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">  [1]+  Running                 ./test.sh &gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># fg %job序号：将后台的任务拿到前台来处理</span></span><br><span class="line"><span class="built_in">fg</span> %1</span><br><span class="line">  ./test.sh &gt; test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>job序号</strong>就是使用<code>jobs</code>命令查看的当前终端的任务序号，如<code>[1]+ Stopped ./test.sh &gt; test.log 2&gt;&amp;1</code>中的<code>[1]</code>，而<strong>不是通过<code>top</code>查看的进程号</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="noopener">Linux 技巧：让进程在后台可靠运行的几种方法-讲解非常好</a></li><li><a href="https://www.cnblogs.com/0616--ataozhijia/p/8037887.html" target="_blank" rel="noopener">[Linux] Linux 守护进程的启动方法-背后的原理</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wget-命令行下载工具</title>
      <link href="/posts/44952.html"/>
      <url>/posts/44952.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux的命令行下载命令wget，其可以实现<strong>断点续传</strong>、<strong>代理下载</strong>、<strong>批量下载</strong>以及<strong>下载整个网站</strong>等强大的功能；这里主要学习的参数包括<code>-O</code>、<code>-q</code>、<code>-o</code>、<code>-c</code>、<code>-b</code>、<code>用户名和密码登录</code>、<code>下载限速</code>、<code>测试下载链接</code>、<code>-t</code>、<code>-i</code>、<code>下载整个网站</code>、<code>镜像下载</code>、<code>-R</code>、<code>-A</code>、<code>-w</code>、<code>-U</code>、<code>-Q</code>，其他参数可以查看帮助文档。</p></div><a id="more"></a><h2 id="wget简介"><a href="#wget简介" class="headerlink" title="wget简介"></a>wget简介</h2><p><code>wget</code>是linux上的命令行的下载工具。这是一个GPL许可证下的自由软件。<code>Linux wget</code>支持<code>HTTP</code>和<code>FTP</code>协议，支持<strong>代理服务器</strong>和<strong>断点续传功能</strong>，能够<strong>自动递归远程主机的目录</strong>，<strong>找到合乎条件的文件并将其下载到本地硬盘上</strong>；如果必要，Linux wget将恰当地转换页面中的超级链接以在本地生成可浏览的镜像。由于没有交互式界面，<strong>Linux wget可在后台运行</strong>，截获并忽略HANGUP信号，因此在用户退出登录以后，仍可继续运行。通常，Linux wget用于<strong>成批量地下载</strong>Internet网站上的文件，或<strong>制作远程网站的镜像</strong>。</p><div class="note info"><p>wget<strong>最大的缺点</strong>是单线程，不支持多线程下载</p></div><hr><h2 id="wget用法"><a href="#wget用法" class="headerlink" title="wget用法"></a>wget用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  wget [OPTION]... [URL]...</span><br></pre></td></tr></table></figure><p>由于wget的参数较多，而平常对于其使用要求也不是很高，所以这里就结合实例进行学习，对其参数不做细致学习，需要的时候可以使用<code>wget --help</code>查看帮助文档。</p><hr><h2 id="wget实例学习"><a href="#wget实例学习" class="headerlink" title="wget实例学习"></a>wget实例学习</h2><h3 id="默认-使用wget下载单个文件"><a href="#默认-使用wget下载单个文件" class="headerlink" title="默认-使用wget下载单个文件"></a>默认-使用wget下载单个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p>以下的例子是从网络下载一个文件<strong>并保存在当前目录</strong>，在下载的过程中会显示如下信息：</p><ul><li>正在下载的文件的名称</li><li>显示下载百分比的进度条</li><li>已下载文件的大小</li><li>当前下载速度</li><li>剩余下载时间(下载完成之后会显示下载用时)</li></ul><div class="note info"><p><strong>默认情况下保存的文件为下载的文件名</strong>，如上述的<code>Homo_sapiens.GRCh38.95.chr.gff3.gz</code></p></div><hr><h3 id="O-指定保存文件名"><a href="#O-指定保存文件名" class="headerlink" title="-O-指定保存文件名"></a>-O-指定保存文件名</h3><p>如上所述，wget默认会以最后一个<code>/</code>的后面的字符来命名下载的文件，这<strong>对于动态链接的下载通常会是错误的</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载动态链接内容(这里的示例不是很好，知道有这个情况即可)</span></span><br><span class="line">wget https://blog.csdn.net/chenbang110/article/details/7854384</span><br></pre></td></tr></table></figure><p></p><p>使用上述命令下载结束后会在当前目录得到名为<code>7854384</code>的文件，而实际上该文件是个<code>html</code>文件。</p><p>为了解决上面出现的问题，<strong>可以使用<code>-O</code>指定输出文件名来解决</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出文件名</span></span><br><span class="line">wget https://blog.csdn.net/chenbang110/article/details/7854384 -O test.html</span><br></pre></td></tr></table></figure><p></p><p>使用上述命令之后会在当前目录得到名为<code>test.html</code>的文件，下载到本地打开可以得到刚刚显示的博客内容，说明<strong>原本是<code>html</code>格式，但是仍然会以最后一个<code>/</code>的后面的字符来命名，忽略文件格式</strong>。</p><div class="note info"><p>个人感觉除了在动态链接下使用这个 <strong><code>-O</code>(大写的)</strong>之外，正常情况下还是使用默认的文件名吧，这样下载的文件的后缀是正确的，自己指定可能会出错，导致文件不能正确打开。</p></div><hr><h3 id="q-无提示下载"><a href="#q-无提示下载" class="headerlink" title="-q-无提示下载"></a>-q-无提示下载</h3><p><strong>默认情况下，下载的时候会显示很多信息</strong>(比如链接状态、正在下载的文件的名称、下载速度等)，<strong>如果不想显示这些内容可以使用<code>-q</code>参数来达到静默下载的目的</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动静默下载，不显示任何信息，包括网络的连接信息</span></span><br><span class="line">wget -q ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="o-保存下载日志文件"><a href="#o-保存下载日志文件" class="headerlink" title="-o-保存下载日志文件"></a>-o-保存下载日志文件</h3><p>使用上面的-q进行无提示下载虽然使得屏幕上没有了杂乱的信息，但是自己也不知道下载的具体情况，所以这个时候就希望可以将下载信息输出到下载日志文件，<strong>wget支持使用<code>-o</code>命令来指定日志文件名称</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定日志文件</span></span><br><span class="line"><span class="comment"># -o,  --output-file=FILE    log messages to FILE.</span></span><br><span class="line">wget -o test.log ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><p>指定<code>-o</code>后下载过程不会显示信息，所有的下载信息都会被保存到指定的日志文件中</p><hr><h3 id="c-断点续传"><a href="#c-断点续传" class="headerlink" title="-c-断点续传"></a>-c-断点续传</h3><p>在下载加大文件的情况下，可能会出现下载中断的情况，为了应对这种问题，<strong><code>wget</code>也支持使用<code>-c</code>来进行断点续传</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始使用默认的下载方式</span></span><br><span class="line">wget ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"><span class="comment"># 但是下载到36%下载就中断了</span></span><br><span class="line"><span class="comment"># 36% [======================================&gt;                                                                      ] 14,005,056  1.20M/s  eta 31s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来进行断点续传</span></span><br><span class="line">wget -c ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"><span class="comment"># 会接着上次下载的位置(36%)进行下载，并使用+表示之前下载的部分，=表示现在下载的部分</span></span><br><span class="line"><span class="comment"># 41% [+++++++++++++++++++++++++++++++++++++++====&gt;                                                                 ] 15,987,368   299K/s  eta 1m 57s</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="b-后台下载"><a href="#b-后台下载" class="headerlink" title="-b-后台下载"></a>-b-后台下载</h3><p>如果当前需要下载的文件比较大，直接放在前台下载有点耽误工作，<strong>wget支持使用<code>-b</code>参数启动后台下载</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动后台下载</span></span><br><span class="line">wget -b ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动后台下载之后会返回pid以及下载的日志文件wget-log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以结合tail命令查看下载进度</span></span><br><span class="line">tail wget-log</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Continuing in background, <strong>pid 190363</strong>.<br>Output will be written to <strong>“wget-log”</strong>.</p></blockquote><hr><h3 id="用户名和密码认证下载"><a href="#用户名和密码认证下载" class="headerlink" title="用户名和密码认证下载"></a>用户名和密码认证下载</h3><p><strong>上面使用<code>ftp</code>下载</strong>时，默认是匿名登录进行下载，如果<strong>需要登录用户名和密码的话需要使用<code>--ftp-user</code>和<code>--ftp-password</code>指定</strong>，具体如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认匿名登录：Logging in as anonymous ... Logged in!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ftp下载时设置用户名和密码登录</span></span><br><span class="line">wget --ftp-user=USERNAME --ftp-password=PASSWORD ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><p>上述是使用ftp进行下载，如果是<strong>使用<code>HTTP</code>下载</strong>，和上面类似，不过是<strong>使用<code>--http-user=USER</code>和<code>--http-password=PASS</code>来分别指定用户名和密码</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP下载时设置用户名和密码登录</span></span><br><span class="line">wget --http-user=USER --http-password=PASS  url</span><br></pre></td></tr></table></figure><p></p><p>wget还支持<strong>使用<code>--user=USER</code>和<code>--password=PASS</code>来统一进行用户名和密码的输入</strong>，<strong>不用区分<code>http</code>或者<code>ftp</code>下载</strong>，但是<strong>设置ftp和http的用户名和密码之后会覆盖这个设置的内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统一设置用户名和密码登录</span></span><br><span class="line">wget --user=USER --password=PASS  url</span><br></pre></td></tr></table></figure><p></p><p>如果担心密码泄露，不想直接指定密码，可以<strong>使用<code>--ask-password</code>选项来提示输入密码</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提示输入密码</span></span><br><span class="line"><span class="comment"># --ask-password   prompt for passwords.</span></span><br><span class="line">wget --user=USER --ask-password  url</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–limit-rate-限速下载"><a href="#–limit-rate-限速下载" class="headerlink" title="–limit-rate-限速下载"></a>–limit-rate-限速下载</h3><p>当执行wget的时候，它<strong>默认会占用全部可能的宽带下载</strong>。但是当你<strong>准备下载一个大文件</strong>，而你<strong>还需要下载其它文件时</strong>就有必要限速了，wget支持使用形如<code>--limit-rate=300k</code>的参数进行限速：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限速下载</span></span><br><span class="line">wget --<span class="built_in">limit</span>-rate=300k ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="–spider-测试下载链接"><a href="#–spider-测试下载链接" class="headerlink" title="–spider-测试下载链接"></a>–spider-测试下载链接</h3><p>当你打算进行<strong>定时下载</strong>，你应该<strong>在预定时间测试下载链接是否有效</strong>，wget支持<strong>使用<code>--spider</code>参数进行链接有效性的检查</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试下载链接</span></span><br><span class="line">wget --spider ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p><strong>输出内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--2019-03-27 23:34:37--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">           =&gt; “Homo_sapiens.GRCh38.95.chr.gff3.gz.3”</span><br><span class="line">Resolving ftp.ensembl.org... 193.62.193.8</span><br><span class="line">Connecting to ftp.ensembl.org|193.62.193.8|:21... connected.</span><br><span class="line">Logging <span class="keyword">in</span> as anonymous ... Logged <span class="keyword">in</span>!</span><br><span class="line">==&gt; SYST ... <span class="keyword">done</span>.    ==&gt; PWD ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; TYPE I ... <span class="keyword">done</span>.  ==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; SIZE Homo_sapiens.GRCh38.95.chr.gff3.gz ... 38793139</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    --2019-03-27 23:34:39--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line">           =&gt; “.listing”</span><br><span class="line">==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    ==&gt; LIST ... <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">    [ &lt;=&gt;                                                                                                         ] 3,175       --.-K/s   <span class="keyword">in</span> 0s      </span><br><span class="line"></span><br><span class="line">Removed “.listing”.</span><br><span class="line"><span class="comment"># 显示文件存在</span></span><br><span class="line">File “Homo_sapiens.GRCh38.95.chr.gff3.gz” exists.</span><br></pre></td></tr></table></figure><p></p><p><strong>如果文件不存在的话</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--2019-03-27 23:36:58--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz</span><br><span class="line">           =&gt; “Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz”</span><br><span class="line">Resolving ftp.ensembl.org... 193.62.193.8</span><br><span class="line">Connecting to ftp.ensembl.org|193.62.193.8|:21... connected.</span><br><span class="line">Logging <span class="keyword">in</span> as anonymous ... Logged <span class="keyword">in</span>!</span><br><span class="line">==&gt; SYST ... <span class="keyword">done</span>.    ==&gt; PWD ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; TYPE I ... <span class="keyword">done</span>.  ==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; SIZE Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    --2019-03-27 23:37:00--  ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz</span><br><span class="line">           =&gt; “.listing”</span><br><span class="line">==&gt; CWD (1) /pub/release-95/gff3/homo_sapiens ... <span class="keyword">done</span>.</span><br><span class="line">==&gt; PASV ... <span class="keyword">done</span>.    ==&gt; LIST ... <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">    [ &lt;=&gt;                                                                                                         ] 3,175       --.-K/s   <span class="keyword">in</span> 0.004s  </span><br><span class="line"></span><br><span class="line">Removed “.listing”.</span><br><span class="line"><span class="comment"># 显示文件不存在</span></span><br><span class="line">No such file “Homo_sapiens.GRCh38.95.chr.gff3adsfa.gz”.</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><strong>你可以在以下几种情况下使用<code>--spider</code>参数</strong>：</p><ul><li><strong>定时下载</strong>之前进行检查</li><li><strong>间隔检测网站是否可用</strong></li><li>检查网站页面的<strong>死链接</strong></li></ul></div><hr><h3 id="t-增加重试次数"><a href="#t-增加重试次数" class="headerlink" title="-t-增加重试次数"></a>-t-增加重试次数</h3><p>如果<strong>网络不稳定或者其他原因导致连接出现问题</strong>，wget支持<strong>使用<code>-t(--tries=NUMBER)</code>参数来设置重试的次数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置重试次数为40次</span></span><br><span class="line"><span class="comment"># set number of retries to NUMBER (0 unlimits)</span></span><br><span class="line">wget --tries=40 ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br></pre></td></tr></table></figure><p></p><p><strong>参数<code>-t</code>设置为0的时候是不对重试次数进行限制</strong></p><hr><h3 id="i-下载多个文件"><a href="#i-下载多个文件" class="headerlink" title="-i-下载多个文件"></a>-i-下载多个文件</h3><p>如果需要<strong>下载多个链接，可以将多个链接写入文件，然后使用<code>-i</code>参数进行文件链接的下载</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用cat命令创建并输入链接文件</span></span><br><span class="line">cat &gt; filelist.txt</span><br><span class="line">url1</span><br><span class="line">url2</span><br><span class="line">url3</span><br><span class="line">url4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-i进行文件链接的下载</span></span><br><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="递归下载整个网站"><a href="#递归下载整个网站" class="headerlink" title="递归下载整个网站"></a>递归下载整个网站</h3><p>比如在学习中我们遇到一个很好的网站，里面有很多自己需要的东西，一个一个下载太麻烦，这个时候就可以使用下面的命令直接下载整个网站(感觉不是很道德。。。)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载整个网站</span></span><br><span class="line">wget --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><p><strong>参数解读</strong>：</p><ul><li><code>--restrict-file-name=ascii</code>：<strong>防止出现中文乱码的问题</strong>，<a href="https://blog.csdn.net/kowity/article/details/6899256" target="_blank" rel="noopener">这个链接</a>中给出了改名字的程序，需要的时候可以看看</li><li><code>-r</code>(<code>--recursive</code>)：specify recursive download.（<strong>指定递归下载</strong>）</li><li><code>-k</code>(<code>--convert-links</code>)：make links in downloaded HTML point to local files.（<strong>将下载的HTML页面中的链接转换为相对链接即本地链接</strong>）</li><li><code>-p</code>(<code>--page-requisites</code>)：get all images, etc. needed to display HTML page.（<strong>下载所有的图片等页面显示所需的内容</strong>）</li><li><code>-np</code>(<code>--no-parent</code>): <strong>不追溯至父级目录</strong> don’t ascend to the parent directory.</li></ul><hr><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>当要下载一个<strong>完整站点并实现本地浏览</strong>的时候，可以使用如下命令进行下载：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启镜像下载</span></span><br><span class="line">wget --mirror -p -k -np -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p></p><p><strong>参数解读</strong>：</p><ul><li><code>-m</code>(<code>--miror</code>)：开户镜像下载</li><li><code>-p</code>：<strong>下载所有的图片等页面显示所需的内容</strong></li><li><code>-k</code>(<code>--convert-links</code>): make links in downloaded HTML point to local files.（<strong>将下载的HTML页面中的链接转换为相对链接即本地链接</strong>）</li><li><code>-P ./LOCAL</code>：保存所有文件和目录到本地指定目录</li><li><code>-np</code>(<code>--no-parent</code>): <strong>不追溯至父级目录</strong> don’t ascend to the parent directory.</li></ul><hr><h3 id="R-过滤指定格式文件"><a href="#R-过滤指定格式文件" class="headerlink" title="-R-过滤指定格式文件"></a>-R-过滤指定格式文件</h3><p>在下载的过程中，如果不想要下载后缀为<code>.png</code>的图片文件，可以使用<code>--reject=png</code>进行限制：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤下载，使用逗号分隔不同格式</span></span><br><span class="line"><span class="comment"># -R,  --reject=LIST   comma-separated list of rejected extensions.</span></span><br><span class="line">wget --restrict-file-name=ascii -r -p -np -k -R <span class="string">'*.html'</span>,<span class="string">'*.css'</span> http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="A-指定下载文件格式"><a href="#A-指定下载文件格式" class="headerlink" title="-A-指定下载文件格式"></a>-A-指定下载文件格式</h3><p>上面讲解了使用-R进行过滤排除文件格式，当然也可以指定下载文件的格式，<strong>wget支持使用<code>-A</code>来指定下载文件格式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定文件格式下载</span></span><br><span class="line"><span class="comment"># -A,  --accept=LIST    comma-separated list of accepted extensions.</span></span><br><span class="line">wget --restrict-file-name=ascii -r -p -np -k -A <span class="string">'*.html'</span>,<span class="string">'*.css'</span> http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="w-设置下载等待时间"><a href="#w-设置下载等待时间" class="headerlink" title="-w-设置下载等待时间"></a>-w-设置下载等待时间</h3><p>上面在下载整个网站的时候，下载过快可能会导致ip被封禁，为了避免这种情况，可以<strong>使用<code>-w</code>设置两次下载之间的等待时间</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置两次下载之间的等待时间</span></span><br><span class="line"><span class="comment"># -w,  --wait=SECONDS    wait SECONDS between retrievals.</span></span><br><span class="line">wget -w 20 --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="U-设置header下载"><a href="#U-设置header下载" class="headerlink" title="-U-设置header下载"></a>-U-设置header下载</h3><p>有些网站可能会<strong>通过代理名称来判断是不是浏览器</strong>，从而可能拒绝下载请求，<strong>为了避免请求被拒绝，wget支持使用<code>-U(--user-agent)</code>参数来进行伪装</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动代理进行伪装</span></span><br><span class="line">wget --user-agent=<span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16"</span> --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><p><strong>越来越有种爬虫的感觉</strong>。。。。。</p><hr><h3 id="Q-限制总下载文件大小"><a href="#Q-限制总下载文件大小" class="headerlink" title="-Q-限制总下载文件大小"></a>-Q-限制总下载文件大小</h3><p>前面提到的下载整个网站虽然很好，但是如果网站太大，对下载的数据量不进行限制，很多能导致自己的服务器存储不够，这时可使用<strong>wget的<code>-Q</code>来指定总下载文件大小</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定总下载文件大小</span></span><br><span class="line"><span class="comment"># -Q,  --quota=NUMBER   set retrieval quota to NUMBER.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意其对单个文件的下载不起效，以下命令可正常下载</span></span><br><span class="line">wget -Q 5m ftp://ftp.ensembl.org/pub/release-95/gff3/homo_sapiens/Homo_sapiens.GRCh38.95.chr.gff3.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对递归下载起效(也可以说链接不止一个)</span></span><br><span class="line">wget -Q 10k --restrict-file-name=ascii -r -p -np -k http://xxx.com/xxx</span><br></pre></td></tr></table></figure><p></p><p><strong>下载超过设置值时会提示</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br><span class="line">Download quota of 10K EXCEEDED!</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="Linux上下载迅雷内容"><a href="#Linux上下载迅雷内容" class="headerlink" title="Linux上下载迅雷内容"></a>Linux上下载迅雷内容</h3><p>参考<a href="https://www.linuxidc.com/Linux/2011-10/46052.htm" target="_blank" rel="noopener">这个链接</a></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/wget" target="_blank" rel="noopener">wget命令-实例讲解</a></li><li><a href="https://www.linuxidc.com/Linux/2018-02/150757.htm" target="_blank" rel="noopener">Linux wget命令实例讲解</a></li><li><a href="https://vpsps.com/1325.html" target="_blank" rel="noopener">最后列出了参数，可以看看</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>more和less-查看文本内容</title>
      <link href="/posts/57059.html"/>
      <url>/posts/57059.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux查看文本内容的常用命令<code>more</code>以及<code>less</code>，两个命令很多地方都很相似，但是<code>less</code><strong>更加强大</strong>；分别学习了<code>more</code>和<code>less</code>的<strong>参数</strong>以及<strong>命令</strong>，其中<code>less</code>部分的参数和命令 <strong>只学习了常用的部分</strong>(<code>less</code>的功能很强大，对应的参数和命令很多，但是很多用不上，这里就没学习，后学如果有用在补上)。</p></div><a id="more"></a><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>more会以<strong>一页一页</strong>的显示方便使用者逐页阅读，而最基本的指令就是按<strong>空白键(space)就往下一页显示</strong>，<strong>按 b 键就会往回(back)一页显示</strong>，而且还有<strong>搜寻字串(直接跳转行)的功能</strong>,<strong>使用中按<code>h</code>可以查看说明文件</strong> 。more命令从前向后读取文件，因此在<strong>启动时就加载整个文件</strong>。</p><h3 id="more命令用法"><a href="#more命令用法" class="headerlink" title="more命令用法"></a>more命令用法</h3><h4 id="more命令格式"><a href="#more命令格式" class="headerlink" title="more命令格式"></a>more命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: </span><br><span class="line">  more [-dflpcsu] [+linenum | +/pattern] name1 name2 ...</span><br></pre></td></tr></table></figure><hr><h4 id="more-options说明"><a href="#more-options说明" class="headerlink" title="more options说明"></a>more options说明</h4><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>+n</code></td><td><strong>从笫n行开始显示</strong></td></tr><tr><td><code>-n</code></td><td><strong>定义屏幕大小为n行</strong></td></tr><tr><td><code>+/pattern</code></td><td><strong>在每个档案显示前搜寻该字串(pattern)，然后从该字串前两行之后开始显示</strong></td></tr><tr><td><code>-c</code></td><td><strong>清屏显示</strong></td></tr><tr><td><code>-d</code></td><td><strong>提示使用者，在内容下方显示 <code>[Press space to continue, &#39;q&#39; to quit.]</code> 如果按错键，则会显示 <code>[Press &#39;h&#39; for instructions.]</code> 而不是 ‘哔’ 声</strong></td></tr><tr><td><code>-l</code></td><td>忽略Ctrl+l(换页)字符</td></tr><tr><td><code>-p</code></td><td><strong>通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</strong></td></tr><tr><td><code>-s</code></td><td><strong>把连续的多个空行显示为一行</strong></td></tr><tr><td><code>-u</code></td><td>把文件内容中的下画线去掉</td></tr><tr><td><code>-f</code></td><td><strong>计算行数时，以实际上的行数，而非自动换行过后的行数(有些单行字数太长的会被扩展为两行或两行以上),可以和<code>-n</code>连用</strong></td></tr></tbody></table><hr><h4 id="more常用操作命令"><a href="#more常用操作命令" class="headerlink" title="more常用操作命令"></a>more常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>空格(space)</code></td><td><strong>向下滚动一屏</strong></td></tr><tr><td><code>z</code></td><td>向下滚动一屏</td></tr><tr><td><code>enter(return)</code></td><td><strong>向后滚动n行，默认为1</strong></td></tr><tr><td><code>q or Q or &lt;interrupt&gt;</code></td><td>退出more</td></tr><tr><td><code>b or ctrl-B</code></td><td><strong>返回上一屏</strong></td></tr><tr><td><code>=</code></td><td>输出当前行的行号</td></tr><tr><td><code>：f</code></td><td><strong>输出文件名和当前行的行号</strong></td></tr><tr><td><code>V</code></td><td>调用vi编辑器</td></tr><tr><td><code>!命令</code></td><td><strong>调用Shell，并执行命令</strong></td></tr><tr><td><code>.</code></td><td><strong>重复上一个命令</strong></td></tr></tbody></table><div class="note info"><ul><li><code>!命令</code>:输入的命令不能输错，输错了删不了；输出结果和文本内容之间使用<code>------</code>分割</li><li><code>：f</code>：使用时是按下<code>:</code>同时按下<code>f</code>，不能先按下<code>:</code>松手后再按<code>f</code></li></ul></div><hr><h4 id="参数和命令的关系"><a href="#参数和命令的关系" class="headerlink" title="参数和命令的关系"></a>参数和命令的关系</h4><div class="note info"><p><strong>参数决定了显示的内容(起始行、页面显示行数、换页是清屏还是滚动)，而命令决定了怎么去显示(翻页、滚动等)</strong>，以<code>-p</code>参数为例，规定了是清屏进行翻页，具体的翻页动作需要使用空格键操作，同时需要注意，其只规定的是换页是清屏的，如果使用<code>enter</code>进行显示下一行，仍然是滚动的方式，而不是清屏.</p></div><hr><h3 id="more命令实例"><a href="#more命令实例" class="headerlink" title="more命令实例"></a>more命令实例</h3><h4 id="n-从第n行开始显示"><a href="#n-从第n行开始显示" class="headerlink" title="+n-从第n行开始显示"></a>+n-从第n行开始显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n的索引是从1开始的</span></span><br><span class="line">more +3 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="n-每屏显示n行"><a href="#n-每屏显示n行" class="headerlink" title="-n-每屏显示n行"></a>-n-每屏显示n行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每屏显示4行，可结合空格进行翻页</span></span><br><span class="line">more -4 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="pattern-搜寻字串"><a href="#pattern-搜寻字串" class="headerlink" title="+/pattern-搜寻字串"></a>+/pattern-搜寻字串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找第一个出现"liu"字符串的行，并从该处前两行开始显示输出</span></span><br><span class="line"><span class="comment"># 输出第一行会显示...skipping</span></span><br><span class="line">more +/liu test.log</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>第一次出现字符串</li><li>出现字符串的前两行</li></ul></div><hr><h4 id="c-清屏显示"><a href="#c-清屏显示" class="headerlink" title="-c-清屏显示"></a>-c-清屏显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不使用参数的情况下，如果文件行数大于屏幕可以显示的数目，也会清屏显示</span></span><br><span class="line">more test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用了-n选项，仍然符合上面的规则，如果-n小于屏幕可以显示的数目</span></span><br><span class="line">more -4 test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c参数之后，先清屏之后再显示(不管指定的每页显示行数为多少)</span></span><br><span class="line">more -c -4 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="d-提示信息"><a href="#d-提示信息" class="headerlink" title="-d-提示信息"></a>-d-提示信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">more -d test.log</span><br><span class="line"><span class="comment"># 在显示文本下方显示</span></span><br><span class="line"><span class="comment">#  --More--(0%)[Press space to continue, 'q' to quit.</span></span><br><span class="line"><span class="comment"># 按错命令按键则会出现</span></span><br><span class="line"><span class="comment"># [Press 'h' for instructions.]</span></span><br></pre></td></tr></table></figure><hr><h4 id="f-计算实际行数"><a href="#f-计算实际行数" class="headerlink" title="-f-计算实际行数"></a>-f-计算实际行数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每页显示30行(实际行数)</span></span><br><span class="line"><span class="comment"># 如果不加-f参数的话(也就是默认情况下)显示的不是实际行数(一行太长，换行会当2行算)</span></span><br><span class="line">more -f -30 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="p-清屏换页"><a href="#p-清屏换页" class="headerlink" title="-p-清屏换页"></a>-p-清屏换页</h4><p>通过清屏来换页，而不是通过滚动页面(在同一个页面，内容增加，右侧出现滚动滑块)，和<code>-c</code>参数基本是一样的:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个结合翻页很好用，只会在页面顶端的4行显示内容，不会叠加在同一个页面</span></span><br><span class="line">more -p  -4 test.log</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p><code>less</code>工具也是<strong>对文件或其它输出进行分页显示的工具</strong>，应该说是linux<strong>正统查看文件内容的工具，功能极其强大</strong>。<code>less</code>的用法比起<code>more</code>更加的有弹性:</p><ul><li>在<code>more</code>的时候，我们并没有办法向前面翻，只能往后面看(b或者ctrl+b只是向前翻页，不能像less一样单行单行的向前滚动显示)，但若使用了 <code>less</code>，就可以使用<code>pageup</code>、<code>pagedown</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</li><li>在 <code>less</code> 里头可以拥有<strong>更多的搜索功能，不止可以向下搜，也可以向上搜</strong>，<code>more</code>只能搜素后面的，输出的内容不在搜索范围内</li></ul><h3 id="less命令格式"><a href="#less命令格式" class="headerlink" title="less命令格式"></a>less命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  less [参数]  文件</span><br></pre></td></tr></table></figure><hr><h4 id="less-options说明"><a href="#less-options说明" class="headerlink" title="less options说明"></a>less options说明</h4><p>less的功能非常强大，包含很多方面，对应的参数也非常堵，需要的可以使用<code>less --help</code>查看，这里只列出常用的参数和功能：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-m</code></td><td>显示类似more命令的百分比</td></tr><tr><td><code>-N</code></td><td>显示每行的行号</td></tr><tr><td><code>-M</code></td><td><strong>显法读取文件的百分比、行区间及总行数</strong></td></tr><tr><td><code>-e</code></td><td><strong>当文件显示结束后，自动退出</strong></td></tr><tr><td><code>-S</code></td><td><strong>Chop long lines(在单行显示较长的内容，而不换行显示)</strong></td></tr><tr><td><code>-x &lt;数字&gt;</code></td><td><strong>将TAB字符显示为指定个数的空格字符</strong></td></tr></tbody></table><hr><h4 id="less常用操作命令"><a href="#less常用操作命令" class="headerlink" title="less常用操作命令"></a>less常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>enter(回车)</code></td><td>向下移动一行</td></tr><tr><td><code>y</code></td><td>向上移动一行</td></tr><tr><td><code>pagedown</code></td><td>向下移动一行</td></tr><tr><td><code>pageup</code></td><td>向上移动一行</td></tr><tr><td><code>b</code></td><td>向上滚动一屏</td></tr><tr><td><code>空格键</code></td><td>向下滚动一屏</td></tr><tr><td><code>g</code></td><td><strong>跳到第一行</strong></td></tr><tr><td><code>G</code></td><td><strong>跳到最后一行</strong></td></tr><tr><td><code>p n%</code></td><td><strong>跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示</strong></td></tr><tr><td><code>w n</code></td><td><strong>可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的n是6，那就从第7行显示</strong></td></tr><tr><td><code>!命令</code></td><td>调用Shell，并执行命令</td></tr><tr><td><code>q</code></td><td>退出less</td></tr></tbody></table><hr><h2 id="more和less的区别"><a href="#more和less的区别" class="headerlink" title="more和less的区别"></a>more和less的区别</h2><ul><li>在<code>more</code>的时候，我们并没有办法向前面翻，只能往后面看(b或者ctrl+b只是向前翻页，不能像less一样单行单行的向前滚动显示)，但若使用了 <code>less</code>，就可以使用<code>pageup</code>、<code>pagedown</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</li><li>在 <code>less</code> 里头可以拥有<strong>更多的搜索功能，不止可以向下搜，也可以向上搜</strong>，<code>more</code>只能搜素后面的，输出的内容不在搜索范围内</li><li><code>less</code>使用退出之后屏幕<strong>不会留下显示的内容</strong>，而<code>more</code>退出之后屏幕<strong>会留下当前显示的内容</strong></li><li><code>less</code>不必读整个文件，加载速度会比<code>more</code>更快</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/aijianshi/p/5750911.html" target="_blank" rel="noopener">Linux中more和less命令用法</a></li><li><a href="http://www.cnblogs.com/xqzt/p/5414814.html" target="_blank" rel="noopener">每天一个linux命令(12):more命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成-Python系列之setup.py</title>
      <link href="/posts/33963.html"/>
      <url>/posts/33963.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/maociping/p/6633948.html" target="_blank" rel="noopener">python的构建工具setup.py</a></li><li><a href="https://lingxiankong.github.io/2013-12-23-python-setup.html" target="_blank" rel="noopener">关于python中的setup.py</a></li><li><a href="https://blog.csdn.net/langb2014/article/details/53114341" target="_blank" rel="noopener">python的setup问题</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫之Selenium-自动化测试</title>
      <link href="/posts/50111.html"/>
      <url>/posts/50111.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章将自己在使用Selenium过程中遇到的好文章进行了汇总和整理，便于后续继续使用这个工具时能尽快找到好的参考，节省时间！</p></div><a id="more"></a><h2 id="Selenium简介"><a href="#Selenium简介" class="headerlink" title="Selenium简介"></a>Selenium简介</h2><p>selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。</p><p>selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。</p><hr><h2 id="selenium用法"><a href="#selenium用法" class="headerlink" title="selenium用法"></a>selenium用法</h2><p>用python写爬虫的时候，主要用的是selenium的Webdriver，我们可以通过下面的方式先看看Selenium.Webdriver支持哪些浏览器</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193320778-188010556.png" alt></p><p>执行结果如下，从结果中我们也可以看出基本山支持了常见的所有浏览器：</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193414684-1032464838.png" alt></p><p>这里要说一下比较重要的PhantomJS,PhantomJS是一个而基于WebKit的服务端JavaScript API,支持Web而不需要浏览器支持，其快速、原生支持各种Web标准：Dom处理，CSS选择器，JSON等等。PhantomJS可以用用于页面自动化、网络监测、网页截屏，以及无界面测试</p><h3 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h3><p>上面我们知道了selenium支持很多的浏览器，但是如果想要声明并调用浏览器则需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 打开浏览器，注意需要提前下载浏览器驱动以及将其写入环境变量</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br></pre></td></tr></table></figure><p>这里只写了两个例子，当然了其他的支持的浏览器都可以通过这种方式调用。</p><p><strong>可能遇到的问题</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\selenium\webdriver\common\service.py"</span>, line <span class="number">76</span>, <span class="keyword">in</span> start</span><br><span class="line">    stdin=PIPE)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">769</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    restore_signals, start_new_session)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">1172</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">    startupinfo)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。</span><br></pre></td></tr></table></figure><p></p><p><strong>这是因为没有将浏览器驱动以及没有将浏览器驱动添加到环境变量</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 驱动下载地址</span></span><br><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载对应的chrome版本之后将压缩包解压，我下载的是chromedriver_win32.zip</span></span><br><span class="line"><span class="comment"># 发现32位的也能用，关键是只提供了32位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压上述包，然后将exe文件写入环境变量，可将exe文件放在C:\Program Files (x86)\Google\Chrome\Application目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量(可能需要重启电脑才会生效)之后直接输入</span></span><br><span class="line">chromedriver.exe</span><br><span class="line">Starting ChromeDriver <span class="number">72.0</span><span class="number">.3626</span><span class="number">.69</span> (<span class="number">3</span>c16f8a135abc0d4da2dff33804db79b849a7c38) on port <span class="number">9515</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver <span class="keyword">and</span> related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网站</span></span><br><span class="line">browser.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 输入网站源码</span></span><br><span class="line">print(browser.page_source)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>上述代码运行后，会自动打开Chrome浏览器，并登陆百度打印百度首页的源代码，然后关闭浏览器</p><hr><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="单个元素查找"><a href="#单个元素查找" class="headerlink" title="单个元素查找"></a>单个元素查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 使用id查找</span></span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">"q"</span>)</span><br><span class="line"><span class="comment"># 使用css_selector查找</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">"#q"</span>)</span><br><span class="line"><span class="comment"># 使用xpath查找</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line"></span><br><span class="line">print(input_first)</span><br><span class="line">print(input_second)</span><br><span class="line">print(input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>这里我们通过三种不同的方式去获取响应的元素，第一种是通过id的方式，第二个中是CSS选择器，第三种是xpath选择器，结果都是相同的。<br>结果如下：</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193535200-558486822.png" alt></p><p><strong>这里列举一下常用的查找元素方法</strong>：</p><ul><li><code>find_element_by_name</code></li><li><code>find_element_by_id</code></li><li><code>find_element_by_xpath</code></li><li><code>find_element_by_link_text</code></li><li><code>find_element_by_partial_link_text</code></li><li><code>find_element_by_tag_name</code></li><li><code>find_element_by_class_name</code></li><li><code>find_element_by_css_selector</code></li></ul><p>下面这种方式是比较通用的一种方式：这里需要记住By模块所以需要导入<code>from selenium.webdriver.common.by import By</code><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 设置查找的方法以及查找的对象</span></span><br><span class="line">input_first = browser.find_element(By.ID,<span class="string">"q"</span>)</span><br><span class="line"></span><br><span class="line">print(input_first)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p></p><p>当然这种方法和上述的方式是通用的，<code>browser.find_element(By.ID,&quot;q&quot;)</code>这里<code>By.ID</code>中的ID可以替换为其他几个</p><hr><h4 id="多个元素查找"><a href="#多个元素查找" class="headerlink" title="多个元素查找"></a>多个元素查找</h4><p>其实多个元素和单个元素的区别，举个例子：<code>find_elements</code>,单个元素是<code>find_element</code>,其他使用上没什么区别，通过其中的一个例子演示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 执行查找</span></span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通用的方法实现</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">lis = browser.find_elements(By.CSS_SELECTOR,<span class="string">'.service-bd li'</span>)</span><br><span class="line"></span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p></p><p>这样获得就是一个列表</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193737497-369795287.png" alt></p><p><strong>同样的在单个元素中查找的方法在多个元素查找中同样存在</strong>：</p><ul><li><code>find_elements_by_name</code></li><li><code>find_elements_by_id</code></li><li><code>find_elements_by_xpath</code></li><li><code>find_elements_by_link_text</code></li><li><code>find_elements_by_partial_link_text</code></li><li><code>find_elements_by_tag_name</code></li><li><code>find_elements_by_class_name</code></li><li><code>find_elements_by_css_selector</code></li></ul><hr><h3 id="元素交互操作"><a href="#元素交互操作" class="headerlink" title="元素交互操作"></a>元素交互操作</h3><p>对于获取的元素调用交互方法:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"></span><br><span class="line">input_str = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line"><span class="comment"># 发送信息</span></span><br><span class="line">input_str.send_keys(<span class="string">"ipad"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">input_str.clear()</span><br><span class="line"></span><br><span class="line">input_str.send_keys(<span class="string">"MakBook pro"</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line"></span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure><p></p><p><strong>运行的结果可以看出程序会自动打开Chrome浏览器并打开淘宝输入ipad,然后删除，重新输入MakBook pro，并点击搜索</strong></p><p><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">Selenium所有的api文档</a></p><p><strong>交互动作</strong></p><p><strong>将动作附加到动作链中串行执行</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">"http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable"</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"></span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line"></span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p></p><p><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">更多操作参考</a></p><hr><h3 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h3><p>这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，下面的例子是 <strong>通过登录知乎然后通过js翻到页面底部，并弹框提示</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.zhihu.com/explore"</span>)</span><br><span class="line"></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure><p></p><h4 id="获取元素属性-get-attribute-‘class’"><a href="#获取元素属性-get-attribute-‘class’" class="headerlink" title="获取元素属性-get_attribute(‘class’)"></a>获取元素属性-get_attribute(‘class’)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">logo = browser.find_element_by_id(<span class="string">'zh-top-link-logo'</span>)</span><br><span class="line"></span><br><span class="line">print(logo)</span><br><span class="line">print(logo.get_attribute(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure><hr><h4 id="获取文本值-text"><a href="#获取文本值-text" class="headerlink" title="获取文本值-text"></a>获取文本值-text</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.text)</span><br></pre></td></tr></table></figure><hr><h4 id="获取ID、位置、标签名"><a href="#获取ID、位置、标签名" class="headerlink" title="获取ID、位置、标签名"></a>获取ID、位置、标签名</h4><ul><li><code>id</code></li><li><code>location</code></li><li><code>tag_name</code></li><li><code>size</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.id)</span><br><span class="line">print(input.location)</span><br><span class="line">print(input.tag_name)</span><br><span class="line">print(input.size)</span><br></pre></td></tr></table></figure><hr><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p>在很多网页中都是有Frame标签，所以我们爬取数据的时候就涉及到切入到frame中以及切出来的问题，通过下面的例子演示<br>这里常用的是<code>switch_to.from()</code>和<code>switch_to.parent_frame()</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">print(source)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'NO LOGO'</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0</p><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>到了一定的时间发现元素还没有加载，则继续等待我们指定的时间，如果超过了我们指定的时间还没有加载就会抛出异常，如果没有需要等待的时候就已经加载完毕就会立即执行<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 设置隐式等待</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h4><p>指定一个等待条件，并且指定一个最长等待时间，会在这个时间内进行判断是否满足等待条件，如果成立就会立即返回，如果不成立，就会一直等待，直到等待你指定的最长等待时间，如果还是不满足，就会抛出异常，如果满足了就会正常返回</p><p><strong>常用的判断条件</strong>：</p><ul><li><code>title_is</code> 标题是某内容</li><li><code>title_contains</code> 标题包含某内容</li><li><code>presence_of_element_located</code> 元素加载出，传入定位元组，如(By.ID, ‘p’)</li><li><code>visibility_of_element_located</code> 元素可见，传入定位元组</li><li><code>visibility_of</code> 可见，传入元素对象</li><li><code>presence_of_all_elements_located</code> 所有元素加载出</li><li><code>text_to_be_present_in_element</code> 某个元素文本包含某文字</li><li><code>text_to_be_present_in_element_value</code> 某个元素值包含某文字</li><li><code>frame_to_be_available_and_switch_to_it</code> frame加载并切换</li><li><code>invisibility_of_element_located</code> 元素不可见</li><li><code>element_to_be_clickable</code> 元素可点击</li><li><code>staleness_of</code> 判断一个元素是否仍在DOM，可判断页面是否已经刷新</li><li><code>element_to_be_selected</code> 元素可选择，传元素对象</li><li><code>element_located_to_be_selected</code> 元素可选择，传入定位元组</li><li><code>element_selection_state_to_be</code> 传入元素对象以及状态，相等返回True，否则返回False</li><li><code>element_located_selection_state_to_be</code> 传入定位元组以及状态，相等返回True，否则返回False</li><li><code>alert_is_present</code> 是否出现Alert</li></ul><p>实例讲解，以来自<a href="https://www.cnblogs.com/yuuwee/p/6635652.html" target="_blank" rel="noopener">这篇文章</a>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"><span class="comment"># 定义等待时间，这是隐式等待，当隐式等待和显示等待都存在时，超时时间取二者中较大的，显示等待是sleep(10)这种</span></span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="comment"># 定义查找位置</span></span><br><span class="line">locator = (By.ID,<span class="string">'kw'</span>)</span><br><span class="line">driver.get(base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断title,返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.title_is(<span class="string">u"百度一下，你就知道"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断title，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.title_contains(<span class="string">u"百度一下"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被加到了dom树里，并不代表该元素一定可见，如果定位到就返回WebElement</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.presence_of_element_located((By.ID,<span class="string">'kw'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被添加到了dom里并且可见，可见代表元素可显示且宽和高都大于0</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of_element_located((By.ID,<span class="string">'su'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否可见，如果可见就返回这个元素</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of(driver.find_element(by=By.ID,value=<span class="string">'kw'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否至少有1个元素存在于dom树中，如果定位到就返回列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.presence_of_all_elements_located((By.CSS_SELECTOR,<span class="string">'.mnav'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否至少有一个元素在页面中可见，如果定位到就返回列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of_any_elements_located((By.CSS_SELECTOR,<span class="string">'.mnav'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定的元素中是否包含了预期的字符串，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.text_to_be_present_in_element((By.XPATH,<span class="string">"//*[@id='u1']/a[8]"</span>),<span class="string">u'设置'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定元素的属性值中是否包含了预期的字符串，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.text_to_be_present_in_element_value((By.CSS_SELECTOR,<span class="string">'#su'</span>),<span class="string">u'百度一下'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False，注意这里并没有一个frame可以切换进去</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.frame_to_be_available_and_switch_to_it(locator))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素在是否存在于dom或不可见,如果可见返回False,不可见返回这个元素，注意#swfEveryCookieWrap在此页面中是一个隐藏的元素</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.invisibility_of_element_located((By.CSS_SELECTOR,<span class="string">'#swfEveryCookieWrap'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素中是否可见并且是enable的，代表可点击</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_clickable((By.XPATH,<span class="string">"//*[@id='u1']/a[8]"</span>))).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='wrapper']/div[6]/a[1]"</span>).click()</span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_clickable((By.XPATH,<span class="string">"//*[@id='wrapper']/div[6]/a[1]"</span>))).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待某个元素从dom树中移除，这里没有找到合适的例子</span></span><br><span class="line"><span class="comment">#WebDriverWait(driver,10).until(EC.staleness_of(driver.find_element(By.ID,'su')))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被选中了,一般用在下拉列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_selected(driver.find_element(By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素的选中状态是否符合预期</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_selection_state_to_be(driver.find_element(By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>),<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素的选中状态是否符合预期</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_located_selection_state_to_be((By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>),<span class="keyword">True</span>))</span><br><span class="line">driver.find_element_by_xpath(<span class="string">".//*[@id='gxszButton']/a[1]"</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断页面上是否存在alert,如果有就切换到alert并返回alert的内容</span></span><br><span class="line">instance = WebDriverWait(driver,<span class="number">10</span>).until(EC.alert_is_present())</span><br><span class="line"><span class="keyword">print</span> instance.text</span><br><span class="line">instance.accept()</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>关于显式等待和隐式等待具体的讲解可以参考<a href="https://www.jianshu.com/p/bf27aad96614" target="_blank" rel="noopener">这篇文章</a></strong></li><li><strong><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions" target="_blank" rel="noopener">更多操作</a></strong>参考</li></ul><hr><h3 id="浏览器的前进和后退"><a href="#浏览器的前进和后退" class="headerlink" title="浏览器的前进和后退"></a>浏览器的前进和后退</h3><ul><li><code>back()</code></li><li><code>forward()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.python.org/'</span>)</span><br><span class="line"></span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><hr><h3 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h3><ul><li><code>get_cookies()</code></li><li><code>delete_all_cookes()</code></li><li><code>add_cookie()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'zhaofan'</span>&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure><hr><h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><ul><li>通过执行js命令实现新开选项卡<code>window.open()</code></li><li>不同的选项卡是存在列表里<code>browser.window_handles</code></li><li>通过<code>browser.window_handles[0]</code>就可以操作第一个选项卡</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line"></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常比较复杂，<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions" target="_blank" rel="noopener">官网的参考地址</a>，这里只进行简单的演示，查找一个不存在的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    print(<span class="string">'Time Out'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Element'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong>无界面模式浏览器</strong>：</p><blockquote><p>opt=webdriver.ChromeOptions()<br># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数<br>opt.set_headless()#无界面<br>self.driver=webdriver.Chrome(options=opt)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span>  webdriver</span><br><span class="line"><span class="keyword">import</span>  lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span>  etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span>  pymysql</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span>  WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span>  expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span>  By</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LagouSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        opt=webdriver.ChromeOptions()</span><br><span class="line">        <span class="comment"># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数</span></span><br><span class="line">        opt.set_headless()<span class="comment">#无界面</span></span><br><span class="line">        self.driver=webdriver.Chrome(options=opt)</span><br><span class="line">        self.url=<span class="string">"https://www.lagou.com/zhaopin/Python/"</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.driver.get(self.url)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            source = self.driver.page_source</span><br><span class="line">            <span class="comment">#此句话大致意思，执行driver 时间不超过20s 什么时候加载到xpath定位的位置神魔时候停止开始执行页面 内容爬去</span></span><br><span class="line">            WebDriverWait(driver=self.driver,timeout=<span class="number">20</span>).until(EC.presence_of_all_elements_located(By.XPATH,<span class="string">'//*[@id="s_position_list"]/div[2]/div/a[6]'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># WebDriverWait(driver=self.driver, timeout=20).until(</span></span><br><span class="line">            <span class="comment">#     EC.presence_of_element_located((By.XPATH, '//*[@id="s_position_list"]/div[2]/div/a[6]'))</span></span><br><span class="line">            <span class="comment"># )</span></span><br><span class="line">            self.parse_list_page(source)</span><br><span class="line">            <span class="comment"># 点“下一页”</span></span><br><span class="line">            next_btn=self.driver.find_element_by_xpath(  <span class="string">'//*[@id="s_position_list"]/div[2]/div/a[6]'</span>)</span><br><span class="line">            <span class="comment"># 提取下一页的按钮，注意class的值中有空格不可用。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"pager_next_disabled"</span> <span class="keyword">in</span> next_btn.get_attribute(<span class="string">"class"</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_btn.click()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># next_btn = self.driver.find_element_by_xpath(</span></span><br><span class="line">            <span class="comment">#      '//*[@id="s_position_list"]/div[2]/div/a[6]')</span></span><br><span class="line">            <span class="comment"># if "pager_next_disabled" in next_btn.get_attribute("class"):</span></span><br><span class="line">            <span class="comment">#     break</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     next_btn.click()</span></span><br><span class="line">            <span class="comment"># time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># source=self.driver.page_source</span></span><br><span class="line">        <span class="comment"># #print(source)</span></span><br><span class="line">        <span class="comment"># self.parse_list_page(source)</span></span><br><span class="line">    <span class="comment">#职位url列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_list_page</span><span class="params">(self,source)</span>:</span></span><br><span class="line">        <span class="comment">#t通过etree调用xpath</span></span><br><span class="line">        html=etree.HTML(source)</span><br><span class="line">        links=html.xpath(<span class="string">'//*[@id="s_position_list"]/ul/li/div[1]/div[1]/div[1]/a/@href'</span>)</span><br><span class="line">        <span class="keyword">for</span>  link <span class="keyword">in</span> links:</span><br><span class="line">            self.request_detail_page(link)</span><br><span class="line">            <span class="comment"># print(link)</span></span><br><span class="line">            <span class="comment">#time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行提取的url</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_detail_page</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        <span class="comment">#self.driver.get(url)</span></span><br><span class="line">        <span class="comment">#打开新的页面</span></span><br><span class="line">        self.driver.execute_script(<span class="string">"window.open('%s')"</span>%url)</span><br><span class="line">        <span class="comment">#切换句柄进入新打开的页面</span></span><br><span class="line">        self.driver.switch_to.window((self.driver.window_handles[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># self.driver.execute_script("window.open('%s')" % url)</span></span><br><span class="line">        <span class="comment"># self.driver.switch_to.window(self.driver.window_handles[1])</span></span><br><span class="line">        <span class="comment">#加载出来工作名开始爬取</span></span><br><span class="line">        WebDriverWait(driver=self.driver, timeout=<span class="number">20</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">"//div[@class='job-name']/span[@class='name']"</span>)) )</span><br><span class="line"></span><br><span class="line">        source=self.driver.page_source</span><br><span class="line">        self.parse_detail_page(source)</span><br><span class="line">        <span class="comment"># 关闭当前详情页，并且切换到列表页</span></span><br><span class="line">        self.driver.close()</span><br><span class="line">        self.driver.switch_to.window(self.driver.window_handles[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#self.parse_list_page(source)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#提取具体信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_detail_page</span><span class="params">(self,source)</span>:</span></span><br><span class="line">        html=etree.HTML(source)</span><br><span class="line">        positionName=html.xpath(<span class="string">"//div[@class='position-head']/div/div[1]/div/span/text()"</span>)[<span class="number">0</span>]</span><br><span class="line">        job_request_spans=html.xpath(<span class="string">"//div[@class='position-head']/div/div[1]/dd/p[1]/span"</span>)</span><br><span class="line">        salary=job_request_spans[<span class="number">0</span>].xpath(<span class="string">".//text()"</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        city=job_request_spans[<span class="number">1</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="comment">#city = re.match(r'&lt;span class="xh-highlight"&gt;/(.*?) /&lt;/span&gt;',city)</span></span><br><span class="line">        city = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, city)<span class="comment">#此处将"/"替换为空""</span></span><br><span class="line">        work_years = job_request_spans[<span class="number">2</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        work_years = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, work_years)</span><br><span class="line">        education = job_request_spans[<span class="number">3</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        education = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, education)</span><br><span class="line">        content = <span class="string">""</span>.join(html.xpath(<span class="string">"//dd[@class='job_bt']//text()"</span>)).strip()</span><br><span class="line">        <span class="comment">#print(positionName)</span></span><br><span class="line">        <span class="comment">#mysql=MySQLPipeline()</span></span><br><span class="line">        <span class="comment">#mysql.process_item(positionName,salary,city,work_years,education,content)</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        语法：  'sep'.join(seq)</span></span><br><span class="line"><span class="string">        参数说明</span></span><br><span class="line"><span class="string">        sep：分隔符。可以为空</span></span><br><span class="line"><span class="string">        seq：要连接的元素序列、字符串、元组、字典</span></span><br><span class="line"><span class="string">        上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串</span></span><br><span class="line"><span class="string">        返回值：返回一个以分隔符sep连接各个元素后生成的字符串</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">"root"</span>,db=<span class="string">"lagou"</span>, charset=<span class="string">'utf8'</span>)</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self,positionName,salary,city,work_years,education,content)</span>:</span></span><br><span class="line">        insert_sql = <span class="string">'''</span></span><br><span class="line"><span class="string">                    insert into lagou_table(positionName,salary,city,work_years,education,content)</span></span><br><span class="line"><span class="string">                    values(%s,%s,%s,%s,%s,%s)</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">        self.cursor.execute(insert_sql,(positionName,salary,city,work_years,education,content))</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span> <span class="comment">#TypeError: close_spider() takes 1 positional argument but 2 were given</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    spider=LagouSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/zhaof/p/6953241.html" target="_blank" rel="noopener">本文框架来源</a></li><li><a href="https://www.cnblogs.com/yuuwee/p/6635652.html" target="_blank" rel="noopener">显示等待WebDriverWait与条件判断expected_conditions实例</a></li><li><a href="https://blog.csdn.net/work_you_will_see/article/details/84638750" target="_blank" rel="noopener">实战项目来源</a></li><li><a href="https://www.jianshu.com/p/bf27aad96614" target="_blank" rel="noopener">Selenium中的“显示等待”和“隐式等待”</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之logging-日志</title>
      <link href="/posts/56982.html"/>
      <url>/posts/56982.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章依照<a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">这篇博客</a>对Python的常用模块logging进行了学习，主要学习了<code>日志的作用</code>、<code>不同开发环境设置不同的日志输出</code>、<code>使用logging模块的日志级别函数直接记录日志</code>；也学习了logging模块的<strong>高级用法</strong>，包括<strong>使用logging模块的四大组件进行日志记录(主要用于满足多种需求，如将结果同时输出到文件和屏幕)</strong>、配置logging的几种方式、向日志输出上下文信息等；最后也总结了一些<strong>实战技巧</strong>。</p></div><a id="more"></a><h2 id="日志相关概念"><a href="#日志相关概念" class="headerlink" title="日志相关概念"></a>日志相关概念</h2><p>日志是一种可以<strong>追踪某些软件运行时所发生事件的方法</strong>。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有<strong>重要性</strong>的概念，这个重要性也可以被称为严重性级别（level）。</p><h3 id="日志的作用"><a href="#日志的作用" class="headerlink" title="日志的作用"></a>日志的作用</h3><p>通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。<br><strong>简单来讲就是</strong>，我们通过记录和分析日志可以了解一个系统或软件程序<strong>运行情况是否正常</strong>，也可以<strong>在应用程序出现故障时快速定位问题</strong>。比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。日志的作用可以<strong>简单总结</strong>为以下3点：</p><ul><li><strong>程序调试</strong></li><li><strong>了解软件程序运行情况，是否正常</strong></li><li><strong>软件程序运行故障分析与问题定位</strong></li></ul><p>如果应用的日志信息足够详细和丰富，还可以<strong>用来做用户行为分析</strong>，如：分析用户的操作行为、类型喜好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。</p><hr><h3 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h3><p>我们先来思考下下面的两个问题：</p><ul><li>作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？</li><li>作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？</li></ul><p>在<strong>软件开发阶段或部署开发环境</strong>时，为了<strong>尽可能详细</strong>的查看应用程序的运行状态来<strong>保证上线后的稳定性</strong>，我们可能<strong>需要把该应用程序所有的运行日志全部记录下来进行分析</strong>，<u>这是非常耗费机器性能的</u>。当<strong>应用程序正式发布或在生产环境部署应用程序</strong>时，我们通常<strong>只需要记录应用程序的异常信息、错误信息</strong>等，这样既可以减小服务器的<code>I/O</code>压力，也可以避免我们在排查故障时被淹没在日志的海洋里。那么，<mark><strong>怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？</strong>这就是<strong>日志等级</strong>的作用了，我们<strong>通过配置文件指定我们需要的日志等级就可以了</strong></mark>。</p><p>不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级(具体的级别高低在后面会有讲解)：</p><ul><li>DEBUG</li><li>INFO</li><li>NOTICE</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>ALERT</li><li>EMERGENCY</li></ul><hr><h3 id="日志字段信息与日志格式"><a href="#日志字段信息与日志格式" class="headerlink" title="日志字段信息与日志格式"></a>日志字段信息与日志格式</h3><p>本节开始问题提到过，<strong>一条日志信息对应的是一个事件的发生</strong>，而<strong>一个事件通常需要包括以下几个内容</strong>：</p><ul><li>事件发生<strong>时间</strong></li><li>事件发生<strong>位置</strong></li><li>事件的<strong>严重程度–日志级别</strong></li><li>事件<strong>内容</strong></li></ul><p>上面这些都是一条日志记录中可能包含的字段信息，当然<strong>还可以包括</strong>一些其他信息，如<code>进程ID</code>、<code>进程名称</code>、<code>线程ID</code>、<code>线程名称</code>等。<strong>日志格式</strong>就是用来定义一条日志记录中包含哪些字段的，且日志格式通常都是可以自定义的。</p><div class="note info"><p>输出一条日志时，<strong>日志内容</strong>和<strong>日志级别</strong>是<strong>需要开发人员明确指定的(必须的)</strong>。对于而其它字段信息，只需要是否显示在日志中就可以了。</p></div><h3 id="日志功能的实现"><a href="#日志功能的实现" class="headerlink" title="日志功能的实现"></a>日志功能的实现</h3><p>几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：<code>log4j</code>，<code>log4php</code>等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块–<code>logging</code>。</p><hr><p><br></p><h2 id="logging模块简介"><a href="#logging模块简介" class="headerlink" title="logging模块简介"></a>logging模块简介</h2><p><code>logging</code>模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。<code>logging</code>模块是Python的一个<strong>标准库模块</strong>，<strong>由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能</strong>。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><h3 id="logging模块的日志级别"><a href="#logging模块的日志级别" class="headerlink" title="logging模块的日志级别"></a>logging模块的日志级别</h3><p>logging模块默认定义了以下几个日志等级，它<strong>允许开发人员自定义其他日志级别</strong>，但是这是<strong>不被推荐的</strong>，尤其是在开发供别人使用的库时，因为这<strong>会导致日志级别的混乱</strong>。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>日志等级</th><th>数值</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>10</td><td><strong>最详细</strong>的日志信息，典型应用场景是<strong>问题诊断</strong></td></tr><tr><td>INFO</td><td>20</td><td>信息详细程度仅次于DEBUG，通常<strong>只记录关键节点信息</strong>，用于<strong>确认一切都是按照我们预期的那样进行工作</strong></td></tr><tr><td>WARNING</td><td>30</td><td>当<strong>某些不期望的事情发生</strong>时记录的信息（如，磁盘可用空间较低），但是<strong>此时应用程序还是正常运行</strong>的</td></tr><tr><td>ERROR</td><td>40</td><td>由于一个更严重的问题<strong>导致某些功能不能正常运行</strong>时记录的信息</td></tr><tr><td>CRITICAL</td><td>50</td><td>当发生严重错误，<strong>导致应用程序不能继续运行</strong>时记录的信息</td></tr></tbody></table><div class="note info"><ul><li>上面列表中的<strong>日志等级是从上到下依次升高(按照数值的大小排序)</strong>的，即：<code>DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</code>，而<strong>日志的信息量是依次减少的</strong>；</li><li><p><code>logging</code>模块<strong>可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃</strong>；</p></li><li><p><strong>开发应用程序或部署开发环境</strong>时，可以使用<code>DEBUG</code>或<code>INFO</code>级别的日志获取<strong>尽可能详细</strong>的日志信息来进行开发或部署调试；</p></li><li><strong>应用上线或部署生产环境</strong>时，应该使用<code>WARNING</code>或<code>ERROR</code>或<code>CRITICAL</code>级别的日志来降低机器的<code>I/O</code>压力和提高获取错误日志信息的效率；</li><li><strong>日志级别的指定通常都是在应用程序的配置文件中进行的</strong>。</li></ul></div><hr><h3 id="logging模块的使用方式介绍"><a href="#logging模块的使用方式介绍" class="headerlink" title="logging模块的使用方式介绍"></a>logging模块的使用方式介绍</h3><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是<strong>使用logging提供的日志级别的函数</strong></li><li>第二种方式是<strong>使用Logging日志系统的四大组件</strong></li></ul><p>其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已</p><h4 id="logging模块定义的日志级别的常用函数"><a href="#logging模块定义的日志级别的常用函数" class="headerlink" title="logging模块定义的日志级别的常用函数:"></a>logging模块定义的日志级别的常用函数:</h4><table><tr><th width="40%">函数</th><th width="60%">说明</th></tr><tr><td><code>logging.debug(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>DEBUG</code>的日志记录</td></tr><tr><td><code>logging.info(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>INFO</code>的日志记录</td></tr><tr><td><code>logging.warning(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>WARNING</code>的日志记录</td></tr><tr><td><code>logging.error(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>ERROR</code>的日志记录</td></tr><tr><td><code>logging.critical(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>CRITICAL</code>的日志记录</td></tr><tr><td><code>logging.log(level, *args, **kwargs)</code></td><td>创建一条级别为<code>level</code>的日志记录</td></tr><tr><td><code>logging.basicConfig(**kwargs)</code></td><td>对<code>root logger</code>进行一次性配置</td></tr></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定<code>要记录的日志级别</code>、<code>日志格式</code>、<code>日志输出位置</code>、<code>日志文件的打开模式</code>等信息，<strong>其他几个都是用于记录各个级别日志的函数</strong>。</p><hr><h4 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h4><table><tr><th width="20%">组件</th><th width="80%">说明</th></tr><tr><td><code>loggers</code></td><td>提供应用程序代码直接使用的接口</td></tr><tr><td><code>handlers</code></td><td>用于将日志记录发送到指定的目的位置</td></tr><tr><td><code>filters</code></td><td>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）</td></tr><tr><td><code>formatters</code></td><td>用于控制日志信息的最终输出格式</td></tr></table><div class="note info"><p>logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。</p></div><hr><p><br></p><h2 id="使用日志级别函数记录日志"><a href="#使用日志级别函数记录日志" class="headerlink" title="使用日志级别函数记录日志"></a>使用日志级别函数记录日志</h2><p>回顾下前面提到的<strong>几个重要信息</strong>：</p><ul><li>可以通过logging模块定义的日志级别方法去完成简单的日志记录</li><li><strong>只有级别大于或等于日志记录器指定级别的日志记录才会被输出，小于该级别的日志记录将会被丢弃</strong></li></ul><h3 id="最简单的日志输出"><a href="#最简单的日志输出" class="headerlink" title="最简单的日志输出"></a>最简单的日志输出</h3><p><strong>使用各种具体级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>也可以使用统一设置级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.log(logging.DEBUG, <span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.log(logging.INFO, <span class="string">"This is a info log."</span>)</span><br><span class="line">logging.log(logging.WARNING, <span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.log(logging.ERROR, <span class="string">"This is a error log."</span>)</span><br><span class="line">logging.log(logging.CRITICAL, <span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br><span class="line">================================</span><br><span class="line">WARNING:root:This <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:This <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:This <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><p>第二种写法显然没有第一种写法简单，以后还是使用第一种写法吧</p><h3 id="简单日志输出的结果分析"><a href="#简单日志输出的结果分析" class="headerlink" title="简单日志输出的结果分析"></a>简单日志输出的结果分析</h3><h4 id="为什么前面两条日志没有被打印出来？"><a href="#为什么前面两条日志没有被打印出来？" class="headerlink" title="为什么前面两条日志没有被打印出来？"></a>为什么前面两条日志没有被打印出来？</h4><p>这是因为logging模块提供的日志记录函数所使用的日志器设置的日志级别是<code>WARNING</code>(<strong>logging的默认日志级别是warning</strong>)，因此只有<code>WARNING</code>级别的日志记录以及<strong>大于等于</strong>它的<code>ERROR</code>和<code>CRITICAL</code>级别的日志记录<strong>被输出</strong>了，而<strong>小于</strong>它的<code>DEBUG</code>和<code>INFO</code>级别的日志记录<strong>被丢弃</strong>了。</p><hr><h4 id="日志信息中各字段含义？为什么会这样输出？"><a href="#日志信息中各字段含义？为什么会这样输出？" class="headerlink" title="日志信息中各字段含义？为什么会这样输出？"></a>日志信息中各字段含义？为什么会这样输出？</h4><p>上面输出结果中每行日志记录的各个字段含义分别是：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志级别:日志器名称:日志内容</span><br></pre></td></tr></table></figure><p></p><p>之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器<strong>设置的日志格式默认是<code>BASIC_FORMAT</code></strong>，其值为：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="如果将日志记录输出到文件中，而不是打印到控制台？"><a href="#如果将日志记录输出到文件中，而不是打印到控制台？" class="headerlink" title="如果将日志记录输出到文件中，而不是打印到控制台？"></a>如果将日志记录输出到文件中，而不是打印到控制台？</h4><p>因为在logging模块提供的日志记录函数所使用的日志器设置的处理器所<strong>指定的日志输出位置默认为:<code>sys.stderr</code>.</strong></p><hr><h4 id="我是怎么知道这些的？"><a href="#我是怎么知道这些的？" class="headerlink" title="我是怎么知道这些的？"></a>我是怎么知道这些的？</h4><p><strong>查看这些日志记录函数的实现代码</strong>，可以发现：当我们<strong>没有提供任何配置信息的时候</strong>，这些函数都会去调用<code>logging.basicConfig(**kwargs)</code>方法，且不会向该方法传递任何参数。继续<strong>查看<code>basicConfig()</code>方法的代码</strong>就可以找到上面这些问题的答案了。</p><p><strong>查看源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先导入模块</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">help(logging.basicConfig)</span><br><span class="line"></span><br><span class="line">The default behaviour <span class="keyword">is</span> to create a StreamHandler which writes to sys.stderr, set a formatter using the BASIC_FORMAT format string, <span class="keyword">and</span> add the handler to the root logger.</span><br><span class="line"></span><br><span class="line">BASIC_FORMAT = <span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="怎么修改这些默认设置呢？"><a href="#怎么修改这些默认设置呢？" class="headerlink" title="怎么修改这些默认设置呢？"></a>怎么修改这些默认设置呢？</h4><p>其实很简单，在我们<strong>调用上面这些日志记录函数之前</strong>，<strong>手动调用一下<code>basicConfig()</code>方法</strong>，把我们<strong>想设置的内容以参数的形式传递进去就可以了</strong>。</p><hr><h3 id="logging-basicConfig-函数说明"><a href="#logging-basicConfig-函数说明" class="headerlink" title="logging.basicConfig()函数说明"></a>logging.basicConfig()函数说明</h3><p>经过上述对简单日志输出的结果分析，发现如果我们想修改输出的信息(默认设置)就需要在调用日志记录函数之前，手动调用一下<code>basicConfig()</code>方法，所以这里来对<code>logging.basicConfig()</code>函数进行一定的学习。该方法用于为logging日志系统做一些基本配置，方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure><p></p><p><strong>该函数可接收的关键字参数</strong>如下：</p><table><tr><th width="20%">参数名称</th><th width="80%">描述</th></tr><tr><td><code>filename</code></td><td><strong>指定日志输出目标文件的文件名</strong>，指定该设置项后日志信息就不会被输出到控制台了</td></tr><tr><td><code>filemode</code></td><td>指定日志文件的打开模式，默认为<code>a</code>。需要注意的是，<strong>该选项要在filename指定时才有效</strong></td></tr><tr><td><code>format</code></td><td>指定日志格式字符串，即<strong>指定日志输出时所包含的字段信息以及它们的顺序</strong>。logging模块定义的格式字段下面会列出。</td></tr><tr><td><code>datefmt</code></td><td>指定日期/时间格式。需要注意的是，该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></td></tr><tr><td><code>level</code></td><td><strong>指定日志器的日志级别</strong></td></tr><tr><td><code>stream</code></td><td>指定日志输出目标stream，如<code>sys.stdout</code>、<code>sys.stderr</code>以及网络stream。需要说明的是，<strong>stream和filename不能同时提供，否则会引发 ValueError异常</strong></td></tr><tr><td><code>style</code></td><td>Python 3.2中新添加的配置项。<strong>指定format格式字符串的风格<strong>，可取值为<code>%</code>、<code>{</code>和<code>$</code>，默认为<code>%</code></strong></strong></td></tr><tr><td><code>handlers</code></td><td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：<strong>filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常</strong>。</td></tr></table><hr><h3 id="格式字符串字段-format"><a href="#格式字符串字段-format" class="headerlink" title="格式字符串字段(format)"></a>格式字符串字段(format)</h3><p>这里列出了<code>logging.basicConfig()</code>函数中的日志格式字符串(format)包含的字段：</p><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的<strong>时间</strong>–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–<strong>时间戳</strong>，就是当时调用<code>time.time()</code>函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的<strong>相对毫秒数</strong>（目前还不知道干嘛用的）</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的<strong>毫秒部分</strong></td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的<strong>文字形式的日志级别(‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’)</strong></td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的<strong>数字形式的日志级别(10, 20, 30, 40, 50)</strong></td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的<strong>日志器名称</strong>，<strong>默认是’root’，因为默认使用的是 rootLogger</strong></td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 <code>msg % args</code>计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td><strong>调用日志记录函数的源码文件的全路径</strong></td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的<strong>文件名部分，包含文件后缀</strong></td></tr><tr><td>module</td><td>%(module)s</td><td>filename的<strong>名称部分，不包含后缀</strong></td></tr><tr><td>lineno</td><td>%(lineno)d</td><td><strong>调用日志记录函数的源代码所在的行号</strong></td></tr><tr><td>funcName</td><td>%(funcName)s</td><td><strong>调用日志记录函数的函数名</strong></td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><div class="note info"><p>定义format的形式：<code>BASIC_FORMAT = &quot;%(levelname)s:%(name)s:%(message)s&quot;</code>这是官方的默认形式，不同字段间使用<code>:</code>分割，分割符可以自定义</p></div><hr><h3 id="自定义输出日志信息"><a href="#自定义输出日志信息" class="headerlink" title="自定义输出日志信息"></a>自定义输出日志信息</h3><h4 id="level-自定义日志级别"><a href="#level-自定义日志级别" class="headerlink" title="level-自定义日志级别"></a>level-自定义日志级别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"=====change level====="</span>)</span><br><span class="line"><span class="comment">## 自定义日志器的日志级别</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p>输出信息：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====change level=====</span><br><span class="line">DEBUG:root:this <span class="keyword">is</span> a debug log.</span><br><span class="line">INFO:root:this <span class="keyword">is</span> a info log.</span><br><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="filename-amp-format-设置日志输出目标文件和日志格式"><a href="#filename-amp-format-设置日志输出目标文件和日志格式" class="headerlink" title="filename &amp; format-设置日志输出目标文件和日志格式"></a>filename &amp; format-设置日志输出目标文件和日志格式</h4><ul><li><code>filename</code>：指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了</li><li><code>format</code>：指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。<ul><li><code>%(asctime)s</code>：日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</li><li><code>%(levelname)s</code>：该日志记录的文字形式的日志级别<code>(&#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;)</code></li><li><code>%(message)s</code>：日志记录的文本内容，通过 <code>msg % args</code>计算得到的</li></ul></li></ul><p><strong>示例代码如下</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"=====change out file and format====="</span>)</span><br><span class="line"><span class="comment"># 设置输出的format，中间的字段分隔符可以自定义</span></span><br><span class="line">LOG_FORMAT=<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line"><span class="comment"># 设置日志输出文件名以及format</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>,level=logging.DEBUG,format=LOG_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="datefmt-设置日期-时间格式"><a href="#datefmt-设置日期-时间格式" class="headerlink" title="datefmt-设置日期/时间格式"></a>datefmt-设置日期/时间格式</h4><ul><li>时间格式同<code>time.strftime()</code>，具体信息可以本文最后的补充信息</li><li>该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>从上面输出结果可以发现，前面几行是上一步生成的日志文件，下面几行是这步生成的文件，这是因为<strong>默认的<code>filemode</code>是<code>a</code>也就是追加的意思，所以没有清空原始文件的信息</strong>。</p><hr><h4 id="filemode-指定日志文件的打开模式"><a href="#filemode-指定日志文件的打开模式" class="headerlink" title="filemode-指定日志文件的打开模式"></a>filemode-指定日志文件的打开模式</h4><ul><li>该选项默认为<code>a</code></li><li>需要注意的是，<strong>该选项要在filename指定时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件打开模式更改为w，如果存在就清空然后写入，如果不存在就创建</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT,filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  03/23/2019 00:23:36 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>可以发现前一步的输出结果已经被覆盖掉了，只生成了这一步的输出结果。</p><hr><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><h4 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h4><ul><li><code>logging.basicConfig()</code>函数是一个<strong>一次性的简单配置工具</strong>，也就是说<strong>只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作</strong></li><li><strong>日志器（Logger）是有层级关系的</strong>，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为<code>root</code>，它是<strong>处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的</strong></li><li>如果要记录的<strong>日志中包含变量数据</strong>，<strong>可使用一个格式字符串</strong>作为这个事件的描述消息(<code>logging.debug</code>、<code>logging.info</code>等函数的第一个参数)，然后将变量数据作为第二个参数<code>*args</code>的值进行传递，如:<code>logging.warning(&#39;%s is %d years old.&#39;, &#39;Tom&#39;, 10)</code>，输出内容为<code>WARNING:root:Tom is 10 years old.</code>.</li></ul><hr><h4 id="日志级别方法参数的补充说明"><a href="#日志级别方法参数的补充说明" class="headerlink" title="日志级别方法参数的补充说明"></a>日志级别方法参数的补充说明</h4><ul><li><code>logging.debug()</code>, <code>logging.info()</code>等方法的定义中，除了<code>msg</code>和<code>args</code>参数外，还有一个<code>**kwargs</code>参数。它们<strong>支持3个关键字参数</strong>: <code>exc_info</code>、<code>stack_info</code>、<code>extra</code>，下面对这几个关键字参数作个说明:</li><li><code>exc_info</code>：其值为<strong>布尔值</strong>，如果该参数的值设置为<strong>True</strong>，则会<strong>将异常信息添加到日志消息中</strong>；如果<strong>没有异常信息则添加None到日志信息</strong>中</li><li><code>stack_info</code>：其值也为<strong>布尔值</strong>，<strong>默认值为False</strong>。如果该参数的值设置为<strong>True</strong>，<strong>栈信息将会被添加到日志信息中，相当于是哪一行输入了这个log信息</strong></li><li><code>extra</code>：这是一个<strong>字典（dict）参数</strong>，它可以用来<strong>自定义消息格式中所包含的字段</strong>，但是<strong>它的<code>key</code>不能与logging模块定义的字段冲突</strong></li></ul><p><strong>示例</strong>：<br>在日志消息中添加<code>exc_info</code>和<code>stack_info</code>信息，并添加<strong>两个自定义的字端</strong><code>ip</code>和<code>user</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(user)s[%(ip)s] - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置exc_info、stack_info、extra参数</span></span><br><span class="line">logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=<span class="keyword">True</span>, stack_info=<span class="keyword">True</span>, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03/23/2019 09:28:06 AM - WARNING - Tom[47.98.53.222] - Some one delete the <span class="built_in">log</span> file.</span><br><span class="line">NoneType: None</span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">"logging_learn.py"</span>, line 75, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=True, stack_info=True, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="日志模块四大组件以及日志流处理流程"><a href="#日志模块四大组件以及日志流处理流程" class="headerlink" title="日志模块四大组件以及日志流处理流程"></a>日志模块四大组件以及日志流处理流程</h2><p>在介绍logging模块的<strong>高级用法</strong>之前，很有必要对logging模块所包含的<strong>重要组件以及其工作流程做个全面、简要的介绍</strong>，这有助于我们更好的理解我们所写的代码（将会触发什么样的操作）。</p><h3 id="日志模块四大组件"><a href="#日志模块四大组件" class="headerlink" title="日志模块四大组件"></a>日志模块四大组件</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块日志级别的函数也是通过这些组件对应的类来实现的。</p><hr><h3 id="四大组件之间的关系"><a href="#四大组件之间的关系" class="headerlink" title="四大组件之间的关系"></a>四大组件之间的关系</h3><ul><li><strong>日志器(logger)需要通过处理器(handler)将日志信息输出到目标位置</strong>，如：文件、<code>sys.stdout</code>、网络等；</li><li>不同的<strong>处理器(handler)可以将日志输出到不同的位置</strong>；</li><li>日志器(logger)可以设置<strong>多个</strong>处理器(handler)将<strong>同一条</strong>日志记录输出到<strong>不同的位置</strong>；</li><li>每个<strong>处理器(handler)</strong>都可以<strong>设置自己的过滤器(filter)实现日志过滤</strong>，从而只保留感兴趣的日志；</li><li>每个<strong>处理器(handler)</strong>都可以设<strong>置自己的格式器(formatter)</strong>实现同一条日志<strong>以不同的格式输出到不同的地方</strong>。</li></ul><p>简单点说就是：<mark>日志器(logger)是入口，真正干活儿的是处理器(handler)，处理器(handler)还可以通过过滤器(filter)和格式器(formatter)对要输出的日志内容做过滤和格式化等处理操作。</mark></p><hr><h3 id="组件相关类与常用方法介绍"><a href="#组件相关类与常用方法介绍" class="headerlink" title="组件相关类与常用方法介绍"></a>组件相关类与常用方法介绍</h3><h4 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h4><p><strong>Logger对象有3个任务要做</strong>：</p><ul><li>向<strong>应用程序代码暴露几个方法</strong>，使应用程序<strong>可以在运行时记录日志消息</strong>；</li><li>基于日志严重等级(默认的过滤设施)或filter对象来<strong>决定要对哪些日志进行后续处理</strong>；</li><li>将日志消息<strong>传送给</strong>所有感兴趣的日志<strong>handlers</strong>。</li></ul><p><strong>Logger对象最常用的方法分为两类</strong>：</p><ul><li><code>配置方法</code></li><li><code>消息发送方法(创建日志)</code></li></ul><h5 id="最常用的配置方法"><a href="#最常用的配置方法" class="headerlink" title="最常用的配置方法"></a>最常用的配置方法</h5><table><tr><th>方法</th><th>描述</th></tr><tr><td><code>Logger.setLevel()</code></td><td><strong>设置<strong>日志器将会处理的日志消息的<strong>最低严重级别</strong></strong></strong></td></tr><tr><td><code>Logger.addHandler()</code>和<code>Logger.removeHandler()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>handler对象</strong></td></tr><tr><td><code>Logger.addFilter()</code>和<code>Logger.removeFilter()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>filter对象</strong></td></tr></table><div class="note info"><p>关于<code>Logger.setLevel()</code>方法的说明：内建等级中，级别最低的是<code>DEBUG</code>，级别最高的是<code>CRITICAL</code>。例如<code>setLevel(logging.INFO)</code>，此时函数参数为INFO，那么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。</p></div><hr><h5 id="创建日志记录方法"><a href="#创建日志记录方法" class="headerlink" title="创建日志记录方法"></a>创建日志记录方法</h5><p>logger对象配置完成后，可以<strong>使用下面的方法来创建日志记录</strong>：</p><table><tr><th width="50%">方法</th><th width="50%">描述</th></tr><tr><td><code>Logger.debug()</code>, <code>Logger.info()</code>, <code>Logger.warning()</code>, <code>Logger.error()</code>, <code>Logger.critical()</code></td><td>创建一个与它们的方法名对应等级的日志记录</td></tr><tr><td><code>Logger.exception()</code></td><td>创建一个类似于<code>Logger.error()</code>的日志消息</td></tr><tr><td><code>Logger.log()</code></td><td>需要获取一个明确的日志level参数来创建一个日志记录</td></tr></table><div class="note info"><ul><li><code>Logger.exception()</code>与<code>Logger.error()</code>的区别在于：<code>Logger.exception()</code>将会输出堆栈追踪信息，另外<strong>通常只是在一个exception handler中调用该方法</strong></li><li><code>Logger.log()</code>与<code>Logger.debug()</code>、<code>Logger.info()</code>等方法相比，虽然<strong>需要多传一个level参数，显得不是那么方便，但是当需要记录自定义level的日志时还是需要该方法来完成</strong></li></ul></div><h5 id="得到一个Logger对象"><a href="#得到一个Logger对象" class="headerlink" title="得到一个Logger对象"></a>得到一个Logger对象</h5><p>得到Logger对象方法有两种：</p><ul><li>第一种方式是通过<strong>Logger类的实例化方法</strong>创建一个Logger类的实例</li><li>第二种方式是<code>logging.getLogger()</code>方法，这是通常使用的方法</li></ul><p><code>logging.getLogger()</code>方法有一个<strong>可选参数</strong><code>name</code>，该参数表示将<strong>要返回的日志器的名称标识，如果不提供该参数，则其值为’root’</strong>。若以相同的<code>name</code>参数值多次调用<code>getLogger()</code>方法，将会返回指向同一个logger对象的引用。</p><div class="note info"><p>关于logger的<strong>层级结构</strong>与<strong>有效等级</strong>的说明：</p><ul><li><p>logger的名称是一个以<code>.</code>分割的层级结构，每个<code>.</code>后面的logger都是<code>.</code>前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代</p></li><li><p>logger有一个<strong>有效等级(effective level)</strong>的概念。</p><ul><li>如果一个logger上<strong>没有被明确设置一个level</strong>，那么该logger就是<strong>使用它parent的level</strong>；</li><li>如果它的<strong>parent也没有明确设置level</strong>则继续向上<strong>查找parent的parent的有效level，依次类推</strong>，直到找到个一个明确设置了level的祖先为止。</li><li>需要说明的是，<strong>root logger总是会有一个明确的level设置(默认为 WARNING)</strong>。</li><li>当<strong>决定是否去处理一个已发生的事件时</strong>，<strong>logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理</strong>。</li></ul></li><li><p><code>child loggers</code>在完成对日志消息的处理后，<strong>默认会将日志消息传递给与它们的祖先loggers相关的handlers</strong>。因此，我们<strong>不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了</strong>。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</p></li></ul></div><hr><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的<strong>作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）</strong>。Logger对象可以通过<code>addHandler()</code>方法<strong>为自己添加0个或者更多个handler对象</strong>。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>把所有日志都发送到一个日志文件中；</li><li>把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>把所有严重级别为critical的日志发送到一个email邮件地址。</li></ul><p>这种场景就需要<strong>3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置</strong>。</p><p>一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似乎唯一相关的handler方法就是下面这几个<strong>配置方法</strong>：</p><table><tr><th width="40%">方法</th><th width="60%">描述</th></tr><tr><td><code>Handler.setLevel()</code></td><td>设置handler将会处理的日志消息的最低严重级别</td></tr><tr><td><code>Handler.setFormatter()</code></td><td>为handler设置一个格式器对象</td></tr><tr><td><code>Handler.addFilter()</code>和<code>Handler.removeFilter()</code></td><td>为handler添加和删除一个过滤器对象</td></tr></table><p>需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了所有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些<strong>常用的Handler</strong>：</p><table><tr><th width="40%">Handler</th><th width="60%">描述</th></tr><tr><td><code>logging.StreamHandler</code></td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td><code>logging.FileHandler</code></td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td><code>logging.handlers.RotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td><code>logging.hanlders.TimedRotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td><code>logging.handlers.HTTPHandler</code></td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td><code>logging.handlers.SMTPHandler</code></td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td><code>logging.NullHandler</code></td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免'No handlers could be found for logger XXX'信息的出现。</td></tr></table><hr><h4 id="Formater类"><a href="#Formater类" class="headerlink" title="Formater类"></a>Formater类</h4><p>Formater对象用于<strong>配置日志信息的最终顺序、结构和内容</strong>。与logging.Handler基类不同的是，<strong>应用代码可以直接实例化Formatter类</strong>。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=<span class="keyword">None</span>, datefmt=<span class="keyword">None</span>, style=<span class="string">'%'</span>)</span><br></pre></td></tr></table></figure><p></p><p>可见，该构造方法接收3个可选参数：</p><ul><li><code>fmt</code>：指定消息格式化字符串，如果不指定该参数则<strong>默认使用message的原始值</strong></li><li><code>datefmt</code>：指定日期格式字符串，如果不指定该参数则默认使用<code>%Y-%m-%d %H:%M:%S</code></li><li><code>style</code>：Python 3.2新增的参数，可取值为<code>%</code>、<code>{</code>和<code>$</code>，如果不指定该参数则默认使用<code>%</code></li></ul><hr><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>.<span class="title">Filter</span><span class="params">(name=<span class="string">''</span>)</span></span></span><br><span class="line"><span class="class">    <span class="title">filter</span><span class="params">(record)</span></span></span><br></pre></td></tr></table></figure><p></p><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><div class="note info"><ul><li>如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性</li><li>我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等</li></ul></div><hr><h3 id="logging日志流处理流程"><a href="#logging日志流处理流程" class="headerlink" title="logging日志流处理流程"></a>logging日志流处理流程</h3><p>下面这个图描述了日志流的处理流程：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/logging处理流程.png" alt="logging处理流程.png"></p><p>我们来描述下上面这个图的日志流处理流程：</p><ul><li>（在用户代码中进行）<strong>日志记录函数调用</strong>，如：logger.info(…)，logger.debug(…)等；</li><li>判断要记录的日志级别<strong>是否满足日志器设置的级别要求</strong>（要记录的日志级别要大于或等于日志器设置的级别才算满足要求），如果不满足则该日志记录会被丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>根据日志记录函数调用时掺入的参数，<strong>创建</strong>一个<strong>日志记录（LogRecord类）对象</strong>；</li><li>判断日志记录器上设置的<strong>过滤器是否拒绝这条日志记录</strong>，如果日志记录器上的某个过滤器拒绝，则该日志记录会被丢弃并终止后续的操作，如果日志记录器上设置的过滤器不拒绝这条日志记录或者日志记录器上没有设置过滤器则继续下一步操作–<strong>将日志记录</strong>分别交给该日志器上添加的各个<strong>处理器</strong>；</li><li>判断要记录的日志级别<strong>是否满足处理器设置的级别要求</strong>（要记录的日志级别要大于或等于该处理器设置的日志级别才算满足要求），如果不满足记录将会被该处理器丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>判断该<strong>处理器上设置的过滤器</strong>是否拒绝这条日志记录，如果该处理器上的某个过滤器拒绝，则该日志记录会被当前处理器丢弃并终止后续的操作，如果当前处理器上设置的过滤器不拒绝这条日志记录或当前处理器上没有设置过滤器测继续下一步操作；</li><li>如果能到这一步，说明这条日志记录经过了层层关卡允许被输出了，此时当前<strong>处理器会根据自身被设置的格式器</strong>（如果没有设置则使用默认格式）将这条日志记录进行格式化，最后将格式化后的结果输出到指定位置（文件、网络、类文件的Stream等）；</li><li>如果日志器被设置了<strong>多个处理器</strong>的话，上面的第5-8步会执行多次；</li><li>这里才是完整流程的最后一步：<strong>判断该日志器输出的日志消息是否需要传递给上一级logger（之前提到过，日志器是有层级关系的）的处理器</strong>，如果propagate属性值为1则表示日志消息将会被输出到处理器指定的位置，同时还会被传递给parent日志器的handlers进行处理直到当前日志器的propagate属性为0停止，如果propagate值为0则表示不向parent日志器的handlers传递该消息，到此结束。</li></ul><p>可见，<strong>一条日志信息要想被最终输出需要依次经过以下几次过滤</strong>：</p><ul><li><strong>日志器等级过滤</strong></li><li>日志器的过滤器过滤</li><li><strong>日志器的处理器等级过滤</strong></li><li>日志器的处理器的过滤器过滤</li></ul><div class="note info"><p><strong>需要说明的是</strong>： 关于上面第9个步骤，如果propagate值为1，那么日志消息会直接传递交给上一级logger的handlers进行处理，此时上一级logger的日志等级并不会对该日志消息进行等级过滤。</p></div><hr><p><br></p><h2 id="使用四大组件记录日志"><a href="#使用四大组件记录日志" class="headerlink" title="使用四大组件记录日志"></a>使用四大组件记录日志</h2><p>现在，我们对logging模块的重要组件及整个日志流处理流程都应该有了一个比较全面的了解，下面我们来看一个例子。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>现在有以下几个日志记录的需求：</p><ul><li>要求将<strong>所有级别的所有日志都写入磁盘文件</strong>中</li><li><strong>all.log文件中记录所有的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 日志信息</li><li><strong>error.log文件中单独记录error及以上级别的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 文件名[:行号] - 日志信息</li><li>要求all.log在<strong>每天凌晨</strong>进行<strong>日志切割</strong></li></ul><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>要记录所有级别的日志，因此日志器的有效level需要设置为最低级别–DEBUG;</li><li><strong>日志需要被发送到两个不同的目的地</strong>，因此需要<strong>为日志器设置两个handler</strong>；另外，两个<strong>目的地都是磁盘文件</strong>，因此<strong>这两个handler都是与FileHandler相关的</strong>；</li><li>all.log要求<strong>按照时间进行日志切割</strong>，因此他需要用<code>logging.handlers.TimedRotatingFileHandler</code>; 而error.log没有要求日志切割，因此可以使用<code>FileHandler</code>;</li><li><strong>两个日志文件的格式不同</strong>，因此需要<strong>对这两个handler分别设置格式器</strong>.</li></ul><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'mylogger'</span>)</span><br><span class="line"><span class="comment"># 设置日志器的日志级别</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第一个handler，实现日志切割</span></span><br><span class="line">rf_handler = logging.handlers.TimedRotatingFileHandler(<span class="string">'all.log'</span>, when=<span class="string">'midnight'</span>, interval=<span class="number">1</span>, backupCount=<span class="number">7</span>, atTime=datetime.time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置第一个handler的格式器，使用了formatter类</span></span><br><span class="line">rf_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第二个handler</span></span><br><span class="line">f_handler = logging.FileHandler(<span class="string">'error.log'</span>)</span><br><span class="line"><span class="comment"># 设置这个handler的日志级别，实现日志过滤，在上面日志器的过滤结果中进行进一步的过滤</span></span><br><span class="line">f_handler.setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># 设置第二个handler的日志格式，使用了formatter类</span></span><br><span class="line">f_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给日志器添加第一个handler</span></span><br><span class="line">logger.addHandler(rf_handler)</span><br><span class="line"><span class="comment"># 给日志器添加第二个handler</span></span><br><span class="line">logger.addHandler(f_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同级别的日志信息 </span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat all.log</span><br><span class="line">  2019-03-23 16:53:48,763 - DEBUG - debug message</span><br><span class="line">  2019-03-23 16:53:48,766 - INFO - info message</span><br><span class="line">  2019-03-23 16:53:48,766 - WARNING - warning message</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - critical message</span><br><span class="line"></span><br><span class="line">cat error.log</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - logging_learn.py[:100] - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - logging_learn.py[:101] - critical message</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>%(filename)s[:%(lineno)d]</code>可以用来显示哪个文件的哪一行进行了这个日志输出</p></div><hr><h3 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a>其他实例</h3><h4 id="日志同时输出到文件和屏幕"><a href="#日志同时输出到文件和屏幕" class="headerlink" title="日志同时输出到文件和屏幕"></a>日志同时输出到文件和屏幕</h4><p>上面的那个实例是创建了两个handler来进行相关操作，其实也可以使用四大组件和日志级别函数结合来进行设置，<strong>以下是将日志同时输出到文件和屏幕的示例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用logging.basicConfig()来自定义日志输出信息，将日志信息输入到文件中</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                filename=<span class="string">'myapp.log'</span>,</span><br><span class="line">                filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"><span class="comment"># 使用四大组件来控制日志，因为一个handler只能输出到一个地方</span></span><br><span class="line"><span class="comment"># 这种需要输出到多个地方的肯定是需要两个handler的，上面的logging.basicConfig()相当于一个，所以还需要自己创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象#</span></span><br><span class="line">console = logging.StreamHandler()</span><br><span class="line"><span class="comment"># 设置handler的日志级别</span></span><br><span class="line">console.setLevel(logging.INFO)</span><br><span class="line"><span class="comment"># 使用foramtter类设置formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(name)-12s: %(levelname)-8s %(message)s'</span>)</span><br><span class="line"><span class="comment"># 设置handler的formatter</span></span><br><span class="line">console.setFormatter(formatter)</span><br><span class="line"><span class="comment"># 得到Logger类的对象并添加handler</span></span><br><span class="line">logging.getLogger(<span class="string">''</span>).addHandler(console)</span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'This is debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'This is info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'This is warning message'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="配置logging的几种方式"><a href="#配置logging的几种方式" class="headerlink" title="配置logging的几种方式"></a>配置logging的几种方式</h2><p>作为开发者，我们可以<strong>通过以下3中方式来配置logging</strong>:</p><ul><li>使用Python代码显式的创建loggers, handlers和formatters并分别调用它们的配置函数；</li><li>创建一个日志配置文件，然后使用fileConfig()函数来读取该文件的内容；</li><li>创建一个包含配置信息的dict，然后把它传递个dictConfig()函数；</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6885182.html" target="_blank" rel="noopener">《python之配置日志的几种方式》</a></p><hr><p><br></p><h2 id="向日志输出中添加上下文信息"><a href="#向日志输出中添加上下文信息" class="headerlink" title="向日志输出中添加上下文信息"></a>向日志输出中添加上下文信息</h2><p>除了传递给日志记录函数的参数外，有时候我们还想在<strong>日志输出中包含一些额外的上下文信息</strong>。比如，在一个网络应用中，可能希望在日志中记录客户端的特定信息，如：远程客户端的IP地址和用户名。这里我们来介绍以下几种实现方式：</p><ul><li>通过向日志记录函数传递一个<code>extra</code>参数引入上下文信息</li><li>使用<code>LoggerAdapters</code>引入上下文信息</li><li>使用<code>Filters</code>引入上下文信息</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6897964.html" target="_blank" rel="noopener">《Python之向日志输出中添加上下文信息》</a></p><hr><p><br></p><h2 id="实战技巧"><a href="#实战技巧" class="headerlink" title="实战技巧"></a>实战技巧</h2><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p><code>FileHandler</code> 创建对象时可以设置文件编码，如果将<strong>文件编码设置为 <code>utf-8</code>（utf-8 和 utf8 等价）</strong>，就可以解决中文乱码问题啦。</p><ul><li>一种方法是<strong>自定义 Logger 对象</strong>，需要写很多配置</li><li>另一种方法是<strong>使用默认配置方法 <code>basicConfig()</code>，传入 handlers 处理器列表对象</strong>，在其中的 handler 设置文件的编码</li></ul><p>关键参考代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义 Logger 配置</span></span><br><span class="line">handler = logging.FileHandler(filename=<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用默认的 Logger 配置，传入handlers时设置编码方式</span></span><br><span class="line">logging.basicConfig(handlers=[logging.FileHandler(<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)], level=logging.DEBUG)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="临时禁用日志输出"><a href="#临时禁用日志输出" class="headerlink" title="临时禁用日志输出"></a>临时禁用日志输出</h3><p>有时候我们又不想让日志输出，但在这后又想输出日志。</p><ul><li>一种方法是在<strong>使用默认配置时</strong>，给 <code>logging.disabled()</code> 方法<strong>传入禁用的日志级别</strong>，就可以禁止设置级别以下的日志输出了</li><li>另一种方法时在<strong>自定义 Logger 时</strong>，<strong>Logger 对象的 disable 属性设为 True，默认值是 False，也即不禁用</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认配置</span></span><br><span class="line">logging.disable(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的Logger</span></span><br><span class="line">logger.disabled = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割日志文件"><a href="#分割日志文件" class="headerlink" title="分割日志文件"></a>分割日志文件</h3><p><code>logging.handlers</code>文件中提供了<code>TimedRotatingFileHandler</code>和<code>RotatingFileHandler</code>类分别可以实现<strong>按时间</strong>和<strong>大小</strong>划分:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1000 Byte 划分一个日志文件，备份文件为 3 个</span></span><br><span class="line">file_handler = logging.handlers.RotatingFileHandler(<span class="string">"test.log"</span>, mode=<span class="string">"w"</span>, maxBytes=<span class="number">1000</span>, backupCount=<span class="number">3</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1小时 划分一个日志文件，interval 是时间间隔，备份文件为 10 个</span></span><br><span class="line">handler2 = logging.handlers.TimedRotatingFileHandler(<span class="string">"test.log"</span>, when=<span class="string">"H"</span>, interval=<span class="number">1</span>, backupCount=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>这个在前面的使用四大组件记录日志的示例中也有提及。</p><hr><p><br></p><h2 id="补充信息"><a href="#补充信息" class="headerlink" title="补充信息"></a>补充信息</h2><h3 id="datefmt支持的时间格式"><a href="#datefmt支持的时间格式" class="headerlink" title="datefmt支持的时间格式"></a>datefmt支持的时间格式</h3><table><tr><th width="20%">格式</th><th width="80%">含义</th></tr><tr><td><code>%a</code></td><td>本地（locale）简化星期名称</td></tr><tr><td><code>%A</code></td><td>本地完整星期名称</td></tr><tr><td><code>%b</code></td><td>本地简化月份名称</td></tr><tr><td><code>%B</code></td><td>本地完整月份名称</td></tr><tr><td><code>%c</code></td><td>本地相应的日期和时间表示</td></tr><tr><td><code>%d</code></td><td>一个月中的第几天（01 - 31）</td></tr><tr><td><code>%H</code></td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td><code>%I</code></td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td><code>%j</code></td><td>一年中的第几天（001 - 366）</td></tr><tr><td><code>%m</code></td><td>月份（01 - 12）</td></tr><tr><td><code>%M</code></td><td>分钟数（00 - 59）</td></tr><tr><td><code>%p</code></td><td>本地am或者pm的相应符</td></tr><tr><td><code>%S</code></td><td>秒（01 - 61）</td></tr><tr><td><code>%U</code></td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td></tr><tr><td><code>%w</code></td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td><code>%W</code></td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td><code>%x</code></td><td>本地相应日期</td></tr><tr><td><code>%X</code></td><td>本地相应时间</td></tr><tr><td><code>%y</code></td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td><code>%Y</code></td><td>完整的年份</td></tr><tr><td><code>%Z</code></td><td>时区的名字（如果不存在为空字符）</td></tr><tr><td><code>%%</code></td><td>‘%’字符</td></tr></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3.5/howto/logging.html" target="_blank" rel="noopener">Logging HOWTO-官方细致教程</a></li><li><a href="https://docs.python.org/3.5/howto/logging-cookbook.html" target="_blank" rel="noopener">Logging Cookbook-官方实例</a></li><li><a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">官方链接</a></li><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li><li><a href="http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html" target="_blank" rel="noopener">python 的日志logging模块学习</a></li><li><a href="https://blog.csdn.net/fxjtoday/article/details/6307285" target="_blank" rel="noopener">项目中比较需要用到的</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cat-显示、读取或拼接文件内容</title>
      <link href="/posts/24399.html"/>
      <url>/posts/24399.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用Linux的<code>cat</code>命令来执行文件的查看、合并和创建功能。在查看文件方面包括的参数有：<code>-n</code>、<code>-b</code>、<code>-s</code>、<code>-E</code>、<code>-T</code>；在合并文件方面学习了<strong>结合输出重定向以及前面的查看功能的参数进行合并</strong>；在创建文件方面主要有三个命令：<code>cat &gt;filename</code>、<code>cat &lt;&lt; EOF</code>和<code>cat &gt; filename &lt;&lt; EOF</code>。</p></div><a id="more"></a><h2 id="cat简介"><a href="#cat简介" class="headerlink" title="cat简介"></a>cat简介</h2><p><code>cat</code> 是一个文本文件(查看)和(连接)工具，通常是用于查看某个文件的内容，其主要有三大功能：</p><ul><li><strong>显示整个文件</strong>内容</li><li>将几个文件<strong>合并</strong>为一个文件</li><li><strong>从键盘创建一个文件</strong></li></ul><hr><p><br></p><h2 id="cat命令用法"><a href="#cat命令用法" class="headerlink" title="cat命令用法"></a>cat命令用法</h2><h3 id="cat命令格式"><a href="#cat命令格式" class="headerlink" title="cat命令格式"></a>cat命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cat [OPTION]... [FILE]...</span><br><span class="line">Description:</span><br><span class="line">  Concatenate FILE(s), or standard input, to standard output.</span><br></pre></td></tr></table></figure><hr><h3 id="cat-options说明"><a href="#cat-options说明" class="headerlink" title="cat options说明"></a>cat options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-n</strong></td><td>–number</td><td><strong>由1开始对所有输出的行数编号</strong></td></tr><tr><td><strong>-b</strong></td><td>–number-nonblank</td><td><strong>和-n相似，只不过对于空白行不编号</strong></td></tr><tr><td><strong>-s</strong></td><td>–squeeze-blank</td><td><strong>当遇到有连续两行以上的空白行，只输出一行的空白行</strong></td></tr><tr><td>-E</td><td>–show-ends</td><td>在每行结束处显示<code>$</code></td></tr><tr><td>-v</td><td>–show-nonprinting</td><td>使用<code>^</code>和<code>M-</code>符号，除了<code>LFD</code>和<code>TAB</code>之外</td></tr><tr><td>-T</td><td>–show-tabs</td><td>将<code>TAB</code>字符显示为<code>^I</code></td></tr><tr><td>-A</td><td>–show-all</td><td>等价于 <code>-vET</code></td></tr><tr><td>-e</td><td></td><td>等价于<code>-vE</code>选项</td></tr><tr><td>-t</td><td></td><td>等价于<code>-vT</code>选项</td></tr></tbody></table><hr><p><br></p><h2 id="cat用法实例"><a href="#cat用法实例" class="headerlink" title="cat用法实例"></a>cat用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>a<br>b 1</p><p>\====</p></blockquote><blockquote><p><code>cat test2.txt</code><br>c<br>d<br>\==</p></blockquote><hr><h3 id="查看文件功能"><a href="#查看文件功能" class="headerlink" title="查看文件功能"></a>查看文件功能</h3><h4 id="n-对所有行编号"><a href="#n-对所有行编号" class="headerlink" title="-n-对所有行编号"></a>-n-对所有行编号</h4><p><strong>所有行包含空白行</strong>：</p><blockquote><p><code>cat -n test1.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====</p></blockquote><hr><h4 id="b-对除空白行之外的行进行编号"><a href="#b-对除空白行之外的行进行编号" class="headerlink" title="-b-对除空白行之外的行进行编号"></a>-b-对除空白行之外的行进行编号</h4><blockquote><p><code>cat -b test1.txt</code><br>1 a<br>2 b 1</p><pre><code>3     ====  </code></pre></blockquote><p><strong>需要和上面的<code>-n</code>参数进行区分</strong></p><hr><h4 id="s-只输出连续多行空白行的其中一行"><a href="#s-只输出连续多行空白行的其中一行" class="headerlink" title="-s-只输出连续多行空白行的其中一行"></a>-s-只输出连续多行空白行的其中一行</h4><p><strong>结合前面的<code>-n</code>参数</strong>：</p><blockquote><p><code>cat -sn test1.txt</code><br>1 a<br>2 b 1<br>3<br>4 ====</p></blockquote><p>可以发现只输出了连续两行空白行中的一个，并进行编号，说明是先输出一个，然后编号的，不是先编号再输出其中一行</p><hr><h4 id="E-在每行结束处显示"><a href="#E-在每行结束处显示" class="headerlink" title="-E-在每行结束处显示$"></a>-E-在每行结束处显示$</h4><blockquote><p><code>cat -E test1.txt</code><br>a <strong>\$</strong><br>b 1<strong>\$</strong><br><strong>\$</strong><br><strong>\$</strong><br>====<strong>\$</strong></p></blockquote><hr><h4 id="T-将TAB字符显示为-I"><a href="#T-将TAB字符显示为-I" class="headerlink" title="-T-将TAB字符显示为^I"></a>-T-将TAB字符显示为^I</h4><blockquote><p>cat -nT test1.txt<br>1 a<br>2 b <strong>^I</strong>1<br>3<br>4<br>5 ====</p></blockquote><hr><p><br></p><h3 id="合并文件功能"><a href="#合并文件功能" class="headerlink" title="合并文件功能"></a>合并文件功能</h3><p>将<code>test1.txt</code>和<code>test2.txt</code>合并后重定向到<code>test3.txt</code>中：</p><blockquote><p><code>cat test1.txt test2.txt &gt;test3.txt</code><br><code>cat test3.txt</code><br>a<br>b 1</p><p>\====<br>c<br>d<br>\==</p></blockquote><p><strong>可以结合前面查看文件的参数</strong>：</p><blockquote><p><code>cat -n test1.txt test2.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====<br>6 c<br>7 d<br>8 ==</p></blockquote><div class="note info"><ul><li><strong>后面不接文件的话会输出到标准输出</strong></li><li>文件内容是<strong>按照文件顺序连接起来的</strong></li><li><strong>编号是连续的</strong>，不是每个文件单独的编号</li></ul></div><hr><p><br></p><h3 id="创建文件相关功能"><a href="#创建文件相关功能" class="headerlink" title="创建文件相关功能"></a>创建文件相关功能</h3><p>这一部分主要有三个比较重要和常见的命令：</p><ul><li><code>cat &lt;&lt; EOF</code></li><li><code>cat &gt; filename</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code></li></ul><h4 id="cat-lt-lt-EOF"><a href="#cat-lt-lt-EOF" class="headerlink" title="`cat &lt;&lt; EOF"></a>`cat &lt;&lt; EOF</h4><p><strong>以<code>EOF</code>输入字符为标准输入结束</strong>，这里的<strong>EOF并不是固定</strong>的(<code>EOF是end of file</code>，表示文本结束符，使用有含义的字符可能更容易记住用法)，可以设置为<code>mmm</code>等其他自定义的字符，示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF </span><br><span class="line">&gt; ad    <span class="comment"># 开始从标准输入读取</span></span><br><span class="line">&gt; adad</span><br><span class="line">&gt; EOF <span class="comment"># 遇到了标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad    <span class="comment"># 直接输出</span></span><br><span class="line">adad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换标准输入结束字符</span></span><br><span class="line">cat &lt;&lt; mmm</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; mmm   <span class="comment"># 遇到了上面定义的标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad</span><br><span class="line">ad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>这一部分输入输入和输出重定向部分，还可以参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h4 id="cat-gt-filename"><a href="#cat-gt-filename" class="headerlink" title="cat &gt; filename"></a><code>cat &gt; filename</code></h4><p><strong>创建文件</strong>，并<strong>把标准输入输出到filename文件</strong>中，<strong>以<code>ctrl+d</code>作为输入结束</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并写入</span></span><br><span class="line">cat &gt; filename</span><br><span class="line">ad</span><br><span class="line">adad   <span class="comment"># 这一行输入完成之后按下快捷键ctrl+d结束输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat filename </span><br><span class="line">ad</span><br><span class="line">adad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>cat &gt; filename</code>命令和上面的<code>cat &lt;&lt; EOF</code>不同之处在于：</p><ul><li><code>cat &lt;&lt; EOF</code>不会创建文件，而<code>cat &gt; filename</code>会创建文件</li><li><code>cat &lt;&lt; EOF</code>可以自定义结束的字符，而<code>cat &gt; filename</code>则是使用快捷键<code>ctrl+d</code>作为输入结束</li><li><code>cat &lt;&lt; EOF</code>输入的时候有<code>&gt;</code>提示输入，而<code>cat &gt; filename</code>没有任何提示输入的此内容</li></ul></div><hr><h4 id="cat-gt-filename-lt-lt-EOF"><a href="#cat-gt-filename-lt-lt-EOF" class="headerlink" title="cat &gt; filename &lt;&lt; EOF"></a><code>cat &gt; filename &lt;&lt; EOF</code></h4><p>这个是上面两个的合并版，<strong>既可以创建文件</strong>，<strong>又可以自定义停止输入字符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并设置停止输入字符</span></span><br><span class="line">cat &gt; test4.txt &lt;&lt; EOF</span><br><span class="line">&gt; a</span><br><span class="line">&gt; b</span><br><span class="line">&gt; c</span><br><span class="line">&gt; d</span><br><span class="line">&gt; EOF   <span class="comment"># 遇到了标准输入结束字符，结束标准输入，但是不会直接输入，因为内容已经重定向到test4.txt中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test4.txt文件内容，是刚刚输入的内容</span></span><br><span class="line">cat test4.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p></p><ul><li>上面的创建文件也<strong>可以改为追加文件</strong>：<code>cat &gt;&gt; test4.txt &lt;&lt; EOF</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code>书写的前后顺序可以调换，比如可写成：<code>cat &lt;&lt; EOF &gt; filename</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cat" target="_blank" rel="noopener">cat命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-cat.html" target="_blank" rel="noopener">Linux cat命令</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/7717602.html" target="_blank" rel="noopener">Linux cat命令详解</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5856106.html" target="_blank" rel="noopener">Linux中cat、more、less、tail、head命令的区别</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系列-Git实战总结</title>
      <link href="/posts/5778.html"/>
      <url>/posts/5778.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在使用Git中遇到的比较使用的技巧和问题解决方案，便于后续查询和使用。</p></div><a id="more"></a><h2 id="gitignore文件不起作用以及文件规则"><a href="#gitignore文件不起作用以及文件规则" class="headerlink" title=".gitignore文件不起作用以及文件规则"></a>.gitignore文件不起作用以及文件规则</h2><h3 id="文件书写规则"><a href="#文件书写规则" class="headerlink" title="文件书写规则"></a>文件书写规则</h3><p>在使用Git管理代码的过程中，可以修改<code>.gitignore</code>文件中的标示的方法来<strong>忽略开发者想忽略掉的文件或目录(实际项目中，很多文件都是不需要版本管理的)</strong>，如果没有<code>.gitignore</code>文件，可以自己手工创建。在<code>.gitignore</code>文件中的每一行保存一个匹配的规则例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"> </span><br><span class="line">*.a       <span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">!lib.a    <span class="comment"># 但 lib.a 除外</span></span><br><span class="line">/TODO     <span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line">build/    <span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">doc/*.txt <span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure><p></p><p>需要强调的一点是，如果你不慎在创建<code>.gitignore</code>文件之前就push了项目，那么即使你在<code>.gitignore</code>文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说，出现这种问题的原因就是<strong>Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们</strong>。所以大家一定要<strong>养成在项目开始就创建<code>.gitignore</code>文件的习惯，否则一旦push，处理起来会非常麻烦。</strong></p><div class="note info"><p>忽略整个文件夹，只需要<code>build/</code>即可，千万不要<code>build/*</code>，这样的话不会起效</p></div><hr><h3 id="清除本地缓存"><a href="#清除本地缓存" class="headerlink" title="清除本地缓存"></a>清除本地缓存</h3><p>如果一不小心在创建<code>.gitignore</code>文件之前就使用了<code>git push</code>，这样可能会使得<code>.gitignore</code>的忽略规则失效，这是因为新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在<code>.gitignore</code>中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行<code>git push</code>，这样就不会出现忽略的文件了。git清除本地缓存命令如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line">git rm -r --cached .</span><br><span class="line"><span class="comment"># 将所有文件改变上传到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 将暂存区的所有内容提交到当前分支上</span></span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="git-push-u-VS-git-push"><a href="#git-push-u-VS-git-push" class="headerlink" title="git push -u VS git push"></a>git push -u VS git push</h2><p><code>git push</code>的用法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与多个主机存在追踪关系(连接)，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用：</span></span><br><span class="line"><span class="comment"># 先使用带-u参数的git push</span></span><br><span class="line">git push -u origin master </span><br><span class="line"><span class="comment"># 后续的git push可以省略参数</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将已有的文件夹上传到github"><a href="#将已有的文件夹上传到github" class="headerlink" title="将已有的文件夹上传到github"></a>将已有的文件夹上传到github</h2><p>背景：可能有些时候并没有在文件夹创建之初没有考虑到上传到Github的情况，所以就需要将已有的文件夹上传到Github，但是又不希望先建立空的repo，然后clone下来将文件复制进去，然后就有了下面的方法：</p><ul><li>在bash下<strong>进入需要上传的文件夹</strong>：<code>cd dir</code></li><li><strong>初始化产生版本库</strong>：<code>git init</code></li><li>将所有文件<strong>添加到暂存区</strong>：<code>git add .</code></li><li>提交文件：<code>git commit -m &quot;message&quot;</code></li><li>添加远程仓库：<code>git remote add origin git@github.com:showteeth/orth_blast_docker.git</code></li><li>上传本地代码：<code>git push -u origin master</code></li><li>后续上传：<ul><li><code>git add .</code></li><li><code>git commit -m &quot;message&quot;</code></li><li><code>git push origin master</code>或者<code>git push</code></li></ul></li></ul><p>在使用<code>git push -u origin master</code>上传本地代码时，如果报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.com:showteeth/orth_blast_docker.git'</span></span><br></pre></td></tr></table></figure><p></p><ul><li>按照这个<a href="https://github.com/rtyley/bfg-repo-cleaner/issues/29" target="_blank" rel="noopener">issue</a>的说法，可以试试<code>git push -u origin master --force</code></li><li>或者按照<a href="https://blog.csdn.net/pql925/article/details/72772660" target="_blank" rel="noopener">这篇文章</a>的做法：<ul><li>合并代码：<code>git pull origin master</code>或者<code>git pull --rebase origin master</code>(<mark>文章中使用的这个，但我感觉是不是应该使用前面的，下次可以先试试前面的可不可以</mark>)</li><li>上传代码：<code>git push -u origin master</code></li></ul></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker系列-Dockerfile</title>
      <link href="/posts/31987.html"/>
      <url>/posts/31987.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/leveldc/article/details/85492558#_1" target="_blank" rel="noopener">Dockerfile详解</a></li><li><a href="https://www.cnblogs.com/lighten/p/6900556.html" target="_blank" rel="noopener">docker学习(3)–Dockfile详解</a></li><li><a href="https://www.centos.bz/2016/12/dockerfile-cmd-instruction/" target="_blank" rel="noopener">Dockerfile参考(8) – CMD设置运行容器时执行的命令</a></li><li><a href="https://www.jianshu.com/p/78f4591b7ff0" target="_blank" rel="noopener">Docker CMD</a></li><li><a href="https://www.cnblogs.com/51kata/p/5264894.html" target="_blank" rel="noopener">docker学习笔记16：Dockerfile 指令 ADD 和 COPY介绍</a></li><li><a href="https://www.cnblogs.com/lienhua34/p/5170335.html" target="_blank" rel="noopener">Dockerfile创建自定义Docker镜像以及CMD与ENTRYPOINT指令的比较</a></li><li><a href="http://www.dockone.io/article/1414" target="_blank" rel="noopener">九个编写Dockerfiles的常见错误</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-构建第一个docker镜像</title>
      <link href="/posts/371.html"/>
      <url>/posts/371.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是我的第一个Docker镜像，主要是依托项目是寻找两个基因之间的同源基因对。这篇文章主要记录了创建第一个镜像的过程，包括前期测试、编写Dockfile、查看镜像、运行镜像、修改镜像、退出、关闭、重启镜像、删除镜像以及后面的发布镜像、拉取镜像等操作，同时也记录了运行中的一些错误和解决办法。</p></div><a id="more"></a><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>docker 镜像是一个只读的 docker 容器模板，含有启动 docker 容器所需的文件系统结构及其内容(包括对资源需求、环境的要求、依赖的类库和运行的代码等等)，因此是启动一个 docker 容器的基础。</p><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile用于构建<strong>一致的Docker镜像</strong>，其定义了容器中的运行环境，包括像网络接口和虚拟化的磁盘驱动等硬件资源，这些资源是与宿主系统隔离开的，不会对系统有任何影响。使用Docker镜像运行Docker容器，可以让定义在该镜像中的应用程序<strong>无论在哪里运行，都有一致的功能</strong>。</p><h3 id="示例Dockerfile学习"><a href="#示例Dockerfile学习" class="headerlink" title="示例Dockerfile学习"></a>示例Dockerfile学习</h3><p>以下是官方的<code>Dockerfile</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方python镜像作为根镜像</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER <span class="string">"user_id&lt;email address&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /app 目录下</span></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外公开容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个环境变量world</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行 python app.py命令</span></span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="示例Dockerfile解读"><a href="#示例Dockerfile解读" class="headerlink" title="示例Dockerfile解读"></a>示例Dockerfile解读</h3><ul><li>FROM：FROM命令是<strong>必须的</strong>，<strong>可以是基于某个镜像</strong><ul><li><strong>从0开始构建</strong>：需要使用<code>scratch</code>，<code>scratch</code>代表着一个空白的镜像**，此时基本命令就是<code>FROM scratch</code>；</li><li>基于某个镜像：如上使用官方python镜像作为根镜像，所有的官方镜像可以在这个网站看到</li></ul></li><li>MAINTAINER：就是将维护人信息添加到脚本文件中，<strong>不一定需要，可有可无</strong></li><li>WORKDIR：定义工作目录</li><li><p>ADD：将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件拷贝到镜像中</p></li><li><p>RUN：用来执行基本命令的，基本格式有两种</p><ul><li>第一种是Shell格式：如上面安装包的命令以及<code>RUN npm install</code></li><li>第二种是exec格式：如<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ul></li></ul><p>由于<code>Dockerfile</code>每一个命令都会建立一层，RUN也不例外，在不必要的情况下使用多行RUN命令会使得镜像非常冗余和庞大，以下是一个示例:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p></p><p>类似上述例子，<strong>一共构建了7层镜像</strong>，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等，<strong>结果就是产生非常臃肿、非常 多层的镜像，不仅仅增加了构建部署的时间，也很容易出错</strong>。</p><p>正确写法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \ &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p></p><p>首先，之前所有的命令只有一个目的：编译、安装redis可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个RUN指令，并使用 <code>&amp;&amp;</code>将各个所需命令串联起来。将之前的7层，简化为了1层。其中每行命令后的 <code>\</code> 代表着换行，使dockerfile的RUN命令更具有可读性。</p><p>此外，命令的最后一行还有一个 <code>--auto-remove</code>命令，这个为<strong>清理工作</strong>的命令，<strong>删除了编译所需要的软件，清理下载以及展开的文件，并且还清理了apt缓存文件</strong>。由于镜像是一层一层构建的，每一层的多余东西并不会在下一层中被删除掉，到后面镜像会越来越大，因此<strong>清理这些没有用处的东西很有必要</strong>.</p><blockquote><p>RUN示例<a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">参考博客</a></p></blockquote><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile，其中安装Python所需要的依赖包时使用了文件进行安装，没有使用多行命令以及上述提及的使用<code>&amp;&amp;</code>的方法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p></p><p>示例的requirements.txt文件内容：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p></p><ul><li>EXPOSE：将指定的端口暴露出来，可以供外界访问，或者映射到宿主机的端口上去</li><li>CMD：容器启动命令，CMD命令和RUN命令相似，也是两种格式，分别为 <strong><code>shell</code>命令格式</strong>和 <strong><code>exec</code>命令格式</strong>。</li></ul><p>CMD 指令就是用于指定<strong>默认的容器主进程的启动命令的</strong>。在<code>exec</code>命令格式上，一般会被解析成json数组格式，<strong>需要用双引号，不能使用单引号!!!</strong></p><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile的CMD命令：<code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>，属于 <strong><code>exec</code>命令格式</strong>，<strong>注意使用的是双引号</strong>，意思是<strong>容器使用Python运行app.py文件</strong>，至于具体的app.py文件信息就不列举了。</p><div class="note info"><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">各个参数的官方解释</a></p></div><hr><h3 id="动手测试Dockerfile"><a href="#动手测试Dockerfile" class="headerlink" title="动手测试Dockerfile"></a>动手测试Dockerfile</h3><p>基于上面对示例Dockerfile的学习，接下来自己建立自己的Dockerfile</p><h4 id="建立centos的测试"><a href="#建立centos的测试" class="headerlink" title="建立centos的测试"></a>建立centos的测试</h4><p>Dockerfile内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos7</span></span><br><span class="line">FROM centos:7</span><br><span class="line"><span class="comment"># 维护人信息</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"><span class="comment"># 看看是否安装了python以及版本</span></span><br><span class="line">CMD python -v</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="创建docker镜像"><a href="#创建docker镜像" class="headerlink" title="创建docker镜像"></a>创建docker镜像</h4><p>基于上述Dockerfile使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>建立镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker build -f .\Dockerfile  -t centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line"><span class="comment"># 第一步对应于第一行</span></span><br><span class="line">Step 1/4 : FROM centos:7</span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">8ba884070f61: Pull complete</span><br><span class="line">Digest: sha256:ca58fe458b8d94bc6e3072f1cfbd334855858e05e1fd633aa07cf7f82b048e66</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:7</span><br><span class="line"> ---&gt; 9f38484d220f</span><br><span class="line"><span class="comment"># 第二步对应于第二行</span></span><br><span class="line">Step 2/4 : MAINTAINER showteeth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 75f880e1b2d9</span><br><span class="line">Removing intermediate container 75f880e1b2d9</span><br><span class="line"> ---&gt; 9ea90a7b7832</span><br><span class="line"><span class="comment"># 第三步对应于第三行</span></span><br><span class="line">Step 3/4 : WORKDIR /orth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 2c117f20ad92</span><br><span class="line">Removing intermediate container 2c117f20ad92</span><br><span class="line"> ---&gt; 07e0e346b57d</span><br><span class="line"><span class="comment"># 第四步对应于第四行 </span></span><br><span class="line">Step 4/4 : CMD python -v</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 297b155a52be</span><br><span class="line">Removing intermediate container 297b155a52be</span><br><span class="line"> ---&gt; 1f29d9e70fac</span><br><span class="line">Successfully built 1f29d9e70fac</span><br><span class="line">Successfully tagged centos:1.0</span><br><span class="line">SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have <span class="string">'-rwxr-xr-x'</span> permissions. It is recommended to double check and reset permissions <span class="keyword">for</span> sensitive files and directories.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>创建完成之后使用命令<code>docker images</code>查看镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里信息和build命令以及输出信息的对应</span></span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                     1.0                 1f29d9e70fac        8 minutes ago       202MB</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>使用<code>docker run -it centos:1.0</code>运行镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/aliases.pyc matches /usr/lib64/python2.7/encodings/aliases.py</span></span><br><span class="line">import encodings.aliases <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/aliases.pyc</span></span><br><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/ascii.pyc matches /usr/lib64/python2.7/encodings/ascii.py</span></span><br><span class="line">import encodings.ascii <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/ascii.pyc</span></span><br><span class="line">Python 2.7.5 (default, Oct 30 2018, 23:45:53)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">dlopen(<span class="string">"/usr/lib64/python2.7/lib-dynload/readline.so"</span>, 2);</span><br><span class="line">import readline <span class="comment"># dynamically loaded from /usr/lib64/python2.7/lib-dynload/readline.so</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p></p><p><strong>如上，运行之后自动运行了<code>python -v</code>，因为前面的Dockerfile的<code>CMD</code>写的就是这个命令</strong>，如果没有Python，可以参考这个链接来<a href="https://www.centos.bz/2018/01/%E5%9C%A8centos%E4%B8%8A%E5%AE%89%E8%A3%85python3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">安装Python</a></p><hr><h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h4><p>由于开始的时候设置了<code>CMD python -v</code>，导致镜像运行之后自动进入Python程序，退出Python之后也退出了整个docker环境，所以想知道可不可以修改CMD命令，查询<a href="https://serverfault.com/questions/594281/how-can-i-override-cmd-when-running-a-docker-image" target="_blank" rel="noopener">相关文档</a>之后，可以使用如下进行修改：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --entrypoint=/bin/bash <span class="variable">$IMAGE</span> -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如我可以使用如下命令进入bash shell的交互环境</span></span><br><span class="line">docker run -it --entrypoint=/bin/bash centos:1.0 -i</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="退出、关闭、重启镜像"><a href="#退出、关闭、重启镜像" class="headerlink" title="退出、关闭、重启镜像"></a>退出、关闭、重启镜像</h4><ul><li>使用命令<code>exit</code>来<strong>退出</strong>正在使用的镜像，注意退出之后并没有关闭，后台还在运行，使用<code>docker ps -a</code>可看到</li><li>使用<code>docker stop image_id|name</code>来关闭镜像</li></ul><hr><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>测试版本镜像和真正想要使用的镜像有很大差距，所以打算直接删掉重新创建一个镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有的container，这样才能够删除其中的images：</span></span><br><span class="line">docker stop $(docker ps -a -q)   <span class="comment"># Linux下可以这么使用，windows还是单个单个操作吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要删除 所有container 的话再加一个指令：</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前有些什么images</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除images，通过image的 id 来指定删除谁，注意和上面的删除容器相区分</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print <span class="variable">$3</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除 全部 image的话</span></span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：运行docker时docker desktop必须也在运行，而且不要关闭，一旦关闭，正在运行的container会直接退出</p></div><hr><h3 id="编写Dockfile"><a href="#编写Dockfile" class="headerlink" title="编写Dockfile"></a>编写Dockfile</h3><h4 id="准备文件信息"><a href="#准备文件信息" class="headerlink" title="准备文件信息"></a>准备文件信息</h4><ul><li>blast软件包</li><li>python相关运行文件</li><li>初始文件(fasta文件)</li><li>相关的脚本</li></ul><hr><h4 id="正式的Dockerfile"><a href="#正式的Dockerfile" class="headerlink" title="正式的Dockerfile"></a>正式的Dockerfile</h4><p>经过上述所有的学习和尝试，这里给出了最终可以运行的Dockerfile：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos镜像</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /orth</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /orth 目录下</span></span><br><span class="line">ADD . /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN yum -y install epel-release \</span><br><span class="line">&amp;&amp; yum -y install python-pip \ </span><br><span class="line">&amp;&amp; yum -y install vim \</span><br><span class="line">&amp;&amp; pip install -r requirements.txt \</span><br><span class="line">&amp;&amp; chmod 744 /orth/scripts/docker_blast.sh \</span><br><span class="line">&amp;&amp; tar -zxvf /orth/ncbi-blast-2.8.1+-x64-linux.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将blast加入环境变量</span></span><br><span class="line">ENV PATH /orth/ncbi-blast-2.8.1+/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行命令</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p></p><p>上面使用ADD没有执行自动解压操作，后续添加了自动解压操作，这个是官方的一个<a href="https://github.com/docker/docker-ce/releases/tag/v17.06.0-ce" target="_blank" rel="noopener">issue</a>，后续版本会改进。</p><hr><h4 id="创建和运行镜像"><a href="#创建和运行镜像" class="headerlink" title="创建和运行镜像"></a>创建和运行镜像</h4><ul><li>创建镜像：<code>docker build -f .\Dockerfile -t orth_project:2.0 .</code></li><li>运行镜像：<code>docker run -it orth_project:2.0</code></li><li>在镜像中使用<code>bash /orth/scripts/docker_blast.sh</code>运行查找同源基因的程序</li></ul><hr><p><br></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>主要步骤如下：</p><ul><li>第一步：开通<a href="https://cr.console.aliyun.com/new/new" target="_blank" rel="noopener">阿里云镜像服务</a></li><li>第二步：创建镜像仓库</li><li>第三步：推送镜像</li><li>第四步：查找验证镜像</li></ul><p>首先是开通阿里云镜像服务：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/开通阿里云镜像服务" alt="开通阿里云镜像服务"></p><hr><p>接下来创建镜像仓库：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库.png" alt="创建镜像仓库"><br><strong>仓库类型选择公开</strong><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库_2.png" alt="创建镜像仓库_2.png"><br><strong>代码源选择本地仓库</strong></p><hr><p>创建完成镜像仓库后，点击刚刚创建的镜像的管理，发现如下信息：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/推送镜像.png" alt="推送镜像.png"><br>然后，就可以按照上述图片中的提示完成镜像的推送，下面也列出了镜像推送的命令：</p><ul><li><code>docker login --username=username registry.cn-beijing.aliyuncs.com</code>输入这一步需要验证密码，验证成功会显示<code>Login Succeeded</code></li><li><code>docker tag [ImageId] registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这一步前面的<code>[ImageId]</code>使用<code>docker images</code>查看，<code>[镜像版本号]</code>是你上传上去想要显示的版本号，运行完成没有输出信息</li><li><code>docker push registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这里的<code>[镜像版本号]</code>是你上传上去想要显示的版本号，和上一步的保持一致，这一步完成会显示如下信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The push refers to repository [registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project]</span><br><span class="line">788a64a2f222: Pushed</span><br><span class="line">f652370971d2: Pushed</span><br><span class="line">d245b64a20a7: Pushed</span><br><span class="line">d69483a6face: Pushed</span><br><span class="line">1.0: digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7 size: 1161</span><br></pre></td></tr></table></figure></li></ul><div class="note info"><p>上传完成镜像后，本地也会出现一个名为<code>registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project</code>的镜像(<strong>该镜像具有和原始镜像相同的iamge id</strong>)，可以删除，通过命令<code>docker rmi -f registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</code>删除</p></div><hr><p>最后是查找验证镜像，经过上面几步已经成功将镜像上传到阿里云，接下来到阿里云中搜索自己刚刚上传的镜像：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索.png" alt="镜像搜索.png"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索结果.png" alt="镜像搜索结果.png"></p><hr><p><br></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>在上述查询到镜像结果之后，点击<strong>查看镜像的详细信息</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像的详细信息.png" alt="镜像的详细信息.png"></p><p><strong>复制公网地址</strong>并<strong>使用如下命令拉取镜像</strong>：<code>docker pull registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code></p><div class="note info"><p><strong>注意这个<code>[镜像版本号]</code>一定要指定，因为可能会存在很多版本号，这里指定后会拉取指定版本</strong></p></div><p>运行完成之后输出如下信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0: Pulling from showteeth/orth_blast_project</span><br><span class="line">Digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="build-with-gRPC-error"><a href="#build-with-gRPC-error" class="headerlink" title="build with gRPC error"></a>build with gRPC error</h3><p>使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[0000] failed to dial gRPC: cannot connect to the Docker daemon. Is <span class="string">'docker daemon'</span> running on this host?: open //./pipe/docker_engine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure><p></p><p><strong>解决办法</strong>：<br>在Github上看到了类似的<a href="https://github.com/docker-library/docker/issues/71" target="_blank" rel="noopener">issue</a>，主要的解决方法是在docker的设置中开启experimental features，如下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/experimental_features" alt="experimental_features"></p><p><strong>开启完成之后就解决了问题</strong></p><hr><h3 id="docker-image-is-being-used"><a href="#docker-image-is-being-used" class="headerlink" title="docker image is being used"></a>docker image is being used</h3><p>在使用<code>docker rmi 20ffdd2f28c0</code>删除镜像是发现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: conflict: unable to delete 20ffdd2f28c0 (must be forced) - image is being used by stopped container 7356c1e7efc0</span><br></pre></td></tr></table></figure><p></p><p><strong>解决方法：</strong></p><ul><li><p>先删除上面提示的那个占用当前镜像的<code>7356c1e7efc0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm  7356c1e7efc0</span><br></pre></td></tr></table></figure></li><li><p>然后再使用命令<code>docker rmi 20ffdd2f28c0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 20ffdd2f28c0</span><br></pre></td></tr></table></figure></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">Docker工作基本流程</a></li><li><a href="https://yq.aliyun.com/articles/596352" target="_blank" rel="noopener">Docker初体验，向Docker Hub推送第一个Docker镜像</a></li><li><a href="https://blog.csdn.net/qq_34680763/article/details/79711567" target="_blank" rel="noopener">第一次构建、运行、发布、获取docker镜像</a></li><li><a href="https://www.jianshu.com/p/4971967f7d3c" target="_blank" rel="noopener">Docker入门（二）创建您的第一个Docker镜像</a></li><li><a href="http://dockone.io/article/783" target="_blank" rel="noopener">10张图带你深入理解Docker容器和镜像</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-博客转载项目</title>
      <link href="/posts/26003.html"/>
      <url>/posts/26003.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这个项目主要是基于在转载博客时直接复制HTML后期不好修改，不能像Markdown一样生成大纲，不易管理，所以这里想做这样一个项目，<a href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener">项目地址</a>。</p></div><a id="more"></a><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="HTML装换为markdown"><a href="#HTML装换为markdown" class="headerlink" title="HTML装换为markdown"></a>HTML装换为markdown</h3><p>要想实现博客的装载，其中HTML装换为markdown是最为关键的一步，目前github上使用较多的(star较多)的HTML装换为markdown工具有三个：</p><ul><li><a href="https://github.com/domchristie/turndown" target="_blank" rel="noopener">turndown</a>，使用javascript代码，有<a href="http://domchristie.github.io/turndown/" target="_blank" rel="noopener">网页版</a>可以使用，比较好用，如果没有太大需要可以使用这个</li><li><a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener">html2text</a>，使用Python代码，可以嵌入其他程序使用，比较方便(很多印象笔记转文本的都是使用这个的)，这次我也打算使用这个</li><li><a href="https://github.com/gaojiuli/tomd" target="_blank" rel="noopener">tomd</a>，这个也是使用Python代码，但是star没有前面一个高，作为备用吧</li></ul><hr><h4 id="html2text使用"><a href="#html2text使用" class="headerlink" title="html2text使用"></a>html2text使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> html2text</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (html2text.html2text(<span class="string">"&lt;p&gt;Hello, world.&lt;/p&gt;"</span>))</span><br><span class="line">Hello, world.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = html2text.HTML2Text()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (h.handle(<span class="string">"&lt;p&gt;Hello, &lt;a href='http://earth.google.com/'&gt;world&lt;/a&gt;!"</span>))</span><br><span class="line">Hello, [world](http://earth.google.com/)!</span><br></pre></td></tr></table></figure><hr><h3 id="爬取网站内容"><a href="#爬取网站内容" class="headerlink" title="爬取网站内容"></a>爬取网站内容</h3><p>有了HTML装换markdown的工具，还需要使用工具将网页内容爬取下来，这里使用Python爬虫实现。</p><ul><li>XPATH和selector都可以通过右键复制得到</li><li><code>Selenium</code>模拟登陆很好用</li></ul><hr><h3 id="博客园、CSDN、简书博客"><a href="#博客园、CSDN、简书博客" class="headerlink" title="博客园、CSDN、简书博客"></a>博客园、CSDN、简书博客</h3><p>这几个网站作为统一的博客平台，爬虫时选取的部位固定，所以直接内置了.</p><hr><h3 id="其他自建博客"><a href="#其他自建博客" class="headerlink" title="其他自建博客"></a>其他自建博客</h3><p><strong>需要给双引号增加转义</strong>，如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python blog_parse.py -u http://rvdsd.top/2017/09/22/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-13%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/ -b others -c //*[@id=\<span class="string">"posts\"]/article/div/div -t //*[@id=\"posts\"]/article/div/header/h1</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h3><p>网上有将印象笔记先到处enex格式文件，然后根据这个文件进行转换格式的工具，但是我使用后发现并不好用.所以这里的想法是先将印象笔记分享为html的形式，然后再进行html转换为markdown，这样应该效果会好很多。</p><ul><li><a href="https://dev.yinxiang.com/doc/" target="_blank" rel="noopener">印象笔记开发者文档</a></li><li><a href="https://dev.yinxiang.com/doc/start/python.php" target="_blank" rel="noopener">印象笔记 Python SDK 快速入门指南</a></li></ul><h4 id="申请印象笔记-API-Key"><a href="#申请印象笔记-API-Key" class="headerlink" title="申请印象笔记 API Key"></a>申请印象笔记 API Key</h4><p>见官网教程</p><hr><h4 id="下载印象笔记-Python-SDK"><a href="#下载印象笔记-Python-SDK" class="headerlink" title="下载印象笔记 Python SDK"></a>下载印象笔记 Python SDK</h4><p>不要使用官网的那个链接，使用<a href="https://github.com/evernote/evernote-sdk-python3" target="_blank" rel="noopener">Python3的版本</a>，然后执行：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="测试-SDK"><a href="#测试-SDK" class="headerlink" title="测试 SDK"></a>测试 SDK</h4><p>进入Python环境，尝试导入包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\evernote3-1.25.0-py3.7.egg\evernote\api\client.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'oauth2'</span></span><br></pre></td></tr></table></figure><p></p><p>按照上面的提示，安装oauth2包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install oauth2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再进入Python环境</span></span><br><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"><span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>常规的按照印象笔记网站上的步骤，但是进行的过程中发现使用网站上的代码一直报错：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码</span></span><br><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">dev_token = <span class="string">"personal taken"</span></span><br><span class="line">client = EvernoteClient(token=dev_token,sandbox=<span class="keyword">False</span>,service_host=<span class="string">'app.yinxiang.com'</span>)</span><br><span class="line">userStore = client.get_user_store()</span><br><span class="line">user = userStore.getUser()</span><br><span class="line"><span class="keyword">print</span> (user.username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">evernote.edam.error.ttypes.EDAMSystemException: EDAMSystemException(message=<span class="string">'authenticationToken'</span>, errorCode=<span class="number">8</span>, rateLimitDuration=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p>在官方文档的各种地方查找都没有找到合适的方法，最后在<a href="https://www.tuicool.com/articles/2MV3QvU" target="_blank" rel="noopener">这篇文章中</a>找到了解决方案：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">dev_token = <span class="string">"personla taken"</span></span><br><span class="line">client = EvernoteClient(token=dev_token,sandbox=<span class="keyword">False</span>,service_host=<span class="string">'app.yinxiang.com'</span>)</span><br><span class="line">userStore = client.get_user_store()</span><br><span class="line">user = userStore.getUser()</span><br><span class="line"><span class="keyword">print</span> (user.username)</span><br></pre></td></tr></table></figure><p></p><p>吐槽一句：<strong>印象笔记的官方文档实在是太差了！！！忍不了！！！</strong></p><div class="note info"><p><a href="https://www.tuicool.com/articles/2MV3QvU" target="_blank" rel="noopener">这篇文章中</a>解决问题的步骤很值得我们学习，查看源码，找出问题，然后解决问题，很关键。</p></div><hr><h4 id="NoteStore-笔记本仓库"><a href="#NoteStore-笔记本仓库" class="headerlink" title="NoteStore-笔记本仓库"></a>NoteStore-笔记本仓库</h4><p>NoteStore 是用来创建、更新和删除笔记、笔记本还有其他在用户帐户中可找到的印象笔记的数据的。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">noteStore = client.get_note_store()</span><br><span class="line">notebooks = noteStore.listNotebooks()</span><br><span class="line"><span class="comment"># 输出笔记本的名称</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> notebooks:</span><br><span class="line">    <span class="keyword">print</span> (n.name)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出内容</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的第一个笔记本</span><br><span class="line">导入的笔记</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="Notebook-笔记本"><a href="#Notebook-笔记本" class="headerlink" title="Notebook-笔记本"></a>Notebook-笔记本</h4><ul><li>通过NoteStore类的<code>listNotebooks</code>方法可以获取一个<strong>包含所有笔记本的列表</strong></li><li><strong>在客户端视图中存在笔记本的嵌套，但实际上数据存储中所有笔记本都在同一层</strong></li><li>其下的笔记<strong>并不能通过该类的某个属性或者方法获取</strong></li><li>不管笔记本为空还是有笔记，属性都会有值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> notebook <span class="keyword">in</span> noteStore.listNotebooks():</span><br><span class="line"><span class="comment"># 得到笔记本的名字</span></span><br><span class="line">    notebookName = notebook.name</span><br><span class="line">    <span class="comment"># 得到笔记本的guid</span></span><br><span class="line">    notebookGuid = notebook.guid</span><br><span class="line">    print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(notebookName, notebookGuid))</span><br></pre></td></tr></table></figure><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我的第一个笔记本: dd36443d<span class="number">-2</span>ef1<span class="number">-4289</span>-aeb6<span class="number">-527e57</span>ce173b</span><br><span class="line">导入的笔记: <span class="number">5</span>c1dd2ec<span class="number">-8e0</span>a<span class="number">-4</span>a6e-b5f0<span class="number">-22507</span>c178086</span><br><span class="line">笔记本<span class="number">2</span>: <span class="number">3</span>f683ab0<span class="number">-4</span>ea7<span class="number">-4</span>ffb<span class="number">-800</span>d<span class="number">-4</span>c0864413c4b</span><br><span class="line">笔记本<span class="number">1</span>: <span class="number">61</span>bb02cd<span class="number">-1</span>fc2<span class="number">-404e-9</span>bc6<span class="number">-2</span>c20555dedec</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="enml-to-markdown"><a href="#enml-to-markdown" class="headerlink" title="enml to markdown"></a>enml to markdown</h4><ul><li><a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="noopener">enml格式讲解</a></li><li>不合算，放弃</li></ul><hr><h4 id="爬取动态页面"><a href="#爬取动态页面" class="headerlink" title="爬取动态页面"></a>爬取动态页面</h4><p>使用selenium模拟登陆</p><p><strong>遇到的问题</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\selenium\webdriver\common\service.py"</span>, line <span class="number">76</span>, <span class="keyword">in</span> start</span><br><span class="line">    stdin=PIPE)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">769</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    restore_signals, start_new_session)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">1172</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">    startupinfo)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。</span><br></pre></td></tr></table></figure><p></p><p>这是因为没有将浏览器驱动以及没有将浏览器驱动添加到环境变量：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 驱动下载地址</span></span><br><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载对应的chrome版本之后将压缩包解压，我下载的是chromedriver_win32.zip</span></span><br><span class="line"><span class="comment"># 发现32位的也能用，关键是只提供了32位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压上述包，然后将exe文件写入环境变量，可将exe文件放在C:\Program Files (x86)\Google\Chrome\Application目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量(可能需要重启电脑才会生效)之后直接输入</span></span><br><span class="line">chromedriver.exe</span><br><span class="line">Starting ChromeDriver <span class="number">72.0</span><span class="number">.3626</span><span class="number">.69</span> (<span class="number">3</span>c16f8a135abc0d4da2dff33804db79b849a7c38) on port <span class="number">9515</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver <span class="keyword">and</span> related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="博客园、CSDN、简书博客-1"><a href="#博客园、CSDN、简书博客-1" class="headerlink" title="博客园、CSDN、简书博客"></a>博客园、CSDN、简书博客</h3><ul><li>博客园：<code>python blog_parse.py -u https://www.cnblogs.com/zhaof/p/6953241.html -p C:/Users/14910/Desktop</code></li><li>CSDN：<code>python blog_parse.py -b csdn -u https://blog.csdn.net/work_you_will_see/article/details/84638750 -p C:/Users/14910/Desktop</code></li><li>简书博客：<code>python blog_parse.py -b jianshu -u https://www.jianshu.com/p/95331e7a98cd -p C:/Users/14910/Desktop</code></li></ul><hr><h3 id="自建博客"><a href="#自建博客" class="headerlink" title="自建博客"></a>自建博客</h3><ul><li><p>得到title的xpath：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/得到title的xpath.png" alt="得到title的xpath.png"></p></li><li><p>得到content的xpath：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/得到content的xpath.png" alt="得到content的xpath.png"></p></li><li><p>使用命令：<code>python blog_parse.py -b others -c //*[@id=\&quot;posts\&quot;]/article/div/div[1] -t //*[@id=\&quot;posts\&quot;]/article/div/header/h1 -u http://showteeth.tech/posts/56982.html -p C:/Users/14910/Desktop</code></p></li></ul><hr><h3 id="印象笔记-1"><a href="#印象笔记-1" class="headerlink" title="印象笔记"></a>印象笔记</h3><ul><li>将笔记<a href="https://help.evernote.com/hc/sr-me/articles/213420097-%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E7%AC%94%E8%AE%B0-" target="_blank" rel="noopener">导出单个html文件</a></li><li>将图片上传到图床，如果上传到图床的某个文件夹，需要指定下面的<code>-f</code>参数</li><li>使用命令：<code>python blog_parse.py -l &quot;C:/Users/14910/Desktop/VS code配置.html&quot; -f VS_code配置 -b evernote</code></li></ul><hr><p><br></p><h2 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h2><ul><li style="list-style:none"><input type="checkbox" checked> 启动这个项目 2019-3-21</li><li style="list-style:none"><input type="checkbox" checked> 印象笔记转载-API<ul><li style="list-style:none"><input type="checkbox" checked> 爬虫的方法，enml-这个就相当于使用印象笔记转markdown的那些工具，<mark>效果不好</mark></li><li style="list-style:none"><input type="checkbox" checked> 爬虫，模拟登陆— failed</li><li style="list-style:none"><input type="checkbox" checked> 既然能够模拟登陆了，那就不用在使用分享链接了啊，直接在网页版的印象笔记操作即可—&gt; <code>failed</code></li></ul></li><li style="list-style:none"><input type="checkbox" checked> 博客园</li><li style="list-style:none"><input type="checkbox" checked> CSDN</li><li style="list-style:none"><input type="checkbox" checked> 其他自建博客</li><li style="list-style:none"><input type="checkbox" checked> 爬取文章标题作为新建的markdown文件的标题</li><li style="list-style:none"><input type="checkbox" checked> 提供多种方法，加上另一个html转markdown的工具—&gt;<code>do not have the need</code></li><li style="list-style:none"><input type="checkbox" checked> 图片链接会自动换行，导致图片显示不出来 <code>fixed with set body_width = 0</code></li><li><p>[ ] 图片保留html形式，设置images_as_html=True，但没有起作用</p></li><li><p>[x] 印象笔记导出之前需要将其图片名称进行修改—&gt;两图片的空格替换为<code>%20</code></p></li><li style="list-style:none"><input type="checkbox" checked> 参数分组</li><li style="list-style:none"><input type="checkbox"> 爬取整个博客然后转化为markdown(不是很实用)</li><li style="list-style:none"><input type="checkbox"> 增加配置文件</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/littlecodersh/EasierLife" target="_blank" rel="noopener">EasierLife</a></li><li><a href="https://github.com/muzizongheng/Python/blob/master/Utility/Evernote2Blog/Main.py" target="_blank" rel="noopener">Evernote2Blog</a></li><li><a href="https://www.jianshu.com/p/bda26798f3b3" target="_blank" rel="noopener">使用Python操作Evernote API</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text3使用以及配置</title>
      <link href="/posts/53131.html"/>
      <url>/posts/53131.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在学习和使用sublime text编辑器过程中对其进行的配置和优化，包括一些插件的用法，便于后续使用和查询</p></div><a id="more"></a><h2 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h2><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="显示目录插件"><a href="#显示目录插件" class="headerlink" title="显示目录插件"></a>显示目录插件</h3><p>使用的是<strong>插件</strong>：<a href="https://github.com/warmdev/SublimeOutline" target="_blank" rel="noopener">SublimeOutline</a></p><p><strong>显示效果</strong>：</p><p><br><a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/warmdev/SublimeOutline/master/screenshot.png"><img src="https://raw.githubusercontent.com/warmdev/SublimeOutline/master/screenshot.png" alt="Screenshot" title="Screenshot" style="max-width:100%"></a><br></p><p><strong>具体使用</strong>：</p><ul><li><strong>打开</strong>侧边栏：<code>ctrl + shift + p</code>打开命令框，然后再输入<code>Browse Mode: Outline (Right)</code></li><li><strong>关闭</strong>侧边栏：<code>ctrl + shift + p</code>打开命令框，然后再输入<code>Browse mode: Close sidebar(s)</code></li></ul><hr><h3 id="设置自定义的模板"><a href="#设置自定义的模板" class="headerlink" title="设置自定义的模板"></a>设置自定义的模板</h3><p>使用的<strong>插件</strong>是：<a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="noopener">SublimeTmpl</a> ，该插件默认支持<code>html</code>、<code>ruby</code>、<code>html</code>、<code>php</code>、<code>js</code>和<code>python</code>，由于平时使用bash脚本也比较多，所以想设置一下<code>bash</code>的模板</p><ul><li><strong>添加自定义模板</strong>：<code>C:\Users\user\AppData\Roaming\Sublime Text 3\Packages\User\SublimeTmpl\templates</code>(说是会优先使用这个目录下的自定义模板)，按照插件已存在的模板来看看如何写，我写的如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># @Date    : $&#123;date&#125;</span></span><br><span class="line"><span class="comment"># @Author  : $&#123;author&#125; ($&#123;email&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#BSUB -J $1</span></span><br><span class="line"><span class="comment">#BSUB -o $1.%J</span></span><br><span class="line"><span class="comment">#BSUB -e $1.%J</span></span><br><span class="line"><span class="comment">#BSUB -n 16</span></span><br><span class="line"><span class="comment">#BSUB -q TEST-A</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$0</span></span><br></pre></td></tr></table></figure><div class="note info"><p><strong>需要特别注意模板的命名</strong>：需要结合已存在的对bash语言的支持，如下一步的语言支持中是<code>shellscript</code>，这里的模板命令也要是<code>shellscript</code>，不然不会高亮脚本，保存的时候也不会出现默认的后缀名。</p></div><ul><li>查看是不是有bash<strong>语言的支持</strong>：在<code>Sublime Text/Preferences/Package Settings/SublimeTmpl/Setting-Default</code>中查看，这里有bash语言的支持，所以就不需要进行进一步的配置，如果没有的话需参考<a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="noopener">官方设置语言</a>的方式：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"shellscript"</span>: &#123;</span><br><span class="line">        <span class="string">"syntax"</span>: <span class="string">"Packages/ShellScript/Shell-Unix-Generic.tmLanguage"</span>,</span><br><span class="line">        <span class="string">"extension"</span>: <span class="string">"sh"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>新增开始菜单</strong>：可以在<code>Sublime Text/Preferences/Package Settings/SublimeTmpl/Menu-Default</code>里：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"shellscript"</span>,</span><br><span class="line">    <span class="string">"caption"</span>: <span class="string">"shellscript"</span>,</span><br><span class="line">    <span class="string">"command"</span>: <span class="string">"sublime_tmpl"</span>,</span><br><span class="line">    <span class="string">"args"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"shellscript"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的type是自己创建的模板名称，我创建的是shellscript.tmpl，所以这里是shellscript，还需要和支持的bash语言的名称相对应</span></span><br><span class="line"><span class="comment"># caption是menu里面显示的名称</span></span><br><span class="line"><span class="comment"># 这我设置user menu没有起效，不知道为啥，只有设置了default menu才起效</span></span><br></pre></td></tr></table></figure><ul><li>如果需要给<strong>一种语言</strong>增加<strong>两种模板</strong>，想我需要一个server版的、一个本地的版的：<ul><li>bash语言的支持中<strong>增加</strong>：</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"shellscript_basic"</span>: &#123;</span><br><span class="line">        <span class="string">"syntax"</span>: <span class="string">"Packages/ShellScript/Shell-Unix-Generic.tmLanguage"</span>,</span><br><span class="line">        <span class="string">"extension"</span>: <span class="string">"sh"</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li><code>User\SublimeTmpl\templates</code>中<strong>创建</strong><code>shellscript_basic.tmpl</code>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># @Date    : $&#123;date&#125;</span></span><br><span class="line"><span class="comment"># @Author  : $&#123;author&#125; ($&#123;email&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$0</span></span><br></pre></td></tr></table></figure><ul><li><code>Menu-Default</code>中<strong>添加</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"bash_basic"</span>,</span><br><span class="line">    <span class="string">"caption"</span>: <span class="string">"bash_basic"</span>,</span><br><span class="line">    <span class="string">"command"</span>: <span class="string">"sublime_tmpl"</span>,</span><br><span class="line">    <span class="string">"args"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"shellscript_basic"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><div class="note info"><p>这里<strong>没有设置快捷键</strong>，因为快捷键多了<strong>容易冲突</strong>，所以就没有设置，直接在菜单栏中选择也是不错的。</p></div><ul><li>参考链接<ul><li><a href="https://xhl.me/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="noopener">开发者的中文说明，可以看看评论区</a></li><li><a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="noopener">插件的github</a></li></ul></li></ul><hr><h3 id="支持GBK编码的文件"><a href="#支持GBK编码的文件" class="headerlink" title="支持GBK编码的文件"></a>支持GBK编码的文件</h3><p><code>sublime text</code>的默认打开文件的编码方式是<code>UTF-8</code>，打开<code>GBK</code>编码的文件出现乱码， 并且<code>reopen with encoding</code>也没有找到对应GBK的编码，需要安装插件<code>GBK support</code></p><hr><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime text3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图床-阿里云+PicGo上传照片</title>
      <link href="/posts/41221.html"/>
      <url>/posts/41221.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是关于使用阿里云搭建图床以及使用PicGo进行上传照片的操作，便与后续查询使用</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来图床使用的是七牛的服务，但是前几天七牛给我发了一封”测试域名回收通知”的邮件，看了邮件，然后查看相关说明发现如果想要使用就有添加自己的域名，然后为了添加自己的域名还要去公安部备案，尝试了一下，太麻烦了，然后看了一下关于阿里和腾讯的，本着天下没有免费的午餐的理念，我选择了阿里(腾讯的存储不要钱)，然后就有了接下来的故事。</p><h2 id="开通阿里云oss"><a href="#开通阿里云oss" class="headerlink" title="开通阿里云oss"></a>开通阿里云oss</h2><p>主要流程：实名认证—&gt;开通对象存储服务 OSS—&gt;购买资源包—&gt;新建Bucket</p><p>购买资源包的时候可以选取资源包类型和规格等信息，按照自己的需求选取即可，我这里选择的是存储包以及40G大小，作为博客图片应该是足够用了(如果有再小一点的我肯定就选了)。</p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/阿里oss.png"><br></div><p>关于阿里oss收费，比较复杂，主要包括：存储容量，流量，请求次数。刚刚购买的只是存储容量，具体的收费详情请查看<a href="https://www.aliyun.com/price/product?spm=5176.7933691.744462.c1.79ba6a56EQXVX5#/oss/detail" target="_blank" rel="noopener">这个链接</a></p><p>接下来就是新建Bucket了，我按照如下选项进行的创建：</p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/阿里oss_2.png"><br></div><hr><h2 id="使用PicGo上传图片"><a href="#使用PicGo上传图片" class="headerlink" title="使用PicGo上传图片"></a>使用PicGo上传图片</h2><p>PicGo是一款图片上传的工具，目前支持微博图床、七牛图床、腾讯云、又拍云、GitHub、阿里等主流图床，并且支持macOS、windows 64位（&gt;= v1.3.1），linux（&gt;= v1.6.0），可是说是全平台很强大了，这是<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Github链接</a>、这是<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">官方网站</a></p><p>下载并安装之后进入图床设置，选择对应的图床，我这里选取了阿里oss：</p><div align="center"><br><img src="https://i.loli.net/2019/03/20/5c92335ee931f.png"><br></div><ul><li>accesskey和accesskeySecret可以从阿里云控制台获取(就在新建Bucket旁边)</li><li>存储空间名是bucket的名字</li><li>存储区域按照提示填写(在bucket的访问域名中可以看到)</li><li>存储路径按照提示填写</li><li>自定义域名可以不填写</li></ul><h3 id="PicGo插件使用"><a href="#PicGo插件使用" class="headerlink" title="PicGo插件使用"></a>PicGo插件使用</h3><p>这里给出的<a href="https://github.com/PicGo/Awesome-PicGo/blob/master/README.md" target="_blank" rel="noopener">PicGo</a>中包含的插件，我觉得比较好的是<a href="https://github.com/Spades-S/vs-picgo/blob/master/README_ZH.md" target="_blank" rel="noopener">vs-picgo</a>，其可以在vscode中使用，刚好自己使用的就是vscode，所以非常方便，这里记录这个插件的主要用法。</p><ul><li>安装插件，直接在vscode应用商店中搜索PicGo即可</li><li><p><strong>配置插件</strong>：<br><strong>修改vscode的<code>setting.json</code>文件</strong>，加入如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 其中的XXX使用自己的信息填写进去</span><br><span class="line">"picgo": &#123;</span><br><span class="line">  "path": ""</span><br><span class="line">&#125;,</span><br><span class="line">"picBed": &#123;</span><br><span class="line">  "current": "aliyun",</span><br><span class="line">  "aliyun": &#123;</span><br><span class="line">    "accessKeyId": "XXX",</span><br><span class="line">    "accessKeySecret": "XXX",</span><br><span class="line">    "bucket": "XXX",</span><br><span class="line">    "area": "XXX",</span><br><span class="line">    "path": "XXX",</span><br><span class="line">    "customUrl": ""</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>插件上传的图片<strong>不会显示在PicGo软件的相册</strong>中，直接上传在了阿里云</p></li><li>如果想要<strong>对上传的图片更改名称</strong>，可以<strong>先选中名称</strong>，然后<strong>再插入图片</strong></li><li>上传<strong>只支持markdown的链接</strong>，<strong>不支持其他类型(如html)链接</strong>，这个<strong>没有PicGo桌面版好用</strong></li><li>支持从剪贴板、文件选取以及输入框上床，对应的快捷键如下：<blockquote><ul><li><code>ctrl+alt+u</code>：<strong>剪贴板</strong>图片上传</li><li><code>ctrl+alt+e</code>：打开<strong>文件管理器</strong>上传</li><li><code>ctrl+alt+o</code>：打开<strong>输入框输入路径</strong>上传</li></ul></blockquote></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之argparse-命令行选项与参数解析</title>
      <link href="/posts/19941.html"/>
      <url>/posts/19941.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python用于解析命令行参数的<code>argparse</code>模块，按照其使用过程依次学习了<strong>生成参数分析器</strong>、<strong>添加参数</strong>、<strong>参数解析</strong>和<strong>输出传入参数值</strong>，最后还学习了<strong>参数群组</strong>、比较强大的<strong>创建子命令</strong>以及<strong>互斥参数组</strong>的使用。</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>argparse</code>是 <code>Python</code> 标准库中用来解析命令行参数和选项的模块，很早之前就想学习和使用这个模块了，但由于种种原因没能实现；之前一直使用的是<code>sys</code>模块的<code>argv</code>来传递参数，但是这种传递参数的方法比较简单，不能输出一些提示信息，导致有些脚本很久之后再看可能不知道当时设置的参数的含义或者需要打开具体的脚本才能知道参数的含义，比较麻烦，所以这里来对<code>argparse</code>进行学习，在以后的脚本中替换<code>sys</code>模块。</p><hr><h2 id="初识argparse"><a href="#初识argparse" class="headerlink" title="初识argparse"></a>初识argparse</h2><p>创建python文件(<strong>注意不要将文件命名为argparse.py，不然会报错，因为文件名和模块名相同，导入会出问题</strong>)，并在其中写入如下代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成参数分析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出传入参数值 </span></span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><p></p><p>运行上述python文件：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–sum] N [N …]</p><p>Process some integers.</p><p>positional arguments:<br>N an integer for the accumulator</p><p>optional arguments:<br>-h, –help show this help message and exit<br>–sum sum the integers (default: find the max)</p></blockquote><p>从上述输出结果可以发现：<code>argparse</code>会自动生成帮助文档，也就是说即使在程序中不添加任何参数，<strong><code>argparse</code>也会自动默认生成一个参数<code>-h</code></strong>，用于输出帮助文档</p><p>在上述<code>argparse</code>使用过程中依次经过了<strong>生成参数分析器</strong>、<strong>添加参数</strong>、<strong>参数解析</strong>和<strong>输出传入参数值</strong>这几步，接下来我就按照这个顺序进行学习。</p><hr><h2 id="创建解析器-ArgumentParser类"><a href="#创建解析器-ArgumentParser类" class="headerlink" title="创建解析器-ArgumentParser类"></a>创建解析器-ArgumentParser类</h2><p>上述argparse测试代码中使用<code>argparse.ArgumentParser()</code>创建参数分析器也就是解析器，这里就先对这个解析器进行一定的了解，其原型如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">argparse</span>.<span class="title">ArgumentParser</span><span class="params">(prog=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                usage=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                description=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                epilog=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                parents=[], </span></span></span><br><span class="line"><span class="class"><span class="params">                formatter_class=argparse.HelpFormatter,</span></span></span><br><span class="line"><span class="class"><span class="params">                prefix_chars=<span class="string">'-'</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">                fromfile_prefix_chars=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                argument_default=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                conflict_handler=<span class="string">'error'</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">                add_help=True,</span></span></span><br><span class="line"><span class="class"><span class="params">                allow_abbrev=True)</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>其中参数的含义</strong>：</p><style>table th:first-of-type{width:30%}table th:nth-of-type(2){width:50%}table th:nth-of-type(3){width:20%}</style><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>prog</td><td>程序的名字，help中显示的</td><td><code>sys.argv[0]</code></td></tr><tr><td>usage</td><td>描述程序用途的字符串</td><td>从解析器的参数生成</td></tr><tr><td>description</td><td>参数帮助信息之前的文本</td><td>none</td></tr><tr><td>epilog</td><td>参数帮助信息之后的文本</td><td>none</td></tr><tr><td>parents</td><td><code>ArgumentParser</code> 对象的一个列表，这些对象的参数应该包括进去(参数继承)</td><td></td></tr><tr><td>formatter_class</td><td>定制化输出的帮助信息</td><td></td></tr><tr><td>prefix_chars</td><td>可选参数的前缀字符</td><td>‘-‘</td></tr><tr><td>fromfile_prefix_chars</td><td>从文件中读取参数时文件的前缀字符</td><td>None</td></tr><tr><td>argument_default</td><td>参数的全局默认值</td><td>None</td></tr><tr><td>conflict_handler</td><td>解决冲突的可选参数的策略（通常没有必要）</td><td></td></tr><tr><td>add_help</td><td>解析器添加-h/–help 选项</td><td>True</td></tr><tr><td>allow_abbrev</td><td>如果前缀是明确的，则允许缩写长参数</td><td>True</td></tr></tbody></table><h3 id="proc-help中描述程序的名称"><a href="#proc-help中描述程序的名称" class="headerlink" title="proc-help中描述程序的名称"></a>proc-help中描述程序的名称</h3><p><code>proc</code>参数代表程序的名字，默认为<code>sys.argv[0]</code>，<strong>用来在help信息中描述程序的名称</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改上述代码解析器的部分如下</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br></pre></td></tr></table></figure><p></p><p>并使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: <strong><em>myprogram</em></strong> [-h]</p></blockquote><p>发现<code>usage</code>后面接着的文字由默认的<code>argparse_test.py(sys.argv[0])</code>变成了现在的<code>prog=&#39;myprogram&#39;</code>定义的内容</p><hr><h3 id="usage-描述程序用途"><a href="#usage-描述程序用途" class="headerlink" title="usage-描述程序用途"></a>usage-描述程序用途</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以结合proc一起使用</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>, usage=<span class="string">'%(prog)s is a test of argparse'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: <strong>myprogram is a test of argparse</strong></p></blockquote><p>发现<code>usage</code>后面接着的文字由默认的<code>argparse_test.py [-h]</code>变成了现在的<code>myprogram is a test of argparse</code></p><hr><h3 id="description和epilog-程序描述信息，help-信息前后的文字"><a href="#description和epilog-程序描述信息，help-信息前后的文字" class="headerlink" title="description和epilog-程序描述信息，help 信息前后的文字"></a>description和epilog-程序描述信息，help 信息前后的文字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'before help'</span>,epilog=<span class="string">"after help"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [-h]</p><p><strong>before help</strong></p><p>optional arguments:<br>-h, –help show this help message and exit</p><p><strong>after help</strong></p></blockquote><hr><h3 id="prefix-chars-参数前缀"><a href="#prefix-chars-参数前缀" class="headerlink" title="prefix_chars-参数前缀"></a>prefix_chars-参数前缀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prefix_chars=<span class="string">'+'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py +h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [<strong>+</strong>h]</p><p>optional arguments:<br><strong>+</strong>h, <strong>++</strong>help show this help message and exit</p></blockquote><hr><h3 id="parents-参数继承"><a href="#parents-参数继承" class="headerlink" title="parents-参数继承"></a>parents-参数继承</h3><p>我们常常需要实现一套命令行程序，这些程序都带一组参数，只是<strong>在某些方面有特殊化</strong>。例如，如果所有程序都需要在用户进行任何实际的操作之前对用户进行认证，那么它们就<strong>都需要支持<code>--user</code>和<code>--password</code>选项</strong>。你可以共享的选项来定义一个“父母”解析器，然后<strong>令单个程序的解析器从该“父母”解析器继承共享选项，这样就不必显式为每个ArgumentParser添加共享选项</strong>。</p><p><strong>第一步</strong>是以共享的参数定义<strong>建立“父母”解析器</strong>。注意：<strong>由于“父母”解析器的后代使用者会添加相同的帮助选项，从而会引发一个异常(见下面冲突解决)，所以在基础解析器中我们关闭自动帮助选项生成</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 注意这里的add_help=False</span></span><br><span class="line">parser = argparse.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure><p></p><p>文件保存在名为<code>argparse_parent_base.py</code>的文件中</p><p><strong>第二步以父母解析器集创建另一个解析器</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 导入parent的文件</span></span><br><span class="line"><span class="keyword">import</span> argparse_parent_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承父母解析器的参数</span></span><br><span class="line">parser = argparse.ArgumentParser(parents=[argparse_parent_base.parser])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置自己的参数</span></span><br><span class="line">parser.add_argument(<span class="string">'--local-arg'</span>, action=<span class="string">"store_true"</span>, default=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出所有的参数</span></span><br><span class="line"><span class="keyword">print</span> parser.parse_args()</span><br></pre></td></tr></table></figure><p></p><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_uses_parent.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_uses_parent.py [-h] [--user USER] [--password PASSWORD]</span><br><span class="line">                           [--local-arg]</span><br><span class="line"><span class="comment"># 可以发现继承了父母解析器的参数</span></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">    --user USER</span><br><span class="line">    --password PASSWORD</span><br><span class="line">    --local-arg</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="conflict-handler-冲突解决"><a href="#conflict-handler-冲突解决" class="headerlink" title="conflict_handler-冲突解决"></a>conflict_handler-冲突解决</h3><p>前一个例子指出<strong>以相同的参数名字为一个解析器添加两个参数处理器会引发一个异常</strong>(就是<code>parent</code>中提到的的帮助选项)。可以通过传递一个<code>conflict_handler</code>来改变冲突消除行为。<code>argparse</code>有两个内置的冲突处理器<code>error（默认）</code>和<code>resolve</code>，<code>resolve</code>会基于冲突选项的添加顺序来选择一个参数处理器:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 设置冲突解决的策略为resolve</span></span><br><span class="line">parser = argparse.ArgumentParser(conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">"store"</span>)</span><br><span class="line"><span class="comment"># 两个相同参数名的参数</span></span><br><span class="line">parser.add_argument(<span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">"Short alone"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--long-b'</span>, <span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">"Long and short together"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> parser.parse_args([<span class="string">'-h'</span>])</span><br></pre></td></tr></table></figure><p></p><p>由于最后一个处理器所给定的参数名已被使用，那么本例中<strong>独立选项<code>-b</code>将被<code>--long-b</code>所覆盖</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_conflict_handler_resolve.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_conflict_handler_resolve.py [-h] [-a A] [--long-b LONG_B]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -a A</span><br><span class="line">    <span class="comment"># 只出现了后定义的参数，前面定义的参数被覆盖了</span></span><br><span class="line">    --long-b LONG_B, -b LONG_B</span><br><span class="line">            Long <span class="keyword">and</span> short together</span><br></pre></td></tr></table></figure><p></p><p><strong>切换<code>add_argument()</code>的调用顺序</strong>就可以使两个选项都可以使用：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">"store"</span>)</span><br><span class="line"><span class="comment"># 同样是定义两个相同参数名的参数，只是顺序发生改变</span></span><br><span class="line">parser.add_argument(<span class="string">'--long-b'</span>, <span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">'Long and short together'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">'Short alone'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> parser.parse_args([-h])</span><br></pre></td></tr></table></figure><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_conflict_handler_resolve2.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_conflict_handler_resolve2.py [-h] [-a A] [--long-b LONG_B] [-b B]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -a A</span><br><span class="line">    <span class="comment"># 两个参数都可以使用了，没有进行覆盖</span></span><br><span class="line">    --long-b LONG_B Long <span class="keyword">and</span> short together</span><br><span class="line">    -b B    Short alone</span><br></pre></td></tr></table></figure><hr><h3 id="fromfile-prefix-chars-从文件中读取参数时文件的前缀字符集"><a href="#fromfile-prefix-chars-从文件中读取参数时文件的前缀字符集" class="headerlink" title="fromfile_prefix_chars-从文件中读取参数时文件的前缀字符集"></a>fromfile_prefix_chars-从文件中读取参数时文件的前缀字符集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'args.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>   fp.write(<span class="string">'-f\nbar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(fromfile_prefix_chars=<span class="string">'@'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-f'</span>, <span class="string">'foo'</span>, <span class="string">'@args.txt'</span>])</span><br><span class="line">Namespace(f=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p>当<strong>参数过多</strong>时，可以<strong>将参数放到文件中读取</strong>，例子中<code>parser.parse_args([&#39;-f&#39;, &#39;foo&#39;, &#39;@args.txt&#39;])</code><strong>解析时会从文件args.txt读取，相当于<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;-f&#39;, &#39;bar&#39;]</code></strong></p><hr><h3 id="add-help-解析器添加-h-–help-选项"><a href="#add-help-解析器添加-h-–help-选项" class="headerlink" title="add_help-解析器添加-h/–help 选项"></a>add_help-解析器添加-h/–help 选项</h3><p>设为 <code>False</code> 时，<code>help</code> 信息里面不再显示 <code>-h --help</code> 信息</p><div class="note info"><p>以上是我觉得比较重要的参数，但不是全部参数，具体参数的解释请参考<a href="https://docs.python.org/3/library/argparse.html#argumentparser-objects" target="_blank" rel="noopener">官方文档</a></p></div><hr><h3 id="allow-abbrev-长参数缩写"><a href="#allow-abbrev-长参数缩写" class="headerlink" title="allow_abbrev-长参数缩写"></a>allow_abbrev-长参数缩写</h3><p>参考后面解析参数<code>-parse_args()</code>的参数缩写</p><hr><p><br></p><h2 id="添加参数-add-argument"><a href="#添加参数-add-argument" class="headerlink" title="添加参数-add_argument()"></a>添加参数-add_argument()</h2><p>创建解析器之后如果需要为程序序添加参数选项需要用 ArgumentParser 对象的 <code>add_argument</code> 方法，该方法原型如下:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name <span class="keyword">or</span> flags...[, action][, nargs]</span><br><span class="line">                                            [, const][, default]</span><br><span class="line">                                            [, type][, choices]</span><br><span class="line">                                            [, required][, help]</span><br><span class="line">                                            [, metavar][, dest])</span><br></pre></td></tr></table></figure><p></p><table><tr><th width="20%">参数</th><th width="80%">含义</th></tr><tr><td>name or flags</td><td>选项字符串的名字或者列表，例如foo 或者-f, --foo</td></tr><tr><td>action</td><td>在命令行遇到该参数时采取的基本动作类型</td></tr><tr><td>nargs</td><td>应该读取的命令行参数个数</td></tr><tr><td>const</td><td>某些action和nargs选项要求的常数值</td></tr><tr><td>default</td><td>如果命令行中没有出现该参数时的默认值</td></tr><tr><td>type</td><td>命令行参数应该被转换成的类型</td></tr><tr><td>choices</td><td>包含参数可允许的值的一个容器</td></tr><tr><td>required</td><td>该命令行选项是否可以省略(只针对可选参数)</td></tr><tr><td>help</td><td>参数的简短描述</td></tr><tr><td>metavar</td><td>参数在帮助信息中的名字</td></tr><tr><td>dest</td><td>给parse_args()返回的对象要添加的属性名称</td></tr></table><h3 id="位置参数和可选参数"><a href="#位置参数和可选参数" class="headerlink" title="位置参数和可选参数"></a>位置参数和可选参数</h3><p>在学习具体的各个参数的含义之前，先了解一下argparse中的两种参数类型：<strong>位置参数</strong>和<strong>可选参数</strong>，<strong>位置参数在定义时没有前缀，而可选参数需要加前缀（默认为’-‘）</strong>。</p><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在前面的代码中按如下进行修改</span></span><br><span class="line"><span class="comment"># 添加echo这个位置参数，且定义参数的帮助信息</span></span><br><span class="line">parser.add_argument(<span class="string">"echo"</span>, help = <span class="string">"echo the string you use here"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="keyword">print</span> args.echo</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [-h] echo</p><p><strong>positional arguments:</strong><br>echo echo the string you use here</p><p><strong>optional arguments:</strong><br>-h, –help show this help message and exit</p></blockquote><p>如果直接使用<code>python argparse_test.py</code>运行程序，不加参数：</p><blockquote><p>python argparse_test.py<br>usage: argparse_test.py [-h] echo<br>argparse_test.py: <strong>error: the following arguments are required: echo</strong></p></blockquote><p>位置参数<strong>相当于默认情况下使用了参数，如果不进行传参会报错</strong>，当然这可以通过<code>action=&#39;store_true&#39;</code>解决</p><p>使用<code>python argparse_test.py test</code>运行程序：</p><blockquote><p>python argparse_test.py test<br>test</p></blockquote><p>在添加参数后程序正常执行，输出参数值(<strong>通过解析后，参数的值保存在<code>echo</code>变量中</strong>)</p><hr><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>可选参数有两种：</p><ul><li>通过一个<code>-</code>来指定的<strong>短参数</strong>，如<code>-h</code></li><li>通过<code>--</code>来指定的<strong>长参数</strong>，如<code>--help</code></li><li>长参数是完整版，使用比较麻烦，而短参数则是简写版，便于使用，两个可以同时存在，也可以只写其中一个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br></pre></td></tr></table></figure><p>显示出帮助信息：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-v VERBOSITY]</p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>-v <code>VERBOSITY</code>, –verbosity <code>VERBOSITY</code></strong><br><strong>increase output verbosity</strong></p></blockquote><p>可选参数<code>-v</code>或<code>--verbosity</code>，通过解析后，其<strong>值保存在<code>args.verbosity</code>变量</strong>中:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一句</span></span><br><span class="line"><span class="keyword">print</span> (args.verbosity)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -v 2</code><br>2</p></blockquote><div class="note info"><ul><li>位置参数和可选参数是通过<code>-</code>来区分，如果不加<code>-</code>，<code>argparse</code>会将其当做位置参数解析</li><li>位置参数在解析时，值存储在位置参数同名的变量中；可选参数在解析时，如果没有添加长参数，则和位置参数一样，储存在同名变量中，而如果添加了长参数，则存储在长参数的变量中</li></ul></div><hr><h3 id="name-or-flags-参数名"><a href="#name-or-flags-参数名" class="headerlink" title="name or flags-参数名"></a>name or flags-参数名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加位置参数，echo即为参数名</span></span><br><span class="line">parser.add_argument(<span class="string">"echo"</span>, help = <span class="string">"echo the string you use here"</span>)</span><br><span class="line"><span class="comment"># 添加可选参数，-v和--verbosity都为参数名</span></span><br><span class="line">parser.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="action-对参数采取的动作"><a href="#action-对参数采取的动作" class="headerlink" title="action-对参数采取的动作"></a>action-对参数采取的动作</h3><p>action包括六种不同的取值，分别为<code>store(默认选项)</code>、<code>store_const</code>、<code>store_true</code>、<code>store_false</code>、<code>append</code>、<code>append_const</code>、<code>count</code>、<code>help</code>、<code>version</code>。</p><h4 id="只存储值–action-’store"><a href="#只存储值–action-’store" class="headerlink" title="只存储值–action=’store"></a>只存储值–action=’store</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store'</span>)</span><br></pre></td></tr></table></figure><p>这是默认情况，可以不用加，<strong>这种情况如果使用了参数但是不传入值，就会报错</strong></p><hr><h4 id="常量参数–action-’store-const’"><a href="#常量参数–action-’store-const’" class="headerlink" title="常量参数–action=’store_const’"></a>常量参数–action=’store_const’</h4><p><code>store_const</code>，表示参数为固定值，该固定值存放在 <code>const</code> 中:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_const'</span>, const=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py --foo</code><br>42</p></blockquote><p><strong>不能修改值(默认值，不能修改)</strong>，如果修改值就会报错：</p><blockquote><p><code>python argparse_test.py --foo 20</code><br>usage: argparse_test.py [-h] [–foo]<br>argparse_test.py: error: unrecognized arguments: 20</p></blockquote><hr><h4 id="True-or-False–store-true和store-false"><a href="#True-or-False–store-true和store-false" class="headerlink" title="True or False–store_true和store_false"></a>True or False–store_true和store_false</h4><p>store_true和store_false，值存为 True 或 False。这个很实用，比如前面<strong>在位置参数中如果直接执行(可选参数也是一样，不过需要调用)，不对参数传值的话就会报错，但是设置这个之后参数即使不传参，调用后也会返回值，不过是True或者False：</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用<code>python argparse_test.py --foo</code>执行程序：</p><blockquote><p>usage: argparse_test.py [-h] [–foo FOO]<br>argparse_test.py: error: argument –foo: expected one argument</p></blockquote><blockquote><p>True</p></blockquote><hr><h4 id="存储列表参数-action-’append’"><a href="#存储列表参数-action-’append’" class="headerlink" title="存储列表参数-action=’append’"></a>存储列表参数-action=’append’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'append'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo 2 --foo 3</code><br>[‘2’, ‘3’]</p></blockquote><hr><h4 id="参数出现次数–action-’count’"><a href="#参数出现次数–action-’count’" class="headerlink" title="参数出现次数–action=’count’"></a>参数出现次数–action=’count’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'count'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo --foo</code><br>2</p></blockquote><hr><h4 id="保存常量到列表–action-’append-const’"><a href="#保存常量到列表–action-’append-const’" class="headerlink" title="保存常量到列表–action=’append_const’"></a>保存常量到列表–action=’append_const’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-A'</span>, action=<span class="string">'append_const'</span>, dest=<span class="string">'const_collection'</span>,</span><br><span class="line">        const=<span class="string">'value-1-to-append'</span>,</span><br><span class="line">        default=[],</span><br><span class="line">        help=<span class="string">'Add different values to list'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-B'</span>, action=<span class="string">'append_const'</span>, dest=<span class="string">'const_collection'</span>,</span><br><span class="line">        const=<span class="string">'value-2-to-append'</span>,</span><br><span class="line">        help=<span class="string">'Add different values to list'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py -A -B</code><br>[‘value-1-to-append’, ‘value-2-to-append’]</p></blockquote><p>可以参考上面的<code>action=&#39;store_const&#39;</code></p><hr><h4 id="版本信息–action-’version’"><a href="#版本信息–action-’version’" class="headerlink" title="版本信息–action=’version’"></a>版本信息–action=’version’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 2.0'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --version</code><br>argparse_test.py 2.0</p></blockquote><hr><h3 id="nargs-参数数量"><a href="#nargs-参数数量" class="headerlink" title="nargs-参数数量"></a>nargs-参数数量</h3><p>参数可以传入的值的数目，可以为：</p><ul><li><strong>整数<code>N</code></strong>：<strong>N个</strong>传入值，返回传入值的<strong>列表</strong>，即使为1， 也返回列表</li><li><strong><code>&#39;*&#39;</code></strong>：<strong>任意多个传入值(包括0个)</strong>，返回<strong>列表</strong></li><li><strong><code>&#39;+&#39;</code></strong>：<strong>一个或更多</strong>，不加传入值的时候会报错，返回<strong>列表</strong></li><li><strong><code>&#39;?&#39;</code></strong>：首先从命令行获得参数，若没有则从const获得，然后从default获得；还可以使用该参数<mark>指定输入和输出文件</mark></li><li><strong><code>argparse.REMAINDER</code></strong>：将<strong>剩余的参数</strong>作为<strong>列表</strong>搜集起来</li></ul><h4 id="整数N"><a href="#整数N" class="headerlink" title="整数N"></a>整数N</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo 1 2</code><br>[‘1’, ‘2’]</p></blockquote><p><strong>注意使用整数N(N个)时返回的是一个列表，即使N=1，返回的也是一个元素的列表，这和默认行为(传入一个参数)返回传入值本身不同</strong></p><hr><h4 id="使用-39-39-进行文件操作"><a href="#使用-39-39-进行文件操作" class="headerlink" title="使用&#39;?&#39;进行文件操作"></a>使用<code>&#39;?&#39;</code>进行文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件，默认值为从标准输入读取</span></span><br><span class="line">parser.add_argument(<span class="string">'infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>),</span><br><span class="line">                     default=sys.stdin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件，默认值为标准输出</span></span><br><span class="line">parser.add_argument(<span class="string">'outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>),</span><br><span class="line">                     default=sys.stdout)</span><br></pre></td></tr></table></figure><div class="note info"><p>如果没有提供<code>nargs</code>参数，传入值的数量将由<code>action</code>决定，通常情况下只有一个参数</p></div><hr><h3 id="const-保存常量"><a href="#const-保存常量" class="headerlink" title="const-保存常量"></a>const-保存常量</h3><p>在以下两种情况使用：</p><ul><li><code>action</code>中的<code>action=&#39;store_const&#39;</code>和<code>action=&#39;append_const&#39;</code>给参数设置固定值</li><li><code>nargs</code>中的<code>&#39;?&#39;</code>，首先从命令行获得参数，若没有则从const获得，然后从default获得</li></ul><hr><h3 id="default-设置默认值"><a href="#default-设置默认值" class="headerlink" title="default-设置默认值"></a>default-设置默认值</h3><p>和前面的<code>const</code>的区别在于：const设置之后不能修改这个值，但是default设置之后只有命令行中没有传入参数值才会使用default，传入值的话就使用传入的值。</p><hr><h3 id="type-参数类型"><a href="#type-参数类型" class="headerlink" title="type-参数类型"></a>type-参数类型</h3><p><strong>默认情况下将传入的参数值统一作为字符读入</strong>，可以通过设置type来确定传入的参数值的类型：</p><ul><li><strong>type=float：浮点</strong></li><li><strong>type=float：整型</strong></li><li><p><strong>type=argparse.FileType()</strong>：创建可写入文件，其中的参数包括<code>mode=</code>、<code>bufsize=</code>、<code>encoding=</code>和<code>errors=</code>，前面的<code>nargs</code>中的<code>&#39;?&#39;</code>也是用于文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>, type=argparse.FileType(mode=<span class="string">'w'</span>,encoding=<span class="string">'UTF-8'</span>))</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python argparse_test.py out.txt</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   &lt;_io.TextIOWrapper name='out.txt' mode='w' encoding='UTF-8'&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>type还可以接受一个可以调用的函数(输入单个字符，返回转化后的类型)</p></li></ul><hr><h3 id="choices-参数的范围"><a href="#choices-参数的范围" class="headerlink" title="choices-参数的范围"></a>choices-参数的范围</h3><ul><li>choices设置参数的范围，例如通过<code>choices=range(1, 4)</code>设定数字的，也可以通过<code>choices=[&#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]</code>设置字符的</li><li><strong>需要注意：传入值先进行<code>type</code>的类型转换，然后才看检查<code>choices</code>范围，所以<code>choices</code>范围的类型要和<code>type</code>一致</strong></li><li><strong>支持<code>in操作(for i in sth)</code>的都可以作为<code>choices</code>的范围，例如常规的<code>dict</code>、<code>set</code>、<code>list</code>等</strong></li></ul><hr><h3 id="required-参数是否必须"><a href="#required-参数是否必须" class="headerlink" title="required-参数是否必须"></a>required-参数是否必须</h3><ul><li><strong><code>required</code>只针对可选参数</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, required=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用的时候如果不加--foo</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     argparse.py: error: option --foo is required</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="help-参数的帮助信息"><a href="#help-参数的帮助信息" class="headerlink" title="help-参数的帮助信息"></a>help-参数的帮助信息</h3><ul><li>对参数的简短描述，可以帮助选择参数</li><li><p>为了避免与<code>argparse</code>的参数重叠，帮助信息中的有些关键字(<code>prog</code>、<code>default</code>)可以使用<code>%</code>包围(文字中需要出现<code>%</code>的话用<code>%%</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>, type=int, default=<span class="number">42</span>,</span><br><span class="line">                     help=<span class="string">'the bar to %(prog)s (default: %(default)s)'</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 显示帮助信息时：</span></span><br><span class="line"><span class="comment">#   usage: frobble [-h] [bar]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   positional arguments:</span></span><br><span class="line"><span class="comment">#    bar     the bar to frobble (default: 42)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不输出某个参数的帮助信息，使用<code>help=argparse.SUPPRESS</code></strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=argparse.SUPPRESS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示帮助信息时显示：</span></span><br><span class="line"><span class="comment">#  usage: frobble [-h]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  optional arguments:</span></span><br><span class="line"><span class="comment">#   -h, --help  show this help message and exit</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="metavar-参数在帮助信息中的名称"><a href="#metavar-参数在帮助信息中的名称" class="headerlink" title="metavar-参数在帮助信息中的名称"></a>metavar-参数在帮助信息中的名称</h3><p>默认情况下，参数使用<code>dest</code>值作为名称，例如位置参数的参数名称就是位置参数的名称，而可选参数如果使用了长参数则是长参数的名称，如果<strong>只使用了短参数</strong>则是短参数的名称(前面位置参数也有讲解)</p><p>默认情况：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–foo <strong>FOO</strong>] <strong>bar</strong></p><p>positional arguments:<br>bar</p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>–foo FOO</strong></p></blockquote><p><strong>通过metavar设置</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, metavar=<span class="string">'YYY'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>, metavar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–foo <strong>YYY</strong>] <strong>XXX</strong></p><p>positional arguments:<br><strong>XXX</strong></p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>–foo YYY</strong></p></blockquote><p>可以发现上述加粗的地方的名称出现了改变</p><p><strong>需要注意的是<code>metavar</code>只是改变了名称的显示内容，真正的变量解析的名称还是有<code>dest</code>决定</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上述输出变量值，使用metavar设置的名称</span></span><br><span class="line"><span class="keyword">print</span> (args.YYY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述输出变量值，使用dest的名称</span></span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><p><code>print (args.YYY)</code>的输出：</p><blockquote><p><code>python argparse_test.py --foo test test2</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.YYY)<br>AttributeError: <strong>‘Namespace’ object has no attribute ‘YYY’</strong></p></blockquote><p><code>print (args.foo)</code>的输出：</p><blockquote><p><code>python argparse_test.py --foo test test2</code><br>test</p></blockquote><p><strong>可以发现只有使用<code>print (args.foo)</code>才能正常输出，说明参数解析存放的变量还是没变，<code>metavar</code>设置的名称只是改变了显示形式</strong></p><div class="note info"><ul><li>参数解析存放的变量还是没变(还是由<code>dest</code>决定)，<code>metavar</code>设置的名称只是改变了显示形式</li><li>如果参数设置了<code>nargs</code>(例如：nargs=2)，会导致<code>metavar</code>设置的名称(如果只指定了一个名称)重复出现</li></ul></div><hr><h3 id="dest-传入值的属性名称"><a href="#dest-传入值的属性名称" class="headerlink" title="dest-传入值的属性名称"></a>dest-传入值的属性名称</h3><ul><li>如果<strong>存在长参数(–开头的)</strong>，则<code>dest</code>取<strong>第一个长参数的值作为属性名称</strong>；</li><li>如果<strong>没有长参数</strong>，则<code>dest</code>取<strong>第一个短参数的值作为属性名称</strong></li><li>所有字符中间的<code>-</code>都会被转化为<code>_</code>，保证属性名称是有效的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-x'</span>, <span class="string">'-y'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用第一个长参数以及将-转化为_</span></span><br><span class="line"><span class="keyword">print</span> (args.foo_bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用第二个长参数</span></span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.y)</span><br></pre></td></tr></table></figure><p><strong>查看帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-f <strong>FOO_BAR</strong>] [-x <strong>X</strong>]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-f <strong>FOO_BAR</strong>, –foo-bar <strong>FOO_BAR</strong>, –foo <strong>FOO_BAR</strong><br>-x <strong>X</strong>, -y <strong>X</strong></p></blockquote><p><strong>使用第一个长参数以及将<code>-</code>转化为<code>_</code></strong>：</p><blockquote><p><code>python argparse_test.py --foo test</code><br>test</p></blockquote><p><strong>如果使用短参数</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.f)<br>AttributeError: <strong>‘Namespace’ object has no attribute ‘f’</strong></p></blockquote><p><strong>如果使用第二个长参数</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in<module><br>print (args.foo)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘foo’</strong></module></p></blockquote><p><strong>第一个短参数</strong>:</p><blockquote><p><code>python argparse_test.py -x test</code><br>test</p></blockquote><p><strong>第二个短参数</strong>:</p><blockquote><p><code>python argparse_test.py -x test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.y)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘y’</strong></p></blockquote><p><mark>使用dest自定义属性名称</mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>,dest=<span class="string">"my_set"</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果还使用最开始的foo_bar</span></span><br><span class="line"><span class="keyword">print</span> (args.foo_bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的my_set</span></span><br><span class="line"><span class="keyword">print</span> (args.my_set)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-f <strong>MY_SET</strong>]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-f <strong>MY_SET</strong>, –foo-bar <strong>MY_SET</strong>, –foo <strong>MY_SET</strong></p></blockquote><p><strong>如果还使用最开始的foo_bar</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 5, in \&lt;module><br>print (args.foo_bar)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘foo_bar’</strong></p></blockquote><p><strong>使用自定义的my_set</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>test</p></blockquote><div class="note info"><p><strong><code>dest</code>就是命令行参数(传入值)在经过解析后存储的变量名</strong>，默认情况下：</p><ul><li>如果存在长参数，就是第一个长参数的值(<code>--</code>后面接着的字符串)</li><li>如果不存在长参数，就是第一个短参数的值(<code>-</code>后面接着的字符串)</li><li>参数中间的<code>-</code>都会被转化为<code>_</code>，保证属性名称是有效的</li></ul><p><strong>当然可以通过<code>dest</code>参数进行自定义解析后存储的变量名</strong></p></div><hr><p><br></p><h2 id="解析参数-parse-args"><a href="#解析参数-parse-args" class="headerlink" title="解析参数-parse_args()"></a>解析参数-parse_args()</h2><p>上述添加完所有参数之后，就可以给 <code>parse_args()</code> 传递一组参数字符串来解析命令行。<strong>默认情况下</strong>，参数是从 <code>sys.argv[1:]</code> 中获取，但你也可以传递自己的参数列表。因为一般使用argparse都是用来解析命令行参数，所以使用其默认情况即可，这里对自己传递参数的方法没有进行学习，需要的时候可以去看官方文档。<br><code>parse_args()</code> 的返回值是一个命名空间，包含传递给命令的参数。<strong>该对象将参数保存其属性</strong>，因此如果你的参数 <code>dest</code> 是 <code>&quot;myoption&quot;</code>，那么你就可以<code>args.myoption</code> 来访问该值(可以参考前面<code>dest</code>的用法).<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.parse_args(args=<span class="keyword">None</span>, namespace=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>args</code> - List of strings to parse. <strong>The default is taken from sys.argv</strong>.</li><li><code>namespace</code> - An object to take the attributes. <strong>The default is a new empty Namespace object</strong>.</li></ul><hr><p><br></p><h3 id="参数缩写"><a href="#参数缩写" class="headerlink" title="参数缩写"></a>参数缩写</h3><p>parse_args()默认允许长参数缩写为前缀(前缀是不相同的)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-bacon'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-badger'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-bac MMM'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="string">'MMM'</span>, badger=None)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-bad WOOD'</span>.split())</span><br><span class="line">Namespace(bacon=None, badger=<span class="string">'WOOD'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-ba BA'</span>.split())</span><br><span class="line">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span><br><span class="line">PROG: error: ambiguous option: -ba could match -badger, -bacon</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="解析部分参数-parse-known-args"><a href="#解析部分参数-parse-known-args" class="headerlink" title="解析部分参数-parse_known_args()"></a>解析部分参数-parse_known_args()</h3><p>有时间一个脚本只需要解析所有命令行参数中的一小部分，剩下的命令行参数给另一个脚本或者程序。在这种情况下，<code>parse_known_args()</code>就很有用。它很像<code>parse_args()</code>，但是它在接受到多余的命令行参数时不报错。相反的，返回一个tuple类型的命名空间和一个保存着余下的命令行字符的list。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse </span><br><span class="line">parser = argparse.ArgumentParser() </span><br><span class="line">parser.add_argument( </span><br><span class="line">    <span class="string">'--flag_int'</span>, </span><br><span class="line">    type=float, </span><br><span class="line">    default=<span class="number">0.01</span>, </span><br><span class="line">    help=<span class="string">'flag_int.'</span> </span><br><span class="line">) </span><br><span class="line">FLAGS, unparsed = parser.parse_known_args() </span><br><span class="line">print(FLAGS.flag_int) </span><br><span class="line">print(unparsed)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py --flag_int 0.02 --double 0.03 a 1</code><br>0.02<br>[‘–double’, ‘0.03’, ‘a’, ‘1’]</p></blockquote><p>binbin师兄的项目中有所使用，可以看看</p><hr><p><br></p><h2 id="参数群组"><a href="#参数群组" class="headerlink" title="参数群组"></a>参数群组</h2><p><code>argparse</code>能将参数定义组合成“群组”。<strong>默认情况下是使用两个群组，一个是可选参数的群组，另一个是必须的位置参数的群组</strong>，这可以在程序的帮助信息中看到，使用<code>optional arguments</code>和<code>positional arguments</code>将群组分开，可以参考前面的位置参数和可选参数部分</p><p>在实际使用中，<strong>可以调整群组来提高帮助信息中群组的逻辑性，这样相关选项或值能记录在一起</strong>。可以使用自定义群组来重写之前的共享选项的示例，如在帮助信息中身份认证的选项就可以显示在一起：<br><strong>第一步</strong>：在基础解析器中使用<code>add_argument_group()</code>来<strong>创建一个“身份认证”群组</strong>，然后逐个添加身份认证相关的选项到该群组<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparser.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 创建名为authentication的群组</span></span><br><span class="line">group = parser.add_argument_group(<span class="string">'authentication'</span>)</span><br><span class="line"><span class="comment"># 给这个群组添加参数</span></span><br><span class="line">group.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">group.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure><p></p><p>以上内容保存在名为<code>argparse_parent_with_group.py</code>的文件中</p><p><strong>第二步</strong>：和之前parent中讲到的一样进行参数继承<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> argparse_parent_with_group</span><br><span class="line"><span class="comment"># 继承参数，注意parent中是ArgumentParser类，所以这里依然导入的是parser，而不是group</span></span><br><span class="line">parser = argparse.ArgumentParser(parents=[argparse_parent_with_group.parser])</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--local-arg'</span>, action=<span class="string">"store_true"</span>, default=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (parser.parse_args())</span><br></pre></td></tr></table></figure><p></p><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">python argparse_test.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">usage: argparse_test.py [-h] [--user USER] [--password PASSWORD] [--local-arg]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">  --local-arg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的群组</span></span><br><span class="line">authentication:</span><br><span class="line">  --user USER</span><br><span class="line">  --password PASSWORD</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="创建子命令"><a href="#创建子命令" class="headerlink" title="创建子命令"></a>创建子命令</h2><p>有时候，我们可以根据功能将命令行分组成一系列相关的子命令，为了实现这种分组行为argparse提供了ArgumentParser.add_subparsers()方法，其使用如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_subparsers([title][, description][, prog]</span><br><span class="line">                              [, parser_class][, action][, option_string]</span><br><span class="line">                              [, dest][, required][, help][, metavar])</span><br></pre></td></tr></table></figure><p></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成参数分析器</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'cmd'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sub-commands</span></span><br><span class="line">sub_parser = parser.add_subparsers(title=<span class="string">'subcommands'</span>,</span><br><span class="line">                                description=<span class="string">'valid subcommands'</span>,</span><br><span class="line">                                help=<span class="string">'config subscommand help'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第一个分组，相当于单个分组中的argparse.ArgumentParser</span></span><br><span class="line">add_parser = sub_parser.add_parser(<span class="string">'add'</span>,help=<span class="string">'add user config'</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">add_parser.add_argument(<span class="string">'--name'</span>, required=<span class="keyword">True</span>, help=<span class="string">'user name'</span>)</span><br><span class="line">add_parser.add_argument(<span class="string">'--addr'</span>, required=<span class="keyword">False</span>, help=<span class="string">'user address'</span>)</span><br><span class="line">add_parser.add_argument(<span class="string">'--phone'</span>, required=<span class="keyword">False</span>, help=<span class="string">'phone number'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第二个分组</span></span><br><span class="line">delete_parser = sub_parser.add_parser(<span class="string">'delete'</span>, help=<span class="string">'delete user config'</span>)</span><br><span class="line">delete_parser.add_argument(<span class="string">'--name'</span>, required=<span class="keyword">True</span>, help=<span class="string">'user name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第三个分组</span></span><br><span class="line">show_parser = sub_parser.add_parser(<span class="string">'show'</span>, help=<span class="string">'show user config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py -h</code><br>usage: cmd [-h] {add,delete,show} …</p><p>optional arguments:<br>-h, –help show this help message and exit</p><p>subcommands:<br>valid subcommands</p><p>{add,delete,show} config subscommand help<br>add add user config<br>delete delete user config<br>show show user config</p></blockquote><p><strong>上述过程讲解：</strong><br><code>ArgumentParser</code>对象使用<code>add_subparsers()</code>方法创建子命令组；该方法通常在调用的时候不传递参数，并返回一个特殊的action实例，这个实例只有一个方法：<code>add_parser()</code>；对这个实例分别调用<code>add_parser()</code>方法来创建子命令对应的<code>ArgumentParser</code>(包含了其所有可以使用的参数，还包含了一个子命令组名称的参数)，再调用这个<code>ArgumentParser</code>实例的<code>add_argument()</code>方法来添加子命令的参数。</p><p>从上述帮助输出可以看出，<strong>对整体使用-h不会返回每个子命令组详细的帮助信息，如果想查看每个子命令组详细的帮助信息需要使用<code>python argparse_test.py add -h</code></strong>:</p><blockquote><p><code>python argparse_test.py add -h</code><br>usage: cmd add [-h] –name NAME [–addr ADDR] [–phone PHONE]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>–name NAME user name<br>–addr ADDR user address<br>–phone PHONE phone number</p></blockquote><p><mark>通过<code>ArgumentParser</code>的<code>set_defaults()</code>方法来设置不同的子命令执行的函数</mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置子命令add的执行函数为add_fn</span></span><br><span class="line">add_parser.set_defaults(func=add_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子命令delete的执行函数为delete_fn</span></span><br><span class="line">delete_parser.set_defaults(func=delete_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子命令show的执行函数为show_fn</span></span><br><span class="line">show_parser.set_defaults(func=show_fn)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建互斥参数"><a href="#创建互斥参数" class="headerlink" title="创建互斥参数"></a>创建互斥参数</h2><p>使用<code>ArgumentParser</code>的<code>add_mutually_exclusive_group()</code>来创建互斥参数组：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"calculate X to the power of Y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建互斥参数</span></span><br><span class="line">group = parser.add_mutually_exclusive_group()</span><br><span class="line">group.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbose"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">group.add_argument(<span class="string">"-q"</span>, <span class="string">"--quiet"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"x"</span>, type=int, help=<span class="string">"the base"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"y"</span>, type=int, help=<span class="string">"the exponent"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">answer = args.x**args.y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.quiet:</span><br><span class="line">    <span class="keyword">print</span> (answer)</span><br><span class="line"><span class="keyword">elif</span> args.verbose:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125;^&#123;&#125; == &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br></pre></td></tr></table></figure><p></p><p><strong>查看帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] <strong>[-v | -q]</strong> x y</p><p>calculate X to the power of Y</p><p>positional arguments:<br>x the base<br>y the exponent</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-v, –verbose<br>-q, –quiet</p></blockquote><p><strong>如果同时使用会报错</strong>：</p><blockquote><p><code>python argparse_test.py -v -q</code><br>usage: argparse_test.py [-h] [-v | -q] x y<br><strong>argparse_test.py: error: argument -q/–quiet: not allowed with argument -v/–verbose</strong></p></blockquote><p><strong><code>add_mutually_exclusive_group(required=True)</code>支持<code>required=True</code>参数(但是不支持title和description参数)，表明两个互斥的参数中必须使用一个</strong></p><hr><p><br></p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ul><li>可以将<strong>共有的参数放在一个父参数文件中，然后其他的文件直接导入(<code>parent</code>的使用)</strong>，这样比较简单</li><li>参数群组(<code>add_argument_group()</code>)，<strong>可以自己组织参数出现的分组，看着比较清晰</strong>，如果没有必要用到子命令(<code>add_subparsers()</code>)的时候可以尝试一下</li><li><mark>如果传入参数只带有双引号，需要对双引号进行转义，否则接受的参数中将不含双引号</mark></li><li>如果传入的参数带有<mark>空格</mark>，传入时可以<strong>使用双引号将其括起来：<code>-d &quot;abc def&quot;</code></strong></li></ul><hr><h2 id="实战添加"><a href="#实战添加" class="headerlink" title="实战添加"></a>实战添加</h2><h3 id="添加带有格式的帮助信息"><a href="#添加带有格式的帮助信息" class="headerlink" title="添加带有格式的帮助信息"></a>添加带有格式的帮助信息</h3><p>在帮助信息中如果想要换行显示等，需要在创建解析器的时候使用<code>RawTextHelpFormatter</code>类：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会识别\n，从而达到换行的目的</span></span><br><span class="line"><span class="comment"># 注意直接使用\n就可以达到换行的目的</span></span><br><span class="line"><span class="comment"># 不用继续使用回车键</span></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">"""change sequence library name download from nova \npython single_cell_change_name.py -d /workstation/songyabing/projects/rat/190703_data -s - -S 2"""</span>,</span><br><span class="line">        formatter_class=argparse.RawTextHelpFormatter)</span><br></pre></td></tr></table></figure><p></p><p>参考链接：<a href="https://stackoverflow.com/questions/29613487/multiple-lines-in-python-argparse-help-display/29613565" target="_blank" rel="noopener">Multiple lines in python argparse help display</a></p><hr><h3 id="添加子命令"><a href="#添加子命令" class="headerlink" title="添加子命令"></a>添加子命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'some useful functions for dealing with genome fasta'</span></span><br><span class="line">                                  ,formatter_class=argparse.RawTextHelpFormatter)</span><br><span class="line">sub_parser = parser.add_subparsers()</span><br><span class="line"></span><br><span class="line">extract_parser = sub_parser.add_parser(<span class="string">'extract'</span>,help=<span class="string">'extract chr(s) genome fasta \npython fasta_utils.py extract -i Ca22chrA.fa -c chrR -o test.genome'</span>)</span><br><span class="line">extract_parser.add_argument(<span class="string">'--in_genome'</span>,<span class="string">'-i'</span>, type=str ,help=<span class="string">'input reference genome'</span>)</span><br><span class="line">extract_parser.add_argument(<span class="string">'--chr_names'</span>,<span class="string">'-c'</span>, nargs=<span class="string">'+'</span>, type=str, help=<span class="string">'chr names to extract'</span>)</span><br><span class="line">extract_parser.add_argument(<span class="string">'--out_genome'</span>,<span class="string">'-o'</span>, type=str ,help=<span class="string">'output file for modified genome'</span>)</span><br><span class="line"></span><br><span class="line">replace_parser = sub_parser.add_parser(<span class="string">'replace'</span>,help=<span class="string">'replace chr(s) genome fasta \npython fasta_utils.py replace -i Ca22chrA.fa -c chrM -r genome.fa -C chrM -o test_replece.fa'</span>)</span><br><span class="line">replace_parser.add_argument(<span class="string">'--in_genome'</span>,<span class="string">'-i'</span>, type=str ,help=<span class="string">'input reference genome'</span>)</span><br><span class="line">replace_parser.add_argument(<span class="string">'--chr_names'</span>,<span class="string">'-c'</span>, nargs=<span class="string">'+'</span>, type=str, help=<span class="string">'chr names to extract'</span>)</span><br><span class="line">replace_parser.add_argument(<span class="string">'--out_genome'</span>,<span class="string">'-o'</span>, type=str ,help=<span class="string">'output file for modified genome'</span>)</span><br><span class="line">replace_parser.add_argument(<span class="string">'--replace_genome'</span>,<span class="string">'-r'</span>, type=str ,help=<span class="string">'input genome file to replace chr in reference genome'</span>)</span><br><span class="line">replace_parser.add_argument(<span class="string">'--replace_chrs'</span>,<span class="string">'-C'</span>, nargs=<span class="string">'+'</span>, type=str ,help=<span class="string">'chr names in replace genome to replace input genome'</span>)</span><br><span class="line"></span><br><span class="line">length_parser = sub_parser.add_parser(<span class="string">'length'</span>,help=<span class="string">'extract genome chr(s) length'</span>)</span><br><span class="line">length_parser.add_argument(<span class="string">'--in_genome'</span>,<span class="string">'-i'</span>, type=str ,help=<span class="string">'input reference genome'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定子命令运行的功能</span></span><br><span class="line">extract_parser.set_defaults(func=extract_chrs)</span><br><span class="line">replace_parser.set_defaults(func=replace_chrs)</span><br><span class="line">length_parser.set_defaults(func=get_genome_length)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是必须的</span></span><br><span class="line">args.func(args)</span><br></pre></td></tr></table></figure><p><strong>运行示例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">python fasta_utils.py --<span class="built_in">help</span></span><br><span class="line">usage: fasta_utils.py [-h] &#123;extract,replace,length&#125; ...</span><br><span class="line"></span><br><span class="line">some useful <span class="built_in">functions</span> <span class="keyword">for</span> dealing with genome fasta</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;extract,replace,length&#125;</span><br><span class="line">    extract             extract chr(s) genome fasta </span><br><span class="line">                        python fasta_utils.py extract -i Ca22chrA.fa -c chrR -o test.genome</span><br><span class="line">    replace             replace chr(s) genome fasta </span><br><span class="line">                        python fasta_utils.py replace -i Ca22chrA.fa -c chrM -r genome.fa -C chrM -o test_replece.fa</span><br><span class="line">    length              extract genome chr(s) length</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="关于bool参数出错"><a href="#关于bool参数出错" class="headerlink" title="关于bool参数出错"></a>关于bool参数出错</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在某个程序中我想通过对参数bool值的判断来采取不同的函数处理，参数的设置如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--lane_flag'</span>, <span class="string">'-f'</span>, type=bool, default=<span class="keyword">True</span>,help=<span class="string">'lane indicator'</span>)</span><br></pre></td></tr></table></figure><p></p><p>但是实际使用过程中，<mark>即使我将该参数设置为false，但是<strong>仍然按照该参数为true的情况</strong>进行处理</mark></p><p>在<code>stackoverflow</code>上有人说<code>for a boolean switch, is not a common pattern to use</code>，也就是说bool值的变换其实不是一个很好的处理方式，但是如果使用了可以怎么理解和解决这种现象呢？</p><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><blockquote><p>As for your issue, remember that the <strong>command line value is a string</strong> and, <code>type=bool</code> means that you want <code>bool(entered-string-value)</code> to be applied. For <code>--foo False</code> that means <code>bool(&quot;False&quot;)</code>, producing <code>True</code>; <code>all non-empty strings are true</code>!</p></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用<a href="#true-or-false--storetrue%e5%92%8cstorefalse">action</a>来<code>代替bool参数类型</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="comment"># parser.add_argument('--foo', action='store_false')</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><p><strong>使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用该参数时就可以得到其存储的值</span></span><br><span class="line"><span class="comment"># 不需要对齐进行赋值操作，否则会报错</span></span><br><span class="line">python test.py --foo </span><br><span class="line">  True</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不调用该参数的时候就会得到false</span></span><br><span class="line">python test.py </span><br><span class="line">  False</span><br></pre></td></tr></table></figure><p></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://stackoverflow.com/questions/41655897/why-is-argparse-not-parsing-my-boolean-flag-correctly" target="_blank" rel="noopener">Why is argparse not parsing my boolean flag correctly? [duplicate]</a></li><li><a href="https://stackoverflow.com/questions/52403065/argparse-optional-boolean" target="_blank" rel="noopener">Argparse optional boolean [duplicate]</a></li></ul><hr><p><br></p><h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.jianshu.com/p/fef2d215b91d" target="_blank" rel="noopener">python argparse用法总结</a></li><li><a href="https://www.jianshu.com/p/0361cd8b8fec" target="_blank" rel="noopener">python命令行参数解析</a></li><li><a href="http://blog.konghy.cn/2016/06/30/python-argparse/" target="_blank" rel="noopener">Python 模块简介 – argparse</a></li><li><a href="https://www.cnblogs.com/xlqtlhx/p/8243592.html" target="_blank" rel="noopener">argarse.ArgumentParser.parse_known_args()解析</a></li><li><a href="http://blog.xiayf.cn/2013/03/30/argparse/" target="_blank" rel="noopener">非常好的讲解，但是适合回顾的时候看，需要基础</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-main函数的理解</title>
      <link href="/posts/32155.html"/>
      <url>/posts/32155.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇之前学习过的关于Python main函数的理解，主要学习了main函数的作用、在作为包引入以及直接运行时的区别，同时对Python的代码运行机制也有了一定的了解.</p></div><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><strong>程序入口：</strong><br>&emsp;&emsp;对于<strong>很多编程语言</strong>来说，<strong>程序都必须要有一个入口</strong>，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，<strong>C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始</strong>。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。<br>&emsp;&emsp;而 <strong>Python 则有不同</strong>，它<strong>属于脚本语言</strong>，不像编译型语言那样先将程序编译成二进制再运行，而是<strong>动态的逐行解释运行</strong>。也就是<strong>从脚本第一行开始运行，没有统一的入口</strong>，结合Python<strong>使用缩进对齐组织代码</strong>的执行，所有<strong>没有缩进的代码（非函数定义和类定义），都会被当成Python的main函数，在载入时自动执行</strong>。<br>&emsp;&emsp; 一个 Python 源码文件除了<strong>可以被直接运行</strong>外，还<strong>可以作为模块（也就是库）被导入</strong>。<strong>不管是导入还是直接运行，最顶层的代码都会被运行（没有设置缩进的代码）</strong>，<strong>而实际上在导入的时候，有一部分代码我们是不希望被运行的，这一部分代码可以放在main函数中，当作为模块进行导入时就不会被执行</strong></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'AAA'</span>)                <span class="comment">#没有所进的代码，会被直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'BBB'</span>)             <span class="comment">#函数中的内容，被调用后会被执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (__name__)              <span class="comment">#是内置变量，用于表示当前模块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment">#当name是main的时候执行</span></span><br><span class="line">   test()</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'CCC'</span>)</span><br></pre></td></tr></table></figure><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p><strong>直接运行文件的输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line"></span><br><span class="line">__main__</span><br><span class="line"></span><br><span class="line">BBB</span><br><span class="line">CCC</span><br></pre></td></tr></table></figure><p></p><p>可以看出<strong>直接执行文件</strong>的时候<strong>先是两个print会被执行</strong>，并且从输出信息可以<strong>看出<code>__name__</code>是<code>__main__</code>，满足<code>if</code>的判断条件，所以<code>test()</code>函数会被执行，并且输出<code>CCC</code></strong>。</p><hr><h3 id="当成模块引入"><a href="#当成模块引入" class="headerlink" title="当成模块引入"></a>当成模块引入</h3><ul><li>将上述代码保存为<code>test_main.py</code>文件</li><li>在同一个目录下创建另一个文件，里面只写入<code>from test_main import test</code>，运行该文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只导入包的时候出现</span></span><br><span class="line"><span class="keyword">from</span> test_main <span class="keyword">import</span> test</span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件中继续写入 test()，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只写 test，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">&lt;function test at <span class="number">0x03433970</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>导入包的时候，和上面一样，两个print也会被直接执行</strong>，<strong>需要注意的是这里的<code>__name__</code>已经变成了<code>module</code>的名称（test_main）</strong>，由于<strong>此时的<code>__name__</code>不等于<code>__main___</code>，不满足if的条件，所以不会直接执行test函数和输出CCC</strong>；<strong>导入之后，调用其中的test函数（被导入的函数），原始的test函数就会被执行。</strong></p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>&emsp;&emsp;<strong><code>__name__ == &#39;__main__&#39;</code>含义是“Make a script both importable and executable”</strong>，也就是<strong>让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行</strong>。每个python模块(python文件)都包含内置的变量<code>__name__</code>，当运行模块被直接执行的时候，<code>__name__</code>等于<code>&#39;__main__&#39;</code>；如果import到其他模块中，则<code>__name__</code>等于模块名称(不包含后缀.py)。而在程序中的判断条件是<code>if __name__ == &#39;__main__&#39;</code>，所以当模块被直接执行时，<code>__name__ == &#39;__main__&#39;</code>结果为真；而当模块被import到其他模块中时，<code>__name__ == &#39;__main__&#39;</code>结果为假，就是不调用对应的方法。简单来说： <strong>如果模块是被直接运行的，则if语句中的代码块被运行，如果模块是被导入的，则if语句中的代码块不被运行</strong>。</p><div class="note info"><p>这个功能有一个用处：调试代码的时候，在<code>if __name__ == &#39;__main__&#39;</code>中加入一些我们的调试代码，我们可以<strong>让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</strong></p></div><hr><h2 id="典型的python文件结构"><a href="#典型的python文件结构" class="headerlink" title="典型的python文件结构"></a>典型的python文件结构</h2><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python文件结构.gif"><br></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/51892.htm" target="_blank" rel="noopener">浅析python 中<strong>name</strong> = ‘<strong>main</strong>‘ 的作用</a></li><li><a href="https://zhuanlan.zhihu.com/p/34366092" target="_blank" rel="noopener">python编程中的if <strong>name</strong> == ‘main’ 的作用和原理</a></li><li><a href="https://www.restran.net/2015/10/22/how-python-code-run/" target="_blank" rel="noopener">Python 源码剖析读书笔记</a></li><li><a href="http://blog.konghy.cn/2017/04/24/python-entry-program/" target="_blank" rel="noopener">Python 中的 if <strong>name</strong> == ‘<strong>main</strong>‘ 该如何理解</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用程序块</title>
      <link href="/posts/58475.html"/>
      <url>/posts/58475.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇博客总结一些常用的Python程序块，避免重复造轮子</p></div><a id="more"></a><h2 id="添加中文注释"><a href="#添加中文注释" class="headerlink" title="添加中文注释"></a>添加中文注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><hr><h2 id="正则匹配-分组、非贪婪"><a href="#正则匹配-分组、非贪婪" class="headerlink" title="正则匹配(分组、非贪婪)"></a>正则匹配(分组、非贪婪)</h2><p>正则匹配是经常使用的，也是经常容易出错的，这个给出比较常用的带<strong>分组</strong>和<strong>非贪婪</strong>模式的匹配：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">'&gt;AT1G01060.4 | Symbols: LHY, LHY1 | Homeodomain-like superfamily protein | chr1:33992-37061 REVERSE LENGTH=644'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配前面的AT1G01060</span></span><br><span class="line">pattern=re.compile(<span class="string">'^&gt;(.*?)\.'</span>)</span><br><span class="line"></span><br><span class="line">re.search(pattern,s).group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>‘AT1G01060’</p></blockquote><div class="note info"><ul><li>需要注意的：<code>&#39;^&gt;(.*?)\.&#39;</code>这里<code>?</code>加在<code>*</code>的后面，因为<code>*</code>才是贪婪匹配的来源；不应该加载<code>()</code>后面，那样起不到非贪婪匹配的作用</li><li><code>group(0)</code>或者<code>group()</code>表示的是整个匹配上的字符串，比如这里指的就是<code>&#39;&gt;AT1G01060.&#39;</code>；<code>group(1)</code>才是匹配的括号内的内容</li><li><code>re.match</code><strong>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None</strong>；而<code>re.search</code>匹配<strong>整个字符串，直到找到一个匹配</strong></li><li><strong><code>re.match</code> 和 <code>re.search</code> 是匹配一次 <code>re.findall</code> 匹配所有，返回列表</strong></li></ul></div><hr><h2 id="自动调用函数执行"><a href="#自动调用函数执行" class="headerlink" title="自动调用函数执行"></a>自动调用函数执行</h2><p>关于main函数的理解，请参考<a href="http://showteeth.tech/">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义主函数</span></span><br><span class="line">def main():</span><br><span class="line">    my_func()</span><br><span class="line">    my_func_1()</span><br><span class="line">    my_func_2()</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="输出固定长度的字串"><a href="#输出固定长度的字串" class="headerlink" title="输出固定长度的字串"></a>输出固定长度的字串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改every即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wrapped</span><span class="params">(string, every=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\n'</span>.join(string[i:i+every] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), every))</span><br></pre></td></tr></table></figure><hr><h2 id="字典相关操作"><a href="#字典相关操作" class="headerlink" title="字典相关操作"></a>字典相关操作</h2><h3 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的字典</span></span><br><span class="line">dic=&#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="string">'3'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用collections中的defaultdict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dic_test=defaultdict(list)</span><br><span class="line">dic_test[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 具体的形式：defaultdict(&lt;type 'list'&gt;, &#123;'a': [1]&#125;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="两个列表组成字典"><a href="#两个列表组成字典" class="headerlink" title="两个列表组成字典"></a>两个列表组成字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"></span><br><span class="line">dictionary = dict(zip(keys, values)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (dictionary) </span><br><span class="line"><span class="comment"># 输出: </span></span><br><span class="line"><span class="comment">#      &#123;'a': 1, 'c': 3, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方法创建方法都可以使用以下方法遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">  <span class="keyword">print</span> (k)</span><br><span class="line">  <span class="keyword">print</span> (v)</span><br></pre></td></tr></table></figure><hr><h3 id="字典是否有该键值"><a href="#字典是否有该键值" class="headerlink" title="字典是否有该键值"></a>字典是否有该键值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用in</span></span><br><span class="line"><span class="keyword">if</span> k <span class="keyword">in</span> dic.keys():</span><br><span class="line">print(k)</span><br></pre></td></tr></table></figure><hr><h3 id="将字典写入文本文件"><a href="#将字典写入文本文件" class="headerlink" title="将字典写入文本文件"></a>将字典写入文本文件</h3><h4 id="处理fasta"><a href="#处理fasta" class="headerlink" title="处理fasta"></a>处理fasta</h4><ul><li><strong>以下是将fasta文件格式生成的字典写入文件</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义每一行的字符数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wrapped</span><span class="params">(string, every=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\n'</span>.join(string[i:i+every] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), every))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将fasta格式文件产生的字典写入文件</span></span><br><span class="line"><span class="comment"># k是&gt;开头的信息</span></span><br><span class="line"><span class="comment"># v是核苷酸或者蛋白质序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dic_file</span><span class="params">(dic,out_file)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(out_file,<span class="string">'w'</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">out.write(k+<span class="string">'\n'</span>)</span><br><span class="line">out_s=write_wrapped(v, every=<span class="number">60</span>)</span><br><span class="line">out.write(out_s)</span><br><span class="line">out.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="处理值为列表"><a href="#处理值为列表" class="headerlink" title="处理值为列表"></a>处理值为列表</h4><p>处理普通的当值为列表时的字典，形如：<code>{key:[value1,value2,value3]}</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当字典value是列表的时候可将值先join起来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dic_file</span><span class="params">(dic,out_file)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(out_file,<span class="string">'w'</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">out.write(k+<span class="string">'\t'</span>)</span><br><span class="line">out_s=<span class="string">'\t'</span>.join(v)</span><br><span class="line">out.write(out_s)</span><br><span class="line">out.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="将字典写入excel中"><a href="#将字典写入excel中" class="headerlink" title="将字典写入excel中"></a>将字典写入excel中</h3><p>字典特征：<strong>key为样本名</strong>，<strong>value为dataframe</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_excel</span><span class="params">(df_dic,out_file)</span>:</span></span><br><span class="line">    writer = pd.ExcelWriter(out_file)</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> df_dic.items():</span><br><span class="line">        v.to_excel(writer,sheet_name=<span class="string">'&#123;&#125;'</span>.format(str(k)),index=<span class="keyword">False</span>)</span><br><span class="line">    writer.save()</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="获取字典最值"><a href="#获取字典最值" class="headerlink" title="获取字典最值"></a>获取字典最值</h3><p><strong>利用<code>min(dict, key=dict.get)</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="number">3</span>:<span class="number">2</span>&#125;</span><br><span class="line">min(d, key=d.get)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     2</span></span><br></pre></td></tr></table></figure><p></p><p><strong>利用<code>lambda</code>函数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到索引和值</span></span><br><span class="line">min(d.items(), key=lambda x: x[1])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     (2, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只得到值</span></span><br><span class="line">min(d, key=lambda x: d[x])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#      2</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="判断最后一行文本"><a href="#判断最后一行文本" class="headerlink" title="判断最后一行文本"></a>判断最后一行文本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bug:if second last is same as last, this will be wrong </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">last_line=total_lines[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> line == last_line:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># fix bug above</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line_num)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">total_line_num=len(total_lines)</span><br><span class="line"><span class="keyword">if</span> line_num==total_line_num:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br></pre></td></tr></table></figure><hr><h2 id="读取fasta文件"><a href="#读取fasta文件" class="headerlink" title="读取fasta文件"></a>读取fasta文件</h2><h3 id="使用biopython包"><a href="#使用biopython包" class="headerlink" title="使用biopython包"></a>使用biopython包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="comment"># 如果可能存在小写的序列，可以使用SeqRecord 对象的 upper() 方法轻易的实现</span></span><br><span class="line"><span class="comment"># seq_record.upper()</span></span><br><span class="line"><span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(<span class="string">"/home/songyabing/genome/Ca22chrA.fa"</span>, <span class="string">"fasta"</span>):</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Chr: &#123;chr_name&#125; with length: &#123;seq_length&#125;"</span>.format(chr_name=seq_record.id,seq_length=str(len(seq_record))))</span><br><span class="line">    <span class="keyword">print</span> (repr(seq_record.upper().seq))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Chr: chr1 <span class="keyword">with</span> length: <span class="number">3188341</span></span><br><span class="line">Seq(<span class="string">'GAGTCACGCCAATCACAAATTCCTTTGAAAAACTTGATTCGACCACATTCACAA...ACA'</span>, SingleLetterAlphabet())</span><br><span class="line">Chr: chr2 <span class="keyword">with</span> length: <span class="number">2231883</span></span><br><span class="line">Seq(<span class="string">'ACACTCACCGTTTCTAACTGCTTAACCTATTACTATTAAGAATTCGCTATTGTT...GGG'</span>, SingleLetterAlphabet())</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p><strong>其他常见用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from Bio import SeqIO</span><br><span class="line"><span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(<span class="string">"/home/songyabing/genome/genome.fa"</span>, <span class="string">"fasta"</span>):</span><br><span class="line"><span class="comment">#     print ("Chr: &#123;chr_name&#125; with length: &#123;seq_length&#125;".format(chr_name=seq_record.id,seq_length=str(len(seq_record))))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> seq_record.id == <span class="string">"chrM"</span>:</span><br><span class="line">        <span class="comment"># 输出染色体的name，和seq_record.name作用相同，如</span></span><br><span class="line">        <span class="comment"># &gt;chrM AC:J01415.2 gi:113200490 LN:16569 rl:Mitochondrion M5:c68f52674c9fb33aef52dcf399755519 AS:GRCh38 tp:circular</span></span><br><span class="line">        <span class="comment"># 输出的是chrM</span></span><br><span class="line">        <span class="built_in">print</span> (seq_record.id)</span><br><span class="line">        <span class="comment"># 输出染色体的具体序列(字符串)，不会输出前面的&gt;chrM等信息</span></span><br><span class="line">        <span class="built_in">print</span> (seq_record.upper().seq)</span><br><span class="line">        <span class="comment"># 显示序列但不直接输出字符</span></span><br><span class="line">        <span class="built_in">print</span> (repr(seq_record.upper().seq))</span><br><span class="line">        <span class="comment"># 输出字符串的序列以及&gt;chrM等信息</span></span><br><span class="line">        <span class="built_in">print</span>(seq_record.format(<span class="string">"fasta"</span>))</span><br><span class="line">        <span class="comment"># 修改序列的描述信息</span></span><br><span class="line">        seq_record.description +=<span class="string">' extend:400bp'</span></span><br><span class="line">        <span class="comment"># 输出序列的描述信息，包括长度，来源等 </span></span><br><span class="line">        <span class="built_in">print</span> (seq_record.description)</span><br></pre></td></tr></table></figure><p></p><p>如果想要使用其中seq序列信息，可以使用str将其转化<code>str(seq_record.seq)</code>，直接输出可能不是很好。</p><p>biopython还可以很方便地统计GC含量，关于biopython的更多使用可以参考：</p><ul><li><a href="https://blog.csdn.net/u011262253/article/details/88542836" target="_blank" rel="noopener">用biopython解析序列</a></li><li><a href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr01.html" target="_blank" rel="noopener">Biopython中文文档</a></li></ul><hr><h3 id="自己编写代码"><a href="#自己编写代码" class="headerlink" title="自己编写代码"></a>自己编写代码</h3><p>自己编写的读取<strong>会很慢</strong>，所以建议还是使用上面的biopython包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"/home/user/genome/Ca22chrA.fa"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> fa_in:</span><br><span class="line">    fa_seq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fa_in.readlines():</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">"&gt;"</span>:</span><br><span class="line">            chr_name=line.split()[<span class="number">0</span>].replace(<span class="string">'&gt;'</span>,<span class="string">''</span>)</span><br><span class="line">            fa_seq[chr_name]=<span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fa_seq[chr_name] = fa_seq[chr_name] + line</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="判断一个列表是不是另一个列表的子集"><a href="#判断一个列表是不是另一个列表的子集" class="headerlink" title="判断一个列表是不是另一个列表的子集"></a>判断一个列表是不是另一个列表的子集</h2><p>参考链接：<a href="https://www.geeksforgeeks.org/python-check-if-one-list-is-subset-of-other/" target="_blank" rel="noopener">Python | Check if one list is subset of other</a></p><h3 id="all-方法"><a href="#all-方法" class="headerlink" title="all()方法"></a>all()方法</h3><p>如果<code>all(x)</code>参数x对象的所有元素<strong>不为</strong><code>0</code>、<code>&#39;&#39;</code>、<code>False</code>或者x为<code>空对象</code>，则<strong>返回True</strong>，<strong>否则返回False</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># 存在空字符串</span></span><br><span class="line">all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">''</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在元素为0</span></span><br><span class="line">all([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>判断子集</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> all(x <span class="keyword">in</span> test_list <span class="keyword">for</span> x <span class="keyword">in</span> sub_list):</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"yes, &#123;sub_list&#125; is subset of &#123;total_list&#125;"</span>.format(sub_list=sub_list,total_list=test_list))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"no"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">yes, [<span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>] <span class="keyword">is</span> subset of [<span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>与<code>all(x)</code>方法相对应的是<code>any(x)</code>方法，判断x对象是否<strong>全为空对象</strong>，如果都为<code>&#39;&#39;</code>、<code>0</code>、<code>false</code>，则<code>返回false</code>，如果<strong>不都为</strong><code>&#39;&#39;</code>、<code>0</code>、<code>false</code>，则<strong>返回true</strong>。</p></div><hr><h3 id="集合的issubset-方法"><a href="#集合的issubset-方法" class="headerlink" title="集合的issubset()方法"></a>集合的issubset()方法</h3><p>最好用也最方便的就是使用集合的相关方法，主要是<code>issubset()</code>、<code>issuperset()</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先将两个列表转换为集合</span></span><br><span class="line"><span class="comment"># 使用subset方法</span></span><br><span class="line"><span class="keyword">if</span> set(sub_list).issubset(set(test_list)):</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"yes, &#123;sub_list&#125; is subset of &#123;total_list&#125;"</span>.format(sub_list=sub_list,total_list=test_list))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"no"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用superset方法与这个类似</span></span><br><span class="line"><span class="comment"># 需要注意两者是对应关系</span></span><br><span class="line"><span class="keyword">if</span> set(test_list).issuperset(set(sub_list)):</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"yes, &#123;sub_list&#125; is subset of &#123;total_list&#125;"</span>.format(sub_list=sub_list,total_list=test_list))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"no"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">yes, [<span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>] <span class="keyword">is</span> subset of [<span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常见错误</title>
      <link href="/posts/61409.html"/>
      <url>/posts/61409.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要整理了在Python学习过程中遇到的具有典型性的问题，搜集起来，以免以后遇到同样的错误重新找解决方法。</p></div><a id="more"></a><h2 id="常规报错"><a href="#常规报错" class="headerlink" title="常规报错"></a>常规报错</h2><h2 id="pandas报错"><a href="#pandas报错" class="headerlink" title="pandas报错"></a>pandas报错</h2><h2 id="jupyter报错"><a href="#jupyter报错" class="headerlink" title="jupyter报错"></a>jupyter报错</h2><h3 id="jupyter启动报错"><a href="#jupyter启动报错" class="headerlink" title="jupyter启动报错"></a>jupyter启动报错</h3><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\Scripts\jupyter-notebook-script.py"</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from notebook.notebookapp import main</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\notebookapp.py"</span>, line 81, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .services.kernels.kernelmanager import MappingKernelManager</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\services\kernels\kernelmanager.py"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.session import Session</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\session.py"</span>, line 61, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.jsonutil import extract_dates, squash_dates, date_default</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\jsonutil.py"</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from dateutil.parser import parse as _dateutil_parse</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\dateutil\parser.py"</span>, line 158</span><br><span class="line">    l.append(<span class="string">"%s=%s"</span> % (attr, `value`))</span><br><span class="line">                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall python-dateutil</span><br><span class="line">pip install python-dateutil</span><br></pre></td></tr></table></figure><hr><h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p>之前安装的将印象笔记转化为markdown格式的时候安装的包将某个包的版本降低了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ever2simple 2.0 has requirement python-dateutil&lt;2.0, but you<span class="string">'ll have python-dateutil 2.8.0 which is incompatible.</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-数组</title>
      <link href="/posts/46714.html"/>
      <url>/posts/46714.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要对Shell的数组进行了学习，主要内容包括<code>创建数组</code>、<code>数组赋值</code>、<code>读取数组</code>、<code>获取数组长度</code>、<code>获取数组使用的下标</code>、<code>在数组末尾添加元素</code>、<code>数组排序</code>、<code>删除数组</code>和<code>关联数组</code>。</p></div><a id="more"></a><h2 id="shell数组简介"><a href="#shell数组简介" class="headerlink" title="shell数组简介"></a>shell数组简介</h2><p>数组是可以存放多个值的一种数据结构，Bash shell也支持数组，但是其对数组的支持比较有限，下面列出了Bash shell数组的特征：</p><ul><li>Bash Shell <strong>只支持一维数组(不支持多维数组)</strong></li><li>初始化时<strong>不需要定义数组大小</strong></li><li>数组元素的<strong>下标由0开始</strong>(与大部分编程语言类似)</li><li>数组用<strong>括号来表示</strong>，<strong>元素用”空格”符号分割</strong>开</li></ul><hr><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="提前创建"><a href="#提前创建" class="headerlink" title="提前创建"></a>提前创建</h3><p><strong>特殊符号<code>( )</code></strong>被用于数组的声明中，因此可以使用如下命令提前创建数组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array=(element1 element2 element3 ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组时直接指定元素的索引值</span></span><br><span class="line">array=([1]=element1 [2]=element2 [3]=element3)</span><br></pre></td></tr></table></figure><p></p><p>更多关于特殊符号<code>( )</code>的用法参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><p><strong>也可以使用declare命令创建数组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array=<span class="string">'(element1 element2 element3 ...)'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p>数组变量就像其它 bash 变量一样命名，当<strong>被访问的时候，它们会被自动地创建</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[1]=foo</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  foo</span><br></pre></td></tr></table></figure><p></p><p>上面是一个赋值并访问数组元素的例子，通过<code>a[1]=foo</code>，数组索引为1(开始于0)的元素被赋值为foo(索引为0的位置可以访问，但是输出为空)；通过<code>echo ${a[1]}</code>访问数组索引为1的元素，<code>${}</code>可以进行数组操作，具体的请看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><div class="note info"><p>可以不使用连续的下标创建数组，而且下标的范围没有限制</p></div><hr><h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>在上述创建数组的过程中其实已经实现了数组的赋值：</p><ul><li><strong>单个元素</strong>赋值：<code>array[index]=value</code></li><li><strong>多个元素</strong>赋值：<code>array=(element1 element2 element3 ...)</code></li><li><strong>多个元素结合索引</strong>进行赋值：<code>array=([1]=element1 [2]=element2 [3]=element3)</code></li></ul><p><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次赋值</span></span><br><span class="line">a=(a b c)</span><br><span class="line"><span class="comment"># $&#123;a[@]&#125;是获取数组所有元素，后面会讲到</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次赋值</span></span><br><span class="line">a=(d e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a b c<br>d e f g</p></blockquote><div class="note info"><ul><li>数组的<code>index</code>是<strong>一个大于或等于零的整数（或算术表达式）</strong></li><li>数组<strong>第一个元素的下标是0</strong>， 而不是1</li><li>数组<strong>元素的值可以是一个字符串或整数</strong></li><li><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong></li></ul></div><hr><h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><h3 id="读取数组单个元素"><a href="#读取数组单个元素" class="headerlink" title="读取数组单个元素"></a>读取数组单个元素</h3><p>读取数组使用特殊符号<code>${}</code>，一般形式为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><p>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=A</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>A<br>2<br>3<br>4</p></blockquote><hr><h3 id="读取数组所有元素"><a href="#读取数组所有元素" class="headerlink" title="读取数组所有元素"></a>读取数组所有元素</h3><p><strong>如果想要获取数组的所有元素，使用<code>@</code> 或 <code>*</code></strong> :<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1 2 3 4<br>1 2 3 4</p></blockquote><p><code>@</code>和<code>*</code>的区别和使用<a href="http://showteeth.tech/posts/55603.html"><code>$*</code>或<code>$@</code>得到所有脚本变量</a>的区别相同：</p><ul><li><strong>不使用双引号括起来时完全相同</strong>：都以”element1” “element2” … “elementn” 的形式输出所有参数</li><li><strong>使用双引号括起来时不同</strong>：<code>&quot;${!array[*]}&quot;</code> 会将所有的元素作为一个整体，以”element1 element2 … elementn”的形式输出所有元素；<code>&quot;${!array[@]}&quot;</code> 会将各个元素分开，以”element1” “element2” … “elementn” 的形式输出所有元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>不使用双引号括起来时输出结果完全相同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>使用双引号括起来时输出结果不同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><blockquote><p>1 2 3 4</p></blockquote><div class="note info"><ul><li>读取数组所有元素需要注意<code>${array[*]}</code>和<code>${array[@]}</code>加引号和不加引号输出结果的区别</li><li>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong></li></ul></div><hr><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>获取数组长度(元素个数)的方法与获取字符串长度的方法相同，仍然是使用特殊符号<code>${}</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>4</p></blockquote><p><strong>如果上面不是使用了<code>@</code>和<code>*</code>，而是使用了具体的索引位置，则会得到指定索引位置的元素长度：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[1]=test_length</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[1]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>11 &emsp;&emsp;&emsp;# 输出的是test_length的长度</p></blockquote><p>还有需要注意的地方是：<strong>如果赋值时数组的索引不是连续的，数组的长度不是最大索引对应的长度，而是有具体值的索引的个数，也就是说没有赋值的那些索引不计入数组长度(但是仍然可以通过索引访问，返回结果为空)</strong>。示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[100]=100</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>5 &emsp;&emsp;&emsp;# 这里输出结果是5，而不是101，即使最后一个有值的索引为100，但是5-99的索引位置并没有赋值，也就没有计入数组长度</p></blockquote><div class="note info"><ul><li><strong>使用<code>@</code>和<code>*</code></strong>获取的是<strong>数组的长度</strong></li><li><strong>使用具体的索引位置</strong>获取的是<strong>指定索引位置的元素长度</strong></li><li><strong>未赋值的索引不计入输入长度的计算</strong></li></ul></div><hr><h2 id="获取数组使用的下标"><a href="#获取数组使用的下标" class="headerlink" title="获取数组使用的下标"></a>获取数组使用的下标</h2><p>因为shell数组允许赋值的数组下标包含 “间隔”，所以确定哪些下标在数组中是具有值的有时候很关键：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>0 1 2 3 100</p></blockquote><p><strong>和前面提到的使用双引号和不使用双引号括起来输出结果不同相同，这里两种方法在使用双引号括起来的时候也会存在差异</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;!array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;!array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><code>&quot;${!array[@]}&quot;</code>输出结果：</p><blockquote><p>0<br>1<br>2<br>3<br>100</p></blockquote><p><code>&quot;${!array[*]}&quot;</code>输出结果：</p><blockquote><p>0 1 2 3 100</p></blockquote><div class="note info"><ul><li>获取数组下标时需要注意<code>${!array[*]}</code>和<code>${!array[@]}</code>加引号和不加引号输出结果的区别</li><li><code>${array[*]}</code>和<code>${array[@]}</code>是获取数组所有元素的方法，而<code>!</code>具有取反的作用，<strong>数组元素的反理解为索引</strong>的话就很好记忆了</li></ul></div><hr><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><p>如果我们需要<strong>在数组末尾附加数据</strong>，那么知道数组中元素的个数是没用的，<strong>直接不加索引继续赋值的话第二次的赋值会覆盖前一次的赋值结果</strong>。幸运地是，shell 为我们提供了一种解决方案：<strong>通过使用 <code>+=</code> 赋值运算符，我们能够自动地把值附加到数组末尾(索引接着最后一个索引)</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=(a b c)</span><br><span class="line"><span class="built_in">test</span>[100]=d</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>+=(e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100 101 102 103</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>Shell 没有直接对数组元素排序的方法，但是可以通过获取值然后排序再利用排序后的值重新赋值给另一个数组即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=(a d c f e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将排序后的结果赋值给新数组，这里使用了循环接入管道的操作</span></span><br><span class="line"><span class="comment"># 可以不使用新数组，直接赋值给原始数组即可覆盖原始数组的值</span></span><br><span class="line">a_sorted=($(<span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;a[@]&#125;</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span> |sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在同一行输出新数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;a_sorted[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a c d e f</p></blockquote><hr><h2 id="删除数组相关操作"><a href="#删除数组相关操作" class="headerlink" title="删除数组相关操作"></a>删除数组相关操作</h2><p>删除数组相关操作都会使用 <code>unset</code> 命令</p><h3 id="删除整个数组"><a href="#删除整个数组" class="headerlink" title="删除整个数组"></a>删除整个数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> foo</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出为空</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> <span class="string">'foo[2]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b d e f</span></span><br></pre></td></tr></table></figure><hr><h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>现在最新的 <code>bash</code> 版本(<code>bash 4.X</code>)支持关联数组(<strong>其实就是字典，在我看来</strong>)了，<strong>关联数组使用字符串而不是整数作为数组索引(AWK只支持关联数组，但可以把数字下标转化为字符)</strong>。</p><p>具体用法可以参考<a href="http://showteeth.tech/posts/17760.html">这篇文章</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用-A也可以使用-a</span></span><br><span class="line"><span class="comment"># 也可以直接在使用的时候创建</span></span><br><span class="line"><span class="built_in">declare</span> -A colors</span><br><span class="line">colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#ff0000 #0000ff #00ff00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种创建输出会出问题：</span></span><br><span class="line">array=([<span class="string">"red"</span>]=<span class="string">"#ff0000"</span> [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span> [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#0000ff</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/chapter4/46.html" target="_blank" rel="noopener">shell-guide</a></li><li><a href="https://baijiahao.baidu.com/s?id=1608244941950314734&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/hanframe/p/3564313.html" target="_blank" rel="noopener">shell编程中使用数组进行操作</a></li><li><a href="http://www.runoob.com/linux/linux-shell-array.html" target="_blank" rel="noopener">Shell 数组</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系列(一):Git简介</title>
      <link href="/posts/60073.html"/>
      <url>/posts/60073.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在有了前面两篇转载的偏实战文章的学习之后，打算针对Git进行一系列的学习，这次是偏系统，因为在实战学习中发现有些命令和操作不是很懂，同时在这篇文章的参考链接中也给出了一些Git相关的系列教程</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></li><li><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5" target="_blank" rel="noopener">Git官方教程</a></li><li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/article-8478-1.html" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/daima/git_code/" target="_blank" rel="noopener">Git实例</a></li><li></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令及日常问题集锦(转载)</title>
      <link href="/posts/13404.html"/>
      <url>/posts/13404.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的博客，主要记录了<code>Git</code>的常用命令，包括<code>新建代码库</code>、<code>Git相关配置</code>、<code>添加文件到暂存区</code>、<code>删除工作区文件</code>、<code>代码提交</code>、<code>分支操作</code>、<code>标签</code>、<code>查看信息</code>、<code>远程同步</code>，还整理了一些使用过程中<code>常见的问题</code>。</p></div><a id="more"></a><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><ul><li>在<strong>当前目录</strong>新建一个Git代码库(初始化)：<code>git init</code></li><li><strong>新建一个目录</strong>，<strong>将其初始化</strong>为Git代码库：<code>git init [project-name]</code></li><li><strong>下载一个项目和它的整个代码历史</strong>：<code>git clone [url]</code></li></ul><hr><h2 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h2><ul><li><strong>显示当前</strong>的Git配置：<code>git config --list</code></li><li><strong>编辑</strong>Git配置文件：<code>git config -e [--global]</code></li><li><strong>设置提交代码时的用户信息</strong>：<code>git config [--global] user.name &quot;[name]&quot;</code>和<code>git config [--global] user.email &quot;[email address]&quot;</code></li></ul><hr><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><ul><li><strong>添加</strong>指定<strong>文件</strong>到<strong>暂存区</strong>：<code>git add [file1] [file2] ...</code></li><li>添加指定<strong>目录到暂存区</strong>，<strong>包括子目录</strong>：<code>git add [dir]</code></li><li>添加<strong>当前目录的所有文件到暂存区</strong>：<code>git add .</code></li><li>添加<strong>每个变化</strong>前，都会<strong>要求确认</strong>(对于<strong>同一个文件的多处变化</strong>，可以实现<strong>分次提交</strong>)：<code>git add -p</code></li></ul><hr><h2 id="删除工作区文件"><a href="#删除工作区文件" class="headerlink" title="删除工作区文件"></a>删除工作区文件</h2><ul><li><strong>删除工作区</strong>文件，并且将这次删除<strong>放入暂存区</strong>：<code>git rm [file1] [file2] ...</code></li><li><strong>停止追踪</strong>指定文件，但该文件会<strong>保留在工作区</strong>：<code>git rm --cached [file]</code></li><li><strong>改名</strong>文件，并且将这个<strong>改名放入暂存区</strong>：<code>git mv [file-original] [file-renamed]</code></li></ul><hr><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><ul><li>提交<strong>暂存区到仓库区</strong>：<code>git commit -m [message]</code></li><li>提交<strong>暂存区的指定文件到仓库区</strong>：<code>git commit [file1] [file2] ... -m [message]</code></li><li>提交<strong>工作区自上次commit之后的变化，<u>直接到仓库区</u></strong>：<code>git commit -a</code><br><br></li><li>提交时<strong>显示所有diff信息</strong>：<code>git commit -v</code><br><br></li><li><strong>使用一次新的commit，替代上一次提交(如果代码没有任何新变化，则用来改写上一次commit的提交信息)</strong>：<code>git commit --amend -m [message]</code></li><li><strong>重做上一次commit，并包括指定文件的新变化</strong>：<code>git commit --amend [file1] [file2] ...</code></li></ul><hr><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ul><li><strong>列出</strong>所有<strong>本地分支</strong>：<code>git branch</code></li><li><strong>列出</strong>所有<strong>远程分支</strong>：<code>git branch -r</code></li><li><strong>列出</strong>所有<strong>本地分支和远程分支</strong>：<code>git branch -a</code><br><br></li><li><strong>新建</strong>一个分支，但<strong>依然停留在当前分支</strong>：<code>git branch [branch-name]</code></li><li><strong>新建</strong>一个分支，并<strong>切换到该分支</strong>：<code>git checkout -b [branch]</code></li><li><strong>新建</strong>一个分支，<strong>指向指定commit</strong>：<code>git branch [branch] [commit]</code></li><li><strong>新建</strong>一个分支，<strong>与指定的远程分支建立追踪关系(连接)</strong>：<code>git branch --track [branch] [remote-branch]</code><br><br></li><li><strong>切换</strong>到<strong>指定</strong>分支，并<strong>更新工作区</strong>：<code>git checkout [branch-name]</code></li><li><strong>切换</strong>到<strong>上一个</strong>分支：<code>git checkout -</code></li><li><strong>建立追踪关系(连接)</strong>，在<strong>现有分支</strong>与<strong>指定的远程分支</strong>之间：<code>git branch --set-upstream [branch] [remote-branch]</code><br><br></li><li><strong>合并指定分支</strong>到<strong>当前分支</strong>：<code>git merge [branch]</code></li><li><strong>选择一个commit</strong>，<strong>合并进当前分支</strong>：<code>git cherry-pick [commit]</code><br><br></li><li><strong>删除</strong>分支：<code>git branch -d [branch-name]</code></li><li><strong>删除远程</strong>分支：<code>git push origin --delete [branch-name]</code>或者<code>git branch -dr [remote/branch]</code></li></ul><hr><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><strong>列出</strong>所有tag：<code>git tag</code></li><li><strong>查看</strong>tag信息：<code>git show [tag]</code><br><br></li><li><strong>新建</strong>一个tag<strong>在当前commit</strong>：<code>git tag [tag]</code></li><li><strong>新建</strong>一个tag在<strong>指定commit</strong>：<code>git tag [tag] [commit]</code><br><br></li><li><strong>删除本地</strong>tag：<code>git tag -d [tag]</code></li><li><strong>删除远程</strong>tag：<code>git push origin :refs/tags/[tagName]</code><br><br></li><li><strong>提交指定</strong>tag：<code>git push [remote] [tag]</code></li><li><strong>提交所有</strong>tag：<code>git push [remote] --tags</code><br><br></li><li><strong>新建一个分支</strong>，<strong>指向某个tag</strong>：<code>git checkout -b [branch] [tag]</code></li></ul><hr><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul><li><strong>显示有变更的文件</strong>：<code>git status</code><br><br></li><li>显示<strong>暂存区</strong>和<strong>工作区的差异</strong>：<code>git diff</code></li><li>显示<strong>暂存区</strong>和<strong>上一个commit的差异</strong>：<code>git diff --cached [file]</code></li><li>显示<strong>工作区</strong>与<strong>当前分支最新commit之间的差异</strong>：<code>git diff HEAD</code></li><li>显示<strong>两次提交之间的差异</strong>：<code>git diff [commit_1] [commit_2]</code></li><li><strong>显示今天你写了多少行代码</strong>：<code>git diff --shortstat &quot;@{0 day ago}&quot;</code><br><br></li><li>显示<strong>某次提交</strong>的<strong>元数据和内容变化</strong>：<code>git show [commit]</code></li><li>显示<strong>某次提交发生变化的文件</strong>：<code>git show --name-only [commit]</code></li><li>显示<strong>某次提交时，某个文件的内容</strong>：<code>git show [commit]:[filename]</code><br><br></li><li><strong>显示当前分支的版本历史</strong>：<code>git log</code></li><li><strong>显示commit历史</strong>，以及<strong>每次commit发生变更的文件</strong>：<code>git log --stat</code></li><li><strong>根据关键词搜索提交历史</strong>：<code>git log -S [keyword]</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>每个commit占据一行</strong>：<code>git log [tag] HEAD --pretty=format:%s</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>其”提交说明”必须符合搜索条件</strong>：<code>git log [tag] HEAD --grep feature</code></li><li>显示<strong>某个文件的版本历史</strong>，<strong>包括文件改名</strong>：<code>git log --follow [file]</code>或者<code>git whatchanged [file]</code></li><li>显示<strong>指定文件</strong>相关的<strong>每一次diff</strong>：<code>git log -p [file]</code></li><li><strong>显示过去5次提交</strong>，且<strong>每个commit占据一行</strong>：<code>git log -5 --pretty --oneline</code><br><br></li><li><strong>记录几乎当前分支的所有改变，带版本号</strong>：<code>git reflog</code><br><br></li><li>显示<strong>所有提交过的用户</strong>，<strong>按提交次数排序</strong>：<code>git shortlog -sn</code></li><li>显示<strong>指定文件</strong>是<strong>什么人在什么时间修改过</strong>：<code>git blame [file]</code></li></ul><hr><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><ul><li><strong>下载远程仓库的所有变动</strong>：<code>git fetch [remote]</code></li><li><strong>取回远程仓库的变化</strong>，并<strong>与本地分支合并</strong>：<code>git pull [remote] [branch]</code><br><br></li><li>上传<strong>本地指定分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] [branch]</code></li><li><strong>强行</strong>推送<strong>当前分支</strong>到<strong>远程仓库</strong>，<strong>即使有冲突</strong>：<code>git push [remote] --force</code></li><li>推送<strong>所有分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] --all</code><br><br></li><li><strong>显示所有远程仓库</strong>：<code>git remote -v</code></li><li>显示<strong>某个远程仓库</strong>的信息：<code>git remote show [remote]</code></li><li><strong>增加一个新的远程仓库</strong>，<strong>并命名</strong>：<code>git remote add [shortname] [url]</code></li></ul><hr><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li>恢复<strong>暂存区的指定文件</strong>到<strong>工作区</strong>：<code>git checkout [file]</code></li><li>恢复<strong>暂存区的所有文件</strong>到<strong>工作区</strong>：<code>git checkout .</code></li><li>恢复<strong>某个commit的指定文件</strong>到<strong>暂存区和工作区</strong>：<code>git checkout [commit] [file]</code><br><br></li><li>重置<strong>暂存区的指定文件</strong>，与<strong>上一次commit保持一致</strong>，但<strong>工作区不变</strong>：<code>git reset [file]</code></li><li>重置<strong>暂存区与工作区</strong>，与<strong>上一次commit保持一致</strong>：<code>git reset --hard</code></li><li>重置<strong>当前分支的指针为指定commit</strong>，同时<strong>重置暂存区</strong>，但<strong>工作区不变</strong>：<code>git reset [commit]</code></li><li>重置<strong>当前分支的HEAD为指定commit</strong>，同时<strong>重置暂存区和工作区</strong>，<strong>与指定commit一致</strong>：<code>git reset --hard [commit]</code></li><li>重置<strong>当前HEAD为指定commit</strong>，但<strong>保持暂存区</strong>和<strong>工作区不变</strong>：<code>git reset --keep [commit]</code><br><br></li><li><strong>新建一个commit</strong>，<strong>用来撤销指定commit(后者的所有变化都将被前者抵消，并且应用到当前分支)</strong>：<code>git revert [commit]</code><br><br></li><li><strong>暂时将未提交的变化移除，稍后再移入</strong>：<code>git stash</code>和<code>git stash pop</code></li></ul><div><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr><div class="RichText ztext Post-RichText"><h2 id="常见问题">常见问题</h2><h3 id="failed to push some refs to git">failed to push some refs to git</h3><p style="font-weight:700">Question1</p><div class="highlight"><pre><code class="language-text"><span></span>如何解决: failed to push some refs to git    </code></pre></div><p style="font-weight:700">Answer1</p><div class="highlight"><pre><code class="language-text"><span></span>git pull --rebase origin master  # 进行代码合并    git push -u origin master  # 即可完成代码上传    </code></pre></div><hr><h3 id="git pull未指定本地与远程连接报错">git pull未指定本地与远程连接报错</h3><p style="font-weight:700">Question2</p><p><code>If you wish to set tracking information for this branch you can do so with:</code></p><p><code>git branch --set-upstream-to=origin/ master</code></p><p style="font-weight:700">Answer2</p><p>指定当前工作分支跟远程仓库分支之间的联系</p><p><code>git branch --set-upstream master origin/master</code></p><hr><h3 id="获取最新代码报错">获取最新代码报错</h3><p style="font-weight:700">Question3</p><p><code>git pull</code> 获取最新代码报以下错误</p><p><code>fatal: refusing to merge unrelated histories</code></p><p style="font-weight:700">Answer3</p><p>git pull之后加上可选参数 --allow-unrelated-histories 强制合并</p><p><code>git pull origin master --allow-unrelated-histories</code></p><hr><h3 id="使用钩子报错">使用钩子报错</h3><p style="font-weight:700">Question4</p><p>使用钩子<code>pre-commit</code>，提交代码提示如下错误：</p><div class="highlight"><pre><code class="language-text"><span></span>$ git commit -m '.'    sh: eslint: command not found    pre-commit:    pre-commit: We've failed to pass the specified git pre-commit hooks as the `fix`    pre-commit: hook returned an exit code (1). If you're feeling adventurous you can    pre-commit: skip the git pre-commit hooks by adding the following flags to your commit:    pre-commit:    pre-commit:   git commit -n (or --no-verify)    pre-commit:    pre-commit: This is ill-advised since the commit is broken.    pre-commit:    </code></pre></div><p style="font-weight:700">Answer4</p><ul><li>打开项目中的<code>.git/hooks</code>文件夹，找到<code>pre-commit.sample</code>文件，将以下代码替换到文件中，或者，<code>npm install pre-commit --save</code>也可以，这个命令会自动执行以下操作。</li></ul><div class="highlight"><pre><code class="language-text"><span></span>#!/bin/bash    TSLINT="$(git rev-parse --show-toplevel)/node_modules/.bin/tslint"    for file in $(git diff --cached --name-only | grep -E '\.ts$')    do            git show ":$file" | "$TSLINT" "$file"            if [ $? -ne 0 ]; then                    exit 1            fi    done    </code></pre></div><ul><li>将<code>pre-commit.sample</code>文件名修改为<code>pre-commit</code>。</li></ul><hr><h3 id=".gitignore规则不生效">.gitignore规则不生效</h3><p style="font-weight:700">Question5</p><p><code>.gitignore规则不生效的解决办法</code></p><p style="font-weight:700">Answer5</p><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</p><div class="highlight"><pre><code class="language-text"><span></span>git rm -r --cached . 或者 git rm -r README.md    git add .    git commit -m 'update .gitignore'    </code></pre></div><p><br>作者：五月君<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/269298" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/26929</span><span class="invisible">8</span><span class="ellipsis"></span></a><br>来源：慕课网<br>本文首次发布于慕课网 ，转载请注明出处，谢谢合作</p></div><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git讲解与使用实战(转载)</title>
      <link href="/posts/13035.html"/>
      <url>/posts/13035.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要偏向实战，通过实战讲解Git的用法，比较全面，包括<code>创建版本库</code>、<code>版本回退</code>、<code>撤销修改和删除文件操作</code>、<code>远程仓库相关操作</code>以及<code>分支操作</code>，总的来说是一篇不错的文章。</p></div><a id="more"></a><div class="RichText ztext Post-RichText"><h2 id="简介与安装">Git简介与安装</h2><h3 id="Git是什么？">Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。工作原理 / 流程：</p><img 图片1 src="http://img.mukewang.com/59c31e4400013bc911720340.png" alt="图片描述" data-original="http://img.mukewang.com/59c31e4400013bc911720340.png" style="cursor:pointer;display:block"><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><hr><h3 id="SVN与Git的最主要的区别">SVN与Git的最主要的区别</h3><p><code>SVN</code>是<strong>集中式版本控制系统</strong>，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。<strong>集中式版本控制系统是必须联网才能工作</strong>，如果在<u>局域网</u>还可以，带宽够大，速度够快，如果在<u>互联网下</u>，如果网速慢的话，就纳闷了。</p><p><code>Git</code>是<strong>分布式版本控制系统</strong>，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就<strong>不需要联网</strong>了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><hr><h3 id="在windows上安装Git">在windows上安装Git</h3><p><code>msysgit</code>是 windows版的Git,如下：</p><img 图片2 src="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" style="cursor:pointer;display:block"><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 "Git --&gt; Git Bash",如下：<br></p><img 图片3 src="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" style="cursor:pointer;display:block"><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：<br></p><img 图片4 src="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" style="cursor:pointer;display:block"><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><img 图片5 src="http://img.mukewang.com/59c1d041000110d906460213.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1d041000110d906460213.jpg" style="cursor:pointer;display:block"><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p>注意：<code>git config --global</code> 参数，有了这个参数，表示<strong>你这台机器上所有的Git仓库都会使用这个配置</strong>，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><hr><br><h2 id="Git使用">Git使用</h2><h3 id="创建版本库">创建版本库</h3><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><img 图片6 src="http://img.mukewang.com/59c1d1060001909005780268.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d1060001909005780268.png" style="cursor:pointer;display:block"><p>pwd 命令是用于显示当前的目录。</p><h4 id="把这个目录变成git可以管理的仓库">把这个目录变成git可以管理的仓库</h4><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><img 图片7 src="http://img.mukewang.com/59c1d12b0001b08305270077.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d12b0001b08305270077.png" style="cursor:pointer;display:block"><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><img 图片8 src="http://img.mukewang.com/59c1d143000112df06120173.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d143000112df06120173.png" style="cursor:pointer;display:block"><hr><h4 id="把文件添加到版本库中">把文件添加到版本库中</h4><p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><b>示例demo：</b></p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p><strong>第一步：使用命令 <code>git add readme.txt</code>添加到暂存区</strong>里面去，如下：<br></p><img 图片9 src="http://img.mukewang.com/59c1d2080001e4bb04490080.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2080001e4bb04490080.png" style="cursor:pointer;display:block"><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p><strong>第二步：用命令 <code>git commit</code>告诉Git，把文件提交到仓库</strong>:<br></p><img 图片10 src="http://img.mukewang.com/59c1d2200001f05b04930121.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2200001f05b04930121.png" style="cursor:pointer;display:block"><p>这样我们就已经提交了一个readme.txt文件了</p><p><strong>第三步：使用命令<code>git status</code>来查看是否还有文件未提交</strong>，如下：<br></p><img 图片11 src="http://img.mukewang.com/59c1d2340001a87904690107.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2340001a87904690107.png" style="cursor:pointer;display:block"><p>说明没有任何文件未提交</p><p><strong>第四步：继续来修改readme.txt内容，比如我在下面添加一行2222222222内容，继续使用<code>git status</code>来查看下结果</strong>，如下：<br></p><img 图片12 src="http://img.mukewang.com/59c1d2500001634606170171.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2500001634606170171.png" style="cursor:pointer;display:block"><p>上面的命令告诉我们 readme.txt文件已被修改，但是<strong>未被提交的修改</strong>。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？</p><p><strong>第五步：使用<code>git diff readme.txt</code>查看文件到底改了什么内容</strong>，如下：<br></p><img 图片13 src="http://img.mukewang.com/59c1d2cb00010a0304960202.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2cb00010a0304960202.png" style="cursor:pointer;display:block"><p>如上可以看到，readme.txt文件内容从一行11111111改成二行添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是<code>git add</code>；第二步是：<code>git commit</code>)，如下：<br></p><img 图片14 src="http://img.mukewang.com/59c1d2ff00015a9606180342.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2ff00015a9606180342.png" style="cursor:pointer;display:block"><hr><br><h3 id="版本回退">版本回退</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为<strong>33333333333333</strong>继续执行命令如下：</p><img 图片15 src="http://img.mukewang.com/59c1d32b00012ba604570139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d32b00012ba604570139.png" style="cursor:pointer;display:block"><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？</p><h4 id="使用命令 git log 查看历史记录">使用命令 git log 查看历史记录</h4><img 图片16 src="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" style="cursor:pointer;display:block"><p><code>git log</code>命令显示<strong>从最近到最远</strong>的修改日志，我们可以看到最近有三次提交，最近的一次是：增加内容为333333；上一次是添加内容222222；第一次默认是 111111.<br></p><p>如果<strong>嫌上面显示的信息太多的话，我们可以使用命令 <code>git log –pretty=oneline</code></strong>演示如下：<br></p><img 图片17 src="http://img.mukewang.com/59c1d3fc00013ad206040097.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d3fc00013ad206040097.png" style="cursor:pointer;display:block"><hr><h4 id="使用命令 git reset 进行版本回退">使用命令 git reset 进行版本回退</h4><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令：<br></p><ul><li>第一种是：<code>git reset --hard HEAD^</code>，那么如果要回退到<strong>上上个版本只需把HEAD^ 改成 HEAD^^，以此类推</strong></li><li>第二种是：<code>git reset --hard HEAD~1</code>，第一种方法如果要回退到前100个版本的话，肯定不方便，这时可以使用简便命令操作：<code>git reset --hard HEAD~100</code></li></ul><p><strong>未回退之前</strong>的readme.txt内容如下：<br></p><img 图片18 src="http://img.mukewang.com/59c1d4140001a0c404490165.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4140001a0c404490165.png" style="cursor:pointer;display:block"><p>如果想<strong>回退到上一个版本</strong>的命令如下操作：</p><img 图片19 src="http://img.mukewang.com/59c1d429000199fc04610105.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d429000199fc04610105.png" style="cursor:pointer;display:block"><p><strong>使用命令cat readme.txt查看下 readme.txt内容</strong>，如下：<br></p><img 图片20 src="http://img.mukewang.com/59c1d4470001fcdc04360085.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4470001fcdc04360085.png" style="cursor:pointer;display:block"><p>可以看到，<strong>内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息</strong>，如下：<br></p><img 图片21 src="http://img.mukewang.com/59c1d45300012d9604800219.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d45300012d9604800219.png" style="cursor:pointer;display:block"><p>发现增加333333内容已经没有了</p><hr><h4 id="使用命令 git reset 结合 git reflog 进行版本号回退">使用命令 git reset 结合 git reflog 进行版本号回退</h4><p>如果现在想<strong>回退到最新的版本</strong>，如：有333333的内容要如何恢复呢？我们可以<strong>通过版本号回退</strong>，使用命令：<code>git reset --hard 版本号</code> ，但是现在的问题<strong>假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？</strong><br></p><p>可以<strong>通过<code>git reflog</code>命令获取到版本号</strong>，演示如下：<br></p><img 图片22 src="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" style="cursor:pointer;display:block"><p>通过上面的显示我们可以知道，增加内容3333的版本号是 <code>6fcfc89</code>。我们现在可以使用命令：<code>git reset --hard 6fcfc89</code>来恢复了，演示如下：<br></p><img 图片23 src="http://img.mukewang.com/59c1d53a0001b8b305050153.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d53a0001b8b305050153.png" style="cursor:pointer;display:block"><p>可以看到目前已经是最新的版本了。</p><hr><br><h3 id="理解工作区与暂存区的区别">理解工作区与暂存区的区别</h3><ul><li>工作区：就是你在<strong>电脑上看到的目录</strong>，比如目录下testgit里的文件(<code>.git</code>隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li><li>版本库(Repository)：<strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库</strong>。其中版本库里面存了很多东西，其中最重要的就是<strong>stage(暂存区)</strong>，还有Git为我们<strong>自动创建了第一个分支master</strong>,以及<strong>指向master的一个指针HEAD</strong>。</li></ul><p>我们前面说过使用<strong>Git提交文件到版本库有两步</strong>：</p><ul><li>第一步：是使用<code>git add</code>把文件添加进去，实际上就是把文件<strong>添加到暂存区</strong></li><li>第二步：使用<code>git commit</code>提交更改，实际上就是<strong>把暂存区的所有内容提交到当前分支上</strong></li></ul><p>继续使用demo来演示下：</p><p>我们在readme.txt再<u>添加一行内容为4444444</u>，接着在目录下<u>新建一个文件为test.txt 内容为test</u>，我们先用命令<code>git status</code>来查看下状态，如下：</p><img 图片24 src="http://img.mukewang.com/59c1d55a0001a3c306430241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d55a0001a3c306430241.png" style="cursor:pointer;display:block"><p>现在我们先<strong>使用<code>git add</code>命令把2个文件都添加到暂存区</strong>中，再使用<code>git status</code>来查看下状态，如下：</p><img 图片25 src="http://img.mukewang.com/59c1d56a0001a28704700241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d56a0001a28704700241.png" style="cursor:pointer;display:block"><p>接着我们可以<strong>使用<code>git commit</code>一次性提交到分支上</strong>，如下：</p><img 图片26 src="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" style="cursor:pointer;display:block"><hr><br><h3 id="撤销修改和删除文件操作">撤销修改和删除文件操作</h3><h4 id="撤销修改">撤销修改</h4><p>现在在readme.txt文件里面增加一行内容为555555555555，我们先通过命令查看如下：<br></p><img 图片27 src="http://img.mukewang.com/59c1d5e40001806803930139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5e40001806803930139.png" style="cursor:pointer;display:block"><p>在我<strong>未提交之前</strong>，我发现添加5555555555555内容有误，所以我得马上<strong>恢复以前的版本</strong>，现在我可以有如下几种方法可以做修改：</p><ul><li>第一：如果我知道要删掉那些内容的话，直接<strong>手动更改</strong>去掉那些需要的文件，然后add添加到暂存区，最后commit掉</li><li>第二：使用<code>git reset --hard HEAD^</code>直接恢复到上一个版本</li><li>第三：使用撤销命令<code>git checkout --</code>，下面讲解如何使用撤销命令</li></ul><p>首先在做撤销之前，我们可以先用<code>git status</code>查看下当前的状态。如下所示：</p><img 图片28 src="http://img.mukewang.com/59c1d5fa0001b07806400168.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5fa0001b07806400168.png" style="cursor:pointer;display:block"><p>可以发现，Git会告诉你，<strong><code>git checkout -- file</code>可以丢弃工作区的修改</strong>，例如使用<code>git checkout -- readme.txt</code>：</p><img 图片29 src="http://img.mukewang.com/59c1d6390001419705210140.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6390001419705210140.png" style="cursor:pointer;display:block"><p><strong>命令<code>git checkout --readme.txt</code>意思就是：把readme.txt文件在工作区做的修改全部撤销</strong>，这里有2种情况：</p><ul><li>readme.txt自动修改后，还<strong>没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态</strong></li><li>readme.txt<strong>已经放入暂存区了，接着又作了修改，撤销修改就回到<u>添加暂存区后</u>的状态</strong></li></ul><p><strong>也就是说<code>git checkout --readme.txt</code>只能撤销没有提交到暂存区的修改</strong></p><p>对于上面列举的<strong>第二种情况</strong>，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我<code>git add</code>添加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><img 图片30 src="http://img.mukewang.com/59c1d6ca0001782f06160482.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6ca0001782f06160482.png" style="cursor:pointer;display:block"><p><mark>注意：命令<code>git checkout -- readme.txt</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了。</mark></p><hr><h4 id="删除文件">删除文件</h4><p>假如我现在版本库testgit目录<u>添加一个文件b.txt,然后提交</u>，如下：<br></p><img 图片31 src="http://img.mukewang.com/59c1d6de0001a31606390392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6de0001a31606390392.png" style="cursor:pointer;display:block"><p>如上：一般情况下，可以<strong>直接在文件目录中把文件删了</strong>，或者<strong>使用如上<code>rm</code>命令：<code>rm b.txt</code></strong>，如果我想<strong>彻底从版本库中删掉了此文件的话，可以再执行commit命令提交掉</strong>，现在目录是这样的：<br></p><img 图片32 src="http://img.mukewang.com/59c1d78200017e8f07030192.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d78200017e8f07030192.png" style="cursor:pointer;display:block"><hr><h4 id="撤销删除操作">撤销删除操作</h4><p>只要<strong><u>没有commit之前</u>，如果我想在版本库中恢复此文件如何操作呢？</strong>，可以使用如下命令<strong><code>git checkout -- b.txt</code></strong>，如下所示：</p><img 图片33 src="http://img.mukewang.com/59c1d7980001368e05570244.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7980001368e05570244.png" style="cursor:pointer;display:block"><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><img 图片34 src="http://img.mukewang.com/59c1d7b70001308907550258.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7b70001308907550258.png" style="cursor:pointer;display:block"><hr><br><h3 id="远程仓库">远程仓库</h3><h4 id="建立传输连接">建立传输连接</h4><p>以Github为例进行远程仓库的操作，首先需要建立本地Git仓库和Github仓库之间的传输(通过SSH加密的)连接</p><p><strong>第一步：创建SSHKey</strong>。在用户主目录下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入命令：<code>ssh-keygen -t rsa –C “youremail@example.com”</code>, 结果如下所示：</p><img 图片35 src="http://img.mukewang.com/59c1d7d7000120d107530169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7d7000120d107530169.png" style="cursor:pointer;display:block"><p>注意：<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第二步：在Github中添加公钥</strong>。登录Github,打开“settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴<code>id_rsa.pub</code>文件的内容。<br></p><img 图片36 src="http://img.mukewang.com/59c1d7ef0001c75411330860.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7ef0001c75411330860.png" style="cursor:pointer;display:block"><p>点击Add Key，你就应该可以看到已经添加的key。<br></p><img 图片37 src="http://img.mukewang.com/59c1d8540001eb3707620373.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8540001eb3707620373.png" style="cursor:pointer;display:block"><hr><h4 id="添加远程库">添加远程库</h4><p><strong>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在Github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样Github的仓库可以作为备份，又可以其他人通过该仓库来协作。</strong></p><p>首先，登录Github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><img 图片38 src="http://img.mukewang.com/59c1d86a0001044b10840605.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d86a0001044b10840605.png" style="cursor:pointer;display:block"><p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br></p><img 图片39 src="http://img.mukewang.com/59c1d8850001b5ea10260661.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8850001b5ea10260661.png" style="cursor:pointer;display:block"><p>目前，在GitHub上的这个testgit仓库还是空的，GitHub提示我们，<strong>可以从这个仓库克隆出新的仓库</strong>，<strong>也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库</strong>。<br>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p><img 图片40 src="http://img.mukewang.com/59c1d8a70001c86206320252.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8a70001c86206320252.png" style="cursor:pointer;display:block"><p><strong>把本地库的内容推送到远程，使用<code>git push</code>命令，实际上是把当前分支master推送到远程。</strong></p><div class="note info"><p>由于远程库是空的，我们第一次推送master分支时，加上了<code>–u</code>参数，<strong>Git不但会把本地的master分支内容推送的远程新的master分支</strong>，还会<strong>把本地的master分支和远程的master分支关联起来</strong>，在以后的推送或者拉取时就可以简化命令。</p></div><p>推送成功后，可以立刻在Github页面中看到远程库的内容已经和本地一模一样了:<br></p><img 图片41 src="http://img.mukewang.com/59c1d8bb00019ff310480655.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8bb00019ff310480655.png" style="cursor:pointer;display:block"><p><strong>从现在起，只要本地作了提交，就可以通过命令：<code>git push origin master</code>把本地master分支的最新修改推送到Github上了，现在你就拥有了真正的分布式版本库了。</strong></p><hr><h4 id="克隆远程库到本地">克隆远程库到本地</h4><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。现在我们想，假如<strong>远程库有新的内容了，我想克隆到本地来，如何克隆呢？</strong></p><p>首先，登录Github，创建一个新的仓库，名字叫testgit2，如下：</p><img 图片42 src="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" style="cursor:pointer;display:block"> <img 图片43 src="http://img.mukewang.com/59c1d97400014d4e10360484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d97400014d4e10360484.png" style="cursor:pointer;display:block"><p>接下来，使用命令<code>git clone</code>克隆一个本地库了。如下所示：</p><img 图片44 src="http://img.mukewang.com/59c1d9860001e0d806370127.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9860001e0d806370127.png" style="cursor:pointer;display:block"><p>操作完成后可以发现在我本地目录下生成testgit2目录了，如下所示：</p><img 图片45 src="http://img.mukewang.com/59c1d99500016a2e07130197.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d99500016a2e07130197.png" style="cursor:pointer;display:block"><hr><br><h3 id="分支操作">分支操作</h3><p>在版本回填退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<strong>主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p><strong>Git的分支操作主要包括：创建分支、合并分支、删除分支</strong></p><h4 id="创建分支">创建分支</h4><p>首先，我们来<strong>创建dev分支</strong>，然后<strong>切换到dev分支上</strong>，如下操作：</p><img 图片46 src="http://img.mukewang.com/59c1d9aa0001c15604080167.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9aa0001c15604080167.png" style="cursor:pointer;display:block"><div class="note info"><ul><li><strong><code>git checkout</code>命令加上<code>–b</code>参数表示创建并切换，相当于2条命令</strong>：<ul><li><strong><code>git branch dev</code>(新建分支)</strong></li><li><strong><code>git checkout dev</code>(切换分支)</strong></li></ul></li><li><strong><code>git branch</code>查看分支，会列出所有的分支，当前分支前面会添加一个星号</strong></li></ul></div><p>接下来我们<strong>在dev分支上</strong>继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><img 图片47 src="http://img.mukewang.com/59c1da3f0001b5b703890392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da3f0001b5b703890392.png" style="cursor:pointer;display:block"><p>现在dev分支工作已完成，现在我们<strong>切换到主分支master</strong>上，继续查看readme.txt内容如下：</p><img 图片48 src="http://img.mukewang.com/59c1da520001d44c06340206.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da520001d44c06340206.png" style="cursor:pointer;display:block"><div class="note info"><p>不同分支上的内容修改是不共享的，如果想要共享需要使用合并操作，具体请看下文</p></div><hr><h4 id="合并分支">合并分支</h4><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令<code>git merge dev</code>如下所示：<br></p><img 图片49 src="http://img.mukewang.com/59c1da69000145ca05320255.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da69000145ca05320255.png" style="cursor:pointer;display:block"><ul><li><strong><code>git merge</code>命令用于合并指定分支到当前分支上</strong>，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的</li><li><strong>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快</strong></li></ul><hr><h4 id="删除分支">删除分支</h4><p>合并完成后，我们可以使用命令<code>git branch –d dev</code>删除dev分支了，操作如下：</p><img 图片50 src="http://img.mukewang.com/59c1da91000120cd06430139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da91000120cd06430139.png" style="cursor:pointer;display:block"><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><hr><h4 id="分支合并冲突">分支合并冲突</h4><p><mark>当我们同时在两个分支中修改同一个文件，并将其合并的时候会出现分支合并冲突</mark>，示例如下：<br><strong>首先</strong>，先新建一个新分支，比如名字叫fenzhi1，<strong>在readme.txt添加一行内容8888888，然后提交</strong>，如下所示：<br></p><img 图片51 src="http://img.mukewang.com/59c1db410001036105690462.png" alt="图片描述" data-original="http://img.mukewang.com/59c1db410001036105690462.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，我们现在<strong>切换到master分支上来，也在readme.txt最后一行添加内容，内容为99999999，然后提交</strong>，如下所示：</p><img 图片52 src="http://img.mukewang.com/59c1daaf0001133205840500.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daaf0001133205840500.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们在master分支上来合并fenzhi1，<strong>直接使用<code>git merge</code>会提示conflict，然后使用<code>git status</code>查看发现在两个分支中readme.txt都被修改了，此时打开readme.txt文件发现出现了冲突的内容显示</strong>，具体内容和操作截图如下：</p><img 图片53 src="http://img.mukewang.com/59c1daff000106eb06340589.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daff000106eb06340589.png" style="cursor:pointer;display:block"><p><strong>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以手动对readme.txt文件进行如下修改后保存</strong>：<br></p><img 图片54 src="http://img.mukewang.com/59c1dbaf00015f2205770266.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbaf00015f2205770266.png" style="cursor:pointer;display:block"><p><strong>最后</strong>，使用命令<code>git log</code>命令查看分支合并的情况：<br></p><img 图片55 src="http://img.mukewang.com/59c1dbc50001076c04970869.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbc50001076c04970869.png" style="cursor:pointer;display:block"><hr><h4 id="分支合并模式">分支合并模式</h4><p><strong>通常合并分支时，Git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</strong><br>首先我们来做demo演示下：</p><div class="highlight"><pre><code class="language-text">            创建一个dev分支;            修改readme.txt内容;            添加到暂存区;            切换回主分支(master);            合并dev分支，使用命令 git merge –no-ff -m “注释” dev;            查看历史记录;        </code></pre></div><img 图片56 src="http://img.mukewang.com/59c1dbdc0001836d06030780.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbdc0001836d06030780.png" style="cursor:pointer;display:block"><hr><h4 id="分支管理策略">分支管理策略</h4><div class="note info"><p><strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</strong></p></div><hr><h4 id="创建bug分支">创建bug分支</h4><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，<strong>每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</strong></p><p>例如，我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，<strong>当前的dev分支上的工作还没有提交</strong>，具体如下：</p><img 图片57 src="http://img.mukewang.com/59c1dc4e000141b306260166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc4e000141b306260166.png" style="cursor:pointer;display:block"><p><strong>这里并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成</strong>。怎么办呢？还好，<strong>Git还提供了一个<code>stash</code>功能，可以把当前工作现场”隐藏起来”，等以后恢复现场后继续工作</strong>。如下：</p><img 图片58 src="http://img.mukewang.com/59c1dc63000121ff06510188.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc63000121ff06510188.png" style="cursor:pointer;display:block"><p>现在我可以通过创建issue-404分支来修复bug了，具体的实施步骤如下：</p><p><strong>首先</strong>，我们要<strong>确定在哪个分支上修复bug</strong>，比如我现在是在主分支master上来修复的，现在我要在master分支上<strong>创建</strong>一个临时分支，演示如下：</p><img 图片59 src="http://img.mukewang.com/59c1dc7000010f8506010533.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc7000010f8506010533.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，在<strong>修复完成</strong>后<strong>切换</strong>到master分支上，并完成<strong>合并</strong>，最后<strong>删除</strong>issue-404分支。演示如下：</p><img 图片60 src="http://img.mukewang.com/59c1dce00001c1ed06120441.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dce00001c1ed06120441.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们<strong>回到dev分支</strong>上干活:<br></p><img 图片61 src="http://img.mukewang.com/59c1dcfa00019c8104220136.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dcfa00019c8104220136.png" style="cursor:pointer;display:block"><p><strong>但是</strong>，我们发现<strong>工作区是干净的</strong>，那么我们工作现场去哪里呢？我们可以<strong>使用命令<code>git stash list</code>来查看工作现场</strong>。如下：</p><img 图片62 src="http://img.mukewang.com/59c1dd07000152b404340093.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd07000152b404340093.png" style="cursor:pointer;display:block"><p>通过<code>git stash list</code>发现工作现场还在，Git把<code>stash</code>内容存在某个地方了，但是需要<strong>恢复</strong>一下，可以使用如下2个方法：</p><ul><li><code>git stash apply</code>恢复，<strong>恢复后，<code>stash</code>内容并不删除，你需要使用命令<code>git stash drop</code>来删除</strong></li><li>另一种方式是使用<code>git stash pop</code>，<strong>恢复的同时把<code>stash</code>内容也删除了</strong></li></ul><p>示例如下：</p><img 图片63 src="http://img.mukewang.com/59c1dd1f000174d406380466.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd1f000174d406380466.png" style="cursor:pointer;display:block"><hr><h4 id="多人协作">多人协作</h4><h5 id="查看远程库的信息">查看远程库的信息</h5><p>当你从<strong>远程库克隆</strong>时候，<strong>实际上Git自动把本地的master分支和远程的master分支对应起来了，并且<u>远程库的默认名称是origin</u>。</strong></p><p>要<strong>查看远程库的信息</strong>，使用<code>git remote</code><br>要<strong>查看远程库的详细信息</strong>，使用<code>git remote –v</code>，具体操作如下：</p><img 图片64 src="http://img.mukewang.com/59c1dd7d000136fd06190169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd7d000136fd06190169.png" style="cursor:pointer;display:block"><hr><h5 id="推送分支">推送分支</h5><p>推送分支就是<strong>把该分支上所有本地提交到远程库</strong>中，推送时<strong>要指定本地分支</strong>，这样Git就会<strong>把该分支推送到远程库对应的远程分支上</strong></p><p><strong>把本地分支推送到远程分支</strong>，使用<code>git push origin master</code></p><p>例如，我的<strong>Github(远程库)</strong>上的readme.txt代码如下：<br></p><img 图片65 src="http://img.mukewang.com/59c1dd90000164a508280459.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd90000164a508280459.png" style="cursor:pointer;display:block"><p><strong>本地</strong>的readme.txt代码如下：<br></p><img 图片66 src="http://img.mukewang.com/59c1dda60001771804210205.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dda60001771804210205.png" style="cursor:pointer;display:block"><p>现在我想把<strong>本地更新</strong>的readme.txt代码<strong>推送到远程库</strong>中，使用命令如下：<br></p><img 图片67 src="http://img.mukewang.com/59c1ddbf0001271e05410203.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddbf0001271e05410203.png" style="cursor:pointer;display:block"><p>我们可以看到如上Git信息提示，推送成功，然后我们可以看看Github上的readme.txt内容 如下：</p><img 图片68 src="http://img.mukewang.com/59c1ddcf0001771f08100484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddcf0001771f08100484.png" style="cursor:pointer;display:block"><p>可以看到推送成功了，如果我们现在要<strong>推送到其他分支</strong>，比如dev分支上，我们还是那个命令<code>git push origin dev</code></p><div class="note info"><p>那么一般情况下，那些分支要推送呢？</p><p><strong>master分支是主分支</strong>，因此要<strong>时刻与远程同步</strong>；一些<strong>修复bug分支不需要推送到远程去</strong>，可以<strong>先合并</strong>到主分支(或者dev分支)上，然后把主分支master(或者dev分支)推送到远程去</p></div><hr><h5 id="抓取分支">抓取分支</h5><p><strong>多人协作时，大家都会往master分支上推送各自的修改</strong>。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到Github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2，具体的协作步骤如下：</p><p><strong>首先</strong>，我要把dev分支也要<strong>推送</strong>到远程去，如下：</p><img 图片69 src="http://img.mukewang.com/59c1ded800014adf05030151.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1ded800014adf05030151.jpg" style="cursor:pointer;display:block"><p><strong>然后</strong>，进入testgit2目录，进行<strong>克隆</strong>远程的库到本地来(模拟的协作)，如下：<br></p><img 图片70 src="http://img.mukewang.com/59c1deb70001ec7605080170.png" alt="图片描述" data-original="http://img.mukewang.com/59c1deb70001ec7605080170.png" style="cursor:pointer;display:block"><p>现在目录下生成有如下所示：<br></p><img 图片71 src="http://img.mukewang.com/59c1defe0001942707180256.png" alt="图片描述" data-original="http://img.mukewang.com/59c1defe0001942707180256.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们的小伙伴要在dev分支上做开发，就必须<strong>把远程的origin的dev分支到本地来</strong>，于是可以<strong>使用命令创建本地dev分支：<code>git checkout –b dev origin/dev</code></strong>。创建完成后，小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时，如下：<br></p><img 图片72 src="http://img.mukewang.com/59c1df160001ef1e06020730.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df160001ef1e06020730.png" style="cursor:pointer;display:block"><p><strong>下一步</strong>，小伙伴们<strong>已经向origin/dev分支上推送了提交</strong>，而我在<strong>我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库</strong>时，如下：<br></p><img 图片73 src="http://img.mukewang.com/59c1df340001209306470759.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df340001209306470759.png" style="cursor:pointer;display:block"><p>由上面可知：推送失败，<strong>因为我的小伙伴最新提交的和我试图推送的有冲突</strong>，<strong>解决的办法</strong>也很简单，上面已经提示我们，<strong>先用<code>git pull</code>把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</strong></p><img 图片74 src="http://img.mukewang.com/59c1dfa60001473e05940282.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfa60001473e05940282.png" style="cursor:pointer;display:block"><p><code>git pull</code>也失败了，原因是<strong>没有指定本地dev分支与远程origin/dev分支的链接</strong>，根据提示，<strong>设置dev和origin/dev的链接，使用<code>git branch --set-upstream dev origin/dev</code></strong>，如下：</p><img 图片75 src="http://img.mukewang.com/59c1dfc8000159c106460199.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfc8000159c106460199.png" style="cursor:pointer;display:block"><p>这回git pull成功，但是<strong>合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</strong>。解决后，提交，再push。我们可以先来看看readme.txt内容：</p><img 图片76 src="http://img.mukewang.com/59c1dff70001a87605190277.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dff70001a87605190277.png" style="cursor:pointer;display:block"><p>手动解决完后，接着再提交，再push到远程库里面去。如下所示：<br></p><img 图片77 src="http://img.mukewang.com/59c1e0130001843906050480.png" alt="图片描述" data-original="http://img.mukewang.com/59c1e0130001843906050480.png" style="cursor:pointer;display:block"><div class="note info"><p>总结一下，多人协作工作模式一般是这样的：</p><ul><li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li><li>如果<strong>推送失败</strong>，则因为远程分支比你的本地更新早，需要先用<code>git pull</code>试图合并；</li><li>如果<strong>合并有冲突</strong>，则需要解决冲突，并在本地提交，然后再用<code>git push origin branch-name</code>推送。</li></ul></div><p>感谢龙恩的贡献：<a href="http://link.zhihu.com/?target=http%3A//www.cnblogs.com/tugenhua0707/p/4050072.html" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">cnblogs.com/tugenhua070</span><span class="invisible">7/p/4050072.html</span><span class="ellipsis"></span></a></p><hr><br><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell解析命令行过程以及eval命令</title>
      <link href="/posts/29719.html"/>
      <url>/posts/29719.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的过程以及eval命令</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML常用字符实体</title>
      <link href="/posts/45689.html"/>
      <url>/posts/45689.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括<code>特色字符实体</code>、<code>常用字符实体</code>、<code>货币类字符实体</code>、<code>数字类字符实体</code>、<code>方向类字符实体</code>以及<code>其他字符实体</code>，以供需要时查阅</p></div><a id="more"></a><h2 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h2><p>一些字符在 HTML 中拥有特殊的含义，比如小于号<code>&lt;</code>用于定义 HTML 标签的开始，在这种情况下如果我们<strong>希望浏览器正确地显示这些字符</strong>，我们必须在 HTML 源码中<strong>插入字符实体</strong>来使HTML不将其当做具有特殊含义的字符，例如，要在 HTML 文档中显示小于号，我们需要这样写：<code>&amp;lt;</code> 或者 <code>&amp;#60;</code>。</p><p><strong>字符实体有三部分：</strong></p><ul><li>一个和号<code>&amp;</code></li><li>一个实体名称，或者 <code>#</code> 和一个实体编号</li><li>以及一个分号 <code>;</code></li></ul><p>使用<strong>实体名称</strong>而<strong>不是实体编号</strong>的<strong>好处</strong>在于，名称相对来说更容易记忆；而这么做的<strong>坏处</strong>是，并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。</p><p><strong>注意：实体对大小写敏感。</strong></p><hr><h2 id="特色HTML字符实体"><a href="#特色HTML字符实体" class="headerlink" title="特色HTML字符实体"></a>特色HTML字符实体</h2><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:40%}</style><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线，常用作菜单或导航中的分隔符</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>圆点，有时被用来作为菜单分隔符</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头，常用作网页“返回页面顶部”标识</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元标识</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2，数学中的平方，在数字处理中常用到，例如：<strong>1000²</strong></td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>心型，用来表达你的心</td></tr></tbody></table><hr><h2 id="常用HTML字符实体"><a href="#常用HTML字符实体" class="headerlink" title="常用HTML字符实体"></a>常用HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&nbsp;</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td>空格</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td>&amp;#38;</td><td>and符号，与</td></tr><tr><td>"</td><td>&amp;quot;</td><td>&amp;#34;</td><td>引号</td></tr><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>®</td><td>&amp;reg;</td><td>&amp;#187;</td><td>注册标志</td></tr><tr><td>™</td><td>&amp;trade;</td><td>&amp;#153;</td><td>商标标志</td></tr><tr><td>“</td><td>&amp;ldquo;</td><td>&amp;#147;</td><td>左双引号</td></tr><tr><td>”</td><td>&amp;rdquo;</td><td>&amp;#148;</td><td>右双引号</td></tr><tr><td>‘</td><td>&amp;lsquo;</td><td>&amp;#145;</td><td>做单引号</td></tr><tr><td>’</td><td>&amp;rsquo;</td><td>&amp;#146;</td><td>右单引号</td></tr><tr><td>«</td><td>&amp;laquo;</td><td>&amp;#171;</td><td>左三角双引号</td></tr><tr><td>»</td><td>&amp;raquo;</td><td>&amp;#187;</td><td>右三角双引号</td></tr><tr><td>‹</td><td>&amp;lsaquo;</td><td>&amp;#8249;</td><td>左三角单引号</td></tr><tr><td>›</td><td>&amp;rsaquo;</td><td>&amp;#8250;</td><td>右三角单引号</td></tr><tr><td>§</td><td>&amp;sect;</td><td>&amp;#167;</td><td>章节标志</td></tr><tr><td>¶</td><td>&amp;para;</td><td>&amp;#182;</td><td>段落标志</td></tr><tr><td>•</td><td>&amp;bull;</td><td>&amp;#149;</td><td>列表圆点（大）</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>列表圆点（中）</td></tr><tr><td>…</td><td>&amp;hellip;</td><td>&amp;#8230;</td><td>省略号</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线</td></tr><tr><td>¦</td><td>&amp;brvbar;</td><td>&amp;#166;</td><td>断的竖线</td></tr><tr><td>–</td><td>&amp;ndash;</td><td>&amp;#150;</td><td>短破折号</td></tr><tr><td>—</td><td>&amp;mdash;</td><td>&amp;#151;</td><td>长破折号</td></tr></tbody></table><hr><h2 id="货币类HTML字符实体"><a href="#货币类HTML字符实体" class="headerlink" title="货币类HTML字符实体"></a>货币类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>¤</td><td>&amp;curren;</td><td>&amp;#164;</td><td>一般货币符号</td></tr><tr><td>$</td><td>&nbsp;</td><td>&amp;#36;</td><td>美元符号</td></tr><tr><td>¢</td><td>&amp;cent;</td><td>&amp;#162;</td><td>分</td></tr><tr><td>£</td><td>&amp;pound;</td><td>&amp;#163;</td><td>英镑</td></tr><tr><td>¥</td><td>&amp;yen;</td><td>&amp;#165;</td><td>日元</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元</td></tr></tbody></table><hr><h2 id="数字类HTML字符实体"><a href="#数字类HTML字符实体" class="headerlink" title="数字类HTML字符实体"></a>数字类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&amp;#60;</td><td>小于号</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&amp;#62;</td><td>大于号</td></tr><tr><td>≤</td><td>&amp;le;</td><td>&amp;#8804;</td><td>小于等于号</td></tr><tr><td>≥</td><td>&amp;ge;</td><td>&amp;#8805;</td><td>大于等于号</td></tr><tr><td>×</td><td>&amp;times;</td><td>&amp;#215;</td><td>乘号</td></tr><tr><td>÷</td><td>&amp;divide;</td><td>&amp;#247;</td><td>除号</td></tr><tr><td>−</td><td>&amp;minus;</td><td>&amp;#8722;</td><td>减号</td></tr><tr><td>±</td><td>&amp;plusmn;</td><td>&amp;#177;</td><td>加/减 号</td></tr><tr><td>≠</td><td>&amp;ne;</td><td>&amp;#8800;</td><td>不等于号</td></tr><tr><td>¹</td><td>&amp;sup1;</td><td>&amp;#185;</td><td>上标1</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2</td></tr><tr><td>³</td><td>&amp;sup3;</td><td>&amp;#179;</td><td>上标3</td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>¼</td><td>&amp;frac14;</td><td>&amp;#188;</td><td>四分之一</td></tr><tr><td>¾</td><td>&amp;frac34;</td><td>&amp;#190;</td><td>四分之三</td></tr><tr><td>‰</td><td>&amp;permil;</td><td>&amp;#8240;</td><td>千分率</td></tr><tr><td>°</td><td>&amp;deg;</td><td>&amp;#176;</td><td>度</td></tr><tr><td>√</td><td>&amp;radic;</td><td>&amp;#8730;</td><td>平方根</td></tr><tr><td>∞</td><td>&amp;infin;</td><td>&amp;#8734;</td><td>无限大</td></tr></tbody></table><hr><h2 id="方向类HTML字符实体"><a href="#方向类HTML字符实体" class="headerlink" title="方向类HTML字符实体"></a>方向类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>←</td><td>&amp;larr;</td><td>&amp;#8592;</td><td>左箭头</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头</td></tr><tr><td>→</td><td>&amp;rarr;</td><td>&amp;#8594;</td><td>右箭头</td></tr><tr><td>↓</td><td>&amp;darr;</td><td>&amp;#8595;</td><td>下箭头</td></tr><tr><td>↔</td><td>&amp;harr;</td><td>&amp;#8596;</td><td>左右箭头</td></tr><tr><td>↵</td><td>&amp;crarr;</td><td>&amp;#8629;</td><td>回车箭头</td></tr><tr><td>⌈</td><td>&amp;lceil;</td><td>&amp;#8968;</td><td>左上限</td></tr><tr><td><strong>⌉</strong></td><td>&amp;rceil;</td><td>&amp;#8969;</td><td>右上限</td></tr><tr><td><strong>⌊</strong></td><td>&amp;lfloor;</td><td>&amp;#8970;</td><td>左下限</td></tr><tr><td><strong>⌋</strong></td><td>&amp;rfloor;</td><td>&amp;#8971;</td><td>右下限</td></tr></tbody></table><hr><h2 id="其他HTML字符实体"><a href="#其他HTML字符实体" class="headerlink" title="其他HTML字符实体"></a>其他HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>♠</td><td>&amp;spades;</td><td>&amp;#9824;</td><td>黑桃</td></tr><tr><td>♣</td><td>&amp;clubs;</td><td>&amp;#9827;</td><td>梅花</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>红桃，心</td></tr><tr><td>♦</td><td>&amp;diams;</td><td>&amp;#9830;</td><td>方块牌</td></tr><tr><td>◊</td><td>&amp;loz;</td><td>&amp;#9674;</td><td>菱形</td></tr><tr><td>†</td><td>&amp;dagger;</td><td>&amp;#8224;</td><td>匕首</td></tr><tr><td>‡</td><td>&amp;Dagger;</td><td>&amp;#8225;</td><td>双剑号</td></tr><tr><td>¡</td><td>&amp;iexcl;</td><td>&amp;#161;</td><td>反向感叹号</td></tr><tr><td>¿</td><td>&amp;iquest;</td><td>&amp;#191;</td><td>反向问号</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/cutdragonhit/p/9785350.html" target="_blank" rel="noopener">HTML实体符号</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/4159374.html" target="_blank" rel="noopener">网页中常用HTML字符实体</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux通配符和正则表达式及其区别</title>
      <link href="/posts/37480.html"/>
      <url>/posts/37480.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像<code>awk</code>、<code>sed</code>、<code>grep</code>使用正则表达式、像<code>find</code>、<code>ls</code>、<code>cp</code>使用通配符。</p></div><a id="more"></a><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls <span class="built_in">test</span>*.txt</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls d*.txt</span><br><span class="line">  ls: cannot access d*.txt: No such file or directory</span><br></pre></td></tr></table></figure><hr><h3 id="通配符的作用方式"><a href="#通配符的作用方式" class="headerlink" title="通配符的作用方式"></a>通配符的作用方式</h3><p><strong>通配符是由<code>shell</code>处理的</strong>(不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍), 它只会出现在命令的<strong>参数</strong>里(它不用在命令名称里， 也不用在操作符上)。<strong>当shell在参数中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个<u>普通字符传递给命令</u>，然后再由命令进行处理</strong>。总之，<strong>通配符实际上就是一种shell实现的路径扩展功能</strong>。在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。</p><p>我们回过头分析上面命令：</p><ul><li>在第2个命令中，<strong>test*.txt 实际shell搜索文件,找到了符合条件的文件，命令会变成</strong>：<code>ls test2.txt test3.txt test.txt</code> ,实际在执行<code>ls</code>时候传给它的<strong>参数</strong>是test2.txt test3.txt test.txt。</li><li>而命令3，<code>d*.txt</code> 由于当前目录下面没有这样的文件或目录，直接将<code>d*.txt</code>作为普通字符传给<code>ls</code>作为参数。这个时候<code>*</code>只是一个普通的 <code>ls</code>参数而已，已经<strong>失去了它通配意义</strong>。由于找不到文件，所以会出现：无法访问提示！</li></ul><p>了解了shell通配符，我们现在看下，shell常见通配符有哪些了。</p><hr><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td><code>?</code></td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td><code>\</code></td><td><strong>转义字符</strong>，将特殊符号的特殊意义去除</td><td>例如：rm a[*]c.txt是删除a[*]c.txt文件</td></tr><tr><td><code>[char]</code></td><td>匹配<strong>原始字符char，相当于转义操作</strong></td><td>a[?]b：a与b之间<strong>只有一个字符且为<code>?</code></strong>,此时的<code>?</code>已经不再具有匹配任意一个字符的功能 如: a?b.txt</td></tr><tr><td><code>[list]</code></td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td><code>[!list]</code></td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td><code>[^list]</code></td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[^0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr><tr><td><code>{string1,string2,...}</code></td><td>匹配 sring1 或 string2 (或更多)<strong>其一字符串</strong></td><td>a{abc,xyz,123}b：a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><div class="note info"><p>需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种</p></div><hr><h3 id="通配符示例"><a href="#通配符示例" class="headerlink" title="通配符示例"></a>通配符示例</h3><p><code>[!list]</code> 和<code>[^list]</code>：</p><blockquote><p><code>ls test[^1-2].txt</code><br>test3.txt</p></blockquote><blockquote><p><code>ls test[!1-2].txt</code><br>test3.txt</p></blockquote><p>注意不会出现test.txt，因为test和.txt之间必须要有一个字符，而test.txt不具备这个条件</p><hr><p><br></p><h2 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>^word</td><td>待搜寻的字串(word)在<strong>行首</strong></td><td>grep -n ‘^#’ regular_express.txt：搜寻行首为 # 开始的那一行，并列出行号</td></tr><tr><td>word$</td><td>待搜寻的字串(word)在<strong>行尾</strong></td><td>grep -n ‘!$’ regular_express.txt：将行尾为 ! 的那一行打印出来，并列出行号</td></tr><tr><td>.</td><td>代表<strong>一定有一个任意字符</strong>的字符</td><td>grep -n ‘e.e’ regular_express.txt：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定<strong>仅有一个字符，而空白字符也是字符！</strong></td></tr><tr><td>\</td><td>转义字符，将特殊符号的特殊意义去除</td><td>grep -n \’ regular_express.txt：搜寻含有单引号 ‘ 的那一行</td></tr><tr><td>*</td><td>重复<strong>零个到无穷多个的前一个字符</strong></td><td>grep -n ‘ess*’ regular_express.txt：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字串。另外，之前也可以紧接着一个 RE 字符，例如任意字符则为 “.”</td></tr><tr><td>[list]</td><td>字符集合，匹配list 中的任意单个字符</td><td>grep -n ‘g[ld]’ regular_express.txt：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思</td></tr><tr><td>[n1-n2]</td><td>字符范围，匹配n1-n2中的任意单个字符</td><td>grep -n ‘[A-Z]’ regular_express.txt：搜寻含有大写字母的那一行。需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关。</td></tr><tr><td>[^list]</td><td>字符集合，匹配 除list 中的任意单一字符(一定要有一个)</td><td>不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字</td></tr><tr><td>{n,m}</td><td>连续 n 到 m 个的前一个字符；若为 {n} 则是连续 n 个的前一个字符；若是 {n,} 则是连续 n 个以上的前一个字符</td><td>grep -n ‘go{2,3}g’ regular_express.txt：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)</td></tr></tbody></table><hr><h3 id="延伸正则表达式字符"><a href="#延伸正则表达式字符" class="headerlink" title="延伸正则表达式字符"></a>延伸正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>重复<strong>一个或一个以上的前一个字符</strong></td><td>egrep -n ‘go+d’ regular_express.txt：搜寻 (god) (good) (goood)… 等等的字串，那个 o+ 代表一个以上的 o</td></tr><tr><td>?</td><td><strong>零个或一个的前一个字符</strong></td><td>egrep -n ‘go?d’ regular_express.txt：搜寻 (gd) (god) 这两个字串，那个 o? 代表空的或 1 个 o</td></tr><tr><td>&#124;</td><td>用<strong>或( or )的方式找出数个字串</strong></td><td>egrep -n ‘gd&#124;good’ regular_express.txt：搜寻 gd 或 good 这两个字串</td></tr><tr><td>()</td><td>找出<strong>群组字串</strong></td><td>egrep -n ‘g(la&#124;oo)d’ regular_express.txt：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来</td></tr><tr><td>()+</td><td><strong>多个重复群组的判别</strong></td><td>echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’</td></tr></tbody></table><div class="note info"><p><code>grep</code> <strong>默认仅支持基础正则表达式</strong>，如果要<strong>使用延伸型正则表达式</strong>，你可以使用 <code>grep -E</code> ， 不过更建议直接使用 <code>egrep</code>！直接区分指令比较好记忆！其实 <code>egrep</code> 与 <code>grep -E</code> 是类似命令别名的关系啦！</p></div><h2 id="通配符和正则表达式关系"><a href="#通配符和正则表达式关系" class="headerlink" title="通配符和正则表达式关系"></a>通配符和正则表达式关系</h2><ul><li>在<strong>文本过滤工具里，都是用正则表达式</strong>，比如像<code>awk</code>、<code>sed</code>、<code>grep</code>等，是针对文件的内容的；而<strong>通配符多用在文件名</strong>上，比如<code>find</code>、<code>ls</code>、<code>cp</code>等等</li><li>正则表达式中有部分与通配符是相近的含义，如<code>[list]</code>、<code>[n1-n2]</code>、<code>[^list]</code>，但也有一些差异非常大，如<code>*</code> <strong>在通配符中表示匹配0或多个</strong>字符(可以独立使用)，但<strong>在正则表达式中表示重复零个到无穷多个的<u>前一个字符</u></strong>(不能独立使用)</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://blog.csdn.net/swjtuwyp/article/details/51817472" target="_blank" rel="noopener">linux通配符和正则表达式</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-循环结构</title>
      <link href="/posts/16486.html"/>
      <url>/posts/16486.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇博客主要学习了<code>shell</code>的循环结构，包括<code>for</code>、<code>while</code>、<code>until</code>循环，重点学习了前两个，整理了这两种循环的不同使用情形，同时也学习了循环控制结构的<code>break</code>和<code>continue</code>语句</p></div><a id="more"></a><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环适用于<strong>已经知道需要进行多少次的循环</strong>，所以for循环也叫<strong>固定循环</strong>。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      程序段</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p>为了防止可能的字符分割(变量存在空格)问题，con1 con2 con3都需要被引用(使用双引号括起来)，关于字符分割的示例可以查看<a href="http://showteeth.tech/posts/58105.html">shell-if条件测试</a></p></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用变量进行循环"><a href="#使用变量进行循环" class="headerlink" title="使用变量进行循环"></a>使用变量进行循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line">field1=$(cut -d <span class="string">' '</span> -f 1 test.txt)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;field1&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>this<br>that<br>there<br>those</p></blockquote><blockquote><p><code>name=&quot;my name is test&quot;</code><br><code>for i in ${name};do echo $i;done</code></p></blockquote><p><strong>输出</strong>：</p><blockquote><p>my<br>name<br>is<br>test</p></blockquote><hr><h4 id="使用seq命令进行循环"><a href="#使用seq命令进行循环" class="headerlink" title="使用seq命令进行循环"></a>使用seq命令进行循环</h4><p><strong>seq命令的用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line"></span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -f, --format=FORMAT      use <span class="built_in">printf</span> style floating-point FORMAT</span><br><span class="line">  -s, --separator=STRING   use STRING to separate numbers (default: \n)</span><br><span class="line">  -w, --equal-width        equalize width by padding with leading zeroes</span><br></pre></td></tr></table></figure><p></p><p><strong>默认用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>设置步长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 2 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>1<br>3<br>5</p></blockquote><p><strong>-w设置输出等长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w 1 2 12`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>01<br>03<br>05<br>07<br>09<br>11</p></blockquote><hr><h4 id="使用特殊符号-进行循环"><a href="#使用特殊符号-进行循环" class="headerlink" title="使用特殊符号{}进行循环"></a>使用特殊符号{}进行循环</h4><p><strong>特殊符号<code>{}</code>用法</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  &#123;FIRST..LAST..INCREMENT &#125;</span><br><span class="line">  </span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><p></p><p>对<strong>数字</strong>循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字循环设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>1<br>3<br>5</p></blockquote><p>对<strong>字母</strong>循环：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字母循环也可以设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a&#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..2&#125;&#123;a..d&#125;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>a<br>b<br>c<br>d</p></blockquote><blockquote><p>a<br>c</p></blockquote><blockquote><p>aa<br>ab<br>ac<br>ad</p></blockquote><blockquote><p>1a<br>1b<br>1c<br>1d<br>2a<br>2b<br>2c<br>2d</p></blockquote><p>特殊符号<code>{}</code>中的<strong>两个小数点来代表连续出现的意思</strong>，更多关于特殊符号<code>{}</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用特殊符号-进行循环-1"><a href="#使用特殊符号-进行循环-1" class="headerlink" title="使用特殊符号(())进行循环"></a>使用特殊符号(())进行循环</h4><p><strong>使用形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> （（ 初始值; 限制值; 执行步阶 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i=i+2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i+=2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>特殊符号<code>(())</code>表示<strong>执行计算</strong>，和linux <code>let</code>命令相似，更多关于特殊符号<code>(())</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用通配符进行循环"><a href="#使用通配符进行循环" class="headerlink" title="使用通配符进行循环"></a>使用通配符进行循环</h4><p>通配符主要有星号(<code>*</code>)和问号(<code>?</code>)，用来<strong>模糊搜索文件</strong>。关于shell中常见的通配符以及通配符和正则表达式的区别请参考<a href="http://showteeth.tech/posts/37480.html">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">test</span>*.txt</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  test2.txt  </span><br><span class="line">  test3.txt  </span><br><span class="line">  test.txt  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="comment">#           ^  Bash 在检测到通配表达式时，</span></span><br><span class="line"><span class="comment">#+             会进行文件名扩展。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ls -l <span class="string">"<span class="variable">$file</span>"</span>  <span class="comment"># 列出 $PWD（当前工作目录）下的所有文件。</span></span><br><span class="line">  <span class="comment">#  回忆一下，通配符 "*" 会匹配所有的文件名，</span></span><br><span class="line">  <span class="comment">#+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  如果没有匹配到文件，那么它将会扩展为它自身。</span></span><br><span class="line">  <span class="comment">#  为了防止出现这种情况，需要设置 nullglob 选项。</span></span><br><span class="line">  <span class="comment">#+    (shopt -s nullglob)。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> [jx]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="variable">$file</span>    <span class="comment"># 删除当前目录下所有以 "j" 或 "x" 开头的文件。</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Removed file \"<span class="variable">$file</span>\""</span>.</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="每个元素多个参数"><a href="#每个元素多个参数" class="headerlink" title="每个元素多个参数"></a>每个元素多个参数</h4><p>用于循环的每个参数可以继续分解为多个参数，这里使用 <code>set</code> 命令<strong>强制解析循环内容中的每一个元素</strong>，并将元素的每一个部分分配给位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个行星与其到太阳的距离放在一起。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> planet <span class="keyword">in</span> <span class="string">"Mercury 36"</span> <span class="string">"Venus 67"</span> <span class="string">"Earth 93"</span> <span class="string">"Mars 142"</span> <span class="string">"Jupiter 483"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">set</span> -- <span class="variable">$planet</span>  <span class="comment">#  解析变量 "planet"</span></span><br><span class="line">                  <span class="comment">#+ 并将其每个部分赋值给位置参数。</span></span><br><span class="line">  <span class="comment"># "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。</span></span><br><span class="line">  <span class="comment"># 你可以使用数组来保存</span></span><br><span class="line">  <span class="comment">#         original_params=("$@")</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>        <span class="variable">$2</span>,000,000 miles from the sum"</span></span><br><span class="line">  <span class="comment">#-------两个制表符---将后面的一系列 0 连到参数 $2 上。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>Mercury 36,000,000 miles from the sum<br>Venus 67,000,000 miles from the sum<br>Earth 93,000,000 miles from the sum<br>Mars 142,000,000 miles from the sum<br>Jupiter 483,000,000 miles from the sum</p></blockquote><p>示例来源于<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part3/11_1_loops.html" target="_blank" rel="noopener">这本书</a></p><hr><h4 id="集成管道符"><a href="#集成管道符" class="headerlink" title="集成管道符"></a>集成管道符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$( find $directory -type 1 )</span>"</span>   <span class="comment"># -type 1 = 符号链接</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span> | sort</span><br></pre></td></tr></table></figure><blockquote><p><code>for i in test*.txt;do echo $i;done |wc -l</code></p></blockquote><blockquote><p>3</p></blockquote><hr><p><br></p><h2 id="while-until循环"><a href="#while-until循环" class="headerlink" title="while/until循环"></a>while/until循环</h2><p><code>while/until</code>循环适用于条件判断，<strong>条件成立则进行循环，具体多少次的循环不知道</strong>，只要条件成立即可，所以<code>while/until</code>循环也叫<strong>不定循环</strong>。<code>while</code>和<code>until</code>循环在进行条件判断时执行的是完全相反的操作，<code>while</code>是条件成立则进行循环，而<code>until</code>这是条件成立终止循环，是完全相反的，所以后续的学习主要集中于使用较多的<code>while</code>循环，<code>until</code>循环一样的道理，只是将条件判断改变即可。</p><h3 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止</span></span><br><span class="line"><span class="keyword">while</span> [ condition ]  <span class="comment"># 括号内的状态就是判断式</span></span><br><span class="line"><span class="keyword">do</span>                   <span class="comment"># do 是循环的开始！</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span>                 <span class="comment"># done 是循环的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 condition 条件成立时，就终止循环， 否则就持续进行循环的程序段(和while循环相反)</span></span><br><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>while</code>和<code>until</code>循环中当<strong>使用条件测试进行循环时和前面在if条件测试分支结构中使用的条件测试是相同的</strong>，具体的各种测试形式这里就不在列出，后续可以查看<a href="http://showteeth.tech/posts/58105.html">这篇文章</a></p></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用条件测试进行循环"><a href="#使用条件测试进行循环" class="headerlink" title="使用条件测试进行循环"></a>使用条件测试进行循环</h4><p>和 <code>if</code> 一样， 使用条件测试进行循环时 <code>while</code> 会计算一系列命令的退出状态。只要<strong>退出状态为零(条件测试执行成功)，它就执行循环内的命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=0  <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0  <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]   <span class="comment"># 变量使用双引号在进行变量替换的同时防止字符分割</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+1))   <span class="comment"># 每次 i 都会增加 1 </span></span><br><span class="line">    s=$((<span class="variable">$s</span>+<span class="variable">$i</span>))  <span class="comment"># 每次都会加总一次！</span></span><br><span class="line">                  <span class="comment"># 使用了特殊符号$(())来执行计算</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is  <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p><mark>如果一个 while 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止，这个也和if命令相同:</mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环，输出this is true</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">false</span>;<span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="循环读取文件"><a href="#循环读取文件" class="headerlink" title="循环读取文件"></a>循环读取文件</h4><p>使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this is a test<br>that is a test<br>there is a test<br>those are tests</p></blockquote><p>也可以<strong>按字段读取文件的每行内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 field3 field4 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field3</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field4</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this<br>is a test<br>that<br>is a test<br>there<br>is a test<br>those<br>are tests</p></blockquote><blockquote><p>this<br>is<br>a<br>test<br>that<br>is<br>a<br>test<br>there<br>is<br>a<br>test<br>those<br>are<br>tests<br><em>这是空行</em></p></blockquote><div class="note info"><ul><li>为了重定向文件到循环中，可以将重定向操作符放置到 <code>done</code> 语句之后。循环使用 <code>read</code> 从重定向文件中读取字段；<strong>这个 <code>read</code> 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾，这时候它的退出状态为非零数值，因此终止循环</strong>。</li><li><strong>指定字段数小于每行字段数</strong>：第一个字段为第一个空格之前的内容，剩下的所有字段为第二个字段(这里只指定了两个字段来读取每一行)</li><li><strong>指定字段数大于每行字段数</strong>：不足的字段使用空格填补</li></ul></div><hr><h4 id="集成管道符-1"><a href="#集成管道符-1" class="headerlink" title="集成管道符"></a>集成管道符</h4><p>上面使用使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件的操作也可以使用管道符实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt|<span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>因为管道将会在<strong>子 shell</strong> 中执行循环，<strong>当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失</strong>，记住这一点很重要(这个还没测试过，先mark一下)</p></div><hr><p><br></p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break-终止循环"><a href="#break-终止循环" class="headerlink" title="break-终止循环"></a>break-终止循环</h3><p><code>break</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳出当前所在的循环体(终止循环)，执行循环体之后的语句</strong>。</p><h4 id="终止单层循环"><a href="#终止单层循环" class="headerlink" title="终止单层循环"></a>终止单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"></span><br><span class="line">  <span class="built_in">break</span>---------+</span><br><span class="line">                |</span><br><span class="line">  commands      |</span><br><span class="line">  commands      | 跳出(终止)循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">                |</span><br><span class="line"><span class="keyword">done</span>            |</span><br><span class="line">                |</span><br><span class="line">commands&lt;-------+</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; <span class="built_in">break</span>  <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>在循环中一旦发现目录，则立即停止循环并退出</p><hr><h4 id="终止多层循环"><a href="#终止多层循环" class="headerlink" title="终止多层循环"></a>终止多层循环</h4><p><mark><code>break</code> 命令可以接受一个参数，普通的 <code>break</code> 命令<strong>仅仅跳出其所在的那层循环</strong>，而 <code>break N</code> 命令则可以<strong>跳出其上 N 层的循环</strong></mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outerloop</span>:   "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> innerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$innerloop</span> "</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$innerloop</span>"</span> -eq 3 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">break</span> 2 <span class="comment"># 尝试一下 break 2 看看会发生什么。</span></span><br><span class="line">             <span class="comment"># （它同时中止了内层和外层循环。）</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>直接使用<code>break</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3<br>Group 2: 1 2 3<br>Group 3: 1 2 3<br>Group 4: 1 2 3<br>Group 5: 1 2 3</p></blockquote><p>使用了<code>break 2</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3</p></blockquote><p>可以发现使用<code>break 2</code>不仅跳出了本层循环，还跳出了本层循环的外层循环，也就是跳出了2层循环</p><hr><h3 id="continue-进行下一次循环"><a href="#continue-进行下一次循环" class="headerlink" title="continue-进行下一次循环"></a>continue-进行下一次循环</h3><p><code>continue</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</strong>。</p><h4 id="影响单层循环"><a href="#影响单层循环" class="headerlink" title="影响单层循环"></a>影响单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]&lt;-------+</span><br><span class="line"><span class="keyword">do</span>                         |</span><br><span class="line">                           |</span><br><span class="line">  commands                 | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">  commands                 |</span><br><span class="line">                           |</span><br><span class="line">  <span class="built_in">continue</span> ----------------+</span><br><span class="line"></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">commands</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -d <span class="string">"<span class="variable">$f</span>"</span> ] || <span class="built_in">continue</span>    <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line">    chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>如果是目录，添加权限；如果不是，跳过当前循环，continue 后面代码不再执行，而是直接执行下次循环。</p><hr><h4 id="影响多层循环"><a href="#影响多层循环" class="headerlink" title="影响多层循环"></a>影响多层循环</h4><p><mark>与 <code>break</code> 类似，<code>continue</code> 也可以接受一个参数，普通的 <code>continue</code> 命令<strong>仅仅影响其所在的那层循环</strong>，而 <code>continue N</code> 命令则可以<strong>影响其上 N 层的循环</strong></mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outer <span class="keyword">in</span> I II III IV V           <span class="comment"># 外层循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span>; <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outer</span>: "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> inner <span class="keyword">in</span> 1 2 3 4 5 6 7 8 9 10  <span class="comment"># 内层循环</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$inner</span>"</span> -eq 7 &amp;&amp; <span class="string">"<span class="variable">$outer</span>"</span> = <span class="string">"III"</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">continue</span> 2  <span class="comment"># 影响两层循环，包括“外层循环”。</span></span><br><span class="line">                  <span class="comment"># 将其替换为普通的 "continue"，那么只会影响内层循环。</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$inner</span> "</span>  <span class="comment"># 7 8 9 10 将不会出现在 "Group III."中。</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>直接使用<code>continue</code>的输出结果(只有第三组少了数字7)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6 8 9 10<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><p>使用了<code>continue 2</code>的输出结果(第三组7以后的数字全消失了)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><div class="note warning"><p><code>continue N</code> 结构<strong>不易理解并且可能在一些情况下有歧义，因此不建议使用</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-if条件测试</title>
      <link href="/posts/58105.html"/>
      <url>/posts/58105.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了shell中的条件测试命令，包括<code>test</code>命令、<code>[ ]</code>、<code>[[ ]]</code>、<code>(( ))</code>，主要介绍了前三个，其中<code>[ ]</code>和<code>[[ ]]</code>可以用在<strong>if条件测试分支结构</strong>中，两者之间的优缺点在文中也有讲解；也学习了<strong>if条件测试分支结构</strong>在多种情形下的多种形式以及<code>exit</code>命令设定程序退出状态</p></div><a id="more"></a><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>本来打算直接学习if判断分支结构，但是在阅读相关资料后发现if判断分支中的条件判断其实就是shell条件测试，所以这里先对shell的条件测试进行学习。shell的条件测试可以使用<code>test</code>命令、<code>[ ]</code>判断式、<code>[[ ]]</code>判断式以及<code>(( ))</code>判断式，其中<code>[ ]</code>和<code>[[ ]]</code>是if判断分支结构中主要使用的。</p><h3 id="test命令测试"><a href="#test命令测试" class="headerlink" title="test命令测试"></a>test命令测试</h3><p>test命令是 shell 环境中用于测试条件表达式的工具，当条件成立时，命令执行后的返回值为0，否则为其他数值。</p><h4 id="test命令结构"><a href="#test命令结构" class="headerlink" title="test命令结构"></a>test命令结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> ! EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -a EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -o EXPRESSION</span><br></pre></td></tr></table></figure><p><mark><strong>test EXPRESSION</strong>执行结果并<strong>不会显示任何信息</strong>，如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</mark></p><p><strong>使用<code>$?</code></strong>：</p><blockquote><p><code>test -f test1.txt</code> # 不输出结果<br><code>echo $?</code> # $?返回最后运行的命令的结束代码</p></blockquote><blockquote><p>0 # 正常运行的命令结束代码为0，也就是条件成立</p></blockquote><blockquote><p><code>test -f test2.txt</code><br><code>echo $?</code></p></blockquote><blockquote><p>1 # 出错或者异常结束代码为非0，也就是条件不成立</p></blockquote><p><strong>使用<code>&amp;&amp;</code>和<code>||</code>的组合</strong>：</p><blockquote><p><code>test -f test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><p><strong>注意<code>&amp;&amp;</code>和<code>||</code>的顺序不能随意，如果上面的顺序调换</strong>：</p><blockquote><p><code>test -f test2.txt || echo &quot;Not exist&quot; &amp;&amp; echo &quot;exist&quot;</code><br>Not exist<br>exist</p></blockquote><p>上面的判断是按顺序执行的，具体<code>&amp;&amp;</code>和<code>||</code>前后命令的执行规则参考<a href="http://showteeth.tech/posts/55603.html">这篇博客</a></p><hr><h4 id="文件是否存在测试"><a href="#文件是否存在测试" class="headerlink" title="文件是否存在测试"></a>文件是否存在测试</h4><p>使用示例：<strong>test -e filename</strong></p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-e</strong></td><td>该“文件名”<strong>是否存在</strong>（常用）</td></tr><tr><td><strong>-f</strong></td><td>该“文件名”是否存在且为<strong>文件</strong>（file）（常用）</td></tr><tr><td><strong>-d</strong></td><td>该“文件名”是否存在且为<strong>目录</strong>（directory）（常用）</td></tr><tr><td><strong>-s</strong></td><td>侦测该文件名是否存在且为“非空白文件”(<strong>文件大小不为0</strong>) （常用）</td></tr><tr><td>-b</td><td>该“文件名”是否存在且为一个 block device 设备</td></tr><tr><td>-c</td><td>该“文件名”是否存在且为一个 character device 设备</td></tr><tr><td>-S</td><td>该“文件名”是否存在且为一个 Socket 文件</td></tr><tr><td>-p</td><td>该“文件名”是否存在且为一个 FIFO （pipe） 文件</td></tr><tr><td>-L</td><td>该“文件名”是否存在且为一个<strong>链接文件</strong></td></tr></tbody></table><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -e test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -d test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="权限测试"><a href="#权限测试" class="headerlink" title="权限测试"></a>权限测试</h4><p>使用示例：<strong>test -r filename</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>侦测该文件名是否存在且<strong>具有“可读”的权限</strong></td></tr><tr><td>-w</td><td>侦测该文件名是否存在且<strong>具有“可写”的权限</strong></td></tr><tr><td>-x</td><td>侦测该文件名是否存在且<strong>具有“可执行”的权限</strong></td></tr><tr><td>-u</td><td>侦测该文件名是否存在且具有“SUID”的属性</td></tr><tr><td>-g</td><td>侦测该文件名是否存在且具有“SGID”的属性</td></tr><tr><td>-k</td><td>侦测该文件名是否存在且具有“Sticky bit”的属性</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt</p></blockquote><blockquote><p><code>test -r test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -w test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -x test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="文件之间的测试"><a href="#文件之间的测试" class="headerlink" title="文件之间的测试"></a>文件之间的测试</h4><p>使用示例：<strong>test file1 -nt file2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-nt</td><td>（<strong>newer than</strong>）判断 file1 是否比 file2 新</td></tr><tr><td>-ot</td><td>（<strong>older than</strong>）判断 file1 是否比 file2 旧</td></tr><tr><td>-ef</td><td>判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上（通过硬链接两个文件名指向相同的文件）</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt<br>-rw-rw-r– 1 user user 0 Mar 14 21:20 test2.txt</p></blockquote><blockquote><p><code>test test1.txt -nt test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test test1.txt -ot test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><hr><h4 id="整数之间的测试"><a href="#整数之间的测试" class="headerlink" title="整数之间的测试"></a>整数之间的测试</h4><p>使用示例：<strong>test n1 -eq n2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>两数值相等 （<strong>equal</strong>）</td></tr><tr><td>-ne</td><td>两数值不等 （<strong>not equal</strong>）</td></tr><tr><td>-gt</td><td>n1 大于 n2 （<strong>greater than</strong>）</td></tr><tr><td>-lt</td><td>n1 小于 n2 （<strong>less tha</strong>n）</td></tr><tr><td>-ge</td><td>n1 大于等于 n2 （<strong>greater than or equal</strong>）</td></tr><tr><td>-le</td><td>n1 小于等于 n2 （<strong>less than or equal</strong>）</td></tr></tbody></table><blockquote><p><code>test 2 -eq 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist<br><code>test 2 -ne 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="字符串的测试"><a href="#字符串的测试" class="headerlink" title="字符串的测试"></a>字符串的测试</h4><p>使用示例：<strong>test str1 == str2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>test -z string</td><td>判定字串是否为 0 ，若 string <strong>为空字串(空格不为空)，则为 true</strong></td></tr><tr><td>test -n string</td><td>判定字串是否非为 0 ，若 string <strong>为空字串，则为 false</strong>。 -n 亦可省略</td></tr><tr><td>test str1 == str2</td><td>判定 str1 <strong>是否等于</strong> str2 ，若相等，则回传 true</td></tr><tr><td>test str1 != str2</td><td>判定 str1 <strong>是否不等于</strong> str2 ，若相等，则回传 false</td></tr></tbody></table><p>注意：<code>==</code>前后需要空格隔开，不用空格隔开可能会出问题</p><hr><h4 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h4><p>使用示例：<strong>test -r file -a -x file</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>（<strong>and</strong>）两状况同时成立！例如 <em>test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true</em>。</td></tr><tr><td>-o</td><td>（<strong>or</strong>）两状况任何一个成立！例如 <em>test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true</em>。</td></tr><tr><td>!</td><td>反向状态，如 <em>test ! -x file ，当 file 不具有 x 时，回传 true</em></td></tr></tbody></table><hr><div class="note info"><p><code>test</code>命令最需要注意的是：单纯的<code>test</code>命令不会返回任何信息，所以如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</p></div><hr><h3 id="判断式"><a href="#判断式" class="headerlink" title="[]判断式"></a>[]判断式</h3><div class="note info"><ul><li>条件测试会使用一个特殊的命令 <code>[</code>，等同于 <code>test</code> 命令，它是一个<strong>内建命令</strong>，写法更加简洁高效。该命令<strong>将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）</strong></li><li>Bash 在 2.02 版本中引入了扩展测试命令 <code>[[ ]]</code>，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， <code>[[</code> 是一个<strong>关键字 而非一个命令</strong>，Bash 将 <code>[[ $a -lt $b ]]</code> 视为一整条语句，执行并返回退出状态</li><li><code>[]</code>有<a href="http://showteeth.tech/posts/55603.html">几种不同的功能</a>，如果想要用来作为条件测试必须要注意<strong>中括号的两端以及判断符前后需要有空白字符来分隔</strong>，如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code></li></ul><ul><li>中括号和test命令的各种测试是相同的，<code>[ ]</code>判断式和test命令可以相互转换，比如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code>可以转换为test “$HOME” == “$MAIL”，所以上面提到的各种测试都可以在中括号中使用</li><li>在中括号 <code>[ ]</code> 内的<strong>每个元件都需要有空白键来分隔</strong></li><li>在中括号内的<strong>变量</strong>，最好都<strong>以双引号括号起来</strong></li><li>在中括号内的<strong>常数</strong>，最好都<strong>以单或双引号括号起来</strong></li><li><code>[ ]</code>以及<code>test</code>命令中所有的表达式和操作符都被 shell 看作是命令参数，对于 bash 有特殊含义的字符，比如说 <code>(</code>、 <code>)</code>、<code>&gt;</code>、<code>&lt;</code><strong>必须引起来或者是转义</strong></li></ul><ul><li>在复合测试中，仅仅引用字符串可能还不够，比如表达式<code>[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</code> 在<strong>某些 Bash 版本</strong>下，如果 <code>$string</code> 为空可能会出错。更加安全的方式是，<strong>对于可能为空的字符串，添加一个额外的字符</strong>，例如 <code>[ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]</code>（其中的 x 互相抵消）</li></ul></div><p><strong>[]判断式需要注意的问题-字符分割</strong>：</p><blockquote><p>test=”my name”<br>[ ${test} == “my” ]</p></blockquote><blockquote><p>bash: [: too many arguments</p></blockquote><p>上面的出错显示判断式中存在太多参数，但是明明就只有test一个参数，为什么会出现这个问题呢？因为 <code>${test}</code> 如果<strong>没有使用双引号括起来</strong>，那么上面的判定式会变成：</p><blockquote><p>[ my name == “my” ]</p></blockquote><p>如果写成这个样子就会发现问题，因为一个判断式仅能有两个数据的比对，上面 my 与 name 还有 “my” 就有三个数据！所以会出错，而我们需要的是：</p><blockquote><p>[ “my name” == “my” ]</p></blockquote><p>所以这就说明了(如果字符串中带有空格，以防万一都带上吧)需要<strong>使用双引号括起来，不用单引号</strong>的原因是单引号会<a href="http://showteeth.tech/posts/55603.html">防止任何变量替换</a></p><hr><h3 id="判断式-1"><a href="#判断式-1" class="headerlink" title="[[]]判断式"></a>[[]]判断式</h3><p>在 <strong>Bash(限制条件)</strong> 里，<code>[[ ]]</code> 是比 <code>[ ]</code> 更加通用的写法，使用 <code>[[ ]]</code> 代替<code>[ ]</code>可以避免很多逻辑错误。比如可以在 <code>[[ ]]</code> 中使用 <code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code> 和 <code>&gt;</code> 操作符，而在 <code>[ ]</code> 中使用则会报错</p><p>下面列出<code>[[ ]]</code> 比 <code>[ ]</code>更好用的几点：</p><h4 id="使用正则匹配"><a href="#使用正则匹配" class="headerlink" title="使用正则匹配"></a>使用正则匹配</h4><p>增加了一个重要的新的字符串表达式来使用正则匹配</p><blockquote><p><strong>string1 =~ regex</strong><br>取反操作： <strong>! string1 =~ regex</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"chrM"</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$a</span>"</span> =~ ^(chrM|whole)$ ]];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">"no"</span>;<span class="keyword">fi</span></span><br><span class="line">  yes </span><br><span class="line"><span class="comment"># 取反操作</span></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="string">"<span class="variable">$a</span>"</span> =~ ^(chrM|whole)$ ]];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"yes"</span>;<span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">"no"</span>;<span class="keyword">fi</span></span><br><span class="line">no</span><br></pre></td></tr></table></figure><h4 id="不需要使用双引号"><a href="#不需要使用双引号" class="headerlink" title="不需要使用双引号"></a>不需要使用双引号</h4><p><code>[[ ]]</code>判断式<strong>不需要</strong>对其中的变量和常数使用<strong>双引号</strong>括起来：</p><blockquote><p><code>[[ ${test} == &quot;my&quot; ]] &amp;&amp; echo &quot;right&quot; || echo &quot;wrong&quot;</code><br>wrong</p></blockquote><h4 id="操作符支持模式匹配"><a href="#操作符支持模式匹配" class="headerlink" title="==操作符支持模式匹配:"></a>==操作符支持模式匹配:</h4><blockquote><p>FILE=foo.bar<br>if [[ $FILE == foo.* ]]; then<br>> echo “$FILE matches pattern ‘foo.*‘“<br>> fi</p></blockquote><blockquote><p>foo.bar matches pattern ‘foo.*’</p></blockquote><p>使<code>[[ ]]</code>有助于计算文件和路径名，如果<code>foo.*</code>外加了双引号就没有正则匹配的意思，单纯的字符相等的意思</p><div class="note warning"><p>只有 <strong><code>==操作符</code>支持通配符</strong>，<strong>其他的都不支持通配符，这个需要注意</strong></p></div><h4 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h4><blockquote><p><code>[[ condition1 &amp;&amp; condition2 ]]</code> <code>[[ condition1 || condition2 ]]</code></p></blockquote><h4 id="对不同进制的数直接进行比较"><a href="#对不同进制的数直接进行比较" class="headerlink" title="对不同进制的数直接进行比较"></a>对不同进制的数直接进行比较</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">decimal=15</span><br><span class="line">octal=017   <span class="comment"># = 15 (十进制)</span></span><br><span class="line">hex=0x0f    <span class="comment"># = 15 (十进制)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span>       <span class="comment"># 15 不等于 017</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在单括号 [ ] 之间不会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span>                <span class="comment"># 15 等于 017</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在双括号 [[ ]] 之间会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$hex</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$hex</span>"</span>                  <span class="comment"># 15 等于 0x0f</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$hex</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 十六进制也可以进行转换。</span></span><br></pre></td></tr></table></figure><hr><h3 id="数值判断"><a href="#数值判断" class="headerlink" title="(())数值判断"></a>(())数值判断</h3><p>使用<strong>小于</strong>和<strong>大于</strong>符号，以及<code>==</code>用来测试是否相等，专为整数设计</p><p>不仔细讲解，因为这些也可以使用上面提到的<code>[ ]</code>和<code>[[ ]]</code>进行较好的替代，后续想学习可以参考：<a href="https://www.kancloud.cn/thinkphp/linux-command-line/39459" target="_blank" rel="noopener">文章一</a>、<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part2/07_1_test_constructs.html" target="_blank" rel="noopener">文章二</a>。</p><hr><p><br></p><h2 id="if条件测试分支结构"><a href="#if条件测试分支结构" class="headerlink" title="if条件测试分支结构"></a>if条件测试分支结构</h2><p>在学习<code>test</code>命令以及<code>[ ]</code>判断式过程中我们发现条件测试默认是不会返回任何信息的，如果想要进行操作或者返回信息就要使用<code>&amp;&amp;</code>或者<code>||</code>，这些其实和这里的if条件测试分支结构的作用的相同的，只是if条件测试分支结构可以支持的命令更加多和复杂，有利于大程序的编写。</p><p><strong>if条件测试分支结构工作原理</strong>：通过<strong>判断条件测试的退出状态</strong>，如果<strong>执行成功(命令退出状态为0)</strong>则执行<code>then</code>中的命令，<strong>否则(命令退出状态为非0)</strong>终止判断语句或者执行<code>else</code>或者执行下一层判断等。</p><h3 id="单层、简单条件判断式"><a href="#单层、简单条件判断式" class="headerlink" title="单层、简单条件判断式"></a>单层、简单条件判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  这里的条件判断式就是前面条件测试中使用的[]判断式</span><br></pre></td></tr></table></figure><hr><h3 id="多个表达式、多重判别"><a href="#多个表达式、多重判别" class="headerlink" title="多个表达式、多重判别"></a>多个表达式、多重判别</h3><p>前面在test命令中讲过关于使用多个表达式、多重判断的情况，在多个表达式之间<strong>使用-a表示and、-o表示or</strong>，示例如下：</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; -o &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p>如果想要使用<strong>多个括号将不同的表达式隔开</strong>可以使用<code>&amp;&amp;</code>和<code>||</code>:</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; ] || [ &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p><mark>上面的多重判别实际是写成了一个判断式的形式，而如果 if 之后跟随一系列命令(使用<code>;</code>隔开)，则将计算列表中的<strong>最后一个命令</strong>：</mark></p><blockquote><p><code>if false; true; then echo &quot;It&#39;s true.&quot;; fi</code> 因为true在后，所以得到退出状态为0，输出结果<br>It’s true.</p></blockquote><blockquote><p><code>if true; false; then echo &quot;It&#39;s true.&quot;; fi</code> 因为false在后，所以得到退出状态为非0，不输出结果</p></blockquote><hr><h3 id="双层判断式"><a href="#双层判断式" class="headerlink" title="双层判断式"></a>双层判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 一个条件判断，分成功进行与失败进行 （else）</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><hr><h3 id="多层、复杂判断式"><a href="#多层、复杂判断式" class="headerlink" title="多层、复杂判断式"></a>多层、复杂判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 多个条件判断 （if ... elif ... elif ... else） 分多种不同情况执行</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式一 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式一成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">elif</span> [ 条件判断式二 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式二成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式一与二均不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>if</code>、<code>elif</code>后面需要使用<code>then</code>，而<code>else</code>后面就不用使用<code>then</code>，因为<code>elif</code> 也是个判断式，因此出现 <code>elif</code> 后面都要接 <code>then</code> 来处理！但是 <code>else</code> 已经是最后的没有成立的结果了， 所以 <code>else</code> 后面并没有 <code>then</code></p></div><hr><h3 id="exit程序退出状态"><a href="#exit程序退出状态" class="headerlink" title="exit程序退出状态"></a>exit程序退出状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &lt;name&gt;"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>在运行此脚本时，如果没有输入参数，则提示正确的使用方法，<strong>非正常退出(exit 1)</strong>；否则，打印输入的参数，<strong>程序正常退出(exit 0)</strong>。</p><hr><h3 id="和任何命令连用"><a href="#和任何命令连用" class="headerlink" title="和任何命令连用"></a>和任何命令连用</h3><p>这里首先再次说明一下if判断的原理：<mark>通过<strong>判断if后面语句的退出状态</strong>，如果<strong>执行成功(命令退出状态为0)</strong>则执行<code>then</code>中的命令，<strong>否则(命令退出状态为非0)</strong>终止判断语句或者执行<code>else</code>或者执行下一层判断等。</mark></p><p>这里将前面的判断<strong>条件测试</strong>的退出状态修改为了判断<strong>if后面语句</strong>的退出状态，<strong>原因是if可以与任何命令连用</strong>，因为后面命令执行肯定会有一个返回状态。</p><p>最近想判断文件夹中是不是存在压缩文件<code>gz</code>，如果存在希望可以对其进行解压，自然而然这里就涉及到了一个判断语句，然而我按照常规的写法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -f <span class="string">".gz"</span> ]]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>却不能得到正确的结果，不管是不是存在，返回的结果都是<code>no</code>，后来发现，除了使用<code>[[]]</code>可以进行<code>~=</code>的正则匹配之外，通配符在<code>if</code>中是不被允许的，所以只能尝试其他方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ls *.gz &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用上面的命令就可以得到正确的结果，因为<strong>如果存在</strong>压缩文件<code>gz</code>，<strong>ls命令的退出状态就是0</strong>，那么就执行<code>then</code>中的结果；如果<strong>不存在压缩文件</strong>，那么<code>ls</code>的<strong>退出状态就会非0</strong>，所以就会执行<code>else</code>中的命令，达到目的！</p><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML块级标签和行内标签</title>
      <link href="/posts/8829.html"/>
      <url>/posts/8829.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇<a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">转载</a>的文章，主要记录了HTML的块级标签和行内标签各自包括的内容</p></div><a id="more"></a><h2 id="块级标签"><a href="#块级标签" class="headerlink" title="块级标签"></a>块级标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;address&gt;</td><td style="text-align:left">定义地址</td></tr><tr class="even"><td style="text-align:left">&lt;article&gt;</td><td style="text-align:left">定义文章</td></tr><tr class="odd"><td style="text-align:left">&lt;aside&gt;</td><td style="text-align:left">定义页面内容之外的内容</td></tr><tr class="even"><td style="text-align:left">&lt;audio&gt;</td><td style="text-align:left">定义声音内容</td></tr><tr class="odd"><td style="text-align:left">&lt;blockquote&gt;</td><td style="text-align:left">定义长的引用</td></tr><tr class="even"><td style="text-align:left">&lt;canvas&gt;</td><td style="text-align:left">定义图形</td></tr><tr class="odd"><td style="text-align:left">&lt;caption&gt;</td><td style="text-align:left">定义表格标题</td></tr><tr class="even"><td style="text-align:left">&lt;dd&gt;</td><td style="text-align:left">定义定义列表中项目的描述</td></tr><tr class="odd"><td style="text-align:left">&lt;div&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;dl&gt;</td><td style="text-align:left">定义定义列表</td></tr><tr class="odd"><td style="text-align:left">&lt;dt&gt;</td><td style="text-align:left">定义定义列表中的项目</td></tr><tr class="even"><td style="text-align:left">&lt;details&gt;</td><td style="text-align:left">定义元素的细节</td></tr><tr class="odd"><td style="text-align:left">&lt;fieldset&gt;</td><td style="text-align:left">定义围绕表单中元素的边框</td></tr><tr class="even"><td style="text-align:left">&lt;figcaption&gt;</td><td style="text-align:left">定义 figure 元素的标题</td></tr><tr class="odd"><td style="text-align:left">&lt;figure&gt;</td><td style="text-align:left">定义媒介内容的分组，以及它们的标题</td></tr><tr class="even"><td style="text-align:left">&lt;footer&gt;</td><td style="text-align:left">定义 section 或 page 的页脚</td></tr><tr class="odd"><td style="text-align:left">&lt;form&gt;</td><td style="text-align:left">定义供用户输入的 HTML 表单</td></tr><tr class="even"><td style="text-align:left">&lt;h1&gt; to &lt;h6&gt;</td><td style="text-align:left">定义 HTML 标题</td></tr><tr class="odd"><td style="text-align:left">&lt;header&gt;</td><td style="text-align:left">定义 section 或 page 的页眉</td></tr><tr class="even"><td style="text-align:left">&lt;hr&gt;</td><td style="text-align:left">定义水平线</td></tr><tr class="odd"><td style="text-align:left">&lt;legend&gt;</td><td style="text-align:left">定义 fieldset 元素的标题</td></tr><tr class="even"><td style="text-align:left">&lt;li&gt;</td><td style="text-align:left">定义列表的项目</td></tr><tr class="odd"><td style="text-align:left">&lt;menu&gt;</td><td style="text-align:left">定义命令的列表或菜单</td></tr><tr class="even"><td style="text-align:left">&lt;meter&gt;</td><td style="text-align:left">定义预定义范围内的度量</td></tr><tr class="odd"><td style="text-align:left">&lt;nav&gt;</td><td style="text-align:left">定义导航链接</td></tr><tr class="even"><td style="text-align:left">&lt;noframes&gt;</td><td style="text-align:left">定义针对不支持框架的用户的替代内容</td></tr><tr class="odd"><td style="text-align:left">&lt;noscript&gt;</td><td style="text-align:left">定义针对不支持客户端脚本的用户的替代内容</td></tr><tr class="even"><td style="text-align:left">&lt;ol&gt;</td><td style="text-align:left">定义有序列表</td></tr><tr class="odd"><td style="text-align:left">&lt;output&gt;</td><td style="text-align:left">定义输出的一些类型</td></tr><tr class="even"><td style="text-align:left">&lt;p&gt;</td><td style="text-align:left">定义段落</td></tr><tr class="odd"><td style="text-align:left">&lt;pre&gt;</td><td style="text-align:left">定义预格式文本</td></tr><tr class="even"><td style="text-align:left">&lt;section&gt;</td><td style="text-align:left">定义 section</td></tr><tr class="odd"><td style="text-align:left">&lt;table&gt;</td><td style="text-align:left">定义表格</td></tr><tr class="even"><td style="text-align:left">&lt;tbody&gt;</td><td style="text-align:left">定义表格中的主体内容</td></tr><tr class="odd"><td style="text-align:left">&lt;td&gt;</td><td style="text-align:left">定义表格中的单元</td></tr><tr class="even"><td style="text-align:left">&lt;tfoot&gt;</td><td style="text-align:left">定义表格中的表注内容（脚注）</td></tr><tr class="odd"><td style="text-align:left">&lt;th&gt;</td><td style="text-align:left">定义表格中的表头单元格</td></tr><tr class="even"><td style="text-align:left">&lt;thead&gt;</td><td style="text-align:left">定义表格中的表头内容</td></tr><tr class="odd"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="even"><td style="text-align:left">&lt;tr&gt;</td><td style="text-align:left">定义表格中的行</td></tr><tr class="odd"><td style="text-align:left">&lt;ul&gt;</td><td style="text-align:left">定义无序列表</td></tr></tbody></table><hr><p><br></p><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;a&gt;</td><td style="text-align:left">定义锚</td></tr><tr class="even"><td style="text-align:left">&lt;abbr&gt;</td><td style="text-align:left">定义缩写</td></tr><tr class="odd"><td style="text-align:left">&lt;acronym&gt;</td><td style="text-align:left">定义只取首字母的缩写</td></tr><tr class="even"><td style="text-align:left">&lt;b&gt;</td><td style="text-align:left">定义粗体字</td></tr><tr class="odd"><td style="text-align:left">&lt;bdo&gt;</td><td style="text-align:left">定义文字方向</td></tr><tr class="even"><td style="text-align:left">&lt;big&gt;</td><td style="text-align:left">定义大号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;br&gt;</td><td style="text-align:left">定义简单的折行</td></tr><tr class="even"><td style="text-align:left">&lt;button&gt;</td><td style="text-align:left">定义按钮 (push button)</td></tr><tr class="odd"><td style="text-align:left">&lt;cite&gt;</td><td style="text-align:left">定义引用(citation)</td></tr><tr class="even"><td style="text-align:left">&lt;code&gt;</td><td style="text-align:left">定义计算机代码文本</td></tr><tr class="odd"><td style="text-align:left">&lt;command&gt;</td><td style="text-align:left">定义命令按钮</td></tr><tr class="even"><td style="text-align:left">&lt;dfn&gt;</td><td style="text-align:left">定义定义项目</td></tr><tr class="odd"><td style="text-align:left">&lt;del&gt;</td><td style="text-align:left">定义被删除文本</td></tr><tr class="even"><td style="text-align:left">&lt;em&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;embed&gt;</td><td style="text-align:left">定义外部交互内容或插件</td></tr><tr class="even"><td style="text-align:left">&lt;i&gt;</td><td style="text-align:left">定义斜体字</td></tr><tr class="odd"><td style="text-align:left">&lt;img&gt;</td><td style="text-align:left">定义图像</td></tr><tr class="even"><td style="text-align:left">&lt;input&gt;</td><td style="text-align:left">定义输入控件</td></tr><tr class="odd"><td style="text-align:left">&lt;kbd&gt;</td><td style="text-align:left">定义键盘文本</td></tr><tr class="even"><td style="text-align:left">&lt;label&gt;</td><td style="text-align:left">定义 input 元素的标注</td></tr><tr class="odd"><td style="text-align:left">&lt;map&gt;</td><td style="text-align:left">定义图像映射</td></tr><tr class="even"><td style="text-align:left">&lt;mark&gt;</td><td style="text-align:left">定义有记号的文本</td></tr><tr class="odd"><td style="text-align:left">&lt;objec&gt;</td><td style="text-align:left">定义内嵌对象</td></tr><tr class="even"><td style="text-align:left">&lt;progress&gt;</td><td style="text-align:left">定义任何类型的任务的进度</td></tr><tr class="odd"><td style="text-align:left">&lt;q&gt;</td><td style="text-align:left">定义短的引用</td></tr><tr class="even"><td style="text-align:left">&lt;samp&gt;</td><td style="text-align:left">定义计算机代码样本</td></tr><tr class="odd"><td style="text-align:left">&lt;select&gt;</td><td style="text-align:left">定义选择列表（下拉列表）</td></tr><tr class="even"><td style="text-align:left">&lt;small&gt;</td><td style="text-align:left">定义小号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;span&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;strong&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;sub&gt;</td><td style="text-align:left">定义下标文本</td></tr><tr class="even"><td style="text-align:left">&lt;sup&gt;</td><td style="text-align:left">定义上标文本</td></tr><tr class="odd"><td style="text-align:left">&lt;textarea&gt;</td><td style="text-align:left">定义多行的文本输入控件</td></tr><tr class="even"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="odd"><td style="text-align:left">&lt;tt&gt;</td><td style="text-align:left">定义打字机文本</td></tr><tr class="even"><td style="text-align:left">&lt;var&gt;</td><td style="text-align:left">定义文本的变量部分</td></tr><tr class="odd"><td style="text-align:left">&lt;video&gt;</td><td style="text-align:left">定义视频</td></tr><tr class="even"><td style="text-align:left">&lt;wbr&gt;</td><td style="text-align:left">定义可能的换行符</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/d69878549d92" target="_blank" rel="noopener">关于两者之间的转换</a></li><li><a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">HTML中块级元素和行内元素的总结和区分，本文内容摘自此文章</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载其他博主博客</title>
      <link href="/posts/52283.html"/>
      <url>/posts/52283.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载<strong>CSDN博客</strong>、<strong>博客园博客</strong>、<strong>简书</strong>以及<strong>其他自建博客</strong>等</p></div><a id="more"></a><h2 id="转载CSDN博客"><a href="#转载CSDN博客" class="headerlink" title="转载CSDN博客"></a>转载CSDN博客</h2><div id="article_content" class="article_content csdn-tracking-statistics tracking-click"><div class="markdown_views"><h3 id="检查"><a name="t2"></a><a target="_blank"></a>博客页面右键，点击【检查】</h3><img src="https://img-blog.csdn.net/20180205164141852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> 点击检查后，页面右侧出现<strong>html</strong>代码，如下图： <img src="https://img-blog.csdn.net/20180205164538679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="找内容"><a name="t3"></a><a target="_blank"></a>找到article_content内容</h3><img src="https://img-blog.csdn.net/20180205164709557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="复制"><a name="t4"></a><a target="_blank"></a>复制article_content内容</h3>在选中html的article_content代码处右键，点击<strong>【Copy】</strong>,再点击<strong>【Copy outerHTML】</strong>即可，至此，博客内容的html代码复制完成 <img src="https://img-blog.csdn.net/20180205164702137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="新建"><a name="t5"></a><a target="_blank"></a>新建markdown博客</h3><ul><li>如果是<strong>转载到CSDN博客</strong>需要注意：<strong>使用markdown编辑器</strong>，CSDN博客默认的是<a href="https://www.baidu.com/s?wd=html%E7%BC%96%E8%BE%91%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank"><strong>html编辑器</strong></a>，在博客设置中<strong>修改成markdown编辑器</strong>，在html编辑器中是无法将html代码转换成相应博客内容</li><li>如果是<strong>转载到自己搭建的博客</strong>，比如我的这个博客，需要注意：按照上述方法会得到<mark>很多的空格</mark>，这是因为直接使用html来编写markdown，只要存在换行(如标签换行)都会在最终生成的页面中得到一个空格，为了解决这个问题可以在整个<code>article_content</code>标签外加上<code>escape</code>标签即可，这个和<a href="http://showteeth.tech/posts/65136.html" target="_blank"><strong>插入html表格</strong></a>的处理是一样的</li><li>HTML <mark>区块标签间的 Markdown 格式语法将不会被处理</mark>，但 Markdown 语法在 HTML <mark>行内标签间是有效的</mark>，具体的行内标签和区块标签包含的内容见<mark><a href="http://showteeth.tech/posts/8829.html" target="_blank">这篇博客</a></mark></li><li>在手动更改html内容时需要注意：每个标题的<code>id</code>是<mark>不可以相同</mark>的，不然<strong>生成的目录会出问题</strong>，点击不能到达相应的标题(目录是根据<code>id</code>生成的)</li><li>最后特别要注意的是，我们发表转载文章的时候一定要标注<strong>转载</strong>，尊重原创！！</li></ul></div></div><hr><h2 id="转载博客园博客"><a href="#转载博客园博客" class="headerlink" title="转载博客园博客"></a>转载博客园博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>data-note-content</code>即可</p><hr><h2 id="转载简书博客"><a href="#转载简书博客" class="headerlink" title="转载简书博客"></a>转载简书博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>cnblogs_post_body</code>即可</p><hr><h2 id="转载其他自建博客"><a href="#转载其他自建博客" class="headerlink" title="转载其他自建博客"></a>转载其他自建博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>post-body</code>即可</p><p>其他博客依据上述规律<strong>找到对应的文章主体内容</strong>，然后按照转载CSDN博客的方法进行处理即可</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/zhongjianblackberry/article/details/79456338" target="_blank" rel="noopener">CSDN怎么转载别人的博客</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diff-比较文件差异</title>
      <link href="/posts/56778.html"/>
      <url>/posts/56778.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用<code>diff</code>命令对<strong>文件和目录</strong>进行比较，对文件比较时采用的是<strong>逐行进行比较</strong>；包括的参数有<code>-r</code>、<code>-q</code>、<code>-i</code>、<code>-s</code>、<code>-b</code>、<code>-y</code>、<code>-W</code>、<code>-c</code>、<code>-C</code>、<code>-u</code>和<code>-U</code>。</p></div><a id="more"></a><h2 id="diff简介"><a href="#diff简介" class="headerlink" title="diff简介"></a>diff简介</h2><p><code>diff</code>命令能<strong>比较(单个)文件或者目录</strong>内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，并<strong>以逐行的方式</strong>，比较文本文件的异同；如果指定<strong>比较的是目录</strong>，diff 命令会比较两个目录下名字相同但内容不同的文本文件，列出公共子目录和只在一个目录出现的文件和目录。</p><p><mark>这个和前面讲到的<code>comm</code>命令和<code>cmp</code>命令的不同之处在于</mark>：<code>diff</code>和<code>comm</code>命令都是以逐行的方式进行比较，而<code>cmp</code>是<strong>Compare two files byte by byte</strong>；同时<code>diff</code>命令可以比较<strong>单个文件</strong>，而<code>comm</code>和<code>cmp</code>都是针对的两个文件的比较，其中<code>comm</code>还需要文件是排过序的；<code>diff</code>命令还能用来对目录进行排序；感觉<code>diff</code>在比较两个文件或目录时是将两个文件当成了同一个文件修改前后的不同版本，通过<code>diff</code>可以知道新文件是在旧文件上进行了哪些操作得到的，得到的结果也更复杂。</p><p>总结一下三个命令的适用情形：<br></p><div class="note info"><ul><li>comm适合简单的比较，需要<strong>排序</strong>，<strong>逐行</strong>比较，用于比较的文件不是同一个文件的不同版本(新旧文件)，得到的结果<strong>简单清晰</strong>(文件求交、并、补等)，便于提取分析</li><li>cmp可以应用于对两个文件<strong>逐字节</strong>的比较，可以<strong>跳过一定的字节</strong>(个人感觉这个实用性不是很强，不同系统编码方式字节也有所不同)</li><li>diff适合<strong>逐行</strong>比较<strong>文件修改前后</strong>的区别(类似版本控制，新文件是旧文件经过什么操作得到的)，也可以<strong>对目录进行比较</strong>，但是输出<strong>结果较为复杂</strong>，还可以输出<strong>上下文</strong>关系的信息</li></ul></div><p></p><hr><h2 id="diff命令用法"><a href="#diff命令用法" class="headerlink" title="diff命令用法"></a>diff命令用法</h2><h3 id="diff命令格式"><a href="#diff命令格式" class="headerlink" title="diff命令格式"></a>diff命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  diff [OPTION]... FILES</span><br></pre></td></tr></table></figure><p><strong>Compare files line by line</strong></p><hr><h3 id="diff-options说明"><a href="#diff-options说明" class="headerlink" title="diff options说明"></a>diff options说明</h3><p>由于diff命令的参数较多，这里就不一一列举，详细请查看帮助文档，比较常用的请看用法实例。</p><hr><p><br></p><h2 id="diff用法实例"><a href="#diff用法实例" class="headerlink" title="diff用法实例"></a>diff用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Hi,<br>Hello,<br>How are you?<br>I am fine,<br>Thank you.</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Hello,<br>Hi,<br>How are you?<br>I am fine.</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><h4 id="比较两个文件"><a href="#比较两个文件" class="headerlink" title="比较两个文件"></a>比较两个文件</h4><blockquote><p><code>diff test1.txt test2.txt</code><br>1d0<br>&lt; Hi,<br>2a2<br>> Hi,<br>4,5c4<br>&lt; I am fine,<br>&lt; Thank you.<br>-–<br>> I am fine.</p></blockquote><p><strong>结果解读：</strong></p><ul><li>可以将test1.txt当做旧文件，test2.txt当做新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li><code>1d0</code>这一行意味着旧文件的第一行应该被<strong>删除(d)</strong>以使两个文件的第一行同步，<strong>旧文件中需要被删除的行</strong>以<code>&lt;</code>标记</li><li><code>2a2</code>行意味着<strong>新文件中的第二行应该加到旧文件的第二行后</strong>，要<strong>添加的行显示在输出的下一行</strong>用<code>&gt;</code>标记</li><li><code>4,5c4</code>这一行意味着在<strong>旧文件中的4到5行现在已被改变并且需要用新文件中的第4行代替</strong>，代替和删除的行分别用<code>&gt;</code>和<code>&lt;</code>表示，<code>---</code>用于隔开先后进行的不同操作，如先删除旧文件中的4到5行，然后再用新文件中的第4行代替，这两步之间使用<code>---</code>分割</li></ul><div class="note info"><ul><li><code>diff</code>命令的第一个参数被视为旧文件而第二个参数被视为新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li>像<code>1d0</code>、<code>2a2</code>、<code>4,5c4</code>这种表达式可以用语法解码为 <strong>[旧文件的行号或者行的范围][行为][新文件的行号或者行的范围]</strong>，这里的<strong>行为</strong>可以是追加(<code>a，代表addition</code>)、删除(<code>d，代表deletion</code>)或者改变替换(<code>c，代表change</code>)</li><li><code>&lt;</code>代表删除的行，而<code>&gt;</code>代表添加的行，<code>---</code>用于改变替换(<code>c，代表change</code>)中分割先后的操作</li></ul></div><hr><h4 id="比较两个目录"><a href="#比较两个目录" class="headerlink" title="比较两个目录"></a>比较两个目录</h4><blockquote><p><code>ls new_dir/</code><br>comm_dir new_new_dir test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls new_dir/new_new_dir/</code> and <code>ls new_dir/comm_dir/</code><br>test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls orig_dir/</code><br>comm_dir orig_orig_dir test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>ls orig_dir/orig_orig_dir/</code> and <code>ls orig_dir/comm_dir/</code><br>test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>diff orig_dir/ new_dir/</code><br>Common subdirectories: new_dir/comm_dir and orig_dir/comm_dir # 两个目录共有的子目录，不会比较子目录中的文件信息<br>Only in new_dir/: new_new_dir # 只出现在new_dir中的目录，不会比较子目录中的文件信息<br>Only in orig_dir/: orig_orig_dir # 只出现在orig_dir中的目录，不会比较子目录中的文件信息<br>diff orig_dir/test1.txt new_dir/test1.txt # new_dir和orig_dir共有的同名文件内容的差异<br>0a1 # 具体的差异信息<br>> asdfaf # 具体的差异信息<br>Only in new_dir/: test3.txt # 只出现在new_dir中的文件<br>Only in orig_dir/: test4.txt # 只出现在orig_dir中的文件</p></blockquote><p><strong>比较两个目录可以找到每个目录共有的、独有的文件和目录信息；对于共有的子目录，不会继续比较子目录中的信息；对于共有的文件，会得出文件的差异信息</strong></p><hr><h3 id="r-比较子目录中的文件"><a href="#r-比较子目录中的文件" class="headerlink" title="-r-比较子目录中的文件"></a>-r-比较子目录中的文件</h3><p>上述对目录进行比较时默认不会比较子目录中的文件信息，使用-r参数可以对这些文件进行比较：</p><blockquote><p><code>diff -r orig_dir/ new_dir/</code><br>diff -r orig_dir/comm_dir/test1.txt new_dir/comm_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/comm_dir: test3.txt<br>Only in orig_dir/comm_dir: test4.txt<br>Only in new_dir/: new_new_dir<br>Only in orig_dir/: orig_orig_dir<br>diff -r orig_dir/test1.txt new_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/: test3.txt<br>Only in orig_dir/: test4.txt</p></blockquote><hr><h3 id="q-只显示有无差异"><a href="#q-只显示有无差异" class="headerlink" title="-q-只显示有无差异"></a>-q-只显示有无差异</h3><p>默认情况下如果文件存在差异会显示差异信息，使用<code>-q</code>参数只会显示有无差异不会显示具体的差异信息:</p><blockquote><p><code>diff -q test1.txt test2.txt</code><br>Files test1.txt and test2.txt differ</p></blockquote><hr><h3 id="i-忽略文件中文本大小写"><a href="#i-忽略文件中文本大小写" class="headerlink" title="-i-忽略文件中文本大小写"></a>-i-忽略文件中文本大小写</h3><blockquote><p><code>diff file1.txt file2.txt</code><br>1c1<br>&lt; hi<br>-–<br>> HI</p></blockquote><p>默认情况下是会区分文件中文本信息大小写的</p><blockquote><p><code>diff -i file1.txt file2.txt</code></p></blockquote><p>使用了<code>-i</code>参数没有输出内容，因为忽略大小写之后文件中文本信息是相同的</p><hr><h3 id="s-在文件内容相同条件下报告信息"><a href="#s-在文件内容相同条件下报告信息" class="headerlink" title="-s-在文件内容相同条件下报告信息"></a>-s-在文件内容相同条件下报告信息</h3><p>上面使用了<code>-i</code>参数得到了文件内容是相同的，这时默认就不会输出信息，如果想要在文件内容相同时报告文件内容是相同的，需要使用<code>-s</code>参数</p><blockquote><p><code>diff -is file1.txt file2.txt</code><br>Files file1.txt and file2.txt are identical</p></blockquote><hr><h3 id="b-忽略文本中的空格"><a href="#b-忽略文本中的空格" class="headerlink" title="-b-忽略文本中的空格"></a>-b-忽略文本中的空格</h3><blockquote><p><code>cat file1</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>cat file2</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>diff file1 file2</code><br>1c1<br>&lt; Hi, how are you?<br>-–<br>> Hi, how are you?</p></blockquote><p>上述文件中的区别仅仅是file2多了一个空格，但是使用<code>diff</code>命令后仍然会输出不同，而常规情形下，这应该被认为是相同的，这时就可以使用<code>-b</code>参数</p><blockquote><p><code>diff -bs file1 file2</code><br>Files file1 and file2 are identical</p></blockquote><hr><h3 id="y-以并列的方式显示文件的异同之处"><a href="#y-以并列的方式显示文件的异同之处" class="headerlink" title="-y-以并列的方式显示文件的异同之处"></a>-y-以并列的方式显示文件的异同之处</h3><blockquote><p><code>diff -y test1.txt test2.txt</code><br>Hi, &lt;<br>Hello, Hello,<br>&gt; Hi,<br>How are you? How are you?<br>I am fine, | I am fine.<br>Thank you. &lt;</p></blockquote><ul><li><code>|</code>：表示前后2个文件内容存在差异</li><li><code>&gt;</code>：表示第一个文件删除的行</li><li><code>&lt;</code>：表示第二个文件增加的行</li></ul><hr><h3 id="W-在使用-y参数时，指定栏宽"><a href="#W-在使用-y参数时，指定栏宽" class="headerlink" title="-W-在使用-y参数时，指定栏宽"></a>-W-在使用-y参数时，指定栏宽</h3><p>如果指定的栏宽太窄，会显示每行的部分信息：</p><blockquote><p><code>diff -y -W 10 test1.txt test2.txt</code><br>Hi &lt;<br>He He<br>> Hi<br>Ho Ho<br>I | I<br>Th &lt;</p></blockquote><hr><h3 id="c-上下文格式输出"><a href="#c-上下文格式输出" class="headerlink" title="-c-上下文格式输出"></a>-c-上下文格式输出</h3><p>显示不同行的信息时一同显示上下文信息，默认是存在不同的上下3行：</p><blockquote><p><code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><ul><li><code>***</code>表示变动前的文件，<code>---</code>表示变动后的文件</li><li><code>*** 1,5 ****</code>表示变动前文件的1到5行，<code>--- 1,4 ----</code>表示变动后文件的1到4行</li><li>文件内容的每一行最前面，还有一个标记位<ul><li>如果为<code>空</code>，表示该行无变化</li><li>如果是感叹号（<code>!</code>），表示该行有改动</li><li>如果是减号（<code>-</code>），表示该行被删除</li><li>如果是加号（<code>+</code>），表示该行为新增</li></ul></li></ul><hr><h3 id="C-NUM-指定具体是上下文行数"><a href="#C-NUM-指定具体是上下文行数" class="headerlink" title="-C NUM-指定具体是上下文行数"></a>-C NUM-指定具体是上下文行数</h3><p>这个功能和上面的<code>-c</code>是相同的，只是<code>-c</code>只能是默认的上下3行，而<code>-C num</code>可以指定具体的上下文行数</p><blockquote><p><code>diff -C 3 test1.txt test2.txt</code> 等同于 <code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><hr><h3 id="u-合并格式输出"><a href="#u-合并格式输出" class="headerlink" title="-u-合并格式输出"></a>-u-合并格式输出</h3><p>如果两个文件<strong>相似度很高</strong>，那么<strong>上下文格式的<code>diff</code>，将显示大量重复的内容</strong>，很浪费空间，这个时候使用合并格式输出<strong>将f1和f2的上下文(默认3行)合并在一起显示</strong>：</p><blockquote><p><code>diff -u test1.txt test2.txt</code><br>— test1.txt 2019-03-14 15:26:48.960323475 +0800<br>+++ test2.txt 2019-03-14 15:27:07.411322620 +0800<br>@@ -1,5 +1,4 @@<br>-Hi,<br>Hello,<br>+Hi,<br>How are you?<br>-I am fine,<br>-Thank you.<br>+I am fine.</p></blockquote><ul><li><code>---</code>表示变动前的文件，<code>+++</code>表示变动后的文件</li><li>变动的位置用两个<code>@</code>作为起首和结束，<code>-1,5</code>表示第一个文件的1到5行，<code>+1,4</code>表示第二个文件的1到4行</li><li>每一行最前面的标志位，<strong>空表示无变动</strong>，<strong>减号表示第一个文件删除的行</strong>，<strong>加号表示第二个文件新增的行</strong></li></ul><hr><h3 id="U-NUM-指定合并格式上下文的行数"><a href="#U-NUM-指定合并格式上下文的行数" class="headerlink" title="-U NUM-指定合并格式上下文的行数"></a>-U NUM-指定合并格式上下文的行数</h3><p>这个功能和上面的<code>-u</code>是相同的，只是<code>-u</code>只能是默认的上下3行，而<code>-U num</code>可以指定具体的上下文行数</p><hr><h3 id="结合patch进行内容更新"><a href="#结合patch进行内容更新" class="headerlink" title="结合patch进行内容更新"></a>结合patch进行内容更新</h3><p>这个暂时应该用不到，所以就不学习了，后期如果使用的话再进行学习补充，后面列出的参考链接有对应的示例。</p><hr><p><br></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><div class="note info"><ul><li>diff的<strong>几种输出模式</strong>：<strong>并列输出(-y)</strong>、<strong>上下文格式输出(-c)</strong>、<strong>合并格式输出(-u)</strong>之间的不兼容的，只能使用其中一种，参数不能混用</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/12/2814048.html" target="_blank" rel="noopener">实例较多</a></li><li><a href="https://linux.cn/article-2298-1.html" target="_blank" rel="noopener">举例说明Linux diff 命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-diff.html" target="_blank" rel="noopener">参数讲解</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">清晰的讲解</a></li><li><a href="http://wiki.jikexueyuan.com/project/shell-learning/file-comparing-cmp-diff-patch.html" target="_blank" rel="noopener">文件比较 cmp，diff，patch</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmp-比较文件差异</title>
      <link href="/posts/62860.html"/>
      <url>/posts/62860.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<code>cmp</code>对<strong>两个文件</strong>进行比较，比较时是<strong>逐字节</strong>进行的；包括的参数：<code>-b</code>、<code>-i</code>、<code>-i</code>、<code>-l</code>、<code>-n</code>、<code>-s</code>以及<strong>显示运行进度</strong>。</p></div><a id="more"></a><h2 id="cmp简介"><a href="#cmp简介" class="headerlink" title="cmp简介"></a>cmp简介</h2><p><code>cmp</code>命令用于比较两个文件是否有差异；当相互比较的两个文件<strong>完全一样</strong>时，则该命令不会有输出结果；若发现<strong>有所差异</strong>，<strong>默认会标示出第一个不同之处的字符和列数编号</strong></p><p>若不指定任何文件名称或是所给予的文件名为<code>-</code>，则<code>cmp</code>指令会从标准输入读取数据</p><p><mark>这个和前面讲到的<code>comm</code>命令的不同之处在于</mark>：comm命令对已排序的文件进行比较并将结果分为3列，便于提取文件比较的结果，如得到两个文件的差集、交集、并集和对称差集等，而<code>cmp</code>命令侧重于比较两个文件差异，大多用于比较同一个文件修改之后和修改之前的差异，并且<code>cmp</code>比较文件不需要进行排序；<code>cmp</code>命令比较文件是<strong>byte by byte</strong>，而comm命令比较文件是<strong>line by line</strong>。</p><hr><p><br></p><h2 id="cmp命令用法"><a href="#cmp命令用法" class="headerlink" title="cmp命令用法"></a>cmp命令用法</h2><h3 id="cmp命令格式"><a href="#cmp命令格式" class="headerlink" title="cmp命令格式"></a>cmp命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  cmp [OPTION] FILE1 [FILE2 [SKIP1 [SKIP2]]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The optional SKIP1 and SKIP2 specify the number of bytes to skip</span></span><br><span class="line"><span class="comment"># at the beginning of each file (zero by default).</span></span><br></pre></td></tr></table></figure><p><strong>Compare two files byte by byte</strong></p><hr><h3 id="cmp-options说明"><a href="#cmp-options说明" class="headerlink" title="cmp options说明"></a>cmp options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–print-bytes</td><td>除了标明差异处所在之外，一并显示该字符所对应字符和字节值</td></tr><tr><td>-i SKIP</td><td>–ignore-initial=SKIP</td><td>跳过一定的字节数(不包括SKIP)</td></tr><tr><td>-i SKIP1:SKIP2</td><td>–ignore-initial=SKIP1:SKIP2</td><td>从两个文件中跳过不同的字节数，SKIP1是FILE1跳过的字节数，SKIP为FILE2跳过的字节数</td></tr><tr><td>-l</td><td>–verbose</td><td>显示所有不同字节的字节位置（和值）</td></tr><tr><td>-n</td><td>–bytes=LIMIT</td><td>限制要比较的字节数(包括LIMIT)</td></tr><tr><td>-s</td><td>–quiet, –silent</td><td>抑制正常生成的输出，只返回文件是否相同的退出码(可以通过<code>$?</code>得到)</td></tr></tbody></table><hr><h3 id="cmp-i选项可选单位"><a href="#cmp-i选项可选单位" class="headerlink" title="cmp -i选项可选单位"></a>cmp -i选项可选单位</h3><table><thead><tr><th>简写</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>kB</td><td>kilobytes</td><td>1000</td></tr><tr><td>K</td><td>kibibytes</td><td>1024</td></tr><tr><td>MB</td><td>megabytes</td><td>1,000,000</td></tr><tr><td>M</td><td>mebibytes</td><td>1,048,576</td></tr><tr><td>GB</td><td>gigabytes</td><td>1,000,000,000</td></tr><tr><td>G</td><td>gibibytes</td><td>1,073,741,824</td></tr></tbody></table><hr><p><br></p><h2 id="cmp用法实例"><a href="#cmp用法实例" class="headerlink" title="cmp用法实例"></a>cmp用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Absncn 50<br>Asldssja 60<br>Jslkadjls 85</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Absncn 50<br>AsldssjE 62<br>Jslkadjls 85</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><p>默认会告诉在第几行的第几个字节出现不同：</p><blockquote><p><code>cmp test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2</p></blockquote><p><strong>注意这里的<code>byte 18</code>来源：系统默认编码方式为UTF-8(查看方式见<a href="http://showteeth.tech/posts/56690.html">这篇文章</a>)，1个英文字符 = 1个字节；换行符占一个字节；空格占一个字节；第二行的结果存在差异的话，字符会从第一行的第一个开始算起，叠加的，不是单独每一行算</strong></p><h3 id="b-显示不同的字节及字节值"><a href="#b-显示不同的字节及字节值" class="headerlink" title="-b-显示不同的字节及字节值"></a>-b-显示不同的字节及字节值</h3><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is <strong>141 a 105 E</strong></p></blockquote><p><strong>只会显示第一个，不会显示所有的</strong>，具体是字母a和E不同，字节值分别为141和105(这个没算。。。)</p><hr><h3 id="i-跳过指定的字节"><a href="#i-跳过指定的字节" class="headerlink" title="-i-跳过指定的字节"></a>-i-跳过指定的字节</h3><blockquote><p><code>cmp -b -i 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 3</strong>, line 1 is 60 0 62 2</p></blockquote><p>跳过<strong>前18个之后开始的第3个字节</strong>，0和2不同</p><div class="note info"><p>注意这个是<strong>不包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置</p></div><hr><h3 id="i-从两个文件跳过不同数量的字节"><a href="#i-从两个文件跳过不同数量的字节" class="headerlink" title="-i-从两个文件跳过不同数量的字节"></a>-i-从两个文件跳过不同数量的字节</h3><blockquote><p><code>cmp -b -i 18:18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 3, line 1 is 60 0 62 2</p></blockquote><p>18:18：第一个文件跳过的字节数为18，第二个文件跳过的字节数也是18</p><hr><h3 id="l-显示所有不同字节的字节位置（和值）"><a href="#l-显示所有不同字节的字节位置（和值）" class="headerlink" title="-l-显示所有不同字节的字节位置（和值）"></a>-l-显示所有不同字节的字节位置（和值）</h3><blockquote><p><code>cmp -l test1.txt test2.txt</code><br>18 141 105<br>21 60 62</p></blockquote><p>输出结果：</p><ul><li>第一列（如上所示）表示不同<strong>字节的位置</strong>（字节数）</li><li>第二列表示<strong>第一个文件</strong>中不同字节的字节值</li><li>第三列表示<strong>第二个文件</strong>中不同字节的字节值</li></ul><p>前面的<code>-b</code>等参数只会显示<strong>第一个</strong>不同的字节位置和值，这里会<strong>显示所有的</strong>字节数字和值</p><hr><h3 id="n-限制要比较的字节数"><a href="#n-限制要比较的字节数" class="headerlink" title="-n-限制要比较的字节数"></a>-n-限制要比较的字节数</h3><p>最多只比较的字符数：</p><blockquote><p><code>cmp -n 17 test1.txt test2.txt</code><br><code>cmp -n 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 18</strong>, line 2</p></blockquote><p>如果和<code>-i</code>参数联合使用：</p><blockquote><p><code>cmp -b -l -i 3 -n 18 test1.txt test2.txt</code><br>15 141 a 105 E<br>18 60 0 62 2</p></blockquote><p>注意这里相比于没有设置跳过字节会多出一行差异的结果，<strong>表明-n是相对字节位置，而不是绝对的字节位置</strong></p><p>和不使用<code>-i</code>的对比：</p><blockquote><p><code>cmp -b -l -n 18 test1.txt test2.txt</code><br>18 141 a 105 E</p></blockquote><div class="note info"><ul><li>注意这里是<strong>包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置，因为包括了所以才会输出在byte18位置存在区别</li><li><strong>-n指定的是相对字节位置，而不是绝对字节位置</strong>，比如上面跳过前3个字符之后出现差异的就成了第15个字节位置的，同时因为-n设置为18向后推移3个字节，就会出现了第二个不同的位置，而如果不设置-i参数就不会得到第二个不同的位置</li></ul></div><hr><h3 id="s-抑制正常生成的输出，只返回反映文件是否相同的退出码"><a href="#s-抑制正常生成的输出，只返回反映文件是否相同的退出码" class="headerlink" title="-s-抑制正常生成的输出，只返回反映文件是否相同的退出码"></a>-s-抑制正常生成的输出，只返回反映文件是否相同的退出码</h3><blockquote><p><code>cmp -s -b test1.txt test2.txt</code></p></blockquote><p>没有输出结果，也就是原本需要输出的在哪一行存在差异都不会输出来了，然后查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果是<code>1</code>，表明文件是不相同的，这样可<strong>得到文件是否相同的信息，但是并不关注具体的差异在什么地方</strong></p><p>而如果不加<code>-s</code>就会正常输出：</p><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is 141 a 105 E</p></blockquote><p>同时不加<code>-s</code>查看查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果和加了<code>-s</code>一样都返回的是<code>1</code></p><div class="note info"><p>在脚本中使用<code>cmp</code>命令时，此选项可以会派上用场。 例如，根据文件是否相同(通过访问命令的退出代码可以知道)来进行下一步的操作，这个时候我们可能并<strong>不关心具体文件的差异在什么地方，而是关心文件是不是有差异这个整体的结果</strong></p></div><h3 id="显示运行进度"><a href="#显示运行进度" class="headerlink" title="显示运行进度"></a>显示运行进度</h3><p>这个需要结合<a href="http://showteeth.tech/posts/6226.html">pv命令</a>，安装和使用<a href="http://showteeth.tech/posts/6226.html">pv命令</a>之后再进行学习，参考参考链接的前两个</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtoforge.com/linux-cmp-command/" target="_blank" rel="noopener">Linux cmp command tutorial for beginners （7 examples）</a></li><li><a href="https://www.howtoing.com/linux-cmp-command" target="_blank" rel="noopener">Linux初学者的cmp命令教程（7个例子）</a></li><li><a href="https://www.computerhope.com/unix/ucmp.htm" target="_blank" rel="noopener">Linux cmp command-关于-i参数单位的问题很好</a></li><li><a href="https://www.tutorialspoint.com/unix_commands/cmp.htm" target="_blank" rel="noopener">cmp - Unix, Linux Command</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>journey</title>
      <link href="/posts/34270.html"/>
      <url>/posts/34270.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><h3 id="磁器口"><a href="#磁器口" class="headerlink" title="磁器口"></a>磁器口</h3><ul><li>吃的：陈麻花-推荐<strong>陈昌银</strong>或者<strong>夏麻花</strong>、<strong>张老汉手工酸辣粉</strong>（磁器口必吃之一）</li><li>有很多文艺的小咖啡馆或者书店</li><li>磁器口的主街人满为患，商业化严重，<strong>更建议去侧街</strong>，也是咖啡馆一条街，客量少，店面装饰都很有文艺味儿，<strong>是来磁器口的正确打开方式</strong>。（在此安利一家咖啡馆——<strong>懒鱼时光馆</strong>，上图即是该咖啡馆，是一家有故事的咖啡馆）</li></ul><h3 id="洪崖洞"><a href="#洪崖洞" class="headerlink" title="洪崖洞"></a>洪崖洞</h3><ul><li><strong>晚上去</strong>，白天不好看，晚上有灯光</li><li>主要是建筑构造和风貌</li></ul><h3 id="南山一棵树观景台"><a href="#南山一棵树观景台" class="headerlink" title="南山一棵树观景台"></a>南山一棵树观景台</h3><ul><li>可以将重庆所有的美景尽收眼底！建议<strong>夜晚去</strong>，重庆的夜景很美很美很美！<ul><li>门票：门票30，学生证15</li></ul></li><li>吃的：泉水鸡、枇杷园（火锅）</li></ul><h3 id="十八梯"><a href="#十八梯" class="headerlink" title="十八梯"></a><del>十八梯</del></h3><ul><li>电影《从你的全世界路过》</li><li>十八梯是重庆渝中半岛的一条街，从重庆城的上半城（山顶）通到下半城（山脚），全部由石阶铺成，<strong>把山顶的繁华商业区和山下江边的老城区连起来</strong>。</li><li><strong>拆迁了</strong></li></ul><h3 id="朝天门两江游"><a href="#朝天门两江游" class="headerlink" title="朝天门两江游"></a>朝天门两江游</h3><ul><li>重庆很出名的两江交汇：<strong>长江与嘉陵江</strong></li><li>夜景</li></ul><h3 id="长江索道"><a href="#长江索道" class="headerlink" title="长江索道"></a>长江索道</h3><ul><li>到达对岸后不用着急回来可以在那边拍拍照，然后再返回来</li></ul><h3 id="皇冠大扶梯"><a href="#皇冠大扶梯" class="headerlink" title="皇冠大扶梯"></a>皇冠大扶梯</h3><ul><li>亚洲第二长的一级提升坡地大扶梯</li><li>这个扶梯<strong>不用刻意去</strong>，如果方便可以去坐坐，其实<em>就是一个长长的扶梯</em>，但是因为有坡度而且特别长所以很炫酷！</li></ul><h3 id="中山四路"><a href="#中山四路" class="headerlink" title="中山四路"></a>中山四路</h3><ul><li>历史遗迹很多，除了中国民主党派博物馆的特园外，此地还有桂园、周公馆、戴公馆、张骧公馆、国民政府总统府旧址等</li></ul><h3 id="解放碑"><a href="#解放碑" class="headerlink" title="解放碑"></a>解放碑</h3><ul><li><strong>解放碑是重庆的标志</strong>，特别是圣诞节和跨年的时候，大家会不约而同地去解放碑一同度过！场面壮观到每年都会提前进行封路。</li><li>解放碑那有一条<strong>好吃街</strong>，可以去吃吃～</li><li><strong>李串串</strong></li></ul><h3 id="两江影视城民国街"><a href="#两江影视城民国街" class="headerlink" title="两江影视城民国街"></a>两江影视城民国街</h3><ul><li>再现了百年老重庆风土人情</li><li>影视城里重现了当时的解放碑、磁器口、朝天门、十八梯，特别有意思</li><li>当地也可以<strong>租民国服装</strong></li></ul><h2 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h2><h3 id="重庆小面"><a href="#重庆小面" class="headerlink" title="重庆小面"></a>重庆小面</h3><h3 id="重庆火锅"><a href="#重庆火锅" class="headerlink" title="重庆火锅"></a>重庆火锅</h3><ul><li><strong>大龙火锅</strong>。以<strong>超辣</strong>闻名，吃这家店的人超级多，中午都得排很久的队</li></ul><h3 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h3><ul><li>串串推荐小郡肝、李记、怒火八零等等</li></ul><h3 id="酸辣粉-凉粉-冰粉凉虾-凉糕"><a href="#酸辣粉-凉粉-冰粉凉虾-凉糕" class="headerlink" title="酸辣粉/凉粉/冰粉凉虾/凉糕"></a>酸辣粉/凉粉/冰粉凉虾/凉糕</h3><ul><li><strong>莱得快</strong>的杂酱酸辣粉</li><li><strong>阿坤</strong>的杂酱酸辣粉、苕皮、海带，有点辣。但是阿坤里面有甜品所以可以也点一份甜品，防止被辣着，推荐它们的双皮奶。</li><li>好又来酸辣粉（口碑店家）、手工酸辣粉（视觉和味觉两不误）</li></ul><h3 id="麻辣鱼-酸菜鱼-尖椒兔"><a href="#麻辣鱼-酸菜鱼-尖椒兔" class="headerlink" title="麻辣鱼/酸菜鱼/尖椒兔"></a>麻辣鱼/酸菜鱼/尖椒兔</h3><ul><li>大渡口，店名是：<strong>霸王兔</strong></li></ul><h3 id="夜啤酒-万州烤鱼-烧烤"><a href="#夜啤酒-万州烤鱼-烧烤" class="headerlink" title="夜啤酒/万州烤鱼/烧烤"></a>夜啤酒/万州烤鱼/烧烤</h3><h3 id="奶制品"><a href="#奶制品" class="headerlink" title="奶制品"></a>奶制品</h3><ul><li>重庆本土的<strong>天友</strong>，以及后发的<strong>奶牛梦工厂</strong></li></ul><h2 id="参考路线"><a href="#参考路线" class="headerlink" title="参考路线"></a>参考路线</h2><ul><li><a href="https://www.zhihu.com/question/36219939/answer/109923082" target="_blank" rel="noopener">两天</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>comm-文件比较，文本文件的交集、差集与求差</title>
      <link href="/posts/39582.html"/>
      <url>/posts/39582.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>comm</code>命令对两个文件内容进行比较，注意文件<strong>需要排序</strong>，相比于其他比较文件的命令，<code>comm</code>可以将文件内容不同的分列显示，<strong>便于提取(文件求交、并、差、对称差等)所需要的内容</strong>，另外两个文件比较命令包括<a href="http://showteeth.tech/posts/62860.html">cmp</a>、<a href="http://showteeth.tech/posts/56778.html">diff</a>。</p></div><a id="more"></a><h2 id="comm用法"><a href="#comm用法" class="headerlink" title="comm用法"></a>comm用法</h2><p><code>comm</code>命令会<strong>一行行(line by line)地</strong>比较两个<mark>已排序文件</mark>的差异，并将其结果显示出来，如果没有指定任何参数，则会把<strong>结果分成3行显示</strong>：</p><ul><li>第1行<strong>仅</strong>是在<strong>第1个文件中</strong>出现过的列</li><li>第2行是<strong>仅</strong>在<strong>第2个文件中</strong>出现过的列</li><li>第3行则是在第1与第2个文件里<strong>都出现过</strong>的列。</li></ul><p>若给予的文件名称为<code>-</code>，则<code>comm</code>命令会从<strong>标准输入</strong>设备读取数据</p><h3 id="comm命令格式"><a href="#comm命令格式" class="headerlink" title="comm命令格式"></a>comm命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  comm [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="comm-options说明"><a href="#comm-options说明" class="headerlink" title="comm options说明"></a>comm options说明</h3><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>不显示第1列（即不显示只在file1中找到的行）</td></tr><tr><td>-2</td><td>不显示第2列（即不显示只在file2中找到的行）</td></tr><tr><td>-3</td><td>不显示第3列（即不显示在两个文件中都找到的行）</td></tr><tr><td>–check-order</td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td>不判断所有输入文件是不是已经排好序</td></tr><tr><td>–output-delimiter=STR</td><td>指定输出结果的分隔符</td></tr></tbody></table><hr><p><br></p><h2 id="comm用法实例"><a href="#comm用法实例" class="headerlink" title="comm用法实例"></a>comm用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat a.txt<br>aaa<br>bbb<br>ccc<br>111<br>ddd<br>eee<br>222</p></blockquote><blockquote><p>cat b.txt<br>bbb<br>ccc<br>aaa<br>hhh<br>ttt<br>jjj</p></blockquote><p>注意上面两个文件都没有排序，看看comm对没排序文件的处理</p><hr><h3 id="使用默认方式对文本进行比较"><a href="#使用默认方式对文本进行比较" class="headerlink" title="使用默认方式对文本进行比较"></a>使用默认方式对文本进行比较</h3><blockquote><p><code>comm a.txt b.txt</code><br>aaa<br>bbb<br>ccc<br>comm: file 1 is not in sorted order<br>comm: file 2 is not in sorted order<br>111<br>aaa<br>ddd<br>eee<br>222<br>hhh<br>ttt<br>jjj</p></blockquote><p>从上面可以看出，没排序comm命令会爆出问题，但是仍然会运行得到结果；发现因为没有排序的原因，第二个文件的<code>aaa</code>在第一个文件中也存在但是却被当成了file2独有的。<strong>总的来说就是如果没排序，comm命令会爆出问题但不会停止运行，并且结果会存在问题</strong>，正常结果如下：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><p>可以看出默认情况会输出三列，第一列是第一个文件独有的内容，第二列是第二个文件独有的内容，第三列是第三个文件独有的内容，各列是以制表符<code>\t</code>作为定界符，可以通过对定界符-制表符<code>\t</code>的操作来达到相应的目的。</p><p>由于参数较为简单，这里就不单独列出每个参数单独的用法的示例，主要给出<strong>参数组合用法以及和定界符组合使用的示例如下</strong>：</p><table><thead><tr><th>集合操作</th><th>含义及对应的参数组合</th></tr></thead><tbody><tr><td>A∩B</td><td>文件交集，-12</td></tr><tr><td>A∪B</td><td>文件的并集，将输出整合为一列，去掉定界符\t</td></tr><tr><td>A-B</td><td>差集，-23</td></tr><tr><td>B-A</td><td>差集，-13</td></tr><tr><td>A∆B</td><td>对称差集，并集减去交集，也就是去除文件中相同的部分，需要使用-3以及将剩下两列整合为一列</td></tr></tbody></table><h3 id="12-A∩B-文件交集"><a href="#12-A∩B-文件交集" class="headerlink" title="-12-A∩B-文件交集"></a>-12-A∩B-文件交集</h3><p>默认输出结果的第三列就是两个文件共有的部分：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -12 - &lt;(sort -k 1,1 b.txt)</code><br>aaa<br>bbb<br>ccc</p></blockquote><hr><h3 id="定界符-t-A∪B-文件的并集"><a href="#定界符-t-A∪B-文件的并集" class="headerlink" title="定界符\t-A∪B-文件的并集"></a>定界符\t-A∪B-文件的并集</h3><p>并集就是将三列输出结果合并：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="23-A-B-差集"><a href="#23-A-B-差集" class="headerlink" title="-23-A-B-差集"></a>-23-A-B-差集</h3><p>差集就是在A中但是不在B中的部分，去掉第三列(A、B共有的)以及第二列B独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -23 - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>ddd<br>eee</p></blockquote><hr><h3 id="12-B-A-差集"><a href="#12-B-A-差集" class="headerlink" title="-12-B-A-差集"></a>-12-B-A-差集</h3><p>差集就是在B中但是不在A中的部分，去掉第三列(A、B共有的)以及第一列A独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -13 - &lt;(sort -k 1,1 b.txt)</code><br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="3-定界符-t-A∆B-对称差集"><a href="#3-定界符-t-A∆B-对称差集" class="headerlink" title="-3+定界符\t-A∆B-对称差集"></a>-3+定界符\t-A∆B-对称差集</h3><p>对称差集就是两个文件独有的内容的并集：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -3 - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="多列文件的处理"><a href="#多列文件的处理" class="headerlink" title="多列文件的处理"></a>多列文件的处理</h3><p>多列文件处理会<strong>将一整行当成一个元素进行比较</strong>，来列出各个文件独有的、文件共有的信息，具体的每列代表的意思和单列文件相同，注意如果<strong>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠</strong></p><blockquote><p><code>cat c.txt</code><br>aaa 111<br>bbb 222</p></blockquote><blockquote><p><code>cat d.txt</code><br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><blockquote><p><code>comm c.txt d.txt</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><p>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠：</p><blockquote><p><code>sed &#39;s/ /\t/&#39; c.txt |comm - &lt;(sed &#39;s/ /\t/&#39; d.txt)</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/comm" target="_blank" rel="noopener">comm命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-comm.html" target="_blank" rel="noopener">Linux comm命令</a></li><li><a href="https://www.cnblogs.com/nerxious/archive/2013/01/09/2853004.html" target="_blank" rel="noopener">简明Linux命令行笔记：comm</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda安装多版本python及常用命令</title>
      <link href="/posts/34297.html"/>
      <url>/posts/34297.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本是通过anaconda给电脑安装的python3，但是今天在从github上下载使用一个package时候报错：</p><blockquote><p>SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(‘File does not exist: %s’ % filepath)?</p></blockquote><p>后来发现这个是因为<strong>python版本的问题</strong>，所以就需要<strong>重新再安装一个python2的环境</strong></p><hr><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><p>这个本来可以使用简单地打开<code>anaconda navigator</code>图形界面进行<code>creat</code>环境即可，但是秉承着想对anaconda进行学习的态度，这里主要使用命令行的形式。</p><h3 id="显示所有环境名字和路径"><a href="#显示所有环境名字和路径" class="headerlink" title="显示所有环境名字和路径"></a>显示所有环境名字和路径</h3><p>创建新环境之前先看看目前的电脑有哪些环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>发现电脑只有一个原装的<code>base</code>环境，也就是<code>python3</code>的环境以及我自己安装的<code>rstudio</code>环境，同时需要注意<strong>上面的<code>*</code>表明是当前使用的环境！</strong></p><hr><h3 id="创建环境并指定环境名称和python版本"><a href="#创建环境并指定环境名称和python版本" class="headerlink" title="创建环境并指定环境名称和python版本"></a>创建环境并指定环境名称和python版本</h3><p>这一步是使用<code>conda create</code>创建环境，同时指定环境的名称为<code>pyenv2_7</code>，使用的python版本为<code>python=2.7</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pyenv2_7 python=2.7</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="再次显示所有环境名字和路径"><a href="#再次显示所有环境名字和路径" class="headerlink" title="再次显示所有环境名字和路径"></a>再次显示所有环境名字和路径</h3><p>创建新环境再次查看现在所有的环境名称和对应的路径：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><p>发现已经出现了新建的环境：</p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>pyenv2_7 C:\Users\14910\Anaconda3\envs\pyenv2_7<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>由于只是创建了环境，还没有激活，所以当前使用的环境(<code>*</code>标记的)还是<code>base</code>环境，<strong>新建的环境需要激活才能够使用</strong></p><hr><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>为了能够使用新创建的环境还需要激活：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pyenv2_7</span><br></pre></td></tr></table></figure><p></p><p>为了验证环境是不是已经成功应用，检查python版本：</p><blockquote><p>python –version<br>Python 2.7.15 :: Anaconda, Inc.</p></blockquote><p>发现环境已经安装成功</p><hr><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><p>使用完成之后推出新建的环境，回到<code>base</code>环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p></p><p><strong>注意<code>conda deactivate</code>后面不需要跟退出的环境名，直接就退出当前环境，退出环境之后直接就进入了base环境</strong>。</p><hr><h2 id="anaconda-常用命令"><a href="#anaconda-常用命令" class="headerlink" title="anaconda 常用命令"></a>anaconda 常用命令</h2><ul><li>activate // 切换到base环境</li><li>activate learn // 切换到learn环境</li><li>conda deactivate // 退出当前环境</li><li>conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)</li><li>conda env list (conda env –info) // 列出conda管理的所有环境</li><li>conda list // 列出当前环境的所有包</li><li>conda install requests (pip install requests) // 安装requests包</li><li>conda remove requests (pip uninstall requests) // 卸载requets包</li><li>conda update requests // 更新requests包</li><li>conda remove -n learn –all // <strong>删除learn环境及下属所有包</strong></li><li>conda env export &gt; environment.yaml // <strong>导出当前环境的包信息</strong></li><li>conda env create -f environment.yaml // <strong>用配置文件创建新的虚拟环境</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/tangwenbo124/article/details/74784044" target="_blank" rel="noopener">ananconda创建新环境，python 2.7、3.5共存，pycharm 使用conda新环境，win10、linux下通用</a></li><li><a href="https://www.jb51.net/article/114614.htm" target="_blank" rel="noopener">利用Anaconda完美解决Python 2与python 3的共存问题</a></li></ul><hr><p><br></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="UnavailableInvalidChannel"><a href="#UnavailableInvalidChannel" class="headerlink" title="UnavailableInvalidChannel"></a>UnavailableInvalidChannel</h3><p><strong>问题表现</strong>：<br><img src="https://i.loli.net/2019/04/11/5caed32a7e2ed.png" alt="conda_UnavailableInvalidChannel.png"></p><p><strong>解决办法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以试试这个办法</span></span><br><span class="line"><span class="comment"># 依次添加后面添加的channels会移到最上面</span></span><br><span class="line">conda config --add channels defaults</span><br><span class="line">conda config --add channels bioconda</span><br><span class="line">conda config --add channels conda-forge</span><br><span class="line"><span class="comment"># 也可以直接修改.condarc文件</span></span><br><span class="line">conda config --show-source</span><br><span class="line">==&gt; /root/.condarc &lt;==</span><br><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接添加conda-forge和bioconda</span></span><br><span class="line">vim /root/.condarc </span><br><span class="line">channels:</span><br><span class="line">  - conda-forge</span><br><span class="line">  - bioconda</span><br><span class="line">  - defaults</span><br></pre></td></tr></table></figure><p></p><p><strong>参考链接</strong>：</p><ul><li><a href="https://bioconda.github.io/" target="_blank" rel="noopener">Bioconda</a></li><li><a href="https://conda-forge.org/#about" target="_blank" rel="noopener">conda-forge</a></li></ul><hr><h3 id="退出默认的base环境"><a href="#退出默认的base环境" class="headerlink" title="退出默认的base环境"></a>退出默认的base环境</h3><p>默认情况下，安装anaconda之后，每次登陆服务器都会自动激活conda的base环境，为了不让这种默认的设置生效可以使用如下命令来关闭：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭自动激活base环境</span></span><br><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><p><strong>参考链接</strong>：</p><ul><li><a href="https://stackoverflow.com/questions/54429210/how-do-i-prevent-conda-from-activating-the-base-environment-by-default" target="_blank" rel="noopener">How do I prevent Conda from activating the base environment by default?</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成-使用Travis CI自动部署github项目</title>
      <link href="/posts/62916.html"/>
      <url>/posts/62916.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>linux系统，换电脑之后再写！</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://segmentfault.com/a/1190000011218410?utm_source=tag-newest" target="_blank" rel="noopener">Travis CI 自动化部署博客</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程</a></li><li><a href="https://www.cnblogs.com/zqzjs/p/6119750.html" target="_blank" rel="noopener">Travis CI用来持续集成你的项目</a></li><li><a href="https://www.cnblogs.com/morang/p/7228488.html" target="_blank" rel="noopener">使用travis-ci自动部署github上的项目</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理多个SSH公钥</title>
      <link href="/posts/51573.html"/>
      <url>/posts/51573.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法</p></div><a id="more"></a><h2 id="SSH-key介绍"><a href="#SSH-key介绍" class="headerlink" title="SSH key介绍"></a>SSH key介绍</h2><p>SSH key提供了一种与GitHub或其他平台通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub或其他平台作为自己的remote端服务器，进行版本控制。</p><p>需要注意的是<strong>不同平台的SSH key各不相同</strong>，所以为了能在各个平台上方便地使用git进行版本控制，就需要设置多个SSH key。</p><p><strong>使用SSH key的步骤</strong>：</p><ul><li>在客户端生成SSH key（密钥对：公钥-&gt;锁头和私钥-&gt;钥匙，利用了公钥和私钥实现数据加密和解密）</li><li>在服务端的配置文件中加入你的公钥。（比如我们需要再GitHub中粘贴你的公钥）</li></ul><p><strong>具体原理</strong>：用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回远程主机，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。</p><hr><p><br></p><h2 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h2><p>默认情况下，使用<code>ssh-keygen</code>生成会在<code>C:\Users\user\.ssh</code>目录下生成SSH key(<code>id_rsa</code>和<code>id_rsa.pub(公钥)</code>)，为了使生成了SSH key互不干扰，所以需要使用<code>-f</code>参数进行设置生成了SSH key名称，不然可能会覆盖。</p><p>在<strong>git bash</strong>中输入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/keyname(eg:github)</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/coding_pages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-t：指定要创建的密钥类型，默认是 rsa ，可以省略</span><br><span class="line">-C：添加注释，比如邮箱；</span><br><span class="line">-f：指定用来保存密钥的文件名；</span><br><span class="line">-b：指定密钥长度；</span><br><span class="line">-e：读取openssh的私钥或者公钥文件；</span><br><span class="line">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；</span><br><span class="line">-l：显示公钥文件的指纹数据；</span><br><span class="line">-N：提供一个新密语；</span><br><span class="line">-P：提供（旧）密语；</span><br><span class="line">-q：静默模式；</span><br></pre></td></tr></table></figure><p></p><p>上述命令输入后，会出现<strong>如下提示</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line"><span class="comment"># Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p></p><ul><li>可以不输入文件名，使用默认文件名（推荐），那么就会生成 github 和 github.pub 两个秘钥文件；</li><li>接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）；</li><li>也可以不输入密码，直接按回车，那么push的时候就不需要输入密码，直接提交到github上了；</li><li>将 github.pub 文件的内容添加到github上面的ssh key</li></ul><p>以上是生成一个的过程，生成另一个的过程也是相同的操作。</p><hr><p><br></p><h2 id="添加生成的SSH"><a href="#添加生成的SSH" class="headerlink" title="添加生成的SSH"></a>添加生成的SSH</h2><p>将上述得到的公钥(以<strong>pub结尾的文件</strong>内容复制到平台相应的ssh key添加部位)：</p><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/github_key.png"><br></div><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/coding_pages_key.png"><br></div><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在 <code>C:\Users\user\.ssh</code> 目录下新建一个config文件，并添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host 公司github的地址 如：github.com</span><br><span class="line">HostName 公司github的地址 如：github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host git.dev.tencent.com</span><br><span class="line">    HostName git.dev.tencent.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/coding_pages</span><br></pre></td></tr></table></figure><p>上述host地址的得到可以通过点击平台任意一个项目的<code>clone and download</code>看到，冒号<code>:</code>前面的就是host地址了</p><hr><p><br></p><h2 id="验证SSH-key是否添加成功"><a href="#验证SSH-key是否添加成功" class="headerlink" title="验证SSH key是否添加成功"></a>验证SSH key是否添加成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding pages</span></span><br><span class="line">ssh -T git@git.dev.tencent.com</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Hi showteeth! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><blockquote><p>Coding 提示: Hello showteeth, You’ve connected to Coding.net via SSH. This is a personal key.<br>showteeth，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</p></blockquote><p>到这里留完成了管理多个SSH公钥的步骤，接下来就可以不用输入密码地将代码托管到相应的平台上了!</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/3e57bb0f8185" target="_blank" rel="noopener">如何同时使用多个SSH公钥提交代码至不同平台</a></li><li><a href="https://blog.csdn.net/DBB_zifeng/article/details/71698865" target="_blank" rel="noopener">管理多个SSH公钥密钥</a></li><li><a href="https://www.jianshu.com/p/a869072a0092" target="_blank" rel="noopener">同一台电脑关于多个SSH KEY管理</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF转HTML-pdf2htmlex</title>
      <link href="/posts/40996.html"/>
      <url>/posts/40996.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。</p></div><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><p>由于电脑是windows系统，所以只能按照<a href="https://gist.github.com/cnstar9988/3571c66b49050d98df92142dc19fbb00" target="_blank" rel="noopener">这里</a>给定的教程进行安装，无奈尝试了很多次，最终都以失败告终，都有点想放弃使用这个工具了，但是后来尝试了其他工具如<a href="https://github.com/mgufrone/pdf-to-html" target="_blank" rel="noopener">pdf-to-html</a>，但是效果很差，出来的效果和原本的pdf差很多，所以还是放弃了。</p><p>最近忽然发现应该可以使用docker进行安装，所以尝试使用<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>，接下来就是安装和使用docker：</p><ul><li>注册docker账号然后下载</li><li>安装docker，这里注意如果电脑上安装了360会提示<strong>发现黑客新建用户帐号，建议阻止</strong>，鉴于360的一贯行为以及阻止后不能顺利安装，我选择了允许操作</li><li>安装完成之后会<strong>注销和重启电脑</strong>，这个按照提示操作即可</li><li>最后需要注意的是<strong>运行docker是在命令行形式下运行</strong>，而不是直接打开桌面的快捷方式</li></ul><hr><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>使用docker安装pdf2htmlex，可以参考<a href="https://github.com/BWITS/pdf2htmlEX_docker" target="_blank" rel="noopener">官方给出的教程</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><p>输入上述命令后<strong>发现错误</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> connection (Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span><br></pre></td></tr></table></figure><p></p><p>上网搜了一下，发现这个错误是因为网络原因导致无法拉取镜像，解决方法：<strong>使用国内的Docker仓库daocloud</strong>：</p><ul><li>进入<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daocloud关于docker加速器的网站</a>，找到<strong>配置 Docker 加速器</strong>下对应的操作系统，因为我使用的windows系统，所以选择windows系统下的<code>http://f1361db2.m.daocloud.io</code></li></ul><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/docker配置镜像2.png"><br></div><ul><li>将上述所得到的的地址写入<code>docker-&gt;setting-&gt;daemon-&gt;registry mirrors</code>中，然后<strong>apply</strong>，docker会提示<strong>restart</strong>：</li></ul><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/docker配置镜像.png"><br></div><ul><li>上述操作完成之后重新执行命令，发现下载速度飞快~~~</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="通过docker命令"><a href="#通过docker命令" class="headerlink" title="通过docker命令"></a>通过docker命令</h3><p>详细的使用参考<a href="https://github.com/coolwanglu/pdf2htmlEX/wiki/Quick-Start" target="_blank" rel="noopener">工具的github</a>，这里我只尝试较为简单的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX --zoom 1.8  resume.pdf</span><br></pre></td></tr></table></figure><p></p><p>用到的docker参数说明：</p><ul><li><code>-v</code>：挂载宿主机目录，~/pdf对应于C:\Users\user\pdf，/pdf的容器的目录，在容器启动后，容器内会自动创建/pdf目录，也就是冒号<code>:</code>前面的目录是宿主机目录，后面的目录是容器内目录。<strong>注意使用时docker会提示需要使用文件权限</strong>，如果宿主机目录放在C盘，还要输入电脑密码</li><li><code>--rm</code>：默认情况下，每个container在退出时，它的文件系统也会保存下来，该参数可以让docker在container结束时自动清理其所产生的数据</li><li><code>-ti</code>：以交互模式启动一个容器</li></ul><hr><h3 id="创建命令调用别名"><a href="#创建命令调用别名" class="headerlink" title="创建命令调用别名"></a>创建命令调用别名</h3><p>因为使用的docker安装，每次调用可能全长命令比较麻烦，所以这里使用alias创建命令别名-pdf2htmlEX：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己修改挂载目录</span></span><br><span class="line"><span class="built_in">alias</span> pdf2htmlEX=<span class="string">"docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX"</span></span><br></pre></td></tr></table></figure><p>这里一直没有成功不知道是为什么，总是显示<code>文件名、目录名或卷标语法不正确。</code>，但我直接使用命令不使用alias的方式却能正常使用，所以就没有继续使用这个</p><blockquote><p>系统自带的cmd是不支持alias的，我这里使用的是<a href="https://cmder.net/" target="_blank" rel="noopener">cmder</a>，很强大的命令行工具，关于如何在windows下配置这个工具，可以参考博客中关于配置cmder的文章</p></blockquote><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pdf2htmlex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coding_pages和mkdocs使用</title>
      <link href="/posts/54578.html"/>
      <url>/posts/54578.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>coding pages和mkdocs使用简介</p></div><a id="more"></a><h2 id="注册coding-pages"><a href="#注册coding-pages" class="headerlink" title="注册coding pages"></a>注册coding pages</h2><ul><li>前往其<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>，常规的注册方法即可</li><li>关于会员：<ul><li><a href="https://feedback.coding.net/topics/7257" target="_blank" rel="noopener">免费升级</a>好像</li><li>升级之前不可以创建项目，如果有项目需要转让或者删除，具体操作步骤<a href="https://dev.tencent.com/help/doc/account/up-to-tencent#CODING-3" target="_blank" rel="noopener">参考文章</a></li></ul></li></ul><hr><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>填写项目标识，项目标识在最后创建完pages之后就会显示为username.coding.me/项目标识/</li><li>项目名称填写：username.coding.me，相当于 github 上面的 name.github.io</li><li>创建完成即进入项目，选择代码下的代码浏览，创建<code>index.html</code>页面(注意名字一定要叫 <code>index.html</code>)，随意写一段话：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Coding Pages<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Coding!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>然后点击左侧<strong>代码</strong>下的 <strong>Pages 服务</strong>，选择<strong>静态 Pages 服务</strong>，一键创建pages</li><li>静态 Coding Pages 允许的部署分支来源为master 分支和coding-pages 分支，默认部署来源是master 分支，用户可在设置(右上角)里更改部署来源（实测发现只有master分支）。部署成功后后可通过<code>&lt;user_name&gt;.coding.me／&lt;project_name&gt;</code>形式的 URL 访问静态 Pages</li><li>如果需要自定义域名，这个也在pages服务中的设置(右上角)中进行设置</li></ul><hr><p><br></p><h2 id="结合mkdocs"><a href="#结合mkdocs" class="headerlink" title="结合mkdocs"></a>结合mkdocs</h2><h3 id="安装相关packages"><a href="#安装相关packages" class="headerlink" title="安装相关packages"></a>安装相关packages</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装mkdocs</span></span><br><span class="line">pip install mkdocs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure><hr><h3 id="常规用法："><a href="#常规用法：" class="headerlink" title="常规用法："></a>常规用法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">mkdocs new my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动内建服务器</span></span><br><span class="line">mkdocs serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点生成，创建了一个 site 新目录</span></span><br><span class="line">mkdocs build</span><br></pre></td></tr></table></figure><hr><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主题和头像</span></span><br><span class="line">theme:</span><br><span class="line">  name: material</span><br><span class="line">  favicon: <span class="string">'/dark_logo_16x16.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加页面</span></span><br><span class="line">nav:</span><br><span class="line">- 主页 : index.md</span><br><span class="line">- 软件 : about.md</span><br><span class="line">- 项目 : about.md</span><br><span class="line">- 关于 : about.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持中文搜索，虽然search功能(lunr.js)暂不直接支持中文，但测试发现设置为日语后，中文和英文搜索都可以使用</span></span><br><span class="line">extra:</span><br><span class="line">  search:</span><br><span class="line">    language: <span class="string">'jp'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加扩展</span></span><br><span class="line">markdown_extensions:</span><br><span class="line">  - admonition</span><br><span class="line">  - codehilite:</span><br><span class="line">      guess_lang: <span class="literal">false</span></span><br><span class="line">      linenums: <span class="literal">false</span></span><br><span class="line">  ......</span><br><span class="line"><span class="comment"># 自定义的CSS和JS</span></span><br><span class="line">extra_javascript:</span><br><span class="line">  - <span class="string">'js/extra.js'</span></span><br><span class="line">  - <span class="string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'</span></span><br><span class="line"></span><br><span class="line">extra_css:</span><br><span class="line">  - <span class="string">'css/extra.css'</span></span><br></pre></td></tr></table></figure><hr><h3 id="上传到coding-pages"><a href="#上传到coding-pages" class="headerlink" title="上传到coding pages"></a>上传到coding pages</h3><ul><li>将coding pages项目clone到本地：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里本想使用ssh的链接，但是失败，提示repo不存在，但是使用https的却可以成功，需要再看看问题</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.dev.tencent.com/showteeth/project.git bio_projects</span><br></pre></td></tr></table></figure><ul><li>将原本mkdoc目录下的文件拷进这个目录</li><li><p>部署到coding pages，详细参考<a href="https://www.mkdocs.org/user-guide/deploying-your-docs/" target="_blank" rel="noopener">官方教程</a></p><ul><li>自动将相应内容推送到项目的 master 分支上，默认会部署在 gh-pages 分支上，而我的账户好像只能部署在master分支上，所以只能修改分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdocs gh-deploy -b master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>输入链接即可访问</p></li></ul><p>最后吐槽一句：coding pages真的好慢好慢！！！！</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.mkdocs.org/" target="_blank" rel="noopener">mkdocs的官方网站</a></li><li><a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs的github</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">mkdocs主题material的相关材料（拓展、代码高亮）</a></li><li><a href="https://docs.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">readthedocs的官方网站（介绍的比较简答，具体实施还是需要看mkdocs的网站说明）</a></li><li><a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs托管文档</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/syntax/note_style/" target="_blank" rel="noopener">支持的markdown语法</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">基于mkdocs-material搭建个人静态博客(含支持的markdown语法)</a></li><li><a href="https://docs.flc.io/more/github-travis-mkdocs-document/" target="_blank" rel="noopener">使用mkdocs搭建的文档库</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter主题、插件、技巧、server搭建</title>
      <link href="/posts/13473.html"/>
      <url>/posts/13473.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>针对默认的jupyter notebook的<strong>页面进行修改</strong>、<strong>增加一些插件</strong>使jupyter的使用更加方便，整理一些jupyter<strong>使用技巧</strong>，最后是关于<strong>搭建jupyter server</strong>的内容，记录了自己<strong>搭建jupyterhub</strong>的过程的遇到<strong>问题的解决办法</strong>。</p></div><a id="more"></a><h2 id="jupyter默认页面的修改"><a href="#jupyter默认页面的修改" class="headerlink" title="jupyter默认页面的修改"></a>jupyter默认页面的修改</h2><p>jupyter默认页面的修改主要是使用<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyter-themes</a>包。</p><h3 id="jupyter-themes安装"><a href="#jupyter-themes安装" class="headerlink" title="jupyter-themes安装"></a>jupyter-themes安装</h3><p>常规的<code>pip</code>安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install jupyterthemes</span></span><br><span class="line">pip install jupyterthemes</span><br><span class="line"></span><br><span class="line"><span class="comment"># upgrade to latest version</span></span><br><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure><ul><li>为了达到最好的效果，建议notebook的版本是<code>&gt;=5.6.0</code>，如果低于此版本可以使用<code>pip install --upgrade notebook</code>进行升级</li><li>refreshing / removing / resetting：如果想要恢复默认值或者使新采用的主题生效，可能需要清除浏览器缓存（不一定非要进行，看自己的浏览器和系统，真遇到情况可以参考<a href="https://github.com/dunovank/jupyter-themes/issues/86" target="_blank" rel="noopener">issue</a>）；进行上述操作后刷新浏览器肯定是要刷新浏览器的！</li><li>安装或其他问题直接上<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">github</a>找答案！</li></ul><hr><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p><strong>命令行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jt  [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">    [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">    [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim]</span><br><span class="line">    [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout]</span><br><span class="line">    [-P] [-T] [-N] [-r] [-dfonts]</span><br></pre></td></tr></table></figure><p><strong>具体的参数说明</strong>：</p><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:10%}table th:nth-of-type(3){width:75%}</style><table><thead><tr><th>cl options</th><th>arg</th><th>default</th></tr></thead><tbody><tr><td>Usage help</td><td>-h</td><td>–</td></tr><tr><td>List Themes</td><td>-l</td><td>–</td></tr><tr><td>Theme Name to Install</td><td>-t</td><td>–</td></tr><tr><td>Code Font</td><td>-f</td><td>–</td></tr><tr><td>Code Font-Size</td><td>-fs</td><td>11</td></tr><tr><td>Notebook Font</td><td>-nf</td><td>–</td></tr><tr><td>Notebook Font Size</td><td>-nfs</td><td>13</td></tr><tr><td>Text/MD Cell Font</td><td>-tf</td><td>–</td></tr><tr><td>Text/MD Cell Fontsize</td><td>-tfs</td><td>13</td></tr><tr><td>Pandas DF Fontsize</td><td>-dfs</td><td>9</td></tr><tr><td>Output Area Fontsize</td><td>-ofs</td><td>8.5</td></tr><tr><td>Mathjax Fontsize (%)</td><td>-mathfs</td><td>100</td></tr><tr><td>Intro Page Margins</td><td>-m</td><td>auto</td></tr><tr><td>Cell Width</td><td>-cellw</td><td>980</td></tr><tr><td>Line Height</td><td>-lineh</td><td>170</td></tr><tr><td>Cursor Width</td><td>-cursw</td><td>2</td></tr><tr><td>Cursor Color</td><td>-cursc</td><td>–</td></tr><tr><td>Alt Prompt Layout</td><td>-altp</td><td>–</td></tr><tr><td>Alt Markdown BG Color</td><td>-altmd</td><td>–</td></tr><tr><td>Alt Output BG Color</td><td>-altout</td><td>–</td></tr><tr><td>Style Vim NBExt*</td><td>-vim</td><td>–</td></tr><tr><td>Toolbar Visible</td><td>-T</td><td>–</td></tr><tr><td>Name &amp; Logo Visible</td><td>-N</td><td>–</td></tr><tr><td>Kernel Logo Visible</td><td>-kl</td><td>–</td></tr><tr><td>Reset Default Theme</td><td>-r</td><td>–</td></tr><tr><td>Force Default Fonts</td><td>-dfonts</td><td>–</td></tr></tbody></table><p>github上有具体的示例用法，建议大家去看看，我这里挑选我最喜欢的配置如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t monokai -f firacode -fs 12 -cellw 70% -ofs 10 -dfs 11 -T -N -altp -lineh 140</span><br></pre></td></tr></table></figure><p></p><ul><li>上述命令是在cmd中输入进行配置，而不是在jupyter notebook中</li><li>-fs：字体大小</li><li>-ofs：输出字体大小</li><li>-dfs：pandas dataframe字体大小</li><li>-cellw：主体宽度</li><li>-T：显示导航栏</li><li>-N：显示文件名称</li><li>-altp：不显示格子左上角的number</li><li>-lineh：行高</li></ul><p>设置完成之后发现<strong>jupyter的logo没有完全显示出来</strong>，同时<strong>文件名称也只显示了一部分</strong>，这些需要修改，找到<code>C:\Users\username\.jupyter\custom</code>目录下的<code>custom.css</code>进行修改:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将none改为block来显示jupyter的logo --&gt;</span></span><br><span class="line">div#ipython_notebook &#123;</span><br><span class="line"> display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将height: initial修改为20px，这个可以自己设置 --&gt;</span></span><br><span class="line">span.save_widget span.filename &#123;</span><br><span class="line"> margin-left: 8px;</span><br><span class="line"> height: 22px;</span><br><span class="line"> font-size: 100%;</span><br><span class="line"> color: #a6e22e;</span><br><span class="line"> background-color: #282828;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述修改每次重新修改主题相关配置后都需要重新修改</p><p>修改绘图配置：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jupyterthemes <span class="keyword">import</span> jtplot</span><br><span class="line">jtplot.style(theme=<span class="string">'grade3'</span>,ticks=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>主要使用的包是<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">jupyter_contrib_nbextensions</a>，这是一个非常强大的包，里面包含了很多在jupyter notebook只很常用的插件，包括代码段、显示目录等等等，同时这个包还提供了一个链接：<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">A collection of various notebook extensions for Jupyter</a>，里面总结了可以用在jupyter notebook中的插件。</p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install the python package</span></span><br><span class="line"><span class="comment">## 这个安装经常失败，下载速度太慢了</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment">## 换用这个了</span></span><br><span class="line">pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install javascript and css files</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>上述两步安装完成之后就可以在<code>jupyter</code>的<code>home page</code>看到如下的插件：</p><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/jupyter插件.png"><br></div><h3 id="选取插件安装"><a href="#选取插件安装" class="headerlink" title="选取插件安装"></a>选取插件安装</h3><h4 id="Code-prettify-代码美化"><a href="#Code-prettify-代码美化" class="headerlink" title="Code prettify-代码美化"></a>Code prettify-代码美化</h4><p>插件的快捷键：ctrl + l进行单个cell的prettify（也可以在选中cell时直接点击导航栏的小锤子按钮）、Ctrl-Shift-L进行所有的的prettify<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个插件安装后提示yapf没有安装</span></span><br><span class="line">pip install yapf</span><br></pre></td></tr></table></figure><p></p><p>After checking “Snippets Menu” in Configurable nbextensions, Snippets did’t appear in</p><h4 id="Collapsible-headings-折叠标题"><a href="#Collapsible-headings-折叠标题" class="headerlink" title="Collapsible headings-折叠标题"></a>Collapsible headings-折叠标题</h4><h4 id="Snippets-自定义代码片段"><a href="#Snippets-自定义代码片段" class="headerlink" title="Snippets-自定义代码片段"></a>Snippets-自定义代码片段</h4><p>修改<code>C:\Users\user\AppData\Roaming\jupyter\nbextensions\snippets\snippets.json</code>来添加新的代码段，注意是上面的地址，<strong>而不是anaconda目录下的文件，如果修改了anaconda下的文件不起作用</strong>。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "name" : "common_use",</span><br><span class="line">    "code" : [</span><br><span class="line">        "import os",</span><br><span class="line">        "import sys",</span><br><span class="line">        "import numpy as np",</span><br><span class="line">        "import pandas as pd"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编辑完成之后想要<strong>生效</strong>需要<strong>重启jupyter notebook</strong></p><h4 id="Table-of-Contents-2-显示目录结构"><a href="#Table-of-Contents-2-显示目录结构" class="headerlink" title="Table of Contents (2)-显示目录结构"></a>Table of Contents (2)-显示目录结构</h4><p>这个和上面的jupyter-themes好像要有些冲突，导航栏遮挡部分的目录结构，现在还不知道有没有什么解决办法， 可以取舍一下</p><h4 id="Highlight-selected-word-高亮代码中与选中部分相同的"><a href="#Highlight-selected-word-高亮代码中与选中部分相同的" class="headerlink" title="Highlight selected word-高亮代码中与选中部分相同的"></a>Highlight selected word-高亮代码中与选中部分相同的</h4><h4 id="highlighter-高亮选中的文本"><a href="#highlighter-高亮选中的文本" class="headerlink" title="highlighter-高亮选中的文本"></a>highlighter-高亮选中的文本</h4><h4 id="ExecuteTime-显示每个cell的运行时间"><a href="#ExecuteTime-显示每个cell的运行时间" class="headerlink" title="ExecuteTime-显示每个cell的运行时间"></a>ExecuteTime-显示每个cell的运行时间</h4><h4 id="table-beautifier-让输出的table更好看"><a href="#table-beautifier-让输出的table更好看" class="headerlink" title="table_beautifier-让输出的table更好看"></a>table_beautifier-让输出的table更好看</h4><h4 id="Snippets-Menu-和snippet类似，但是没有正常工作，需要看看为什么？？？"><a href="#Snippets-Menu-和snippet类似，但是没有正常工作，需要看看为什么？？？" class="headerlink" title="Snippets Menu-和snippet类似，但是没有正常工作，需要看看为什么？？？"></a>Snippets Menu-和snippet类似，但是<mark>没有正常工作，需要看看为什么？？？</mark></h4><h4 id="Hinterland-自动补全代码"><a href="#Hinterland-自动补全代码" class="headerlink" title="Hinterland-自动补全代码"></a>Hinterland-自动补全代码</h4><h4 id="Split-Cells-Notebook-拆分单元格"><a href="#Split-Cells-Notebook-拆分单元格" class="headerlink" title="Split Cells Notebook-拆分单元格"></a>Split Cells Notebook-拆分单元格</h4><p>可以将单元格拆分为一半，然后将下一个单元格进行同样的操作，两个一半的单元格会在同一行显示，这对于一些试探性的工作会比较有用。</p><h4 id="Move-selected-cells"><a href="#Move-selected-cells" class="headerlink" title="Move selected cells"></a>Move selected cells</h4><p>同时移动多个选定的cell，选定cell可以使用<code>Shift-up/Shift-down or Shift-K/Shift-J</code>；也可以使用<code>rubberband</code>，这个也是一个插件</p><h4 id="快速选取多个cell"><a href="#快速选取多个cell" class="headerlink" title="快速选取多个cell"></a>快速选取多个cell</h4><p>可以结合前面的<code>Move selected cells</code>插件使用，使用shift+鼠标左边选取范围内的cells。</p><p><strong>最后的插件配置结果</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/nbextension.png" alt="nbextension.png"></p><hr><p><br></p><h2 id="jupyter-使用技巧"><a href="#jupyter-使用技巧" class="headerlink" title="jupyter 使用技巧"></a>jupyter 使用技巧</h2><ul><li><a href="https://www.jianshu.com/p/a85bc2a8fa56" target="_blank" rel="noopener">多行输出</a></li><li><a href="https://zhuanlan.zhihu.com/p/32600329" target="_blank" rel="noopener">关于Jupyter Notebook的28个技巧(快捷键、Magic命令等)</a><hr></li></ul><p><br></p><h2 id="jupyter-server搭建"><a href="#jupyter-server搭建" class="headerlink" title="jupyter server搭建"></a>jupyter server搭建</h2><p>后来发现jupyter的server是为<strong>单人创建的server</strong>，有一个专门的为<strong>多个用户</strong>使用jupyter server的程序叫<code>jupyterhub</code>，这里主要记录配置<a href="https://github.com/jupyterhub/jupyterhub" target="_blank" rel="noopener">jupyterhub</a>的过程。</p><h3 id="关于jupyter的server搭建教程"><a href="#关于jupyter的server搭建教程" class="headerlink" title="关于jupyter的server搭建教程"></a>关于jupyter的server搭建教程</h3><ul><li><a href="https://suixinblog.cn/2019/02/jupyter-notebook.html" target="_blank" rel="noopener">在服务器部署Jupyter Notebook</a></li><li><a href="https://www.cnblogs.com/andylhc/p/9513504.html" target="_blank" rel="noopener">远程使用jupyter</a></li><li><a href="https://blog.csdn.net/qq_18293213/article/details/72910834" target="_blank" rel="noopener">在服务器上配置jupyter, 远程登录</a></li></ul><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p><strong>使用conda安装</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge jupyterhub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现错误</span></span><br><span class="line">WARNING: The conda.compat module is deprecated and will be removed <span class="keyword">in</span> a future release.</span><br><span class="line">Collecting package metadata: failed</span><br><span class="line"></span><br><span class="line">UnavailableInvalidChannel: The channel is not accessible or is invalid.</span><br><span class="line">  channel name: conda-forge</span><br><span class="line">  channel url: https://conda.anaconda.org/conda-forge</span><br><span class="line">  error code: 403</span><br><span class="line"></span><br><span class="line">You will need to adjust your conda configuration to proceed.</span><br><span class="line">Use `conda config --show channels` to view your configuration<span class="string">'s current state,</span></span><br><span class="line"><span class="string">and use `conda config --show-sources` to view config file locations.</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用npm和pip进行安装</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install -g configurable-http-proxy</span><br><span class="line">python3 -m pip install jupyterhub   </span><br><span class="line"><span class="comment"># pip安装报错</span></span><br><span class="line">  pip is configured with locations that require TLS/SSL, however the ssl module <span class="keyword">in</span> Python is not available.</span><br><span class="line">  Collecting jupyterhub</span><br><span class="line">    Could not fetch URL https://pypi.python.org/simple/jupyterhub/: There was a problem confirming the ssl certificate: Can<span class="string">'t connect to HTTPS URL because the SSL module is not available. - skipping</span></span><br><span class="line"><span class="string">    Could not find a version that satisfies the requirement jupyterhub (from versions: )</span></span><br><span class="line"><span class="string">  No matching distribution found for jupyterhub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 直接卸载了原本安装的miniconda，重新安装了anaconda3</span></span><br><span class="line"><span class="string"># 就解决了问题</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><h4 id="创建jupyterhub配置文件夹"><a href="#创建jupyterhub配置文件夹" class="headerlink" title="创建jupyterhub配置文件夹"></a>创建jupyterhub配置文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/jupyterhub &amp;&amp; <span class="built_in">cd</span> /etc/jupyterhub</span><br></pre></td></tr></table></figure><hr><h4 id="在上述文件夹下生成配置文件"><a href="#在上述文件夹下生成配置文件" class="headerlink" title="在上述文件夹下生成配置文件"></a>在上述文件夹下生成配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jupyterhub --generate-config</span><br><span class="line">  <span class="comment"># 输出信息</span></span><br><span class="line">  Writing default config to: jupyterhub_config.py</span><br></pre></td></tr></table></figure><hr><h4 id="生成自签名的-SSL-证书"><a href="#生成自签名的-SSL-证书" class="headerlink" title="生成自签名的 SSL 证书"></a>生成自签名的 SSL 证书</h4><p>这是<strong>可选的</strong>一步，用于<code>enable HTTPS</code>，设置之后<strong>必须使用https才能访问</strong>，不然会出现下面提到的<code>ERR_EMPTY_RESPONSE</code>错误：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mykey.key -out mycert.pem</span><br><span class="line"><span class="comment"># 在目录下生成mykey.key、mycert.pem文件</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/04/10/5cadffade8219.png" alt="20190410223727.png"></p><hr><h4 id="配置启动-jupyterlab"><a href="#配置启动-jupyterlab" class="headerlink" title="配置启动 jupyterlab"></a>配置启动 jupyterlab</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip</span></span><br><span class="line">c.JupyterHub.ip = <span class="string">'192.168.1.231'</span></span><br><span class="line">c.JupyterHub.port = 8000</span><br><span class="line">c.PAMAuthenticator.encoding = <span class="string">'utf-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is an application.</span></span><br><span class="line"><span class="comment"># create system users that don't exist yet</span></span><br><span class="line">c.LocalAuthenticator.create_system_users = True</span><br><span class="line">c.Authenticator.whitelist = <span class="built_in">set</span>(os.listdir(<span class="string">'/home'</span>))</span><br><span class="line">c.Authenticator.admin_users = &#123;<span class="string">'user'</span>&#125;</span><br><span class="line"><span class="comment"># 设置笔记本从登陆用户的home目录</span></span><br><span class="line">c.Spawner.notebook_dir = <span class="string">'/'</span></span><br><span class="line">c.Spawner.default_url = <span class="string">'/tree/home/&#123;username&#125;'</span></span><br><span class="line"><span class="comment"># 如果设置之后必须使用https才能访问，不然会出错</span></span><br><span class="line"><span class="comment"># c.JupyterHub.ssl_cert = '/etc/jupyterhub/mycert.pem'</span></span><br><span class="line"><span class="comment"># c.JupyterHub.ssl_key = '/etc/jupyterhub/mykey.key'</span></span><br><span class="line">c.JupyterHub.cookie_secret_file = <span class="string">'/etc/jupyterhub/jupyterhub_cookie_secret'</span></span><br><span class="line">c.ConfigurableHTTPProxy.command = [<span class="string">'/usr/bin/configurable-http-proxy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次打开session不用重新登录</span></span><br><span class="line"><span class="comment"># 参考链接：https://github.com/jupyterhub/jupyterhub/issues/323</span></span><br><span class="line">c.PAMAuthenticator.open_sessions = False</span><br></pre></td></tr></table></figure><p>运行jupyterhub：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyterhub -f /etc/jupyterhub/jupyterhub_config.py</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="设置外网映射"><a href="#设置外网映射" class="headerlink" title="设置外网映射"></a>设置外网映射</h4><p>上面设置的ip地址为<code>192.168.1.231</code>是内网地址，为了能够在外网(不使用实验室的网络)使用，需要<strong>通过路由器进行外网映射</strong></p><hr><h3 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h3><h4 id="Error-adding-user-manasrk-already-in-db"><a href="#Error-adding-user-manasrk-already-in-db" class="headerlink" title="Error adding user manasrk already in db"></a>Error adding user manasrk already in db</h4><p><strong>删掉jupyterhub.sqlite</strong>即可，<a href="https://serverfault.com/questions/794938/jupyterhub-error-on-start-keyerror-user-k-does-not-exist" target="_blank" rel="noopener">参考1</a>、<a href="https://github.com/jupyterhub/jupyterhub/issues/687" target="_blank" rel="noopener">参考2</a></p><div class="note info"><p>注意：jupyterhub_cookie_secret和jupyterhub.sqlite会在安装jupyterlab的目录下，所以尽量在/etc/jupyterhub下进行安装，以免需要重新移动</p></div><hr><h4 id="ERR-EMPTY-RESPONSE"><a href="#ERR-EMPTY-RESPONSE" class="headerlink" title="ERR_EMPTY_RESPONSE"></a>ERR_EMPTY_RESPONSE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">该网页无法正常运作   </span><br><span class="line">192.168.1.231 未发送任何数据。  </span><br><span class="line">ERR_EMPTY_RESPONSE</span><br></pre></td></tr></table></figure><p><a href="https://github.com/jupyterhub/jupyterhub/issues/694" target="_blank" rel="noopener">解决办法</a>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect to https://127.0.0.1:8000, not http://127.0.0.1:8000</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="IOPub-data-rate-exceeded"><a href="#IOPub-data-rate-exceeded" class="headerlink" title="IOPub data rate exceeded"></a>IOPub data rate exceeded</h4><p>在对大文件进行处理中很容易出现这个问题：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IOPub data rate exceeded.</span><br><span class="line">The notebook server will temporarily stop sending output</span><br><span class="line">to the client <span class="keyword">in</span> order to avoid crashing it.</span><br><span class="line">To change this <span class="built_in">limit</span>, <span class="built_in">set</span> the config variable</span><br><span class="line">`--NotebookApp.iopub_data_rate_limit`.</span><br><span class="line"></span><br><span class="line">Current values:</span><br><span class="line">NotebookApp.iopub_data_rate_limit=1000000.0 (bytes/sec)</span><br><span class="line">NotebookApp.rate_limit_window=3.0 (secs)</span><br></pre></td></tr></table></figure><p></p><p><strong>解决方法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行如下设置即可解决</span></span><br><span class="line">c.Spawner.args = [<span class="string">'--NotebookApp.iopub_data_rate_limit=1000000000'</span>]</span><br></pre></td></tr></table></figure><p></p><p>参考链接：<a href="https://github.com/jupyterhub/jupyterhub/issues/1152" target="_blank" rel="noopener">IOPub limits setting to jupyterhub</a></p><hr><h3 id="安装不同的内核"><a href="#安装不同的内核" class="headerlink" title="安装不同的内核"></a>安装不同的内核</h3><h4 id="R内核"><a href="#R内核" class="headerlink" title="R内核"></a>R内核</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install -c r r-irkernel</span><br><span class="line"></span><br><span class="line">IRkernel::installspec()</span><br></pre></td></tr></table></figure><h4 id="python2内核"><a href="#python2内核" class="headerlink" title="python2内核"></a>python2内核</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">conda create -n py27 python=2.7</span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line">conda activate py27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将kernel安装在指定的目录</span></span><br><span class="line"><span class="comment"># /path/to/python3 -m IPython kernel install --prefix=/usr/local</span></span><br><span class="line">python -m IPython kernel install --prefix=/usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><div class="note info"><p>必须要加上<code>--prefix=/usr/local</code>安装，这样最后的kernel安装在<code>/usr/local/share/jupyter/kernels/python2</code>，而默认的<code>pip install ipykernel</code>安装在<code>/root/.local/share/jupyter/kernels/python2</code>，这种情况不会加载这个kernel，<strong>这和jupyter不同</strong>，<strong>具体的jupyterhub自己的设定</strong>需要查看<a href="https://jupyterhub.readthedocs.io/en/stable/reference/config-user-env.html?highlight=kernels#configuring-user-environments" target="_blank" rel="noopener">这个链接</a></p></div><p><strong>查看所有已有的内核</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec list</span><br><span class="line">  Available kernels:</span><br><span class="line">    ir         /home/softwares/anaconda3/share/jupyter/kernels/ir</span><br><span class="line">    python3    /home/softwares/anaconda3/share/jupyter/kernels/python3</span><br><span class="line">    python2    /usr/<span class="built_in">local</span>/share/jupyter/kernels/python2</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://jupyterhub.readthedocs.io/en/stable/" target="_blank" rel="noopener">jupyterhub官方文档</a></li><li><a href="https://github.com/jupyterhub/jupyterhub/" target="_blank" rel="noopener">jupyterhub的github</a></li></ul><hr><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML中的实体空格与markdown空格缩进</title>
      <link href="/posts/58681.html"/>
      <url>/posts/58681.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了HTML中的6种实体空格以及在实际markdown写作中会涉及到的空格缩进应该使用哪种空格实体会比较好，最后发现使用<code>&amp;emsp;</code>-全角空格在中文markdown写作中是最合适的</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在markdown写作过程中，我们可能需要再文本中插入一些空格，比如中文的首行缩进，与word文档写作直接使用space键空两格即可出现空格不同，markdown不会识别这种空格(四个空格会代表代码块)，为了达到插入空格的效果就需要使用<strong>HTML中的空格实体</strong></p><hr><h2 id="HTML中的实体空格"><a href="#HTML中的实体空格" class="headerlink" title="HTML中的实体空格"></a>HTML中的实体空格</h2><p>HTML提供了6种空格实体（space entity），它们拥有不同的宽度，<strong>非断行空格（<code>&amp;nbsp;</code>）是常规空格的宽度，可运行于所有主流浏览器</strong>。其他几种空格（<code>&amp;ensp;</code>、<code>&amp;emsp;</code>、<code>&amp;thinsp;</code>、<code>&amp;zwnj;</code>、<code>&amp;zwj;</code>）在<strong>不同浏览器中宽度各异</strong></p><h3 id="amp-nbsp-不换行空格"><a href="#amp-nbsp-不换行空格" class="headerlink" title="&amp;nbsp;-不换行空格"></a><code>&amp;nbsp;</code>-不换行空格</h3><p>&emsp;&emsp;它叫不换行空格，全称是 <strong>No-Break Space</strong>，它是最常见和我们<em>使用最多</em>的空格，大多数的人可能只接触了<code>&amp;nbsp;</code>，它是<strong>按下space键产生的空格，一般两个<code>&amp;nbsp;</code>对应于一个中文字符</strong>。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个），要使用html实体表示才可累加，<strong>该空格占据宽度受字体影响明显而强烈</strong>。</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不同的！</p><hr><h3 id="amp-ensp-半角空格"><a href="#amp-ensp-半角空格" class="headerlink" title="&amp;ensp;-半角空格"></a><code>&amp;ensp;</code>-半角空格</h3><p>&emsp;&emsp;它叫<strong>半角空格</strong>，全称是 <strong>En Space</strong>，<code>en</code>是字体排印学的计量单位，为<code>em</code>宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母<code>n</code>的宽度。此空格传承空格家族一贯的特性：透明的，<strong>此空格有个相当稳健的特性，就是其占据的宽度正好是<u>1/2个中文宽度</u>，而且<mark>基本上不受字体影响</mark></strong></p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不变的，并且两格空格占据一个字体大小！</p><hr><h3 id="amp-emsp-全角空格"><a href="#amp-emsp-全角空格" class="headerlink" title="&amp;emsp;-全角空格"></a><code>&amp;emsp;</code>-全角空格</h3><p>&emsp;&emsp;它叫<strong>全角空格</strong>，全称是 <strong>Em Space</strong>，<code>em</code>是字体排印学的计量单位，相当于当前指定的点数。例如，<code>1 em</code>在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，<strong>此空格也有个相当稳健的特性，就是其占据的宽度正好是<u>1个中文宽度</u>，而且<mark>基本上不受字体影响</mark></strong>，和上面的<code>&amp;ensp;</code>-半角空格特性相同，但是是一个中文宽度</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不变的，并且两格空格占据两个字体大小！</p><hr><h3 id="amp-thinsp-窄空格"><a href="#amp-thinsp-窄空格" class="headerlink" title="&amp;thinsp;-窄空格"></a><code>&amp;thinsp;</code>-窄空格</h3><p>&emsp;&emsp;它叫<strong>窄空格</strong>，全称是 <strong>Thin Space</strong>。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是<code>em</code>之六分之一宽(前面的<code>&amp;ensp;</code>-半角空格是<code>em</code>宽度的一半，<code>&amp;emsp;</code>-全角空格就是<code>em</code>宽度)</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&emsp;字体，前面有一个<code>&amp;emsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;字体，前面有六个<code>&amp;thinsp;</code>空格</font></li></ul><hr><h3 id="amp-zwnj-零宽不连字"><a href="#amp-zwnj-零宽不连字" class="headerlink" title="&amp;zwnj;-零宽不连字"></a><code>&amp;zwnj;</code>-零宽不连字</h3><p>&emsp;&emsp;它叫<strong>零宽不连字</strong>，全称是 <strong>Zero Width Non Joiner</strong>，简称“ZWNJ”，是一个<strong>不打印字符</strong>，放在<strong>电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制</strong>。<em>Unicode</em>中的零宽不连字<strong>字符映射为</strong>（zero width non-joiner，<code>U+200C</code>），HTML<strong>字符值引用</strong>为<code>&amp;#8204</code></p><h3 id="amp-zwj-零宽连字"><a href="#amp-zwj-零宽连字" class="headerlink" title="&amp;zwj;-零宽连字"></a><code>&amp;zwj;</code>-零宽连字</h3><p>&emsp;&emsp;它叫<strong>零宽连字</strong>，全称是 <strong>Zero Width Joiner</strong>，简称“ZWJ”，是一个<strong>不打印字符</strong>，放在某些需要<strong>复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果</strong>。零宽连字符的Unicode码位是<code>U+200D</code> (HTML:<code>&amp;#8205;</code>、<code>&amp;zwj;</code>）。</p><p>此外，<strong>浏览器还会把以下字符当作空白进行解析</strong>：空格<code>&amp;#x0020;</code>、制表位<code>&amp;#x0009;</code>、换行<code>&amp;#x000A;</code>、回车<code>&amp;#x000D;</code>和<code>&amp;#12288;</code>等等。</p><hr><h2 id="markdowm首行缩进方法"><a href="#markdowm首行缩进方法" class="headerlink" title="markdowm首行缩进方法"></a>markdowm首行缩进方法</h2><p>通过上述对HTML中实体空格的介绍，可以总结出以下几种可以用在markdown中充当首行缩进的方法：</p><ul><li>使用<code>&amp;emsp;</code>-全角空格，优点：占据的宽度正好是<u>1个中文宽度</u>，而且<strong>基本上不受字体影响</strong>，<strong>推荐使用这个进行首行缩进</strong></li><li>使用<code>&amp;ensp;</code>-半角空格，优点：占据的宽度正好是<u>1/2个中文宽度</u>，需要使用两格才能达到缩进效果，而且<strong>基本上不受字体影响</strong></li><li>使用<code>&amp;nbsp;</code>-不换行空格，缺点：<u>需要使用四个来代表两个中文字符</u>，并且<strong>受字体影响较大</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/31eade263e7a" target="_blank" rel="noopener">markdown空格缩进以及HTML空格实体</a></li><li><a href="https://blog.csdn.net/testcs_dn/article/details/78957685" target="_blank" rel="noopener">markdown编辑器中可以使用的6种空格标记</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结|位、字节、字符和编码</title>
      <link href="/posts/56690.html"/>
      <url>/posts/56690.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要讲解了编码、字符、字节、位的概念，以及不同编码情况下字节与字符的对应关系，主要包括<code>ASCII码</code>、<code>UTF-8编码</code>、<code>Unicode编码</code>、<code>UTF-16编码</code>和<code>UTF-32编码</code>。</p></div><a id="more"></a><h2 id="编码问题的由来，相关概念的理解"><a href="#编码问题的由来，相关概念的理解" class="headerlink" title="编码问题的由来，相关概念的理解"></a>编码问题的由来，相关概念的理解</h2><h3 id="字符与编码的发展"><a href="#字符与编码的发展" class="headerlink" title="字符与编码的发展"></a>字符与编码的发展</h3><p>从计算机对多国语言的支持角度看，大致可以分为三个阶段：<br><table><tr><th width="10%">　</th><th width="10%">系统内码</th><th width="60%">说明</th><th width="20%">系统</th></tr><tr><td>阶段一</td><td>ASCII</td><td>计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。</td><td>英文 DOS</td></tr><tr><td>阶段二</td><td>ANSI编码（本地化）</td><td>为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 <strong>2 个字节来表示 1 个字符</strong>。比如：汉字 '中' 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些 <strong>使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码</strong>。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。<strong>不同 ANSI 编码之间 互不兼容 </strong>，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 <strong>ANSI 编码</strong>的文本中。</td><td>中文 DOS，中文 Windows 95/98，日文 Windows 95/98</td></tr><tr><td>阶段三</td><td>UNICODE（国际化）</td><td>为了使国际间信息交流更加方便，国际组织制定了 <strong>UNICODE 字符集</strong>，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。</td><td>Windows NT/2000/XP，Linux，Java</td></tr></table></p><p>字符串在内存中的存放方法：</p><p>在 <strong>ASCII</strong> 阶段，<strong>单字节字符串</strong>使用<strong>一个字节存放一个字符（SBCS）</strong>。比如，”Bob123” 在内存中为：<br><u>42</u> <u>6F</u> <u>62</u> <u>31</u> <u>32</u> <u>33</u> <u>00</u><br>&nbsp;B&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0</p><p>在使用 <strong>ANSI 编码</strong>支持多种语言阶段，每个字符使用一个字节或多个字节来表示（MBCS），因此，这种方式存放的字符也被称作<strong>多字节字符</strong>。比如，”中文123” 在中文 Windows 95 内存中为7个字节，<strong>每个汉字占2个字节，每个英文和数字字符占1个字节</strong>：</p><p><u>D6 D0</u> <u>CE C4</u> <u>31</u> <u>32</u> <u>33</u> <u>00</u><br>&emsp;中&emsp;&emsp;文&emsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0</p><p>在 <strong>UNICODE</strong> 被采用之后，计算机存放字符串时，改为存放每个字符在 UNICODE 字符集中的序号。目前计算机<strong>一般使用 2 个字节（16 位）来存放一个序号（DBCS）</strong>，因此，这种方式存放的字符也被称作<strong>宽字节字符</strong>。比如，字符串 “中文123” 在 Windows 2000 下，内存中实际存放的是 5 个序号：</p><p><u>2D 4E</u> <u>87 65</u> <u>31 00</u> <u>32 00</u> <u>33 00</u> <u>00 00</u> &lt;-在 x86 CPU 中，低字节在前<br>&emsp;中&emsp;&emsp;文&emsp;&emsp;1&emsp;&emsp;2&emsp;&emsp;3&emsp;&emsp;\0<br>一共占 10 个字节</p><hr><h3 id="字符、字节、字符串"><a href="#字符、字节、字符串" class="headerlink" title="字符、字节、字符串"></a>字符、字节、字符串</h3><p>理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分：</p><table><tr><th width="10%">　</th><th width="70%">概念描述</th><th width="20%">举例</th></tr><tr><td>字符</td><td>人们使用的记号，抽象意义上的一个符号。</td><td>'1', '中', 'a', '$', '￥', ……</td></tr><tr><td>字节</td><td>计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。</td><td>0x01, 0x45, 0xFA, ……</td></tr><tr><td>ANSI字符串</td><td>在内存中，如果“字符”是以 <strong>ANSI 编码</strong>形式存在的，<strong>一个字符可能使用一个字节或多个字节</strong>来表示，那么我们称这种字符串为 <strong>ANSI 字符串</strong>或者<strong>多字节字符串</strong>。</td><td>"中文123"（占7字节）</td></tr><tr><td>UNICODE字符串</td><td>在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 <strong>UNICODE 字符串或者宽字节字符串</strong>。</td><td>L"中文123"（占10字节）</td></tr></table><p>由于不同 ANSI 编码所规定的标准是不相同的，因此，对于一个给定的<strong>多字节字符串</strong>，我们必须知道它采用的是哪一种编码规则，才能够知道它包含了哪些“字符”。而对于 <strong>UNICODE 字符串</strong>来说，不管在什么环境下，它所代表的“字符”内容总是不变的。</p><hr><h3 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h3><p>各个国家和地区所制定的不同 ANSI 编码标准中，都只规定了各自语言所需的“字符”。比如：汉字标准（GB2312）中没有规定韩国语字符怎样存储。这些 ANSI 编码标准所规定的内容包含两层含义：</p><ol><li>使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“<strong>字符集</strong>”。</li><li>规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“<strong>编码</strong>”。</li></ol><p>各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p><p>“<strong>UNICODE 字符集</strong>”包含了各种语言中使用到的所有“字符”。用来给 UNICODE 字符集编码的标准有很多种，比如：UTF-8, UTF-7, UTF-16, UnicodeLittle, UnicodeBig 等。</p><hr><h3 id="常用的编码简介"><a href="#常用的编码简介" class="headerlink" title="常用的编码简介"></a>常用的编码简介</h3><p>简单介绍一下常用的编码规则，为后边的章节做一个准备。在这里，我们根据编码规则的特点，把所有的编码分成三类：<br><table><tr><th width="15%">分类</th><th width="15%">编码标准</th><th width="70%">说明</th></tr><tr><td>单字节字符</td><td>ISO-8859-1</td><td>最简单的编码规则，每一个字节直接作为一个 UNICODE 字符。比如，[0xD6, 0xD0] 这两个字节，通过 iso-8859-1 转化为字符串时，将直接得到 [0x00D6, 0x00D0] 两个 UNICODE 字符，即 "ÖÐ"。反之，将 UNICODE 字符串通过 iso-8859-1 转化为字节串时，只能正常转化 0~255 范围的字符。</td></tr><tr><td>ANSI</td><td>GB2312,BIG5,Shift_JIS,ISO-8859-2 ……</td><td>把 UNICODE 字符串通过 ANSI 编码转化为“字节串”时，根据各自编码的规定，一个 UNICODE 字符可能转化成一个字节或多个字节。反之，将字节串转化成字符串时，也可能多个字节转化成一个字符。比如，[0xD6, 0xD0] 这两个字节，通过 GB2312 转化为字符串时，将得到 [0x4E2D] 一个字符，即 '中' 字。“ANSI 编码”的<strong>特点</strong>：1. 这些“ANSI 编码标准”都只能处理各自语言范围之内的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间的关系是人为规定的。</td></tr><tr><td>UNICODE</td><td>UTF-8,UTF-16, UnicodeBig ……</td><td>与“ANSI 编码”类似的，把字符串通过 UNICODE 编码转化成“字节串”时，一个 UNICODE 字符可能转化成一个字节或多个字节。<strong>与“ANSI 编码”不同的是</strong>：1. 这些“UNICODE 编码”能够处理所有的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间是可以通过计算得到的。</td></tr></table></p><p>我们实际上没有必要去深究每一种编码具体把某一个字符编码成了哪几个字节，我们<strong>只需要知道“编码”的概念就是把“字符”转化成“字节”就可以了</strong>。对于“UNICODE 编码”，由于它们是可以通过计算得到的，因此，在特殊的场合，我们可以去了解某一种“UNICODE 编码”是怎样的规则。</p><hr><p><br></p><h2 id="简介介绍区别"><a href="#简介介绍区别" class="headerlink" title="简介介绍区别"></a>简介介绍区别</h2><p><strong>位（bit）</strong>：计算机存储信息的最小单位，11001100是一个八位二进制数。</p><p><strong>字节（byte）</strong>：是一种计量单位，表示数据量多少，是计算机存储容量基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）</p><p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号，比如<code>1、2、3、A、B、C、~！·#￥%……—*（）——+、</code>等等。</p><p><strong>编码</strong>：把“字符”转化成“字节”</p><p>不同编码里，字符和字节的对应关系如下：</p><p>ASCII码：</p><ul><li>1个英文字母（不分大小写）= 1个字节的空间</li><li>1个中文汉字 = 2个字节的空间</li></ul><p>Unicode编码：</p><ul><li>1个英文字符 = 2个字节</li><li>英文标点 = 2个字节</li><li>1个中文（含繁体） = 2个字节</li><li>中文标点 = 2个字节</li></ul><p>UTF-8编码：</p><ul><li>1个英文字符 = 1个字节</li><li>英文标点 = 1个字节</li><li>1个中文（含繁体） = 3个字节</li><li>中文标点 = 3个字节</li></ul><p>UTF-16编码：</p><ul><li>一个英文字母字符或一个汉字字符存储都需要2个字节</li><li>Unicode扩展区的一些汉字存储需要4个字节</li></ul><p>UTF-32编码：</p><ul><li>世界上任何字符的存储都需要4个字节</li></ul><div class="note info"><p>unicode编码、UTF-8编码、UTF-16编码、UTF-32编码都是对Unicode字符集进行编码的实现方式</p></div><hr><h2 id="查看系统编码"><a href="#查看系统编码" class="headerlink" title="查看系统编码"></a>查看系统编码</h2><h3 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h3><blockquote><p><code>locale</code><br><strong>LANG=en_US.UTF-8</strong><br>LC_CTYPE=en_US.UTF-8<br>LC_NUMERIC=”en_US.UTF-8”<br>LC_TIME=”en_US.UTF-8”<br>LC_COLLATE=”en_US.UTF-8”<br>LC_MONETARY=”en_US.UTF-8”<br>LC_MESSAGES=”en_US.UTF-8”<br>LC_PAPER=”en_US.UTF-8”<br>LC_NAME=”en_US.UTF-8”<br>LC_ADDRESS=”en_US.UTF-8”<br>LC_TELEPHONE=”en_US.UTF-8”<br>LC_MEASUREMENT=”en_US.UTF-8”<br>LC_IDENTIFICATION=”en_US.UTF-8”<br>LC_ALL=</p></blockquote><p><strong>可以看出linux系统的默认编码是UTF-8</strong></p><h3 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h3><p>windows在dos环境下输入chcp：</p><blockquote><p><code>chcp</code><br>活动代码页: 936</p></blockquote><p><strong>活动代码页为：936，对应的编码格式为GBK</strong></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/u012156116/article/details/79923484" target="_blank" rel="noopener">字符与字节的区别</a></li><li><a href="http://www.regexlab.com/zh/encoding.htm" target="_blank" rel="noopener">字符，字节和编码</a></li><li><a href="https://www.cnblogs.com/yangxiaoqin/p/8460395.html" target="_blank" rel="noopener">位、字节、字符的区别</a></li><li><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">UTF-8和Unicode关系</a></li><li><a href="https://www.cnblogs.com/wpcockroach/p/3907324.html" target="_blank" rel="noopener">简单几句话总结Unicode，UTF-8和UTF-16</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单行命令嵌套</title>
      <link href="/posts/50164.html"/>
      <url>/posts/50164.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>单行命令嵌套，也就是一行命令使用另一行命令的结果，或者将命令的结果当做参数传给另一个命令，使用方法<code>command1 &lt;(command2)</code>.</p></div><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>将command2的结果作为command1的输入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  command1 &lt;(command2)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>uniq命令去重常常需要先进行排序操作：</p><blockquote><p><code>uniq -c &lt;(sort uniq.txt)</code><br>1 i am test<br>2 i love test<br>1 i want go abroad<br>4 this is a test<br>1 those are good men<br>1 we are good men<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try</p></blockquote><p>当前上述也可以直接使用<strong>管道符<code>|</code></strong>来操作</p><p>但是如果是像<code>join</code>这种<strong>需要操作两个文件的</strong>，单纯地使用管道符就很难达到目的，<code>join</code>对指定列进行连接时也需要进行排序操作：</p><blockquote><p><code>cat test1.txt</code><br>aa 1 2<br>bb 2 3<br>cc 4 6<br>dd 3 3</p></blockquote><blockquote><p><code>cat test2.txt</code><br>aa 2 1<br>bb 8 2<br>ff 2 4<br>cc 4 4<br>dd 5 5</p></blockquote><p>管道符和命令嵌套合用：</p><blockquote><p><strong><code>sort -k 1,1 test2.txt |join -j 1 &lt;(sort -k 1,1 test1.txt) -</code></strong><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>当然也可以直接使用命令嵌套：</p><blockquote><p><strong><code>join -j 1 &lt;(sort -k 1,1 test1.txt) &lt;(sort -k 1,1 test2.txt)</code></strong><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cut-按列切分文件字段工具</title>
      <link href="/posts/64687.html"/>
      <url>/posts/64687.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了Linux下对每一行文本按照给定的分隔符进行切割并按照指定的范围提取字段、字符或字节的命令<code>cut</code>，其主要选项包括：<code>-d</code>、<code>-f</code>、<code>--complement</code>、<code>-s</code>、<code>-c</code>、<code>-b</code>、<code>-n</code>和<code>--output-delimiter</code>。</p></div><a id="more"></a><h2 id="cut用法"><a href="#cut用法" class="headerlink" title="cut用法"></a>cut用法</h2><ul><li><code>cut</code>命令从文件的每一行剪切字节、字符或字段并将这些字节、字符或字段写至标准输出</li><li>如果不指定文件，<code>cut</code>命令将读取标准输入</li></ul><h3 id="cut命令格式"><a href="#cut命令格式" class="headerlink" title="cut命令格式"></a>cut命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cut OPTION [FILE]</span><br></pre></td></tr></table></figure><hr><h3 id="cut-options说明"><a href="#cut-options说明" class="headerlink" title="cut options说明"></a>cut options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–bytes=LIST</td><td>以字节为单位进行分割，这些字节位置将忽略多字节字符边界，除非也指定了-n标志</td></tr><tr><td>-c</td><td>–characters=LIST</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>–delimiter=DELIM</td><td>自定义分隔符，默认为制表符tab</td></tr><tr><td>-f</td><td>–fields=LIST</td><td>与-d一同使用，显示指定字段的内容；也会打印不包含分隔符的行，除非指定了-s参数</td></tr><tr><td>-n</td><td></td><td>with -b: 取消分割多字节字符，仅和 -b 标志一起使用；如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出，否则该字符将被排除</td></tr><tr><td></td><td>–complement</td><td>补足被选择的字节、字符或字段</td></tr><tr><td>-s</td><td>–only-delimited</td><td>不打印没有包含分隔符的行，有利于去掉注释和标题</td></tr><tr><td></td><td>–output-delimiter=STRING</td><td>指定输出内容的分隔符</td></tr></tbody></table><hr><h3 id="cut指定字段、字符或字节范围的方法"><a href="#cut指定字段、字符或字节范围的方法" class="headerlink" title="cut指定字段、字符或字节范围的方法"></a>cut指定字段、字符或字节范围的方法</h3><p>指定字段、字符或字节范围有以下三种方法：</p><ul><li><strong>N-</strong>：获取<em>连续</em>范围，<strong>从第N个</strong>字节、字符、字段<strong>到结尾</strong>；</li><li><strong>N-M</strong>：获取<em>连续</em>范围，<strong>从第N个</strong>字节、字符、字段<strong>到第M个（包括M在内）</strong>字节、字符、字段；</li><li><strong>-M</strong>：获取<em>连续</em>范围，<strong>从第1个</strong>字节、字符、字段<strong>到第M个（包括M在内）</strong>字节、字符、字段</li><li><strong>N,M</strong>：获取<em>不连续</em>范围，得到<strong>第N个</strong>字节、字符、字段和<strong>第M个</strong>字节、字符、字段</li><li><strong>N,M,Z-P</strong>：获取<em>连续范围和不连续</em>范围，<strong>第N个</strong>字节、字符、字段、<strong>第M个</strong>字节、字符、字段以及<strong>从第Z个</strong>字节、字符、字段<strong>到第P个（包括P在内）</strong>字节、字符、字段</li></ul><div class="note info"><p>逗号(,)可以使用多个</p></div><hr><p><br></p><h2 id="cut用法实例"><a href="#cut用法实例" class="headerlink" title="cut用法实例"></a>cut用法实例</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><blockquote><p><code>cat cut.txt</code><br>No Name Mark Percent<br>01 tom 69 91<br>02 jack 71 87<br>03 alex 68 98</p></blockquote><h3 id="d-自定义分隔符"><a href="#d-自定义分隔符" class="headerlink" title="-d 自定义分隔符"></a>-d 自定义分隔符</h3><p><mark>默认-d是制表符tab，这个很关键，不是空白字符，同时自定义的分隔符必须是单个的字符，比如单个的空格，不能是两个或以上空格</mark></p><blockquote><p><code>cut -d &#39; &#39; -f 1 cut.txt</code><br>No<br>01<br>02<br>03</p></blockquote><blockquote><p><code>awk &#39;{print $1&quot;;&quot;$2&quot;;&quot;$3&quot;;&quot;$4}&#39; cut.txt |cut -d &#39;;&#39; -f 1</code><br>No<br>01<br>02<br>03</p></blockquote><hr><h3 id="f-提取指定字段内容"><a href="#f-提取指定字段内容" class="headerlink" title="-f 提取指定字段内容"></a>-f 提取指定字段内容</h3><p>选取<strong>单个filed</strong>如上面-d用法示例</p><p><strong>选取多个字段，直接将多个字段在-f选项后使用,分割即可：</strong></p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3 cut.txt</code></strong><br>No Mark<br>01 69<br>02 71<br>03 68</p></blockquote><p><strong>也可以使用<code>-</code>和<code>,</code>混用的方法：</strong></p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3-4 cut.txt</code></strong><br>No Mark Percent<br>01 69 91<br>02 71 87<br>03 68 98</p></blockquote><hr><h3 id="–complement-提取指定字段之外的内容"><a href="#–complement-提取指定字段之外的内容" class="headerlink" title="–complement 提取指定字段之外的内容"></a>–complement 提取指定字段之外的内容</h3><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3 --complement cut.txt</code></strong><br>Name Percent<br>tom 91<br>jack 87<br>alex 98</p></blockquote><p><strong>这里得到的结果和上面单纯使用<code>-f</code>得到的结果可以说是互补的，因为<code>--complement</code>是提取指定字段之外的内容</strong></p><hr><h3 id="s-不打印没有包含分隔符的行"><a href="#s-不打印没有包含分隔符的行" class="headerlink" title="-s 不打印没有包含分隔符的行"></a>-s 不打印没有包含分隔符的行</h3><p>在cut.txt上增加一行文本，其分隔符和其他几行不同：</p><blockquote><p><code>cat cut.txt</code><br>#this-is-test<br>No Name Mark Percent<br>01 tom 69 91<br>02 jack 71 87<br>03 alex 68 98</p></blockquote><p><strong>默认情况，如果一行不包含分隔符，就会输出这一行</strong>：</p><blockquote><p>cut -d ‘ ‘ -f 1 cut.txt<br>#this-is-test<br>No<br>01<br>02<br>03</p></blockquote><p>为了防止上述情形出现，可以使用<code>-s</code>选项：</p><blockquote><p><code>cut -d &#39; &#39; -s -f 1 cut.txt</code><br>No<br>01<br>02<br>03</p></blockquote><p>可以发现，不包含空格作为分隔符的第一行就没有进行输出</p><hr><h3 id="c-提取指定字符范围的内容"><a href="#c-提取指定字符范围的内容" class="headerlink" title="-c 提取指定字符范围的内容"></a>-c 提取指定字符范围的内容</h3><blockquote><p><code>cat cut2.txt</code><br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz</p></blockquote><p><strong>指定连续范围：</strong></p><blockquote><p><code>cut -c -2 cut2.txt</code><br>ab<br>ab<br>ab<br>ab<br>ab</p></blockquote><blockquote><p><code>cut -c 5- cut2.txt</code><br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz</p></blockquote><p><strong>指定不连续范围和连续范围（<code>,</code>和<code>-</code>混用）：</strong></p><blockquote><p><code>cut -c 1,3-5 cut2.txt</code><br>acde<br>acde<br>acde<br>acde<br>acde</p></blockquote><hr><h3 id="b-提取指定字符范围的内容"><a href="#b-提取指定字符范围的内容" class="headerlink" title="-b 提取指定字符范围的内容"></a>-b 提取指定字符范围的内容</h3><blockquote><p><code>cut -b 1-5 cut2.txt</code><br>abcde<br>abcde<br>abcde<br>abcde<br>abcde</p></blockquote><p><strong>这结果咋一看和前面的<code>-c</code>没有什么区别，这是因为操作对象都是英文字母，而在<code>ASCII码</code>和<code>UTF-8编码</code>中英文字母的字节和字符是相等的</strong>，具体的字节和字符的区别见<a href="http://showteeth.tech/posts/56690.html">这篇博客</a></p><p>由于我使用的<strong>vscode的默认编码方式为<code>utf-8</code></strong>，所以<strong>英文字母的字节和字符是相等的</strong>，而<strong>中文1个中文（含繁体） = 3个字节</strong>，为了凸显-b和-c的区别，下面采用中文进行测试：</p><blockquote><p><code>cat cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><blockquote><p><code>cut -b 1-3 cut3.txt</code> # cut -b <strong>1-2</strong> cut3.txt<strong>结果为空</strong>，因为需要三个字节才可以<br>星<br>星<br>星<br>星<br>星</p></blockquote><blockquote><p><code>cut -c 1-3 cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><div class="note info"><p>针对英文字符进行提取指定字符范围内容时，<code>-b</code>和<code>-c</code>选项没什么差别，因为在大部分编码方式中，英文字母的字节和字符是相等的，而针对中文就需要注意不同的编码方式对中文字符对应字节数的设置，当然<code>cut</code>命令还提供了了一个选项<code>-n</code>来解决上述<code>-b</code>可能遇到的问题</p></div><hr><h3 id="n-取消分割多字节字符"><a href="#n-取消分割多字节字符" class="headerlink" title="-n 取消分割多字节字符"></a>-n 取消分割多字节字符</h3><p><strong>该选项仅和 -b 选项一起使用</strong>，用来取消分割多字节字符</p><blockquote><p><code>cut -b 3 cut3.txt</code></p></blockquote><blockquote><p>cut -nb 3 cut3.txt<br>星<br>星<br>星<br>星<br>星</p></blockquote><blockquote><p><code>cut -nb 3,6,9 cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><p>当<code>-nb</code>后面的数字为<code>3的整数倍（utf-8编码）</code>时就不会分割多字节字符，得到对应的字符，不过感觉这没啥大用处，一般都直接使用了<code>-c</code>参数来获取字符</p><hr><h3 id="–output-delimiter-STRING-指定输出内容是的分隔符"><a href="#–output-delimiter-STRING-指定输出内容是的分隔符" class="headerlink" title="–output-delimiter=STRING 指定输出内容是的分隔符"></a>–output-delimiter=STRING 指定输出内容是的分隔符</h3><blockquote><p><code>cut -d &#39; &#39; -f 1-3 --output-delimiter=$&#39;\t&#39; cut.txt</code><br>#this-is-test<br>No Name Mark<br>01 tom 69<br>02 jack 71<br>03 alex 68</p></blockquote><div class="note info"><p>注意这里指定输出分割符为tab的时候使用了<code>$&#39;\t&#39;</code>的方式，其中<code>$</code>和<code>单引号</code>都是必须的不能更改的，这个和<code>join</code>命令中指定分隔符的用法相同，具体原因查看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cut" target="_blank" rel="noopener">cut命令</a></li><li><a href="https://www.cnblogs.com/fulucky/p/8124858.html" target="_blank" rel="noopener">linux的cut命令</a></li><li><a href="https://www.cnblogs.com/longjshz/p/5792502.html" target="_blank" rel="noopener">Linux下的cut选取命令详解</a></li><li><a href="https://www.cnblogs.com/Hobbies/articles/4527447.html" target="_blank" rel="noopener">linux每日一命令–cut</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniq-去重</title>
      <link href="/posts/20744.html"/>
      <url>/posts/20744.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文学习了linux中准备对文本进行去重操作的<code>uniq</code>命令，其重要的参数包括<code>-c</code>、<code>-d</code>、<code>-D</code>、<code>-f</code>、<code>-s</code>、<code>-w</code>、<code>-i</code>、<code>-u</code>。这个命令通常与<a href="http://showteeth.tech/posts/61024.html">sort</a>一起使用。</p></div><a id="more"></a><h2 id="uniq用法"><a href="#uniq用法" class="headerlink" title="uniq用法"></a>uniq用法</h2><p>uniq命令是专门用来去除重复行的命令，使用时需要注意：</p><ul><li>对文本操作时，它一般会和<a href="http://showteeth.tech/posts/61024.html">sort命令</a>进行组合使用，因为<strong>uniq 不会检查重复的行，除非它们是相邻的</strong>，如果您想<strong>先对输入排序</strong>，使用<strong>sort -u</strong></li><li>对文本操作时，若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中<strong>字符前的空字符将被跳过</strong></li></ul><h3 id="uniq命令格式"><a href="#uniq命令格式" class="headerlink" title="uniq命令格式"></a>uniq命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  uniq [OPTION] [INPUT [OUTPUT]]</span><br><span class="line">  <span class="comment"># 从输入文件或者标准输入中过滤相邻的匹配行并将结果写入到输出文件或标准输出</span></span><br><span class="line">  <span class="comment"># 在不加options的情况下，匹配行将在首次出现处被合并</span></span><br></pre></td></tr></table></figure><hr><h3 id="uniq-options说明"><a href="#uniq-options说明" class="headerlink" title="uniq options说明"></a>uniq options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>–count</td><td>在每行前加上表示行出现次数</td></tr><tr><td>-d</td><td>–repeated</td><td>只输出重复的行，即出现次数&gt;=2的行，且只打印一次</td></tr><tr><td>-D</td><td>–all-repeated[=delimit-method]</td><td>仅显示重复的行，即出现次数&gt;=2的行，且打印重复行的所有行。其中delimit-method表示对重复行集合的分隔方式，有三种取值，分别为none（默认）、prepend和separate。</td></tr><tr><td>-u</td><td>–unique</td><td>只显示唯一的行，即出现次数等于1的行</td></tr><tr><td>-f</td><td>–skip-fields=N</td><td>忽略前N个<strong>字段</strong></td></tr><tr><td>-s</td><td>–skip-chars=N</td><td>和-f类似，不过-s是忽略前N个<strong>字符</strong></td></tr><tr><td>-w</td><td>–check-chars=N</td><td>指定每行要比较的前N个字符数</td></tr><tr><td>-i</td><td>–ignore-case</td><td>不区分大小写</td></tr><tr><td>-z</td><td>–zero-terminated</td><td>end lines with 0 byte, not newline</td></tr></tbody></table><hr><p><br></p><h2 id="uniq用法实例"><a href="#uniq用法实例" class="headerlink" title="uniq用法实例"></a>uniq用法实例</h2><h3 id="测试文本"><a href="#测试文本" class="headerlink" title="测试文本"></a>测试文本</h3><blockquote><p><code>cat uniq.txt</code><br>this is a test<br>this is a test<br><strong>this is a test</strong><br>i am test<br>i love test<br>i love test<br><strong>this is a test</strong><br>whom have a try<br>WhoM have a try<br>you have a try<br>i want go abroad<br>those are good men<br>we are good men</p></blockquote><h3 id="使用默认方式进行去重"><a href="#使用默认方式进行去重" class="headerlink" title="使用默认方式进行去重"></a>使用默认方式进行去重</h3><blockquote><p><code>uniq uniq.txt</code><br><em>this is a test</em><br>i am test<br>i love test<br><em>this is a test</em><br>whom have a try<br>WhoM have a try<br>you have a try<br>i want go abroad<br>those are good men<br>we are good men</p></blockquote><p>可以发现，<strong>uniq在计算重复的时候只会看相邻行</strong>，有一个<em>this is a test</em>没有和其他相邻，结果就被保留下来，当做非重复行</p><h3 id="c-显示行出现的次数"><a href="#c-显示行出现的次数" class="headerlink" title="-c 显示行出现的次数"></a>-c 显示行出现的次数</h3><blockquote><p><code>uniq -c uniq.txt</code><br>3 this is a test<br>1 i am test<br>2 i love test<br>1 this is a test<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try<br>1 i want go abroad<br>1 those are good men<br>1 we are good men</p></blockquote><p>依旧存在前面提到的问题，<strong>uniq在计算重复的时候只会看相邻行</strong>，和sort连用：</p><blockquote><p><code>sort uniq.txt |uniq -c</code><br>1 i am test<br>2 i love test<br>1 i want go abroad<br><strong>4 this is a test</strong><br>1 those are good men<br>1 we are good men<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try</p></blockquote><p>单纯使用sort命令去重的结果和上面是一样的，只是不能得到具体的重复数目，uniq功能更加强大：</p><blockquote><p><code>sort -u uniq.txt</code><br>i am test<br>i love test<br>i want go abroad<br>this is a test<br>those are good men<br>we are good men<br>whom have a try<br>WhoM have a try<br>you have a try</p></blockquote><hr><h3 id="d-只输出重复的行-输出一行"><a href="#d-只输出重复的行-输出一行" class="headerlink" title="-d 只输出重复的行(输出一行)"></a>-d 只输出重复的行(输出一行)</h3><blockquote><p><code>sort uniq.txt |uniq -dc</code><br>2 i love test<br>4 this is a test</p></blockquote><hr><h3 id="D-仅输出重复的行-重复输出"><a href="#D-仅输出重复的行-重复输出" class="headerlink" title="-D 仅输出重复的行(重复输出)"></a>-D 仅输出重复的行(重复输出)</h3><blockquote><p><code>sort uniq.txt |uniq -D</code><br>i love test<br>i love test<br>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><p>这个就<strong>不能和<code>-c</code>连用</strong>，因为重复行都显示出来了</p><h4 id="delimit-method-none"><a href="#delimit-method-none" class="headerlink" title="delimit-method=none"></a>delimit-method=none</h4><p>none表示不进行分隔，为<strong>默认选项</strong>，<code>uniq -D</code>等同于<code>uniq --all-repeated=none</code></p><p>注意使用<code>delimit-method</code>的时候就<strong>不能使用option的简写形式</strong>，<strong>必须使用完整参数</strong></p><hr><h4 id="delimit-method-prepend"><a href="#delimit-method-prepend" class="headerlink" title="delimit-method=prepend"></a>delimit-method=prepend</h4><p>prepend表示在每一个<strong>重复行集合前面</strong>插入一个空行</p><blockquote><p><strong><code>sort uniq.txt |uniq --all-repeated=prepend</code></strong></p><p>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><hr><h4 id="delimit-method-separate"><a href="#delimit-method-separate" class="headerlink" title="delimit-method=separate"></a>delimit-method=separate</h4><p>separate表示在每个<strong>重复行集合间</strong>插入一个空行</p><blockquote><p><strong><code>sort uniq.txt |uniq --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><hr><h3 id="f-忽略前N个字段"><a href="#f-忽略前N个字段" class="headerlink" title="-f 忽略前N个字段"></a>-f 忽略前N个字段</h3><blockquote><p><strong><code>sort uniq.txt |uniq -f 1 --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p><em>those</em> are good men<br><em>we</em> are good men</p><p><em>whom</em> have a try<br><em>WhoM</em> have a try</p></blockquote><blockquote><p><code>uniq -f 2 --all-repeated=separate uniq2.txt</code><br>this is a test<br>this are a test</p><p>my name is showteeth<br>your mmmm is showteeth</p></blockquote><div class="note info"><p><strong>-f是指定前N个field</strong>，而<strong>不是仅仅规定单独的field来进行判断是不是重复</strong>，如果<strong>仅仅想看某一列</strong>，可以<strong>将那一列放在第一个field</strong>，然后使用<code>-f</code>参数即可</p></div><hr><h3 id="s-忽略前N个字符"><a href="#s-忽略前N个字符" class="headerlink" title="-s 忽略前N个字符"></a>-s 忽略前N个字符</h3><blockquote><p><strong><code>sort uniq.txt |uniq -s 4 --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p><em>whom</em> have a try<br><em>WhoM</em> have a try<br><em>you</em> have a try</p></blockquote><hr><h3 id="w-指定每行要比较的前N个字符数"><a href="#w-指定每行要比较的前N个字符数" class="headerlink" title="-w 指定每行要比较的前N个字符数"></a>-w 指定每行要比较的前N个字符数</h3><blockquote><p><strong><code>sort uniq.txt |uniq -w 2 --all-repeated=separate</code></strong><br><em>i</em> am test<br><em>i</em> love test<br><em>i</em> love test<br><em>i</em> want go abroad</p><p><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>ose are good men</p></blockquote><div class="note info"><p>注意这个参数和前面的<code>-f</code>、<code>-s</code>相同，都是<mark>前N个字段或者字符</mark>，而<strong>不是单纯地指定某一个字段或者字符</strong></p></div><hr><h3 id="i-不区分大小写"><a href="#i-不区分大小写" class="headerlink" title="-i 不区分大小写"></a>-i 不区分大小写</h3><blockquote><p><code>sort uniq.txt |uniq -i --all-repeated=separate</code><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p>whom have a try<br>WhoM have a try</p></blockquote><hr><h3 id="u-只显示唯一的行"><a href="#u-只显示唯一的行" class="headerlink" title="-u 只显示唯一的行"></a>-u 只显示唯一的行</h3><blockquote><p><code>sort uniq.txt |uniq -u</code><br>i am test<br>i want go abroad<br>those are good men<br>we are good men<br><em>whom</em> have a try<br><em>WhoM</em> have a try<br>you have a try</p></blockquote><p>显示<strong>在忽略大小写情况下的唯一的行</strong>：</p><blockquote><p><code>sort uniq.txt |uniq -u -i</code><br>i am test<br>i want go abroad<br>those are good men<br>we are good men<br>you have a try</p></blockquote><p>上面的whom存在大小写区别的行就没排除在外</p><div class="note info"><p>不会显示去除了重复之后的保留的唯一重复行</p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/ftl1012/p/uniq.html" target="_blank" rel="noopener">Linux uniq命令详解</a></li><li><a href="https://blog.csdn.net/k346k346/article/details/70175532" target="_blank" rel="noopener">Linux命令——uniq命令</a></li><li><a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">实例详细说明linux下去除重复行命令uniq</a></li><li><a href="http://man.linuxde.net/uniq" target="_blank" rel="noopener">uniq命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>join-连接文本</title>
      <link href="/posts/5579.html"/>
      <url>/posts/5579.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文学习了可以按照指定<code>field</code>内容来将两个文件连接起来的<code>join</code>命令，其重要的参数包括<code>-1</code>、<code>-2</code>、<code>-j</code>、<code>-o</code>、<code>-t</code>、<code>-a</code>、<code>-e</code>、<code>-v</code>、<code>–nocheck-order</code>。</p></div><a id="more"></a><h2 id="join用法"><a href="#join用法" class="headerlink" title="join用法"></a>join用法</h2><ul><li><code>join</code>命令用来将<strong>两个文件</strong>中<strong>指定栏位内容相同的行连接起来</strong>，再输出到标准输出设备</li><li><strong>默认</strong>连接的栏位是有<strong>空白字符分隔</strong>的第一个栏位</li></ul><h3 id="join命令格式"><a href="#join命令格式" class="headerlink" title="join命令格式"></a>join命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  join [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="join-options说明"><a href="#join-options说明" class="headerlink" title="join options说明"></a>join options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>FILENUM</td><td>FILENUM 取1或者2，表示除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行，<strong>相当于指定左外链接还是右外连接</strong></td></tr><tr><td>-v</td><td>FILENUM</td><td>与-a相似 但只显示文件里没匹配上的行</td></tr><tr><td>-e</td><td>EMPTY</td><td>取值为字符串，将需要显示可是文件里不存在的域用此选项指定的字符取代</td></tr><tr><td>-i</td><td>–ignore-case</td><td>比较栏位内容时，忽略大小写的差异</td></tr><tr><td>-j</td><td>FIELD</td><td>-j指定一个域作为匹配字段，等同于 -1 FIELD -2 FIELD</td></tr><tr><td>-1</td><td>FIELD</td><td>以file1中FIELD字段进行匹配</td></tr><tr><td>-2</td><td>FIELD</td><td>以file2中FIELD字段进行匹配</td></tr><tr><td>-o</td><td>FORMAT</td><td>以指定格式输出</td></tr><tr><td>-t</td><td>CHAR</td><td>指定输入输出的分隔符，join 默认以空白字符做分隔符</td></tr><tr><td>–check-order</td><td></td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td></td><td>不判断所有输入文件是不是已经排好序</td></tr></tbody></table><hr><p><br></p><h2 id="join用法实例"><a href="#join用法实例" class="headerlink" title="join用法实例"></a>join用法实例</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><blockquote><p><code>cat test1.txt</code><br>aa 1 2<br>bb 2 3<br>cc 4 6<br>dd 3 3</p></blockquote><blockquote><p><code>cat test2.txt</code><br>aa 2 1<br>bb 8 2<br>ff 2 4<br>cc 4 4<br>dd 5 5</p></blockquote><h3 id="使用默认方式连接文件"><a href="#使用默认方式连接文件" class="headerlink" title="使用默认方式连接文件"></a>使用默认方式连接文件</h3><blockquote><p><code>join test1.txt test2.txt</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br><strong>join: file 2 is not in sorted order</strong></p></blockquote><p>上面的结果<strong>没有输出完整</strong>，同时输出了提示信息，<strong>file 2(test2.txt)没有进行没有进行排序</strong>，结合前面学习的<a href="http://showteeth.tech/posts/61024.html">sort</a>命令对其第一列进行排序并进行连接：</p><blockquote><p><code>sort -k 1,1 test2.txt |join test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>这次得到了完整的结果，同时注意在<strong>管道符</strong>后使用<code>-</code>表示<code>read standard input</code>也就是前面的sort的输出内容</p><div class="note info"><p>对某一列进行连接，就需要<strong>保证文件的这一列是排好序的</strong>，而不是只要对整个文件进行排序即可</p></div><hr><h3 id="–nocheck-order-检查是否排序"><a href="#–nocheck-order-检查是否排序" class="headerlink" title="–nocheck-order 检查是否排序"></a>–nocheck-order 检查是否排序</h3><p>针对上面出现的文件没有排序的问题，也可以在不报错的情况下直接输出部分结果，默认情况应该是<code>--check-order</code>的：</p><blockquote><p><code>join --nocheck-order test1.txt test2.txt</code><br>aa 1 2 2 1<br>bb 2 3 8 2</p></blockquote><p>这个感觉没啥意义，得不到正确结果</p><hr><h3 id="1、-2-指定连接列"><a href="#1、-2-指定连接列" class="headerlink" title="-1、-2 指定连接列"></a>-1、-2 指定连接列</h3><ul><li><code>-1</code>：指定<strong>文件1（写在前面的文件）</strong>中用于连接的列</li><li><code>-2</code>：指定<strong>文件2（写在后面的文件）</strong>中用于连接的列</li></ul><blockquote><p><code>sort -k 1,1 test2.txt |join -1 1 -2 1 test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>这个结果和上面默认的结果相同</p><p>让文件1的第2列与文件2的第3列进行连接（两列都是已经排好序的，不用再排序）：</p><blockquote><p><code>join -1 2 -2 3 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong></p></blockquote><p>可以发现<strong>文件1中的<code>cc 4 6</code>出现了两次</strong>，这是因为<em>文件2中在第3列上出现了2个4</em>，这2个4对应的行都和文件1中的对应的行进行连接，从而出现了2次</p><p>如果在文件1中增加一列重复的<code>cc 4 6</code>，得到如下结果：</p><blockquote><p><code>join -1 2 -2 3 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong><br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong></p></blockquote><p>即使<strong>存在重复，连接也会进行组合操作</strong>，得到2x2个结果</p><div class="note info"><ul><li><strong>默认情况下</strong>，对哪一列进行连接，输出的结果中，<strong>用于连接的那一列就会放在最前面</strong>，如果需要<strong>自定义输出内容和顺序</strong>，可以使用后面提到的<code>-o</code>参数进行修改</li><li>文件在指定的列上存在相同的，则会进行组合，比如各有2个相同的，则会得到2x2也就是4个结果（这里不管文件是否存在重复）</li></ul></div><hr><h3 id="j-指定用于连接的列"><a href="#j-指定用于连接的列" class="headerlink" title="-j 指定用于连接的列"></a>-j 指定用于连接的列</h3><p>如果两个文件中用于连接的列(field)相同，可以直接使用-j参数统一制定，不用使用上面那种-1、-2这种分别指定，较为简便：</p><blockquote><p><code>sort -k 1,1 test2.txt |join -j 1 test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><hr><h3 id="o-自定义输出内容和顺序"><a href="#o-自定义输出内容和顺序" class="headerlink" title="-o 自定义输出内容和顺序"></a>-o 自定义输出内容和顺序</h3><p>输出文件1的第1列和第2列以及文件2的第1列和第3列：</p><blockquote><p><code>join -1 2 -2 3 -o 1.{1,2} 2.{1,3} test1.txt test2.txt</code><br>aa 1 aa 1<br>bb 2 bb 2<br>cc 4 ff 4<br>cc 4 cc 4</p></blockquote><div class="note info"><p>注意这里大括号<code>{}</code>的用法，详细请参考<a href="http://showteeth.tech/posts/55603.html">文章</a></p></div><hr><h3 id="t-指定分隔符"><a href="#t-指定分隔符" class="headerlink" title="-t 指定分隔符"></a>-t 指定分隔符</h3><blockquote><p><code>sort -k 1,1 test2.txt|awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39;|join -t $&#39;\t&#39; &lt;(awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39; test1.txt) -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>指定<code>-t $&#39;\t&#39;</code>后，<strong>输出的内容也是以tab作为分隔的</strong>；使用<strong>默认的分隔符</strong>也能对上述案例进行连接，但是<strong>输出的是空格分隔</strong>，不管原始文件内是使用空格份额各还是tab分隔</p><div class="note info"><p>注意这里指定tab作为分隔符的方式，<strong><code>$&#39;\t&#39;</code>设定的原因（单引号+<code>$</code>）</strong>参考之前的<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h3 id="a-指定外连接"><a href="#a-指定外连接" class="headerlink" title="-a 指定外连接"></a>-a 指定外连接</h3><p><strong>join默认进行的是内连接</strong>，也就是找到两个文件中在指定列上能够连接起来的行显示出现，但是要想显示共有的以及一个文件有一个文件没有的行就需要涉及到外连接，分为<strong>左外链接和右外连接和全外连接</strong>。<strong>左外链接指</strong>除了显示在指定列上能够连接起来的行外，还要把左边文件有，右边文件没有的行显示出来，右外连接类似，<strong>全外连接</strong>是将左边和右边的都显示出来，不管有没有连接上</p><p>设置<strong>左外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a 1 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br><strong>3 dd 3</strong></p></blockquote><p>设置<strong>右外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a 2 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br><strong>5 dd 5</strong></p></blockquote><p>设置<strong>全外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a1 -a2 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br>3 dd 3<br>5 dd 5</p></blockquote><p>这个顺序好像有点错乱，不管是文件1还是文件2的内容都靠左显示，使用-o指定输出内容：</p><blockquote><p><code>join -1 2 -2 3 -a1 -a2 -o 1.{1..3} 2.{1..3} test1.txt test2.txt</code><br>aa 1 2 aa 2 1<br>bb 2 3 bb 8 2<br>cc 4 6 ff 2 4<br>cc 4 6 cc 4 4<br>dd 3 3<br>dd 5 5</p></blockquote><p>发现文件1的内容靠左，文件2的内容前面会留有3个空格（文件1每一行的长度），刚好错开</p><hr><h3 id="e-指定替代字符"><a href="#e-指定替代字符" class="headerlink" title="-e 指定替代字符"></a>-e 指定替代字符</h3><p>在上面设置<strong>左外链接和右外连接</strong>的情况下，使用<code>-e</code>设置字符来填充某个文件没有的行的信息:</p><blockquote><p><code>join -1 2 -2 3 -a 2 -o 1.{1..3} 2.{1..3} -e &quot;empty&quot; test1.txt test2.txt</code><br>aa 1 2 aa 2 1<br>bb 2 3 bb 8 2<br>cc 4 6 ff 2 4<br>cc 4 6 cc 4 4<br>empty empty empty dd 5 5</p></blockquote><div class="note info"><p><strong>使用<code>-e</code>选项时必须也要设定<code>-o</code>选项</strong>，不然不能使用字符进行填充（可能是因为如-a参数使用中的不设置-o参数会使得结果显示出现问题，指定连接的列会在最左边显示，不能连接的行的内容不管是文件1还是文件2都会靠左显示，不能正确显示出内容和文件的对应关系）</p></div><hr><h3 id="v-显示未匹配行"><a href="#v-显示未匹配行" class="headerlink" title="-v 显示未匹配行"></a>-v 显示未匹配行</h3><blockquote><p><code>join -1 2 -2 3 -v 1 test1.txt test2.txt</code><br>3 dd 3</p></blockquote><blockquote><p><code>join -1 2 -2 3 -v 2 test1.txt test2.txt</code><br>5 dd 5</p></blockquote><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="指定多个列来进行链接"><a href="#指定多个列来进行链接" class="headerlink" title="指定多个列来进行链接"></a>指定多个列来进行链接</h3><p>因为join命令只支持单个field的连接，而指定多个field作为连接列又非常常用，所以这里给出了几种解决方法：</p><p><strong>思路一：既然join命令只支持单个field的连接，那就把多个field转化为单个field进行连接即可</strong><br>将上述test1.txt的第1列和第2列与test2.txt的第1列和第3列进行连接：</p><blockquote><p><strong><code>join -j 1 &lt;(awk &#39;{print $1&quot;-&quot;$2&quot;\t&quot;$0}&#39; test1.txt |sort -k 1,1) &lt;(awk &#39;{print $1&quot;-&quot;$3&quot;\t&quot;$0}&#39; test2.txt |sort -k 1,1)</code></strong><br><em>aa-1</em> aa 1 2 aa 2 1<br><em>bb-2</em> bb 2 3 bb 8 2<br><em>cc-4</em> cc 4 6 cc 4 4</p></blockquote><p>控制输出的时候可以使用<code>-o</code>参数对输出进行控制，来决定输出的内容</p><p><strong>思路二：通过处理其中一个文件得到匹配的fileds，然后利用<code>grep</code>命令在另一个文件中查找这个fields，得到最终的结果</strong><br>提取test1.txt的第1列和第2列作为pattern_file，在test2.txt文件中对齐进行查找：</p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,2 test1.txt |grep -f - &lt;(awk &#39;{print $1,$3,$2}&#39; test2.txt )</code></strong><br>aa 1 2<br>bb 2 8<br>cc 4 4</p></blockquote><p>注意这个<strong>只能得到test2.txt中的内容</strong>，而且还<strong>必须得调整列的位置</strong>，使<strong>test2.txt中需要和pattern_file进行连接的列进行对应（pattern_file是第1、2列，那就需要把test2.txt的第3列换到第2列的位置，和pattern_file进行对应）</strong>，不然不能查找结果。</p><p>还可以使用<code>awk</code>命令进行操作，具体参考<a href="https://stackoverflow.com/questions/2619562/joining-multiple-fields-in-text-files-on-unix" target="_blank" rel="noopener">这个链接</a></p><hr><h3 id="需要按照ascii来对key进行排序"><a href="#需要按照ascii来对key进行排序" class="headerlink" title="需要按照ascii来对key进行排序"></a>需要按照ascii来对key进行排序</h3><p>必须要按照ascii来对key进行排序才能进行join操作，即使是数字也要按照ascii排序，然后进行join，最后可以再选择将其结果按照数字进行排序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果对按照数字排序的结果进行join会出现没排序的问题提示</span></span><br><span class="line">sort -k 2,2n sortchrM.uniq100bp.map.base |join -j 2 -o 1.&#123;1,2&#125; 2.3 - &lt;(sort -k 2,2n mapping_uniq_site_depth.txt) |more</span><br><span class="line">  <span class="comment"># 提示没有排序</span></span><br><span class="line">  join: file 1 is not <span class="keyword">in</span> sorted order</span><br><span class="line">  join: file 2 is not <span class="keyword">in</span> sorted order</span><br><span class="line">  chrM 4 78</span><br><span class="line">  chrM 5 83</span><br><span class="line">  chrM 6 179</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照默认的ascii排序就是正常的</span></span><br><span class="line">sort -k 2,2 sortchrM.uniq100bp.map.base |join -j 2 -o 1.&#123;1,2&#125; 2.3 - &lt;(sort -k 2,2 mapping_uniq_site_depth.txt) |more</span><br><span class="line">  chrM 10 358</span><br><span class="line">  chrM 100 3497</span><br><span class="line">  chrM 10007 2202</span><br><span class="line">  chrM 10019 2213</span><br><span class="line">  chrM 10025 2493</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先按照ascii排序连接，然后将结果按照数字排序</span></span><br><span class="line">sort -k 2,2 sortchrM.uniq100bp.map.base |join -j 2 -o 1.&#123;1,2&#125; 2.3 - &lt;(sort -k 2,2 /Share/home/wangjb/songyabing/projects/mt/data/LJ_mt_677_2/chrM/mapping_uniq_site_depth.txt) |sort -k 2,2n |more</span><br><span class="line">  chrM 4 78</span><br><span class="line">  chrM 5 83</span><br><span class="line">  chrM 6 179</span><br><span class="line">  chrM 7 254</span><br><span class="line">  chrM 8 304</span><br><span class="line">  chrM 9 308</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.runoob.com/linux/linux-comm-join.html" target="_blank" rel="noopener">Linux join命令</a></li><li><a href="https://www.cnblogs.com/agilework/archive/2012/04/18/2454877.html" target="_blank" rel="noopener">linux下join命令的用法</a></li><li><a href="https://blog.csdn.net/K346K346/article/details/80237368" target="_blank" rel="noopener">Linux命令——join命令</a></li><li><a href="https://www.jianshu.com/p/97006b505cd6" target="_blank" rel="noopener">linux: join</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort-排序</title>
      <link href="/posts/61024.html"/>
      <url>/posts/61024.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文学习sort-对文件进行排序，主要包括了sort用法(命令格式、参数说明)、用法实例(各种参数：<code>-u</code>、<code>-n</code>、<code>-r</code>、<code>-k</code>、<code>-t</code>、<code>-o</code>、<code>-c</code>、<code>-h</code>和<code>-g</code>等的实例讲解)并在最后给出了几个非常常用的实战示例。</p></div><a id="more"></a><h2 id="sort简介和用法"><a href="#sort简介和用法" class="headerlink" title="sort简介和用法"></a>sort简介和用法</h2><ul><li><code>sort</code>命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</li><li><code>sort</code>命令既可以从<strong>特定的文件</strong>，也可以<strong>从stdin中获取输入</strong></li></ul><h3 id="sort命令格式"><a href="#sort命令格式" class="headerlink" title="sort命令格式"></a>sort命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  sort [OPTION] [FILE]</span><br></pre></td></tr></table></figure><hr><h3 id="sort-options说明"><a href="#sort-options说明" class="headerlink" title="sort options说明"></a>sort options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–ignore-leading-blanks</td><td>忽略每行前面开始出的空格字符</td></tr><tr><td>-d</td><td>–dictionary-order</td><td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符</td></tr><tr><td>-f</td><td>–ignore-case</td><td>排序时，将小写字母视为大写字母，亦即忽略大小写</td></tr><tr><td>-g</td><td>–general-numeric-sort</td><td>按通用数值排序，支持科学计数法</td></tr><tr><td>-i</td><td>–ignore-nonprinting</td><td>排序时，除了040至176之间的ASCII字符外，忽略其他的字符</td></tr><tr><td>-M</td><td>–month-sort</td><td>将前面3个字母依照月份的缩写进行排序 (unknown) &lt; ‘JAN’ &lt; … &lt; ‘DEC’</td></tr><tr><td>-m</td><td>–merge</td><td>将几个排序号的文件进行合并</td></tr><tr><td>-h</td><td>–human-numeric-sort</td><td>使用易读性数字(例如： 2K 1G)</td></tr><tr><td>-n</td><td>–numeric-sort</td><td>依照数值的大小排序</td></tr><tr><td>-o</td><td>–output=FILE</td><td>将排序后的结果存入指定的文件</td></tr><tr><td>-r</td><td>–reverse</td><td>降序排序，默认为升序</td></tr><tr><td>-t</td><td>–field-separator=SEP</td><td>指定排序时所用的栏位分隔字符</td></tr><tr><td>-k</td><td>–key=POS1[,POS2]</td><td>排序从POS1开始，若指定POS2，则POS2结束，否则以pos1排序</td></tr><tr><td>-u</td><td>–unique</td><td>去除重复的行</td></tr><tr><td>-c</td><td>–check</td><td>检查文件是否已经按照顺序排序</td></tr></tbody></table><hr><p><br></p><h2 id="sort用法实例"><a href="#sort用法实例" class="headerlink" title="sort用法实例"></a>sort用法实例</h2><h3 id="使用默认方式对文件进行排序"><a href="#使用默认方式对文件进行排序" class="headerlink" title="使用默认方式对文件进行排序"></a>使用默认方式对文件进行排序</h3><p><code>sort</code> 命令将以<strong>默认的方式</strong>将文本文件的<strong>第一列以ASCII码的次序排列</strong>，并将结果<strong>输出到标准输出</strong><br>测试文件default.txt:</p><blockquote><p><code>cat default.txt</code><br>test 30<br>Hello 95<br>Linux 25</p></blockquote><blockquote><p><code>sort default.txt</code><br>Hello 95<br>Linux 25<br>test 30</p></blockquote><hr><h3 id="u-去除重复行"><a href="#u-去除重复行" class="headerlink" title="-u 去除重复行"></a>-u 去除重复行</h3><blockquote><p><code>cat uniq.txt</code><br>test 30<br>Hello 95<br>Linux 25<br>Linux 25<br>Linux 20</p></blockquote><p>文件中存在两行完全相同的信息，这将其去除:</p><blockquote><p><code>sort -u uniq.txt</code><br>Hello 95<br>Linux 20<br>Linux 25<br>test 30</p></blockquote><p><strong>会考察所有的列是否相同来进行去除，只有第一列相同是不会进行去除的</strong></p><h3 id="n-对数字进行排序"><a href="#n-对数字进行排序" class="headerlink" title="-n 对数字进行排序"></a>-n 对数字进行排序</h3><blockquote><p><code>cat num.txt</code><br>10<br>20<br>30<br>110<br>120<br>210</p></blockquote><p>sort默认会<strong>把所有列当成字符来进行排序</strong>，因为1小于3，所以110小于20：</p><blockquote><p><code>sort num.txt</code><br>10<br>110<br>120<br>20<br>210<br>30</p></blockquote><p>为了避免上述情况，需要使用<code>-n</code>选项，声明是数字进行排序，而不是字符：</p><blockquote><p><code>sort -n num.txt</code><br>10<br>20<br>30<br>110<br>120<br>210</p></blockquote><hr><h3 id="h-带单位地排序"><a href="#h-带单位地排序" class="headerlink" title="-h-带单位地排序"></a>-h-带单位地排序</h3><p>结合du命令使用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">du -ah .  |sort -hr</span><br><span class="line">  518M.</span><br><span class="line">  259M./backup/backup_test/B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart.test</span><br><span class="line">  259M./backup/backup_test</span><br><span class="line">  259M./backup</span><br><span class="line">  259M./B2_FKDL190733335-1a-N702-N702_AHYYWCCCXY_L3_1.fq.gz.filepart</span><br><span class="line">  16K./test1.txt</span><br><span class="line">  12K./test2.txt</span><br><span class="line">  4.0K./test.txt</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>关于<code>sort</code> <code>-n</code>和<code>-h</code>参数的区别：</p><ul><li><code>-n</code>选项，按<strong>数值进行比较</strong>，只会<strong>傻傻地比较数字</strong>，它会<strong>认为 98 K大于 2G</strong></li><li><code>-h</code>选项，会更加聪明，先<strong>优先比较单位（G&gt;M&gt;K）</strong>，然后<strong>再对数值进行比较</strong></li></ul></div><hr><h3 id="r-降序排列"><a href="#r-降序排列" class="headerlink" title="-r 降序排列"></a>-r 降序排列</h3><p>从上面的输出结果可以看出：sort默认进行的是升序排列，为了能够得到降序排列的结果，需要使用参数<code>-r</code>：</p><blockquote><p><code>sort -n -r num.txt</code> 等价于 <code>sort -nr num.txt</code><br>210<br>120<br>110<br>30<br>20<br>10</p></blockquote><hr><h3 id="k-指定排序开始-和结束-的位置"><a href="#k-指定排序开始-和结束-的位置" class="headerlink" title="-k 指定排序开始(和结束)的位置"></a>-k 指定排序开始(和结束)的位置</h3><h4 id="k选项的语法格式"><a href="#k选项的语法格式" class="headerlink" title="-k选项的语法格式"></a>-k选项的语法格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FStart.CStart Modifie,FEnd.CEnd Modifier   <span class="comment"># 详细划分</span></span><br><span class="line">-------Start--------,-------End--------    <span class="comment"># 整体划分</span></span><br><span class="line">FStart.CStart 选项  ,  FEnd.CEnd 选项       <span class="comment"># 详细划分解读</span></span><br></pre></td></tr></table></figure><ul><li>这个语法格式可以被其中的逗号<code>,</code>分为两大部分，<strong>Start部分</strong>和<strong>End部分</strong></li><li><code>Start</code>部分也<strong>由两部分组成</strong>:<ul><li><strong>Modifier</strong>部分是<strong>选项部分</strong>，可以用到b、d、f、i、n 或 r。</li><li><code>FStart.CStart</code>，其中<code>FStart</code>就是表示使用的<strong>域</strong>而<code>CStart</code>则表示<strong>在FStart域中</strong>从<strong>第几个字符开始算“排序首字符”</strong>。<code>C.Start</code>也是可以省略的，<u>省略的话就表示从本域的开头部分开始</u></li></ul></li><li>同理，在<code>End</code>部分中，你可以设定<code>FEnd.CEnd</code>，如果你<strong>省略.CEnd，则表示结尾到“域尾”，即<u>本域</u>的最后一个字符</strong>。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”</li><li><mark>如果直接省略了<code>End</code>部分，则会直接从指定的开始位置到一行的结束进行排序</mark></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>从<strong>公司英文名称（第一个域）</strong>的<strong>第二个字母</strong>开始进行排序：</p><blockquote><p><code>sort -k 1.2 salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p><strong>结果解读：</strong>使用了<code>-k 1.2</code>，表示对<strong>第一个域</strong>的<strong>第二个字符开始到本域的最后一个字符为止</strong>的字符串进行排序，结果是baidu因为第二个字母是a而名列榜首，sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三，guge只能排在第四了。</p><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序：</p><blockquote><p><code>sort -k 1.2 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>可以发现这个与预期的结果并不一致，和没有按照员工工资进行降序排序的结果相同，所以命令肯定存在问题。首先，<code>-k 3nr</code>没有起作用，相当于只是用前面的<code>-k 1.2</code>就可以达到效果，事实上也正是如此，因为<code>-k 1.2</code>表示对<strong>第一个域</strong>的<strong>第二个字符开始到本域的最后一个字符为止</strong>的字符串进行排序，按照上一个示例的分析，可以将这些结果分开，所以就不存在上面所说的<code>如果相同的按照员工工资进行降序排序</code>，因此后面的排序也就没有了意义。随后基于此我做了一个测试，在最后一行增加”google 110 4500”，这样就存在了<code>-k 1.2</code>不能讲所有的分开是现象，依旧使用上面的命令进行排序：</p><blockquote><p><code>sort -k 1.2 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>发现上述并没有按照我预定的<code>-k 1.2</code>不能讲所有的分开，然后就按照第二个指定的<code>-k 3nr</code>进行排序，然后我去google上搜索相关问题发现<a href="https://unix.stackexchange.com/questions/78925/how-to-sort-by-multiple-columns?rq=1" target="_blank" rel="noopener">有个回答</a>说<mark>对多行进行排序时需要指定sort keys的开始和结束，如果没指定结束就会在一直到一行的末尾结束（可能是因为第一个key是主key），不会考虑后面继续设置的key</mark>，基于此，做了测试：</p><blockquote><p><code>sort -k 1.2,1 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>google 110 4500<br>guge 50 3000</p></blockquote><p>最终得到了正确的结果，使用<code>-k 1.2,1</code>是<strong>省略.CEnd，则表示结尾到“域尾”</strong>，同时吸取上面的教训，为了严谨期间，虽然第3列是最后一列，也直接加上sort key的结束位置：<code>sort -k 1.2,1 -k 3,3nr salary.txt</code>，结果和上面相同</p><div class="note info"><ul><li><code>-k 3nr</code>：表示在第3列上进行按数字的降序进行排列</li><li><strong>对不同的列进行不同的排序方式时尤其需要指定sort key的结束为止，如果不指定，会以第一个key设置的为主，忽略后续key的设置，这个在对不同的列分别依据ascii和数字进行排序中非常常见</strong></li></ul></div><hr><h3 id="t-指定field分隔符"><a href="#t-指定field分隔符" class="headerlink" title="-t 指定field分隔符"></a>-t 指定field分隔符</h3><p>sort使用<code>-t</code>参数来<strong>指定分隔符</strong>，<strong>默认的分隔符为空格(包括空格和tab)</strong>:</p><blockquote><p><code>cat sep.txt</code><br>aaa:eee<br>ccc:eee<br>ddd:ddd<br>bbb:ccc<br>eee:bbb<br>eee:aaa</p></blockquote><p>以<code>:</code>为分隔符，对<strong>第二列</strong>进行排序：</p><blockquote><p><code>sort -t : -k 2 sep.txt</code><br>eee:aaa<br>eee:bbb<br>bbb:ccc<br>ddd:ddd<br>aaa:eee<br>ccc:eee</p></blockquote><p>当然也可以<strong>指定列来判断重复与否</strong>，并进行删除：</p><blockquote><p><code>sort -t : -uk 2 sep.txt</code><br>eee:aaa<br>eee:bbb<br>bbb:ccc<br>ddd:ddd<br>aaa:eee</p></blockquote><hr><h3 id="o-输出到文件"><a href="#o-输出到文件" class="headerlink" title="-o 输出到文件"></a>-o 输出到文件</h3><p>输出到文件也可以使用重定向<code>&gt;</code>进行操作，但是<strong>如果使用重定向想要写入原文件，这个时候不但写不进去，还把原文件清空了</strong></p><p>这个问题可以很好的使用<code>-o</code>参数解决，<code>-o</code>后面接原文件，即<strong>可将重排序的结果写入原文件</strong></p><hr><h3 id="c-检查文件是否已经排序"><a href="#c-检查文件是否已经排序" class="headerlink" title="-c 检查文件是否已经排序"></a>-c 检查文件是否已经排序</h3><p><strong>如果乱序，则输出第一个乱序的行的相关信息</strong></p><blockquote><p><code>sort -c uniq.txt</code><br>sort: uniq.txt:2: disorder: Hello 95</p></blockquote><hr><h3 id="V-对字符和数组混合排序"><a href="#V-对字符和数组混合排序" class="headerlink" title="-V-对字符和数组混合排序"></a>-V-对字符和数组混合排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chr21 Any </span><br><span class="line">chr2 Data </span><br><span class="line">chr3 Or </span><br><span class="line">chrY Information </span><br><span class="line">chr1 Some </span><br><span class="line">chr3 Annotation </span><br><span class="line">chr10 Or </span><br><span class="line">chrX Other</span><br></pre></td></tr></table></figure><p>使用<code>sort</code>排序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort -k 1,1 -V test.txt </span><br><span class="line">  chr1 Some </span><br><span class="line">  chr2 Data </span><br><span class="line">  chr3 Annotation </span><br><span class="line">  chr3 Or </span><br><span class="line">  chr10 Or </span><br><span class="line">  chr21 Any </span><br><span class="line">  chrX Other</span><br><span class="line">  chrY Information</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="对多行进行排序并进行去重"><a href="#对多行进行排序并进行去重" class="headerlink" title="对多行进行排序并进行去重"></a>对多行进行排序并进行去重</h3><p>示例文件：含有google共有三行，其中有两行1、2列是完全相同的，有一行是第一列是相同的：</p><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br><strong>google 110 5000</strong><br>guge 50 3000<br><strong>google 110 4500</strong><br><strong>google 120 4500</strong></p></blockquote><p><strong>对1、2列进行排序并删除在这两列上的重复行：</strong></p><blockquote><p><code>sort -uk 1,2 salary.txt</code><br>baidu 100 5000<br><strong>google 110 5000</strong><br><strong>google 120 4500</strong><br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>可以发现达到了目的</p><p>只针对第一列来看：</p><blockquote><p><code>sort -uk 1 salary.txt</code><br>baidu 100 5000<br>google 110 4500<br>google 110 5000<br>google 120 4500<br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>这个并没有达到目的，和前面提到的<code>-k</code>选项中提到的一样，<strong>必须要指定终止位置</strong>，<strong>不然会比较整个行</strong>，这样最终结果是没有重复的，如果在上面文件中<strong>故意加一行重复的</strong>，还果真如此，比较的是整个行：</p><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000<br>google 110 4500<br><strong>google 120 4500</strong><br><strong>google 120 4500</strong></p></blockquote><blockquote><p><code>sort -uk 1 salary.txt</code><br>baidu 100 5000<br>google 110 4500<br>google 110 5000<br><strong>google 120 4500</strong><br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>增加终止位置，得到预期结果：</p><blockquote><p><code>sort -uk 1,1 salary.txt</code><br>baidu 100 5000<br>google 110 5000<br>guge 50 3000<br>sohu 100 4500</p></blockquote><p><strong>第一列相同的行中进行去重复保留的是原始文件中第一个出现的</strong></p><hr><h3 id="对文件大小进行排序"><a href="#对文件大小进行排序" class="headerlink" title="对文件大小进行排序"></a>对文件大小进行排序</h3><p><code>-h</code>：排序时使用易读性数字(例如： 2K 1G)</p><p><strong>统计目录下子目录的大小，并按大小进行降序排列：</strong></p><blockquote><p><code>du -h |sort -hr</code> # <code>du -h</code>统计目录下子目录的大小<br>2.6G ./test2<br>2.6G . # 整个目录大小<br>6.8M ./test<br>4.0K ./test3</p></blockquote><hr><h3 id="系统进程内存占用排序"><a href="#系统进程内存占用排序" class="headerlink" title="系统进程内存占用排序"></a>系统进程内存占用排序</h3><p><code>-g</code>：按通用数值排序，支持科学计数法</p><blockquote><p><code>ps aux |less -S</code><br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p></blockquote><blockquote><p><code>ps aux|sort -gr -k 4|head -n 5|awk &#39;{print $2,$3,$4}&#39;</code><br>10742 0.0 0.8<br>3916 99.5 0.7<br>110870 99.5 0.4<br>131268 99.5 0.3<br>66967 0.0 0.0</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html" target="_blank" rel="noopener">linux sort 命令详解</a></li><li><a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-sort.html" target="_blank" rel="noopener">Linux sort命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串截取方法</title>
      <link href="/posts/43811.html"/>
      <url>/posts/43811.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>字符串截取在平常的工作中非常常用，这里总结常用的截取方法，便于查阅和温习，主要包括：<code>${}</code>的<strong>字符串截取</strong>和<strong>正则匹配</strong>、<code>cut</code>命令的<code>-c</code>参数、<code>awk</code>的<code>substr</code>函数和<code>FS</code>内置参数以及<code>expr</code>的<code>substr</code>表达式</p></div><a id="more"></a><h2 id="使用-进行截取"><a href="#使用-进行截取" class="headerlink" title="使用${}进行截取"></a>使用<code>${}</code>进行截取</h2><p><code>${}</code>是一种非常常用的linux特殊符号，一般来说共有五种不同的功能，具体的是哪五种功能，之前已经写过<a href="http://showteeth.tech/posts/55603.html">一篇博文</a>，这里就不赘述了，这里主要用示例的形式讲解其中与字符串截取相关的两种功能：<strong>字符串截取</strong>和<strong>正则匹配替换</strong>。</p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><ul><li><code>${str:offest}</code>：从<strong>字符串开头（左侧）下标offset(含)开始截取到末尾</strong>的子串</li><li><code>${str:offest:length}</code>：从<strong>字符串开头（左侧）下标offset(含)开始向后截取长度为length</strong>的子串，长度超出不报错</li><li><code>${str:0-offset:length}</code>：从<strong>字符串尾端（右侧）下标offset(含)开始以及<u>向后</u>截取长度为length</strong>的子串</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"http://showteeth.tech/posts/55603.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取从下标5到字符串结尾的子串，注意下标是从0开始的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从下标5开始截取长度为10的子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5:10&#125;</span></span><br><span class="line"><span class="comment"># 字符长度超出不会报错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5:40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右数下标15开始截取长度为10的子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0-15:10&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="http://showteeth.tech/posts/55603.html">http://showteeth.tech/posts/55603.html</a><br>ttp://showteeth.tech/posts/55603.html<br>//showteeth.tech/posts/55603.html</p></blockquote><blockquote><p>//showteet<br>//showteeth.tech/posts/55603.html</p></blockquote><blockquote><p>osts/55603</p></blockquote><div class="note info"><ul><li><code>下标（offset）</code>从0开始 <strong>（注意与使用<code>awk</code>的<code>substr</code>函数进行字符截取不同）</strong></li><li><code>${str:0-offset:length}</code>是从字串右侧开始数坐标，然后和正常的一样，向后截取长度</li></ul></div><hr><h3 id="正则匹配替换"><a href="#正则匹配替换" class="headerlink" title="正则匹配替换"></a>正则匹配替换</h3><ul><li><code>${\#parameter}</code>：获取变量长度</li><li><code>${parameter#word}</code>、<code>${parameter##word}</code>：<strong>从头开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>#</code>为<strong>最短</strong>匹配，<code>##</code>为<strong>最长</strong>匹配</li><li><code>${parameter%word}</code>、<code>${parameter%%word}</code>：<strong>从尾开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>%</code>为<strong>最短</strong>匹配，<code>%%</code>为<strong>最长</strong>匹配</li><li><code>${parameter/pattern/string}</code>、<code>${parameter//pattern/string}</code>：使用string替换pattern，<code>/</code>表示<strong>只替换一次</strong>；<code>//</code>表示<strong>全部替换</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取变量长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边开始删除第一次出现子字符串即其左边字符，保留右边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str#*/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边开始删除最后一次出现子字符串即其左边字符，保留符号最右边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str##*/&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始删除第一次出现子字符串即其右边字符，保留左边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%/*&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始删除最后一次出现子字符串即其右边字符，保留最左边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%%/*&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换，只替换第一次出现的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str/\//%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换，所有匹配的都进行替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str//\//%&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>38</p></blockquote><blockquote><p>/showteeth.tech/posts/55603.html<br>55603.html</p></blockquote><blockquote><p><a href="http://showteeth.tech/posts">http://showteeth.tech/posts</a><br>http:</p></blockquote><blockquote><p>http:%/showteeth.tech/posts/55603.html<br>http:%%showteeth.tech%posts%55603.html</p></blockquote><div class="note info"><ul><li><code>#</code>在<code>%</code>的左边，所以<code>#</code>是从左向右删除字符，保留右边子串，而<code>%</code>是从右向左删除字符，保留左边字符</li><li>一个<code>#</code>或<code>%</code>是匹配并删除第一次出现的pattern，而<code>##</code>或<code>%%</code>是匹配并删除最后一次出现的pattern（相当于贪婪匹配）</li><li>上述的<code>parameter</code>都是可以不用引用的，因为<code>${var}</code>本来就和<code>$var</code>是一个意思</li></ul></div><hr><p><br></p><h2 id="使用awk进行截取"><a href="#使用awk进行截取" class="headerlink" title="使用awk进行截取"></a>使用awk进行截取</h2><p>使用<code>awk</code>中的<code>substr</code>函数，<code>substr()</code>用于从字符串中<strong>指定位置</strong>和<strong>长度</strong>截取出子串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usage：</span><br><span class="line">  substr(s, i [, n])</span><br><span class="line">    s 待截取的字符串</span><br><span class="line">    i 索引位置，从1开始，按照字符计算、非字节</span><br><span class="line">    n 要截取的长度，默认或者填写长度超出字符尾，则截取到字符尾</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |awk <span class="string">'&#123;print substr($str,5,10)&#125;'</span></span><br></pre></td></tr></table></figure><blockquote><p>://showtee</p></blockquote><p>也可以使用<code>awk</code>指定<strong>输入分割符</strong>的方式截取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |awk -v FS=<span class="string">"/"</span> <span class="string">'&#123; print $3 &#125;'</span></span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>注意这里与使用<code>${}</code>进行字符串截取不同，这里字符的<strong>索引开始为1</strong>，而上面<code>${}</code>索引<strong>开始位置为0</strong></li><li><code>FS</code>是awk内置的系统变量，表示<strong>域分隔符</strong>，默认为空白字符（空格），使用时需要结合<code>-v</code>来传递参数</li></ul></div><hr><p><br></p><h2 id="使用cut进行截取"><a href="#使用cut进行截取" class="headerlink" title="使用cut进行截取"></a>使用cut进行截取</h2><p><strong>直接通过范围得到子串：</strong><br><code>cut</code>命令的<code>-c</code>参数：<strong>仅显示行中指定范围的字符</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |cut -c 2-6</span><br></pre></td></tr></table></figure><p></p><blockquote><p>ttp:/</p></blockquote><div class="note warning"><ul><li>注意这里与使用<code>${}</code>进行字符串截取<strong>不同</strong>，与使用<code>awk</code>的<code>substr</code>函数进行字符截取<strong>相同</strong>，这里字符的<strong>索引开始为1</strong>，而上面<code>${}</code>索引<strong>开始位置为0</strong></li><li><code>cut</code> <code>-c</code> 后面接的是<code>index的起始和终止范围</code>，而不是像前面的<code>awk</code>和<code>${}</code>一样是<strong>index</strong>和<strong>length</strong>的组合</li></ul></div><p><strong>利用cut按分割符分割来得到子串：</strong></p><ul><li><code>cut</code>命令的<code>-d</code>参数：<strong>指定字段的分隔符，默认的字段分隔符为”TAB”</strong></li><li><code>cut</code>命令的<code>-f</code>参数：<strong>指定需要显示的字段</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |cut -d / -f 3</span><br></pre></td></tr></table></figure><blockquote><p>showteeth.tech</p></blockquote><div class="note info"><p><code>cut</code>命令的<code>-d</code>和<code>-f</code>参数合用主要用于得到被<strong>已知分隔符</strong>分割的<strong>一块子串</strong></p></div><hr><p><br></p><h2 id="使用expr进行截取"><a href="#使用expr进行截取" class="headerlink" title="使用expr进行截取"></a>使用expr进行截取</h2><p><code>expr</code>用于计算表达式变量的值，其中有表达式：<code>substr String StartPosition Length</code>，表示<strong>从String的StartPosition开始截取Length的子串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr substr <span class="variable">$str</span> 2 6</span><br></pre></td></tr></table></figure><blockquote><p>ttp://</p></blockquote><div class="note info"><ul><li>注意每个单词之间都有空格，不带空格会出错</li><li>索引位置也是从1开始，和<code>awk</code>的<code>substr</code>函数、<code>cut</code>命令的<code>-c</code>参数相同，和<code>${}</code>不同</li></ul></div><hr><p><br></p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><div class="note info"><ul><li>一般最为常用的是<code>${}</code>的<strong>正则匹配替换</strong>方法(保留字符串最左或者最右的子串)，同时awk和cut使用的也非常多</li><li>使用需要提供索引位置的方法时需要注意索引的开始位置：<ul><li><code>awk</code>的<code>substr</code>函数、<code>cut</code>命令的<code>-c</code>参数还有expr的substr表达式索引都是从1开始</li><li><code>${str:offest:length}</code>方法的索引则开始于0</li></ul></li><li><code>${}</code>、<code>cut</code>命令的<code>-c</code>参数以及<code>awk</code>的<code>FS</code>内置参数都是用于通过<strong>已知分割符</strong>得到相应的<strong>一块子串</strong>，而不是具体地通过索引位置</li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数计算、浮点计算并保留小数</title>
      <link href="/posts/28430.html"/>
      <url>/posts/28430.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在linux中进行整数计算、浮点计算并保留小数，主要包括：使用<code>expr</code>进行<strong>整数运算</strong>以及<strong>简单的字符串操作</strong>、<code>let</code>、<code>(( ))</code>、<code>$(())与declare -i</code>、<code>$[]</code>进行<strong>整数运算</strong>、使用<code>bc</code>进行<strong>浮点运算</strong>和<strong>进制转换</strong>以及使用<code>awk</code>进行<strong>浮点运算</strong>。</p></div><a id="more"></a><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>shell中默认的操作都是字符操作，如果想要进行数学运算，简单的shell操作可能得不到预期的结果：</p><blockquote><p>a=1<br>b=1<br>echo $a + $b<br><strong>1 + 1</strong></p></blockquote><p>所以为了执行数学计算就需要有专门的命令来进行操作，以下介绍几种常用的命令和特殊符号。</p><h3 id="expr-整数或字符串表达式计算"><a href="#expr-整数或字符串表达式计算" class="headerlink" title="expr 整数或字符串表达式计算"></a>expr 整数或字符串表达式计算</h3><p><code>expr</code>语法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 表达式</span><br></pre></td></tr></table></figure><p></p><p>表达式说明:</p><ul><li><strong><code>expr</code>只能用于整数计算</strong></li><li>用<strong>空格隔开</strong>每个项</li><li><strong>用<code>/</code>(反斜杠)放在shell特定的字符</strong>前面</li><li><strong>对包含空格和其他特殊字符的字符串要用引号括起来</strong></li></ul><h4 id="整数计算"><a href="#整数计算" class="headerlink" title="整数计算"></a>整数计算</h4><table><tr><th width="10%">类别</th><th width="20%">语法</th><th width="70%">说明</th></tr><tr><td rowspan="2">四则运算</td><td>expr1 \| expr2</td><td>如果 expr1 不是零或 null 则传回 expr1，否则传回 expr2</td></tr><tr><td>expr1 \&amp; expr2</td><td>如果 expr1 及 expr2 都不为零或 null，则传回 expr1，否则传回 0</td></tr><tr><td rowspan="5">四则运算</td><td>expr1 + expr2</td><td>传回 expr1 加 expr2 后的值</td></tr><tr><td>expr1 - expr2</td><td>传回 expr1 减 expr2 后的值</td></tr><tr><td>expr1\* expr2</td><td>传回 expr1 乘 expr2 后的值</td></tr><tr><td>expr1 / expr2</td><td>传回 expr1 除 expr2 后的整数位值（小数位直接丢弃，不四舍五入）</td></tr><tr><td>expr1 % expr2</td><td>传回 expr1 除 expr2 的余数</td></tr><tr><td rowspan="6">大小判断</td><td>expr1 \&gt; expr2</td><td>如果 expr1 大于 expr2 则传回 1，否则传回 0。如果 expr1 及 expr2 都是数字，则是以数字大小判断，否则是以文字判断。以下皆同</td></tr><tr><td>expr1 \&lt; expr2</td><td>如果 expr1 小于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 = expr2</td><td>如果 expr1 等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 != expr2</td><td>如果 expr1 不等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 \&gt;= expr2</td><td>如果 expr1 大于或等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 \&lt;= expr2</td><td>如果 expr1 小于或等于 expr2 则传回 1，否则传回 0</td></tr></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">expr 2+3</span><br><span class="line">expr 2 + 3</span><br><span class="line"></span><br><span class="line">expr 2 * 3</span><br><span class="line">expr 2 \* 3</span><br><span class="line"></span><br><span class="line">expr 5 / 3</span><br><span class="line"></span><br><span class="line">expr 2 % 3</span><br></pre></td></tr></table></figure><blockquote><p>2+3 # 2和3之间没有空格，直接被输出，没有进行计算<br>5 # 输出正确结果</p></blockquote><blockquote><p>expr: syntax error # 因为没有对<code>*</code>进行转义，所以报错<br>6 # 转义后输出正确结果</p></blockquote><blockquote><p>1 # 直接去掉余数，不进行四舍五入</p></blockquote><blockquote><p>2 # 输出余数</p></blockquote><hr><h4 id="字符串表达式计算"><a href="#字符串表达式计算" class="headerlink" title="字符串表达式计算"></a>字符串表达式计算</h4><p>因为<code>expr</code>用于字符串计算并不常见，所以这里不仔细了解，只了解几个个人感觉比较常用的，需要了解的可以参考<a href="https://blog.csdn.net/guhong5153/article/details/6542995" target="_blank" rel="noopener">这篇博客</a></p><p><strong>计算字串长度(length)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr length <span class="string">"this is a test"</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>14</p></blockquote><p><strong>截取子串(substr)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># substr String StartPosition Length</span></span><br><span class="line">expr substr <span class="string">"this is a test"</span> 3 5</span><br></pre></td></tr></table></figure><p></p><blockquote><p>is is</p></blockquote><p><strong>匹配第一个字符(串)出现的位置(index)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr index <span class="string">"this is a test"</span> is</span><br></pre></td></tr></table></figure><p></p><blockquote><p>3</p></blockquote><div class="note info"><p>注意四则运算中的<code>*</code>需要进行转义处理，同时还有条件判断中的<code>|</code> <code>&amp;</code>和大小判断中的<code>&gt;</code> <code>&lt;</code>都需要进行转义处理</p></div><hr><p><br></p><h3 id="let-运算并赋值"><a href="#let-运算并赋值" class="headerlink" title="let-运算并赋值"></a>let-运算并赋值</h3><p><code>let</code> 命令是 BASH 中用于计算的工具，用于<strong>执行一个或多个表达式</strong>，变量计算中<strong>不要加上 <code>$</code> 来表示变量(否则会报错)</strong>。如果表达式中<strong>包含了空格或其他特殊字符，则必须引起来</strong>(可以看出来与<code>expr</code>命令每个都需要空格隔开不同，<code>let</code>命令最好不要有空格)。</p><ul><li>自加操作：<code>let no++</code></li><li>自减操作：<code>let no--</code></li><li>简写形式 <code>let no+=10</code>，<code>let no-=20</code>，分别等同于 <code>let no=no+10</code>，<code>let no=no-20</code></li></ul><blockquote><p>let var +=1 //存在空格但是不带引号会报错<br>-bash: let: +=1: syntax error: operand expected (error token is “+=1”)</p></blockquote><blockquote><p>let “var +=1” //增加引号即可<br>echo $var<br>2</p></blockquote><blockquote><p>let $var+=1 //加上 <code>$</code> 来表示变量会报错<br>-bash: let: 2+=1: attempted assignment to non-variable (error token is “+=1”)</p></blockquote><blockquote><p>let var+=1 //不加 <code>$</code> 正常<br>echo $var<br>3</p></blockquote><blockquote><p>a=1<br>b=2<br>let c=a+b //赋值操作<br>echo $c<br>3</p></blockquote><hr><h3 id="执行计算"><a href="#执行计算" class="headerlink" title="((  )) 执行计算"></a>(( )) 执行计算</h3><p>和linux<code>let</code>指令相似，比<code>let</code>命令好的方面是<strong>可以在括号内加空格，不会报错</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自加操作</span></span><br><span class="line">a=5;b=7</span><br><span class="line">((a--));<span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用在for循环中</span></span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;5;i++));<span class="keyword">do</span> <span class="built_in">echo</span>  <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">((c=b+1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加空格</span></span><br><span class="line">(( c = b + 1 ))</span><br></pre></td></tr></table></figure><hr><h3 id="与declare-i-整数运算"><a href="#与declare-i-整数运算" class="headerlink" title="$(())与declare -i 整数运算"></a>$(())与declare -i 整数运算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i total=<span class="variable">$firstnu</span>*<span class="variable">$secnu</span></span><br><span class="line">total=$((<span class="variable">$firstnu</span>*<span class="variable">$secnu</span>))</span><br></pre></td></tr></table></figure><p>区别就是<strong>小方括号内可以加上空格符，也是合法的写法</strong>，而declare -i 不可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2*3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2* 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错</span></span><br><span class="line">total=$((2*3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取</span></span><br><span class="line">a=5;b=7;c=2</span><br><span class="line"><span class="built_in">echo</span> $((a+b*c))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>+<span class="variable">$b</span>*<span class="variable">$c</span>))</span><br></pre></td></tr></table></figure><p><code>declare -i</code>加空格报错：</p><blockquote><p>bash: declare: 2<em>: syntax error: operand expected (error token is “</em>“)</p></blockquote><p><code>$(())</code>在等号左右加空格报错：</p><blockquote><p>bash: 6: command not found</p></blockquote><p><strong><code>$(())</code>进制转化：将其他进制转成十进制数显示出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值</span></span><br><span class="line"><span class="built_in">echo</span> $((N<span class="comment">#xx))</span></span><br></pre></td></tr></table></figure><hr><h3 id="运算"><a href="#运算" class="headerlink" title="$[]运算"></a>$[]运算</h3><blockquote><p>a=1<br><code>echo $[a+1]</code><br>2</p></blockquote><blockquote><p>echo $[c=a+1]<br>2 //会先输出运算的结果<br>echo $c<br>2 //也会赋值</p></blockquote><hr><p><br></p><h2 id="浮点计算并保留小数"><a href="#浮点计算并保留小数" class="headerlink" title="浮点计算并保留小数"></a>浮点计算并保留小数</h2><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p><code>bc</code>命令是任意精度计算器语言，通常在linux下当计算器用, 它类似基本的计算器, 使用这个计算器可以做基本的数学运算。</p><p>常用的运算：</p><ul><li>+ 加法</li><li>- 减法</li><li>* 乘法</li><li>/ 除法</li><li>^ 指数</li><li>% 余数</li><li>sqrt 开方</li></ul><p>语法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc (选项) (参数)</span><br></pre></td></tr></table></figure><p></p><p>在shell中直接输入<code>bc</code>即可进入交互式界面，类似于没有图形界面的计算器，输入表达式得到结果<br>具体用法不详细讲解，可以参考<a href="https://www.cnblogs.com/lovevivi/p/4359296.html" target="_blank" rel="noopener">这篇博客</a></p><p><strong>实际进行浮点运算常用的方法是通过管道符：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage:</span><br><span class="line">  <span class="built_in">echo</span>  <span class="string">'scale=num; expression'</span>|bc</span><br><span class="line">    num：表示保留的小数点后位数</span><br><span class="line">    expression：表示计算表达式</span><br></pre></td></tr></table></figure><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;2/3'</span> |bc</span><br></pre></td></tr></table></figure><blockquote><p>.66</p></blockquote><p><strong>可以发现上述输出结果中并没有0(因为结果小于0)，如果想要显示可以使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>0.66</p></blockquote><p><strong>bc还能用来进行进制的转换：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usage：</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"obase=base;ibase=base;num"</span> | bc</span><br><span class="line">    obase:输出数字的进制，默认值为10</span><br><span class="line">    ibase:输入数字的进制，默认值为10</span><br><span class="line">    num:进行进制转换的数字</span><br><span class="line">    obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的</span><br></pre></td></tr></table></figure><p></p><p>obase如果放在ibase后可能会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"obase=10;ibase=2;110"</span> | bc</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ibase=2;obase=10;110"</span> | bc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>6<br>110</p></blockquote><hr><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk中的计算，默认支持浮点运算：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> |awk <span class="string">'&#123;print 2/3&#125;'</span></span><br></pre></td></tr></table></figure><p></p><p><strong>格式化输出：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line"><span class="built_in">echo</span> |awk <span class="string">'&#123;printf("%.2f\n" , 3/50)&#125;'</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中特殊符号用法</title>
      <link href="/posts/55603.html"/>
      <url>/posts/55603.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>Linux常见特殊符号作用，包括<code>#</code>、<code>~</code>、<code>~+</code>、<code>~-</code>、<code>;</code>、<code>;;</code>、<code>.</code>、<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>`</code>、<code>,</code>、<code>/</code>、<code>\</code>、<code>|</code>、<code>!</code>、<code>:</code>、<code>*</code>、<code>**</code>、<code>$</code>、<code>$$</code>、<code>?</code>、<code>${}</code>、<code>$*</code>、<code>$@</code>、<code>$#</code>、<code>$(())</code>、<code>(())</code>、<code>()</code>、<code>{}</code>、<code>[]</code>、<code>[[]]</code>、<code>||</code> 、<code>&amp;&amp;</code>、<code>\&lt;...\&gt;</code>和文件操作符以及重定向。</p></div><a id="more"></a><h2 id="号-注释"><a href="#号-注释" class="headerlink" title="#号-注释"></a>#号-注释</h2><p>在脚本中 <code>#</code>也常出现在一行的<strong>开头</strong>,或者位于<strong>完整指令之后</strong>,这类情况表示符号后边是<strong>注解文字,不会被执行</strong>，如果被<u>用在指令</u>中，或者<u>引号、双引号括住</u>的话，或者<u>在反斜线的后面</u>，那他就变成<strong>一般符号</strong>，不具上述的特殊功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#this line is comments</span></span><br></pre></td></tr></table></figure><hr><h2 id="home目录"><a href="#home目录" class="headerlink" title="~ home目录"></a>~ home目录</h2><p>代表使用者的<strong>home目录</strong>：<code>cd ~</code>表示进入home目录；也可以<strong>直接在符号后加上某帐户</strong>的名称：<code>cd ~user</code>表示进入这个user的home目录；或者<strong>当成是路径的一部份</strong>：<code>~/bin</code></p><p><code>~+</code>表示当前的工作目录</p><p><code>~-</code>表示上一个工作目录，这个在目录切换很好用啊，<code>cd ~-</code>直接<strong>进入上一次cd之前的目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">echo</span> ~+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入上一次cd之前的目录</span></span><br><span class="line"><span class="built_in">cd</span> ~-</span><br><span class="line"><span class="comment"># 进入上一次cd之前目录下的test目录</span></span><br><span class="line"><span class="built_in">cd</span> ~-/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure><hr><h2 id="分号"><a href="#分号" class="headerlink" title="; 分号"></a>; 分号</h2><p><strong>连续命令之间起到连接作用</strong>，命令之间没有依赖，<mark>不管上一条命令是否执行成功，分号后的命令都会执行</mark>。</p><hr><h2 id="连续分号"><a href="#连续分号" class="headerlink" title=";;连续分号"></a>;;连续分号</h2><p>专用在<code>case（多分支条件判断）</code>的选项，担任 <code>Terminator</code> 的角色</p><hr><h2 id="点号-dot"><a href="#点号-dot" class="headerlink" title=". 点号(dot)"></a>. 点号(dot)</h2><ul><li>在<strong>目录</strong>中：一个<code>.</code>表示当前目录，两个<code>..</code>表示上层目录</li><li>在<strong>文件命名</strong>中：以<code>.</code>开头的文件表明该文件是<strong>隐藏文件</strong>，需要使用<code>ls -a</code>才能看到</li><li>在<strong>正则表达式</strong>中：一个逗号表示一个任意字符（换行符 \n 之外），如果想要匹配<code>.</code>，需要使用转义<code>\.</code>。</li></ul><h2 id="‘’-单引号"><a href="#‘’-单引号" class="headerlink" title="‘’ 单引号"></a>‘’ 单引号</h2><p>被单引号用括住的内容，将被视为<code>单一字串</code>，其<mark>不允许任何变量、元字符、通配符、转义符的解析</mark>，例如<strong>在引号内的代表变量的<code>$</code>符号，没有作用</strong>，也就是说，他被视为一般符号处理，<strong>防止任何变量替换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$test'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">'s/hello/$test/'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p><code>$</code>test</p></blockquote><blockquote><p><code>$</code>test WORLD</p></blockquote><hr><h2 id="“”-双引号"><a href="#“”-双引号" class="headerlink" title="“” 双引号"></a>“” 双引号</h2><p>被双引号用括住的内容，将被视为<code>单一字串</code>，其能<mark>保护特殊元字符和通配符不被shell解析，但是允许变量和命令替换，以及转义符的解析</mark>，这点与单引号的处理方式不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$test</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">"s/hello/<span class="variable">$test</span>/"</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>hello</p></blockquote><blockquote><p>HELLO WORLD</p></blockquote><hr><h2 id="反引号"><a href="#反引号" class="headerlink" title="`` 反引号"></a>`` 反引号</h2><p>在前面的<strong>单双引号，括住的是字串</strong>，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用反引号来做，被<strong>反引号括住的内容是可以执行的</strong>。</p><p>与反引号相同可以用来进行命令执行的还有<code>$()</code>，两者的区别在于<mark>如果是使用反引号执行命令在进行命令嵌套时会比较麻烦，而使用<code>$()</code>进行命令的嵌套会比较简单</mark>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$test</span>`</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$test</span>)</span><br></pre></td></tr></table></figure><p>命令嵌套：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$test</span>))</span><br></pre></td></tr></table></figure><p>不等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$test</span>``</span><br></pre></td></tr></table></figure><p><strong>反引号遇到第一个匹配的反引号就结束，之间的内容会当做命令运行，可以使用转义字符<code>\</code>解决嵌套问题</strong></p><p>等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> \`<span class="built_in">echo</span> <span class="variable">$test</span>\``</span><br></pre></td></tr></table></figure><div class="note info"><p>所以还是使用<code>$()</code>来得到命令执行结果更为简便，但是不需要嵌套时两者差不多</p></div><hr><h2 id="逗号"><a href="#逗号" class="headerlink" title=", 逗号"></a>, 逗号</h2><p>这个符号常运用在运算当中当做<strong>区隔用途</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1,$2,$3,$4&#125;'</span> filename</span><br></pre></td></tr></table></figure><hr><h2 id="斜线"><a href="#斜线" class="headerlink" title="/ 斜线"></a>/ 斜线</h2><ul><li>在路径表示时，<strong>分割不同级别的目录</strong></li><li>单一的斜线<code>/</code>表示根目录，和上面的<code>~</code>表示的家目录不同</li><li>在四则运算中，代表<strong>除法的符号</strong></li></ul><h2 id="反斜线"><a href="#反斜线" class="headerlink" title="\ 反斜线"></a>\ 反斜线</h2><p>在交互模式下的escape字元，有几个作用</p><ul><li>放在<strong>指令前</strong>，有<strong>取消 aliases</strong>的作用；</li><li>放在<strong>特殊符号</strong>前，则该<strong>特殊符号的作用消失（转义）</strong>；</li><li>放在<strong>指令的最末端</strong>，表示指令<strong>连接下一行</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l</span></span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消ll代表ls -l，在ll之前防止反斜线表示暂时取消别名的功能，将 ll 指令还原</span></span><br><span class="line">\ll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转义，取消变量应用</span></span><br><span class="line">\<span class="variable">$test</span></span><br></pre></td></tr></table></figure><p>最终ll结果输出：</p><blockquote><p>bash: ll: command not found</p></blockquote><hr><h2 id="管道符"><a href="#管道符" class="headerlink" title="| 管道符"></a>| 管道符</h2><p><strong>连结上个指令的标准输出，做为下个指令的标准输入</strong>。</p><hr><h2 id="惊叹号"><a href="#惊叹号" class="headerlink" title="! 惊叹号"></a>! 惊叹号</h2><ul><li>通常它代表反逻辑的作用，如<code>!=</code>表示不等于</li><li>匹配模式取反：<code>sed -n &#39;1,2!p&#39; test.txt</code>表示打印第1、2行之外的行；<code>ls a[!0-9]</code>表示显示除了a0, a1 …. a9 这几个文件的其他文件</li><li>在历史命令（history）中：<ul><li><code>!number</code> ：表示执行history中<strong>第number条命令</strong></li><li><code>!!</code>：表示执行<strong>上一条命令</strong></li><li><code>!command</code>：执行<strong>最近一条command为开头的命令</strong></li><li><code>!$</code>：表示<strong>最近一条命令的第二个字符信息</strong></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line">!!</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>mkdir test<br>mkdir: cannot create directory `test’: File exists</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line">!$</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>test</p></blockquote><hr><h2 id="冒号"><a href="#冒号" class="headerlink" title=": 冒号"></a>: 冒号</h2><ul><li>在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0</li><li><code>: &gt; f</code>：相当于<code>cat/dev/null&gt;f</code>，这样不仅写法简短了，而且执行效率也好上许多</li><li><code>: ${HOSTNAME?} ${USER?} ${MAIL?}</code>这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 <code>test</code> 或<code>if</code>这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。<strong>(这个具体还没试验过)</strong></li><li>添加环境变量时需要使用<code>:</code>分割，比如<code>PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla</code></li></ul><h2 id="星号"><a href="#星号" class="headerlink" title="* 星号"></a>* 星号</h2><ul><li>在<code>文件名扩展(Filename expansion)</code>上，用来代表<strong>0到无穷多个任意字符</strong></li><li>在<code>正则表达式（Regular Expressions）</code>中，代表<strong>重复零个到无穷多个的<u>前一个字符</u></strong>，而代销<strong>0到无穷多个任意字符</strong>是使用<code>.*</code>。</li><li>在运算时，它则代表 “乘法”</li></ul><div class="note info"><p><code>*</code>在不同地方不同的用法需要注意，尤其是代表<strong>0到无穷多个任意字符</strong>、<strong>重复零个到无穷多个的<u>前一个字符</u></strong>这方面。</p></div><hr><h2 id="次方运算"><a href="#次方运算" class="headerlink" title="** 次方运算"></a>** 次方运算</h2><p>两个星号在运算时代表 “次方” 的意思。</p><hr><h2 id="和"><a href="#和" class="headerlink" title="$和$$"></a>$和$$</h2><ul><li>引用变量的前导符号，如<code>var=&quot;test&quot; echo $var</code></li><li>在正则表达式里被定义为<code>行的最末端 (end-of-line)</code>，这个常用在<code>grep</code>、<code>sed</code>、<code>awk</code> 以及 <code>vim(vi)</code> 当中</li><li>在bash中<code>$</code>本身也是个变量。代表的是<strong>目前这个shell的进程代码</strong>，即所谓的<code>PID（Process ID）</code><ul><li><code>$$</code> Shell本身的PID（ProcessID）</li><li><code>$!</code> Shell最后运行的后台Process的PID</li><li><code>$?</code> 最后运行的命令的结束代码（返回值），一般指令程序倘若执行成功，其回传值为 0，失败为 1。</li><li>其他参考<a href="https://www.cnblogs.com/chjbbs/p/6393935.html" target="_blank" rel="noopener">该博客</a></li></ul></li><li><mark><code>$</code>后接引号（单双引号），单引号可以使引号内的内容被特殊对待：会将某些反斜线序列(如<code>\n</code>，<code>\t</code>，<code>\&quot;</code>，<code>\&#39;</code>等)继续转义(<code>\t-&gt;tab</code>;<code>\n-&gt;换行</code>)，而不认为它是字面符号(如果没有<code>$</code>符号，单引号会强制将string翻译为字面符号，包括反斜线)；而双引号则没有上述效果，<code>$&quot;string&quot;</code>和<code>&quot;string&quot;</code>是完全等价的，使用<code>$&quot;&quot;</code>只是为了保证本地化</mark></li></ul><blockquote><p><code>echo &#39;a\nb&#39;</code><br>a\nb</p></blockquote><p>上述结果<strong>并没有和预期的一样在a、b之间进行换行</strong>，这是因为<strong>单引号中的<code>\n</code>被看成了字面意思，就是反斜线加上n</strong>，而不是特殊的换行的意思</p><p>如果在前面加上<code>$</code>：</p><blockquote><p><code>echo $&#39;a\nb&#39;</code><br>a<br>b</p></blockquote><p>这个结果和预期的一样，<strong>因为<code>$</code>将<code>\n</code>翻译成了换行</strong>，而不是单纯的反斜线加上n，这个在join命令指定分隔符时会用到，具体参考介绍<a href="http://showteeth.tech/posts/5579.html">join用法的文章</a></p><p>如果将上述单引号转换为双引号：</p><blockquote><p><code>echo $&quot;a\nb&quot;</code><br>a\nb</p></blockquote><p>发现在使用<strong>双引号</strong>的情况下，得到的结果<strong>和没使用<code>$</code>是一样的</strong>，这和前面说的<code>$&quot;string&quot;</code>和<code>&quot;string&quot;</code>是完全等价的是相符的。</p><p><strong>常见的需要注意使用<code>$</code>和单引号的转义字符包括</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\a    alert (bell)</span><br><span class="line">\b    backspace</span><br><span class="line">\e</span><br><span class="line">\E    an escape character</span><br><span class="line">\f    form feed</span><br><span class="line">\n    new line</span><br><span class="line">\r    carriage <span class="built_in">return</span></span><br><span class="line">\t    horizontal tab</span><br><span class="line">\v    vertical tab</span><br><span class="line">\\    backslash</span><br><span class="line">\<span class="string">'    single quote</span></span><br><span class="line"><span class="string">\"    double quote</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="问号"><a href="#问号" class="headerlink" title="? 问号"></a>? 问号</h2><ul><li>在<code>文件名扩展(Filename expansion)</code>上扮演的角色是<code>匹配一个任意的字符</code>，但不包含空字符，注意是<strong>一个字符，不能是0个也不能是两个</strong>，注意和正则表达式的用法区分。比如：<code>ls a?c.txt</code>可以得到abc.txt和amc.txt 但是不能得到abbc.txt，也不能得到ac.txt</li><li>在正则表达式式中，<code>?</code>表示匹配<strong>前面的字符0次或1次</strong>，<strong>不是任意字符</strong>，注意和文件名拓展的区分。<mark>同时在正则表达式中还可以用来表示非贪婪匹配</mark></li><li>在<code>bash</code>中，这个变量是<strong>上一个执行的命令所回传的值</strong>。当我们执行某些命令时，这些命令都会回传一个执行后的代码，一般说，<u>如果成功执行该命令，则会回传一个0值</u>，如果执行过程<u>发生错误</u>，就会回传错误代码，一般<u>以非0的数值来替代</u></li></ul><hr><h2 id="变量的正规表达式"><a href="#变量的正规表达式" class="headerlink" title="${} 变量的正规表达式"></a>${} 变量的正规表达式</h2><p>一般情况下，<code>$var</code>与<code>${var}</code>是没有区别的，但是用<code>${}</code>会<strong>比较精确的界定变量名称的范围</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个明确说明了var才是变量</span></span><br><span class="line"><span class="variable">$&#123;var&#125;</span>_suffix</span><br><span class="line"></span><br><span class="line"><span class="variable">$var_suffix</span></span><br></pre></td></tr></table></figure><h3 id="参数替换"><a href="#参数替换" class="headerlink" title="${} 参数替换"></a>${} 参数替换</h3><ul><li><code>${var_name}</code> 等价于<code>$var_name</code>（通常用这种简写方式）</li><li><code>$(var:-default)</code> 和 <code>$(var-default)</code><ul><li><code>$(var:-default)</code>：当<strong>var为空或未定义</strong>时<strong>整个表达式的值为default</strong></li><li><code>$(var-default)</code>：当且<strong>仅当var未定义</strong>时<strong>整个表达式的值为default</strong></li></ul></li><li><code>$(var:=default)</code> 和 <code>$(var=default)</code><ul><li><code>$(var:=default)</code>：当var<strong>为空或未定义</strong>时<strong>整个表达式的值为default</strong>，<strong>并且将var的值设置为default</strong></li><li><code>$(var=default)</code>：当且<strong>仅当var未定义</strong>时<strong>整个表达式的值为default</strong>，<strong>并且将var的值设置为default</strong></li></ul></li><li><code>$(var:?default)</code> 和 <code>$(var?message)</code><ul><li><code>$(var:?message)</code>：当var<strong>为空或未定义</strong>时，<strong>打印错误信息</strong>，信息内容为message表示的值</li><li><code>$(var?message)</code>：当且<strong>仅当var未定义</strong>时，<strong>打印错误信息</strong>，信息内容为message表示的值</li></ul></li><li><code>$(var:+default)</code> 和 <code>$(var+default)</code><ul><li><code>$(var:+default)</code>：当<strong>var已定义且不为空</strong>时整个表达式的值为default</li><li><code>$(var+default)</code>：当<strong>var已定义时</strong>整个表达式的值为default(<strong>不管var是否是空</strong>)</li></ul></li></ul><hr><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="${} 字符串截取"></a>${} 字符串截取</h3><ul><li><code>${str:offest}</code>：从下标<strong>offset(含)开始截取到末尾</strong>的子串</li><li><code>${str:offest:length}</code>：从<strong>下标offset(含)开始向后截取长度为length</strong>的子串，长度超出不报错</li><li><code>${str:offest:index}</code>：</li></ul><hr><h3 id="变量匹配"><a href="#变量匹配" class="headerlink" title="${} 变量匹配"></a>${} 变量匹配</h3><p><code>${!prefix*}</code>、<code>${!prefix@}</code>：将带有<strong>前缀为prefix的变量名打印</strong>出来</p><hr><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="${} 数组操作"></a>${} 数组操作</h3><ul><li><code>${!name[@]}</code>、<code>${!name[*]}</code>：将<strong>数组name的所有<code>下标</code></strong>返回，如果<em>变量name不是数组则返回0,不存在则空</em></li><li><code>${name[@]}</code>、<code>${name[*]}</code>：将<strong>数组name的所有<code>元素</code></strong>返回，如果<em>变量name不是数组则返回name的值,不存在则空</em></li><li><code>${\#name[@]}</code>、<code>${\#name[*]}</code>：返回<strong>数组元素总个数</strong></li><li><code>${name[index]}</code>：将<strong>数组name的index处的<code>元素</code></strong>返回，如果<em>变量name不是数组且index为0时返回name的值</em>，<em>变量或索引index处的元素不存在则返回空</em></li><li><code>${\#name[index]}</code>：返回<strong>数组name的index处的<code>元素长度</code></strong></li><li><code>name[index]=xyz</code>：<strong>数组name的index处的元素重新<code>赋值</code></strong></li></ul><div class="note info"><p>上面的<code>${\#name[@]}</code>中对<code>#</code>做了转义处理，不然博客可能报错，参考<a href="https://github.com/hexojs/hexo/issues/2904" target="_blank" rel="noopener">github issue</a>，正常情况下使用时不用加<code>\</code>进行转义。</p></div><hr><h3 id="正则匹配替换"><a href="#正则匹配替换" class="headerlink" title="${} 正则匹配替换"></a>${} 正则匹配替换</h3><ul><li><code>${parameter#word}</code>、<code>${parameter##word}</code>：<strong>从头开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>#</code>为<strong>最短</strong>匹配，<code>##</code>为<strong>最长</strong>匹配</li><li><code>${parameter%word}</code>、<code>${parameter%%word}</code>：<strong>从尾开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>%</code>为<strong>最短</strong>匹配，<code>%%</code>为<strong>最长</strong>匹配</li><li><code>${parameter/pattern/string}</code>、<code>${parameter//pattern/string}</code>：使用string替换pattern，<code>/</code>表示<strong>只替换一次</strong>；<code>//</code>表示<strong>全部替换</strong></li><li><code>${\#parameter}</code>：获取变量长度</li></ul><div class="note info"><p>上述的<code>parameter</code>都是可以不用引用的，因为<code>${var}</code>本来就和<code>$var</code>是一个意思</p></div><hr><h2 id="得到脚本变量"><a href="#得到脚本变量" class="headerlink" title="$* 得到脚本变量"></a>$* 得到脚本变量</h2><p><code>$*</code>引用script的执行引用变量，引用参数的算法与一般指令相同，<strong>script本身为0</strong>，其后第一个为1，然后依此类推。引用变量的代表方式如下：<code>$0</code>, <code>$1</code>, <code>$2</code>, <code>$3</code>, <code>${10}</code>, <code>${11}</code>，注意个位数的，可直接使用数字，但<strong>两位数以上，则必须使用 {} 符号来括住</strong>。</p><p><code>$*</code> 则是代表<strong>所有引用变量</strong>的符号，使用时得视情况加上双引号，如<code>echo &quot;$*&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash example.sh var1 var2 var3</span><br><span class="line"><span class="comment"># $0是example.sh、$1是var1、$2是var2、$3是var3</span></span><br></pre></td></tr></table></figure><hr><h2 id="得到脚本变量-1"><a href="#得到脚本变量-1" class="headerlink" title="$@ 得到脚本变量"></a>$@ 得到脚本变量</h2><ul><li><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的<strong>所有参数</strong>，<strong>不被双引号(“ “)包含时</strong>，都以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> … <code>&quot;$n&quot;</code> 的形式输出所有参数</li><li>但是<strong>当它们被双引号(“ “)包含时</strong>，<code>&quot;$*&quot;</code> 会将<strong>所有的参数作为一个整体</strong>，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> … <code>&quot;$n&quot;</code> 的形式输出所有参数</li><li>也就是说<code>$@</code>不管有没有被双引号包围，其输出结果<strong>都是单个的变量形式</strong>，而<code>$*</code>在<strong>不被双引号</strong>包围时输出<strong>单个变量的形式</strong>，<strong>被双引号包围</strong>时，所有的参数<strong>以整体的形式输出</strong></li></ul><hr><h2 id="变量总数"><a href="#变量总数" class="headerlink" title="$# 变量总数"></a>$# 变量总数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出变量总数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="与declare-i-整数运算"><a href="#与declare-i-整数运算" class="headerlink" title="$(())与declare -i 整数运算"></a>$(())与declare -i 整数运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i total=<span class="variable">$firstnu</span>*<span class="variable">$secnu</span></span><br><span class="line">total=$((<span class="variable">$firstnu</span>*<span class="variable">$secnu</span>))</span><br></pre></td></tr></table></figure><p>区别就是小方括号内可以加上空格符，也是合法的写法，而declare -i 不可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2*3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2* 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错</span></span><br><span class="line">total=$((2*3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取</span></span><br><span class="line">a=5;b=7;c=2</span><br><span class="line"><span class="built_in">echo</span> $((a+b*c))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>+<span class="variable">$b</span>*<span class="variable">$c</span>))</span><br></pre></td></tr></table></figure><p><code>declare -i</code>加空格报错：</p><blockquote><p>bash: declare: 2<em>: syntax error: operand expected (error token is “</em>“)</p></blockquote><p><code>$(())</code>在等号左右加空格报错：</p><blockquote><p>bash: 6: command not found</p></blockquote><p><strong><code>$(())</code>进制转化：将其他进制转成十进制数显示出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值</span></span><br><span class="line"><span class="built_in">echo</span> $((N<span class="comment">#xx))</span></span><br></pre></td></tr></table></figure><hr><h2 id="执行计算"><a href="#执行计算" class="headerlink" title="((  )) 执行计算"></a>(( )) 执行计算</h2><p>和linux<code>let</code>指令相似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=5;b=7</span><br><span class="line">((a--));<span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;5;i++));<span class="keyword">do</span> <span class="built_in">echo</span>  <span class="variable">$i</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h2 id="指令群组"><a href="#指令群组" class="headerlink" title="(  ) 指令群组"></a>( ) 指令群组</h2><p>用括号将一串连续指令括起来，这被称为指令群组</p><p>指令群组有一个特性，shell会以产生subshell来执行这组指令，因此，在<strong>指令群组所定义的变量，仅作用于指令群组本身</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"test"</span></span><br><span class="line">(<span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>);<span class="built_in">echo</span> <span class="variable">$test</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>/home/usr<br>test</p></blockquote><p><strong><code>( )</code>也可被用于数组的声明中：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array=(element1 element2 element3)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="大括号"><a href="#大括号" class="headerlink" title="{ } 大括号"></a>{ } 大括号</h2><h3 id="作为代码块"><a href="#作为代码块" class="headerlink" title="作为代码块"></a>作为代码块</h3><p><strong>代码块</strong>，又被称为内部组，这个结构事实上创建了一个<strong>匿名函数</strong>。与上面小括号中的指令群组不同，花括号内的命令不会新开一个子shell运行，即<strong>脚本余下部分仍可使用括号内变量</strong>，因此，这样写 script也是相当好的一件事。尤其对<em>输出输入的重导向</em>上，这个做法可<strong>精简 script 的复杂度</strong>。括号内的<strong>命令间用分号隔开</strong>，<strong>最后一个也必须有分号</strong>。<strong><code>{}</code>的第一个命令和左括号之间必须要有一个空格</strong>。</p><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个命令和左括号之间没有空格</span></span><br><span class="line">&#123;<span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一个命令没有分号</span></span><br><span class="line">&#123; <span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确用法</span></span><br><span class="line">&#123; <span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>;&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>第一个命令和左括号之间没有空格</strong>报错：</p><blockquote><p>bash: {cd: command not found<br>/home/user/test}<br>/home/user/test</p></blockquote><p><strong>最后一个命令没有分号</strong>报错：</p><blockquote><p>> ^C</p></blockquote><p>正确输出：</p><blockquote><p>/home/user<br>/home/user</p></blockquote><h3 id="作为拓展"><a href="#作为拓展" class="headerlink" title="作为拓展"></a>作为拓展</h3><p>通配(globbing)将<strong>对花括号中的文件名做扩展</strong>。在大括号中，<strong>不允许有空白</strong>，<strong>除非</strong>这个空白被引用或转义。</p><ul><li>对大括号中的以逗号分割的<strong>文件列表进行拓展</strong>。如 <code>touch {a,b}.txt</code> 结果为<code>a.txt</code> <code>b.txt</code></li><li>对大括号中以点点<code>（..）</code>分割的<strong>顺序文件列表起拓展作用</strong>，如：<code>touch {a..d}.txt</code> 结果为<code>a.txt</code> <code>b.txt</code> <code>c.txt</code> <code>d.txt</code></li><li>对大括号中以点点<code>（..）</code>分割的<strong>顺序文件列表起拓展作用</strong>，如 <code>for i in {1..2};do echo $i;done</code> 结果为<code>1</code> <code>2</code></li></ul><h3 id="进行组合"><a href="#进行组合" class="headerlink" title="进行组合"></a>进行组合</h3><p>大括号<code>{}</code>里面的内容以<strong>逗号分隔</strong>，两个或多个大括号内的内容进行组合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3x3的组合，中间的短横线是分割线，可以自定义</span></span><br><span class="line">mkdir &#123;userA,userB,userC&#125;-&#123;home,bin,data&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行嵌套使用</span></span><br><span class="line">chown root /usr/&#123;ucb/&#123;ex,edit&#125;,lib/&#123;ex?.?*,how_ex&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="中括号"><a href="#中括号" class="headerlink" title="[ ] 中括号"></a>[ ] 中括号</h2><ul><li>在<strong>通配符和正则表达式</strong>中<code>[]</code>代表一定有一个在中括号内的字符，例如<code>[abcd]</code>代表一定有一个字符，可能是a、b、c、d这四个任何一个，<code>[num1-num2]</code>表示范围、<code>[^]</code>表示非</li><li><strong>流程控制</strong>中，扮演括住判断式的作用，<code>[]</code>中可用的比较运算符只有<code>==</code>和<code>!=</code>，两者<strong>都是用于字符串比较的</strong>，<strong>不可用于整数比较</strong>，<strong>整数比较只能使用<code>-eq</code>，<code>-gt</code>这种形式</strong>。无论是字符串比较还是整数比较<strong>都不支持大于号小于号</strong>。如果实在想用，对于字符串比较可以使用<strong>转义形式</strong>，如果比较<code>&quot;ab&quot;</code>和<code>&quot;bc&quot;</code>：<code>[ ab &lt; bc ]</code>，结果为真，也就是返回状态为0。<strong><code>[ ]</code>中的逻辑与和逻辑或使用-a 和-o 表示</strong></li><li>在一个array结构的上下文中，中括号用来引用数组的索引</li></ul><hr><h2 id="双中括号"><a href="#双中括号" class="headerlink" title="[[  ]] 双中括号"></a>[[ ]] 双中括号</h2><ul><li>这组符号与先前的 <code>[]</code> 符号，基本上作用相同，但是<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code>和<code>&gt;</code> 操作符能够正常存在于<code>[[ ]]</code>条件判断结构中，但是如果出现在<code>[ ]</code>结构中的话，会报错。</li><li><strong>支持字符串的模式匹配</strong>，使用<code>=~</code>操作符时甚至支持shell的<strong>正则表达式</strong>，字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如<code>[[ hello == hell? ]]</code>，结果为真。<strong><code>[[ ]]</code>中匹配字符串或通配符，不需要引号</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># [[ 2\&lt;3 ]] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ 2 -lt 3 ]] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ 2 \&lt; 3 ]] &amp;&amp; echo true || false</span></span><br><span class="line">-bash: 期待二元条件运算符</span><br><span class="line">-bash: `\&lt;<span class="string">' 附近有语法错误，这是因为空格的原因</span></span><br><span class="line"><span class="string">[root@localhost ~]# [ 2 \&lt; 3 ] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="string">true</span></span><br><span class="line"><span class="string">[root@localhost ~]# [ 2 &lt; 3 ] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="string">-bash: 3: 没有那个文件或目录</span></span><br></pre></td></tr></table></figure><hr><h2 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="|| 逻辑符号"></a>|| 逻辑符号</h2><p>在中括号中<code>[]</code>代表 <code>or</code> 逻辑的符号</p><p>在命令行中：<br><code>cmd1||cmd2</code><br>若<strong>cmd1执行完毕且正确执行($?=0)</strong>，则cmd2<strong>不执行</strong><br>若<strong>cmd1执行完毕且为错误($?≠0)</strong>，则开始<strong>执行cmd2</strong></p><hr><h2 id="amp-amp-逻辑符号"><a href="#amp-amp-逻辑符号" class="headerlink" title="&amp;&amp; 逻辑符号"></a>&amp;&amp; 逻辑符号</h2><p>在中括号中<code>[]</code>代表 <code>and</code> 逻辑的符号</p><p>在命令行中如下:<br><code>cmd1&amp;&amp;cmd2</code><br>若<strong>cmd1执行完毕且正确执行（$?=0）</strong>,则<strong>开始执行cmd2</strong><br>若<strong>cmd1执行完毕且为错误（$?≠0）</strong>，则<strong>cmd2不执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果./symbol/abc目录不存在则创建这个目录，成功后在目录下创建hehe文件</span></span><br><span class="line">ls ./symbol/abc || mkdir  ./symbol/abc &amp;&amp; touch ./symbol/abc/hehe</span><br></pre></td></tr></table></figure><blockquote><p>目录不存在，ls的报错信息<br>ls: cannot access ./symbol/abc: No such file or directory</p></blockquote><hr><h2 id="lt-…-gt-单字边界"><a href="#lt-…-gt-单字边界" class="headerlink" title="\&lt;…\&gt; 单字边界"></a>\&lt;…\&gt; 单字边界</h2><p>这组符号在规则表达式中，被定义为”边界”的意思。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除能完整匹配This这个单词的行</span></span><br><span class="line">sed <span class="string">'/\&lt;This\&gt;/d'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="文件操作符合输出-输入重定向"><a href="#文件操作符合输出-输入重定向" class="headerlink" title="文件操作符合输出/输入重定向"></a>文件操作符合输出/输入重定向</h2><ul><li><code>&gt;</code>：表示重定向</li><li><code>&amp;</code>：表示等同于的意思</li><li>文件描述符是和文件的输入、输出相关联的非负整数，Linux内核（kernel）利用文件描述符（file descriptor）来访问文件。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。常见的文件描述符是stdin、stdout和stderr。</li></ul><p><strong>常用的文件描述符如下：</strong></p><table><thead><tr><th>文件描述符</th><th>名称</th><th>常用缩写</th><th>默认值</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td>stdin</td><td>键盘</td></tr><tr><td>1</td><td>标准输出</td><td>stdout</td><td>屏幕</td></tr><tr><td>2</td><td>标准错误输出</td><td>stderr</td><td>屏幕</td></tr></tbody></table><p><strong>在简单地用<code>&lt;</code>或<code>&gt;</code>时，相当于使用 <code>0&lt;</code> 或 <code>1&gt;</code>，注意文件描述符和重定向符号之间不能存在空格，同时也可以将<code>&gt;</code>改为<code>&gt;&gt;</code>追加而不是覆盖文本信息</strong></p><ul><li><code>cmd &gt; file</code>等同于<code>cmd 1&gt; file</code>：把cmd命令的<strong>输出重定向到文件file中</strong>，如果file已经存在，则<strong>覆盖原有文件</strong></li><li><code>cmd &gt;&gt; file</code>等同于<code>cmd 1&gt;&gt; file</code>：把cmd命令的<strong>输出重定向到文件file中</strong>，如果file已经存在，则把信息<strong>加在原有文件后面</strong></li><li><code>cmd &lt; file</code>等同于<code>cmd 0&lt; file</code>：使cmd命令从<strong>file</strong>读入，<strong>必须是文件</strong>，不能是字符</li><li><code>cmd &lt;&lt; text</code>等同于<code>cmd 0&lt;&lt; text</code>：从命令行读取输入，直到一个与text字符相同的行结束</li><li><code>cmd 2&gt; file</code>：把cmd命令的<strong>标准错误输出重定向到文件file中</strong>，如果file已经存在，则<strong>覆盖原有文件</strong></li><li><code>cmd 2&gt;&gt; file</code>：把cmd命令的<strong>标准错误输出重定向到文件file中</strong>，如果file已经存在，则把信息<strong>加在原有文件后面</strong></li><li><code>cmd &gt;&amp;n</code>等同于<code>cmd 1&gt;&amp;n</code>：把输出重定向到文件描述符n，通过对<code>&amp;</code>的解读：标准输出的重定向等同于文件描述符n</li><li><code>cmd m&gt;&amp;n</code> ：把输出到文件符m的信息重定向到文件描述符n</li></ul><p><strong>从命令行读取输入：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; wang &gt; haha.txt</span><br></pre></td></tr></table></figure><p></p><p>从命令行得到输入，直到出现<code>wang</code>为止</p><blockquote><p><code>cat &lt;&lt; wang &gt;haha.txt</code><br>> test<br>> test2<br>> wang</p></blockquote><ul><li><code>cmd &lt;&lt;&lt; word</code>：将word(字符)，注意不是上面的file读入</li></ul><p><strong>标准错误输出：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># test.file不存在，没有任何错误提示，正常运行</span></span><br><span class="line">cat test.file 2&gt; out.txt  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 与上面的方法结果相同，错误的信息都被输入到了out.txt中</span></span><br><span class="line">cat test.file &amp;&gt; out.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将错误输出丢弃到/dev/null中，/dev/null是一个特殊的设备文件，这个文件接受到任何数据都会被丢系，通常被称为位桶、黑洞</span></span><br><span class="line">cat test.file  2&gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将标准输出重定向大list.txt文件中，标准错误输出重定向到list.err文件中</span></span><br><span class="line">cat test.file  1&gt; list.txt   2&gt; list.err</span><br></pre></td></tr></table></figure><p><strong>将标准错误stderr与stdout一同重定向到test.log文件:</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将标准输出重定向到test.log中，然后文件描述符2（标准错误输出）的重定向等同于文件描述符1（标准输出）</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>文件描述符支持自定义，<a href="http://man.linuxde.net/shell-script/shell-2" target="_blank" rel="noopener">参考文章</a></p></div><hr><p><br></p><h2 id="实战总结"><a href="#实战总结" class="headerlink" title="实战总结"></a>实战总结</h2><h3 id="得到数字用于循环的方法汇总"><a href="#得到数字用于循环的方法汇总" class="headerlink" title="得到数字用于循环的方法汇总"></a>得到数字用于循环的方法汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5);<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++));<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; ;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h3 id="转义字符总结"><a href="#转义字符总结" class="headerlink" title="转义字符总结"></a>转义字符总结</h3><p>有时候，我们想让<code>通配符</code>或者<code>元字符</code>变成<strong>普通字符</strong>，不需要使用它，那么这里我们就需要用到<code>转义符</code>了，shell提供转义符有三种：</p><table><tr><th width="20%">字符</th><th width="80%">说明</th></tr><tr><td>‘’(单引号)</td><td>又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)</td></tr><tr><td>“”(双引号)</td><td>又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替</td></tr><tr><td>\(反斜杠)</td><td>又叫转义，去除其后紧跟的元字符或通配符的特殊意义</td></tr></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.chinaunix.net/uid-16946891-id-5088144.html" target="_blank" rel="noopener">linux 特殊符号大全</a></li><li><a href="https://www.cnblogs.com/dirt2/p/5991033.html" target="_blank" rel="noopener">Linux命令中特殊符号，排版更好看</a></li><li><a href="https://www.jianshu.com/p/986e88819441" target="_blank" rel="noopener">Linux中的特殊符号及含义</a></li><li><a href="http://www.178linux.com/35067" target="_blank" rel="noopener">linux中特殊符号用法</a></li><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/6839669.html" target="_blank" rel="noopener">字符分类很好</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日总结和计划</title>
      <link href="/posts/51961.html"/>
      <url>/posts/51961.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>2019-2-24开始的每日学习总结与计划</p></div><a id="more"></a><style type="text/css">.tg{border-collapse:collapse;border-spacing:0;border-color:#999}.tg td{font-family:Arial,sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#f7fdfa}.tg th{font-family:Arial,sans-serif;font-size:14px;font-weight:400;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ade4}.tg .tg-phtq{background-color:#d2e4fc;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-hmp3{background-color:#d2e4fc;text-align:left;vertical-align:top}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><h2 id="2019-2-24"><a href="#2019-2-24" class="headerlink" title="2019-2-24"></a>2019-2-24</h2><h3 id="今日学习完成情况"><a href="#今日学习完成情况" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sed</td><td class="tg-phtq">学习了基本语法、掌握了选项i、n、e、f以及命令s、p、g</td><td class="tg-hmp3">2小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">markdown</td><td class="tg-0pky">完成了markdown基本语法的学习</td><td class="tg-0lax">3个小时</td></tr></table><div class="note success"><p>今日学习情况总结：首先是学习了markdown基本语法，收获了很多，比如html块元素是必须要进行留空白行的、有序列表前的数字不关键、创建表格以及进行相应的优化（还不够完善）等新内容；也开始学习了linux基本命令sed，对其使用有了基本的了解，明天还要接着学习！</p></div><hr><h3 id="明日学习哪些内容"><a href="#明日学习哪些内容" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>markdown表格的优化（宽度调整）</del></li><li><del>shell中特殊符号的学习</del></li><li><del>sed命令的学习</del></li></ul></div><hr><p><br></p><h2 id="2019-2-25"><a href="#2019-2-25" class="headerlink" title="2019-2-25"></a>2019-2-25</h2><h3 id="今日学习完成情况-1"><a href="#今日学习完成情况-1" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sed</td><td class="tg-phtq">完成了sed的学习</td><td class="tg-hmp3">大概3个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是完成了sed命令的学习，学习过程中发现sed和之前学的其他命令如awk、grep等有很多相似之处，有了之前的基础学起来更加容易理解，果然是学的越多学得越快！！！通过对sed命令的学习，在以后处理文本时就又增加了一个非常有力的工具！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-1"><a href="#明日学习哪些内容-1" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>shell中特殊符号的处理</del></li><li><p>~~markdown表格的优化（宽度调整）</p></li><li><p><del>开始学习师兄安排的任务</del></p></li></ul></div><hr><p><br></p><h2 id="2019-3-17"><a href="#2019-3-17" class="headerlink" title="2019-3-17"></a>2019-3-17</h2><h3 id="今日学习完成情况-2"><a href="#今日学习完成情况-2" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">shell编程</td><td class="tg-phtq">完成了shell编程数组的学习</td><td class="tg-hmp3">2个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了shell数组的相关操作，shell数组相对比较简单，同时也只支持一维数组，具有一定的局限性。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-2"><a href="#明日学习哪些内容-2" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>开始学习师兄安排的任务</del></li></ul></div><hr><p><br></p><h2 id="2019-3-18"><a href="#2019-3-18" class="headerlink" title="2019-3-18"></a>2019-3-18</h2><h3 id="今日学习完成情况-3"><a href="#今日学习完成情况-3" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">其他技巧整理</td><td class="tg-0pky">常用程序块、常见错误、main函数的理解</td><td class="tg-0lax">2个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是在完成师兄交代的任务，同时也Python相关内容进行了整理，包括常见错误、常用程序块以及之前学习过的main函数的理解</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-3"><a href="#明日学习哪些内容-3" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>学习参数传递，然后修改重构项目文件</del></li></ul></div><hr><p><br></p><h2 id="2019-3-19"><a href="#2019-3-19" class="headerlink" title="2019-3-19"></a>2019-3-19</h2><h3 id="今日学习完成情况-4"><a href="#今日学习完成情况-4" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用模块</td><td class="tg-0pky">argparse-解析命令行参数</td><td class="tg-0lax">一天</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是学习了Python用于命令行参数传递的模块argparse，在学习的过程中发现Python官方库的讲解非常详细，会先给出示例，然后对齐进行详细的讲解，我也比较喜欢这种讲解模式，以后可以多看看，学习学习，同时也发现了比较炫酷的方面就是子命令的使用。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-4"><a href="#明日学习哪些内容-4" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>完成师兄的交代的项目</del></li><li><del>完成图床的搭建</del></li></ul></div><hr><p><br></p><h2 id="2019-3-20"><a href="#2019-3-20" class="headerlink" title="2019-3-20"></a>2019-3-20</h2><h3 id="今日学习完成情况-5"><a href="#今日学习完成情况-5" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">博客完善</td><td class="tg-0pky">基于阿里云搭建了图床，基本抛弃了七牛云</td><td class="tg-0lax">3个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是完成了师兄说的项目内容以及完成了博客图床的搭建，还是花钱的东西好使，七牛云需要认证是真的麻烦</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-5"><a href="#明日学习哪些内容-5" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>项目相关</del></li><li><del>学习logging模块</del></li><li><del>完成cat命令的学习</del></li><li><del>完善argparse的用法</del></li><li><del>博客转载的项目，动手搞一搞，启动</del></li><li><del>安装sublime text3显示大纲的插件(打开的两个Github)</del></li></ul></div><hr><p><br></p><h2 id="2019-3-21"><a href="#2019-3-21" class="headerlink" title="2019-3-21"></a>2019-3-21</h2><h3 id="今日学习完成情况-6"><a href="#今日学习完成情况-6" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用模块</td><td class="tg-0pky">继续完善了模块argparse</td><td class="tg-0lax">2个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">docker学习、sublime text3插件安装</td><td class="tg-0pky">部署完成了第一个docker镜像、配置了sublime text3</td><td class="tg-0lax">4个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是对师兄说的项目内容进行了完善，同时也这对这个项目制作了第一个镜像，果然万事开头难，制作第一个镜像的过程中需要了很多问题，但是还好都得到了解决，同时通过这个项目也对docker有了一定的了解，为后面详细学习docker打下了基础。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-6"><a href="#明日学习哪些内容-6" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>学习logging模块</del></li><li><del>完成cat命令的学习</del></li><li><del>博客转载的项目</del></li></ul></div><hr><p><br></p><h2 id="2019-3-22"><a href="#2019-3-22" class="headerlink" title="2019-3-22"></a>2019-3-22</h2><h3 id="今日学习完成情况-7"><a href="#今日学习完成情况-7" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">cat-显示、读取或者拼接文本内容</td><td class="tg-hmp3">1.5h</td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用模块</td><td class="tg-0pky">完成了logging模块常规使用部分</td><td class="tg-0lax">3个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">git系列</td><td class="tg-0pky">总结了一些Git使用实战</td><td class="tg-0lax">0.5个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是在学习logging模块以及cat命令，都比较简单，上午主要是完善了Docker，将其上传到了Github，其中遇到的问题已经记录并形成了文章。在学习logging模块过程中发现需要看源码(参考的那篇文章)，果然大佬都是会看源码的，所以需要了解看源码的方法。后续需要学习的Linux命令都比较简单，比较的大的和重要的命令前面都已经学习过了，所以后续对Linux命令的学习可以插缝进行。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-7"><a href="#明日学习哪些内容-7" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>完成logging模块</del></li><li><del>和xupeng、yufeng一起学习机器学习</del></li><li><del>Python查看包的源代码的方法</del></li><li><del>博客转载的项目</del></li><li><del>给姐姐筛选一下材料</del></li></ul></div><hr><p><br></p><h2 id="2019-3-23"><a href="#2019-3-23" class="headerlink" title="2019-3-23"></a>2019-3-23</h2><h3 id="今日学习完成情况-8"><a href="#今日学习完成情况-8" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">实战项目</td><td class="tg-0pky">博客转载项目</td><td class="tg-0lax">5个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">深度学习</td><td class="tg-phtq">和xupeng、yufeng学习机器学习</td><td class="tg-hmp3">一上午</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天上午和yufeng、xupeng一起学习了深度学习相关的内容个，发现还是需要一些基础，同时一起学习确实会有一些监督作用，希望下次可以接着学习(每周抽出固定的时间来进行学习)；其次是开始了博客转载的项目。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-8"><a href="#明日学习哪些内容-8" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>博客转载的项目</del></li></ul></div><hr><p><br></p><h2 id="2019-3-24"><a href="#2019-3-24" class="headerlink" title="2019-3-24"></a>2019-3-24</h2><h3 id="今日学习完成情况-9"><a href="#今日学习完成情况-9" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">项目实战</td><td class="tg-0pky">博客转载项目-印象笔记处理</td><td class="tg-0lax">4个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是在继续博客转载项目，主要是处理印象笔记API的问题，想要使用API进行转载印象笔记内容。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-9"><a href="#明日学习哪些内容-9" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>博客转载的项目</del></li></ul></div><hr><p><br></p><h2 id="2019-3-25"><a href="#2019-3-25" class="headerlink" title="2019-3-25"></a>2019-3-25</h2><h3 id="今日学习完成情况-10"><a href="#今日学习完成情况-10" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">项目实战</td><td class="tg-0pky">博客转载项目-自动化爬虫、模拟登陆</td><td class="tg-0lax">5个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了Selenium自动化测试来模拟登陆，进而进行爬虫，因为使用印象笔记的API得到的印象笔记的公开链接由于某些原因被封禁，所以想着就登陆然后再爬虫。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-10"><a href="#明日学习哪些内容-10" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>博客转载的项目</del></li></ul></div><hr><p><br></p><h2 id="2019-3-26"><a href="#2019-3-26" class="headerlink" title="2019-3-26"></a>2019-3-26</h2><h3 id="今日学习完成情况-11"><a href="#今日学习完成情况-11" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">more和less查看文件内容</td><td class="tg-hmp3">2h</td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">项目实战</td><td class="tg-0pky">结束博客转载项目</td><td class="tg-0lax">1个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是收尾了博客转载项目的内容，将其上传到了github，同时也大致了解了setup.py的用法，虽然还没有正式学习；开始学习了more和less查看文件内容的命令。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-11"><a href="#明日学习哪些内容-11" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>师兄交代的任务</del></li><li><del>more和less命令的学习</del></li></ul></div><hr><p><br></p><h2 id="2019-3-27"><a href="#2019-3-27" class="headerlink" title="2019-3-27"></a>2019-3-27</h2><h3 id="今日学习完成情况-12"><a href="#今日学习完成情况-12" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">more和less查看文件内容；wget命令学习</td><td class="tg-hmp3">3h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是完成了more和less查看文件内容的命令，也开始学习了wget下载内容的命令。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-12"><a href="#明日学习哪些内容-12" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>师兄交代的任务</del></li><li><del>wget命令</del></li></ul></div><hr><p><br></p><h2 id="2019-3-28"><a href="#2019-3-28" class="headerlink" title="2019-3-28"></a>2019-3-28</h2><h3 id="今日学习完成情况-13"><a href="#今日学习完成情况-13" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">wget-命令行下载工具、任务管理命令</td><td class="tg-hmp3">4h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是linux的相关学习，首先结束了对wget命令的学习，对其下载整个网站以及断点续传操作记忆犹新，同时也学习了任务管理命令，包括nohup、disown以及&amp;，通过学习解决了自己一直以来的疑惑，同时也发现现在网上的很多资源并不完整(狠毒都是相互借鉴，并没有自己实践)，自己以后在学习和参考网上的资料时要持保留态度，自己多实践，然后针对自己的问题找到解决方案。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-13"><a href="#明日学习哪些内容-13" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>echo命令的学习</del></li></ul></div><hr><p><br></p><h2 id="2019-3-29"><a href="#2019-3-29" class="headerlink" title="2019-3-29"></a>2019-3-29</h2><h3 id="今日学习完成情况-14"><a href="#今日学习完成情况-14" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">echo-字符串输出</td><td class="tg-hmp3">4h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是linux的字符串输出命令echo，虽然平常使用echo非常多，但是一直没有理解什么时候需要加-e参数什么时候不加，所以萌生了学习这个的想法，通过学习了解到在需要输出转义字符的时候就需要使用-e参数以及进行样式输出(字体颜色、背景颜色等)也需要使用-e参数，其中还涉及到了之前学习了关于Linux中特殊符号的相关知识，尤其是单双引号的作用，对这方面的知识也进行了巩固(<strong>知识是越学越轻松，所以不能放弃学习进步啊</strong>)。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-14"><a href="#明日学习哪些内容-14" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>Python打印彩色字符串</del></li><li><del>linux常用解压缩命令</del></li></ul></div><hr><p><br></p><h2 id="2019-3-30"><a href="#2019-3-30" class="headerlink" title="2019-3-30"></a>2019-3-30</h2><h3 id="今日学习完成情况-15"><a href="#今日学习完成情况-15" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">linux中常用解压缩命令</td><td class="tg-hmp3">2h</td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">其他常用技巧总结</td><td class="tg-0pky">Python打印彩色字符串</td><td class="tg-0lax">2h</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了Python打印彩色字符串以及Linux中常用的解压缩命令，在学习Linux常用解压缩命令中的tar命令时，虽然平常使用这个比较多，但是一直以为它是一个解压缩命令，或者说从来没有思考过这个命令究竟是干嘛的，在学习之后才发现其是打包命令，知道了打包以及压缩的区别，也明白了tar.gz和tar.bz2格式的来源。<strong><u>学习要知其然，也要知其所以然，这样理解之后更有利于命令的记忆和使用</u>，在以后的学习中一定要切记，不到非常急的情况下不要拿过来不管三七二十一就用</strong>。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-15"><a href="#明日学习哪些内容-15" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>准备李航机器学习训练营的内容(这个非常重要)</del><ul><li><del>书本</del></li><li><del>ipad(视频+笔记)</del></li><li><del>草稿纸</del></li><li><del>博客和代码</del></li></ul></li><li><del>Python的os路径处理相关的包</del></li></ul></div><hr><p><br></p><h2 id="2019-3-31"><a href="#2019-3-31" class="headerlink" title="2019-3-31"></a>2019-3-31</h2><h3 id="今日学习完成情况-16"><a href="#今日学习完成情况-16" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">Python常用模块</td><td class="tg-0pky">os文件目录和路径操作</td><td class="tg-0lax">4h</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了Python中的os模块，这是一个文件目录操作模块，在平常写程序中非常常用，同时对与其相关的模块os.path也进行了学习。有一句话说的很好，<mark>学习的目的不是为了学完就忘不掉(当然这是最好的状态，但是一般人都达不到)，而是为了知道这里面有什么功能我可以去用，不然你连有什么功能都不知道何谈去使用呢？</mark>，所以还是要持续学习，不能放松！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-16"><a href="#明日学习哪些内容-16" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li><del>Python的shutil模块学习</del></li><li><del>开始学习统计学习方法</del></li></ul></div><hr><p><br></p><h2 id="2019-4-1"><a href="#2019-4-1" class="headerlink" title="2019-4-1"></a>2019-4-1</h2><h3 id="今日学习完成情况-17"><a href="#今日学习完成情况-17" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">Python常用模块</td><td class="tg-0pky">shutil模块-高级文件操作</td><td class="tg-0lax">3h</td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">统计机器学习第一章</td><td class="tg-hmp3">3个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了Python中的shutil模块，这个模块是昨天学习os模块的后续，因为很多非常必要的功能os模块并不具备，而shutil是对os模块的补充，在学习的过程中也深刻体会到<mark>看源码才是王道，很多文字说的不清楚的东西看看源码就很很快懂得其意思，所以今后的学习中要多看源码，尤其是自己不是很懂的地方，其次是多实践</mark>，多动手就会发现很多有意思的方面；同时今天也开始学习了拖了很久的统计机器学习，学习了其中的第一章，有些公式的推导并没有推，打算第一遍先跟着训练营打卡，然后后面第二遍看视频，第三遍再看一遍的时候仔细推导！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-17"><a href="#明日学习哪些内容-17" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>Python中glob模块的学习以及sys模块的整理</del></li><li><del>文件打开操作的整理</del></li><li><del>复习第一章</del></li></ul></div><hr><p><br></p><h2 id="2019-4-2"><a href="#2019-4-2" class="headerlink" title="2019-4-2"></a>2019-4-2</h2><h3 id="今日学习完成情况-18"><a href="#今日学习完成情况-18" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">Python其他技巧整理</td><td class="tg-0pky">文件读写</td><td class="tg-0lax">1.5h</td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">统计机器学习第一章</td><td class="tg-hmp3">3个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了Python中的glob模块以及sys模块；glob模块主要是用来进行文件名的规则匹配的，和linux下一样，对文件名的匹配使用的是通配符而不是正则表达式，glob的通配符与shell的通配符在很多方面都是相同的，可以共用，<mark>充分验证了学得越多学的越快</mark>，哪有什么学习能力很强，只是积累与练出来的罢了；sys模块主要是用来与解释器的交互，在学习的过程中主要涉及了一个使用sys.stdout来实现百分比进度条的实例，从中学到了Python3在写入文件中会返回写入的字符长度以及如何进行覆盖输出。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-18"><a href="#明日学习哪些内容-18" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del><a href="http://www.cnblogs.com/yyds/p/6171340.html" target="_blank" rel="noopener">Python中的字符串与字符编码整理</a></del></li><li><del>统计机器学习</del></li><li><del>sys.exit(n)的异常捕获、exit和break的关系</del></li></ul></div><hr><p><br></p><h2 id="2019-4-3"><a href="#2019-4-3" class="headerlink" title="2019-4-3"></a>2019-4-3</h2><h3 id="今日学习完成情况-19"><a href="#今日学习完成情况-19" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">其他技巧总结</td><td class="tg-0pky">Python系列之字符串与字符编码(转载)</td><td class="tg-0lax">1.5h</td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">统计机器学习第一章</td><td class="tg-hmp3">3.5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习并整理了Python中的字符串与字符编码，对Python2和Python3在字符串上的操作有了进一步的认识，同时也了解了不同位置指定编码类型的不同作用；完成了轮转的报告；晚上结合视频重新学习了一遍统计机器学习的第一章，发现预习之后学习效果果然会有更大的提升，所以今后的两天学习，第一天当做是预习，第二天再结合讲解视频学习，这样效果可能会更好！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-19"><a href="#明日学习哪些内容-19" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>搬实验室</del></li><li><del>看文章的分析流程(上午)</del></li><li><del>看看subprocess模块的用法(下午)</del></li><li><del>学习统计机器学习第二章(晚上)</del></li><li><del>学生证上的注册要贴一下，去新实验室之后再贴</del></li></ul></div><hr><p><br></p><h2 id="2019-4-4"><a href="#2019-4-4" class="headerlink" title="2019-4-4"></a>2019-4-4</h2><h3 id="今日学习完成情况-20"><a href="#今日学习完成情况-20" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky">Python常用模块之subprocess子进程管理</td><td class="tg-0lax">4h</td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">统计机器学习第二章</td><td class="tg-hmp3">3.5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：主要学习了Python的子进程管理模块subproccess，这也是一个非常常用的模块，这个模块学习完成之后，基础的常用模块就学习完了，编写大型的项目基本不存在问题了；学习了统计机器学习方法的第二章。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-20"><a href="#明日学习哪些内容-20" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>学习统计机器学习第二章(晚上)</del></li></ul></div><hr><p><br></p><h2 id="2019-4-5"><a href="#2019-4-5" class="headerlink" title="2019-4-5"></a>2019-4-5</h2><h3 id="今日学习完成情况-21"><a href="#今日学习完成情况-21" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">统计机器学习第二章</td><td class="tg-hmp3">3.5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">其他工具</td><td class="tg-0pky">科学上网</td><td class="tg-0lax">3</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了统计机器学习的第二章，发现这本书讲得真的很好！！！肯定是要多看几遍呀；搬到了新实验室，搞了一下科学上网的东西，整理了几种方法和工具。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-21"><a href="#明日学习哪些内容-21" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>项目学习</del></li></ul></div><hr><p><br></p><h2 id="2019-4-6"><a href="#2019-4-6" class="headerlink" title="2019-4-6"></a>2019-4-6</h2><h3 id="今日学习完成情况-22"><a href="#今日学习完成情况-22" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i></td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">项目学习</td><td class="tg-0pky">项目学习</td><td class="tg-0lax">5</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是在学习老师交代的项目</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-22"><a href="#明日学习哪些内容-22" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>项目学习</del></li><li><del>统计机器学习第三章</del></li></ul></div><hr><p><br></p><h2 id="2019-4-7"><a href="#2019-4-7" class="headerlink" title="2019-4-7"></a>2019-4-7</h2><h3 id="今日学习完成情况-23"><a href="#今日学习完成情况-23" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">统计机器学习第三章</td><td class="tg-hmp3">3.5个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是进行了项目学习同时也看了统计机器学习的第三章，这一章看的比较浅，没有怎么看，同时原理也比较简单，后面需要再看看kd树的信息</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-23"><a href="#明日学习哪些内容-23" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>项目学习</del></li><li><del>统计机器学习第四章</del></li></ul></div><hr><p><br></p><h2 id="2019-4-8"><a href="#2019-4-8" class="headerlink" title="2019-4-8"></a>2019-4-8</h2><h3 id="今日学习完成情况-24"><a href="#今日学习完成情况-24" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">其他内容</td><td class="tg-0pky">项目学习</td><td class="tg-0lax">5h</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了项目的部分，基本可以运行部分程序，明天争取完成整个项目的pipeline试运行工作；推迟学习统计机器学习第四章，明天要补回来。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-24"><a href="#明日学习哪些内容-24" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>学习统计机器学习第四章</del></li></ul></div><hr><p><br></p><h2 id="2019-4-9"><a href="#2019-4-9" class="headerlink" title="2019-4-9"></a>2019-4-9</h2><h3 id="今日学习完成情况-25"><a href="#今日学习完成情况-25" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">朴素贝叶斯</td><td class="tg-hmp3">4h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了统计机器学习中的朴素贝叶斯，从晚上7点45到12点20，完成了第一遍预习以及第二遍的结合视频学习，感觉时间差不多，以后可以就按照这个模式来管理自己的私人学习时间。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-25"><a href="#明日学习哪些内容-25" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>继续项目学习</del></li></ul></div><hr><p><br></p><h2 id="2019-4-10"><a href="#2019-4-10" class="headerlink" title="2019-4-10"></a>2019-4-10</h2><h3 id="今日学习完成情况-26"><a href="#今日学习完成情况-26" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">项目学习</td><td class="tg-0pky">项目学习</td><td class="tg-0lax">3h</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了项目相关内容</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-26"><a href="#明日学习哪些内容-26" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>继续项目的学习</del></li></ul></div><hr><p><br></p><h2 id="2019-4-11"><a href="#2019-4-11" class="headerlink" title="2019-4-11"></a>2019-4-11</h2><h3 id="今日学习完成情况-27"><a href="#今日学习完成情况-27" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">paste、split命令</td><td class="tg-hmp3">4h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天在学习项目的同时也学习了Linux中的常用基本命令paste和split；最近几天都在学习搭建jupyterhub但是效果一直不是很好，有点难受。。。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-27"><a href="#明日学习哪些内容-27" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>学习统计机器学习第五章-决策树</del></li><li>找找斌斌师兄，问问jupyterhub搭建的config文件</li></ul></div><hr><p><br></p><h2 id="2019-4-12"><a href="#2019-4-12" class="headerlink" title="2019-4-12"></a>2019-4-12</h2><h3 id="今日学习完成情况-28"><a href="#今日学习完成情况-28" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">csplit命令</td><td class="tg-hmp3">1h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">第五章-决策树</td><td class="tg-hmp3">4h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天开始学习了Linux中的常用基本命令csplit，作为前面split命令和paste命令的延续性学习；还学习了书本的决策树内容，决策树虽然已经学习过很多次，但是不同的书本提供不同的角度，总有一种角度比较适合自己理解，比如统计机器学习中的条件熵的概念让我对信息增益的计算有了更深入的认识，从而加深了自己对其的理解，if-then规则以及条件概率模型的提出也和前面的知识结合起来加深了记忆与理解—&gt;说明了一个道理：有些内容理解不了可能还真是书本的问题，所以要找点好书看！或者多个经典的书本对照着学习，一个讲解不是很懂可以参考另一个！！！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-28"><a href="#明日学习哪些内容-28" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li><del>学习统计机器学习第五章-决策树</del></li><li>找找斌斌师兄，问问jupyterhub搭建的config文件</li></ul></div><hr><p><br></p><h2 id="2019-4-13"><a href="#2019-4-13" class="headerlink" title="2019-4-13"></a>2019-4-13</h2><h3 id="今日学习完成情况-29"><a href="#今日学习完成情况-29" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">csplit命令</td><td class="tg-hmp3">2h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> 机器学习</td><td class="tg-phtq">书本学习</td><td class="tg-phtq">第五章-决策树</td><td class="tg-hmp3">4h</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是接着昨天的学习工作，学习并完成了csplit命令；开始结合视频对决策树的内容进行整理。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-29"><a href="#明日学习哪些内容-29" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li><li>完成学习统计机器学习第五章-决策树</li><li>找找斌斌师兄，问问jupyterhub搭建的config文件</li></ul></div><hr><p><br></p><h2 id="2019-4-14"><a href="#2019-4-14" class="headerlink" title="2019-4-14"></a>2019-4-14</h2><h3 id="今日学习完成情况-30"><a href="#今日学习完成情况-30" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fak-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改 todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-30"><a href="#明日学习哪些内容-30" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>学习pv命令，完善pv命令相应的文章</del></li><li>博客下载所有的图片，然后完成替换</li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结和计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/posts/65136.html"/>
      <url>/posts/65136.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结markdown基础语法，便于后续查找和使用。<a href="http://showteeth.tech/posts/37746.html">另有一篇next-markdown技巧和模板</a>总结了博客写作中常用的markdown技巧和模板，有些并不是原生的markdown语法，但是写作效果很好看，需要的时候可以查阅这个。</p></div><a id="more"></a><h2 id="markdown特性"><a href="#markdown特性" class="headerlink" title="markdown特性"></a>markdown特性</h2><ul><li>Markdown 的目标是实现<strong>易读易写</strong></li><li><strong>兼容HTML</strong>，不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了，不过<em>有一些标签需要特殊注意</em></li><li><strong>特殊字符转换</strong>：特殊字符如HTML中需要特殊处理的字符<code>&lt;</code>和<code>&amp;</code>，markdown会将其自动转化为<code>&amp;lt;</code> 和 <code>&amp;amp;</code>这种实体的形式（虽然在markdown中看不到，但是实际上在生成html时markdown自动将其转化为上述实体的形式），但是如果是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 不会对它做任何转换。附上<a href="http://showteeth.tech/posts/45689.html">HTML 中有用的字符实体</a></li></ul><div class="note warning"><ul><li>在markdown使用HTML标签<mark>需要特殊注意的是 HTML 的区块元素</mark>，比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在<strong>前后加上空行</strong>与其它内容区隔开，还要求它们的<strong>开始标签与结尾标签不能用制表符或空格来缩进</strong>;Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上<em>不必要</em>的 <code>&lt;p&gt;</code> 标签</li><li>HTML 区块标签间的 Markdown 格式语法将<strong>不会被处理</strong>，如<code>&lt;p&gt;这是**一个**测试&lt;/p&gt;</code>中一个不会加粗显示</li><li>HTML 的行内标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用</li><li>与处在 HTML 区块标签间不同，<strong>Markdown 语法在 HTML 行内标签间是有效的</strong></li><li>具体的HTML区块标签和行内标签有哪些，请参考<a href="http://showteeth.tech/posts/8829.html">这篇转载的文章</a></li></ul></div><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h3><h4 id="换行和段落"><a href="#换行和段落" class="headerlink" title="换行和段落"></a>换行和段落</h4><p>在markdown中进行<strong>换行</strong>操作：一行<strong>文本末尾增加两个以上的空格然后回车</strong>，如果<strong>只使用回车，不添加或者没加够空格看上去两行的文字会变为一行</strong>。</p><p>markdown<strong>区分段落的关键</strong>是：这两行文字之间<strong>是否有空行</strong>，空行的定义是显示上看起来像是空的，便会被视为空行。比如，若某一行<strong>只包含空格和制表符，则该行也会被视为空行</strong>。如果这两行文字之间有空行，就代表这两行文字为两个段落，如果这两行文字之间没有空行，仅仅使用另个以上空格加回车进行换行，这两行文字仍旧是属于同一个段落。</p><div class="note info"><ul><li>得到空行的方法：在上一行<strong>文本末尾加上两个以上空格然后回车</strong>，<strong>再加上<code>&lt;br /&gt;</code>即可</strong></li><li>两个段落之间有一个空行就可以证明其为两个段落，再多的空行也不会在html中渲染（上述添加<code>&lt;br /&gt;</code>制造空行的方式除外，增加几个<code>&lt;br /&gt;</code>就会有几个空行）。</li></ul></div><hr><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>markdown依据<code>#</code>的数量，支持六级的标题，一个<code>#</code>代表一级标题，<strong>用于标题的<code>#</code>数目最多为6个</strong>，当数目<strong>大于6个时不再以标题的形式显现</strong>，如<code>####### 7</code>将直接显示为####### 7，而不是以标题的形式。<br><br><br>当然也可以选择闭合标题的<code>#</code>，在标题之后加上若干数目的<code>#</code>，标题的级别是依据标题之前的<code>#</code>数目决定，和之后的<code>#</code>数目无关。如<code># 1 ##########</code>还是代表的1级标题。</p><hr><h4 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h4><ul><li>markdown使用<code>&gt;</code>进行引用</li><li><strong>段落内多行一同进行区块引用</strong>可以在每一行之前都加上<code>&gt;</code>，也可以进行偷懒，在整个<strong>段落</strong>的第一行加上<code>&gt;</code>引用一整行</li><li>引用可以进行<strong>嵌套</strong>，如加两个&gt;&gt;三个&gt;&gt;&gt;</li></ul><blockquote><p>这是一句引用</p><blockquote><p>这也是一个引用</p><blockquote><p>当然，这个还是一个引用</p></blockquote></blockquote></blockquote><ul><li>使用blockquotes标签进行引用，可以修改文字颜色以及左边框颜色。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">"color:red;border-left: 3px solid #F44336;"</span>&gt;</span>使用blockquotes标签进行引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><blockquote style="color:red;border-left:3px solid #f44336">使用blockquotes标签进行引用</blockquote><ul><li>引用的<strong>区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; #### 这是一个标题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1.   这是第一行列表项</span><br><span class="line">&gt; 2.   这是第二行列表项</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">"color:red;border-left: 3px solid #F44336;"</span>&gt;</span>使用blockquotes标签进行引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">&gt; **引用**结束</span><br></pre></td></tr></table></figure><hr><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>markdown支持<strong>有序列表</strong>、<strong>无序列表</strong>和<strong>任务列表</strong>。</p><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表使用<strong>星号</strong>、<strong>加号</strong>或是<strong>减号</strong>作为列表标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>有序列表则使用<strong>数字接着一个英文句点</strong>作为列表标记。值得注意的是有序列表<mark>中英文句号前面的数字并不重要</mark>，也就是说<strong>可以是完全相同或者不连续的数字</strong>，这些都不会影响最终解析得到的html信息，<strong>得到的结果都是相同的</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br></pre></td></tr></table></figure><h5 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h5><p><strong>依赖模块</strong>: <code>pymdownx.tasklist</code></p><p><strong>用法</strong>: <code>- [ ]</code> 或 <code>- [x]</code>，其中 <strong><code>[ ]</code>表示不打勾</strong>，<strong><code>[x]</code>表示打勾</strong>，<strong><code>-</code>可以用<code>+</code>或<code>*</code>替代</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit</span><br><span class="line">- [x] Nulla lobortis egestas semper</span><br><span class="line">- [x] Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est</span><br><span class="line">- [ ] Vestibulum convallis sit amet nisi a tincidunt</span><br><span class="line">    - [x] In hac habitasse platea dictumst</span><br><span class="line">    - [x] In scelerisque nibh non dolor mollis congue sed et metus</span><br><span class="line">    - [x] Sed egestas felis quis elit dapibus, ac aliquet turpis mattis</span><br><span class="line">    - [ ] Praesent sed risus massa</span><br><span class="line">- [x] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</span><br><span class="line">- [ ] Nulla vel eros venenatis, imperdiet enim id, faucibus nisi</span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果：</strong></p><ul><li style="list-style:none"><input type="checkbox" checked> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li><li style="list-style:none"><input type="checkbox" checked> Nulla lobortis egestas semper</li><li style="list-style:none"><input type="checkbox" checked> Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est</li><li style="list-style:none"><input type="checkbox"> Vestibulum convallis sit amet nisi a tincidunt<ul><li style="list-style:none"><input type="checkbox" checked> In hac habitasse platea dictumst</li><li style="list-style:none"><input type="checkbox" checked> In scelerisque nibh non dolor mollis congue sed et metus</li><li style="list-style:none"><input type="checkbox" checked> Sed egestas felis quis elit dapibus, ac aliquet turpis mattis</li><li style="list-style:none"><input type="checkbox"> Praesent sed risus massa</li></ul></li><li style="list-style:none"><input type="checkbox" checked> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li><li style="list-style:none"><input type="checkbox"> Nulla vel eros venenatis, imperdiet enim id, faucibus nisi</li></ul><h5 id="多级列表"><a href="#多级列表" class="headerlink" title="多级列表"></a>多级列表</h5><p>多级列表的产生：先得到一级列表，然后使用<code>tab键</code>将后续的列表依次缩进即可得到多级列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* this is a test </span><br><span class="line">  * this is a test </span><br><span class="line">    * this is a test</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><ul><li>this is a test<ul><li>this is a test<ul><li>this is a test</li></ul></li></ul></li></ul><h5 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h5><p>列表项目<strong>可以包含多个段落</strong>，每个项目下的段落都<strong>必须缩进 4 个空格或是 1 个制表符</strong>。</p><p>段落的<strong>每一行都可以进行缩进</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span><br><span class="line">    mi posuere lectus.</span><br><span class="line"></span><br><span class="line">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span><br><span class="line">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span><br><span class="line">    sit amet velit.</span><br><span class="line"></span><br><span class="line">2.  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ol><li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p><p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p></li><li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li></ol><p>当然也支持<strong>只对段落首行进行缩进</strong>，和上面的段落每行都缩进结果是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line">    This is the second paragraph in the list item. You're</span><br><span class="line">only required to indent the first line. Lorem ipsum dolor</span><br><span class="line">sit amet, consectetuer adipiscing elit.</span><br><span class="line"></span><br><span class="line">*   Another item in the same list.</span><br></pre></td></tr></table></figure><h5 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h5><p>如果要在<strong>列表项目内放进引用</strong>，那 <code>&gt;</code> 就需要缩进：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line">    &gt; This is a blockquote</span><br><span class="line">    &gt; inside a list item.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><p>A list item with a blockquote:</p><blockquote><p>This is a blockquote<br>inside a list item.</p></blockquote></li></ul><h5 id="包含代码块的列表"><a href="#包含代码块的列表" class="headerlink" title="包含代码块的列表"></a>包含代码块的列表</h5><p>如果要<strong>放代码块</strong>的话，该代码块就需要缩进两次，也<strong>就是 8 个空格或是 2 个制表符</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   一列表项包含一个列表区块：</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">代码写在这</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note warning"><ul><li>如果在<strong>行首出现数字-句点-空白</strong>，可能会误认为是有序列表，要避免这样的状况，你可以在句点前面加上<strong>反斜杠</strong>，如1986. What a great season.</li><li>标记后面最少有一个<strong>空格</strong>或<strong>制表符</strong></li><li><mark>必须和前后文本存在空行</mark>，不然列表可能<strong>不能正确解析</strong>以及后面的文本可能<strong>出现偏移</strong>。</li></ul></div><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h5 id="使用markdown原生的方式插入表格"><a href="#使用markdown原生的方式插入表格" class="headerlink" title="使用markdown原生的方式插入表格"></a>使用markdown原生的方式插入表格</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td><em>短文本</em></td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><div class="note warning"><ul><li>表格的语句<mark>上一行必须为空行</mark>，不然表格不生效;</li><li>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;</li><li>-的数量至少有一个;</li><li>|、-、:之间的多余空格会被忽略，不影响布局;</li><li>表格内容中可以套用其他用法，如加粗、斜体等；</li><li><mark>直接在markdown原生表格之前添加html样式（style）也可以对表格样式进行修改</mark>。</li></ul></div><h5 id="设置表格宽度自适应"><a href="#设置表格宽度自适应" class="headerlink" title="设置表格宽度自适应"></a>设置表格宽度自适应</h5><p>解决了按照<strong>第一列表头宽度进行自适应</strong>的问题：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table th:first-of-type &#123;</span></span><br><span class="line"><span class="undefined">width: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>为每一列单独设置宽度：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">35%</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">45%</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span>第四列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在markdown原生表格之前加上如下内容，设置每一列宽度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table th:first-of-type &#123;</span></span><br><span class="line"><span class="undefined">width: 15%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">table th:nth-of-type(2) &#123;</span></span><br><span class="line"><span class="undefined">width: 25%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">table th:nth-of-type(3) &#123;</span></span><br><span class="line"><span class="undefined">width: 60%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>第一列占整个表格宽度的10%、第二列占35%、第三列占45%、第四列占10%。</p><div class="note warning"><ul><li><code>th:first-of-type</code> 的意思是每个 <code>&lt;th&gt;</code> 为其父级的<strong>第一个元素</strong>，就是指第一列的表头，同理第二、三个使用 <code>th:nth-of-type(2)</code>、<code>th:nth-of-type(3)</code></li><li>修改表头的宽度表头对应的列的宽度也就得到了修改</li><li>这里有一篇关于markdown表格样式优化的<a href="https://www.tuicool.com/articles/mueEZjr" target="_blank" rel="noopener">文章</a>，包括<code>鼠标悬停变色</code>、<code>表格滚动条</code>、<code>隔行变色</code>、<code>表头不换行</code>和<code>首列不换行</code>等优化</li><li><strong>excel也能导出html</strong>，先在excel中创建表格，然后保存为html，最后复制其中的表格，<a href="https://blog.csdn.net/sunbocong/article/details/81033915" target="_blank" rel="noopener">参考文章</a></li></ul></div><h5 id="表格对齐问题"><a href="#表格对齐问题" class="headerlink" title="表格对齐问题"></a>表格对齐问题</h5><ul><li>-:表示内容和标题栏居右对齐；</li><li>:-表示内容和标题栏居左对齐；</li><li>:-:表示内容和标题栏居中对齐；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| :------ | :------: | ------: |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th style="text-align:left">一个普通标题</th><th style="text-align:center">一个普通标题</th><th style="text-align:right">一个普通标题</th></tr></thead><tbody><tr><td style="text-align:left"><em>短文本</em></td><td style="text-align:center">中等文本</td><td style="text-align:right">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:center">短文本</td><td style="text-align:right">中等文本</td></tr></tbody></table><h5 id="使用html插入表格"><a href="#使用html插入表格" class="headerlink" title="使用html插入表格"></a>使用html插入表格</h5><p>上述markdown原生的方法只能创建一些简单的表格，如果想创建复杂的表格，如<mark>合并单元格</mark>、<mark>调整表格颜色</mark>等就需要直接使用html进行创建表格。</p><p>实现合并单元格：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>b1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>b2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>b3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>c2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>c3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果：</strong></p><table><br><tr><br><th>项目1</th><br><th>项目2</th><br><th>项目3</th><br></tr><br><tr><br><td>a1</td><br><td colspan="2">a2</td><br></tr><br><tr><br><td rowspan="2">b1</td><br><td>b2</td><br><td>b3</td><br></tr><br><tr><br><td>c2</td><br><td>c3</td><br></tr><br></table><div class="note info"><ul><li><code>table</code>标签：定义 HTML 表格</li><li><code>tr</code> 元素定义表格<code>行</code></li><li><code>th</code> 元素定义<code>表头</code></li><li><code>td</code> 元素定义表格<code>单元</code></li><li><code>td</code>标签下的<code>colspan（跨列-合并一行的多列）及rowspan（跨行-合并一列的多行）</code>属性进行单元格的合并。</li></ul></div><h5 id="使用html插入表格需要注意空行"><a href="#使用html插入表格需要注意空行" class="headerlink" title="使用html插入表格需要注意空行"></a>使用html插入表格需要注意空行</h5><p>markdown在处理上述的表格时会<strong>产生大量的空行</strong>，除非将整个表格写成一行，不然空行的书目和整个html代码占的行数相同，解决方法是加上<code>escape</code>标签，将整个table套起来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">escape</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>b1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>b2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>b3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>c2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>c3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">escape</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><table><tr><th>项目1</th><th>项目2</th><th>项目3</th></tr><tr><td>a1</td><td colspan="2">a2</td></tr><tr><td rowspan="2">b1</td><td>b2</td><td>b3</td></tr><tr><td>c2</td><td>c3</td></tr></table><h5 id="偷懒方法之直接复制html代码"><a href="#偷懒方法之直接复制html代码" class="headerlink" title="偷懒方法之直接复制html代码"></a>偷懒方法之直接复制html代码</h5><p>从上面html代码可以看出来写着比较麻烦，为了解决这个问题，这里有一个专门生成<code>Latex</code>、<code>html</code>、<code>markdown</code>、<code>text</code>、<code>mediawiki</code>支持的表格源码的网站，只需要选取相应的内容即可，还可以<strong>调整表格颜色</strong>，生成相应的css样式。</p><a class="btn" href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>生成表格源码的网站</a><h5 id="在markdown表格显示竖线"><a href="#在markdown表格显示竖线" class="headerlink" title="在markdown表格显示竖线"></a>在markdown表格显示竖线</h5><p>在使用markdown表格时如果想要显示竖线，仅仅使用转义是不能成功的，需要使用HTML实体，竖线的HTML实体为<code>&amp;#124;</code>，一个竖线就使用一个<code>&amp;#124;</code>两个竖线就使用两个<code>&amp;#124;&amp;#124;</code>，使用HTML实体后，网页会自动将其显示为<code>|</code>，关于HTML中的常用字符实体请参考<a href="http://showteeth.tech/posts/45689.html">这篇文章</a></p><hr><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块有两种写法：使用反引号加代码语言种类，代码写完后面也跟三个相同的符号（这种方法最为常用）；第二种写法就是简单地缩进 4 个空格或是 1 个制表符就可以。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个普通段落：</span><br><span class="line"></span><br><span class="line">    这是一个代码区块。</span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>需要和<strong>普通段落之间存在空行</strong></li><li><strong>最后的三个反引号之后不能存在空格</strong>，不然会出错</li></ul></div><hr><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>你可以在一行中用<mark>三个以上</mark>的<code>星号</code>、<code>减号</code>、<code>底线</code>来<strong>建立一个分隔线</strong>，<em>行内不能有其他东西</em>。你也<em>可以在星号或是减号中间插入空格</em>。下面每种写法都可以建立分隔线：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">_____</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><hr><hr><hr><hr><hr><hr><div class="note info"><p>使用带空格的<code>星号</code>、<code>减号</code>、<code>底线</code>建立空格线，空格线会粗一些。</p></div><hr><p><br></p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>markdown支持两种形式的链接语法：<code>行内式</code>和<code>参考式</code>两种形式，一般行内式使用较为简单和普遍，所以这里就采用行内式的方式。</p><p>链接的使用形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/ "Title")</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br><a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a></p><div class="note info"><ul><li>方括号内的文字（an example）表示链接作用的文字</li><li>圆括号内部第一个是链接地址</li><li>第二个是title：鼠标移到链接文字上显示的内容</li></ul></div><p>如果你是要链接到<strong>同样主机的资源，你可以使用相对路径</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">See my [About](/about/) page for details.</span><br></pre></td></tr></table></figure><p><mark>关于参考式链接:</mark></p><ul><li>参考式的链接其实重点不在于它比较好写，而是它比较好读</li><li>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断</li><li>具体关于参考是的讲解可以参考<a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">这篇文章</a>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        "Google"</span><br><span class="line">  [2]: http://search.yahoo.com/  "Yahoo Search"</span><br><span class="line">  [3]: http://search.msn.com/    "MSN Search"</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><hr><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5><p>markdown使用星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被<code>*</code>或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code>标签包围，显示出斜体的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于*斜体*的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<em>斜体</em>的测试</p><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5><p>markdown使用两个星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被两个<code>*</code>或 <code>_</code> 包围的字词会被转成用 <code>&lt;strong&gt;</code>（加粗显示）包围，显示出加粗的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于**加粗**的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<strong>加粗</strong>的测试</p><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5><p>使用以上的斜体和加粗叠加可以实现斜体和加粗的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于***斜体加粗***的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<strong><em>斜体</em></strong>的测试</p><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><p>要加删除线的文字左右分别用<code>两个~~</code>号包起来，这个也可以叠加斜体以及加粗标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于~~删除线~~的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<del>删除线</del>的测试</p><div class="note info"><ul><li>星号<code>*</code>和底线<code>_</code>与被包围的文字之间不能有空格，不然星号<code>*</code>和底线<code>_</code>就会被当成普通的字符显示</li><li>如果想加入普通的星号<code>*</code>和底线<code>_</code>，你可以用反斜线，如</li></ul></div><hr><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>行内插入代码，可以直接使用反引号（<code>`</code>）将代码包围起来即可。如<code>&lt;div&gt; &lt;/div&gt;</code>就是写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span><br></pre></td></tr></table></figure><p><mark>行内代码中加入反引号：</mark>可以用<strong>多个反引号来开启和结束代码区段</strong>，同时起始和结束端都可以放入一个空白，<em>起始端后面一个，结束端前面一个</em>，这样你就可以<strong>在区段的一开始就插入反引号</strong>：如 A backtick-delimited string in a code span: <code>`foo`</code>、三个反引号就是写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`` `foo` ``</span><br><span class="line"># 三个反引号在hexo博客中显示可能会出问题</span><br><span class="line">`` ``` ``</span><br></pre></td></tr></table></figure><hr><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><h5 id="使用markdown语法插入图片："><a href="#使用markdown语法插入图片：" class="headerlink" title="使用markdown语法插入图片："></a>使用markdown语法插入图片：</h5><p>使用markdown插入图片与插入链接类似，也有两种方式：<strong>行内式和参考式</strong>，这里讲解的主要为行内式。关于参考式的用法可以<em>参考链接参考式</em>的用法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="comment">&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown插入图片"></p><center><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown+center标签居中插入图片"><br></center><div class="note info"><p><code>Optional title</code> 是用来在鼠标移到图片上时显示的title</p></div><div class="note warning"><p>使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别</p></div><hr><h5 id="html代码插入图片"><a href="#html代码插入图片" class="headerlink" title="html代码插入图片"></a>html代码插入图片</h5><p><strong>针对使用markdown插入图片的缺点，使用html语句可以很好的解决</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用img标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"图片名称"</span> <span class="attr">align</span>=<span class="string">center</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用div标签包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png"</span>  <span class="attr">title</span>=<span class="string">"使用html插入图片"</span>  <span class="attr">alt</span>=<span class="string">"图片名称"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" width="300" height="200" alt="图片名称" title="使用html插入图片" align="center"></p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" title="使用html插入图片" alt="图片名称"><br></div><div class="note warning"><ul><li>不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；</li><li>推荐使用div标签包裹img标签。</li></ul></div><hr><p><br></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>markdown支持以下这些符号前面<strong>加上反斜杠来帮助插入普通的符号</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="常见错误原因集锦"><a href="#常见错误原因集锦" class="headerlink" title="常见错误原因集锦"></a>常见错误原因集锦</h3><div class="note warning"><ul><li>html<strong>块级元素上下没有空格</strong>，块级元素是指 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签</li><li><strong>列表</strong>与前后内容之间没有空格</li><li><strong>列表</strong>内容和标记之间没有空格</li><li><strong>换行操作</strong>只回车没有在上一行文本末尾增加两个以上空格</li><li><strong>停止引用</strong>需要和下一行文本空行（另起一段），不然也会被引用进去</li><li><strong>代码</strong>最后的<code>`</code> <code></code>之后不能存在空格，不然会将后面的内容也写入代码内</li><li><strong>强调</strong>，不管是加粗还是斜体，<strong>标记<code>*</code>或`</strong><code>不能与文本之间存在距离**，不然会失效，标记会显示成标记本身，即</code>*<code>或</code>**`</li><li><strong>表格</strong>的语句<mark>上一行必须为空行</mark>，不然表格不生效</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener">markdown融合单元单元格问题</a></li><li><a href="http://www.tablesgenerator.com/text_tables" target="_blank" rel="noopener">Latex|html|markdown|text|mediawiki制作表格并得到相应源代码的利器</a></li><li><a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></li><li><a href="http://wow.kuapp.com/markdown/basic.html" target="_blank" rel="noopener">Markdown: Basics （快速入门）</a></li><li><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">Markdown 基本语法</a></li><li><a href="https://github.com/guoyunsky/Markdown-Chinese-Demo" target="_blank" rel="noopener">Markdown-Chinese-Demo</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed-文本处理工具</title>
      <link href="/posts/1752.html"/>
      <url>/posts/1752.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>sed处理文本，包括sed命令的基本格式、参数和命令说明、文本的替换、打印、删除、增加、插入以及其他常用的技巧（分组、传入参数、命令连用以及对文件进行读取和写入等）。</p></div><a id="more"></a><h2 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h2><p>sed是一种流编辑器，它是文本处理中非常中的工具，能够<strong>完美的配合正则表达式</strong>使用，功能不同凡响。处理时，把<strong>当前处理的行</strong>存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，<strong>接着处理下一行，这样不断重复，直到文件末尾（和awk都是对文件和输入的每一行进行操作）</strong>。<strong>文件内容并没有改变</strong>，除非你使用重定向存储输出。</p><p>sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><hr><h2 id="sed-用法"><a href="#sed-用法" class="headerlink" title="sed 用法"></a>sed 用法</h2><h3 id="sed-命令格式"><a href="#sed-命令格式" class="headerlink" title="sed 命令格式"></a>sed 命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...</span><br><span class="line"></span><br><span class="line">sed [options] <span class="string">'command'</span> file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure><hr><h3 id="sed-options说明"><a href="#sed-options说明" class="headerlink" title="sed options说明"></a>sed options说明</h3><table><tr><th width="20%">参数</th><th width="20%">完整参数</th><th width="60%">说明</th></tr><tr><td>-e script</td><td>–expression=script</td><td>以选项中的指定的script来处理输入的文本文件，直接在命令行模式上进行sed动作编辑，此为默认选项</td></tr><tr><td>-f script</td><td>–files=script</td><td>以选项中的指定的script文件来处理输入的文本文件</td></tr><tr><td>-i</td><td>–in-place</td><td>直接在原位修改原文件</td></tr><tr><td>-n</td><td>–quiet –silent</td><td>仅显示script处理后的结果</td></tr><tr><td>-E</td><td>正则表达式</td><td>该选项后面的正则表达式不需要进行转义，比如(、+等</td></tr><tr><td>-V</td><td>–version</td><td>显示版本信息</td></tr><tr><td>-h</td><td>–help</td><td>显示帮助</td></tr></table><hr><h3 id="sed-command说明"><a href="#sed-command说明" class="headerlink" title="sed command说明"></a>sed command说明</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>在当前行下面插入文本。</td></tr><tr><td>i</td><td>在当前行上面插入文本。</td></tr><tr><td>c</td><td>把选定的行改为新的文本。</td></tr><tr><td>d</td><td>删除，删除选择的行</td></tr><tr><td>D</td><td>删除模板块的第一行</td></tr><tr><td>s</td><td>替换指定字符</td></tr><tr><td>h</td><td>拷贝模板块的内容到内存中的缓冲区</td></tr><tr><td>H</td><td>追加模板块的内容到内存中的缓冲区</td></tr><tr><td>g</td><td>获得内存缓冲区的内容，并替代当前模板块中文本</td></tr><tr><td>G</td><td>获得内存缓冲区的内容，并追加到当前模板块文本的后面</td></tr><tr><td>l</td><td>列表不能打印字符的清单</td></tr><tr><td>n</td><td>读取下一个输入行，用下一个命令处理新的行而不是第一个命令</td></tr><tr><td>N</td><td>追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码</td></tr><tr><td>p</td><td>打印模板块的行</td></tr><tr><td>P</td><td>打印模板块的第一行</td></tr><tr><td>q</td><td>退出sed</td></tr><tr><td>b label</td><td>分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾</td></tr><tr><td>r file</td><td>从file中读行</td></tr><tr><td>t label</td><td>if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾</td></tr><tr><td>T label</td><td>错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾</td></tr><tr><td>w file</td><td>写并追加模板块到file末尾</td></tr><tr><td>W file</td><td>写并追加模板块的第一行到file末尾</td></tr><tr><td>!</td><td>表示后面的命令对所有没有被选定的行发生作用</td></tr><tr><td>=</td><td>打印当前行号</td></tr><tr><td>#</td><td>把注释扩展到第一个换行符以前</td></tr></tbody></table><hr><h3 id="sed-正则匹配元字符集"><a href="#sed-正则匹配元字符集" class="headerlink" title="sed 正则匹配元字符集"></a>sed 正则匹配元字符集</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配行开始，如：/^sed/匹配所有以sed开头的行。</td></tr><tr><td>$</td><td>匹配行结束，如：/sed$/匹配所有以sed结尾的行。</td></tr><tr><td>.</td><td>匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</td></tr><tr><td>*</td><td>匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</td></tr><tr><td>[]</td><td>匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。</td></tr><tr><td>[^]</td><td>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</td></tr><tr><td>(..)</td><td>匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。</td></tr><tr><td>&amp;</td><td>保存搜索字符用来替换其他字符，如s/love/&amp;/，love这成love。</td></tr><tr><td>&lt;</td><td>匹配单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</td></tr><tr><td>&gt;</td><td>匹配单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</td></tr><tr><td>x{m}</td><td>重复字符x，m次，如：/0{5}/匹配包含5个0的行。</td></tr><tr><td>x{m,}</td><td>重复字符x，至少m次，如：/0{5,}/匹配至少有5个0的行。</td></tr><tr><td>x{m,n}</td><td>重复字符x，至少m次，不多于n次，如：/0{5,10}/匹配5~10个0的行。</td></tr></tbody></table><hr><h3 id="需要转义的字符"><a href="#需要转义的字符" class="headerlink" title="需要转义的字符"></a>需要转义的字符</h3><p>在sed使用中经常遇到需要对字符进行转义的情况，这里列出需要转义的字符集：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">?</span><br><span class="line">*</span><br><span class="line">+</span><br><span class="line">()</span><br><span class="line">[</span><br><span class="line">\</span><br><span class="line">^</span><br><span class="line">$</span><br><span class="line">.</span><br><span class="line">| </span><br><span class="line">&lt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><mark>如果在使用sed命令进行正则匹配的时候不想进行转义(记住这些需要转义的字符太麻烦了吧，而且有时候容易忘)，可以<a href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D--e">使用-E选项</a></mark></p></div><hr><p><br></p><h2 id="sed-用法实例"><a href="#sed-用法实例" class="headerlink" title="sed 用法实例"></a>sed 用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test.txt</code><br>my cat’s name is betty<br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><h4 id="sed-替换标记"><a href="#sed-替换标记" class="headerlink" title="sed 替换标记"></a>sed 替换标记</h4><style>table th:first-of-type{width:10%}</style><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>g</td><td>表示行内全面替换</td></tr><tr><td>p</td><td>表示打印行</td></tr><tr><td>w</td><td>表示把行写入一个文件</td></tr><tr><td>x</td><td>表示互换模板块中的文本和缓冲区中的文本</td></tr><tr><td>y</td><td>表示把一个字符翻译为另外的字符（但是不用于正则表达式）</td></tr><tr><td>\1</td><td>子串匹配标记</td></tr><tr><td>&amp;</td><td>已匹配字符串标记</td></tr></tbody></table><hr><h4 id="sed-s-替换指定字符"><a href="#sed-s-替换指定字符" class="headerlink" title="sed s 替换指定字符"></a>sed s 替换指定字符</h4><p>将每一行文本中的This替换为sub<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">'s/is/are/'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略-e</span></span><br><span class="line">sed  <span class="string">'s/is/are/'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name are betty<br>Th<strong>are</strong> <strong>is</strong> your dog<br>my dog’s name are frank<br>Th<strong>are</strong> <strong>is</strong> your fish<br>my fareh’s name is george<br>Th<strong>are</strong> <strong>is</strong> your goat<br>my goat’s name are adam</p></blockquote><div class="note info"><ul><li>option的默认就是-e，所以-e可以省略</li><li><code>s命令</code>：替换指定字符指的是每一行的第一个发生替换，第二个以及后续的不会发生替换</li></ul></div><hr><h4 id="只打印那些发生替换的行"><a href="#只打印那些发生替换的行" class="headerlink" title="只打印那些发生替换的行"></a>只打印那些发生替换的行</h4><p><code>-n选项</code>和<code>p命令</code>一起使用表示<code>只打印</code>那些发生替换的行</p><div class="note info"><ul><li><code>-n选项</code>:仅显示script处理后的结果</li><li><code>p命令</code>:打印模板块的行</li><li>选项、命令、命令三者连用就是：打印处理后的模板块的行</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'s/is/are/p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name <strong>are</strong> betty<br>Th<strong>are</strong> is your dog<br>my dog’s name <strong>are</strong> frank<br>Th<strong>are</strong> is your fish<br>my f<strong>are</strong>h’s name is george<br>Th<strong>are</strong> is your goat<br>my goat’s name <strong>are</strong> adam</p></blockquote><hr><h4 id="全局替换"><a href="#全局替换" class="headerlink" title="全局替换"></a>全局替换</h4><p><code>g命令</code>表示行内全面替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  <span class="string">'s/is/are/g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><blockquote><p>my cat’s name <strong>are</strong> betty<br>Th<strong>are</strong> <strong>are</strong> your dog<br>my dog’s name <strong>are</strong> frank<br>Th<strong>are</strong> <strong>are</strong> your f<strong>are</strong>h<br>my f<strong>are</strong>h’s name <strong>are</strong> george<br>Th<strong>are</strong> <strong>are</strong> your goat<br>my goat’s name <strong>are</strong> adam</p></blockquote><div class="note info"><ul><li>注意与<code>单独的s命令</code>的结果对比</li><li><code>命令s</code>、<code>命令g</code>之间的<strong>顺序是固定的</strong></li></ul></div><hr><h4 id="从第几处开始替换"><a href="#从第几处开始替换" class="headerlink" title="从第几处开始替换"></a>从第几处开始替换</h4><p>从第二处开始替换：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/is/are/2'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果:</strong></p><blockquote><p>my cat’s name is betty<br>This are your dog<br>my dog’s name is frank<br>Th<em>is</em> <strong>are</strong> your f<em>is</em>h<br>my fish’s name are george<br>This are your goat<br>my goat’s name is adam</p></blockquote><div class="note info"><p>数字后面可以接<code>命令g</code>或者<code>命令p</code>等</p></div><p><strong>从每行中第N除开始全局替换：</strong></p><p><code>g命令</code><strong>之前加上数字N</strong>，表示从第N处之后的匹配开始全局替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/is/are/2g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name <strong>is</strong> betty<br>Th<strong>is</strong> <strong>are</strong> your dog<br>my dog’s name is frank<br>Th<strong>is</strong> <strong>are</strong> your f<strong>are</strong>h<br>my fish’s name are george<br>This are your goat<br>my goat’s name is adam</p></blockquote><div class="note info"><p>从第二处（包括）开始，后面的所有匹配上的都被替换掉了</p></div><hr><h3 id="以行为单位进行替换"><a href="#以行为单位进行替换" class="headerlink" title="以行为单位进行替换"></a>以行为单位进行替换</h3><p><code>命令c</code>：把选定的行改为新的文本</p><p>将第2-5行的内容取代成为this is sub of line 2-5<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c 和文字之间有没有空行都可以</span></span><br><span class="line">sed <span class="string">'2,5c this is sub of line 2-5'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br><em>this is sub of line 2-5</em><br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><p><strong>替换为多行的内容，只需要通过<code>\n</code>进行文本的换行即可：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2,5cthis is sub of line 2-5 \nthis is a second sub'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br><em>this is sub of line 2-5</em><br><em>this is a second sub</em><br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="原位修改文件"><a href="#原位修改文件" class="headerlink" title="原位修改文件"></a>原位修改文件</h3><p><code>选项i</code>：在文件的<strong>原位修改，不在屏幕输出</strong>，如果<strong>-i后跟着suffix</strong>，则会产生备份文件，形式为<code>原文件名suffix</code>。</p><p><code>命令g</code>也可以替换为其他命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i_suffix <span class="string">'s/is/are/g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p><code>ls</code><br>test.txt<br>test.txt_suffix</p></blockquote><blockquote><p><code>cat test.txt</code><br>my cat’s name are betty<br>Thare are your dog<br>my dog’s name are frank<br>Thare are your fareh<br>my fareh’s name are george<br>Thare are your goat<br>my goat’s name are adam</p></blockquote><hr><h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符/"></a>定界符/</h3><p>命令中字符 <code>/</code> 在sed中作为<code>定界符</code>使用，也<strong>可以使用任意的定界符</strong>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用冒号替代</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">'s:sk:ma:4g'</span></span><br><span class="line"><span class="comment"># 使用竖线替代</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">'s|sk|ma|4g'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>sksksk<strong>mamama</strong></p></blockquote><blockquote><p>sksksk<strong>mamama</strong></p></blockquote><div class="note info"><ul><li>定界符出现在样式内部时，需要进行<strong>转义</strong>或者直接<strong>更换定界符</strong></li><li>这个定界符个人感觉其实是用来作为<strong>正则匹配</strong>的，和<code>awk</code>用法相似</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/bin'</span> |sed <span class="string">'s/\/usr/\/test/g'</span></span><br><span class="line"><span class="comment"># 直接更换定界符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/bin'</span> |sed <span class="string">'s|/usr|/test|g'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>/test/local/bin</p></blockquote><blockquote><p>/test/local/bin</p></blockquote><hr><h3 id="已匹配字符串标记-amp"><a href="#已匹配字符串标记-amp" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><ul><li><code>&amp;</code>：已经匹配上的内容暂存在这个变量中，方便对已匹配内容进行处理</li></ul><p>正则表达式<code>\w\+</code>匹配每一个单词，使用<code>[&amp;]</code>替换它，<code>&amp;</code>对应之前所匹配到的单词：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span> line | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo test is a test line |sed &#39;s/\w\+/[&amp;]/g&#39;</code><br>[test] [is] [a] [test] [line]</p></blockquote><div class="note info"><ul><li>从上面可以看出，这种方法主要是用来针对<strong>一次匹配多个字符串</strong>，然后<strong>对多个字符串进行分开处理</strong>，而不是使用相同的处理（如使用同一个字符替换）</li></ul></div><hr><h3 id="正则匹配-E"><a href="#正则匹配-E" class="headerlink" title="正则匹配 -E"></a>正则匹配 -E</h3><p>前面的使用<code>&amp;</code>的过程中对<code>+</code>进行正则匹配时需要在前面加上<code>\</code>用来转义，这样比较麻烦，可以在sed中使用-E选项来直接使用<code>+</code>，而不用进行转义：</p><blockquote><p><code>echo test is a test line |sed &#39;s/\w+/[&amp;]/g&#39;</code><br>[test] [is] [a] [test] [line]</p></blockquote><hr><hr><h3 id="正则匹配-非贪婪"><a href="#正则匹配-非贪婪" class="headerlink" title="正则匹配-非贪婪"></a>正则匹配-非贪婪</h3><p>不管是基础的还是拓展的Posix/GNU正则表达式都不支持非贪婪匹配(Neither basic nor extended Posix/GNU regex recognizes the non-greedy quantifier)，如果想要使用非贪婪匹配需要进行问题的转化处理。</p><p>例：希望从<code>http://www.suon.co.uk/product/1/7/3/</code>得到<code>http://www.suon.co.uk</code>需要使用非贪婪匹配，如果直接使用sed:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  直接使用sed结合?进行非贪婪匹配并不能得到正确的结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http://www.suon.co.uk/product/1/7/3/"</span> |sed -n -E <span class="string">'s|(http://.*?)/.*|\1|p'</span> </span><br><span class="line">  http://www.suon.co.uk/product/1/7/3</span><br></pre></td></tr></table></figure><p></p><p>这个问题可以有如下几种解决办法：</p><ul><li><strong>借助perl来进行正则匹配</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用perl强大的正则匹配功能</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http://www.suon.co.uk/product/1/7/3/"</span> | perl -pe <span class="string">'s|(http://.*?)/.*|\1|'</span></span><br><span class="line">  http://www.suon.co.uk</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>仍然使用sed命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 借助了一般的正则匹配都支持的[^/]表示匹配任意非/的字符</span></span><br><span class="line"><span class="comment"># [^/]*表示前面的[^/]重复n次</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http://www.suon.co.uk/product/1/7/3/"</span> |sed -n -E <span class="string">'s|(http://[^/]*)/.*|\1|p'</span></span><br><span class="line">  http://www.suon.co.uk</span><br></pre></td></tr></table></figure></li><li><p><strong>grep结合了perl的正则</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意grep不能得到匹配的分组信息</span></span><br><span class="line"><span class="comment"># 借助其他的技巧可以</span></span><br><span class="line"><span class="comment"># 使用sed却可以</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http://www.suon.co.uk/product/1/7/3/"</span> |grep -oP <span class="string">'(http://.*?)/'</span></span><br><span class="line">  http://www.suon.co.uk/</span><br></pre></td></tr></table></figure></li></ul><p><strong>参考链接</strong>：<a href="https://superuser.com/questions/11130/can-gnu-grep-output-a-selected-group" target="_blank" rel="noopener">Can GNU Grep output a selected group?</a>、<a href="https://stackoverflow.com/questions/1103149/non-greedy-reluctant-regex-matching-in-sed" target="_blank" rel="noopener">Non greedy (reluctant) regex matching in sed?</a></p><hr><h3 id="分组标记-1-、-2"><a href="#分组标记-1-、-2" class="headerlink" title="分组标记\1 、\2"></a>分组标记\1 、\2</h3><ul><li><code>\1</code> 、<code>\2</code>：表示正则匹配的分组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">'s/digit \([0-9]\)/\1/'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo this is digit 7 in a number |sed &#39;s/digit \([0-9]\)/\1/&#39;</code><br>this is 7 in a number</p></blockquote><p>命令中digit 7，被替换成7。样式匹配到的子串是7，<code>\(..\)</code>用于匹配子串，对于匹配到的<strong>第一个子串</strong>标记为<code>\1</code>，依此类推匹配到的<strong>第二个结果</strong>就是<code>\2</code>,例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> aaa BBB | sed <span class="string">'s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo aaa BBB | sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;</code><br>BBB aaa</p></blockquote><p>上面的括号需要进行转义，可以直接使用<code>-E</code>来不用进行转义：</p><blockquote><p><code>echo aaa BBB | sed -E &#39;s/([a-z]+) ([A-Z]+)/\2 \1/&#39;</code><br>BBB aaa</p></blockquote><div class="note info"><ul><li>括号和<code>+</code>需要进行转义</li><li>可以使用<code>-E</code>选项来不进行转义</li></ul></div><hr><h3 id="传入变量-引用"><a href="#传入变量-引用" class="headerlink" title="传入变量-引用"></a>传入变量-引用</h3><p><code>sed</code>作为文本处理工具，可能经常需要传入变量来进行操作，这里提供了关于传入变量的方法，但是需要注意的是，<mark>如果表达式内部存在变量字符串，<strong>command的单引号就要变成双引号</strong></mark>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">"s/hello/<span class="variable">$test</span>/"</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo &quot;hello WORLD&quot; |sed &quot;s/hello/$test/&quot;</code><br>HELLO WORLD</p></blockquote><hr><h3 id="组合多个命令"><a href="#组合多个命令" class="headerlink" title="组合多个命令 ;"></a>组合多个命令 ;</h3><p>命令组合在Linux中是非常常见的，一般是使用<code>管道符</code>，在sed命令中可以使用<code>;</code>分割命令，这种用法同样和<code>awk</code>使用非常相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'表达式'</span> | sed <span class="string">'表达式'</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'表达式; 表达式'</span></span><br></pre></td></tr></table></figure><hr><h3 id="多个命令连用-e"><a href="#多个命令连用-e" class="headerlink" title="多个命令连用 -e"></a>多个命令连用 -e</h3><p><strong>选项-e本就是sed的默认选项</strong>，用于说明使用的是command而不是文件命令形式，多个命令连用，<strong>注意是有前后顺序的连用</strong>，在连用的command之前加上-e即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">'1,5d'</span> -e <span class="string">'s/my/MY/'</span> test.txt</span><br></pre></td></tr></table></figure><p>先删除test.txt文件中的第1、5行，输出删除的内容，然后对这两行进行将my替换为MY。</p><p><strong>最终结果：</strong></p><blockquote><p>This is your goat<br>MY goat’s name is adam</p></blockquote><div class="note info"><p>这个方式进行命令的连用和上面使用分号<code>;</code>将不同命令连写的方式<strong>效果相同</strong></p></div><hr><h3 id="使用-连用命令"><a href="#使用-连用命令" class="headerlink" title="使用{}连用命令"></a>使用<code>{}</code>连用命令</h3><p>使用<code>{}</code>将需要连用的命令包围，并使用<code>;</code>将多个命令隔开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/This/&#123;s/This/this/;n;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><div class="note info"><ul><li><code>命令n</code>：当前匹配行的下一行</li><li><code>选项n</code>：仅显示script处理后的结果</li></ul></div><hr><h3 id="选定行的范围-逗号"><a href="#选定行的范围-逗号" class="headerlink" title="选定行的范围 ,(逗号)"></a>选定行的范围 ,(逗号)</h3><p>选取行的范围来对文本进行处理，可以使用在不同行之间加逗号<code>,</code>的方式</p><p>打印从<strong>第5行开始</strong>到<strong>第一个包含以this开始的行之间的所有行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'5,/^This/p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>sed -n ‘5,/^This/p’ test.txt<br>my fish’s name is george<br>This is your goat</p></blockquote><div class="note info"><ul><li>行的索引<strong>开始于1</strong></li><li>需要注意的是：是包含尾部的，<code>5,7p</code>是<strong>包含</strong>第七行的</li><li>选取行号之后不仅仅可以用来做打印，还可以进行其他操作，具体见本文<strong>使用实战</strong></li></ul></div><hr><h3 id="打印命令-p"><a href="#打印命令-p" class="headerlink" title="打印命令 p"></a>打印命令 p</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印第3行</span></span><br><span class="line">sed -n <span class="string">'3p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第3-5行</span></span><br><span class="line">sed -n <span class="string">'3,5p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字和正则表达式连用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第1行开始，第一次出现This结束之间的行（起始行固定，终止行第一次正则匹配位置）</span></span><br><span class="line">sed -n <span class="string">'1,/This/p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始行固定，终止行第一次正则匹配位置</span></span><br><span class="line">sed -n <span class="string">"/my cat's name is betty/,/This/p"</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次匹配到This的行到第3行，然后再输出所有匹配到This的行</span></span><br><span class="line">sed -n <span class="string">'/This/,3p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果含有This的行在第1行之后，则打印所有含有This的行</span></span><br><span class="line">sed -n <span class="string">'/This/,1p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始行和终止行都不固定，打印全文</span></span><br><span class="line">sed -n <span class="string">'/my/,/This/p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;3p&#39; test.txt</code><br>my dog’s name is frank</p></blockquote><blockquote><p><code>sed -n &#39;3,5p&#39; test.txt</code><br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george</p></blockquote><blockquote><p><code>sed -n &#39;1,/This/p&#39; test.txt</code><br>my cat’s name is betty<br>This is your dog</p></blockquote><blockquote><p><code>sed -n &quot;/my cat&#39;s name is betty/,/This/p&quot; test.txt</code><br>my cat’s name is betty<br>This is your dog</p></blockquote><blockquote><p><code>sed -n &#39;/This/,3p&#39; test.txt</code><br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>This is your goat</p></blockquote><blockquote><p><code>sed -n &#39;/This/,1p&#39; test.txt</code><br>This is your dog<br>This is your fish<br>This is your goat</p></blockquote><blockquote><p><code>sed -n &#39;/my/,/This/p&#39; test.txt</code><br>my cat’s name is betty<br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><div class="note warning"><ul><li>使用<strong>打印命令p</strong>时需要注意，<strong>sed默认会打印出所有的行</strong>（命令d除外，只会打印保留下来的行），所以<strong>想要打印出特定修改过的行需要加上选项n</strong>，如果不加，<mark>匹配上的行会打印两遍</mark></li><li>使用正则表达式进行匹配打印时需要特别小心</li><li>如果数字在前面，是<strong>从数字开始</strong>到<strong>第一次匹配到正则表达式的部分（1就是从1开始，3就是从3开始看后面第一次匹配的）</strong></li><li><mark>如果数字在后面，正则表达式在前面，那么一定会将全文中包含正则表达式的全部输出，其他部分如果数字大于正则表达式第一次出现的行，则输出正则表达式第一次出现的行到数字之间的其他内容，如果数字小于正则表达式第一次出现的行，那就只会打印包含正则表达式的行。<strong>全文匹配正则表达式的输出以及正则表达式第一次出现的行到数字之间的其他内容输出</strong></mark></li><li>如果<strong>前后都为正则表达式</strong>，则<strong>输出全文内容</strong></li><li>关于上述正则表达式我的理解：因为数字是完全确定的，开始和结束行都很确定，所以可以很明确输出想要的结果，但是如果是正则表达式的话，不是唯一的匹配结果（段落中有几行都可以匹配上），那么如果正则表达式在前，则不知道从第几行开始当起始行，所以如果数字大于第一个匹配位置所在的行，那么以第一个匹配位置所在的行为起始行到数字规定的终止行之间的行都会输出，同时起始行可能有很多（其他位置也有匹配），所以还会输出其他匹配位置作为开始，这时如果数字小于第二个匹配位置的话，就只会输出匹配正则表达式的行，同时如果数字大于第二个匹配位置，由于第一个匹配位置的输出已经包含第二个位置，所以不会再输出一遍第二个匹配位置到终止行的信息</li></ul></div><div class="note info"><p>说了很多，总结一下：<mark>使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。</mark></p></div><hr><h3 id="匹配模式取反-！"><a href="#匹配模式取反-！" class="headerlink" title="匹配模式取反 ！"></a>匹配模式取反 ！</h3><p>打印除第一行和第二行之外的其他行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'1,2!p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;1,2!p&#39; test.txt</code><br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号 ="></a>显示行号 =</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/my/&#123;=;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;/my/{=;p}&#39; test.txt</code><br>1<br>my cat’s name is betty<br>3<br>my dog’s name is frank<br>5<br>my fish’s name is george<br>7<br>my goat’s name is adam</p></blockquote><hr><h3 id="删除命令-d"><a href="#删除命令-d" class="headerlink" title="删除命令 d"></a>删除命令 d</h3><ul><li><code>命令d</code>：删除，删除选择的行</li></ul><h4 id="删除空白行"><a href="#删除空白行" class="headerlink" title="删除空白行"></a>删除空白行</h4><blockquote><p><code>cat test2.txt</code><br>my cat’s name is betty</p><p>this is your this dog</p><p>my dog’s name is this frank</p><p>this is your fish</p><p>my fish’s name is this george</p><p>this is your goat</p><p>my goat’s name is this adam</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^$/d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>this is your this dog<br>my dog’s name is this frank<br>this is your fish<br>my fish’s name is this george<br>this is your goat<br>my goat’s name is this adam</p></blockquote><div class="note info"><ul><li>空白行的表示方法：<code>^$</code> (开头和结尾之间的内容为空)</li></ul></div><hr><h4 id="删除含有固定单词的行"><a href="#删除含有固定单词的行" class="headerlink" title="删除含有固定单词的行"></a>删除含有固定单词的行</h4><p><code>&lt;</code>：匹配单词的开始，注意需要转义<br><code>&gt;</code>：匹配单词的结束，注意需要转义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/\&lt;This\&gt;/d'</span> test.txt</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>sed &#39;/\&lt;This\&gt;/d&#39; test.txt</code><br>my cat’s name is betty<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><hr><h4 id="正则匹配删除-删除文件中所有以my开头的行"><a href="#正则匹配删除-删除文件中所有以my开头的行" class="headerlink" title="正则匹配删除-删除文件中所有以my开头的行"></a>正则匹配删除-删除文件中所有以my开头的行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>this is your this dog</p><p>this is your fish</p><p>this is your goat</p></blockquote><hr><h4 id="从某一行开始删除"><a href="#从某一行开始删除" class="headerlink" title="从某一行开始删除"></a>从某一行开始删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2,$d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed &#39;2,$d&#39; test2.txt</code><br>my cat’s name is betty</p></blockquote><div class="note info"><ul><li>最后一行：<code>$</code></li><li>首行不是<code>^</code>，直接使用1</li></ul></div><hr><h4 id="删除文件最后一行"><a href="#删除文件最后一行" class="headerlink" title="删除文件最后一行"></a>删除文件最后一行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'$d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty</p><p>this is your this dog</p><p>my dog’s name is this frank</p><p>this is your fish</p><p>my fish’s name is this george</p><p>this is your goat</p></blockquote><div class="note info"><ul><li>最后一行：<code>$</code></li><li>可以发现前面删掉空行的操作没有影响原始文件，如果想修改原始文件，可以加上<code>选项i</code></li></ul></div><hr><h3 id="写入文件-w命令"><a href="#写入文件-w命令" class="headerlink" title="写入文件 w命令"></a>写入文件 w命令</h3><p>在test.txt中所有包含my的行都被<strong>写入test2.txt</strong>里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/my/w test2.txt'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>cat test2.txt</code><br>my cat’s name is betty<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><hr><h3 id="从文件读入-r命令"><a href="#从文件读入-r命令" class="headerlink" title="从文件读入 r命令"></a>从文件读入 r命令</h3><p>file里的内容被读进来，<strong>显示在与test.txt匹配的行后面</strong>，如果<strong>匹配多行</strong>，则file的内容将<strong>显示在所有匹配行的下面</strong>：</p><blockquote><p>cat test1.txt<br>aaaaaaaa</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/my/r test1.txt'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><strong>my</strong> cat’s name is betty<br><em>aaaaaaaaa</em><br>This is your dog<br><strong>my</strong> dog’s name is frank<br><em>aaaaaaaaa</em><br>This is your fish<br><strong>my</strong> fish’s name is george<br><em>aaaaaaaaa</em><br>This is your goat<br><strong>my</strong> goat’s name is adam<br><em>aaaaaaaaa</em></p></blockquote><hr><h3 id="追加文件-a"><a href="#追加文件-a" class="headerlink" title="追加文件 a\"></a>追加文件 a\</h3><p><strong>追加与上述读取不同</strong>，虽然两者<strong>都是讲在匹配的行下增加文本信息</strong>，但是读取处理的是<strong>两个文件</strong>，追加处理的是<strong>一个文件和一行或多行文本</strong>。</p><p><strong>a后面的反斜杠可有可无</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/a\this is a test line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><em>my</em> cat’s name is betty<br><em>this is a test line</em><br>This is your dog<br><em>my</em> dog’s name is frank<br><em>this is a test line</em><br>This is your fish<br><em>my</em> fish’s name is george<br><em>this is a test line</em><br>This is your goat<br><em>my</em> goat’s name is adam<br><em>this is a test line</em></p></blockquote><p>同样也可以通过追加操作也<strong>增加两行甚至多行内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/a\this is a test line \nthis is second line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>通过使用<code>\n</code>进行换行操作来达到增加多行的目的</strong></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>this is a test line<br><em>this is second line</em><br>This is your dog<br>my dog’s name is frank<br>this is a test line<br><em>this is second line</em><br>This is your fish<br>my fish’s name is george<br>this is a test line<br><em>this is second line</em><br>This is your goat<br>my goat’s name is adam<br>this is a test line<br><em>this is second line</em></p></blockquote><div class="note info"><p>如果命令a之前什么都不加，表明给在每一行下都增加文本<br>当然，a之前也可以是单纯的数字</p></div><hr><h3 id="插入操作-i"><a href="#插入操作-i" class="headerlink" title="插入操作 i\"></a>插入操作 i\</h3><p>插入操作和上述追加和读取操作都不同，<mark>插入是在匹配行的上面进行插入，而追加和读取是在匹配行的下方进行的追加</mark>，同时插入和追加操作都是针对单个文件和一行或多行文本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/i\this is insert line'</span> test.txt</span><br></pre></td></tr></table></figure><blockquote><p><em>this is insert line</em><br>my cat’s name is betty<br>This is your dog<br><em>this is insert line</em><br>my dog’s name is frank<br>This is your fish<br><em>this is insert line</em><br>my fish’s name is george<br>This is your goat<br><em>this is insert line</em><br>my goat’s name is adam</p></blockquote><p><strong>在匹配文本上方插入多行的操作与追加类似，都是使用<code>\n</code>换行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/i\this is insert line \nthis is second insert line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p>this is insert line<br><em>this is second insert line</em><br>my cat’s name is betty<br>This is your dog<br>this is insert line<br><em>this is second insert line</em><br>my dog’s name is frank<br>This is your fish<br>this is insert line<br><em>this is second insert line</em><br>my fish’s name is george<br>This is your goat<br>this is insert line<br><em>this is second insert line</em><br>my goat’s name is adam</p></blockquote><hr><h3 id="匹配行的下一行-n命令"><a href="#匹配行的下一行-n命令" class="headerlink" title="匹配行的下一行 n命令"></a>匹配行的下一行 n命令</h3><p>打印匹配字符串的下一行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个写法会使得以my开头的行被打印两遍，是错误的</span></span><br><span class="line">sed <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法是仅显示script处理后的结果</span></span><br><span class="line">sed -n <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;/my/{n;p}&#39; test.txt</code><br>hhhh is your dog<br>This is your fish<br>This is your goat</p></blockquote><p><strong>在原始test文件中增加了一行用于防止和普通的替换混淆</strong></p><p>如果my被匹配，则<strong>移动到匹配行的下一行</strong>，<strong>替换这一行</strong>的this为This,并打印该行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/my/&#123;n;s/This/this/; &#125;'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述式子不等于</span></span><br><span class="line">sed <span class="string">'/my/n;s/This/this/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终输出：</strong></p><blockquote><p>my cat’s name is betty<br>hhhh is your dog<br><strong>This</strong> is your dog<br>my dog’s name is frank<br><strong>this</strong> is your fish<br>my fish’s name is george<br><strong>this</strong> is your goat<br>my goat’s name is adam</p></blockquote><p><strong>不是以my为开头的下一行的This不会被替换为this</strong></p><div class="note info"><p>注意<code>花括号{}</code>，不能丢掉</p></div><p><mark>使用grep、awk得到匹配行的下一行</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -A 1 my test.txt</span><br><span class="line">sed -n <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br><span class="line">awk <span class="string">'/my/&#123;getline; print&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="字符变换-y命令"><a href="#字符变换-y命令" class="headerlink" title="字符变换 y命令"></a>字符变换 y命令</h3><p>把1~10行内所有<strong>abcde转变为大写</strong>，注意，<strong>正则表达式元字符不能使用这个命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1,10y/abcde/ABCDE/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my CAt’s nAmE is BEtty<br>hhhh is your Dog<br>This is your Dog<br>my Dog’s nAmE is frAnk<br>This is your fish<br>my fish’s nAmE is gEorgE<br>This is your goAt<br>my goAt’s nAmE is ADAm</p></blockquote><div class="note info"><ul><li>注意这个和<strong>普通的替换不同</strong>，替换是将abcde这个字符串进行替换为ABCDE字符串，而这里是将<strong>a、b、c、d、e变为大写</strong>；</li><li>与通过<strong>已匹配字符串&amp;</strong>也不同，这个更为简单</li></ul></div><hr><h3 id="显示分隔符等详细信息-l命令"><a href="#显示分隔符等详细信息-l命令" class="headerlink" title="显示分隔符等详细信息 l命令"></a>显示分隔符等详细信息 l命令</h3><p>如果想知道文件内容的具体分割符，以及其他不能打印的字符信息可以使用’l’命令：</p><blockquote><p><code>sed -n &#39;l&#39; test3.txt</code><br>tab<code>\t</code>sep<code>\t</code>end<code>$</code><br>blank sep end<code>$</code><br>adsfaaaaaaaaaaaaaaaaafdadfasdfasdfasdfasdfsaaavfcadsasd asda asafdafa<code>\</code><br>sd<code>$</code></p></blockquote><p><strong>每行显示30个字符（包括最后的<code>\</code>）</strong>:</p><blockquote><p><code>sed -n &#39;l30&#39; test3.txt</code><br>tab<code>\t</code>sep<code>\t</code>end<code>$</code><br>blank sep end<code>$</code><br>adsfaaaaaaaaaaaaaaaaafdadfasd<code>\</code><br>fasdfasdfasdfsaaavfcadsasd as<code>\</code><br>da asafdafasd<code>$</code></p></blockquote><div class="note info"><p><code>l</code>命令用明确的形式显示模版空间的数据：</p><ul><li>以<code>C-style</code>的<strong>转义形式显示不能打印的字符(换行符、制表符等)</strong>和<strong>本身的<code>\Char</code>形式</strong></li><li><strong>长的行将进行分割</strong>，以字符<code>\</code>结尾的行<strong>表示分割</strong>，以字符<code>$</code>结尾的行表示<strong>分割结束</strong></li><li><code>n</code>指定显示行的长度，超过就进行分割；<strong>若为0表示不分割所有行</strong>；没有指定时就取命令行选项<code>-l</code>的设置，再没有就取<strong>默认值70</strong>。这是GNU的扩展功能</li></ul></div><hr><h3 id="打印奇数行或偶数行"><a href="#打印奇数行或偶数行" class="headerlink" title="打印奇数行或偶数行"></a>打印奇数行或偶数行</h3><h4 id="方法一：通过下一行（命令n）的方式"><a href="#方法一：通过下一行（命令n）的方式" class="headerlink" title="方法一：通过下一行（命令n）的方式"></a>方法一：通过下一行（命令n）的方式</h4><p><strong>打印奇数行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'p;n'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>This is your dog<br>This is your fish<br>This is your goat</p></blockquote><p><strong>打印偶数行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'n;p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>hhhh is your dog<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><div class="note info"><ul><li><code>命令n在前</code>而<code>p在后</code>为打印偶数行</li><li><code>命令p在前</code>而<code>n在后</code>为打印奇数行</li><li><code>命令n</code>为当前匹配的下一行</li></ul></div><hr><h4 id="方法二：简单方法"><a href="#方法二：简单方法" class="headerlink" title="方法二：简单方法"></a>方法二：简单方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印奇数行</span></span><br><span class="line">sed -n <span class="string">'1~2p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印偶数行</span></span><br><span class="line">sed -n <span class="string">'2~2p'</span> test.txt</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="在开头添加start"><a href="#在开头添加start" class="headerlink" title="在开头添加start"></a>在开头添加start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要里面的空格也是有用的</span></span><br><span class="line">sed <span class="string">'s/^/start /'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><code>sed &#39;s/^/start /&#39; test.txt</code><br>start my cat’s name is betty<br>start This is your dog<br>start my dog’s name is frank<br>start This is your fish<br>start my fish’s name is george<br>start This is your goat<br>start my goat’s name is adam</p></blockquote><hr><h3 id="在结尾增加end"><a href="#在结尾增加end" class="headerlink" title="在结尾增加end"></a>在结尾增加end</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要里面的空格也是有用的</span></span><br><span class="line">sed <span class="string">'s/$/ END/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><code>sed &#39;s/$/ END/&#39; test.txt</code><br>my cat’s name is betty END<br>This is your dog END<br>my dog’s name is frank END<br>This is your fish END<br>my fish’s name is george END<br>This is your goat END<br>my goat’s name is adam END</p></blockquote><hr><h3 id="在前三行之前增加-号做注释"><a href="#在前三行之前增加-号做注释" class="headerlink" title="在前三行之前增加#号做注释"></a>在前三行之前增加#号做注释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1,3s/^/# /'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed &#39;1,3s/^/# /&#39; test.txt</code><br># my cat’s name is betty<br># This is your dog<br># my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="将连续的空白替换为tab"><a href="#将连续的空白替换为tab" class="headerlink" title="将连续的空白替换为tab"></a>将连续的空白替换为tab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat -A </span></span><br><span class="line"><span class="comment"># 存在连续的多个空白，也存在tab</span></span><br><span class="line">LJ_WB_mtDNA_1^I14963320^I2553170^I17.06^I1785293^I11.93$</span><br><span class="line">LJ_WB_mtDNA_5   6511598 587331  9.01    413712  6.35$</span><br><span class="line">LJ_WB_mtDNA_4   8663156 531768  6.13    375148  4.33$</span><br><span class="line">LJ_WB_mtDNA_2^I16236228^I1298993^I8.00^I907074^I5.58$</span><br><span class="line">LJ_WB_mtDNA_3^I13546770^I1206932^I8.90^I842322^I6.21$</span><br><span class="line">LJ_frozen_2   6214534 1868771 30.07   1477904 23.78$</span><br><span class="line">LJ_frozen_1   9232822 3122994 33.82   2476874 26.82$</span><br></pre></td></tr></table></figure><p>如果想要将<strong>连续的多个空白</strong>替换为<strong>单个tab键</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接将空白替换会出现很多的tab</span></span><br><span class="line">sed <span class="string">'s/ /\t/g'</span> batch_9.txt |cat -A</span><br><span class="line">  LJ_WB_mtDNA_2^I16236228^I1298993^I8.00^I907074^I5.58$</span><br><span class="line">  LJ_WB_mtDNA_3^I13546770^I1206932^I8.90^I842322^I6.21$</span><br><span class="line">  LJ_frozen_2^I^I^I6214534^I1868771^I30.07^I^I^I1477904^I23.78$</span><br><span class="line">  LJ_frozen_1^I^I^I9232822^I3122994^I33.82^I^I^I2476874^I26.82$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用+不起作用</span></span><br><span class="line">sed <span class="string">'s/ +/\t/g'</span> batch_9.txt</span><br><span class="line"><span class="comment"># 注意这里的+号需要转义</span></span><br><span class="line">sed <span class="string">'s/ \+/\t/g'</span> batch_9.txt</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="sed中进行变量替换"><a href="#sed中进行变量替换" class="headerlink" title="sed中进行变量替换"></a>sed中进行变量替换</h3><p><code>sed</code>中的<code>command</code>部分默认是使用的单引号<code>&#39;&#39;</code>，但是如果想要进行变量替换，在之前的<a href="http://showteeth.tech/posts/55603.html">这篇博客</a>中也学习过关于单引号和双引号的区别：<strong>单引号不允许任何变量、元字符、通配符、转义符的解析，而双引号保护特殊元字符和通配符不被shell解析，但是允许变量和命令替换，以及转义符的解析</strong>。</p><p>所以为了在<code>sed</code>中的<code>command</code>部分使用变量替换就需要将单引号替换为双引号：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号不能进行变量替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test=test_tmp"</span> |sed <span class="string">'s/test_tmp/$&#123;test&#125;/'</span> </span><br><span class="line">  <span class="built_in">test</span>=<span class="variable">$&#123;test&#125;</span></span><br><span class="line"><span class="comment"># 使用双引号完成变量替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test=test_tmp"</span> |sed <span class="string">"s/test_tmp/<span class="variable">$&#123;test&#125;</span>/"</span> </span><br><span class="line">  <span class="built_in">test</span>=16</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="使用技巧及注意事项"><a href="#使用技巧及注意事项" class="headerlink" title="使用技巧及注意事项"></a>使用技巧及注意事项</h2><ul><li>使用<strong>打印命令p</strong>时需要注意，<strong>sed默认会打印出所有的行</strong>（命令d除外，只会打印保留下来的行），所以<strong>想要打印出特定修改过的行需要加上选项n</strong></li><li>区分<code>选项</code>和<code>命令</code>的<strong>关系和书写相对位置</strong>（如选项和命令都有n，但是作用却不同）</li></ul><div class="note info"><p>使用正则表达式进行匹配打印时需要特别小心，总结一下：<mark>使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。</mark></p></div><hr><h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><h3 id="unknown-option-to-s’"><a href="#unknown-option-to-s’" class="headerlink" title="unknown option to `s’"></a>unknown option to `s’</h3><p>报错提示：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/LogTemp/<span class="variable">$&#123;log_folder&#125;</span>/g"</span> LYN-1.run</span><br><span class="line">  sed: -e expression <span class="comment">#1, char 12: unknown option to `s'</span></span><br></pre></td></tr></table></figure><p></p><p>报错原因：需要替换的变量中存在<code>/</code>，这里需要注意，<strong>我的情况其实是这样的</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希望将其中的LogTemp替换为目录</span></span><br><span class="line"><span class="comment">#BSUB -o LogTemp/SampleTmp_gatk_out.%J</span></span><br><span class="line"><span class="comment">#BSUB -e LogTemp/SampleTmp_gatk_err.%J</span></span><br></pre></td></tr></table></figure><p></p><p>所以其实是因为<code>s/LogTemp/${log_folder}/g</code>可以匹配到<code>LogTemp/</code>，从而导致分隔符的混乱，最终导致了报错。</p><p>解决办法：解决办法其实很简单，将<code>/</code>替换为<code>|</code>，也就是<code>sed -i &quot;s|LogTemp|${log_folder}|g&quot; LYN-1.run</code>即可。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/sed" target="_blank" rel="noopener">sed命令</a></li><li><a href="https://www.cnblogs.com/ctaixw/p/5860221.html" target="_blank" rel="noopener">sed命令详解，很多关于实战的讲的很好！！！</a></li><li><a href="https://www.cnblogs.com/maxincai/p/5146338.html" target="_blank" rel="noopener">sed命令用法</a></li><li><a href="https://github.com/dongweiming/sed_and_awk/blob/master/index.html" target="_blank" rel="noopener">sed_and_awk，github上148星</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大致计划</title>
      <link href="/posts/18198.html"/>
      <url>/posts/18198.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>对于想学习内容的大致实施计划，需要根据实际情况灵活更改。</p></div><a id="more"></a><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><div class="note success"><ul><li>Linux的内容比较细小，可以使用零散的时间来学习；</li><li>机器学习的内容需要学习的连贯性，需要大量时间学习和理解；</li><li>Python学习还好，介于Linux和机器学习内容之间；</li><li>其他内容的学习不是很急切，但是一些工具性的可以先学习，比如git以及markdown，时间需求不是很大；</li><li>可以将Linux中比较大的内容和其他内容学习中比较小的内容搭配，比如sed命令和下面的markdown搭配这种；</li><li>大块的内容比如机器学习和Python可以放在晚上10-1点半之间（每天3个小时）？这个还需要考虑；</li><li>机器学习和Python学习的内容可以放在github上。</li></ul></div><h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="机器学习学习"><a href="#机器学习学习" class="headerlink" title="机器学习学习"></a>机器学习学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="其他内容学习"><a href="#其他内容学习" class="headerlink" title="其他内容学习"></a>其他内容学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他想学习的内容</title>
      <link href="/posts/49862.html"/>
      <url>/posts/49862.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>其他想学习的内容汇总，包括Latex排版、git使用、readthedocs+mkdocs静态网站、markdown学习、docker学习以及snakemake等内容，如果遇到后续会持续添加。</p></div><a id="more"></a><h2 id="markdown学习"><a href="#markdown学习" class="headerlink" title="markdown学习"></a>markdown学习</h2><p>&emsp;&emsp;在后面的学习中，我将尽可能使用markdown进行文档的编写，这样看着更加美观，所以有必要对齐进行完善的学习，同时在真正的语法与在博客中遇到的可能有所差别，所以这里的将主要关注一些基础的语法，其他在博客写作中常用的可以参考之前写的博客。</p><div><br><a class="btn" href="http://showteeth.tech/posts/65136.html"><i class="fa fa-telegram fa-lg fa-fw"></i>markdown基础语法学习</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/37746.html"><i class="fa fa-telegram fa-lg fa-fw"></i>next-markdown技巧和模板</a><br></div><hr><p><br></p><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><p>&emsp;&emsp;接触到github之后，git操作是经常需要使用的，所以对其进行学习非常有必要。</p><div><br><a class="btn" href="http://showteeth.tech/posts/13035.html"><i class="fa fa-telegram fa-lg fa-fw"></i>转载-Git讲解与使用实战</a><br></div><br><div><br><a class="btn" href="http://showteeth.tech/posts/13404.html"><i class="fa fa-telegram fa-lg fa-fw"></i>转载-Git常用命令及日常问题集锦</a><br></div><hr><p><br></p><h2 id="Latex排版"><a href="#Latex排版" class="headerlink" title="Latex排版"></a>Latex排版</h2><p>&emsp;&emsp;第一次真正见识到latex是看到清本大佬使用latex对课程<mark>论文进行排版</mark>以及<mark>数学公式编写</mark>，觉得非常牛逼，同时也反思了自己的本科经历，果然大佬就是大佬！啥也不说了学习吧。</p><div><br><a class="btn" href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>一份其实很短的 LaTeX 入门文档</a><br></div><div><br><a class="btn" href="http://liyangbit.com/math/jupyter-latex/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Markdown中输入数学公式及LaTex常用数学符号整理</a><br></div><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>刘海洋-latex入门</a><br></div><hr><p><br></p><h2 id="readthedocs-mkdocs静态网站"><a href="#readthedocs-mkdocs静态网站" class="headerlink" title="readthedocs+mkdocs静态网站"></a>readthedocs+mkdocs静态网站</h2><p>&emsp;&emsp;在binbin师兄的带领下，也算是接触了一下readthedocs+mkdocs静态网站（写技术文档），感觉也挺好看的，可以用来展示自己使用markdown编写的一些文本，主要是指项目。</p><div><br><a class="btn" href="https://www.mkdocs.org/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>mkdocs的官方网站</a><br></div><hr><h3 id="好用的参考"><a href="#好用的参考" class="headerlink" title="好用的参考"></a>好用的参考</h3><div class="note info"><ul><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">很好的教程</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/extensions/admonition/" target="_blank" rel="noopener">mkdocs可用的拓展</a></li></ul></div><hr><p><br></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>&emsp;&emsp;docker是开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><div><br><a class="btn" href="http://showteeth.tech/posts/371.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Docker-构建第一个docker镜像</a><br></div><div><br><a class="btn" href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Docker——从入门到实践</a><br></div><hr><p><br></p><h2 id="snakemake"><a href="#snakemake" class="headerlink" title="snakemake"></a>snakemake</h2><p>&emsp;&emsp;snakemake是用来编写任务流程的工具。</p><div><br><a class="btn" href="https://www.jianshu.com/p/14b9eccc0c0e" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>snakemake使用笔记</a><br></div><div><br><a class="btn" href="https://slowkow.com/notes/snakemake-tutorial/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>snakemake-tutorial</a><br></div><div><br><a class="btn" href="https://www.jianshu.com/p/8e57fd2b81b2" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>使用Snakemake搭建分析流程</a><br></div><div><br><a class="btn" href="https://www.jianshu.com/p/14b9eccc0c0e" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>实例-binbin师兄写的</a><br></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> 其他内容学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习学习计划</title>
      <link href="/posts/130.html"/>
      <url>/posts/130.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>需要学习的机器学习内容汇总，包括自己总结的学习路线、书本和视频内容学习、竞赛等实战项目、很好的博主和网站以及收藏的shell相关书本等相关内容。</p></div><a id="more"></a><h2 id="自己规划的学习路线"><a href="#自己规划的学习路线" class="headerlink" title="自己规划的学习路线"></a>自己规划的学习路线</h2><h3 id="第一阶段-经典课程学习"><a href="#第一阶段-经典课程学习" class="headerlink" title="第一阶段-经典课程学习"></a>第一阶段-经典课程学习</h3><p>&emsp;&emsp;我觉得可以先通过一些<strong>经典课程</strong>，比如<strong>吴恩达老师</strong>或者<strong>林轩田老师</strong>在Coursera上的课程视频来对机器学习有一个初步了解，并通过课程配套的<strong>编程习题</strong>来动手实现一下算法，来提升一些感性的认识。</p><hr><h3 id="第二阶段-经典教材学习"><a href="#第二阶段-经典教材学习" class="headerlink" title="第二阶段-经典教材学习"></a>第二阶段-经典教材学习</h3><p>&emsp;&emsp;之后再选择一本<strong>经典教材</strong>，学习其中<strong>理论和算法的基础部分</strong>。同时也可以尝试把讲到的算法实现一下，这样将书本和实践结合起来的办法，我觉得比较有效，这个过程的学习可以<strong>与第一个阶段同时进行</strong>，学习经典的书本的时候参考视频可以加深理解，目前很多书本都有相应的视频学习课程。</p><hr><h3 id="第三阶段-实战"><a href="#第三阶段-实战" class="headerlink" title="第三阶段-实战"></a>第三阶段-实战</h3><p>&emsp;&emsp;通过这两个阶段的学习，已经<strong>掌握了机器学习的基本原理</strong>，并且对常用的经典算法，如boosting, svm, logistic regression乃至neural network比较熟悉以后，就可以考虑做一个<strong>大的project</strong>, 例如尝试参加一个在线的<strong>数据科学竞赛</strong>，通过这样一个过程，可能就能真正体会到入门的感觉。</p><hr><h3 id="第三阶段-提升"><a href="#第三阶段-提升" class="headerlink" title="第三阶段-提升"></a>第三阶段-提升</h3><p>&emsp;&emsp;借助一些比较经典的、但是也需要一些基础的书来进行提升阶段的学习。</p><div class="note info">如果只是想在毕业之后能找到算法工程师的工作，《统计学习方法》、CS229、CS231N、《deep learning》这些书再加上leetcode、数据挖掘比赛、以及相关项目经验就已经足够</div><hr><p><br></p><h2 id="课程与教材学习"><a href="#课程与教材学习" class="headerlink" title="课程与教材学习"></a>课程与教材学习</h2><p>&emsp;&emsp;现在机器学习部分主要是想根据书本进行学习，同时借助相应的视频课程，也就是上面自己总结学习路线的第一个和第二个阶段。</p><div class="note default"><br><i class="fa fa-square"></i> 《统计学习方法》（李航）<br><i class="fa fa-square"></i> 《机器学习》（周志华）<br><i class="fa fa-square"></i> ISL(An Introduction to Statistical Learning: with Applications in R)<br><i class="fa fa-square"></i> 机器学习Machine-Learning<br><i class="fa fa-square"></i> 《机器学习实战》<br><i class="fa fa-square"></i> 《机器学习实战：基于Scikit-Learn和TensorFlow》<br><i class="fa fa-square"></i> 机器学习基石、技法视频<br><i class="fa fa-square"></i> 吴恩达机器学习视频<br><i class="fa fa-square"></i> ISL配套视频<br><i class="fa fa-square"></i> 上交张志华统计机器学习视频<br></div><hr><h3 id="《统计学习方法》（李航）"><a href="#《统计学习方法》（李航）" class="headerlink" title="《统计学习方法》（李航）"></a>《统计学习方法》（李航）</h3><div class="note info"><br>这本书比较精炼，基本上是把模型推导一遍然后给出一个很简单的例子帮助你理解（完整的解释与论证）。<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>《统计学习方法》（李航）</a><hr><h3 id="《机器学习》（周志华）"><a href="#《机器学习》（周志华）" class="headerlink" title="《机器学习》（周志华）"></a>《机器学习》（周志华）</h3><div class="note info"><br>比较简单，有些只是提及，并没有很好地解释和证明，更系统和全面一点；是偏教材的书籍，需要有人引导才能更好地使用。<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>《机器学习》（周志华）</a><hr><h3 id="ISL-An-Introduction-to-Statistical-Learning-with-Applications-in-R"><a href="#ISL-An-Introduction-to-Statistical-Learning-with-Applications-in-R" class="headerlink" title="ISL(An Introduction to Statistical Learning: with Applications in R)"></a>ISL(An Introduction to Statistical Learning: with Applications in R)</h3><div class="note info"><br>ESL的基础书，统计学习的入门书，通俗易懂；监督学习占了大部分篇幅，我觉得这本书最好的部分就是模型的讨论都围绕variance和bias的trade-off展开，还有就是对模型的整体性能。<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>ISL(An Introduction to Statistical Learning: with Applications in R)</a><hr><h3 id="机器学习Machine-Learning"><a href="#机器学习Machine-Learning" class="headerlink" title="机器学习Machine-Learning"></a>机器学习Machine-Learning</h3><div class="note info"><br>github上别人总结的学习路径，可以看看。<br></div><a class="btn" href="https://github.com/JustFollowUs/Machine-Learning" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>机器学习Machine-Learning</a><hr><h3 id="《机器学习实战》"><a href="#《机器学习实战》" class="headerlink" title="《机器学习实战》"></a>《机器学习实战》</h3><div class="note info"><br>用最基本的pyton语法，从底层上让你构建代码；理论讲的不是很清楚不是很透彻<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>《机器学习实战》</a><hr><h3 id="《机器学习实战：基于Scikit-Learn和TensorFlow》"><a href="#《机器学习实战：基于Scikit-Learn和TensorFlow》" class="headerlink" title="《机器学习实战：基于Scikit-Learn和TensorFlow》"></a>《机器学习实战：基于Scikit-Learn和TensorFlow》</h3><div class="note info"><br>评价较好<br></div><a class="btn" href="https://wizardforcel.gitbooks.io/hands-on-ml-with-sklearn-and-tf/content/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>《机器学习实战：基于Scikit-Learn和TensorFlow》</a><hr><h3 id="机器学习基石、技法视频"><a href="#机器学习基石、技法视频" class="headerlink" title="机器学习基石、技法视频"></a>机器学习基石、技法视频</h3><div><br><a class="btn" href="https://www.bilibili.com/video/av36731342?from=search&seid=9794092689876019617" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>机器学习基石视频</a><br></div><div><br><a class="btn" href="https://www.bilibili.com/video/av36760800?from=search&seid=9794092689876019617" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>机器学习基技法视频</a><br></div><hr><h3 id="吴恩达机器学习视频"><a href="#吴恩达机器学习视频" class="headerlink" title="吴恩达机器学习视频"></a>吴恩达机器学习视频</h3><a class="btn" href="https://www.bilibili.com/video/av9912938?from=search&seid=12568278012054372391" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>吴恩达机器学习视频</a><hr><h3 id="ISL配套视频"><a href="#ISL配套视频" class="headerlink" title="ISL配套视频"></a>ISL配套视频</h3><a class="btn" href="https://www.bilibili.com/video/av31018744/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>ISL配套视频</a><hr><h3 id="上交张志华统计机器学习视频"><a href="#上交张志华统计机器学习视频" class="headerlink" title="上交张志华统计机器学习视频"></a>上交张志华统计机器学习视频</h3><a class="btn" href="https://www.bilibili.com/video/av24367356?from=search&seid=9713216174558800309" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>上交张志华统计机器学习视频</a><hr><p><br></p><h2 id="机器学习实战项目"><a href="#机器学习实战项目" class="headerlink" title="机器学习实战项目"></a>机器学习实战项目</h2><h3 id="好的项目"><a href="#好的项目" class="headerlink" title="好的项目"></a>好的项目</h3><p>&emsp;&emsp;搜集的好的机器学习项目</p><div class="note default"><br><i class="fa fa-square"></i> AI项目实战<br></div><h4 id="AI项目实战"><a href="#AI项目实战" class="headerlink" title="AI项目实战"></a>AI项目实战</h4><a class="btn" href="[https://www.bilibili.com/video/av24367356?from=search&seid=9713216174558800309](https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&mid=2651007079&idx=2&sn=ce6c0bca93524953faadb247076c54f3&chksm=8bad9b90bcda12866997c37169bc32ba7327cce704849eb47b99ad9dc3bbb2bdb14ef98bb60d&mpshare=1&scene=1&srcid=1120LZcC29PgcfzRodOBFIiC#rd)"><i class="fa fa-telegram fa-lg fa-fw"></i>AI项目实战</a><hr><p><br></p><h3 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h3><div class="note info"><ul><li><a href="https://www.kaggle.com/competitions" target="_blank" rel="noopener">Kaggle</a></li><li><a href="http://www.tipdm.org/bdrace/index.html" target="_blank" rel="noopener">“泰迪杯”数据挖掘挑战赛</a></li><li><a href="http://bdc.saikr.com/bdc" target="_blank" rel="noopener">中国高校计算机大赛——大数据挑战赛</a></li><li><a href="https://www.kesci.com/home/competition" target="_blank" rel="noopener">Kesci 科赛</a></li><li><a href="https://challenger.ai/?lan=zh" target="_blank" rel="noopener">AI Challenger 全球AI挑战赛</a></li><li><a href="https://www.datafountain.cn/" target="_blank" rel="noopener">datafountain-DF竞赛平台</a></li><li><a href="http://student.saschampion.com/" target="_blank" rel="noopener">sas中国高校数据分析大赛</a></li><li><a href="http://www.sescn.org.cn" target="_blank" rel="noopener">统计建模大赛</a></li><li><a href="http://gmcm.seu.edu.cn/" target="_blank" rel="noopener">研究生数学建模竞赛</a></li><li><a href="http://www.m2ct.org/index.jsp" target="_blank" rel="noopener">深圳杯数学建模挑战赛</a></li><li><a href="http://shumo.neepu.edu.cn/index.php/Home/Index/index.html" target="_blank" rel="noopener">电工杯数学建模</a></li></ul></div><table><thead><tr><th style="text-align:center">竞赛名称</th><th style="text-align:center">时间范围</th><th style="text-align:center">所需时间</th></tr></thead><tbody><tr><td style="text-align:center">“泰迪杯”数据挖掘挑战赛</td><td style="text-align:center">3.31 4.11 4.15</td><td style="text-align:center">差不多一个半月</td></tr><tr><td style="text-align:center">中国高校计算机大赛-大数据挑战赛</td><td style="text-align:center">5.26 7.25 8.20</td><td style="text-align:center">差不多三个月</td></tr><tr><td style="text-align:center">研究生数学建模竞赛</td><td style="text-align:center">9.10 9.13 9.15 9.19 9.20 9.21</td><td style="text-align:center">三天</td></tr><tr><td style="text-align:center">深圳杯数学建模挑战赛</td><td style="text-align:center">4.15 6.10 8月下旬</td><td style="text-align:center">不详</td></tr><tr><td style="text-align:center">电工杯数学建模</td><td style="text-align:center">5.23 5.25 5.28 7.15</td><td style="text-align:center">不详</td></tr><tr><td style="text-align:center">统计建模大赛</td><td style="text-align:center">5-6月</td><td style="text-align:center">不详</td></tr><tr><td style="text-align:center">sas中国高校数据分析大赛</td><td style="text-align:center">10.10</td><td style="text-align:center">不详</td></tr></tbody></table><hr><p><br></p><h3 id="竞赛对应的教程学习"><a href="#竞赛对应的教程学习" class="headerlink" title="竞赛对应的教程学习"></a>竞赛对应的教程学习</h3><div class="note info"><ul><li><a href="http://www.chioka.in/kaggle-competition-solutions/" target="_blank" rel="noopener">Kaggle Competition Past Solutions</a></li><li><a href="https://zhuanlan.zhihu.com/p/25686876" target="_blank" rel="noopener">Kaggle入门，看这一篇就够了</a></li><li><a href="https://www.jianshu.com/p/47ede942df77" target="_blank" rel="noopener">Kaggle比赛：Text Normalization for English银牌全程记录</a></li><li><a href="http://scarletpan.github.io/2017/04/28/summary-of-get-a-silver-medal-in-kaggle/" target="_blank" rel="noopener">Kaggle 首战拿银总结</a></li><li><a href="https://www.kaggle.com/xirudieyi/house-prices" target="_blank" rel="noopener">House Prices: 比赛经验分享</a></li><li><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">Kaggle泰坦尼克</a></li><li><a href="https://dnc1994.com/2016/04/rank-10-percent-in-first-kaggle-competition/" target="_blank" rel="noopener">如何在 Kaggle 首战中进入前 10%</a></li><li><a href="https://blog.csdn.net/u012162613/article/details/41929171" target="_blank" rel="noopener">大数据竞赛平台——Kaggle 入门篇</a></li><li><a href="https://study.163.com/course/introduction.htm?courseId=1003551009#/courseDetail?tab=1" target="_blank" rel="noopener">Python机器学习kaggle案例</a></li><li><a href="https://www.kesci.com/home/project/5a0575cd60680b295c1ecff2" target="_blank" rel="noopener">DATA TRAIN | 数据分析学习计划</a></li><li><a href="http://chinavis.org/2019/" target="_blank" rel="noopener">可视化与可视分析</a></li></ul></div><hr><p><br></p><h2 id="优秀的博主和网站"><a href="#优秀的博主和网站" class="headerlink" title="优秀的博主和网站"></a>优秀的博主和网站</h2><div class="note info"><ul><li><a href="http://redstonewill.com/" target="_blank" rel="noopener">机器学习、深度学习各种资料，很完善</a></li><li><a href="https://github.com/ageron/handson-ml" target="_blank" rel="noopener">Jupyter notebooks Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.</a></li><li><a href="http://www.apachecn.org/" target="_blank" rel="noopener">各种资源的中文翻译</a></li><li><a href="https://plushunter.github.io/" target="_blank" rel="noopener">人大机器学习笔记</a></li><li><a href="https://www.cnblogs.com/maybe2030/" target="_blank" rel="noopener">机器学习算法</a></li><li><a href="https://blog.csdn.net/c406495762/column/info/16415" target="_blank" rel="noopener">Python3机器学习</a></li><li><a href="https://blog.csdn.net/pipisorry" target="_blank" rel="noopener">机器学习、深度学习</a></li><li><a href="http://bourneli.github.io/" target="_blank" rel="noopener">鹅厂大佬</a></li><li><a href="https://www.jianshu.com/p/516f009c0875" target="_blank" rel="noopener">Scikit-learn使用总结</a></li></ul></div><hr><p><br></p><h2 id="收藏的机器学习相关书本和笔记"><a href="#收藏的机器学习相关书本和笔记" class="headerlink" title="收藏的机器学习相关书本和笔记"></a>收藏的机器学习相关书本和笔记</h2><div class="note info"><ul><li><a href="https://zhuanlan.zhihu.com/p/51171643" target="_blank" rel="noopener">李沐 动手学深度学习</a></li><li><a href="https://yoyoyohamapi.gitbooks.io/mit-ml/content/" target="_blank" rel="noopener">斯坦福机器学习笔记</a></li><li><a href="https://wizardforcel.gitbooks.io/hands-on-ml-with-sklearn-and-tf/content/" target="_blank" rel="noopener">Sklearn 与 TensorFlow 机器学习实用指南</a></li><li><a href="https://github.com/apachecn/hands-on-ml-zh" target="_blank" rel="noopener">Sklearn 与 TensorFlow 机器学习实用指南</a></li><li><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">scikit-learn (sklearn) 官方文档中文版</a></li><li><a href="https://github.com/Ming-Lian/Machine-Learning-Course-in-UCAS" target="_blank" rel="noopener">国科大机器学习课程&amp;机器学习笔记</a></li><li><a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">AiLearning: 机器学习 - MachineLearning - ML、深度学习 - DeepLearning - DL、自然语言处理 NLP</a></li><li><a href="https://feisky.xyz/machine-learning/" target="_blank" rel="noopener">机器学习算法</a></li><li><a href="https://machine-learning-python.kspax.io/" target="_blank" rel="noopener">機器學習：使用Python</a></li><li><a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/" target="_blank" rel="noopener">Neural Networks and Deep Learning中文</a></li><li><a href="https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/" target="_blank" rel="noopener">神经网络与深度学习另一个版本</a></li><li><a href="https://accepteddoge.com/machine-learning-yearning-cn/docs/home/" target="_blank" rel="noopener">机器学习训练秘籍</a></li><li><a href="https://github.com/imhuay/Algorithm_Interview_Notes-Chinese" target="_blank" rel="noopener">Algorithm_Interview_Notes-Chinese</a></li><li><a href="https://github.com/ageron/tf2_course" target="_blank" rel="noopener">Notebooks for my “Deep Learning with TensorFlow 2 and Keras” course</a></li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习计划</title>
      <link href="/posts/22463.html"/>
      <url>/posts/22463.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>需要学习的Python内容汇总，包括面向对象、常用模块使用、其他技巧整理、常用工具整理、实战项目、优秀的博主和网站以及收藏的Python相关书本等相关内容。</p></div><a id="more"></a><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>&emsp;&emsp;这个是我一直想要学习的内容，但是由于诸多原因还没能学习，所以把这个放在了Python学习的第一位。</p><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>面向对象</a><br></div><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>面向对象-网页收藏夹</a><br></div><hr><p><br></p><h2 id="标准库与常用模块"><a href="#标准库与常用模块" class="headerlink" title="标准库与常用模块"></a>标准库与常用模块</h2><p>&emsp;&emsp;这里是一些比较常用的模块的学习。</p><div class="note default"><br><i class="fa fa-check-square"></i> numpy-数组与矩阵运算<br><i class="fa fa-square"></i> matplotlib-绘图<br><i class="fa fa-square"></i> Seaborn-绘图<br><i class="fa fa-square"></i> SciPy-科学计算<br><i class="fa fa-check-square"></i> argparse-命令行选项与参数解析<br><i class="fa fa-square"></i> Bokeh-交互式数据可视化<br><i class="fa fa-square"></i> HDF5-大数据存储与读取<br><i class="fa fa-square"></i> tqdm-显示运行进度条<br><i class="fa fa-check-square"></i> logging-日志<br><i class="fa fa-check-square"></i> glob-文件名规则匹配<br><i class="fa fa-check-square"></i> os-使用操作系统相关功能<br><i class="fa fa-check-square"></i> shutil-高级文件操作<br><i class="fa fa-check-square"></i> sys-程序与python解释器的交互<br><i class="fa fa-check-square"></i> subprocess-子进程管理<br><i class="fa fa-check-square"></i> rpy2-调用R语言<br><i class="fa fa-square"></i> collections-内建的一个集合模块<br><i class="fa fa-check-square"></i> itertools-Python内置迭代器模块<br><i class="fa fa-square"></i> functools-高阶函数相关的函数<br><br></div><hr><h3 id="numpy-数组与矩阵运算"><a href="#numpy-数组与矩阵运算" class="headerlink" title="numpy-数组与矩阵运算"></a>numpy-数组与矩阵运算</h3><div><br><a class="btn" href="http://showteeth.tech/posts/24507.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之numpy-数组与矩阵运算(一)：数组创建</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/35386.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之numpy-数组与矩阵运算(二)：切片、截取和堆叠</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/24353.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之numpy-数组与矩阵运算(三)：广播、迭代以及数组相关操作</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/54407.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之numpy-数组与矩阵运算(四)：常用函数</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/15933.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之numpy-数组与矩阵运算(五)：常用函数汇总</a><br></div><hr><h3 id="matplotlib-绘图"><a href="#matplotlib-绘图" class="headerlink" title="matplotlib-绘图"></a>matplotlib-绘图</h3><a class="btn" href="https://matplotlib.org/users/pyplot_tutorial.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>matplotlib-绘图</a><p><br></p><a class="btn" href="https://liam.page/2014/09/11/matplotlib-tutorial-zh-cn/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>matplotlib-绘图</a><hr><h3 id="Seaborn-绘图"><a href="#Seaborn-绘图" class="headerlink" title="Seaborn-绘图"></a>Seaborn-绘图</h3><a class="btn" href="https://zhuanlan.zhihu.com/p/27435863" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Seaborn-绘图</a><hr><h3 id="SciPy-科学计算"><a href="#SciPy-科学计算" class="headerlink" title="SciPy-科学计算"></a>SciPy-科学计算</h3><a class="btn" href="https://www.kancloud.cn/wizardforcel/scipy-lecture-notes/129867" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>SciPy-科学计算</a><hr><h3 id="argparse-命令行选项与参数解析"><a href="#argparse-命令行选项与参数解析" class="headerlink" title="argparse-命令行选项与参数解析"></a>argparse-命令行选项与参数解析</h3><a class="btn" href="http://showteeth.tech/posts/19941.html"><i class="fa fa-telegram fa-lg fa-fw"></i>argparse-命令行选项与参数解析</a><hr><h3 id="Bokeh-交互式数据可视化"><a href="#Bokeh-交互式数据可视化" class="headerlink" title="Bokeh-交互式数据可视化"></a>Bokeh-交互式数据可视化</h3><a class="btn" href="https://zhuanlan.zhihu.com/p/52093055" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Bokeh-交互式数据可视化</a><hr><h3 id="HDF5-大数据存储与读取"><a href="#HDF5-大数据存储与读取" class="headerlink" title="HDF5-大数据存储与读取"></a>HDF5-大数据存储与读取</h3><a class="btn" href="https://www.jianshu.com/p/ae12525450e8" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>HDF5-大数据存储与读取</a><hr><h3 id="tqdm-显示运行进度条"><a href="#tqdm-显示运行进度条" class="headerlink" title="tqdm-显示运行进度条"></a>tqdm-显示运行进度条</h3><a class="btn" href="https://tqdm.github.io/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>tqdm-显示运行进度条</a><hr><h3 id="logging-日志"><a href="#logging-日志" class="headerlink" title="logging-日志"></a>logging-日志</h3><a class="btn" href="http://showteeth.tech/posts/56982.html"><i class="fa fa-telegram fa-lg fa-fw"></i>logging-日志</a><hr><h3 id="glob-文件名规则匹配"><a href="#glob-文件名规则匹配" class="headerlink" title="glob-文件名规则匹配"></a>glob-文件名规则匹配</h3><a class="btn" href="http://showteeth.tech/posts/24468.html"><i class="fa fa-telegram fa-lg fa-fw"></i>glob-文件操作相关模块</a><hr><h3 id="os-使用操作系统相关功能"><a href="#os-使用操作系统相关功能" class="headerlink" title="os-使用操作系统相关功能"></a>os-使用操作系统相关功能</h3><a class="btn" href="http://showteeth.tech/posts/24368.html"><i class="fa fa-telegram fa-lg fa-fw"></i>os-使用操作系统相关功能</a><hr><h3 id="shutil-高级文件操作"><a href="#shutil-高级文件操作" class="headerlink" title="shutil-高级文件操作"></a>shutil-高级文件操作</h3><a class="btn" href="http://showteeth.tech/posts/51574.html"><i class="fa fa-telegram fa-lg fa-fw"></i>shutil-高级文件操作</a><hr><h3 id="sys-程序与python解释器的交互"><a href="#sys-程序与python解释器的交互" class="headerlink" title="sys-程序与python解释器的交互"></a>sys-程序与python解释器的交互</h3><a class="btn" href="http://showteeth.tech/posts/38877.html"><i class="fa fa-telegram fa-lg fa-fw"></i>sys-程序与python解释器的交互</a><hr><h3 id="subprocess-子进程管理"><a href="#subprocess-子进程管理" class="headerlink" title="subprocess-子进程管理"></a>subprocess-子进程管理</h3><a class="btn" href="http://showteeth.tech/posts/57519.html"><i class="fa fa-telegram fa-lg fa-fw"></i>subprocess-子进程管理</a><hr><h3 id="rpy2-调用R语言"><a href="#rpy2-调用R语言" class="headerlink" title="rpy2-调用R语言"></a>rpy2-调用R语言</h3><div><br><a class="btn" href="http://showteeth.tech/posts/63643.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之rpy2-在Python中使用R</a><br></div><hr><h3 id="collections-内建的一个集合模块"><a href="#collections-内建的一个集合模块" class="headerlink" title="collections-内建的一个集合模块"></a>collections-内建的一个集合模块</h3><div><br><a class="btn" href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>collections-内建的一个集合模块</a><br></div><div><br><a class="btn" href="https://funhacks.net/explore-python/Standard-Modules/collections.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>collections</a><br></div><div><br><a class="btn" href="https://pymotw.com/3/collections/index.html#module-collections" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>collections — Container Data Types</a><br></div><hr><h3 id="itertools-Python内置迭代器模块"><a href="#itertools-Python内置迭代器模块" class="headerlink" title="itertools-Python内置迭代器模块"></a>itertools-Python内置迭代器模块</h3><div><br><a class="btn" href="http://showteeth.tech/posts/49907.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之itertools-Python内置迭代器模块</a><br></div><hr><h3 id="functools-高阶函数相关的函数"><a href="#functools-高阶函数相关的函数" class="headerlink" title="functools-高阶函数相关的函数"></a>functools-高阶函数相关的函数</h3><div><br><a class="btn" href="https://pymotw.com/3/functools/index.html#module-functools" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>functools — Tools for Manipulating Functions</a><br></div><div><br><a class="btn" href="https://blog.windrunner.me/python/functools.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python functools 模块</a><br></div><div><br><a class="btn" href="http://wklken.me/posts/2013/08/18/python-extra-functools.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python-进阶-functools模块小结</a><br></div><div><br><a class="btn" href="http://kuanghy.github.io/2016/10/26/python-functools" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python 模块简介 -- functools</a><br></div><hr><p><br></p><h2 id="其他技巧整理"><a href="#其他技巧整理" class="headerlink" title="其他技巧整理"></a>其他技巧整理</h2><p>&emsp;&emsp;这部分内容虽然不是具体的模块，但是对他们的理解和应用对于Python的学习非常有益处。</p><div class="note default"><br><i class="fa fa-check-square"></i> main函数的理解<br><i class="fa fa-check-square"></i> Python常用程序块<br><i class="fa fa-check-square"></i> Python常见错误<br><i class="fa fa-check-square"></i> Python系列之打印彩色字符串<br><i class="fa fa-square"></i> 接入pipeline<br></div><hr><h3 id="main函数的理解"><a href="#main函数的理解" class="headerlink" title="main函数的理解"></a>main函数的理解</h3><div><br><a class="btn" href="http://showteeth.tech/posts/32155.html"><i class="fa fa-telegram fa-lg fa-fw"></i>main函数的理解</a><br></div><hr><h3 id="Python常用程序块"><a href="#Python常用程序块" class="headerlink" title="Python常用程序块"></a>Python常用程序块</h3><div><br><a class="btn" href="http://showteeth.tech/posts/58475.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python常用程序块</a><br></div><hr><h3 id="Python常见错误"><a href="#Python常见错误" class="headerlink" title="Python常见错误"></a>Python常见错误</h3><div><br><a class="btn" href="http://showteeth.tech/posts/61409.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python常见错误</a><br></div><hr><h3 id="Python系列之打印彩色字符串"><a href="#Python系列之打印彩色字符串" class="headerlink" title="Python系列之打印彩色字符串"></a>Python系列之打印彩色字符串</h3><div><br><a class="btn" href="http://showteeth.tech/posts/9708.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python系列之打印彩色字符串</a><br></div><hr><h3 id="接入pipeline"><a href="#接入pipeline" class="headerlink" title="接入pipeline"></a>接入pipeline</h3><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>接入pipeline</a><br></div><hr><p><br></p><h2 id="常用工具整理"><a href="#常用工具整理" class="headerlink" title="常用工具整理"></a>常用工具整理</h2><h3 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h3><div><br><a class="btn" href="http://showteeth.tech/posts/13473.html"><i class="fa fa-telegram fa-lg fa-fw"></i>jupyter主题、插件、技巧、server搭建</a><br></div><hr><p><br></p><h2 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h2><p>&emsp;&emsp;这部分是收集的一些实战项目，可以在学习的过程中穿插学习，巩固对知识的掌握</p><p></p><div class="note default"><br><i class="fa fa-check-square"></i> Python-博客转载项目<br><i class="fa fa-square"></i> 以撸代码的形式学习Python<br><i class="fa fa-square"></i> Python项目-w3cschool<br><i class="fa fa-square"></i> 电影分析-爬虫+可视化<br><i class="fa fa-square"></i> 12个Python实战项目教程<br><i class="fa fa-square"></i> Python练手项目推荐<br><i class="fa fa-square"></i> Python100例测试<br></div><br><p></p><hr><h3 id="Python-博客转载项目"><a href="#Python-博客转载项目" class="headerlink" title="Python-博客转载项目"></a>Python-博客转载项目</h3><a class="btn" href="http://showteeth.tech/posts/26003.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python-博客转载项目-博客</a> <a class="btn" href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python-博客转载项目-code</a><hr><h3 id="以撸代码的形式学习Python"><a href="#以撸代码的形式学习Python" class="headerlink" title="以撸代码的形式学习Python"></a>以撸代码的形式学习Python</h3><a class="btn" href="https://github.com/xianhu/LearnPython" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>以撸代码的形式学习Python</a><hr><h3 id="Python项目-w3cschool"><a href="#Python项目-w3cschool" class="headerlink" title="Python项目-w3cschool"></a>Python项目-w3cschool</h3><a class="btn" href="https://123.w3cschool.cn/python_projects" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>以撸代码的形式学习Python</a><hr><h3 id="电影分析-爬虫-可视化"><a href="#电影分析-爬虫-可视化" class="headerlink" title="电影分析-爬虫+可视化"></a>电影分析-爬虫+可视化</h3><a class="btn" href="https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247487205&idx=1&sn=82bbe82f1274b8dd6b83ad24aeb08203&chksm=9b5faa03ac2823159ce36c35f7e2c96519737994f6b5efab2190203341eedc65310c1db15cc6&mpshare=1&scene=1&srcid=1127wHAXUaLUP0tzR8jyduMA#rd" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>电影分析-爬虫+可视化</a><hr><h3 id="12个Python实战项目教程"><a href="#12个Python实战项目教程" class="headerlink" title="12个Python实战项目教程"></a>12个Python实战项目教程</h3><a class="btn" href="https://mp.weixin.qq.com/s?__biz=MzUzMjk1MDI0OQ==&mid=2247484138&idx=1&sn=43417bbcd4094bc8bd05dfe037025e6d&chksm=faaa3f6ccdddb67a02b78ae74af243785556c41021e93cf2f847aec6317e62fb0d426feda057&mpshare=1&scene=1&srcid=1126FWvmWRNX8eJdim9fEufv#rd" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>12个Python实战项目教程</a><hr><h3 id="Python练手项目推荐"><a href="#Python练手项目推荐" class="headerlink" title="Python练手项目推荐"></a>Python练手项目推荐</h3><a class="btn" href="https://www.zhihu.com/question/29372574" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python练手项目推荐</a><hr><h3 id="Python100例测试"><a href="#Python100例测试" class="headerlink" title="Python100例测试"></a>Python100例测试</h3><a class="btn" href="http://www.runoob.com/python/python-100-examples.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python100例测试</a><hr><p><br></p><h2 id="优秀的博主和网站"><a href="#优秀的博主和网站" class="headerlink" title="优秀的博主和网站"></a>优秀的博主和网站</h2><div class="note info"><ul><li><a href="https://www.cnblogs.com/yyds/" target="_blank" rel="noopener">云游道士</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰</a></li><li><a href="http://liyangbit.com/" target="_blank" rel="noopener">Python数据之道</a></li><li><a href="http://www.liujiangblog.com/course/python/1" target="_blank" rel="noopener">刘江的博客及教程</a></li></ul></div><hr><p><br></p><h2 id="收藏的Python相关书本"><a href="#收藏的Python相关书本" class="headerlink" title="收藏的Python相关书本"></a>收藏的Python相关书本</h2><div class="note info"><ul><li><a href="https://jackaudrey.gitbooks.io/python-numpy/content/" target="_blank" rel="noopener">Python之numpy教程</a></li><li><a href="https://wizardforcel.gitbooks.io/matplotlib-user-guide/content/1.html" target="_blank" rel="noopener">Matplotlib用户指南</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p25_creating_cached_instances.html" target="_blank" rel="noopener">类与对象</a></li><li><a href="https://l1nwatch.gitbooks.io/writing_solid_python_code_gitbook/content/" target="_blank" rel="noopener">编写高质量代码改善 Python 程序的 91 个建议</a></li><li><a href="https://wizardforcel.gitbooks.io/core-python-2e/content/" target="_blank" rel="noopener">Python 核心编程 第二版</a></li><li><a href="https://eastlakeside.gitbooks.io/interpy-zh/content/" target="_blank" rel="noopener">Python进阶</a></li><li><a href="https://xidianwlc.gitbooks.io/python-data-structrue-and-algrothms/content/" target="_blank" rel="noopener">Python数据结构与算法</a></li><li><a href="https://wizardforcel.gitbooks.io/matplotlib-intro-tut/content/" target="_blank" rel="noopener">Python 数据科学入门教程</a></li><li><a href="https://wizardforcel.gitbooks.io/hands-on-ml-with-sklearn-and-tf/content/" target="_blank" rel="noopener">Sklearn 与 TensorFlow 机器学习实用指南</a></li><li><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">scikit-learn (sklearn) 官方文档中文版</a></li><li><a href="https://wizardforcel.gitbooks.io/sklearn-cookbook/content/" target="_blank" rel="noopener">Scikit-learn 秘籍</a></li><li><a href="https://github.com/apachecn/python_data_analysis_and_mining_action" target="_blank" rel="noopener">python数据分析与挖掘实战的代码笔记</a></li><li><a href="https://germey.gitbooks.io/python3webspider/content/" target="_blank" rel="noopener">Python3网络爬虫开发实战</a></li><li><a href="https://datartisan.gitbooks.io/begining-text-mining-with-python/content/" target="_blank" rel="noopener">Python 文本数据分析初学指南</a></li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习计划</title>
      <link href="/posts/34794.html"/>
      <url>/posts/34794.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>需要学习的Linux内容汇总，包括基本命令、其他一些常用的总结、shell编程、小技巧、其他博主的命令总结、很好的博主和网站以及收藏的shell相关书本等相关内容。</p></div><a id="more"></a><h2 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h2><p>&emsp;&emsp;这些命令是在工作和学习中常用的一些命令，有些我之前系统的学习过，但是学习的笔记都存放在我的印象笔记上，等有时间了会把这些笔记整理到这个博客上（回顾之前学习的内容），感觉博客上面记笔记会比较清爽，便于后期回顾学习，还没有系统学习过的命令后期都将直接呈现在这个博客上。下面列出了需要学习的常用命令，接下来将依据这个进行学习，同时在学习中遇到新的常用命令也会进行补充和完善，同时这一页主要是一个综括页，具体的每一个命令的学习笔记都将单独的页面展示，但是可以通过这个页面直接链接过去。</p><div class="note primary"><br><i class="fa fa-check-square"></i> awk系列-强大的文本处理语言<br><i class="fa fa-check-square"></i> find-搜索文件名<br><i class="fa fa-check-square"></i> grep-搜索文件内容<br><i class="fa fa-check-square"></i> sed-文本处理工具<br><i class="fa fa-check-square"></i> sort-排序<br><i class="fa fa-check-square"></i> uniq-去重<br><i class="fa fa-check-square"></i> join-连接文本<br><i class="fa fa-check-square"></i> cut-按列切分文件字段工具<br><i class="fa fa-check-square"></i> comm-文件比较，文本文件的交集、差集与求差<br><i class="fa fa-check-square"></i> cmp-文件比较命令<br><i class="fa fa-check-square"></i> diff-文件比较命令<br><i class="fa fa-check-square"></i> cat-显示、读取或拼接文件内容<br><i class="fa fa-check-square"></i> more和less-查看文本内容<br><i class="fa fa-check-square"></i> wget-命令行下载工具<br><i class="fa fa-check-square"></i> nohup、disown和&amp;-任务管理<br><i class="fa fa-check-square"></i> echo-字符串的输出<br><i class="fa fa-check-square"></i> Linux中常用的解压缩命令<br><i class="fa fa-check-square"></i> paste-按列合并文件<br><i class="fa fa-check-square"></i> split-按大小分割文件<br><i class="fa fa-check-square"></i> csplit-根据文本内容切割文件<br><i class="fa fa-check-square"></i> scp-跨平台复制命令<br><i class="fa fa-check-square"></i> shuf-随机打乱文件<br><i class="fa fa-check-square"></i> seq-产生固定步长整数<br><i class="fa fa-check-square"></i> printf-格式化输出字符串<br><i class="fa fa-check-square"></i> ps-报告当前系统的进程状态<br><i class="fa fa-check-square"></i> pgrep-使用进程名直接查找pid等信息<br><i class="fa fa-check-square"></i> rsnyc-远程数据同步<br><i class="fa fa-check-square"></i> xargs-将输入转换成命令行参数<br><i class="fa fa-check-square"></i> read-从键盘或文件中获取输入<br><i class="fa fa-check-square"></i> time-计算命令执行花费的时间<br><i class="fa fa-check-square"></i> 获取时间日期格式和延时<br><i class="fa fa-check-square"></i> pv-命令执行的进度信息<br><i class="fa fa-square"></i> screen-远程会话管理工具<br><i class="fa fa-check-square"></i> du-显示目录或文件大小<br></div><hr><h3 id="awk系列-强大的文本处理语言"><a href="#awk系列-强大的文本处理语言" class="headerlink" title="awk系列-强大的文本处理语言"></a>awk系列-强大的文本处理语言</h3><p>该系列包括13个小节，已经学习完毕 ，笔记都保存在印象笔记上。</p><hr><h3 id="find-搜索文件名"><a href="#find-搜索文件名" class="headerlink" title="find-搜索文件名"></a>find-搜索文件名</h3><hr><h3 id="grep-搜索文件内容"><a href="#grep-搜索文件内容" class="headerlink" title="grep-搜索文件内容"></a>grep-搜索文件内容</h3><hr><h3 id="sed-文本处理工具"><a href="#sed-文本处理工具" class="headerlink" title="sed-文本处理工具"></a>sed-文本处理工具</h3><a class="btn" href="http://showteeth.tech/posts/1752.html"><i class="fa fa-telegram fa-lg fa-fw"></i>sed-文本处理工具</a><hr><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort-排序"></a>sort-排序</h3><a class="btn" href="http://showteeth.tech/posts/61024.html"><i class="fa fa-telegram fa-lg fa-fw"></i>sort-排序</a><hr><h3 id="uniq-去重"><a href="#uniq-去重" class="headerlink" title="uniq-去重"></a>uniq-去重</h3><a class="btn" href="http://showteeth.tech/posts/20744.html"><i class="fa fa-telegram fa-lg fa-fw"></i>uniq-去重</a><hr><h3 id="join-连接文本"><a href="#join-连接文本" class="headerlink" title="join-连接文本"></a>join-连接文本</h3><a class="btn" href="http://showteeth.tech/posts/5579.html"><i class="fa fa-telegram fa-lg fa-fw"></i>join-连接文本</a><hr><h3 id="cut-按列切分文件字段工具"><a href="#cut-按列切分文件字段工具" class="headerlink" title="cut-按列切分文件字段工具"></a>cut-按列切分文件字段工具</h3><a class="btn" href="http://showteeth.tech/posts/64687.html"><i class="fa fa-telegram fa-lg fa-fw"></i>cut-按列切分文件字段工具</a><hr><h3 id="comm-文件比较，文本文件的交集、差集与求差"><a href="#comm-文件比较，文本文件的交集、差集与求差" class="headerlink" title="comm-文件比较，文本文件的交集、差集与求差"></a>comm-文件比较，文本文件的交集、差集与求差</h3><a class="btn" href="http://showteeth.tech/posts/39582.html"><i class="fa fa-telegram fa-lg fa-fw"></i>comm-文件比较，文本文件的交集、差集与求差</a><hr><h3 id="cmp-文件比较命令"><a href="#cmp-文件比较命令" class="headerlink" title="cmp-文件比较命令"></a>cmp-文件比较命令</h3><a class="btn" href="http://showteeth.tech/posts/62860.html"><i class="fa fa-telegram fa-lg fa-fw"></i>cmp-文件比较命令</a><hr><h3 id="diff-文件比较命令"><a href="#diff-文件比较命令" class="headerlink" title="diff-文件比较命令"></a>diff-文件比较命令</h3><a class="btn" href="http://showteeth.tech/posts/56778.html"><i class="fa fa-telegram fa-lg fa-fw"></i>diff-文件比较命令</a><hr><h3 id="cat-显示、读取或拼接文件内容"><a href="#cat-显示、读取或拼接文件内容" class="headerlink" title="cat-显示、读取或拼接文件内容"></a>cat-显示、读取或拼接文件内容</h3><a class="btn" href="http://showteeth.tech/posts/24399.html"><i class="fa fa-telegram fa-lg fa-fw"></i>cat-显示、读取或拼接文件内容</a><hr><h3 id="more和less-查看文本内容"><a href="#more和less-查看文本内容" class="headerlink" title="more和less-查看文本内容"></a>more和less-查看文本内容</h3><a class="btn" href="http://showteeth.tech/posts/24399.html"><i class="fa fa-telegram fa-lg fa-fw"></i>more和less-查看文本内容</a><hr><h3 id="wget-命令行下载工具"><a href="#wget-命令行下载工具" class="headerlink" title="wget-命令行下载工具"></a>wget-命令行下载工具</h3><a class="btn" href="http://showteeth.tech/posts/44952.html"><i class="fa fa-telegram fa-lg fa-fw"></i>wget-命令行下载工具</a><hr><h3 id="nohup、disown和-amp-任务管理"><a href="#nohup、disown和-amp-任务管理" class="headerlink" title="nohup、disown和&amp;-任务管理"></a>nohup、disown和&amp;-任务管理</h3><a class="btn" href="http://showteeth.tech/posts/19305.html"><i class="fa fa-telegram fa-lg fa-fw"></i>nohup、disown和&-任务管理</a><hr><h3 id="echo-字符串的输出"><a href="#echo-字符串的输出" class="headerlink" title="echo-字符串的输出"></a>echo-字符串的输出</h3><a class="btn" href="http://showteeth.tech/posts/39761.html"><i class="fa fa-telegram fa-lg fa-fw"></i>echo-字符串的输出</a><hr><h3 id="Linux中常用的解压缩命令"><a href="#Linux中常用的解压缩命令" class="headerlink" title="Linux中常用的解压缩命令"></a>Linux中常用的解压缩命令</h3><a class="btn" href="http://showteeth.tech/posts/29022.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Linux中常用的解压缩命令</a><hr><h3 id="paste-按列合并文件"><a href="#paste-按列合并文件" class="headerlink" title="paste-按列合并文件"></a>paste-按列合并文件</h3><a class="btn" href="http://showteeth.tech/posts/22454.html"><i class="fa fa-telegram fa-lg fa-fw"></i>paste-合并文件</a><hr><h3 id="split-按大小分割文件"><a href="#split-按大小分割文件" class="headerlink" title="split-按大小分割文件"></a>split-按大小分割文件</h3><a class="btn" href="http://showteeth.tech/posts/41178.html"><i class="fa fa-telegram fa-lg fa-fw"></i>split-按大小分割文件</a><hr><h3 id="csplit-根据文本内容切割文件"><a href="#csplit-根据文本内容切割文件" class="headerlink" title="csplit-根据文本内容切割文件"></a>csplit-根据文本内容切割文件</h3><a class="btn" href="http://man.linuxde.net/csplit" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>csplit-根据文本内容切割文件</a><hr><h3 id="scp-跨平台复制命令"><a href="#scp-跨平台复制命令" class="headerlink" title="scp-跨平台复制命令"></a>scp-跨平台复制命令</h3><a class="btn" href="http://showteeth.tech/posts/2539.html"><i class="fa fa-telegram fa-lg fa-fw"></i>scp-跨平台复制命令</a><hr><h3 id="shuf-随机打乱文件"><a href="#shuf-随机打乱文件" class="headerlink" title="shuf-随机打乱文件"></a>shuf-随机打乱文件</h3><a class="btn" href="http://showteeth.tech/posts/50731.html"><i class="fa fa-telegram fa-lg fa-fw"></i>shuf-随机打乱文件</a><hr><h3 id="seq-产生固定步长整数"><a href="#seq-产生固定步长整数" class="headerlink" title="seq-产生固定步长整数"></a>seq-产生固定步长整数</h3><a class="btn" href="http://showteeth.tech/posts/1152.html"><i class="fa fa-telegram fa-lg fa-fw"></i>seq-产生固定步长整数</a><hr><h3 id="ps-报告当前系统的进程状态"><a href="#ps-报告当前系统的进程状态" class="headerlink" title="ps-报告当前系统的进程状态"></a>ps-报告当前系统的进程状态</h3><a class="btn" href="http://showteeth.tech/posts/33990.html"><i class="fa fa-telegram fa-lg fa-fw"></i>ps-报告当前系统的进程状态</a><hr><h3 id="pgrep-使用进程名直接查找pid等信息"><a href="#pgrep-使用进程名直接查找pid等信息" class="headerlink" title="pgrep-使用进程名直接查找pid等信息"></a>pgrep-使用进程名直接查找pid等信息</h3><a class="btn" href="http://showteeth.tech/posts/22799.html"><i class="fa fa-telegram fa-lg fa-fw"></i>ps-报告当前系统的进程状态</a><hr><h3 id="rsnyc-远程数据同步"><a href="#rsnyc-远程数据同步" class="headerlink" title="rsnyc-远程数据同步"></a>rsnyc-远程数据同步</h3><a class="btn" href="http://showteeth.tech/posts/8376.html"><i class="fa fa-telegram fa-lg fa-fw"></i>rsnyc-远程数据同步</a><hr><h3 id="xargs-将输入转换成命令行参数"><a href="#xargs-将输入转换成命令行参数" class="headerlink" title="xargs-将输入转换成命令行参数"></a>xargs-将输入转换成命令行参数</h3><a class="btn" href="http://showteeth.tech/posts/30003.html"><i class="fa fa-telegram fa-lg fa-fw"></i>xargs-将输入转换成命令行参数</a><hr><h3 id="read-从键盘或文件中获取标准输入"><a href="#read-从键盘或文件中获取标准输入" class="headerlink" title="read-从键盘或文件中获取标准输入"></a>read-从键盘或文件中获取标准输入</h3><a class="btn" href="http://showteeth.tech/posts/59492.html"><i class="fa fa-telegram fa-lg fa-fw"></i>read-从键盘或文件中获取标准输入</a><hr><h3 id="time-计算命令执行花费的时间"><a href="#time-计算命令执行花费的时间" class="headerlink" title="time-计算命令执行花费的时间"></a>time-计算命令执行花费的时间</h3><a class="btn" href="http://showteeth.tech/posts/21450.html"><i class="fa fa-telegram fa-lg fa-fw"></i>time-计算命令执行花费的时间</a><hr><h3 id="获取时间日期格式和延时"><a href="#获取时间日期格式和延时" class="headerlink" title="获取时间日期格式和延时"></a>获取时间日期格式和延时</h3><a class="btn" href="http://showteeth.tech/posts/52406.html"><i class="fa fa-telegram fa-lg fa-fw"></i>获取时间日期格式和延时</a><hr><h3 id="pv-命令执行的进度信息"><a href="#pv-命令执行的进度信息" class="headerlink" title="pv-命令执行的进度信息"></a>pv-命令执行的进度信息</h3><a class="btn" href="http://showteeth.tech/posts/6226.html"><i class="fa fa-telegram fa-lg fa-fw"></i>pv-命令执行的进度信息</a><hr><h3 id="screen-远程会话管理工具"><a href="#screen-远程会话管理工具" class="headerlink" title="screen-远程会话管理工具"></a>screen-远程会话管理工具</h3><a class="btn" href="http://showteeth.tech/posts/33882.html"><i class="fa fa-telegram fa-lg fa-fw"></i>screen-远程会话管理工具</a><hr><h3 id="du-显示目录或文件大小"><a href="#du-显示目录或文件大小" class="headerlink" title="du-显示目录或文件大小"></a>du-显示目录或文件大小</h3><a class="btn" href="http://showteeth.tech/posts/30062.html"><i class="fa fa-telegram fa-lg fa-fw"></i>du-显示目录或文件大小</a><hr><p><br></p><h2 id="其他一些常用内容总结"><a href="#其他一些常用内容总结" class="headerlink" title="其他一些常用内容总结"></a>其他一些常用内容总结</h2><p>&emsp;&emsp;这些虽然不是具体的linux命令，但是在具体学习中页非常实用，所以有必要进行积累和整理。</p><div class="note default"><br><i class="fa fa-check-square"></i> Linux中特殊符号用法<br><i class="fa fa-check-square"></i> 浮点计算并保留小数<br><i class="fa fa-check-square"></i> 字符串截取方法<br><i class="fa fa-check-square"></i> 单行命令嵌套<br><i class="fa fa-check-square"></i> 输入输出重定向<br></div><hr><h3 id="Linux中特殊符号用法"><a href="#Linux中特殊符号用法" class="headerlink" title="Linux中特殊符号用法"></a>Linux中特殊符号用法</h3><a class="btn" href="http://showteeth.tech/posts/55603.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Linux中特殊符号用法</a><hr><h3 id="浮点计算并保留小数"><a href="#浮点计算并保留小数" class="headerlink" title="浮点计算并保留小数"></a>浮点计算并保留小数</h3><a class="btn" href="http://showteeth.tech/posts/28430.html"><i class="fa fa-telegram fa-lg fa-fw"></i>浮点计算并保留小数</a><hr><h3 id="字符串截取方法"><a href="#字符串截取方法" class="headerlink" title="字符串截取方法"></a>字符串截取方法</h3><a class="btn" href="http://showteeth.tech/posts/43811.html"><i class="fa fa-telegram fa-lg fa-fw"></i>字符串截取方法</a><hr><h3 id="单行命令嵌套"><a href="#单行命令嵌套" class="headerlink" title="单行命令嵌套"></a>单行命令嵌套</h3><a class="btn" href="http://showteeth.tech/50164.html"><i class="fa fa-telegram fa-lg fa-fw"></i>单行命令嵌套</a><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><a class="btn" href="http://showteeth.tech/posts/55603.html"><i class="fa fa-telegram fa-lg fa-fw"></i>输入输出重定向</a><hr><p><br></p><h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><p>&emsp;&emsp;这一块平常接触没有那些常用命令那么频繁，但是也很多很实用（不用为了一个简单的目的去编写一个Python脚本），所以这里需要系统的学习一下。</p><div class="note default"><br><i class="fa fa-check-square"></i> 传递参数<br><i class="fa fa-check-square"></i> 循环结构<br><i class="fa fa-check-square"></i> if判断<br><i class="fa fa-check-square"></i> 数组<br><i class="fa fa-check-square"></i> 数学运算<br></div><hr><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><a class="btn" href="http://showteeth.tech/posts/16486.html"><i class="fa fa-telegram fa-lg fa-fw"></i>循环结构</a><hr><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><a class="btn" href="http://showteeth.tech/posts/58105.html"><i class="fa fa-telegram fa-lg fa-fw"></i>if判断</a><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><a class="btn" href="http://man.linuxde.net/shell-script/shell-4" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>传递参数</a><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><a class="btn" href="http://showteeth.tech/posts/46714.html"><i class="fa fa-telegram fa-lg fa-fw"></i>数组</a><hr><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><a class="btn" href="http://showteeth.tech/posts/28430.html"><i class="fa fa-telegram fa-lg fa-fw"></i>数学运算</a><hr><p><br></p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>&emsp;&emsp;这里总结一下使用常用命令以及进行shell编程的一些常用小技巧。</p><h3 id="awk使用技巧"><a href="#awk使用技巧" class="headerlink" title="awk使用技巧"></a>awk使用技巧</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>awk使用技巧</a><hr><h3 id="shell技巧-非shell脚本"><a href="#shell技巧-非shell脚本" class="headerlink" title="shell技巧-非shell脚本"></a>shell技巧-非shell脚本</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>shell技巧-非shell脚本</a><hr><h3 id="shell脚本技巧"><a href="#shell脚本技巧" class="headerlink" title="shell脚本技巧"></a>shell脚本技巧</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>shell脚本技巧</a><hr><p><br></p><h2 id="其他博主的命令总结"><a href="#其他博主的命令总结" class="headerlink" title="其他博主的命令总结"></a>其他博主的命令总结</h2><p>&emsp;&emsp;其他优秀的博主整理的常用命令，可作为自查以及必要时查阅。</p><div class="note info"><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxODM4MjA5MA==&amp;mid=2247487779&amp;idx=2&amp;sn=792e34b6d074f91368a4b2bafc1b1d03&amp;chksm=97ea3b46a09db2504a99d0105f4c24e995df7404b9603bd6ecaa53ff789df12dc785c8d5e8aa&amp;mpshare=1&amp;scene=1&amp;srcid=1124yMS6YBS7wVs10BXncBTP#rd" target="_blank" rel="noopener">97条 Linux 常用命令总结</a></li><li><a href="http://weiyanying.com/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">文件与目录基础自查</a></li></ul></div><hr><p><br></p><h2 id="很好的博主和网站"><a href="#很好的博主和网站" class="headerlink" title="很好的博主和网站"></a>很好的博主和网站</h2><div class="note info"><ul><li><a href="http://www.zsythink.net/" target="_blank" rel="noopener">大佬博客，讲解非常细致</a></li><li><a href="http://man.linuxde.net/shell-script" target="_blank" rel="noopener">常用命令和shell总结、很完善</a></li><li><a href="http://man.linuxde.net/" target="_blank" rel="noopener">查询各种linux命令，基本都有且分类清楚</a></li><li><a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">查询各种linux命令，基本都有</a></li><li><a href="https://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/default.html?page=4" target="_blank" rel="noopener">其他博主的每日一个linux命令</a></li><li><a href="https://www.jb51.net/list/list_235_1.htm" target="_blank" rel="noopener">讲解以及实际问题代码</a></li></ul></div><hr><p><br></p><h2 id="收藏的shell相关书本"><a href="#收藏的shell相关书本" class="headerlink" title="收藏的shell相关书本"></a>收藏的shell相关书本</h2><div class="note info"><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/" target="_blank" rel="noopener">鸟哥的Linux私房菜：基础学习篇</a></li><li><a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/" target="_blank" rel="noopener">高级Bash脚本编程指南</a></li><li><a href="https://tinylab.gitbooks.io/shellbook/content/zh/preface/01-chapter1.html" target="_blank" rel="noopener">Shell 编程范例</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/" target="_blank" rel="noopener">shell脚本</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line/39431" target="_blank" rel="noopener">linux command line中文版</a></li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>next-markdown技巧和模板-持续更新</title>
      <link href="/posts/37746.html"/>
      <url>/posts/37746.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>博客中常用markdown的样式和模板</p></div><a id="more"></a><h2 id="markdown技巧"><a href="#markdown技巧" class="headerlink" title="markdown技巧"></a>markdown技巧</h2><h3 id="分割线和空行"><a href="#分割线和空行" class="headerlink" title="分割线和空行"></a>分割线和空行</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">上面是分割线</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">上面是空行</span><br></pre></td></tr></table></figure><p></p><hr><br><strong>上面是分割线</strong><br><br><br><strong>上面是空行</strong><p></p><hr><h3 id="markdown引用以及html写法"><a href="#markdown引用以及html写法" class="headerlink" title="markdown引用以及html写法"></a>markdown引用以及html写法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>引用内容<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果前后间隙很小，可以像下面这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>引用内容<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><blockquote>引用内容</blockquote><p></p><blockquote>引用内容</blockquote><p></p><hr><h3 id="居中和右对齐"><a href="#居中和右对齐" class="headerlink" title="居中和右对齐"></a>居中和右对齐</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 居中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 右对齐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:right"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><center>内容</center><div style="text-align:right">内容</div><hr><h3 id="字体大小和颜色"><a href="#字体大小和颜色" class="headerlink" title="字体大小和颜色"></a>字体大小和颜色</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#FF0000"</span> <span class="attr">size</span>=<span class="string">"8px"</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#FFFF00"</span> <span class="attr">size</span>=<span class="string">"6px"</span>&gt;</span>黄色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#00FF00"</span> <span class="attr">size</span>=<span class="string">"4px"</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><font color="#FF0000" size="8px">红色</font></li><li><font color="#FFFF00" size="6px">黄色</font></li><li><font color="#00FF00" size="4px">绿色</font></li><li>更多颜色请查看 <a href="http://www.bootcss.com/p/websafecolors" target="_blank" rel="noopener">web安全色</a>、<a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="noopener">颜色对照表</a></li></ul><hr><h3 id="字体高亮显示"><a href="#字体高亮显示" class="headerlink" title="字体高亮显示"></a>字体高亮显示</h3><div class="note info">使用mark标签进行标记，高亮显示文档中的文字</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span>这是一个标记<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">使用mark标签进行标记，<span class="tag">&lt;<span class="name">mark</span>&gt;</span>高亮显示<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>文档中的文字</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p>使用mark标签进行标记，<mark>高亮显示</mark>文档中的文字</p><hr><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td><em>短文本</em></td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><div class="note warning"><ul><li>表格的语句<mark>上一行必须为空行</mark>，不然表格不生效;</li><li>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;</li><li>-的数量至少有一个;</li><li>|、-、:之间的多余空格会被忽略，不影响布局;</li><li>表格内容中可以套用其他用法，如加粗、斜体等。</li></ul></div><h4 id="表格对齐问题"><a href="#表格对齐问题" class="headerlink" title="表格对齐问题"></a>表格对齐问题</h4><ul><li>-:表示内容和标题栏居右对齐；</li><li>:-表示内容和标题栏居左对齐；</li><li>:-:表示内容和标题栏居中对齐；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| :------ | :------: | ------: |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th style="text-align:left">一个普通标题</th><th style="text-align:center">一个普通标题</th><th style="text-align:right">一个普通标题</th></tr></thead><tbody><tr><td style="text-align:left"><em>短文本</em></td><td style="text-align:center">中等文本</td><td style="text-align:right">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:center">短文本</td><td style="text-align:right">中等文本</td></tr></tbody></table><a class="btn" href="http://showteeth.tech/posts/65136.html"><i class="fa fa-telegram fa-lg fa-fw"></i>合并单元格、修改表格样式</a><hr><h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo list"></a>Todo list</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><br><li><i class="fa fa-check-square"></i> 已完成</li><br><li><i class="fa fa-square"></i> 未完成</li><br></ul><hr><h3 id="Note-嵌套-Todo-list"><a href="#Note-嵌套-Todo-list" class="headerlink" title="Note 嵌套 Todo list"></a>Note 嵌套 Todo list</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一共有两种写法，效果看下面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br></p><div class="note primary"><br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br></div><div class="note primary"><br><p><br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br></p><br></div><hr><h3 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ```[language] [title] [url] [link-text] --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意前后都，上面演示如果后面加了会出错</li><li>language表示代码语言</li><li><code>title</code>表示出现在代码框左上角的标题</li><li><code>url</code>表示超链接地址</li><li><code>link-text</code>表示超链接的名称</li><li>这 4 项应该是根据<em>空格来分隔</em>，而不是[]，故请不要加[]。除非如果你想<strong>写后面两个</strong>，但不想写前面两个，那么就<strong>必须加 []</strong> 了，要这样写：[] [] [url] [link text] <strong>个人只验证出可以加title，url和text没验证成功。</strong></li></ul><p><strong>效果如下：</strong><br></p><figure class="highlight html"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note info">各种支持语言的名称可以查看<a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" target="_blank" rel="noopener">这篇文章</a></div><hr><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`test`</span><br></pre></td></tr></table></figure><hr><h3 id="Font-Awesome"><a href="#Font-Awesome" class="headerlink" title="Font Awesome"></a>Font Awesome</h3><div class="note default">放大图标的方法示例：</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 普通</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 变大 33%</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download fa-2x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 两倍大</span><br><span class="line"></span><br><span class="line">#fa-fw：ensuring proper alignment of the icons</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download fa-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 图标和文字之间合适间距</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><i class="fa fa-download"></i> 普通</li><li><i class="fa fa-download fa-lg"></i> 变大 33%</li><li><i class="fa fa-download fa-2x"></i> 两倍大</li><li><i class="fa fa-download fa-fw"></i> 图标和文字之间合适间距</li></ul><div class="note info"><code>fa-fw</code>：ensuring proper alignment of the icons</div><hr><h3 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h3><div class="note info">next主题的note标签功能我一发现就爱上了，实在很好看啊~~~~</div><p>首先该功能可以在<code>next\_config.yml</code>配置文件中进行配置，默认是打开的，但是可以挑选自己喜欢的模式。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Note tag (bs-callout).</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure><p></p><p>我自己选择了其中的<code>flat style</code>，其用法如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note default"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>default<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>primary<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note success"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>success<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note info"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>info<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note warning"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>warning<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger no-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger no-icon<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">note danger, note danger, note danger</span><br><span class="line">note danger, note danger, note danger</span><br><span class="line">note danger, note danger, note danger</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>效果如下：</strong></p><div class="note default"><p>default</p></div><br><div class="note primary"><p>primary</p></div><br><div class="note success"><p>success</p></div><br><div class="note info"><p>info</p></div><br><div class="note warning"><p>warning</p></div><br><div class="note danger"><p>danger</p></div><br><div class="note danger no-icon"><p>danger no-icon</p></div><div class="note danger"><p>note danger, note danger, note danger<br>note danger, note danger, note danger<br>note danger, note danger, note danger</p></div><div class="note info"><code>next\_config.yml</code>三种样式的具体情况请看<a href="https://github.com/iissnan/hexo-theme-next/pull/1697" target="_blank" rel="noopener">网站</a></div><hr><h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><div class="note info">该标签也是在<code>next\_config.yml</code>配置文件中，默认是打开的</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Usage:</span><br><span class="line">*</span><br><span class="line">* &#123;% label [class] %&#125;Content&#123;% endlabel %&#125;</span><br><span class="line">*</span><br><span class="line">* [class] : default | primary | success | info | warning | danger.</span><br><span class="line">*           If not defined, default class will be selected.</span><br></pre></td></tr></table></figure><span class="label default">default</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label default@default %&#125;</span><br></pre></td></tr></table></figure><span class="label primary">primary</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label primary@primary %&#125;</span><br></pre></td></tr></table></figure><span class="label success">success</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label success@success %&#125;</span><br></pre></td></tr></table></figure><span class="label info">info</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label info@info %&#125;</span><br></pre></td></tr></table></figure><span class="label warning">warning</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label warning@warning %&#125;</span><br></pre></td></tr></table></figure><span class="label danger">danger</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label danger@danger %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lorem &#123;% label @ipsum %&#125; &#123;% label primary@dolor sit %&#125; amet, consectetur &#123;% label success@adipiscing elit, %&#125; sed &#123;% label info@do eiusmod %&#125; tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line"></span><br><span class="line">Ut enim *&#123;% label warning @ad %&#125;* minim veniam, quis **&#123;% label danger @nostrud %&#125;** exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</span><br><span class="line"></span><br><span class="line">Duis aute irure dolor in reprehenderit in voluptate ~~&#123;% label default @velit %&#125;~~ <span class="tag">&lt;<span class="name">mark</span>&gt;</span>esse<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br>Lorem <span class="label default">ipsum</span> <span class="label primary">dolor sit</span> amet, consectetur <span class="label success">adipiscing elit,</span> sed <span class="label info">do eiusmod</span> tempor incididunt ut labore et dolore magna aliqua.</p><p>Ut enim <em><span class="label warning">ad</span></em> minim veniam, quis <strong><span class="label danger">nostrud</span></strong> exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p><p>Duis aute irure dolor in reprehenderit in voluptate <del><span class="label default">velit</span></del> <mark>esse</mark> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p><div class="note info"><a href="https://almostover.ru/2016-01/hexo-theme-next-test/#" target="_blank" rel="noopener">更多相关使用请看网站</a></div><hr><h3 id="Tab-选项卡"><a href="#Tab-选项卡" class="headerlink" title="Tab 选项卡"></a>Tab 选项卡</h3><div class="note info">该标签也是在<code>next\_config.yml</code>配置文件中</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 3</span><br></pre></td></tr></table></figure><div class="note info">用法讲解：</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tabs.js | global hexo script.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">&#123;% tabs [Unique name], [index] %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab [Tab caption]@[icon] --&gt;</span></span><br><span class="line">Any content (support inline tags too).</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">[Unique name]      : Unique name of tabs block tag without comma.</span><br><span class="line">                   Will be used in #id's as prefix for each tab with their index numbers.</span><br><span class="line">                   If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span><br><span class="line">                   Only for current url of post/page must be unique!</span><br><span class="line">[index]            : Index number of active tab.</span><br><span class="line">                   If not defined, first tab (1) will be selected.</span><br><span class="line">                   If index is -1, no tab will be selected. It's will be something like spoiler.</span><br><span class="line">                   May be not defined.</span><br><span class="line">[Tab caption]      : Caption of current tab.</span><br><span class="line">                   If not caption specified, unique name with tab index suffix will be used as caption of tab.</span><br><span class="line">                   If not caption specified, but specified icon, caption will empty.</span><br><span class="line">                   May be not defined.</span><br><span class="line">[icon]             : Font awesome icon.</span><br><span class="line">                    May be not defined.</span><br></pre></td></tr></table></figure><h4 id="设定选中第二个选项卡"><a href="#设定选中第二个选项卡" class="headerlink" title="设定选中第二个选项卡"></a>设定选中第二个选项卡</h4><p>应用示例：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 2 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**这是选项卡 1** 呵呵哈哈哈哈哈哈</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**这是选项卡 2** 额。。。</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**这是选项卡 3** 哇，你找到我了！</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>效果如下：</strong><br></p><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong> 额。。。</p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了！</p></div></div></div><p></p><div class="note info"><p>tabs 选项卡, 2：<br>选项卡表示选项卡的名称，如果为tab，得到的选项卡显示为tab 1、tab 2、tab 3；<br>2 表示一开始在第二个选项卡，非必须，若数值为 -1 则隐藏选项卡内容(也就是不显示呵呵哈哈哈哈哈哈这一些话，点击之后才会显示)。</p></div><hr><h4 id="自定义每个选项卡的名称"><a href="#自定义每个选项卡的名称" class="headerlink" title="自定义每个选项卡的名称"></a>自定义每个选项卡的名称</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Fourth unique name %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab Solution 1 --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 2 --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 3 --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br></p><div class="tabs" id="fourth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fourth-unique-name-1">Solution 1</a></li><li class="tab"><a href="#fourth-unique-name-2">Solution 2</a></li><li class="tab"><a href="#fourth-unique-name-3">Solution 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="fourth-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="fourth-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div><p></p><div class="note info">上面的solution 1、2、3即为自定义的，每个tab都可以设置自己的</div><hr><h4 id="每个tab只显示图标"><a href="#每个tab只显示图标" class="headerlink" title="每个tab只显示图标"></a>每个tab只显示图标</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Fifth unique name %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab @text-width --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab @amazon --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab @bold --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br></p><div class="tabs" id="fifth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fifth-unique-name-1"><i class="fa fa-text-width" style="text-align:center"></i></a></li><li class="tab"><a href="#fifth-unique-name-2"><i class="fa fa-amazon" style="text-align:center"></i></a></li><li class="tab"><a href="#fifth-unique-name-3"><i class="fa fa-bold" style="text-align:center"></i></a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="fifth-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="fifth-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div><p></p><div class="note info">上面的<code>@amazon</code>即为图标icon</div><hr><h4 id="既显示图标有显示名称"><a href="#既显示图标有显示名称" class="headerlink" title="既显示图标有显示名称"></a>既显示图标有显示名称</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Sixth unique name %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab Solution 1@text-width --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 2@amazon --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 3@bold --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><div class="note warning">这个貌似会报错</div><hr><h4 id="制作链接，快速访问多个tabs组"><a href="#制作链接，快速访问多个tabs组" class="headerlink" title="制作链接，快速访问多个tabs组"></a>制作链接，快速访问多个tabs组</h4><div class="note info">参见<a href="https://almostover.ru/2016-01/hexo-theme-next-test/" target="_blank" rel="noopener">网址</a></div><hr><h4 id="tabs中套用其他标签"><a href="#tabs中套用其他标签" class="headerlink" title="tabs中套用其他标签"></a>tabs中套用其他标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Tags %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"></span><br><span class="line">1. One</span><br><span class="line">2. Two</span><br><span class="line">3. Three</span><br><span class="line"></span><br><span class="line">Tabbed code block:</span><br><span class="line"></span><br><span class="line">nano /etc</span><br><span class="line"></span><br><span class="line">&#123;% code %&#125;</span><br><span class="line">code block tag</span><br><span class="line">code block tag</span><br><span class="line">code block tag</span><br><span class="line">&#123;% endcode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default %&#125;</span><br><span class="line">Note default tag.</span><br><span class="line">&#123;% endnote %&#125;&#123;% youtube A1Qb4zfurA8 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"></span><br><span class="line">* Five</span><br><span class="line">* Six</span><br><span class="line">* Seven</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">&#123;% youtube rX3W5evpeJE %&#125;</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br></p><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><a href="#tags-1">Tags 1</a></li><li class="tab"><a href="#tags-2">Tags 2</a></li><li class="tab"><a href="#tags-3">Tags 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tags-1"><p><strong>This is Tab 1.</strong></p><ol><li>One</li><li>Two</li><li>Three</li></ol><p>Tabbed code block:</p><pre><code>nano /etc</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code block tag</span><br><span class="line">code block tag</span><br><span class="line">code block tag</span><br></pre></td></tr></table></figure><div class="note default"><p>Note default tag.</p></div><div class="video-container"><iframe src="//www.youtube.com/embed/A1Qb4zfurA8" frameborder="0" allowfullscreen></iframe></div></div><div class="tab-pane" id="tags-2"><p><strong>This is Tab 2.</strong></p><ul><li>Five</li><li>Six</li><li>Seven</li></ul><div class="note primary"><div class="video-container"><iframe src="//www.youtube.com/embed/rX3W5evpeJE" frameborder="0" allowfullscreen></iframe></div></div></div><div class="tab-pane" id="tags-3"><p><strong>This is Tab 3.</strong></p><div class="note success"><p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.</p></div></div></div></div><p></p><hr><h3 id="按钮样式"><a href="#按钮样式" class="headerlink" title="按钮样式"></a>按钮样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># fa-lg：放大图标33%</span><br><span class="line"># fa-fw：图标和文字之间合理间距显示</span><br><span class="line"># download：图标的名称，fa-download，这里只写download即可</span><br><span class="line">&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-rotate-90 %&#125;</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br><a class="btn" href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>更多关于按钮的使用点这里</a></p><div class="text-center"><br><a class="btn" href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>更多关于按钮的使用点这里</a><br></div><a class="btn" href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-rotate-90"></i>更多关于按钮的使用点这里</a><div class="note info">点击上面的按钮可以跳转到另一个网址，查看更过关于按钮的操作</div><div class="note success"><ul><li>可以将其放在html语句中进行居中等各种操作</li><li>btn后跟着点击按钮之后想访问的链接</li><li>fa-lg：放大图标33%</li><li>fa-fw：图标和文字之间合理间距显示</li><li>fa-rotate-90：顺时针旋转90度</li><li>download：图标的名称，fa-download，这里只写download即可</li></ul></div><hr><p><br></p><h2 id="插入照片"><a href="#插入照片" class="headerlink" title="插入照片"></a>插入照片</h2><p>因为图片功能在markdown语法中比较常用，所以将其单列出来，便于查找。</p><h3 id="使用七牛作为图床"><a href="#使用七牛作为图床" class="headerlink" title="使用七牛作为图床"></a>使用七牛作为图床</h3><p>用法实例：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将其插入html语句中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>title：鼠标移到图片上显示的名称</li><li>alt：图片不能正常加载时显示的说明文字</li><li>extend:?imageView2/2/w/600 ：表示生成宽度最多600px的缩略图</li></ul></div><div class="note warning"><p>已经放弃七牛图床，并采用阿里云作为图床，具体请参考<a href="http://showteeth.tech/posts/41221.html">这篇文章</a></p></div><hr><h3 id="常规markdown语法"><a href="#常规markdown语法" class="headerlink" title="常规markdown语法"></a>常规markdown语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="comment">&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown插入图片"></p><center><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown+center标签居中插入图片"><br></center><div class="note info"><p><code>Optional title</code> 是用来在鼠标移到图片上时显示的title</p></div><div class="note warning"><p>使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别</p></div><hr><h3 id="html代码插入图片"><a href="#html代码插入图片" class="headerlink" title="html代码插入图片"></a>html代码插入图片</h3><p><strong>针对使用markdown插入图片的缺点，使用html语句可以很好的解决</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用img标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pn9abh3rj.bkt.clouddn.com/test.png"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"图片名称"</span> <span class="attr">align</span>=<span class="string">center</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用div标签包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pn9abh3rj.bkt.clouddn.com/test.png"</span>  <span class="attr">title</span>=<span class="string">"使用html插入图片"</span>  <span class="attr">alt</span>=<span class="string">"图片名称"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" width="300" height="200" alt="图片名称" title="使用html插入图片" align="center"></p><div align="center"><br><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" title="使用html插入图片" alt="图片名称"><br></div><div class="note warning"><ul><li>不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；</li><li>推荐使用div标签包裹img标签。</li></ul></div><hr><p><br></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><div class="note success"><ul><li><strong>博客一般都以二级标题开始写起</strong></li><li><strong>html代码如div标签后面一定要空行</strong></li><li><strong>标签之间一般都是可以嵌套的</strong></li><li><strong>插入图片推荐使用div标签包裹img标签实现</strong></li><li><strong>写完一段记得空行！！！尽量每写完一段就空一行，尤其是代码段和文字之间，不然可能会出现markdown语法不能识别的情况（前面的错误可能导致后续很多语法都不能正常识别，在找错误的时候看第一个不能识别的位置）</strong></li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/" target="_blank" rel="noopener">很详细很好的技巧文章</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">也是很好的教程，可结合上一个看</a></li><li><a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" target="_blank" rel="noopener">支持highlight的语言</a></li><li><a href="https://almostover.ru/2016-01/hexo-theme-next-test/#" target="_blank" rel="noopener">note、label、button、tab使用讲解及示例</a></li><li><a href="https://github.com/iissnan/hexo-theme-next/pull/1697" target="_blank" rel="noopener">note、label、tab使用讲解及示例</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 博客 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
