<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>more和less-查看文本内容</title>
      <link href="/posts/57059.html"/>
      <url>/posts/57059.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了Linux查看文本内容的常用命令<code>more</code>以及<code>less</code>，两个命令很多地方都很相似，但是<code>less</code><strong>更加强大</strong>；分别学习了<code>more</code>和<code>less</code>的<strong>参数</strong>以及<strong>命令</strong>，其中<code>less</code>部分的参数和命令 <strong>只学习了常用的部分</strong>(<code>less</code>的功能很强大，对应的参数和命令很多，但是很多用不上，这里就没学习，后学如果有用在补上)。</p></div><a id="more"></a><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>more会以<strong>一页一页</strong>的显示方便使用者逐页阅读，而最基本的指令就是按<strong>空白键(space)就往下一页显示</strong>，<strong>按 b 键就会往回(back)一页显示</strong>，而且还有<strong>搜寻字串(直接跳转行)的功能</strong>,<strong>使用中按<code>h</code>可以查看说明文件</strong> 。more命令从前向后读取文件，因此在<strong>启动时就加载整个文件</strong>。</p><h3 id="more命令用法"><a href="#more命令用法" class="headerlink" title="more命令用法"></a>more命令用法</h3><h4 id="more命令格式"><a href="#more命令格式" class="headerlink" title="more命令格式"></a>more命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: </span><br><span class="line">  more [-dflpcsu] [+linenum | +/pattern] name1 name2 ...</span><br></pre></td></tr></table></figure><hr><h4 id="more-options说明"><a href="#more-options说明" class="headerlink" title="more options说明"></a>more options说明</h4><style>table th:first-of-type{width:10%}table th:nth-of-type(2){width:90%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>+n</code></td><td><strong>从笫n行开始显示</strong></td></tr><tr><td><code>-n</code></td><td><strong>定义屏幕大小为n行</strong></td></tr><tr><td><code>+/pattern</code></td><td><strong>在每个档案显示前搜寻该字串(pattern)，然后从该字串前两行之后开始显示</strong></td></tr><tr><td><code>-c</code></td><td><strong>清屏显示</strong></td></tr><tr><td><code>-d</code></td><td><strong>提示使用者，在内容下方显示 <code>[Press space to continue, &#39;q&#39; to quit.]</code> 如果按错键，则会显示 <code>[Press &#39;h&#39; for instructions.]</code> 而不是 ‘哔’ 声</strong></td></tr><tr><td><code>-l</code></td><td>忽略Ctrl+l(换页)字符</td></tr><tr><td><code>-p</code></td><td><strong>通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</strong></td></tr><tr><td><code>-s</code></td><td><strong>把连续的多个空行显示为一行</strong></td></tr><tr><td><code>-u</code></td><td>把文件内容中的下画线去掉</td></tr><tr><td><code>-f</code></td><td><strong>计算行数时，以实际上的行数，而非自动换行过后的行数(有些单行字数太长的会被扩展为两行或两行以上),可以和<code>-n</code>连用</strong></td></tr></tbody></table><hr><h4 id="more常用操作命令"><a href="#more常用操作命令" class="headerlink" title="more常用操作命令"></a>more常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>空格(space)</code></td><td><strong>向下滚动一屏</strong></td></tr><tr><td><code>z</code></td><td>向下滚动一屏</td></tr><tr><td><code>enter(return)</code></td><td><strong>向后滚动n行，默认为1</strong></td></tr><tr><td><code>q or Q or &lt;interrupt&gt;</code></td><td>退出more</td></tr><tr><td><code>b or ctrl-B</code></td><td><strong>返回上一屏</strong></td></tr><tr><td><code>=</code></td><td>输出当前行的行号</td></tr><tr><td><code>：f</code></td><td><strong>输出文件名和当前行的行号</strong></td></tr><tr><td><code>V</code></td><td>调用vi编辑器</td></tr><tr><td><code>!命令</code></td><td><strong>调用Shell，并执行命令</strong></td></tr><tr><td><code>.</code></td><td><strong>重复上一个命令</strong></td></tr></tbody></table><div class="note info"><ul><li><code>!命令</code>:输入的命令不能输错，输错了删不了；输出结果和文本内容之间使用<code>------</code>分割</li><li><code>：f</code>：使用时是按下<code>:</code>同时按下<code>f</code>，不能先按下<code>:</code>松手后再按<code>f</code></li></ul></div><hr><h4 id="参数和命令的关系"><a href="#参数和命令的关系" class="headerlink" title="参数和命令的关系"></a>参数和命令的关系</h4><div class="note info"><p><strong>参数决定了显示的内容(起始行、页面显示行数、换页是清屏还是滚动)，而命令决定了怎么去显示(翻页、滚动等)</strong>，以<code>-p</code>参数为例，规定了是清屏进行翻页，具体的翻页动作需要使用空格键操作，同时需要注意，其只规定的是换页是清屏的，如果使用<code>enter</code>进行显示下一行，仍然是滚动的方式，而不是清屏.</p></div><hr><h3 id="more命令实例"><a href="#more命令实例" class="headerlink" title="more命令实例"></a>more命令实例</h3><h4 id="n-从第n行开始显示"><a href="#n-从第n行开始显示" class="headerlink" title="+n-从第n行开始显示"></a>+n-从第n行开始显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n的索引是从1开始的</span></span><br><span class="line">more +3 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="n-每屏显示n行"><a href="#n-每屏显示n行" class="headerlink" title="-n-每屏显示n行"></a>-n-每屏显示n行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每屏显示4行，可结合空格进行翻页</span></span><br><span class="line">more -4 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="pattern-搜寻字串"><a href="#pattern-搜寻字串" class="headerlink" title="+/pattern-搜寻字串"></a>+/pattern-搜寻字串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找第一个出现"liu"字符串的行，并从该处前两行开始显示输出</span></span><br><span class="line"><span class="comment"># 输出第一行会显示...skipping</span></span><br><span class="line">more +/liu test.log</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>第一次出现字符串</li><li>出现字符串的前两行</li></ul></div><hr><h4 id="c-清屏显示"><a href="#c-清屏显示" class="headerlink" title="-c-清屏显示"></a>-c-清屏显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不使用参数的情况下，如果文件行数大于屏幕可以显示的数目，也会清屏显示</span></span><br><span class="line">more test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用了-n选项，仍然符合上面的规则，如果-n小于屏幕可以显示的数目</span></span><br><span class="line">more -4 test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c参数之后，先清屏之后再显示(不管指定的每页显示行数为多少)</span></span><br><span class="line">more -c -4 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="d-提示信息"><a href="#d-提示信息" class="headerlink" title="-d-提示信息"></a>-d-提示信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">more -d test.log</span><br><span class="line"><span class="comment"># 在显示文本下方显示</span></span><br><span class="line"><span class="comment">#  --More--(0%)[Press space to continue, 'q' to quit.</span></span><br><span class="line"><span class="comment"># 按错命令按键则会出现</span></span><br><span class="line"><span class="comment"># [Press 'h' for instructions.]</span></span><br></pre></td></tr></table></figure><hr><h4 id="f-计算实际行数"><a href="#f-计算实际行数" class="headerlink" title="-f-计算实际行数"></a>-f-计算实际行数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每页显示30行(实际行数)</span></span><br><span class="line"><span class="comment"># 如果不加-f参数的话(也就是默认情况下)显示的不是实际行数(一行太长，换行会当2行算)</span></span><br><span class="line">more -f -30 test.log</span><br></pre></td></tr></table></figure><hr><h4 id="p-清屏换页"><a href="#p-清屏换页" class="headerlink" title="-p-清屏换页"></a>-p-清屏换页</h4><p>通过清屏来换页，而不是通过滚动页面(在同一个页面，内容增加，右侧出现滚动滑块)，和<code>-c</code>参数基本是一样的:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个结合翻页很好用，只会在页面顶端的4行显示内容，不会叠加在同一个页面</span></span><br><span class="line">more -p  -4 test.log</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p><code>less</code>工具也是<strong>对文件或其它输出进行分页显示的工具</strong>，应该说是linux<strong>正统查看文件内容的工具，功能极其强大</strong>。<code>less</code>的用法比起<code>more</code>更加的有弹性:</p><ul><li>在<code>more</code>的时候，我们并没有办法向前面翻，只能往后面看(b或者ctrl+b只是向前翻页，不能像less一样单行单行的向前滚动显示)，但若使用了 <code>less</code>，就可以使用<code>pageup</code>、<code>pagedown</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</li><li>在 <code>less</code> 里头可以拥有<strong>更多的搜索功能，不止可以向下搜，也可以向上搜</strong>，<code>more</code>只能搜素后面的，输出的内容不在搜索范围内</li></ul><h3 id="less命令格式"><a href="#less命令格式" class="headerlink" title="less命令格式"></a>less命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  less [参数]  文件</span><br></pre></td></tr></table></figure><hr><h4 id="less-options说明"><a href="#less-options说明" class="headerlink" title="less options说明"></a>less options说明</h4><p>less的功能非常强大，包含很多方面，对应的参数也非常堵，需要的可以使用<code>less --help</code>查看，这里只列出常用的参数和功能：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-m</code></td><td>显示类似more命令的百分比</td></tr><tr><td><code>-N</code></td><td>显示每行的行号</td></tr><tr><td><code>-M</code></td><td><strong>显法读取文件的百分比、行区间及总行数</strong></td></tr><tr><td><code>-e</code></td><td><strong>当文件显示结束后，自动退出</strong></td></tr><tr><td><code>-S</code></td><td><strong>Chop long lines(在单行显示较长的内容，而不换行显示)</strong></td></tr><tr><td><code>-x &lt;数字&gt;</code></td><td><strong>将TAB字符显示为指定个数的空格字符</strong></td></tr></tbody></table><hr><h4 id="less常用操作命令"><a href="#less常用操作命令" class="headerlink" title="less常用操作命令"></a>less常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>enter(回车)</code></td><td>向下移动一行</td></tr><tr><td><code>y</code></td><td>向上移动一行</td></tr><tr><td><code>pagedown</code></td><td>向下移动一行</td></tr><tr><td><code>pageup</code></td><td>向上移动一行</td></tr><tr><td><code>b</code></td><td>向上滚动一屏</td></tr><tr><td><code>空格键</code></td><td>向下滚动一屏</td></tr><tr><td><code>g</code></td><td><strong>跳到第一行</strong></td></tr><tr><td><code>G</code></td><td><strong>跳到最后一行</strong></td></tr><tr><td><code>p n%</code></td><td><strong>跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示</strong></td></tr><tr><td><code>w n</code></td><td><strong>可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的n是6，那就从第7行显示</strong></td></tr><tr><td><code>!命令</code></td><td>调用Shell，并执行命令</td></tr><tr><td><code>q</code></td><td>退出less</td></tr></tbody></table><hr><h2 id="more和less的区别"><a href="#more和less的区别" class="headerlink" title="more和less的区别"></a>more和less的区别</h2><ul><li>在<code>more</code>的时候，我们并没有办法向前面翻，只能往后面看(b或者ctrl+b只是向前翻页，不能像less一样单行单行的向前滚动显示)，但若使用了 <code>less</code>，就可以使用<code>pageup</code>、<code>pagedown</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</li><li>在 <code>less</code> 里头可以拥有<strong>更多的搜索功能，不止可以向下搜，也可以向上搜</strong>，<code>more</code>只能搜素后面的，输出的内容不在搜索范围内</li><li><code>less</code>使用退出之后屏幕<strong>不会留下显示的内容</strong>，而<code>more</code>退出之后屏幕<strong>会留下当前显示的内容</strong></li><li><code>less</code>不必读整个文件，加载速度会比<code>more</code>更快</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/aijianshi/p/5750911.html" target="_blank" rel="noopener">Linux中more和less命令用法</a></li><li><a href="http://www.cnblogs.com/xqzt/p/5414814.html" target="_blank" rel="noopener">每天一个linux命令(12):more命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成-Python系列之setup.py</title>
      <link href="/posts/33963.html"/>
      <url>/posts/33963.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/maociping/p/6633948.html" target="_blank" rel="noopener">python的构建工具setup.py</a></li><li><a href="https://lingxiankong.github.io/2013-12-23-python-setup.html" target="_blank" rel="noopener">关于python中的setup.py</a></li><li><a href="https://blog.csdn.net/langb2014/article/details/53114341" target="_blank" rel="noopener">python的setup问题</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫之Selenium-自动化测试</title>
      <link href="/posts/50111.html"/>
      <url>/posts/50111.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章将自己在使用Selenium过程中遇到的好文章进行了汇总和整理，便于后续继续使用这个工具时能尽快找到好的参考，节省时间！</p></div><a id="more"></a><h2 id="Selenium简介"><a href="#Selenium简介" class="headerlink" title="Selenium简介"></a>Selenium简介</h2><p>selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。</p><p>selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。</p><hr><h2 id="selenium用法"><a href="#selenium用法" class="headerlink" title="selenium用法"></a>selenium用法</h2><p>用python写爬虫的时候，主要用的是selenium的Webdriver，我们可以通过下面的方式先看看Selenium.Webdriver支持哪些浏览器</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193320778-188010556.png" alt></p><p>执行结果如下，从结果中我们也可以看出基本山支持了常见的所有浏览器：</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193414684-1032464838.png" alt></p><p>这里要说一下比较重要的PhantomJS,PhantomJS是一个而基于WebKit的服务端JavaScript API,支持Web而不需要浏览器支持，其快速、原生支持各种Web标准：Dom处理，CSS选择器，JSON等等。PhantomJS可以用用于页面自动化、网络监测、网页截屏，以及无界面测试</p><h3 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h3><p>上面我们知道了selenium支持很多的浏览器，但是如果想要声明并调用浏览器则需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 打开浏览器，注意需要提前下载浏览器驱动以及将其写入环境变量</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br></pre></td></tr></table></figure><p>这里只写了两个例子，当然了其他的支持的浏览器都可以通过这种方式调用。</p><p><strong>可能遇到的问题</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\selenium\webdriver\common\service.py"</span>, line <span class="number">76</span>, <span class="keyword">in</span> start</span><br><span class="line">    stdin=PIPE)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">769</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    restore_signals, start_new_session)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">1172</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">    startupinfo)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。</span><br></pre></td></tr></table></figure><p></p><p><strong>这是因为没有将浏览器驱动以及没有将浏览器驱动添加到环境变量</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 驱动下载地址</span></span><br><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载对应的chrome版本之后将压缩包解压，我下载的是chromedriver_win32.zip</span></span><br><span class="line"><span class="comment"># 发现32位的也能用，关键是只提供了32位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压上述包，然后将exe文件写入环境变量，可将exe文件放在C:\Program Files (x86)\Google\Chrome\Application目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量(可能需要重启电脑才会生效)之后直接输入</span></span><br><span class="line">chromedriver.exe</span><br><span class="line">Starting ChromeDriver <span class="number">72.0</span><span class="number">.3626</span><span class="number">.69</span> (<span class="number">3</span>c16f8a135abc0d4da2dff33804db79b849a7c38) on port <span class="number">9515</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver <span class="keyword">and</span> related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网站</span></span><br><span class="line">browser.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 输入网站源码</span></span><br><span class="line">print(browser.page_source)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>上述代码运行后，会自动打开Chrome浏览器，并登陆百度打印百度首页的源代码，然后关闭浏览器</p><hr><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="单个元素查找"><a href="#单个元素查找" class="headerlink" title="单个元素查找"></a>单个元素查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 使用id查找</span></span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">"q"</span>)</span><br><span class="line"><span class="comment"># 使用css_selector查找</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">"#q"</span>)</span><br><span class="line"><span class="comment"># 使用xpath查找</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line"></span><br><span class="line">print(input_first)</span><br><span class="line">print(input_second)</span><br><span class="line">print(input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>这里我们通过三种不同的方式去获取响应的元素，第一种是通过id的方式，第二个中是CSS选择器，第三种是xpath选择器，结果都是相同的。<br>结果如下：</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193535200-558486822.png" alt></p><p><strong>这里列举一下常用的查找元素方法</strong>：</p><ul><li><code>find_element_by_name</code></li><li><code>find_element_by_id</code></li><li><code>find_element_by_xpath</code></li><li><code>find_element_by_link_text</code></li><li><code>find_element_by_partial_link_text</code></li><li><code>find_element_by_tag_name</code></li><li><code>find_element_by_class_name</code></li><li><code>find_element_by_css_selector</code></li></ul><p>下面这种方式是比较通用的一种方式：这里需要记住By模块所以需要导入<code>from selenium.webdriver.common.by import By</code><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 设置查找的方法以及查找的对象</span></span><br><span class="line">input_first = browser.find_element(By.ID,<span class="string">"q"</span>)</span><br><span class="line"></span><br><span class="line">print(input_first)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p></p><p>当然这种方法和上述的方式是通用的，<code>browser.find_element(By.ID,&quot;q&quot;)</code>这里<code>By.ID</code>中的ID可以替换为其他几个</p><hr><h4 id="多个元素查找"><a href="#多个元素查找" class="headerlink" title="多个元素查找"></a>多个元素查找</h4><p>其实多个元素和单个元素的区别，举个例子：<code>find_elements</code>,单个元素是<code>find_element</code>,其他使用上没什么区别，通过其中的一个例子演示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"><span class="comment"># 执行查找</span></span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通用的方法实现</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">lis = browser.find_elements(By.CSS_SELECTOR,<span class="string">'.service-bd li'</span>)</span><br><span class="line"></span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p></p><p>这样获得就是一个列表</p><p><img src="https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193737497-369795287.png" alt></p><p><strong>同样的在单个元素中查找的方法在多个元素查找中同样存在</strong>：</p><ul><li><code>find_elements_by_name</code></li><li><code>find_elements_by_id</code></li><li><code>find_elements_by_xpath</code></li><li><code>find_elements_by_link_text</code></li><li><code>find_elements_by_partial_link_text</code></li><li><code>find_elements_by_tag_name</code></li><li><code>find_elements_by_class_name</code></li><li><code>find_elements_by_css_selector</code></li></ul><hr><h3 id="元素交互操作"><a href="#元素交互操作" class="headerlink" title="元素交互操作"></a>元素交互操作</h3><p>对于获取的元素调用交互方法:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line"></span><br><span class="line">input_str = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line"><span class="comment"># 发送信息</span></span><br><span class="line">input_str.send_keys(<span class="string">"ipad"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">input_str.clear()</span><br><span class="line"></span><br><span class="line">input_str.send_keys(<span class="string">"MakBook pro"</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line"></span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure><p></p><p><strong>运行的结果可以看出程序会自动打开Chrome浏览器并打开淘宝输入ipad,然后删除，重新输入MakBook pro，并点击搜索</strong></p><p><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">Selenium所有的api文档</a></p><p><strong>交互动作</strong></p><p><strong>将动作附加到动作链中串行执行</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">"http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable"</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"></span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line"></span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p></p><p><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">更多操作参考</a></p><hr><h3 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h3><p>这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，下面的例子是 <strong>通过登录知乎然后通过js翻到页面底部，并弹框提示</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">"http://www.zhihu.com/explore"</span>)</span><br><span class="line"></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure><p></p><h4 id="获取元素属性-get-attribute-‘class’"><a href="#获取元素属性-get-attribute-‘class’" class="headerlink" title="获取元素属性-get_attribute(‘class’)"></a>获取元素属性-get_attribute(‘class’)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">logo = browser.find_element_by_id(<span class="string">'zh-top-link-logo'</span>)</span><br><span class="line"></span><br><span class="line">print(logo)</span><br><span class="line">print(logo.get_attribute(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure><hr><h4 id="获取文本值-text"><a href="#获取文本值-text" class="headerlink" title="获取文本值-text"></a>获取文本值-text</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.text)</span><br></pre></td></tr></table></figure><hr><h4 id="获取ID、位置、标签名"><a href="#获取ID、位置、标签名" class="headerlink" title="获取ID、位置、标签名"></a>获取ID、位置、标签名</h4><ul><li><code>id</code></li><li><code>location</code></li><li><code>tag_name</code></li><li><code>size</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.id)</span><br><span class="line">print(input.location)</span><br><span class="line">print(input.tag_name)</span><br><span class="line">print(input.size)</span><br></pre></td></tr></table></figure><hr><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p>在很多网页中都是有Frame标签，所以我们爬取数据的时候就涉及到切入到frame中以及切出来的问题，通过下面的例子演示<br>这里常用的是<code>switch_to.from()</code>和<code>switch_to.parent_frame()</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">print(source)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'NO LOGO'</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0</p><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>到了一定的时间发现元素还没有加载，则继续等待我们指定的时间，如果超过了我们指定的时间还没有加载就会抛出异常，如果没有需要等待的时候就已经加载完毕就会立即执行<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 设置隐式等待</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h4><p>指定一个等待条件，并且指定一个最长等待时间，会在这个时间内进行判断是否满足等待条件，如果成立就会立即返回，如果不成立，就会一直等待，直到等待你指定的最长等待时间，如果还是不满足，就会抛出异常，如果满足了就会正常返回</p><p><strong>常用的判断条件</strong>：</p><ul><li><code>title_is</code> 标题是某内容</li><li><code>title_contains</code> 标题包含某内容</li><li><code>presence_of_element_located</code> 元素加载出，传入定位元组，如(By.ID, ‘p’)</li><li><code>visibility_of_element_located</code> 元素可见，传入定位元组</li><li><code>visibility_of</code> 可见，传入元素对象</li><li><code>presence_of_all_elements_located</code> 所有元素加载出</li><li><code>text_to_be_present_in_element</code> 某个元素文本包含某文字</li><li><code>text_to_be_present_in_element_value</code> 某个元素值包含某文字</li><li><code>frame_to_be_available_and_switch_to_it</code> frame加载并切换</li><li><code>invisibility_of_element_located</code> 元素不可见</li><li><code>element_to_be_clickable</code> 元素可点击</li><li><code>staleness_of</code> 判断一个元素是否仍在DOM，可判断页面是否已经刷新</li><li><code>element_to_be_selected</code> 元素可选择，传元素对象</li><li><code>element_located_to_be_selected</code> 元素可选择，传入定位元组</li><li><code>element_selection_state_to_be</code> 传入元素对象以及状态，相等返回True，否则返回False</li><li><code>element_located_selection_state_to_be</code> 传入定位元组以及状态，相等返回True，否则返回False</li><li><code>alert_is_present</code> 是否出现Alert</li></ul><p>实例讲解，以来自<a href="https://www.cnblogs.com/yuuwee/p/6635652.html" target="_blank" rel="noopener">这篇文章</a>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"><span class="comment"># 定义等待时间，这是隐式等待，当隐式等待和显示等待都存在时，超时时间取二者中较大的，显示等待是sleep(10)这种</span></span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="comment"># 定义查找位置</span></span><br><span class="line">locator = (By.ID,<span class="string">'kw'</span>)</span><br><span class="line">driver.get(base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断title,返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.title_is(<span class="string">u"百度一下，你就知道"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断title，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.title_contains(<span class="string">u"百度一下"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被加到了dom树里，并不代表该元素一定可见，如果定位到就返回WebElement</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.presence_of_element_located((By.ID,<span class="string">'kw'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被添加到了dom里并且可见，可见代表元素可显示且宽和高都大于0</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of_element_located((By.ID,<span class="string">'su'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否可见，如果可见就返回这个元素</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of(driver.find_element(by=By.ID,value=<span class="string">'kw'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否至少有1个元素存在于dom树中，如果定位到就返回列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.presence_of_all_elements_located((By.CSS_SELECTOR,<span class="string">'.mnav'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否至少有一个元素在页面中可见，如果定位到就返回列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.visibility_of_any_elements_located((By.CSS_SELECTOR,<span class="string">'.mnav'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定的元素中是否包含了预期的字符串，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.text_to_be_present_in_element((By.XPATH,<span class="string">"//*[@id='u1']/a[8]"</span>),<span class="string">u'设置'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定元素的属性值中是否包含了预期的字符串，返回布尔值</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.text_to_be_present_in_element_value((By.CSS_SELECTOR,<span class="string">'#su'</span>),<span class="string">u'百度一下'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False，注意这里并没有一个frame可以切换进去</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.frame_to_be_available_and_switch_to_it(locator))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素在是否存在于dom或不可见,如果可见返回False,不可见返回这个元素，注意#swfEveryCookieWrap在此页面中是一个隐藏的元素</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.invisibility_of_element_located((By.CSS_SELECTOR,<span class="string">'#swfEveryCookieWrap'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素中是否可见并且是enable的，代表可点击</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_clickable((By.XPATH,<span class="string">"//*[@id='u1']/a[8]"</span>))).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='wrapper']/div[6]/a[1]"</span>).click()</span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_clickable((By.XPATH,<span class="string">"//*[@id='wrapper']/div[6]/a[1]"</span>))).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待某个元素从dom树中移除，这里没有找到合适的例子</span></span><br><span class="line"><span class="comment">#WebDriverWait(driver,10).until(EC.staleness_of(driver.find_element(By.ID,'su')))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素是否被选中了,一般用在下拉列表</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_to_be_selected(driver.find_element(By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素的选中状态是否符合预期</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_selection_state_to_be(driver.find_element(By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>),<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个元素的选中状态是否符合预期</span></span><br><span class="line">WebDriverWait(driver,<span class="number">10</span>).until(EC.element_located_selection_state_to_be((By.XPATH,<span class="string">"//*[@id='nr']/option[1]"</span>),<span class="keyword">True</span>))</span><br><span class="line">driver.find_element_by_xpath(<span class="string">".//*[@id='gxszButton']/a[1]"</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断页面上是否存在alert,如果有就切换到alert并返回alert的内容</span></span><br><span class="line">instance = WebDriverWait(driver,<span class="number">10</span>).until(EC.alert_is_present())</span><br><span class="line"><span class="keyword">print</span> instance.text</span><br><span class="line">instance.accept()</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>关于显式等待和隐式等待具体的讲解可以参考<a href="https://www.jianshu.com/p/bf27aad96614" target="_blank" rel="noopener">这篇文章</a></strong></li><li><strong><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions" target="_blank" rel="noopener">更多操作</a></strong>参考</li></ul><hr><h3 id="浏览器的前进和后退"><a href="#浏览器的前进和后退" class="headerlink" title="浏览器的前进和后退"></a>浏览器的前进和后退</h3><ul><li><code>back()</code></li><li><code>forward()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.python.org/'</span>)</span><br><span class="line"></span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><hr><h3 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h3><ul><li><code>get_cookies()</code></li><li><code>delete_all_cookes()</code></li><li><code>add_cookie()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'zhaofan'</span>&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure><hr><h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><ul><li>通过执行js命令实现新开选项卡<code>window.open()</code></li><li>不同的选项卡是存在列表里<code>browser.window_handles</code></li><li>通过<code>browser.window_handles[0]</code>就可以操作第一个选项卡</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line"></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常比较复杂，<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions" target="_blank" rel="noopener">官网的参考地址</a>，这里只进行简单的演示，查找一个不存在的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    print(<span class="string">'Time Out'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Element'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong>无界面模式浏览器</strong>：</p><blockquote><p>opt=webdriver.ChromeOptions()<br># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数<br>opt.set_headless()#无界面<br>self.driver=webdriver.Chrome(options=opt)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span>  webdriver</span><br><span class="line"><span class="keyword">import</span>  lxml</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span>  etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span>  pymysql</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span>  WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span>  expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span>  By</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LagouSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        opt=webdriver.ChromeOptions()</span><br><span class="line">        <span class="comment"># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数</span></span><br><span class="line">        opt.set_headless()<span class="comment">#无界面</span></span><br><span class="line">        self.driver=webdriver.Chrome(options=opt)</span><br><span class="line">        self.url=<span class="string">"https://www.lagou.com/zhaopin/Python/"</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.driver.get(self.url)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            source = self.driver.page_source</span><br><span class="line">            <span class="comment">#此句话大致意思，执行driver 时间不超过20s 什么时候加载到xpath定位的位置神魔时候停止开始执行页面 内容爬去</span></span><br><span class="line">            WebDriverWait(driver=self.driver,timeout=<span class="number">20</span>).until(EC.presence_of_all_elements_located(By.XPATH,<span class="string">'//*[@id="s_position_list"]/div[2]/div/a[6]'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># WebDriverWait(driver=self.driver, timeout=20).until(</span></span><br><span class="line">            <span class="comment">#     EC.presence_of_element_located((By.XPATH, '//*[@id="s_position_list"]/div[2]/div/a[6]'))</span></span><br><span class="line">            <span class="comment"># )</span></span><br><span class="line">            self.parse_list_page(source)</span><br><span class="line">            <span class="comment"># 点“下一页”</span></span><br><span class="line">            next_btn=self.driver.find_element_by_xpath(  <span class="string">'//*[@id="s_position_list"]/div[2]/div/a[6]'</span>)</span><br><span class="line">            <span class="comment"># 提取下一页的按钮，注意class的值中有空格不可用。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"pager_next_disabled"</span> <span class="keyword">in</span> next_btn.get_attribute(<span class="string">"class"</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_btn.click()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># next_btn = self.driver.find_element_by_xpath(</span></span><br><span class="line">            <span class="comment">#      '//*[@id="s_position_list"]/div[2]/div/a[6]')</span></span><br><span class="line">            <span class="comment"># if "pager_next_disabled" in next_btn.get_attribute("class"):</span></span><br><span class="line">            <span class="comment">#     break</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     next_btn.click()</span></span><br><span class="line">            <span class="comment"># time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># source=self.driver.page_source</span></span><br><span class="line">        <span class="comment"># #print(source)</span></span><br><span class="line">        <span class="comment"># self.parse_list_page(source)</span></span><br><span class="line">    <span class="comment">#职位url列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_list_page</span><span class="params">(self,source)</span>:</span></span><br><span class="line">        <span class="comment">#t通过etree调用xpath</span></span><br><span class="line">        html=etree.HTML(source)</span><br><span class="line">        links=html.xpath(<span class="string">'//*[@id="s_position_list"]/ul/li/div[1]/div[1]/div[1]/a/@href'</span>)</span><br><span class="line">        <span class="keyword">for</span>  link <span class="keyword">in</span> links:</span><br><span class="line">            self.request_detail_page(link)</span><br><span class="line">            <span class="comment"># print(link)</span></span><br><span class="line">            <span class="comment">#time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行提取的url</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_detail_page</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        <span class="comment">#self.driver.get(url)</span></span><br><span class="line">        <span class="comment">#打开新的页面</span></span><br><span class="line">        self.driver.execute_script(<span class="string">"window.open('%s')"</span>%url)</span><br><span class="line">        <span class="comment">#切换句柄进入新打开的页面</span></span><br><span class="line">        self.driver.switch_to.window((self.driver.window_handles[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># self.driver.execute_script("window.open('%s')" % url)</span></span><br><span class="line">        <span class="comment"># self.driver.switch_to.window(self.driver.window_handles[1])</span></span><br><span class="line">        <span class="comment">#加载出来工作名开始爬取</span></span><br><span class="line">        WebDriverWait(driver=self.driver, timeout=<span class="number">20</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">"//div[@class='job-name']/span[@class='name']"</span>)) )</span><br><span class="line"></span><br><span class="line">        source=self.driver.page_source</span><br><span class="line">        self.parse_detail_page(source)</span><br><span class="line">        <span class="comment"># 关闭当前详情页，并且切换到列表页</span></span><br><span class="line">        self.driver.close()</span><br><span class="line">        self.driver.switch_to.window(self.driver.window_handles[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#self.parse_list_page(source)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#提取具体信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_detail_page</span><span class="params">(self,source)</span>:</span></span><br><span class="line">        html=etree.HTML(source)</span><br><span class="line">        positionName=html.xpath(<span class="string">"//div[@class='position-head']/div/div[1]/div/span/text()"</span>)[<span class="number">0</span>]</span><br><span class="line">        job_request_spans=html.xpath(<span class="string">"//div[@class='position-head']/div/div[1]/dd/p[1]/span"</span>)</span><br><span class="line">        salary=job_request_spans[<span class="number">0</span>].xpath(<span class="string">".//text()"</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        city=job_request_spans[<span class="number">1</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="comment">#city = re.match(r'&lt;span class="xh-highlight"&gt;/(.*?) /&lt;/span&gt;',city)</span></span><br><span class="line">        city = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, city)<span class="comment">#此处将"/"替换为空""</span></span><br><span class="line">        work_years = job_request_spans[<span class="number">2</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        work_years = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, work_years)</span><br><span class="line">        education = job_request_spans[<span class="number">3</span>].xpath(<span class="string">'.//text()'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        education = re.sub(<span class="string">r"[\s/]"</span>, <span class="string">""</span>, education)</span><br><span class="line">        content = <span class="string">""</span>.join(html.xpath(<span class="string">"//dd[@class='job_bt']//text()"</span>)).strip()</span><br><span class="line">        <span class="comment">#print(positionName)</span></span><br><span class="line">        <span class="comment">#mysql=MySQLPipeline()</span></span><br><span class="line">        <span class="comment">#mysql.process_item(positionName,salary,city,work_years,education,content)</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        语法：  'sep'.join(seq)</span></span><br><span class="line"><span class="string">        参数说明</span></span><br><span class="line"><span class="string">        sep：分隔符。可以为空</span></span><br><span class="line"><span class="string">        seq：要连接的元素序列、字符串、元组、字典</span></span><br><span class="line"><span class="string">        上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串</span></span><br><span class="line"><span class="string">        返回值：返回一个以分隔符sep连接各个元素后生成的字符串</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">"root"</span>,db=<span class="string">"lagou"</span>, charset=<span class="string">'utf8'</span>)</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self,positionName,salary,city,work_years,education,content)</span>:</span></span><br><span class="line">        insert_sql = <span class="string">'''</span></span><br><span class="line"><span class="string">                    insert into lagou_table(positionName,salary,city,work_years,education,content)</span></span><br><span class="line"><span class="string">                    values(%s,%s,%s,%s,%s,%s)</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">        self.cursor.execute(insert_sql,(positionName,salary,city,work_years,education,content))</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span> <span class="comment">#TypeError: close_spider() takes 1 positional argument but 2 were given</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    spider=LagouSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/zhaof/p/6953241.html" target="_blank" rel="noopener">本文框架来源</a></li><li><a href="https://www.cnblogs.com/yuuwee/p/6635652.html" target="_blank" rel="noopener">显示等待WebDriverWait与条件判断expected_conditions实例</a></li><li><a href="https://blog.csdn.net/work_you_will_see/article/details/84638750" target="_blank" rel="noopener">实战项目来源</a></li><li><a href="https://www.jianshu.com/p/bf27aad96614" target="_blank" rel="noopener">Selenium中的“显示等待”和“隐式等待”</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之logging-日志</title>
      <link href="/posts/56982.html"/>
      <url>/posts/56982.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章依照<a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">这篇博客</a>对Python的常用模块logging进行了学习，主要学习了<code>日志的作用</code>、<code>不同开发环境设置不同的日志输出</code>、<code>使用logging模块的日志级别函数直接记录日志</code>；也学习了logging模块的<strong>高级用法</strong>，包括<strong>使用logging模块的四大组件进行日志记录(主要用于满足多种需求，如将结果同时输出到文件和屏幕)</strong>、配置logging的几种方式、向日志输出上下文信息等；最后也总结了一些<strong>实战技巧</strong>。</p></div><a id="more"></a><h2 id="日志相关概念"><a href="#日志相关概念" class="headerlink" title="日志相关概念"></a>日志相关概念</h2><p>日志是一种可以<strong>追踪某些软件运行时所发生事件的方法</strong>。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有<strong>重要性</strong>的概念，这个重要性也可以被称为严重性级别（level）。</p><h3 id="日志的作用"><a href="#日志的作用" class="headerlink" title="日志的作用"></a>日志的作用</h3><p>通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。<br><strong>简单来讲就是</strong>，我们通过记录和分析日志可以了解一个系统或软件程序<strong>运行情况是否正常</strong>，也可以<strong>在应用程序出现故障时快速定位问题</strong>。比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。日志的作用可以<strong>简单总结</strong>为以下3点：</p><ul><li><strong>程序调试</strong></li><li><strong>了解软件程序运行情况，是否正常</strong></li><li><strong>软件程序运行故障分析与问题定位</strong></li></ul><p>如果应用的日志信息足够详细和丰富，还可以<strong>用来做用户行为分析</strong>，如：分析用户的操作行为、类型喜好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。</p><hr><h3 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h3><p>我们先来思考下下面的两个问题：</p><ul><li>作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？</li><li>作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？</li></ul><p>在<strong>软件开发阶段或部署开发环境</strong>时，为了<strong>尽可能详细</strong>的查看应用程序的运行状态来<strong>保证上线后的稳定性</strong>，我们可能<strong>需要把该应用程序所有的运行日志全部记录下来进行分析</strong>，<u>这是非常耗费机器性能的</u>。当<strong>应用程序正式发布或在生产环境部署应用程序</strong>时，我们通常<strong>只需要记录应用程序的异常信息、错误信息</strong>等，这样既可以减小服务器的<code>I/O</code>压力，也可以避免我们在排查故障时被淹没在日志的海洋里。那么，<mark><strong>怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？</strong>这就是<strong>日志等级</strong>的作用了，我们<strong>通过配置文件指定我们需要的日志等级就可以了</strong></mark>。</p><p>不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级(具体的级别高低在后面会有讲解)：</p><ul><li>DEBUG</li><li>INFO</li><li>NOTICE</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>ALERT</li><li>EMERGENCY</li></ul><hr><h3 id="日志字段信息与日志格式"><a href="#日志字段信息与日志格式" class="headerlink" title="日志字段信息与日志格式"></a>日志字段信息与日志格式</h3><p>本节开始问题提到过，<strong>一条日志信息对应的是一个事件的发生</strong>，而<strong>一个事件通常需要包括以下几个内容</strong>：</p><ul><li>事件发生<strong>时间</strong></li><li>事件发生<strong>位置</strong></li><li>事件的<strong>严重程度–日志级别</strong></li><li>事件<strong>内容</strong></li></ul><p>上面这些都是一条日志记录中可能包含的字段信息，当然<strong>还可以包括</strong>一些其他信息，如<code>进程ID</code>、<code>进程名称</code>、<code>线程ID</code>、<code>线程名称</code>等。<strong>日志格式</strong>就是用来定义一条日志记录中包含哪些字段的，且日志格式通常都是可以自定义的。</p><div class="note info"><p>输出一条日志时，<strong>日志内容</strong>和<strong>日志级别</strong>是<strong>需要开发人员明确指定的(必须的)</strong>。对于而其它字段信息，只需要是否显示在日志中就可以了。</p></div><h3 id="日志功能的实现"><a href="#日志功能的实现" class="headerlink" title="日志功能的实现"></a>日志功能的实现</h3><p>几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：<code>log4j</code>，<code>log4php</code>等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块–<code>logging</code>。</p><hr><p><br></p><h2 id="logging模块简介"><a href="#logging模块简介" class="headerlink" title="logging模块简介"></a>logging模块简介</h2><p><code>logging</code>模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。<code>logging</code>模块是Python的一个<strong>标准库模块</strong>，<strong>由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能</strong>。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><h3 id="logging模块的日志级别"><a href="#logging模块的日志级别" class="headerlink" title="logging模块的日志级别"></a>logging模块的日志级别</h3><p>logging模块默认定义了以下几个日志等级，它<strong>允许开发人员自定义其他日志级别</strong>，但是这是<strong>不被推荐的</strong>，尤其是在开发供别人使用的库时，因为这<strong>会导致日志级别的混乱</strong>。</p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>日志等级</th><th>数值</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>10</td><td><strong>最详细</strong>的日志信息，典型应用场景是<strong>问题诊断</strong></td></tr><tr><td>INFO</td><td>20</td><td>信息详细程度仅次于DEBUG，通常<strong>只记录关键节点信息</strong>，用于<strong>确认一切都是按照我们预期的那样进行工作</strong></td></tr><tr><td>WARNING</td><td>30</td><td>当<strong>某些不期望的事情发生</strong>时记录的信息（如，磁盘可用空间较低），但是<strong>此时应用程序还是正常运行</strong>的</td></tr><tr><td>ERROR</td><td>40</td><td>由于一个更严重的问题<strong>导致某些功能不能正常运行</strong>时记录的信息</td></tr><tr><td>CRITICAL</td><td>50</td><td>当发生严重错误，<strong>导致应用程序不能继续运行</strong>时记录的信息</td></tr></tbody></table><div class="note info"><ul><li>上面列表中的<strong>日志等级是从上到下依次升高(按照数值的大小排序)</strong>的，即：<code>DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</code>，而<strong>日志的信息量是依次减少的</strong>；</li><li><p><code>logging</code>模块<strong>可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃</strong>；</p></li><li><p><strong>开发应用程序或部署开发环境</strong>时，可以使用<code>DEBUG</code>或<code>INFO</code>级别的日志获取<strong>尽可能详细</strong>的日志信息来进行开发或部署调试；</p></li><li><strong>应用上线或部署生产环境</strong>时，应该使用<code>WARNING</code>或<code>ERROR</code>或<code>CRITICAL</code>级别的日志来降低机器的<code>I/O</code>压力和提高获取错误日志信息的效率；</li><li><strong>日志级别的指定通常都是在应用程序的配置文件中进行的</strong>。</li></ul></div><hr><h3 id="logging模块的使用方式介绍"><a href="#logging模块的使用方式介绍" class="headerlink" title="logging模块的使用方式介绍"></a>logging模块的使用方式介绍</h3><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是<strong>使用logging提供的日志级别的函数</strong></li><li>第二种方式是<strong>使用Logging日志系统的四大组件</strong></li></ul><p>其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已</p><h4 id="logging模块定义的日志级别的常用函数"><a href="#logging模块定义的日志级别的常用函数" class="headerlink" title="logging模块定义的日志级别的常用函数:"></a>logging模块定义的日志级别的常用函数:</h4><table><tr><th width="40%">函数</th><th width="60%">说明</th></tr><tr><td><code>logging.debug(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>DEBUG</code>的日志记录</td></tr><tr><td><code>logging.info(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>INFO</code>的日志记录</td></tr><tr><td><code>logging.warning(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>WARNING</code>的日志记录</td></tr><tr><td><code>logging.error(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>ERROR</code>的日志记录</td></tr><tr><td><code>logging.critical(msg, *args, **kwargs)</code></td><td>创建一条级别为<code>CRITICAL</code>的日志记录</td></tr><tr><td><code>logging.log(level, *args, **kwargs)</code></td><td>创建一条级别为<code>level</code>的日志记录</td></tr><tr><td><code>logging.basicConfig(**kwargs)</code></td><td>对<code>root logger</code>进行一次性配置</td></tr></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定<code>要记录的日志级别</code>、<code>日志格式</code>、<code>日志输出位置</code>、<code>日志文件的打开模式</code>等信息，<strong>其他几个都是用于记录各个级别日志的函数</strong>。</p><hr><h4 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h4><table><tr><th width="20%">组件</th><th width="80%">说明</th></tr><tr><td><code>loggers</code></td><td>提供应用程序代码直接使用的接口</td></tr><tr><td><code>handlers</code></td><td>用于将日志记录发送到指定的目的位置</td></tr><tr><td><code>filters</code></td><td>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）</td></tr><tr><td><code>formatters</code></td><td>用于控制日志信息的最终输出格式</td></tr></table><div class="note info"><p>logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。</p></div><hr><p><br></p><h2 id="使用日志级别函数记录日志"><a href="#使用日志级别函数记录日志" class="headerlink" title="使用日志级别函数记录日志"></a>使用日志级别函数记录日志</h2><p>回顾下前面提到的<strong>几个重要信息</strong>：</p><ul><li>可以通过logging模块定义的日志级别方法去完成简单的日志记录</li><li><strong>只有级别大于或等于日志记录器指定级别的日志记录才会被输出，小于该级别的日志记录将会被丢弃</strong></li></ul><h3 id="最简单的日志输出"><a href="#最简单的日志输出" class="headerlink" title="最简单的日志输出"></a>最简单的日志输出</h3><p><strong>使用各种具体级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>也可以使用统一设置级别的函数</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.log(logging.DEBUG, <span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.log(logging.INFO, <span class="string">"This is a info log."</span>)</span><br><span class="line">logging.log(logging.WARNING, <span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.log(logging.ERROR, <span class="string">"This is a error log."</span>)</span><br><span class="line">logging.log(logging.CRITICAL, <span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br><span class="line">================================</span><br><span class="line">WARNING:root:This <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:This <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:This <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><p>第二种写法显然没有第一种写法简单，以后还是使用第一种写法吧</p><h3 id="简单日志输出的结果分析"><a href="#简单日志输出的结果分析" class="headerlink" title="简单日志输出的结果分析"></a>简单日志输出的结果分析</h3><h4 id="为什么前面两条日志没有被打印出来？"><a href="#为什么前面两条日志没有被打印出来？" class="headerlink" title="为什么前面两条日志没有被打印出来？"></a>为什么前面两条日志没有被打印出来？</h4><p>这是因为logging模块提供的日志记录函数所使用的日志器设置的日志级别是<code>WARNING</code>(<strong>logging的默认日志级别是warning</strong>)，因此只有<code>WARNING</code>级别的日志记录以及<strong>大于等于</strong>它的<code>ERROR</code>和<code>CRITICAL</code>级别的日志记录<strong>被输出</strong>了，而<strong>小于</strong>它的<code>DEBUG</code>和<code>INFO</code>级别的日志记录<strong>被丢弃</strong>了。</p><hr><h4 id="日志信息中各字段含义？为什么会这样输出？"><a href="#日志信息中各字段含义？为什么会这样输出？" class="headerlink" title="日志信息中各字段含义？为什么会这样输出？"></a>日志信息中各字段含义？为什么会这样输出？</h4><p>上面输出结果中每行日志记录的各个字段含义分别是：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志级别:日志器名称:日志内容</span><br></pre></td></tr></table></figure><p></p><p>之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器<strong>设置的日志格式默认是<code>BASIC_FORMAT</code></strong>，其值为：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="如果将日志记录输出到文件中，而不是打印到控制台？"><a href="#如果将日志记录输出到文件中，而不是打印到控制台？" class="headerlink" title="如果将日志记录输出到文件中，而不是打印到控制台？"></a>如果将日志记录输出到文件中，而不是打印到控制台？</h4><p>因为在logging模块提供的日志记录函数所使用的日志器设置的处理器所<strong>指定的日志输出位置默认为:<code>sys.stderr</code>.</strong></p><hr><h4 id="我是怎么知道这些的？"><a href="#我是怎么知道这些的？" class="headerlink" title="我是怎么知道这些的？"></a>我是怎么知道这些的？</h4><p><strong>查看这些日志记录函数的实现代码</strong>，可以发现：当我们<strong>没有提供任何配置信息的时候</strong>，这些函数都会去调用<code>logging.basicConfig(**kwargs)</code>方法，且不会向该方法传递任何参数。继续<strong>查看<code>basicConfig()</code>方法的代码</strong>就可以找到上面这些问题的答案了。</p><p><strong>查看源码</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先导入模块</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">help(logging.basicConfig)</span><br><span class="line"></span><br><span class="line">The default behaviour <span class="keyword">is</span> to create a StreamHandler which writes to sys.stderr, set a formatter using the BASIC_FORMAT format string, <span class="keyword">and</span> add the handler to the root logger.</span><br><span class="line"></span><br><span class="line">BASIC_FORMAT = <span class="string">"%(levelname)s:%(name)s:%(message)s"</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="怎么修改这些默认设置呢？"><a href="#怎么修改这些默认设置呢？" class="headerlink" title="怎么修改这些默认设置呢？"></a>怎么修改这些默认设置呢？</h4><p>其实很简单，在我们<strong>调用上面这些日志记录函数之前</strong>，<strong>手动调用一下<code>basicConfig()</code>方法</strong>，把我们<strong>想设置的内容以参数的形式传递进去就可以了</strong>。</p><hr><h3 id="logging-basicConfig-函数说明"><a href="#logging-basicConfig-函数说明" class="headerlink" title="logging.basicConfig()函数说明"></a>logging.basicConfig()函数说明</h3><p>经过上述对简单日志输出的结果分析，发现如果我们想修改输出的信息(默认设置)就需要在调用日志记录函数之前，手动调用一下<code>basicConfig()</code>方法，所以这里来对<code>logging.basicConfig()</code>函数进行一定的学习。该方法用于为logging日志系统做一些基本配置，方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure><p></p><p><strong>该函数可接收的关键字参数</strong>如下：</p><table><tr><th width="20%">参数名称</th><th width="80%">描述</th></tr><tr><td><code>filename</code></td><td><strong>指定日志输出目标文件的文件名</strong>，指定该设置项后日志信息就不会被输出到控制台了</td></tr><tr><td><code>filemode</code></td><td>指定日志文件的打开模式，默认为<code>a</code>。需要注意的是，<strong>该选项要在filename指定时才有效</strong></td></tr><tr><td><code>format</code></td><td>指定日志格式字符串，即<strong>指定日志输出时所包含的字段信息以及它们的顺序</strong>。logging模块定义的格式字段下面会列出。</td></tr><tr><td><code>datefmt</code></td><td>指定日期/时间格式。需要注意的是，该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></td></tr><tr><td><code>level</code></td><td><strong>指定日志器的日志级别</strong></td></tr><tr><td><code>stream</code></td><td>指定日志输出目标stream，如<code>sys.stdout</code>、<code>sys.stderr</code>以及网络stream。需要说明的是，<strong>stream和filename不能同时提供，否则会引发 ValueError异常</strong></td></tr><tr><td><code>style</code></td><td>Python 3.2中新添加的配置项。<strong>指定format格式字符串的风格<strong>，可取值为<code>%</code>、<code>{</code>和<code>$</code>，默认为<code>%</code></strong></strong></td></tr><tr><td><code>handlers</code></td><td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：<strong>filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常</strong>。</td></tr></table><hr><h3 id="格式字符串字段-format"><a href="#格式字符串字段-format" class="headerlink" title="格式字符串字段(format)"></a>格式字符串字段(format)</h3><p>这里列出了<code>logging.basicConfig()</code>函数中的日志格式字符串(format)包含的字段：</p><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的<strong>时间</strong>–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–<strong>时间戳</strong>，就是当时调用<code>time.time()</code>函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的<strong>相对毫秒数</strong>（目前还不知道干嘛用的）</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的<strong>毫秒部分</strong></td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的<strong>文字形式的日志级别(‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’)</strong></td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的<strong>数字形式的日志级别(10, 20, 30, 40, 50)</strong></td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的<strong>日志器名称</strong>，<strong>默认是’root’，因为默认使用的是 rootLogger</strong></td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 <code>msg % args</code>计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td><strong>调用日志记录函数的源码文件的全路径</strong></td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的<strong>文件名部分，包含文件后缀</strong></td></tr><tr><td>module</td><td>%(module)s</td><td>filename的<strong>名称部分，不包含后缀</strong></td></tr><tr><td>lineno</td><td>%(lineno)d</td><td><strong>调用日志记录函数的源代码所在的行号</strong></td></tr><tr><td>funcName</td><td>%(funcName)s</td><td><strong>调用日志记录函数的函数名</strong></td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><div class="note info"><p>定义format的形式：<code>BASIC_FORMAT = &quot;%(levelname)s:%(name)s:%(message)s&quot;</code>这是官方的默认形式，不同字段间使用<code>:</code>分割，分割符可以自定义</p></div><hr><h3 id="自定义输出日志信息"><a href="#自定义输出日志信息" class="headerlink" title="自定义输出日志信息"></a>自定义输出日志信息</h3><h4 id="level-自定义日志级别"><a href="#level-自定义日志级别" class="headerlink" title="level-自定义日志级别"></a>level-自定义日志级别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"=====change level====="</span>)</span><br><span class="line"><span class="comment">## 自定义日志器的日志级别</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p>输出信息：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====change level=====</span><br><span class="line">DEBUG:root:this <span class="keyword">is</span> a debug log.</span><br><span class="line">INFO:root:this <span class="keyword">is</span> a info log.</span><br><span class="line">WARNING:root:this <span class="keyword">is</span> a warning log.</span><br><span class="line">ERROR:root:this <span class="keyword">is</span> a error log.</span><br><span class="line">CRITICAL:root:this <span class="keyword">is</span> a critical log.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="filename-amp-format-设置日志输出目标文件和日志格式"><a href="#filename-amp-format-设置日志输出目标文件和日志格式" class="headerlink" title="filename &amp; format-设置日志输出目标文件和日志格式"></a>filename &amp; format-设置日志输出目标文件和日志格式</h4><ul><li><code>filename</code>：指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了</li><li><code>format</code>：指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。<ul><li><code>%(asctime)s</code>：日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</li><li><code>%(levelname)s</code>：该日志记录的文字形式的日志级别<code>(&#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARNING&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;)</code></li><li><code>%(message)s</code>：日志记录的文本内容，通过 <code>msg % args</code>计算得到的</li></ul></li></ul><p><strong>示例代码如下</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"=====change out file and format====="</span>)</span><br><span class="line"><span class="comment"># 设置输出的format，中间的字段分隔符可以自定义</span></span><br><span class="line">LOG_FORMAT=<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line"><span class="comment"># 设置日志输出文件名以及format</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>,level=logging.DEBUG,format=LOG_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"this is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"this is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"this is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"this is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"this is a critical log."</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="datefmt-设置日期-时间格式"><a href="#datefmt-设置日期-时间格式" class="headerlink" title="datefmt-设置日期/时间格式"></a>datefmt-设置日期/时间格式</h4><ul><li>时间格式同<code>time.strftime()</code>，具体信息可以本文最后的补充信息</li><li>该选项要<strong>在format中包含时间字段%(asctime)s时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  2019-03-23 00:01:29,910 - DEBUG - this is a debug <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - INFO - this is a info <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - WARNING - this is a warning <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - ERROR - this is a error <span class="built_in">log</span>.</span><br><span class="line">  2019-03-23 00:01:29,910 - CRITICAL - this is a critical <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:18:15 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>从上面输出结果可以发现，前面几行是上一步生成的日志文件，下面几行是这步生成的文件，这是因为<strong>默认的<code>filemode</code>是<code>a</code>也就是追加的意思，所以没有清空原始文件的信息</strong>。</p><hr><h4 id="filemode-指定日志文件的打开模式"><a href="#filemode-指定日志文件的打开模式" class="headerlink" title="filemode-指定日志文件的打开模式"></a>filemode-指定日志文件的打开模式</h4><ul><li>该选项默认为<code>a</code></li><li>需要注意的是，<strong>该选项要在filename指定时才有效</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件打开模式更改为w，如果存在就清空然后写入，如果不存在就创建</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'my.log'</span>, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT,filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"This is a debug log."</span>)</span><br><span class="line">logging.info(<span class="string">"This is a info log."</span>)</span><br><span class="line">logging.warning(<span class="string">"This is a warning log."</span>)</span><br><span class="line">logging.error(<span class="string">"This is a error log."</span>)</span><br><span class="line">logging.critical(<span class="string">"This is a critical log."</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat my.log</span><br><span class="line">  03/23/2019 00:23:36 AM - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - INFO - This is a info <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - WARNING - This is a warning <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - ERROR - This is a error <span class="built_in">log</span>.</span><br><span class="line">  03/23/2019 00:23:36 AM - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p></p><p>可以发现前一步的输出结果已经被覆盖掉了，只生成了这一步的输出结果。</p><hr><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><h4 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h4><ul><li><code>logging.basicConfig()</code>函数是一个<strong>一次性的简单配置工具</strong>，也就是说<strong>只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作</strong></li><li><strong>日志器（Logger）是有层级关系的</strong>，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为<code>root</code>，它是<strong>处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的</strong></li><li>如果要记录的<strong>日志中包含变量数据</strong>，<strong>可使用一个格式字符串</strong>作为这个事件的描述消息(<code>logging.debug</code>、<code>logging.info</code>等函数的第一个参数)，然后将变量数据作为第二个参数<code>*args</code>的值进行传递，如:<code>logging.warning(&#39;%s is %d years old.&#39;, &#39;Tom&#39;, 10)</code>，输出内容为<code>WARNING:root:Tom is 10 years old.</code>.</li></ul><hr><h4 id="日志级别方法参数的补充说明"><a href="#日志级别方法参数的补充说明" class="headerlink" title="日志级别方法参数的补充说明"></a>日志级别方法参数的补充说明</h4><ul><li><code>logging.debug()</code>, <code>logging.info()</code>等方法的定义中，除了<code>msg</code>和<code>args</code>参数外，还有一个<code>**kwargs</code>参数。它们<strong>支持3个关键字参数</strong>: <code>exc_info</code>、<code>stack_info</code>、<code>extra</code>，下面对这几个关键字参数作个说明:</li><li><code>exc_info</code>：其值为<strong>布尔值</strong>，如果该参数的值设置为<strong>True</strong>，则会<strong>将异常信息添加到日志消息中</strong>；如果<strong>没有异常信息则添加None到日志信息</strong>中</li><li><code>stack_info</code>：其值也为<strong>布尔值</strong>，<strong>默认值为False</strong>。如果该参数的值设置为<strong>True</strong>，<strong>栈信息将会被添加到日志信息中，相当于是哪一行输入了这个log信息</strong></li><li><code>extra</code>：这是一个<strong>字典（dict）参数</strong>，它可以用来<strong>自定义消息格式中所包含的字段</strong>，但是<strong>它的<code>key</code>不能与logging模块定义的字段冲突</strong></li></ul><p><strong>示例</strong>：<br>在日志消息中添加<code>exc_info</code>和<code>stack_info</code>信息，并添加<strong>两个自定义的字端</strong><code>ip</code>和<code>user</code>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOG_FORMAT = <span class="string">"%(asctime)s - %(levelname)s - %(user)s[%(ip)s] - %(message)s"</span></span><br><span class="line">DATE_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S %p"</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=LOG_FORMAT, datefmt=DATE_FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置exc_info、stack_info、extra参数</span></span><br><span class="line">logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=<span class="keyword">True</span>, stack_info=<span class="keyword">True</span>, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03/23/2019 09:28:06 AM - WARNING - Tom[47.98.53.222] - Some one delete the <span class="built_in">log</span> file.</span><br><span class="line">NoneType: None</span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">"logging_learn.py"</span>, line 75, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    logging.warning(<span class="string">"Some one delete the log file."</span>, exc_info=True, stack_info=True, extra=&#123;<span class="string">'user'</span>: <span class="string">'Tom'</span>, <span class="string">'ip'</span>:<span class="string">'47.98.53.222'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="日志模块四大组件以及日志流处理流程"><a href="#日志模块四大组件以及日志流处理流程" class="headerlink" title="日志模块四大组件以及日志流处理流程"></a>日志模块四大组件以及日志流处理流程</h2><p>在介绍logging模块的<strong>高级用法</strong>之前，很有必要对logging模块所包含的<strong>重要组件以及其工作流程做个全面、简要的介绍</strong>，这有助于我们更好的理解我们所写的代码（将会触发什么样的操作）。</p><h3 id="日志模块四大组件"><a href="#日志模块四大组件" class="headerlink" title="日志模块四大组件"></a>日志模块四大组件</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块日志级别的函数也是通过这些组件对应的类来实现的。</p><hr><h3 id="四大组件之间的关系"><a href="#四大组件之间的关系" class="headerlink" title="四大组件之间的关系"></a>四大组件之间的关系</h3><ul><li><strong>日志器(logger)需要通过处理器(handler)将日志信息输出到目标位置</strong>，如：文件、<code>sys.stdout</code>、网络等；</li><li>不同的<strong>处理器(handler)可以将日志输出到不同的位置</strong>；</li><li>日志器(logger)可以设置<strong>多个</strong>处理器(handler)将<strong>同一条</strong>日志记录输出到<strong>不同的位置</strong>；</li><li>每个<strong>处理器(handler)</strong>都可以<strong>设置自己的过滤器(filter)实现日志过滤</strong>，从而只保留感兴趣的日志；</li><li>每个<strong>处理器(handler)</strong>都可以设<strong>置自己的格式器(formatter)</strong>实现同一条日志<strong>以不同的格式输出到不同的地方</strong>。</li></ul><p>简单点说就是：<mark>日志器(logger)是入口，真正干活儿的是处理器(handler)，处理器(handler)还可以通过过滤器(filter)和格式器(formatter)对要输出的日志内容做过滤和格式化等处理操作。</mark></p><hr><h3 id="组件相关类与常用方法介绍"><a href="#组件相关类与常用方法介绍" class="headerlink" title="组件相关类与常用方法介绍"></a>组件相关类与常用方法介绍</h3><h4 id="Logger类"><a href="#Logger类" class="headerlink" title="Logger类"></a>Logger类</h4><p><strong>Logger对象有3个任务要做</strong>：</p><ul><li>向<strong>应用程序代码暴露几个方法</strong>，使应用程序<strong>可以在运行时记录日志消息</strong>；</li><li>基于日志严重等级(默认的过滤设施)或filter对象来<strong>决定要对哪些日志进行后续处理</strong>；</li><li>将日志消息<strong>传送给</strong>所有感兴趣的日志<strong>handlers</strong>。</li></ul><p><strong>Logger对象最常用的方法分为两类</strong>：</p><ul><li><code>配置方法</code></li><li><code>消息发送方法(创建日志)</code></li></ul><h5 id="最常用的配置方法"><a href="#最常用的配置方法" class="headerlink" title="最常用的配置方法"></a>最常用的配置方法</h5><table><tr><th>方法</th><th>描述</th></tr><tr><td><code>Logger.setLevel()</code></td><td><strong>设置<strong>日志器将会处理的日志消息的<strong>最低严重级别</strong></strong></strong></td></tr><tr><td><code>Logger.addHandler()</code>和<code>Logger.removeHandler()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>handler对象</strong></td></tr><tr><td><code>Logger.addFilter()</code>和<code>Logger.removeFilter()</code></td><td>为该logger对象<strong>添加</strong>和<strong>移除</strong>一个<strong>filter对象</strong></td></tr></table><div class="note info"><p>关于<code>Logger.setLevel()</code>方法的说明：内建等级中，级别最低的是<code>DEBUG</code>，级别最高的是<code>CRITICAL</code>。例如<code>setLevel(logging.INFO)</code>，此时函数参数为INFO，那么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。</p></div><hr><h5 id="创建日志记录方法"><a href="#创建日志记录方法" class="headerlink" title="创建日志记录方法"></a>创建日志记录方法</h5><p>logger对象配置完成后，可以<strong>使用下面的方法来创建日志记录</strong>：</p><table><tr><th width="50%">方法</th><th width="50%">描述</th></tr><tr><td><code>Logger.debug()</code>, <code>Logger.info()</code>, <code>Logger.warning()</code>, <code>Logger.error()</code>, <code>Logger.critical()</code></td><td>创建一个与它们的方法名对应等级的日志记录</td></tr><tr><td><code>Logger.exception()</code></td><td>创建一个类似于<code>Logger.error()</code>的日志消息</td></tr><tr><td><code>Logger.log()</code></td><td>需要获取一个明确的日志level参数来创建一个日志记录</td></tr></table><div class="note info"><ul><li><code>Logger.exception()</code>与<code>Logger.error()</code>的区别在于：<code>Logger.exception()</code>将会输出堆栈追踪信息，另外<strong>通常只是在一个exception handler中调用该方法</strong></li><li><code>Logger.log()</code>与<code>Logger.debug()</code>、<code>Logger.info()</code>等方法相比，虽然<strong>需要多传一个level参数，显得不是那么方便，但是当需要记录自定义level的日志时还是需要该方法来完成</strong></li></ul></div><h5 id="得到一个Logger对象"><a href="#得到一个Logger对象" class="headerlink" title="得到一个Logger对象"></a>得到一个Logger对象</h5><p>得到Logger对象方法有两种：</p><ul><li>第一种方式是通过<strong>Logger类的实例化方法</strong>创建一个Logger类的实例</li><li>第二种方式是<code>logging.getLogger()</code>方法，这是通常使用的方法</li></ul><p><code>logging.getLogger()</code>方法有一个<strong>可选参数</strong><code>name</code>，该参数表示将<strong>要返回的日志器的名称标识，如果不提供该参数，则其值为’root’</strong>。若以相同的<code>name</code>参数值多次调用<code>getLogger()</code>方法，将会返回指向同一个logger对象的引用。</p><div class="note info"><p>关于logger的<strong>层级结构</strong>与<strong>有效等级</strong>的说明：</p><ul><li><p>logger的名称是一个以<code>.</code>分割的层级结构，每个<code>.</code>后面的logger都是<code>.</code>前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代</p></li><li><p>logger有一个<strong>有效等级(effective level)</strong>的概念。</p><ul><li>如果一个logger上<strong>没有被明确设置一个level</strong>，那么该logger就是<strong>使用它parent的level</strong>；</li><li>如果它的<strong>parent也没有明确设置level</strong>则继续向上<strong>查找parent的parent的有效level，依次类推</strong>，直到找到个一个明确设置了level的祖先为止。</li><li>需要说明的是，<strong>root logger总是会有一个明确的level设置(默认为 WARNING)</strong>。</li><li>当<strong>决定是否去处理一个已发生的事件时</strong>，<strong>logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理</strong>。</li></ul></li><li><p><code>child loggers</code>在完成对日志消息的处理后，<strong>默认会将日志消息传递给与它们的祖先loggers相关的handlers</strong>。因此，我们<strong>不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了</strong>。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</p></li></ul></div><hr><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的<strong>作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）</strong>。Logger对象可以通过<code>addHandler()</code>方法<strong>为自己添加0个或者更多个handler对象</strong>。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>把所有日志都发送到一个日志文件中；</li><li>把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>把所有严重级别为critical的日志发送到一个email邮件地址。</li></ul><p>这种场景就需要<strong>3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置</strong>。</p><p>一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似乎唯一相关的handler方法就是下面这几个<strong>配置方法</strong>：</p><table><tr><th width="40%">方法</th><th width="60%">描述</th></tr><tr><td><code>Handler.setLevel()</code></td><td>设置handler将会处理的日志消息的最低严重级别</td></tr><tr><td><code>Handler.setFormatter()</code></td><td>为handler设置一个格式器对象</td></tr><tr><td><code>Handler.addFilter()</code>和<code>Handler.removeFilter()</code></td><td>为handler添加和删除一个过滤器对象</td></tr></table><p>需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了所有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些<strong>常用的Handler</strong>：</p><table><tr><th width="40%">Handler</th><th width="60%">描述</th></tr><tr><td><code>logging.StreamHandler</code></td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td><code>logging.FileHandler</code></td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td><code>logging.handlers.RotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td><code>logging.hanlders.TimedRotatingFileHandler</code></td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td><code>logging.handlers.HTTPHandler</code></td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td><code>logging.handlers.SMTPHandler</code></td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td><code>logging.NullHandler</code></td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免'No handlers could be found for logger XXX'信息的出现。</td></tr></table><hr><h4 id="Formater类"><a href="#Formater类" class="headerlink" title="Formater类"></a>Formater类</h4><p>Formater对象用于<strong>配置日志信息的最终顺序、结构和内容</strong>。与logging.Handler基类不同的是，<strong>应用代码可以直接实例化Formatter类</strong>。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=<span class="keyword">None</span>, datefmt=<span class="keyword">None</span>, style=<span class="string">'%'</span>)</span><br></pre></td></tr></table></figure><p></p><p>可见，该构造方法接收3个可选参数：</p><ul><li><code>fmt</code>：指定消息格式化字符串，如果不指定该参数则<strong>默认使用message的原始值</strong></li><li><code>datefmt</code>：指定日期格式字符串，如果不指定该参数则默认使用<code>%Y-%m-%d %H:%M:%S</code></li><li><code>style</code>：Python 3.2新增的参数，可取值为<code>%</code>、<code>{</code>和<code>$</code>，如果不指定该参数则默认使用<code>%</code></li></ul><hr><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>.<span class="title">Filter</span><span class="params">(name=<span class="string">''</span>)</span></span></span><br><span class="line"><span class="class">    <span class="title">filter</span><span class="params">(record)</span></span></span><br></pre></td></tr></table></figure><p></p><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><div class="note info"><ul><li>如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性</li><li>我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等</li></ul></div><hr><h3 id="logging日志流处理流程"><a href="#logging日志流处理流程" class="headerlink" title="logging日志流处理流程"></a>logging日志流处理流程</h3><p>下面这个图描述了日志流的处理流程：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/logging处理流程.png" alt="logging处理流程.png"></p><p>我们来描述下上面这个图的日志流处理流程：</p><ul><li>（在用户代码中进行）<strong>日志记录函数调用</strong>，如：logger.info(…)，logger.debug(…)等；</li><li>判断要记录的日志级别<strong>是否满足日志器设置的级别要求</strong>（要记录的日志级别要大于或等于日志器设置的级别才算满足要求），如果不满足则该日志记录会被丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>根据日志记录函数调用时掺入的参数，<strong>创建</strong>一个<strong>日志记录（LogRecord类）对象</strong>；</li><li>判断日志记录器上设置的<strong>过滤器是否拒绝这条日志记录</strong>，如果日志记录器上的某个过滤器拒绝，则该日志记录会被丢弃并终止后续的操作，如果日志记录器上设置的过滤器不拒绝这条日志记录或者日志记录器上没有设置过滤器则继续下一步操作–<strong>将日志记录</strong>分别交给该日志器上添加的各个<strong>处理器</strong>；</li><li>判断要记录的日志级别<strong>是否满足处理器设置的级别要求</strong>（要记录的日志级别要大于或等于该处理器设置的日志级别才算满足要求），如果不满足记录将会被该处理器丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>判断该<strong>处理器上设置的过滤器</strong>是否拒绝这条日志记录，如果该处理器上的某个过滤器拒绝，则该日志记录会被当前处理器丢弃并终止后续的操作，如果当前处理器上设置的过滤器不拒绝这条日志记录或当前处理器上没有设置过滤器测继续下一步操作；</li><li>如果能到这一步，说明这条日志记录经过了层层关卡允许被输出了，此时当前<strong>处理器会根据自身被设置的格式器</strong>（如果没有设置则使用默认格式）将这条日志记录进行格式化，最后将格式化后的结果输出到指定位置（文件、网络、类文件的Stream等）；</li><li>如果日志器被设置了<strong>多个处理器</strong>的话，上面的第5-8步会执行多次；</li><li>这里才是完整流程的最后一步：<strong>判断该日志器输出的日志消息是否需要传递给上一级logger（之前提到过，日志器是有层级关系的）的处理器</strong>，如果propagate属性值为1则表示日志消息将会被输出到处理器指定的位置，同时还会被传递给parent日志器的handlers进行处理直到当前日志器的propagate属性为0停止，如果propagate值为0则表示不向parent日志器的handlers传递该消息，到此结束。</li></ul><p>可见，<strong>一条日志信息要想被最终输出需要依次经过以下几次过滤</strong>：</p><ul><li><strong>日志器等级过滤</strong></li><li>日志器的过滤器过滤</li><li><strong>日志器的处理器等级过滤</strong></li><li>日志器的处理器的过滤器过滤</li></ul><div class="note info"><p><strong>需要说明的是</strong>： 关于上面第9个步骤，如果propagate值为1，那么日志消息会直接传递交给上一级logger的handlers进行处理，此时上一级logger的日志等级并不会对该日志消息进行等级过滤。</p></div><hr><p><br></p><h2 id="使用四大组件记录日志"><a href="#使用四大组件记录日志" class="headerlink" title="使用四大组件记录日志"></a>使用四大组件记录日志</h2><p>现在，我们对logging模块的重要组件及整个日志流处理流程都应该有了一个比较全面的了解，下面我们来看一个例子。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>现在有以下几个日志记录的需求：</p><ul><li>要求将<strong>所有级别的所有日志都写入磁盘文件</strong>中</li><li><strong>all.log文件中记录所有的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 日志信息</li><li><strong>error.log文件中单独记录error及以上级别的日志信息</strong>，<strong>日志格式</strong>为：日期和时间 - 日志级别 - 文件名[:行号] - 日志信息</li><li>要求all.log在<strong>每天凌晨</strong>进行<strong>日志切割</strong></li></ul><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>要记录所有级别的日志，因此日志器的有效level需要设置为最低级别–DEBUG;</li><li><strong>日志需要被发送到两个不同的目的地</strong>，因此需要<strong>为日志器设置两个handler</strong>；另外，两个<strong>目的地都是磁盘文件</strong>，因此<strong>这两个handler都是与FileHandler相关的</strong>；</li><li>all.log要求<strong>按照时间进行日志切割</strong>，因此他需要用<code>logging.handlers.TimedRotatingFileHandler</code>; 而error.log没有要求日志切割，因此可以使用<code>FileHandler</code>;</li><li><strong>两个日志文件的格式不同</strong>，因此需要<strong>对这两个handler分别设置格式器</strong>.</li></ul><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'mylogger'</span>)</span><br><span class="line"><span class="comment"># 设置日志器的日志级别</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第一个handler，实现日志切割</span></span><br><span class="line">rf_handler = logging.handlers.TimedRotatingFileHandler(<span class="string">'all.log'</span>, when=<span class="string">'midnight'</span>, interval=<span class="number">1</span>, backupCount=<span class="number">7</span>, atTime=datetime.time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置第一个handler的格式器，使用了formatter类</span></span><br><span class="line">rf_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第二个handler</span></span><br><span class="line">f_handler = logging.FileHandler(<span class="string">'error.log'</span>)</span><br><span class="line"><span class="comment"># 设置这个handler的日志级别，实现日志过滤，在上面日志器的过滤结果中进行进一步的过滤</span></span><br><span class="line">f_handler.setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># 设置第二个handler的日志格式，使用了formatter类</span></span><br><span class="line">f_handler.setFormatter(logging.Formatter(<span class="string">"%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给日志器添加第一个handler</span></span><br><span class="line">logger.addHandler(rf_handler)</span><br><span class="line"><span class="comment"># 给日志器添加第二个handler</span></span><br><span class="line">logger.addHandler(f_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同级别的日志信息 </span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat all.log</span><br><span class="line">  2019-03-23 16:53:48,763 - DEBUG - debug message</span><br><span class="line">  2019-03-23 16:53:48,766 - INFO - info message</span><br><span class="line">  2019-03-23 16:53:48,766 - WARNING - warning message</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - critical message</span><br><span class="line"></span><br><span class="line">cat error.log</span><br><span class="line">  2019-03-23 16:53:48,766 - ERROR - logging_learn.py[:100] - error message</span><br><span class="line">  2019-03-23 16:53:48,766 - CRITICAL - logging_learn.py[:101] - critical message</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>%(filename)s[:%(lineno)d]</code>可以用来显示哪个文件的哪一行进行了这个日志输出</p></div><hr><h3 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a>其他实例</h3><h4 id="日志同时输出到文件和屏幕"><a href="#日志同时输出到文件和屏幕" class="headerlink" title="日志同时输出到文件和屏幕"></a>日志同时输出到文件和屏幕</h4><p>上面的那个实例是创建了两个handler来进行相关操作，其实也可以使用四大组件和日志级别函数结合来进行设置，<strong>以下是将日志同时输出到文件和屏幕的示例</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用logging.basicConfig()来自定义日志输出信息，将日志信息输入到文件中</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                filename=<span class="string">'myapp.log'</span>,</span><br><span class="line">                filemode=<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"><span class="comment"># 使用四大组件来控制日志，因为一个handler只能输出到一个地方</span></span><br><span class="line"><span class="comment"># 这种需要输出到多个地方的肯定是需要两个handler的，上面的logging.basicConfig()相当于一个，所以还需要自己创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象#</span></span><br><span class="line">console = logging.StreamHandler()</span><br><span class="line"><span class="comment"># 设置handler的日志级别</span></span><br><span class="line">console.setLevel(logging.INFO)</span><br><span class="line"><span class="comment"># 使用foramtter类设置formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(name)-12s: %(levelname)-8s %(message)s'</span>)</span><br><span class="line"><span class="comment"># 设置handler的formatter</span></span><br><span class="line">console.setFormatter(formatter)</span><br><span class="line"><span class="comment"># 得到Logger类的对象并添加handler</span></span><br><span class="line">logging.getLogger(<span class="string">''</span>).addHandler(console)</span><br><span class="line"><span class="comment">#################################################################################################</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'This is debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'This is info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'This is warning message'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="配置logging的几种方式"><a href="#配置logging的几种方式" class="headerlink" title="配置logging的几种方式"></a>配置logging的几种方式</h2><p>作为开发者，我们可以<strong>通过以下3中方式来配置logging</strong>:</p><ul><li>使用Python代码显式的创建loggers, handlers和formatters并分别调用它们的配置函数；</li><li>创建一个日志配置文件，然后使用fileConfig()函数来读取该文件的内容；</li><li>创建一个包含配置信息的dict，然后把它传递个dictConfig()函数；</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6885182.html" target="_blank" rel="noopener">《python之配置日志的几种方式》</a></p><hr><p><br></p><h2 id="向日志输出中添加上下文信息"><a href="#向日志输出中添加上下文信息" class="headerlink" title="向日志输出中添加上下文信息"></a>向日志输出中添加上下文信息</h2><p>除了传递给日志记录函数的参数外，有时候我们还想在<strong>日志输出中包含一些额外的上下文信息</strong>。比如，在一个网络应用中，可能希望在日志中记录客户端的特定信息，如：远程客户端的IP地址和用户名。这里我们来介绍以下几种实现方式：</p><ul><li>通过向日志记录函数传递一个<code>extra</code>参数引入上下文信息</li><li>使用<code>LoggerAdapters</code>引入上下文信息</li><li>使用<code>Filters</code>引入上下文信息</li></ul><p>具体说明请参考另一篇博文<a href="http://www.cnblogs.com/yyds/p/6897964.html" target="_blank" rel="noopener">《Python之向日志输出中添加上下文信息》</a></p><hr><p><br></p><h2 id="实战技巧"><a href="#实战技巧" class="headerlink" title="实战技巧"></a>实战技巧</h2><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p><code>FileHandler</code> 创建对象时可以设置文件编码，如果将<strong>文件编码设置为 <code>utf-8</code>（utf-8 和 utf8 等价）</strong>，就可以解决中文乱码问题啦。</p><ul><li>一种方法是<strong>自定义 Logger 对象</strong>，需要写很多配置</li><li>另一种方法是<strong>使用默认配置方法 <code>basicConfig()</code>，传入 handlers 处理器列表对象</strong>，在其中的 handler 设置文件的编码</li></ul><p>关键参考代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义 Logger 配置</span></span><br><span class="line">handler = logging.FileHandler(filename=<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用默认的 Logger 配置，传入handlers时设置编码方式</span></span><br><span class="line">logging.basicConfig(handlers=[logging.FileHandler(<span class="string">"test.log"</span>, encoding=<span class="string">"utf-8"</span>)], level=logging.DEBUG)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="临时禁用日志输出"><a href="#临时禁用日志输出" class="headerlink" title="临时禁用日志输出"></a>临时禁用日志输出</h3><p>有时候我们又不想让日志输出，但在这后又想输出日志。</p><ul><li>一种方法是在<strong>使用默认配置时</strong>，给 <code>logging.disabled()</code> 方法<strong>传入禁用的日志级别</strong>，就可以禁止设置级别以下的日志输出了</li><li>另一种方法时在<strong>自定义 Logger 时</strong>，<strong>Logger 对象的 disable 属性设为 True，默认值是 False，也即不禁用</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认配置</span></span><br><span class="line">logging.disable(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的Logger</span></span><br><span class="line">logger.disabled = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="分割日志文件"><a href="#分割日志文件" class="headerlink" title="分割日志文件"></a>分割日志文件</h3><p><code>logging.handlers</code>文件中提供了<code>TimedRotatingFileHandler</code>和<code>RotatingFileHandler</code>类分别可以实现<strong>按时间</strong>和<strong>大小</strong>划分:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1000 Byte 划分一个日志文件，备份文件为 3 个</span></span><br><span class="line">file_handler = logging.handlers.RotatingFileHandler(<span class="string">"test.log"</span>, mode=<span class="string">"w"</span>, maxBytes=<span class="number">1000</span>, backupCount=<span class="number">3</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1小时 划分一个日志文件，interval 是时间间隔，备份文件为 10 个</span></span><br><span class="line">handler2 = logging.handlers.TimedRotatingFileHandler(<span class="string">"test.log"</span>, when=<span class="string">"H"</span>, interval=<span class="number">1</span>, backupCount=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>这个在前面的使用四大组件记录日志的示例中也有提及。</p><hr><p><br></p><h2 id="补充信息"><a href="#补充信息" class="headerlink" title="补充信息"></a>补充信息</h2><h3 id="datefmt支持的时间格式"><a href="#datefmt支持的时间格式" class="headerlink" title="datefmt支持的时间格式"></a>datefmt支持的时间格式</h3><table><tr><th width="20%">格式</th><th width="80%">含义</th></tr><tr><td><code>%a</code></td><td>本地（locale）简化星期名称</td></tr><tr><td><code>%A</code></td><td>本地完整星期名称</td></tr><tr><td><code>%b</code></td><td>本地简化月份名称</td></tr><tr><td><code>%B</code></td><td>本地完整月份名称</td></tr><tr><td><code>%c</code></td><td>本地相应的日期和时间表示</td></tr><tr><td><code>%d</code></td><td>一个月中的第几天（01 - 31）</td></tr><tr><td><code>%H</code></td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td><code>%I</code></td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td><code>%j</code></td><td>一年中的第几天（001 - 366）</td></tr><tr><td><code>%m</code></td><td>月份（01 - 12）</td></tr><tr><td><code>%M</code></td><td>分钟数（00 - 59）</td></tr><tr><td><code>%p</code></td><td>本地am或者pm的相应符</td></tr><tr><td><code>%S</code></td><td>秒（01 - 61）</td></tr><tr><td><code>%U</code></td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td></tr><tr><td><code>%w</code></td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td><code>%W</code></td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td><code>%x</code></td><td>本地相应日期</td></tr><tr><td><code>%X</code></td><td>本地相应时间</td></tr><tr><td><code>%y</code></td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td><code>%Y</code></td><td>完整的年份</td></tr><tr><td><code>%Z</code></td><td>时区的名字（如果不存在为空字符）</td></tr><tr><td><code>%%</code></td><td>‘%’字符</td></tr></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3.5/howto/logging.html" target="_blank" rel="noopener">Logging HOWTO-官方细致教程</a></li><li><a href="https://docs.python.org/3.5/howto/logging-cookbook.html" target="_blank" rel="noopener">Logging Cookbook-官方实例</a></li><li><a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">官方链接</a></li><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li><li><a href="http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html" target="_blank" rel="noopener">python 的日志logging模块学习</a></li><li><a href="https://blog.csdn.net/fxjtoday/article/details/6307285" target="_blank" rel="noopener">项目中比较需要用到的</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cat-显示、读取或拼接文件内容</title>
      <link href="/posts/24399.html"/>
      <url>/posts/24399.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用Linux的<code>cat</code>命令来执行文件的查看、合并和创建功能。在查看文件方面包括的参数有：<code>-n</code>、<code>-b</code>、<code>-s</code>、<code>-E</code>、<code>-T</code>；在合并文件方面学习了<strong>结合输出重定向以及前面的查看功能的参数进行合并</strong>；在创建文件方面主要有三个命令：<code>cat &gt;filename</code>、<code>cat &lt;&lt; EOF</code>和<code>cat &gt; filename &lt;&lt; EOF</code>。</p></div><a id="more"></a><h2 id="cat简介"><a href="#cat简介" class="headerlink" title="cat简介"></a>cat简介</h2><p><code>cat</code> 是一个文本文件(查看)和(连接)工具，通常是用于查看某个文件的内容，其主要有三大功能：</p><ul><li><strong>显示整个文件</strong>内容</li><li>将几个文件<strong>合并</strong>为一个文件</li><li><strong>从键盘创建一个文件</strong></li></ul><hr><p><br></p><h2 id="cat命令用法"><a href="#cat命令用法" class="headerlink" title="cat命令用法"></a>cat命令用法</h2><h3 id="cat命令格式"><a href="#cat命令格式" class="headerlink" title="cat命令格式"></a>cat命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cat [OPTION]... [FILE]...</span><br><span class="line">Description:</span><br><span class="line">  Concatenate FILE(s), or standard input, to standard output.</span><br></pre></td></tr></table></figure><hr><h3 id="cat-options说明"><a href="#cat-options说明" class="headerlink" title="cat options说明"></a>cat options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-n</strong></td><td>–number</td><td><strong>由1开始对所有输出的行数编号</strong></td></tr><tr><td><strong>-b</strong></td><td>–number-nonblank</td><td><strong>和-n相似，只不过对于空白行不编号</strong></td></tr><tr><td><strong>-s</strong></td><td>–squeeze-blank</td><td><strong>当遇到有连续两行以上的空白行，只输出一行的空白行</strong></td></tr><tr><td>-E</td><td>–show-ends</td><td>在每行结束处显示<code>$</code></td></tr><tr><td>-v</td><td>–show-nonprinting</td><td>使用<code>^</code>和<code>M-</code>符号，除了<code>LFD</code>和<code>TAB</code>之外</td></tr><tr><td>-T</td><td>–show-tabs</td><td>将<code>TAB</code>字符显示为<code>^I</code></td></tr><tr><td>-A</td><td>–show-all</td><td>等价于 <code>-vET</code></td></tr><tr><td>-e</td><td></td><td>等价于<code>-vE</code>选项</td></tr><tr><td>-t</td><td></td><td>等价于<code>-vT</code>选项</td></tr></tbody></table><hr><p><br></p><h2 id="cat用法实例"><a href="#cat用法实例" class="headerlink" title="cat用法实例"></a>cat用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>a<br>b 1</p><p>\====</p></blockquote><blockquote><p><code>cat test2.txt</code><br>c<br>d<br>\==</p></blockquote><hr><h3 id="查看文件功能"><a href="#查看文件功能" class="headerlink" title="查看文件功能"></a>查看文件功能</h3><h4 id="n-对所有行编号"><a href="#n-对所有行编号" class="headerlink" title="-n-对所有行编号"></a>-n-对所有行编号</h4><p><strong>所有行包含空白行</strong>：</p><blockquote><p><code>cat -n test1.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====</p></blockquote><hr><h4 id="b-对除空白行之外的行进行编号"><a href="#b-对除空白行之外的行进行编号" class="headerlink" title="-b-对除空白行之外的行进行编号"></a>-b-对除空白行之外的行进行编号</h4><blockquote><p><code>cat -b test1.txt</code><br>1 a<br>2 b 1</p><pre><code>3     ====  </code></pre></blockquote><p><strong>需要和上面的<code>-n</code>参数进行区分</strong></p><hr><h4 id="s-只输出连续多行空白行的其中一行"><a href="#s-只输出连续多行空白行的其中一行" class="headerlink" title="-s-只输出连续多行空白行的其中一行"></a>-s-只输出连续多行空白行的其中一行</h4><p><strong>结合前面的<code>-n</code>参数</strong>：</p><blockquote><p><code>cat -sn test1.txt</code><br>1 a<br>2 b 1<br>3<br>4 ====</p></blockquote><p>可以发现只输出了连续两行空白行中的一个，并进行编号，说明是先输出一个，然后编号的，不是先编号再输出其中一行</p><hr><h4 id="E-在每行结束处显示"><a href="#E-在每行结束处显示" class="headerlink" title="-E-在每行结束处显示$"></a>-E-在每行结束处显示$</h4><blockquote><p><code>cat -E test1.txt</code><br>a <strong>\$</strong><br>b 1<strong>\$</strong><br><strong>\$</strong><br><strong>\$</strong><br>====<strong>\$</strong></p></blockquote><hr><h4 id="T-将TAB字符显示为-I"><a href="#T-将TAB字符显示为-I" class="headerlink" title="-T-将TAB字符显示为^I"></a>-T-将TAB字符显示为^I</h4><blockquote><p>cat -nT test1.txt<br>1 a<br>2 b <strong>^I</strong>1<br>3<br>4<br>5 ====</p></blockquote><hr><p><br></p><h3 id="合并文件功能"><a href="#合并文件功能" class="headerlink" title="合并文件功能"></a>合并文件功能</h3><p>将<code>test1.txt</code>和<code>test2.txt</code>合并后重定向到<code>test3.txt</code>中：</p><blockquote><p><code>cat test1.txt test2.txt &gt;test3.txt</code><br><code>cat test3.txt</code><br>a<br>b 1</p><p>\====<br>c<br>d<br>\==</p></blockquote><p><strong>可以结合前面查看文件的参数</strong>：</p><blockquote><p><code>cat -n test1.txt test2.txt</code><br>1 a<br>2 b 1<br>3<br>4<br>5 ====<br>6 c<br>7 d<br>8 ==</p></blockquote><div class="note info"><ul><li><strong>后面不接文件的话会输出到标准输出</strong></li><li>文件内容是<strong>按照文件顺序连接起来的</strong></li><li><strong>编号是连续的</strong>，不是每个文件单独的编号</li></ul></div><hr><p><br></p><h3 id="创建文件相关功能"><a href="#创建文件相关功能" class="headerlink" title="创建文件相关功能"></a>创建文件相关功能</h3><p>这一部分主要有三个比较重要和常见的命令：</p><ul><li><code>cat &lt;&lt; EOF</code></li><li><code>cat &gt; filename</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code></li></ul><h4 id="cat-lt-lt-EOF"><a href="#cat-lt-lt-EOF" class="headerlink" title="`cat &lt;&lt; EOF"></a>`cat &lt;&lt; EOF</h4><p><strong>以<code>EOF</code>输入字符为标准输入结束</strong>，这里的<strong>EOF并不是固定</strong>的(<code>EOF是end of file</code>，表示文本结束符，使用有含义的字符可能更容易记住用法)，可以设置为<code>mmm</code>等其他自定义的字符，示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF </span><br><span class="line">&gt; ad    <span class="comment"># 开始从标准输入读取</span></span><br><span class="line">&gt; adad</span><br><span class="line">&gt; EOF <span class="comment"># 遇到了标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad    <span class="comment"># 直接输出</span></span><br><span class="line">adad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换标准输入结束字符</span></span><br><span class="line">cat &lt;&lt; mmm</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; ad</span><br><span class="line">&gt; mmm   <span class="comment"># 遇到了上面定义的标准输入结束字符，结束标准输入 </span></span><br><span class="line">ad</span><br><span class="line">ad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>这一部分输入输入和输出重定向部分，还可以参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h4 id="cat-gt-filename"><a href="#cat-gt-filename" class="headerlink" title="cat &gt; filename"></a><code>cat &gt; filename</code></h4><p><strong>创建文件</strong>，并<strong>把标准输入输出到filename文件</strong>中，<strong>以<code>ctrl+d</code>作为输入结束</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并写入</span></span><br><span class="line">cat &gt; filename</span><br><span class="line">ad</span><br><span class="line">adad   <span class="comment"># 这一行输入完成之后按下快捷键ctrl+d结束输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat filename </span><br><span class="line">ad</span><br><span class="line">adad</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p><code>cat &gt; filename</code>命令和上面的<code>cat &lt;&lt; EOF</code>不同之处在于：</p><ul><li><code>cat &lt;&lt; EOF</code>不会创建文件，而<code>cat &gt; filename</code>会创建文件</li><li><code>cat &lt;&lt; EOF</code>可以自定义结束的字符，而<code>cat &gt; filename</code>则是使用快捷键<code>ctrl+d</code>作为输入结束</li><li><code>cat &lt;&lt; EOF</code>输入的时候有<code>&gt;</code>提示输入，而<code>cat &gt; filename</code>没有任何提示输入的此内容</li></ul></div><hr><h4 id="cat-gt-filename-lt-lt-EOF"><a href="#cat-gt-filename-lt-lt-EOF" class="headerlink" title="cat &gt; filename &lt;&lt; EOF"></a><code>cat &gt; filename &lt;&lt; EOF</code></h4><p>这个是上面两个的合并版，<strong>既可以创建文件</strong>，<strong>又可以自定义停止输入字符</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件并设置停止输入字符</span></span><br><span class="line">cat &gt; test4.txt &lt;&lt; EOF</span><br><span class="line">&gt; a</span><br><span class="line">&gt; b</span><br><span class="line">&gt; c</span><br><span class="line">&gt; d</span><br><span class="line">&gt; EOF   <span class="comment"># 遇到了标准输入结束字符，结束标准输入，但是不会直接输入，因为内容已经重定向到test4.txt中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test4.txt文件内容，是刚刚输入的内容</span></span><br><span class="line">cat test4.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p></p><ul><li>上面的创建文件也<strong>可以改为追加文件</strong>：<code>cat &gt;&gt; test4.txt &lt;&lt; EOF</code></li><li><code>cat &gt; filename &lt;&lt; EOF</code>书写的前后顺序可以调换，比如可写成：<code>cat &lt;&lt; EOF &gt; filename</code></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cat" target="_blank" rel="noopener">cat命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-cat.html" target="_blank" rel="noopener">Linux cat命令</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/7717602.html" target="_blank" rel="noopener">Linux cat命令详解</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5856106.html" target="_blank" rel="noopener">Linux中cat、more、less、tail、head命令的区别</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系列-Git实战总结</title>
      <link href="/posts/5778.html"/>
      <url>/posts/5778.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在使用Git中遇到的比较使用的技巧和问题解决方案，便于后续查询和使用。</p></div><a id="more"></a><h2 id="gitignore文件不起作用以及文件规则"><a href="#gitignore文件不起作用以及文件规则" class="headerlink" title=".gitignore文件不起作用以及文件规则"></a>.gitignore文件不起作用以及文件规则</h2><h3 id="文件书写规则"><a href="#文件书写规则" class="headerlink" title="文件书写规则"></a>文件书写规则</h3><p>在使用Git管理代码的过程中，可以修改<code>.gitignore</code>文件中的标示的方法来<strong>忽略开发者想忽略掉的文件或目录(实际项目中，很多文件都是不需要版本管理的)</strong>，如果没有<code>.gitignore</code>文件，可以自己手工创建。在<code>.gitignore</code>文件中的每一行保存一个匹配的规则例如：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"> </span><br><span class="line">*.a       <span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">!lib.a    <span class="comment"># 但 lib.a 除外</span></span><br><span class="line">/TODO     <span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line">build/    <span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">doc/*.txt <span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure><p></p><p>需要强调的一点是，如果你不慎在创建<code>.gitignore</code>文件之前就push了项目，那么即使你在<code>.gitignore</code>文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说，出现这种问题的原因就是<strong>Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们</strong>。所以大家一定要<strong>养成在项目开始就创建<code>.gitignore</code>文件的习惯，否则一旦push，处理起来会非常麻烦。</strong></p><div class="note info"><p>忽略整个文件夹，只需要<code>build/</code>即可，千万不要<code>build/*</code>，这样的话不会起效</p></div><hr><h3 id="清除本地缓存"><a href="#清除本地缓存" class="headerlink" title="清除本地缓存"></a>清除本地缓存</h3><p>如果一不小心在创建<code>.gitignore</code>文件之前就使用了<code>git push</code>，这样可能会使得<code>.gitignore</code>的忽略规则失效，这是因为新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在<code>.gitignore</code>中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行<code>git push</code>，这样就不会出现忽略的文件了。git清除本地缓存命令如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line">git rm -r --cached .</span><br><span class="line"><span class="comment"># 将所有文件改变上传到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 将暂存区的所有内容提交到当前分支上</span></span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="git-push-u-VS-git-push"><a href="#git-push-u-VS-git-push" class="headerlink" title="git push -u VS git push"></a>git push -u VS git push</h2><p><code>git push</code>的用法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p></p><p>使用实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与多个主机存在追踪关系(连接)，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用：</span></span><br><span class="line"><span class="comment"># 先使用带-u参数的git push</span></span><br><span class="line">git push -u origin master </span><br><span class="line"><span class="comment"># 后续的git push可以省略参数</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="将已有的文件夹上传到github"><a href="#将已有的文件夹上传到github" class="headerlink" title="将已有的文件夹上传到github"></a>将已有的文件夹上传到github</h2><p>背景：可能有些时候并没有在文件夹创建之初没有考虑到上传到Github的情况，所以就需要将已有的文件夹上传到Github，但是又不希望先建立空的repo，然后clone下来将文件复制进去，然后就有了下面的方法：</p><ul><li>在bash下<strong>进入需要上传的文件夹</strong>：<code>cd dir</code></li><li><strong>初始化产生版本库</strong>：<code>git init</code></li><li>将所有文件<strong>添加到暂存区</strong>：<code>git add .</code></li><li>提交文件：<code>git commit -m &quot;message&quot;</code></li><li>添加远程仓库：<code>git remote add origin git@github.com:showteeth/orth_blast_docker.git</code></li><li>上传本地代码：<code>git push -u origin master</code></li><li>后续上传：<ul><li><code>git add .</code></li><li><code>git commit -m &quot;message&quot;</code></li><li><code>git push origin master</code>或者<code>git push</code></li></ul></li></ul><p>在使用<code>git push -u origin master</code>上传本地代码时，如果报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.com:showteeth/orth_blast_docker.git'</span></span><br></pre></td></tr></table></figure><p></p><ul><li>按照这个<a href="https://github.com/rtyley/bfg-repo-cleaner/issues/29" target="_blank" rel="noopener">issue</a>的说法，可以试试<code>git push -u origin master --force</code></li><li>或者按照<a href="https://blog.csdn.net/pql925/article/details/72772660" target="_blank" rel="noopener">这篇文章</a>的做法：<ul><li>合并代码：<code>git pull origin master</code>或者<code>git pull --rebase origin master</code>(<mark>文章中使用的这个，但我感觉是不是应该使用前面的，下次可以先试试前面的可不可以</mark>)</li><li>上传代码：<code>git push -u origin master</code></li></ul></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker系列-Dockerfile</title>
      <link href="/posts/31987.html"/>
      <url>/posts/31987.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/leveldc/article/details/85492558#_1" target="_blank" rel="noopener">Dockerfile详解</a></li><li><a href="https://www.cnblogs.com/lighten/p/6900556.html" target="_blank" rel="noopener">docker学习(3)–Dockfile详解</a></li><li><a href="https://www.centos.bz/2016/12/dockerfile-cmd-instruction/" target="_blank" rel="noopener">Dockerfile参考(8) – CMD设置运行容器时执行的命令</a></li><li><a href="https://www.jianshu.com/p/78f4591b7ff0" target="_blank" rel="noopener">Docker CMD</a></li><li><a href="https://www.cnblogs.com/51kata/p/5264894.html" target="_blank" rel="noopener">docker学习笔记16：Dockerfile 指令 ADD 和 COPY介绍</a></li><li><a href="https://www.cnblogs.com/lienhua34/p/5170335.html" target="_blank" rel="noopener">Dockerfile创建自定义Docker镜像以及CMD与ENTRYPOINT指令的比较</a></li><li><a href="http://www.dockone.io/article/1414" target="_blank" rel="noopener">九个编写Dockerfiles的常见错误</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-构建第一个docker镜像</title>
      <link href="/posts/371.html"/>
      <url>/posts/371.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是我的第一个Docker镜像，主要是依托项目是寻找两个基因之间的同源基因对。这篇文章主要记录了创建第一个镜像的过程，包括前期测试、编写Dockfile、查看镜像、运行镜像、修改镜像、退出、关闭、重启镜像、删除镜像以及后面的发布镜像、拉取镜像等操作，同时也记录了运行中的一些错误和解决办法。</p></div><a id="more"></a><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>docker 镜像是一个只读的 docker 容器模板，含有启动 docker 容器所需的文件系统结构及其内容(包括对资源需求、环境的要求、依赖的类库和运行的代码等等)，因此是启动一个 docker 容器的基础。</p><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile用于构建<strong>一致的Docker镜像</strong>，其定义了容器中的运行环境，包括像网络接口和虚拟化的磁盘驱动等硬件资源，这些资源是与宿主系统隔离开的，不会对系统有任何影响。使用Docker镜像运行Docker容器，可以让定义在该镜像中的应用程序<strong>无论在哪里运行，都有一致的功能</strong>。</p><h3 id="示例Dockerfile学习"><a href="#示例Dockerfile学习" class="headerlink" title="示例Dockerfile学习"></a>示例Dockerfile学习</h3><p>以下是官方的<code>Dockerfile</code>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方python镜像作为根镜像</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER <span class="string">"user_id&lt;email address&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /app 目录下</span></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外公开容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个环境变量world</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行 python app.py命令</span></span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="示例Dockerfile解读"><a href="#示例Dockerfile解读" class="headerlink" title="示例Dockerfile解读"></a>示例Dockerfile解读</h3><ul><li>FROM：FROM命令是<strong>必须的</strong>，<strong>可以是基于某个镜像</strong><ul><li><strong>从0开始构建</strong>：需要使用<code>scratch</code>，<code>scratch</code>代表着一个空白的镜像**，此时基本命令就是<code>FROM scratch</code>；</li><li>基于某个镜像：如上使用官方python镜像作为根镜像，所有的官方镜像可以在这个网站看到</li></ul></li><li>MAINTAINER：就是将维护人信息添加到脚本文件中，<strong>不一定需要，可有可无</strong></li><li>WORKDIR：定义工作目录</li><li><p>ADD：将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件拷贝到镜像中</p></li><li><p>RUN：用来执行基本命令的，基本格式有两种</p><ul><li>第一种是Shell格式：如上面安装包的命令以及<code>RUN npm install</code></li><li>第二种是exec格式：如<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ul></li></ul><p>由于<code>Dockerfile</code>每一个命令都会建立一层，RUN也不例外，在不必要的情况下使用多行RUN命令会使得镜像非常冗余和庞大，以下是一个示例:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p></p><p>类似上述例子，<strong>一共构建了7层镜像</strong>，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等，<strong>结果就是产生非常臃肿、非常 多层的镜像，不仅仅增加了构建部署的时间，也很容易出错</strong>。</p><p>正确写法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \ &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p></p><p>首先，之前所有的命令只有一个目的：编译、安装redis可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个RUN指令，并使用 <code>&amp;&amp;</code>将各个所需命令串联起来。将之前的7层，简化为了1层。其中每行命令后的 <code>\</code> 代表着换行，使dockerfile的RUN命令更具有可读性。</p><p>此外，命令的最后一行还有一个 <code>--auto-remove</code>命令，这个为<strong>清理工作</strong>的命令，<strong>删除了编译所需要的软件，清理下载以及展开的文件，并且还清理了apt缓存文件</strong>。由于镜像是一层一层构建的，每一层的多余东西并不会在下一层中被删除掉，到后面镜像会越来越大，因此<strong>清理这些没有用处的东西很有必要</strong>.</p><blockquote><p>RUN示例<a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">参考博客</a></p></blockquote><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile，其中安装Python所需要的依赖包时使用了文件进行安装，没有使用多行命令以及上述提及的使用<code>&amp;&amp;</code>的方法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p></p><p>示例的requirements.txt文件内容：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p></p><ul><li>EXPOSE：将指定的端口暴露出来，可以供外界访问，或者映射到宿主机的端口上去</li><li>CMD：容器启动命令，CMD命令和RUN命令相似，也是两种格式，分别为 <strong><code>shell</code>命令格式</strong>和 <strong><code>exec</code>命令格式</strong>。</li></ul><p>CMD 指令就是用于指定<strong>默认的容器主进程的启动命令的</strong>。在<code>exec</code>命令格式上，一般会被解析成json数组格式，<strong>需要用双引号，不能使用单引号!!!</strong></p><p>在了解了上述规则之后，我们看看最开始的示例Dockerfile的CMD命令：<code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>，属于 <strong><code>exec</code>命令格式</strong>，<strong>注意使用的是双引号</strong>，意思是<strong>容器使用Python运行app.py文件</strong>，至于具体的app.py文件信息就不列举了。</p><div class="note info"><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">各个参数的官方解释</a></p></div><hr><h3 id="动手测试Dockerfile"><a href="#动手测试Dockerfile" class="headerlink" title="动手测试Dockerfile"></a>动手测试Dockerfile</h3><p>基于上面对示例Dockerfile的学习，接下来自己建立自己的Dockerfile</p><h4 id="建立centos的测试"><a href="#建立centos的测试" class="headerlink" title="建立centos的测试"></a>建立centos的测试</h4><p>Dockerfile内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos7</span></span><br><span class="line">FROM centos:7</span><br><span class="line"><span class="comment"># 维护人信息</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"><span class="comment"># 看看是否安装了python以及版本</span></span><br><span class="line">CMD python -v</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="创建docker镜像"><a href="#创建docker镜像" class="headerlink" title="创建docker镜像"></a>创建docker镜像</h4><p>基于上述Dockerfile使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>建立镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker build -f .\Dockerfile  -t centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line"><span class="comment"># 第一步对应于第一行</span></span><br><span class="line">Step 1/4 : FROM centos:7</span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">8ba884070f61: Pull complete</span><br><span class="line">Digest: sha256:ca58fe458b8d94bc6e3072f1cfbd334855858e05e1fd633aa07cf7f82b048e66</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:7</span><br><span class="line"> ---&gt; 9f38484d220f</span><br><span class="line"><span class="comment"># 第二步对应于第二行</span></span><br><span class="line">Step 2/4 : MAINTAINER showteeth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 75f880e1b2d9</span><br><span class="line">Removing intermediate container 75f880e1b2d9</span><br><span class="line"> ---&gt; 9ea90a7b7832</span><br><span class="line"><span class="comment"># 第三步对应于第三行</span></span><br><span class="line">Step 3/4 : WORKDIR /orth</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 2c117f20ad92</span><br><span class="line">Removing intermediate container 2c117f20ad92</span><br><span class="line"> ---&gt; 07e0e346b57d</span><br><span class="line"><span class="comment"># 第四步对应于第四行 </span></span><br><span class="line">Step 4/4 : CMD python -v</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 297b155a52be</span><br><span class="line">Removing intermediate container 297b155a52be</span><br><span class="line"> ---&gt; 1f29d9e70fac</span><br><span class="line">Successfully built 1f29d9e70fac</span><br><span class="line">Successfully tagged centos:1.0</span><br><span class="line">SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have <span class="string">'-rwxr-xr-x'</span> permissions. It is recommended to double check and reset permissions <span class="keyword">for</span> sensitive files and directories.</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>创建完成之后使用命令<code>docker images</code>查看镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里信息和build命令以及输出信息的对应</span></span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                     1.0                 1f29d9e70fac        8 minutes ago       202MB</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>使用<code>docker run -it centos:1.0</code>运行镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/aliases.pyc matches /usr/lib64/python2.7/encodings/aliases.py</span></span><br><span class="line">import encodings.aliases <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/aliases.pyc</span></span><br><span class="line"><span class="comment"># /usr/lib64/python2.7/encodings/ascii.pyc matches /usr/lib64/python2.7/encodings/ascii.py</span></span><br><span class="line">import encodings.ascii <span class="comment"># precompiled from /usr/lib64/python2.7/encodings/ascii.pyc</span></span><br><span class="line">Python 2.7.5 (default, Oct 30 2018, 23:45:53)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">dlopen(<span class="string">"/usr/lib64/python2.7/lib-dynload/readline.so"</span>, 2);</span><br><span class="line">import readline <span class="comment"># dynamically loaded from /usr/lib64/python2.7/lib-dynload/readline.so</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p></p><p><strong>如上，运行之后自动运行了<code>python -v</code>，因为前面的Dockerfile的<code>CMD</code>写的就是这个命令</strong>，如果没有Python，可以参考这个链接来<a href="https://www.centos.bz/2018/01/%E5%9C%A8centos%E4%B8%8A%E5%AE%89%E8%A3%85python3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">安装Python</a></p><hr><h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h4><p>由于开始的时候设置了<code>CMD python -v</code>，导致镜像运行之后自动进入Python程序，退出Python之后也退出了整个docker环境，所以想知道可不可以修改CMD命令，查询<a href="https://serverfault.com/questions/594281/how-can-i-override-cmd-when-running-a-docker-image" target="_blank" rel="noopener">相关文档</a>之后，可以使用如下进行修改：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --entrypoint=/bin/bash <span class="variable">$IMAGE</span> -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如我可以使用如下命令进入bash shell的交互环境</span></span><br><span class="line">docker run -it --entrypoint=/bin/bash centos:1.0 -i</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="退出、关闭、重启镜像"><a href="#退出、关闭、重启镜像" class="headerlink" title="退出、关闭、重启镜像"></a>退出、关闭、重启镜像</h4><ul><li>使用命令<code>exit</code>来<strong>退出</strong>正在使用的镜像，注意退出之后并没有关闭，后台还在运行，使用<code>docker ps -a</code>可看到</li><li>使用<code>docker stop image_id|name</code>来关闭镜像</li></ul><hr><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>测试版本镜像和真正想要使用的镜像有很大差距，所以打算直接删掉重新创建一个镜像：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有的container，这样才能够删除其中的images：</span></span><br><span class="line">docker stop $(docker ps -a -q)   <span class="comment"># Linux下可以这么使用，windows还是单个单个操作吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要删除 所有container 的话再加一个指令：</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前有些什么images</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除images，通过image的 id 来指定删除谁，注意和上面的删除容器相区分</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print <span class="variable">$3</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除 全部 image的话</span></span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>注意：运行docker时docker desktop必须也在运行，而且不要关闭，一旦关闭，正在运行的container会直接退出</p></div><hr><h3 id="编写Dockfile"><a href="#编写Dockfile" class="headerlink" title="编写Dockfile"></a>编写Dockfile</h3><h4 id="准备文件信息"><a href="#准备文件信息" class="headerlink" title="准备文件信息"></a>准备文件信息</h4><ul><li>blast软件包</li><li>python相关运行文件</li><li>初始文件(fasta文件)</li><li>相关的脚本</li></ul><hr><h4 id="正式的Dockerfile"><a href="#正式的Dockerfile" class="headerlink" title="正式的Dockerfile"></a>正式的Dockerfile</h4><p>经过上述所有的学习和尝试，这里给出了最终可以运行的Dockerfile：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用centos镜像</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行定义的是维护人和维护人邮箱，由MAINTAINER开头</span></span><br><span class="line">MAINTAINER showteeth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器工作目录设置为 /orth</span></span><br><span class="line">WORKDIR /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（宿主机）中的内容全部复制到容器的 /orth 目录下</span></span><br><span class="line">ADD . /orth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 requirements.txt 中定义好的包</span></span><br><span class="line">RUN yum -y install epel-release \</span><br><span class="line">&amp;&amp; yum -y install python-pip \ </span><br><span class="line">&amp;&amp; yum -y install vim \</span><br><span class="line">&amp;&amp; pip install -r requirements.txt \</span><br><span class="line">&amp;&amp; chmod 744 /orth/scripts/docker_blast.sh \</span><br><span class="line">&amp;&amp; tar -zxvf /orth/ncbi-blast-2.8.1+-x64-linux.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将blast加入环境变量</span></span><br><span class="line">ENV PATH /orth/ncbi-blast-2.8.1+/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器启动时，运行命令</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p></p><p>上面使用ADD没有执行自动解压操作，后续添加了自动解压操作，这个是官方的一个<a href="https://github.com/docker/docker-ce/releases/tag/v17.06.0-ce" target="_blank" rel="noopener">issue</a>，后续版本会改进。</p><hr><h4 id="创建和运行镜像"><a href="#创建和运行镜像" class="headerlink" title="创建和运行镜像"></a>创建和运行镜像</h4><ul><li>创建镜像：<code>docker build -f .\Dockerfile -t orth_project:2.0 .</code></li><li>运行镜像：<code>docker run -it orth_project:2.0</code></li><li>在镜像中使用<code>bash /orth/scripts/docker_blast.sh</code>运行查找同源基因的程序</li></ul><hr><p><br></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>主要步骤如下：</p><ul><li>第一步：开通<a href="https://cr.console.aliyun.com/new/new" target="_blank" rel="noopener">阿里云镜像服务</a></li><li>第二步：创建镜像仓库</li><li>第三步：推送镜像</li><li>第四步：查找验证镜像</li></ul><p>首先是开通阿里云镜像服务：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/开通阿里云镜像服务" alt="开通阿里云镜像服务"></p><hr><p>接下来创建镜像仓库：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库.png" alt="创建镜像仓库"><br><strong>仓库类型选择公开</strong><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/创建镜像仓库_2.png" alt="创建镜像仓库_2.png"><br><strong>代码源选择本地仓库</strong></p><hr><p>创建完成镜像仓库后，点击刚刚创建的镜像的管理，发现如下信息：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/推送镜像.png" alt="推送镜像.png"><br>然后，就可以按照上述图片中的提示完成镜像的推送，下面也列出了镜像推送的命令：</p><ul><li><code>docker login --username=username registry.cn-beijing.aliyuncs.com</code>输入这一步需要验证密码，验证成功会显示<code>Login Succeeded</code></li><li><code>docker tag [ImageId] registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这一步前面的<code>[ImageId]</code>使用<code>docker images</code>查看，<code>[镜像版本号]</code>是你上传上去想要显示的版本号，运行完成没有输出信息</li><li><code>docker push registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code>这里的<code>[镜像版本号]</code>是你上传上去想要显示的版本号，和上一步的保持一致，这一步完成会显示如下信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The push refers to repository [registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project]</span><br><span class="line">788a64a2f222: Pushed</span><br><span class="line">f652370971d2: Pushed</span><br><span class="line">d245b64a20a7: Pushed</span><br><span class="line">d69483a6face: Pushed</span><br><span class="line">1.0: digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7 size: 1161</span><br></pre></td></tr></table></figure></li></ul><div class="note info"><p>上传完成镜像后，本地也会出现一个名为<code>registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project</code>的镜像(<strong>该镜像具有和原始镜像相同的iamge id</strong>)，可以删除，通过命令<code>docker rmi -f registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</code>删除</p></div><hr><p>最后是查找验证镜像，经过上面几步已经成功将镜像上传到阿里云，接下来到阿里云中搜索自己刚刚上传的镜像：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索.png" alt="镜像搜索.png"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像搜索结果.png" alt="镜像搜索结果.png"></p><hr><p><br></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>在上述查询到镜像结果之后，点击<strong>查看镜像的详细信息</strong>：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/镜像的详细信息.png" alt="镜像的详细信息.png"></p><p><strong>复制公网地址</strong>并<strong>使用如下命令拉取镜像</strong>：<code>docker pull registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:[镜像版本号]</code></p><div class="note info"><p><strong>注意这个<code>[镜像版本号]</code>一定要指定，因为可能会存在很多版本号，这里指定后会拉取指定版本</strong></p></div><p>运行完成之后输出如下信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0: Pulling from showteeth/orth_blast_project</span><br><span class="line">Digest: sha256:2bf8b43babcdecbd0d06dda78e3b585439e17b07642f1445f7911563afb98ca7</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-beijing.aliyuncs.com/showteeth/orth_blast_project:1.0</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="build-with-gRPC-error"><a href="#build-with-gRPC-error" class="headerlink" title="build with gRPC error"></a>build with gRPC error</h3><p>使用命令<code>docker build -f .\Dockerfile -t centos:1.0 .</code>报错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[0000] failed to dial gRPC: cannot connect to the Docker daemon. Is <span class="string">'docker daemon'</span> running on this host?: open //./pipe/docker_engine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure><p></p><p><strong>解决办法</strong>：<br>在Github上看到了类似的<a href="https://github.com/docker-library/docker/issues/71" target="_blank" rel="noopener">issue</a>，主要的解决方法是在docker的设置中开启experimental features，如下图：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/experimental_features" alt="experimental_features"></p><p><strong>开启完成之后就解决了问题</strong></p><hr><h3 id="docker-image-is-being-used"><a href="#docker-image-is-being-used" class="headerlink" title="docker image is being used"></a>docker image is being used</h3><p>在使用<code>docker rmi 20ffdd2f28c0</code>删除镜像是发现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: conflict: unable to delete 20ffdd2f28c0 (must be forced) - image is being used by stopped container 7356c1e7efc0</span><br></pre></td></tr></table></figure><p></p><p><strong>解决方法：</strong></p><ul><li><p>先删除上面提示的那个占用当前镜像的<code>7356c1e7efc0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm  7356c1e7efc0</span><br></pre></td></tr></table></figure></li><li><p>然后再使用命令<code>docker rmi 20ffdd2f28c0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 20ffdd2f28c0</span><br></pre></td></tr></table></figure></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/f06b1e4dfad4" target="_blank" rel="noopener">Docker工作基本流程</a></li><li><a href="https://yq.aliyun.com/articles/596352" target="_blank" rel="noopener">Docker初体验，向Docker Hub推送第一个Docker镜像</a></li><li><a href="https://blog.csdn.net/qq_34680763/article/details/79711567" target="_blank" rel="noopener">第一次构建、运行、发布、获取docker镜像</a></li><li><a href="https://www.jianshu.com/p/4971967f7d3c" target="_blank" rel="noopener">Docker入门（二）创建您的第一个Docker镜像</a></li><li><a href="http://dockone.io/article/783" target="_blank" rel="noopener">10张图带你深入理解Docker容器和镜像</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-博客转载项目</title>
      <link href="/posts/26003.html"/>
      <url>/posts/26003.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这个项目主要是基于在转载博客时直接复制HTML后期不好修改，不能像Markdown一样生成大纲，不易管理，所以这里想做这样一个项目，<a href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener">项目地址</a>。</p></div><a id="more"></a><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="HTML装换为markdown"><a href="#HTML装换为markdown" class="headerlink" title="HTML装换为markdown"></a>HTML装换为markdown</h3><p>要想实现博客的装载，其中HTML装换为markdown是最为关键的一步，目前github上使用较多的(star较多)的HTML装换为markdown工具有三个：</p><ul><li><a href="https://github.com/domchristie/turndown" target="_blank" rel="noopener">turndown</a>，使用javascript代码，有<a href="http://domchristie.github.io/turndown/" target="_blank" rel="noopener">网页版</a>可以使用，比较好用，如果没有太大需要可以使用这个</li><li><a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener">html2text</a>，使用Python代码，可以嵌入其他程序使用，比较方便(很多印象笔记转文本的都是使用这个的)，这次我也打算使用这个</li><li><a href="https://github.com/gaojiuli/tomd" target="_blank" rel="noopener">tomd</a>，这个也是使用Python代码，但是star没有前面一个高，作为备用吧</li></ul><hr><h4 id="html2text使用"><a href="#html2text使用" class="headerlink" title="html2text使用"></a>html2text使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> html2text</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (html2text.html2text(<span class="string">"&lt;p&gt;Hello, world.&lt;/p&gt;"</span>))</span><br><span class="line">Hello, world.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = html2text.HTML2Text()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (h.handle(<span class="string">"&lt;p&gt;Hello, &lt;a href='http://earth.google.com/'&gt;world&lt;/a&gt;!"</span>))</span><br><span class="line">Hello, [world](http://earth.google.com/)!</span><br></pre></td></tr></table></figure><hr><h3 id="爬取网站内容"><a href="#爬取网站内容" class="headerlink" title="爬取网站内容"></a>爬取网站内容</h3><p>有了HTML装换markdown的工具，还需要使用工具将网页内容爬取下来，这里使用Python爬虫实现。</p><ul><li>XPATH和selector都可以通过右键复制得到</li><li><code>Selenium</code>模拟登陆很好用</li></ul><hr><h3 id="博客园、CSDN、简书博客"><a href="#博客园、CSDN、简书博客" class="headerlink" title="博客园、CSDN、简书博客"></a>博客园、CSDN、简书博客</h3><p>这几个网站作为统一的博客平台，爬虫时选取的部位固定，所以直接内置了.</p><hr><h3 id="其他自建博客"><a href="#其他自建博客" class="headerlink" title="其他自建博客"></a>其他自建博客</h3><p><strong>需要给双引号增加转义</strong>，如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python blog_parse.py -u http://rvdsd.top/2017/09/22/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-13%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/ -b others -c //*[@id=\<span class="string">"posts\"]/article/div/div -t //*[@id=\"posts\"]/article/div/header/h1</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h3><p>网上有将印象笔记先到处enex格式文件，然后根据这个文件进行转换格式的工具，但是我使用后发现并不好用.所以这里的想法是先将印象笔记分享为html的形式，然后再进行html转换为markdown，这样应该效果会好很多。</p><ul><li><a href="https://dev.yinxiang.com/doc/" target="_blank" rel="noopener">印象笔记开发者文档</a></li><li><a href="https://dev.yinxiang.com/doc/start/python.php" target="_blank" rel="noopener">印象笔记 Python SDK 快速入门指南</a></li></ul><h4 id="申请印象笔记-API-Key"><a href="#申请印象笔记-API-Key" class="headerlink" title="申请印象笔记 API Key"></a>申请印象笔记 API Key</h4><p>见官网教程</p><hr><h4 id="下载印象笔记-Python-SDK"><a href="#下载印象笔记-Python-SDK" class="headerlink" title="下载印象笔记 Python SDK"></a>下载印象笔记 Python SDK</h4><p>不要使用官网的那个链接，使用<a href="https://github.com/evernote/evernote-sdk-python3" target="_blank" rel="noopener">Python3的版本</a>，然后执行：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="测试-SDK"><a href="#测试-SDK" class="headerlink" title="测试 SDK"></a>测试 SDK</h4><p>进入Python环境，尝试导入包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\evernote3-1.25.0-py3.7.egg\evernote\api\client.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'oauth2'</span></span><br></pre></td></tr></table></figure><p></p><p>按照上面的提示，安装oauth2包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install oauth2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再进入Python环境</span></span><br><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"><span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>常规的按照印象笔记网站上的步骤，但是进行的过程中发现使用网站上的代码一直报错：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码</span></span><br><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">dev_token = <span class="string">"personal taken"</span></span><br><span class="line">client = EvernoteClient(token=dev_token,sandbox=<span class="keyword">False</span>,service_host=<span class="string">'app.yinxiang.com'</span>)</span><br><span class="line">userStore = client.get_user_store()</span><br><span class="line">user = userStore.getUser()</span><br><span class="line"><span class="keyword">print</span> (user.username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">evernote.edam.error.ttypes.EDAMSystemException: EDAMSystemException(message=<span class="string">'authenticationToken'</span>, errorCode=<span class="number">8</span>, rateLimitDuration=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><p>在官方文档的各种地方查找都没有找到合适的方法，最后在<a href="https://www.tuicool.com/articles/2MV3QvU" target="_blank" rel="noopener">这篇文章中</a>找到了解决方案：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evernote.api.client <span class="keyword">import</span> EvernoteClient</span><br><span class="line"></span><br><span class="line">dev_token = <span class="string">"personla taken"</span></span><br><span class="line">client = EvernoteClient(token=dev_token,sandbox=<span class="keyword">False</span>,service_host=<span class="string">'app.yinxiang.com'</span>)</span><br><span class="line">userStore = client.get_user_store()</span><br><span class="line">user = userStore.getUser()</span><br><span class="line"><span class="keyword">print</span> (user.username)</span><br></pre></td></tr></table></figure><p></p><p>吐槽一句：<strong>印象笔记的官方文档实在是太差了！！！忍不了！！！</strong></p><div class="note info"><p><a href="https://www.tuicool.com/articles/2MV3QvU" target="_blank" rel="noopener">这篇文章中</a>解决问题的步骤很值得我们学习，查看源码，找出问题，然后解决问题，很关键。</p></div><hr><h4 id="NoteStore-笔记本仓库"><a href="#NoteStore-笔记本仓库" class="headerlink" title="NoteStore-笔记本仓库"></a>NoteStore-笔记本仓库</h4><p>NoteStore 是用来创建、更新和删除笔记、笔记本还有其他在用户帐户中可找到的印象笔记的数据的。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">noteStore = client.get_note_store()</span><br><span class="line">notebooks = noteStore.listNotebooks()</span><br><span class="line"><span class="comment"># 输出笔记本的名称</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> notebooks:</span><br><span class="line">    <span class="keyword">print</span> (n.name)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出内容</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的第一个笔记本</span><br><span class="line">导入的笔记</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="Notebook-笔记本"><a href="#Notebook-笔记本" class="headerlink" title="Notebook-笔记本"></a>Notebook-笔记本</h4><ul><li>通过NoteStore类的<code>listNotebooks</code>方法可以获取一个<strong>包含所有笔记本的列表</strong></li><li><strong>在客户端视图中存在笔记本的嵌套，但实际上数据存储中所有笔记本都在同一层</strong></li><li>其下的笔记<strong>并不能通过该类的某个属性或者方法获取</strong></li><li>不管笔记本为空还是有笔记，属性都会有值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> notebook <span class="keyword">in</span> noteStore.listNotebooks():</span><br><span class="line"><span class="comment"># 得到笔记本的名字</span></span><br><span class="line">    notebookName = notebook.name</span><br><span class="line">    <span class="comment"># 得到笔记本的guid</span></span><br><span class="line">    notebookGuid = notebook.guid</span><br><span class="line">    print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(notebookName, notebookGuid))</span><br></pre></td></tr></table></figure><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我的第一个笔记本: dd36443d<span class="number">-2</span>ef1<span class="number">-4289</span>-aeb6<span class="number">-527e57</span>ce173b</span><br><span class="line">导入的笔记: <span class="number">5</span>c1dd2ec<span class="number">-8e0</span>a<span class="number">-4</span>a6e-b5f0<span class="number">-22507</span>c178086</span><br><span class="line">笔记本<span class="number">2</span>: <span class="number">3</span>f683ab0<span class="number">-4</span>ea7<span class="number">-4</span>ffb<span class="number">-800</span>d<span class="number">-4</span>c0864413c4b</span><br><span class="line">笔记本<span class="number">1</span>: <span class="number">61</span>bb02cd<span class="number">-1</span>fc2<span class="number">-404e-9</span>bc6<span class="number">-2</span>c20555dedec</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="enml-to-markdown"><a href="#enml-to-markdown" class="headerlink" title="enml to markdown"></a>enml to markdown</h4><ul><li><a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="noopener">enml格式讲解</a></li><li>不合算，放弃</li></ul><hr><h4 id="爬取动态页面"><a href="#爬取动态页面" class="headerlink" title="爬取动态页面"></a>爬取动态页面</h4><p>使用selenium模拟登陆</p><p><strong>遇到的问题</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\site-packages\selenium\webdriver\common\service.py"</span>, line <span class="number">76</span>, <span class="keyword">in</span> start</span><br><span class="line">    stdin=PIPE)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">769</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    restore_signals, start_new_session)</span><br><span class="line">  File <span class="string">"C:\Users\14910\Anaconda3\lib\subprocess.py"</span>, line <span class="number">1172</span>, <span class="keyword">in</span> _execute_child</span><br><span class="line">    startupinfo)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。</span><br></pre></td></tr></table></figure><p></p><p>这是因为没有将浏览器驱动以及没有将浏览器驱动添加到环境变量：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 驱动下载地址</span></span><br><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载对应的chrome版本之后将压缩包解压，我下载的是chromedriver_win32.zip</span></span><br><span class="line"><span class="comment"># 发现32位的也能用，关键是只提供了32位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压上述包，然后将exe文件写入环境变量，可将exe文件放在C:\Program Files (x86)\Google\Chrome\Application目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量(可能需要重启电脑才会生效)之后直接输入</span></span><br><span class="line">chromedriver.exe</span><br><span class="line">Starting ChromeDriver <span class="number">72.0</span><span class="number">.3626</span><span class="number">.69</span> (<span class="number">3</span>c16f8a135abc0d4da2dff33804db79b849a7c38) on port <span class="number">9515</span></span><br><span class="line">Only local connections are allowed.</span><br><span class="line">Please protect ports used by ChromeDriver <span class="keyword">and</span> related test frameworks to prevent access by malicious code.</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="博客园、CSDN、简书博客-1"><a href="#博客园、CSDN、简书博客-1" class="headerlink" title="博客园、CSDN、简书博客"></a>博客园、CSDN、简书博客</h3><ul><li>博客园：<code>python blog_parse.py -u https://www.cnblogs.com/zhaof/p/6953241.html -p C:/Users/14910/Desktop</code></li><li>CSDN：<code>python blog_parse.py -b csdn -u https://blog.csdn.net/work_you_will_see/article/details/84638750 -p C:/Users/14910/Desktop</code></li><li>简书博客：<code>python blog_parse.py -b jianshu -u https://www.jianshu.com/p/95331e7a98cd -p C:/Users/14910/Desktop</code></li></ul><hr><h3 id="自建博客"><a href="#自建博客" class="headerlink" title="自建博客"></a>自建博客</h3><ul><li><p>得到title的xpath：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/得到title的xpath.png" alt="得到title的xpath.png"></p></li><li><p>得到content的xpath：<br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/得到content的xpath.png" alt="得到content的xpath.png"></p></li><li><p>使用命令：<code>python blog_parse.py -b others -c //*[@id=\&quot;posts\&quot;]/article/div/div[1] -t //*[@id=\&quot;posts\&quot;]/article/div/header/h1 -u http://showteeth.tech/posts/56982.html -p C:/Users/14910/Desktop</code></p></li></ul><hr><h3 id="印象笔记-1"><a href="#印象笔记-1" class="headerlink" title="印象笔记"></a>印象笔记</h3><ul><li>将笔记<a href="https://help.evernote.com/hc/sr-me/articles/213420097-%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E7%AC%94%E8%AE%B0-" target="_blank" rel="noopener">导出单个html文件</a></li><li>将图片上传到图床，如果上传到图床的某个文件夹，需要指定下面的<code>-f</code>参数</li><li>使用命令：<code>python blog_parse.py -l &quot;C:/Users/14910/Desktop/VS code配置.html&quot; -f VS_code配置 -b evernote</code></li></ul><hr><p><br></p><h2 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h2><ul><li style="list-style:none"><input type="checkbox" checked> 启动这个项目 2019-3-21</li><li style="list-style:none"><input type="checkbox" checked> 印象笔记转载-API<ul><li style="list-style:none"><input type="checkbox" checked> 爬虫的方法，enml-这个就相当于使用印象笔记转markdown的那些工具，<mark>效果不好</mark></li><li style="list-style:none"><input type="checkbox" checked> 爬虫，模拟登陆— failed</li><li style="list-style:none"><input type="checkbox" checked> 既然能够模拟登陆了，那就不用在使用分享链接了啊，直接在网页版的印象笔记操作即可—&gt; <code>failed</code></li></ul></li><li style="list-style:none"><input type="checkbox" checked> 博客园</li><li style="list-style:none"><input type="checkbox" checked> CSDN</li><li style="list-style:none"><input type="checkbox" checked> 其他自建博客</li><li style="list-style:none"><input type="checkbox" checked> 爬取文章标题作为新建的markdown文件的标题</li><li style="list-style:none"><input type="checkbox" checked> 提供多种方法，加上另一个html转markdown的工具—&gt;<code>do not have the need</code></li><li style="list-style:none"><input type="checkbox" checked> 图片链接会自动换行，导致图片显示不出来 <code>fixed with set body_width = 0</code></li><li><p>[ ] 图片保留html形式，设置images_as_html=True，但没有起作用</p></li><li><p>[x] 印象笔记导出之前需要将其图片名称进行修改—&gt;两图片的空格替换为<code>%20</code></p></li><li style="list-style:none"><input type="checkbox" checked> 参数分组</li><li style="list-style:none"><input type="checkbox"> 爬取整个博客然后转化为markdown(不是很实用)</li><li style="list-style:none"><input type="checkbox"> 增加配置文件</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/littlecodersh/EasierLife" target="_blank" rel="noopener">EasierLife</a></li><li><a href="https://github.com/muzizongheng/Python/blob/master/Utility/Evernote2Blog/Main.py" target="_blank" rel="noopener">Evernote2Blog</a></li><li><a href="https://www.jianshu.com/p/bda26798f3b3" target="_blank" rel="noopener">使用Python操作Evernote API</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text3使用以及配置</title>
      <link href="/posts/53131.html"/>
      <url>/posts/53131.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要记录了在学习和使用sublime text编辑器过程中对其进行的配置和优化，包括一些插件的用法，便于后续使用和查询</p></div><a id="more"></a><h2 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h2><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="显示目录插件"><a href="#显示目录插件" class="headerlink" title="显示目录插件"></a>显示目录插件</h3><p>使用的是<strong>插件</strong>：<a href="https://github.com/warmdev/SublimeOutline" target="_blank" rel="noopener">SublimeOutline</a></p><p><strong>显示效果</strong>：</p><p><br><a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/warmdev/SublimeOutline/master/screenshot.png"><img src="https://raw.githubusercontent.com/warmdev/SublimeOutline/master/screenshot.png" alt="Screenshot" title="Screenshot" style="max-width:100%"></a><br></p><p><strong>具体使用</strong>：</p><ul><li><strong>打开</strong>侧边栏：<code>ctrl + shift + p</code>打开命令框，然后再输入<code>Browse Mode: Outline (Right)</code></li><li><strong>关闭</strong>侧边栏：<code>ctrl + shift + p</code>打开命令框，然后再输入<code>Browse mode: Close sidebar(s)</code></li></ul><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime text3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图床-阿里云+PicGo上传照片</title>
      <link href="/posts/41221.html"/>
      <url>/posts/41221.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要是关于使用阿里云搭建图床以及使用PicGo进行上传照片的操作，便与后续查询使用</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来图床使用的是七牛的服务，但是前几天七牛给我发了一封”测试域名回收通知”的邮件，看了邮件，然后查看相关说明发现如果想要使用就有添加自己的域名，然后为了添加自己的域名还要去公安部备案，尝试了一下，太麻烦了，然后看了一下关于阿里和腾讯的，本着天下没有免费的午餐的理念，我选择了阿里(腾讯的存储不要钱)，然后就有了接下来的故事。</p><h2 id="开通阿里云oss"><a href="#开通阿里云oss" class="headerlink" title="开通阿里云oss"></a>开通阿里云oss</h2><p>主要流程：实名认证—&gt;开通对象存储服务 OSS—&gt;购买资源包—&gt;新建Bucket</p><p>购买资源包的时候可以选取资源包类型和规格等信息，按照自己的需求选取即可，我这里选择的是存储包以及40G大小，作为博客图片应该是足够用了(如果有再小一点的我肯定就选了)。</p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/阿里oss.png"><br></div><p>关于阿里oss收费，比较复杂，主要包括：存储容量，流量，请求次数。刚刚购买的只是存储容量，具体的收费详情请查看<a href="https://www.aliyun.com/price/product?spm=5176.7933691.744462.c1.79ba6a56EQXVX5#/oss/detail" target="_blank" rel="noopener">这个链接</a></p><p>接下来就是新建Bucket了，我按照如下选项进行的创建：</p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/阿里oss_2.png"><br></div><hr><h2 id="使用PicGo上传图片"><a href="#使用PicGo上传图片" class="headerlink" title="使用PicGo上传图片"></a>使用PicGo上传图片</h2><p>PicGo是一款图片上传的工具，目前支持微博图床、七牛图床、腾讯云、又拍云、GitHub、阿里等主流图床，并且支持macOS、windows 64位（&gt;= v1.3.1），linux（&gt;= v1.6.0），可是说是全平台很强大了，这是<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Github链接</a>、这是<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">官方网站</a></p><p>下载并安装之后进入图床设置，选择对应的图床，我这里选取了阿里oss：</p><div align="center"><br><img src="https://i.loli.net/2019/03/20/5c92335ee931f.png"><br></div><ul><li>accesskey和accesskeySecret可以从阿里云控制台获取(就在新建Bucket旁边)</li><li>存储空间名是bucket的名字</li><li>存储区域按照提示填写(在bucket的访问域名中可以看到)</li><li>存储路径按照提示填写</li><li>自定义域名可以不填写</li></ul><h3 id="PicGo插件使用"><a href="#PicGo插件使用" class="headerlink" title="PicGo插件使用"></a>PicGo插件使用</h3><p>这里给出的<a href="https://github.com/PicGo/Awesome-PicGo/blob/master/README.md" target="_blank" rel="noopener">PicGo</a>中包含的插件，我觉得比较好的是<a href="https://github.com/Spades-S/vs-picgo/blob/master/README_ZH.md" target="_blank" rel="noopener">vs-picgo</a>，其可以在vscode中使用，刚好自己使用的就是vscode，所以非常方便，这里记录这个插件的主要用法。</p><ul><li>安装插件，直接在vscode应用商店中搜索PicGo即可</li><li><p><strong>配置插件</strong>：<br><strong>修改vscode的<code>setting.json</code>文件</strong>，加入如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 其中的XXX使用自己的信息填写进去</span><br><span class="line">"picgo": &#123;</span><br><span class="line">  "path": ""</span><br><span class="line">&#125;,</span><br><span class="line">"picBed": &#123;</span><br><span class="line">  "current": "aliyun",</span><br><span class="line">  "aliyun": &#123;</span><br><span class="line">    "accessKeyId": "XXX",</span><br><span class="line">    "accessKeySecret": "XXX",</span><br><span class="line">    "bucket": "XXX",</span><br><span class="line">    "area": "XXX",</span><br><span class="line">    "path": "XXX",</span><br><span class="line">    "customUrl": ""</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>插件上传的图片<strong>不会显示在PicGo软件的相册</strong>中，直接上传在了阿里云</p></li><li>如果想要<strong>对上传的图片更改名称</strong>，可以<strong>先选中名称</strong>，然后<strong>再插入图片</strong></li><li>上传<strong>只支持markdown的链接</strong>，<strong>不支持其他类型(如html)链接</strong>，这个<strong>没有PicGo桌面版好用</strong></li><li>支持从剪贴板、文件选取以及输入框上床，对应的快捷键如下：<blockquote><ul><li><code>ctrl+alt+u</code>：<strong>剪贴板</strong>图片上传</li><li><code>ctrl+alt+e</code>：打开<strong>文件管理器</strong>上传</li><li><code>ctrl+alt+o</code>：打开<strong>输入框输入路径</strong>上传</li></ul></blockquote></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python系列之argparse-命令行选项与参数解析</title>
      <link href="/posts/19941.html"/>
      <url>/posts/19941.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了Python用于解析命令行参数的<code>argparse</code>模块，按照其使用过程依次学习了<strong>生成参数分析器</strong>、<strong>添加参数</strong>、<strong>参数解析</strong>和<strong>输出传入参数值</strong>，最后还学习了<strong>参数群组</strong>、比较强大的<strong>创建子命令</strong>以及<strong>互斥参数组</strong>的使用。</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>argparse</code>是 <code>Python</code> 标准库中用来解析命令行参数和选项的模块，很早之前就想学习和使用这个模块了，但由于种种原因没能实现；之前一直使用的是<code>sys</code>模块的<code>argv</code>来传递参数，但是这种传递参数的方法比较简单，不能输出一些提示信息，导致有些脚本很久之后再看可能不知道当时设置的参数的含义或者需要打开具体的脚本才能知道参数的含义，比较麻烦，所以这里来对<code>argparse</code>进行学习，在以后的脚本中替换<code>sys</code>模块。</p><hr><h2 id="初识argparse"><a href="#初识argparse" class="headerlink" title="初识argparse"></a>初识argparse</h2><p>创建python文件(<strong>注意不要将文件命名为argparse.py，不然会报错，因为文件名和模块名相同，导入会出问题</strong>)，并在其中写入如下代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成参数分析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出传入参数值 </span></span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><p></p><p>运行上述python文件：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–sum] N [N …]</p><p>Process some integers.</p><p>positional arguments:<br>N an integer for the accumulator</p><p>optional arguments:<br>-h, –help show this help message and exit<br>–sum sum the integers (default: find the max)</p></blockquote><p>从上述输出结果可以发现：<code>argparse</code>会自动生成帮助文档，也就是说即使在程序中不添加任何参数，<strong><code>argparse</code>也会自动默认生成一个参数<code>-h</code></strong>，用于输出帮助文档</p><p>在上述<code>argparse</code>使用过程中依次经过了<strong>生成参数分析器</strong>、<strong>添加参数</strong>、<strong>参数解析</strong>和<strong>输出传入参数值</strong>这几步，接下来我就按照这个顺序进行学习。</p><hr><h2 id="创建解析器-ArgumentParser类"><a href="#创建解析器-ArgumentParser类" class="headerlink" title="创建解析器-ArgumentParser类"></a>创建解析器-ArgumentParser类</h2><p>上述argparse测试代码中使用<code>argparse.ArgumentParser()</code>创建参数分析器也就是解析器，这里就先对这个解析器进行一定的了解，其原型如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">argparse</span>.<span class="title">ArgumentParser</span><span class="params">(prog=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                usage=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                description=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                epilog=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                parents=[], </span></span></span><br><span class="line"><span class="class"><span class="params">                formatter_class=argparse.HelpFormatter,</span></span></span><br><span class="line"><span class="class"><span class="params">                prefix_chars=<span class="string">'-'</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">                fromfile_prefix_chars=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                argument_default=None, </span></span></span><br><span class="line"><span class="class"><span class="params">                conflict_handler=<span class="string">'error'</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">                add_help=True,</span></span></span><br><span class="line"><span class="class"><span class="params">                allow_abbrev=True)</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>其中参数的含义</strong>：</p><style>table th:first-of-type{width:30%}table th:nth-of-type(2){width:50%}table th:nth-of-type(3){width:20%}</style><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>prog</td><td>程序的名字，help中显示的</td><td><code>sys.argv[0]</code></td></tr><tr><td>usage</td><td>描述程序用途的字符串</td><td>从解析器的参数生成</td></tr><tr><td>description</td><td>参数帮助信息之前的文本</td><td>none</td></tr><tr><td>epilog</td><td>参数帮助信息之后的文本</td><td>none</td></tr><tr><td>parents</td><td><code>ArgumentParser</code> 对象的一个列表，这些对象的参数应该包括进去(参数继承)</td><td></td></tr><tr><td>formatter_class</td><td>定制化输出的帮助信息</td><td></td></tr><tr><td>prefix_chars</td><td>可选参数的前缀字符</td><td>‘-‘</td></tr><tr><td>fromfile_prefix_chars</td><td>从文件中读取参数时文件的前缀字符</td><td>None</td></tr><tr><td>argument_default</td><td>参数的全局默认值</td><td>None</td></tr><tr><td>conflict_handler</td><td>解决冲突的可选参数的策略（通常没有必要）</td><td></td></tr><tr><td>add_help</td><td>解析器添加-h/–help 选项</td><td>True</td></tr><tr><td>allow_abbrev</td><td>如果前缀是明确的，则允许缩写长参数</td><td>True</td></tr></tbody></table><h3 id="proc-help中描述程序的名称"><a href="#proc-help中描述程序的名称" class="headerlink" title="proc-help中描述程序的名称"></a>proc-help中描述程序的名称</h3><p><code>proc</code>参数代表程序的名字，默认为<code>sys.argv[0]</code>，<strong>用来在help信息中描述程序的名称</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改上述代码解析器的部分如下</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br></pre></td></tr></table></figure><p></p><p>并使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: <strong><em>myprogram</em></strong> [-h]</p></blockquote><p>发现<code>usage</code>后面接着的文字由默认的<code>argparse_test.py(sys.argv[0])</code>变成了现在的<code>prog=&#39;myprogram&#39;</code>定义的内容</p><hr><h3 id="usage-描述程序用途"><a href="#usage-描述程序用途" class="headerlink" title="usage-描述程序用途"></a>usage-描述程序用途</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以结合proc一起使用</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>, usage=<span class="string">'%(prog)s is a test of argparse'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: <strong>myprogram is a test of argparse</strong></p></blockquote><p>发现<code>usage</code>后面接着的文字由默认的<code>argparse_test.py [-h]</code>变成了现在的<code>myprogram is a test of argparse</code></p><hr><h3 id="description和epilog-程序描述信息，help-信息前后的文字"><a href="#description和epilog-程序描述信息，help-信息前后的文字" class="headerlink" title="description和epilog-程序描述信息，help 信息前后的文字"></a>description和epilog-程序描述信息，help 信息前后的文字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'before help'</span>,epilog=<span class="string">"after help"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [-h]</p><p><strong>before help</strong></p><p>optional arguments:<br>-h, –help show this help message and exit</p><p><strong>after help</strong></p></blockquote><hr><h3 id="prefix-chars-参数前缀"><a href="#prefix-chars-参数前缀" class="headerlink" title="prefix_chars-参数前缀"></a>prefix_chars-参数前缀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prefix_chars=<span class="string">'+'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py +h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [<strong>+</strong>h]</p><p>optional arguments:<br><strong>+</strong>h, <strong>++</strong>help show this help message and exit</p></blockquote><hr><h3 id="parents-参数继承"><a href="#parents-参数继承" class="headerlink" title="parents-参数继承"></a>parents-参数继承</h3><p>我们常常需要实现一套命令行程序，这些程序都带一组参数，只是<strong>在某些方面有特殊化</strong>。例如，如果所有程序都需要在用户进行任何实际的操作之前对用户进行认证，那么它们就<strong>都需要支持<code>--user</code>和<code>--password</code>选项</strong>。你可以共享的选项来定义一个“父母”解析器，然后<strong>令单个程序的解析器从该“父母”解析器继承共享选项，这样就不必显式为每个ArgumentParser添加共享选项</strong>。</p><p><strong>第一步</strong>是以共享的参数定义<strong>建立“父母”解析器</strong>。注意：<strong>由于“父母”解析器的后代使用者会添加相同的帮助选项，从而会引发一个异常(见下面冲突解决)，所以在基础解析器中我们关闭自动帮助选项生成</strong>。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 注意这里的add_help=False</span></span><br><span class="line">parser = argparse.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure><p></p><p>文件保存在名为<code>argparse_parent_base.py</code>的文件中</p><p><strong>第二步以父母解析器集创建另一个解析器</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 导入parent的文件</span></span><br><span class="line"><span class="keyword">import</span> argparse_parent_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承父母解析器的参数</span></span><br><span class="line">parser = argparse.ArgumentParser(parents=[argparse_parent_base.parser])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置自己的参数</span></span><br><span class="line">parser.add_argument(<span class="string">'--local-arg'</span>, action=<span class="string">"store_true"</span>, default=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出所有的参数</span></span><br><span class="line"><span class="keyword">print</span> parser.parse_args()</span><br></pre></td></tr></table></figure><p></p><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_uses_parent.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_uses_parent.py [-h] [--user USER] [--password PASSWORD]</span><br><span class="line">                           [--local-arg]</span><br><span class="line"><span class="comment"># 可以发现继承了父母解析器的参数</span></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">    --user USER</span><br><span class="line">    --password PASSWORD</span><br><span class="line">    --local-arg</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="conflict-handler-冲突解决"><a href="#conflict-handler-冲突解决" class="headerlink" title="conflict_handler-冲突解决"></a>conflict_handler-冲突解决</h3><p>前一个例子指出<strong>以相同的参数名字为一个解析器添加两个参数处理器会引发一个异常</strong>(就是<code>parent</code>中提到的的帮助选项)。可以通过传递一个<code>conflict_handler</code>来改变冲突消除行为。<code>argparse</code>有两个内置的冲突处理器<code>error（默认）</code>和<code>resolve</code>，<code>resolve</code>会基于冲突选项的添加顺序来选择一个参数处理器:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 设置冲突解决的策略为resolve</span></span><br><span class="line">parser = argparse.ArgumentParser(conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">"store"</span>)</span><br><span class="line"><span class="comment"># 两个相同参数名的参数</span></span><br><span class="line">parser.add_argument(<span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">"Short alone"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--long-b'</span>, <span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">"Long and short together"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> parser.parse_args([<span class="string">'-h'</span>])</span><br></pre></td></tr></table></figure><p></p><p>由于最后一个处理器所给定的参数名已被使用，那么本例中<strong>独立选项<code>-b</code>将被<code>--long-b</code>所覆盖</strong>:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_conflict_handler_resolve.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_conflict_handler_resolve.py [-h] [-a A] [--long-b LONG_B]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -a A</span><br><span class="line">    <span class="comment"># 只出现了后定义的参数，前面定义的参数被覆盖了</span></span><br><span class="line">    --long-b LONG_B, -b LONG_B</span><br><span class="line">            Long <span class="keyword">and</span> short together</span><br></pre></td></tr></table></figure><p></p><p><strong>切换<code>add_argument()</code>的调用顺序</strong>就可以使两个选项都可以使用：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">"store"</span>)</span><br><span class="line"><span class="comment"># 同样是定义两个相同参数名的参数，只是顺序发生改变</span></span><br><span class="line">parser.add_argument(<span class="string">'--long-b'</span>, <span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">'Long and short together'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-b'</span>, action=<span class="string">"store"</span>, help=<span class="string">'Short alone'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> parser.parse_args([-h])</span><br></pre></td></tr></table></figure><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python argparse_conflict_handler_resolve2.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容</span></span><br><span class="line">usage: argparse_conflict_handler_resolve2.py [-h] [-a A] [--long-b LONG_B] [-b B]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">    -a A</span><br><span class="line">    <span class="comment"># 两个参数都可以使用了，没有进行覆盖</span></span><br><span class="line">    --long-b LONG_B Long <span class="keyword">and</span> short together</span><br><span class="line">    -b B    Short alone</span><br></pre></td></tr></table></figure><hr><h3 id="fromfile-prefix-chars-从文件中读取参数时文件的前缀字符集"><a href="#fromfile-prefix-chars-从文件中读取参数时文件的前缀字符集" class="headerlink" title="fromfile_prefix_chars-从文件中读取参数时文件的前缀字符集"></a>fromfile_prefix_chars-从文件中读取参数时文件的前缀字符集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'args.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>   fp.write(<span class="string">'-f\nbar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(fromfile_prefix_chars=<span class="string">'@'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-f'</span>, <span class="string">'foo'</span>, <span class="string">'@args.txt'</span>])</span><br><span class="line">Namespace(f=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p>当<strong>参数过多</strong>时，可以<strong>将参数放到文件中读取</strong>，例子中<code>parser.parse_args([&#39;-f&#39;, &#39;foo&#39;, &#39;@args.txt&#39;])</code><strong>解析时会从文件args.txt读取，相当于<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;-f&#39;, &#39;bar&#39;]</code></strong></p><hr><h3 id="add-help-解析器添加-h-–help-选项"><a href="#add-help-解析器添加-h-–help-选项" class="headerlink" title="add_help-解析器添加-h/–help 选项"></a>add_help-解析器添加-h/–help 选项</h3><p>设为 <code>False</code> 时，<code>help</code> 信息里面不再显示 <code>-h --help</code> 信息</p><div class="note info"><p>以上是我觉得比较重要的参数，但不是全部参数，具体参数的解释请参考<a href="https://docs.python.org/3/library/argparse.html#argumentparser-objects" target="_blank" rel="noopener">官方文档</a></p></div><hr><h3 id="allow-abbrev-长参数缩写"><a href="#allow-abbrev-长参数缩写" class="headerlink" title="allow_abbrev-长参数缩写"></a>allow_abbrev-长参数缩写</h3><p>参考后面解析参数<code>-parse_args()</code>的参数缩写</p><hr><p><br></p><h2 id="添加参数-add-argument"><a href="#添加参数-add-argument" class="headerlink" title="添加参数-add_argument()"></a>添加参数-add_argument()</h2><p>创建解析器之后如果需要为程序序添加参数选项需要用 ArgumentParser 对象的 <code>add_argument</code> 方法，该方法原型如下:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name <span class="keyword">or</span> flags...[, action][, nargs]</span><br><span class="line">                                            [, const][, default]</span><br><span class="line">                                            [, type][, choices]</span><br><span class="line">                                            [, required][, help]</span><br><span class="line">                                            [, metavar][, dest])</span><br></pre></td></tr></table></figure><p></p><table><tr><th width="20%">参数</th><th width="80%">含义</th></tr><tr><td>name or flags</td><td>选项字符串的名字或者列表，例如foo 或者-f, --foo</td></tr><tr><td>action</td><td>在命令行遇到该参数时采取的基本动作类型</td></tr><tr><td>nargs</td><td>应该读取的命令行参数个数</td></tr><tr><td>const</td><td>某些action和nargs选项要求的常数值</td></tr><tr><td>default</td><td>如果命令行中没有出现该参数时的默认值</td></tr><tr><td>type</td><td>命令行参数应该被转换成的类型</td></tr><tr><td>choices</td><td>包含参数可允许的值的一个容器</td></tr><tr><td>required</td><td>该命令行选项是否可以省略(只针对可选参数)</td></tr><tr><td>help</td><td>参数的简短描述</td></tr><tr><td>metavar</td><td>参数在帮助信息中的名字</td></tr><tr><td>dest</td><td>给parse_args()返回的对象要添加的属性名称</td></tr></table><h3 id="位置参数和可选参数"><a href="#位置参数和可选参数" class="headerlink" title="位置参数和可选参数"></a>位置参数和可选参数</h3><p>在学习具体的各个参数的含义之前，先了解一下argparse中的两种参数类型：<strong>位置参数</strong>和<strong>可选参数</strong>，<strong>位置参数在定义时没有前缀，而可选参数需要加前缀（默认为’-‘）</strong>。</p><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在前面的代码中按如下进行修改</span></span><br><span class="line"><span class="comment"># 添加echo这个位置参数，且定义参数的帮助信息</span></span><br><span class="line">parser.add_argument(<span class="string">"echo"</span>, help = <span class="string">"echo the string you use here"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="keyword">print</span> args.echo</span><br></pre></td></tr></table></figure><p>使用<code>python argparse_test.py -h</code>运行程序：</p><blockquote><p>usage: argparse_test.py [-h] echo</p><p><strong>positional arguments:</strong><br>echo echo the string you use here</p><p><strong>optional arguments:</strong><br>-h, –help show this help message and exit</p></blockquote><p>如果直接使用<code>python argparse_test.py</code>运行程序，不加参数：</p><blockquote><p>python argparse_test.py<br>usage: argparse_test.py [-h] echo<br>argparse_test.py: <strong>error: the following arguments are required: echo</strong></p></blockquote><p>位置参数<strong>相当于默认情况下使用了参数，如果不进行传参会报错</strong>，当然这可以通过<code>action=&#39;store_true&#39;</code>解决</p><p>使用<code>python argparse_test.py test</code>运行程序：</p><blockquote><p>python argparse_test.py test<br>test</p></blockquote><p>在添加参数后程序正常执行，输出参数值(<strong>通过解析后，参数的值保存在<code>echo</code>变量中</strong>)</p><hr><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>可选参数有两种：</p><ul><li>通过一个<code>-</code>来指定的<strong>短参数</strong>，如<code>-h</code></li><li>通过<code>--</code>来指定的<strong>长参数</strong>，如<code>--help</code></li><li>长参数是完整版，使用比较麻烦，而短参数则是简写版，便于使用，两个可以同时存在，也可以只写其中一个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br></pre></td></tr></table></figure><p>显示出帮助信息：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-v VERBOSITY]</p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>-v <code>VERBOSITY</code>, –verbosity <code>VERBOSITY</code></strong><br><strong>increase output verbosity</strong></p></blockquote><p>可选参数<code>-v</code>或<code>--verbosity</code>，通过解析后，其<strong>值保存在<code>args.verbosity</code>变量</strong>中:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一句</span></span><br><span class="line"><span class="keyword">print</span> (args.verbosity)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -v 2</code><br>2</p></blockquote><div class="note info"><ul><li>位置参数和可选参数是通过<code>-</code>来区分，如果不加<code>-</code>，<code>argparse</code>会将其当做位置参数解析</li><li>位置参数在解析时，值存储在位置参数同名的变量中；可选参数在解析时，如果没有添加长参数，则和位置参数一样，储存在同名变量中，而如果添加了长参数，则存储在长参数的变量中</li></ul></div><hr><h3 id="name-or-flags-参数名"><a href="#name-or-flags-参数名" class="headerlink" title="name or flags-参数名"></a>name or flags-参数名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加位置参数，echo即为参数名</span></span><br><span class="line">parser.add_argument(<span class="string">"echo"</span>, help = <span class="string">"echo the string you use here"</span>)</span><br><span class="line"><span class="comment"># 添加可选参数，-v和--verbosity都为参数名</span></span><br><span class="line">parser.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="action-对参数采取的动作"><a href="#action-对参数采取的动作" class="headerlink" title="action-对参数采取的动作"></a>action-对参数采取的动作</h3><p>action包括六种不同的取值，分别为<code>store(默认选项)</code>、<code>store_const</code>、<code>store_true</code>、<code>store_false</code>、<code>append</code>、<code>append_const</code>、<code>count</code>、<code>help</code>、<code>version</code>。</p><h4 id="只存储值–action-’store"><a href="#只存储值–action-’store" class="headerlink" title="只存储值–action=’store"></a>只存储值–action=’store</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store'</span>)</span><br></pre></td></tr></table></figure><p>这是默认情况，可以不用加，<strong>这种情况如果使用了参数但是不传入值，就会报错</strong></p><hr><h4 id="常量参数–action-’store-const’"><a href="#常量参数–action-’store-const’" class="headerlink" title="常量参数–action=’store_const’"></a>常量参数–action=’store_const’</h4><p><code>store_const</code>，表示参数为固定值，该固定值存放在 <code>const</code> 中:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_const'</span>, const=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py --foo</code><br>42</p></blockquote><p><strong>不能修改值(默认值，不能修改)</strong>，如果修改值就会报错：</p><blockquote><p><code>python argparse_test.py --foo 20</code><br>usage: argparse_test.py [-h] [–foo]<br>argparse_test.py: error: unrecognized arguments: 20</p></blockquote><hr><h4 id="True-or-False–store-true和store-false"><a href="#True-or-False–store-true和store-false" class="headerlink" title="True or False–store_true和store_false"></a>True or False–store_true和store_false</h4><p>store_true和store_false，值存为 True 或 False。这个很实用，比如前面<strong>在位置参数中如果直接执行(可选参数也是一样，不过需要调用)，不对参数传值的话就会报错，但是设置这个之后参数即使不传参，调用后也会返回值，不过是True或者False：</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br></pre></td></tr></table></figure><p></p><p>使用<code>python argparse_test.py --foo</code>执行程序：</p><blockquote><p>usage: argparse_test.py [-h] [–foo FOO]<br>argparse_test.py: error: argument –foo: expected one argument</p></blockquote><blockquote><p>True</p></blockquote><hr><h4 id="存储列表参数-action-’append’"><a href="#存储列表参数-action-’append’" class="headerlink" title="存储列表参数-action=’append’"></a>存储列表参数-action=’append’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'append'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo 2 --foo 3</code><br>[‘2’, ‘3’]</p></blockquote><hr><h4 id="参数出现次数–action-’count’"><a href="#参数出现次数–action-’count’" class="headerlink" title="参数出现次数–action=’count’"></a>参数出现次数–action=’count’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'count'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo --foo</code><br>2</p></blockquote><hr><h4 id="保存常量到列表–action-’append-const’"><a href="#保存常量到列表–action-’append-const’" class="headerlink" title="保存常量到列表–action=’append_const’"></a>保存常量到列表–action=’append_const’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-A'</span>, action=<span class="string">'append_const'</span>, dest=<span class="string">'const_collection'</span>,</span><br><span class="line">        const=<span class="string">'value-1-to-append'</span>,</span><br><span class="line">        default=[],</span><br><span class="line">        help=<span class="string">'Add different values to list'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-B'</span>, action=<span class="string">'append_const'</span>, dest=<span class="string">'const_collection'</span>,</span><br><span class="line">        const=<span class="string">'value-2-to-append'</span>,</span><br><span class="line">        help=<span class="string">'Add different values to list'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py -A -B</code><br>[‘value-1-to-append’, ‘value-2-to-append’]</p></blockquote><p>可以参考上面的<code>action=&#39;store_const&#39;</code></p><hr><h4 id="版本信息–action-’version’"><a href="#版本信息–action-’version’" class="headerlink" title="版本信息–action=’version’"></a>版本信息–action=’version’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 2.0'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --version</code><br>argparse_test.py 2.0</p></blockquote><hr><h3 id="nargs-参数数量"><a href="#nargs-参数数量" class="headerlink" title="nargs-参数数量"></a>nargs-参数数量</h3><p>参数可以传入的值的数目，可以为：</p><ul><li><strong>整数<code>N</code></strong>：<strong>N个</strong>传入值，返回传入值的<strong>列表</strong>，即使为1， 也返回列表</li><li><strong><code>&#39;*&#39;</code></strong>：<strong>任意多个传入值(包括0个)</strong>，返回<strong>列表</strong></li><li><strong><code>&#39;+&#39;</code></strong>：<strong>一个或更多</strong>，不加传入值的时候会报错，返回<strong>列表</strong></li><li><strong><code>&#39;?&#39;</code></strong>：首先从命令行获得参数，若没有则从const获得，然后从default获得；还可以使用该参数<mark>指定输入和输出文件</mark></li><li><strong><code>argparse.REMAINDER</code></strong>：将<strong>剩余的参数</strong>作为<strong>列表</strong>搜集起来</li></ul><h4 id="整数N"><a href="#整数N" class="headerlink" title="整数N"></a>整数N</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py --foo 1 2</code><br>[‘1’, ‘2’]</p></blockquote><p><strong>注意使用整数N(N个)时返回的是一个列表，即使N=1，返回的也是一个元素的列表，这和默认行为(传入一个参数)返回传入值本身不同</strong></p><hr><h4 id="使用-39-39-进行文件操作"><a href="#使用-39-39-进行文件操作" class="headerlink" title="使用&#39;?&#39;进行文件操作"></a>使用<code>&#39;?&#39;</code>进行文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件，默认值为从标准输入读取</span></span><br><span class="line">parser.add_argument(<span class="string">'infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>),</span><br><span class="line">                     default=sys.stdin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件，默认值为标准输出</span></span><br><span class="line">parser.add_argument(<span class="string">'outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>),</span><br><span class="line">                     default=sys.stdout)</span><br></pre></td></tr></table></figure><div class="note info"><p>如果没有提供<code>nargs</code>参数，传入值的数量将由<code>action</code>决定，通常情况下只有一个参数</p></div><hr><h3 id="const-保存常量"><a href="#const-保存常量" class="headerlink" title="const-保存常量"></a>const-保存常量</h3><p>在以下两种情况使用：</p><ul><li><code>action</code>中的<code>action=&#39;store_const&#39;</code>和<code>action=&#39;append_const&#39;</code>给参数设置固定值</li><li><code>nargs</code>中的<code>&#39;?&#39;</code>，首先从命令行获得参数，若没有则从const获得，然后从default获得</li></ul><hr><h3 id="default-设置默认值"><a href="#default-设置默认值" class="headerlink" title="default-设置默认值"></a>default-设置默认值</h3><p>和前面的<code>const</code>的区别在于：const设置之后不能修改这个值，但是default设置之后只有命令行中没有传入参数值才会使用default，传入值的话就使用传入的值。</p><hr><h3 id="type-参数类型"><a href="#type-参数类型" class="headerlink" title="type-参数类型"></a>type-参数类型</h3><p><strong>默认情况下将传入的参数值统一作为字符读入</strong>，可以通过设置type来确定传入的参数值的类型：</p><ul><li><strong>type=float：浮点</strong></li><li><strong>type=float：整型</strong></li><li><p><strong>type=argparse.FileType()</strong>：创建可写入文件，其中的参数包括<code>mode=</code>、<code>bufsize=</code>、<code>encoding=</code>和<code>errors=</code>，前面的<code>nargs</code>中的<code>&#39;?&#39;</code>也是用于文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>, type=argparse.FileType(mode=<span class="string">'w'</span>,encoding=<span class="string">'UTF-8'</span>))</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> (args.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python argparse_test.py out.txt</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   &lt;_io.TextIOWrapper name='out.txt' mode='w' encoding='UTF-8'&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>type还可以接受一个可以调用的函数(输入单个字符，返回转化后的类型)</p></li></ul><hr><h3 id="choices-参数的范围"><a href="#choices-参数的范围" class="headerlink" title="choices-参数的范围"></a>choices-参数的范围</h3><ul><li>choices设置参数的范围，例如通过<code>choices=range(1, 4)</code>设定数字的，也可以通过<code>choices=[&#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]</code>设置字符的</li><li><strong>需要注意：传入值先进行<code>type</code>的类型转换，然后才看检查<code>choices</code>范围，所以<code>choices</code>范围的类型要和<code>type</code>一致</strong></li><li><strong>支持<code>in操作(for i in sth)</code>的都可以作为<code>choices</code>的范围，例如常规的<code>dict</code>、<code>set</code>、<code>list</code>等</strong></li></ul><hr><h3 id="required-参数是否必须"><a href="#required-参数是否必须" class="headerlink" title="required-参数是否必须"></a>required-参数是否必须</h3><ul><li><strong><code>required</code>只针对可选参数</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, required=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用的时候如果不加--foo</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     argparse.py: error: option --foo is required</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="help-参数的帮助信息"><a href="#help-参数的帮助信息" class="headerlink" title="help-参数的帮助信息"></a>help-参数的帮助信息</h3><ul><li>对参数的简短描述，可以帮助选择参数</li><li><p>为了避免与<code>argparse</code>的参数重叠，帮助信息中的有些关键字(<code>prog</code>、<code>default</code>)可以使用<code>%</code>包围(文字中需要出现<code>%</code>的话用<code>%%</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>, type=int, default=<span class="number">42</span>,</span><br><span class="line">                     help=<span class="string">'the bar to %(prog)s (default: %(default)s)'</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 显示帮助信息时：</span></span><br><span class="line"><span class="comment">#   usage: frobble [-h] [bar]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   positional arguments:</span></span><br><span class="line"><span class="comment">#    bar     the bar to frobble (default: 42)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不输出某个参数的帮助信息，使用<code>help=argparse.SUPPRESS</code></strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=argparse.SUPPRESS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示帮助信息时显示：</span></span><br><span class="line"><span class="comment">#  usage: frobble [-h]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  optional arguments:</span></span><br><span class="line"><span class="comment">#   -h, --help  show this help message and exit</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="metavar-参数在帮助信息中的名称"><a href="#metavar-参数在帮助信息中的名称" class="headerlink" title="metavar-参数在帮助信息中的名称"></a>metavar-参数在帮助信息中的名称</h3><p>默认情况下，参数使用<code>dest</code>值作为名称，例如位置参数的参数名称就是位置参数的名称，而可选参数如果使用了长参数则是长参数的名称，如果<strong>只使用了短参数</strong>则是短参数的名称(前面位置参数也有讲解)</p><p>默认情况：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–foo <strong>FOO</strong>] <strong>bar</strong></p><p>positional arguments:<br>bar</p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>–foo FOO</strong></p></blockquote><p><strong>通过metavar设置</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, metavar=<span class="string">'YYY'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>, metavar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [–foo <strong>YYY</strong>] <strong>XXX</strong></p><p>positional arguments:<br><strong>XXX</strong></p><p>optional arguments:<br>-h, –help show this help message and exit<br><strong>–foo YYY</strong></p></blockquote><p>可以发现上述加粗的地方的名称出现了改变</p><p><strong>需要注意的是<code>metavar</code>只是改变了名称的显示内容，真正的变量解析的名称还是有<code>dest</code>决定</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上述输出变量值，使用metavar设置的名称</span></span><br><span class="line"><span class="keyword">print</span> (args.YYY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述输出变量值，使用dest的名称</span></span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br></pre></td></tr></table></figure><p></p><p><code>print (args.YYY)</code>的输出：</p><blockquote><p><code>python argparse_test.py --foo test test2</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.YYY)<br>AttributeError: <strong>‘Namespace’ object has no attribute ‘YYY’</strong></p></blockquote><p><code>print (args.foo)</code>的输出：</p><blockquote><p><code>python argparse_test.py --foo test test2</code><br>test</p></blockquote><p><strong>可以发现只有使用<code>print (args.foo)</code>才能正常输出，说明参数解析存放的变量还是没变，<code>metavar</code>设置的名称只是改变了显示形式</strong></p><div class="note info"><ul><li>参数解析存放的变量还是没变(还是由<code>dest</code>决定)，<code>metavar</code>设置的名称只是改变了显示形式</li><li>如果参数设置了<code>nargs</code>(例如：nargs=2)，会导致<code>metavar</code>设置的名称(如果只指定了一个名称)重复出现</li></ul></div><hr><h3 id="dest-传入值的属性名称"><a href="#dest-传入值的属性名称" class="headerlink" title="dest-传入值的属性名称"></a>dest-传入值的属性名称</h3><ul><li>如果<strong>存在长参数(–开头的)</strong>，则<code>dest</code>取<strong>第一个长参数的值作为属性名称</strong>；</li><li>如果<strong>没有长参数</strong>，则<code>dest</code>取<strong>第一个短参数的值作为属性名称</strong></li><li>所有字符中间的<code>-</code>都会被转化为<code>_</code>，保证属性名称是有效的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-x'</span>, <span class="string">'-y'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用第一个长参数以及将-转化为_</span></span><br><span class="line"><span class="keyword">print</span> (args.foo_bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用第二个长参数</span></span><br><span class="line"><span class="keyword">print</span> (args.foo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个短参数</span></span><br><span class="line"><span class="keyword">print</span> (args.y)</span><br></pre></td></tr></table></figure><p><strong>查看帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-f <strong>FOO_BAR</strong>] [-x <strong>X</strong>]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-f <strong>FOO_BAR</strong>, –foo-bar <strong>FOO_BAR</strong>, –foo <strong>FOO_BAR</strong><br>-x <strong>X</strong>, -y <strong>X</strong></p></blockquote><p><strong>使用第一个长参数以及将<code>-</code>转化为<code>_</code></strong>：</p><blockquote><p><code>python argparse_test.py --foo test</code><br>test</p></blockquote><p><strong>如果使用短参数</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.f)<br>AttributeError: <strong>‘Namespace’ object has no attribute ‘f’</strong></p></blockquote><p><strong>如果使用第二个长参数</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in<module><br>print (args.foo)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘foo’</strong></module></p></blockquote><p><strong>第一个短参数</strong>:</p><blockquote><p><code>python argparse_test.py -x test</code><br>test</p></blockquote><p><strong>第二个短参数</strong>:</p><blockquote><p><code>python argparse_test.py -x test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 6, in \&lt;module><br>print (args.y)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘y’</strong></p></blockquote><p><mark>使用dest自定义属性名称</mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser() <span class="comment"># 生成参数分析器</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>,dest=<span class="string">"my_set"</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果还使用最开始的foo_bar</span></span><br><span class="line"><span class="keyword">print</span> (args.foo_bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的my_set</span></span><br><span class="line"><span class="keyword">print</span> (args.my_set)</span><br></pre></td></tr></table></figure><p></p><p><strong>输出帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] [-f <strong>MY_SET</strong>]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-f <strong>MY_SET</strong>, –foo-bar <strong>MY_SET</strong>, –foo <strong>MY_SET</strong></p></blockquote><p><strong>如果还使用最开始的foo_bar</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>Traceback (most recent call last):<br>File “argparse_test.py”, line 5, in \&lt;module><br>print (args.foo_bar)<br><strong>AttributeError: ‘Namespace’ object has no attribute ‘foo_bar’</strong></p></blockquote><p><strong>使用自定义的my_set</strong>:</p><blockquote><p><code>python argparse_test.py --foo test</code><br>test</p></blockquote><div class="note info"><p><strong><code>dest</code>就是命令行参数(传入值)在经过解析后存储的变量名</strong>，默认情况下：</p><ul><li>如果存在长参数，就是第一个长参数的值(<code>--</code>后面接着的字符串)</li><li>如果不存在长参数，就是第一个短参数的值(<code>-</code>后面接着的字符串)</li><li>参数中间的<code>-</code>都会被转化为<code>_</code>，保证属性名称是有效的</li></ul><p><strong>当然可以通过<code>dest</code>参数进行自定义解析后存储的变量名</strong></p></div><hr><p><br></p><h2 id="解析参数-parse-args"><a href="#解析参数-parse-args" class="headerlink" title="解析参数-parse_args()"></a>解析参数-parse_args()</h2><p>上述添加完所有参数之后，就可以给 <code>parse_args()</code> 传递一组参数字符串来解析命令行。<strong>默认情况下</strong>，参数是从 <code>sys.argv[1:]</code> 中获取，但你也可以传递自己的参数列表。因为一般使用argparse都是用来解析命令行参数，所以使用其默认情况即可，这里对自己传递参数的方法没有进行学习，需要的时候可以去看官方文档。<br><code>parse_args()</code> 的返回值是一个命名空间，包含传递给命令的参数。<strong>该对象将参数保存其属性</strong>，因此如果你的参数 <code>dest</code> 是 <code>&quot;myoption&quot;</code>，那么你就可以<code>args.myoption</code> 来访问该值(可以参考前面<code>dest</code>的用法).<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.parse_args(args=<span class="keyword">None</span>, namespace=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p></p><ul><li><code>args</code> - List of strings to parse. <strong>The default is taken from sys.argv</strong>.</li><li><code>namespace</code> - An object to take the attributes. <strong>The default is a new empty Namespace object</strong>.</li></ul><hr><p><br></p><h3 id="参数缩写"><a href="#参数缩写" class="headerlink" title="参数缩写"></a>参数缩写</h3><p>parse_args()默认允许长参数缩写为前缀(前缀是不相同的)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-bacon'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-badger'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-bac MMM'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="string">'MMM'</span>, badger=None)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-bad WOOD'</span>.split())</span><br><span class="line">Namespace(bacon=None, badger=<span class="string">'WOOD'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser.parse_args(<span class="string">'-ba BA'</span>.split())</span><br><span class="line">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span><br><span class="line">PROG: error: ambiguous option: -ba could match -badger, -bacon</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="解析部分参数-parse-known-args"><a href="#解析部分参数-parse-known-args" class="headerlink" title="解析部分参数-parse_known_args()"></a>解析部分参数-parse_known_args()</h3><p>有时间一个脚本只需要解析所有命令行参数中的一小部分，剩下的命令行参数给另一个脚本或者程序。在这种情况下，<code>parse_known_args()</code>就很有用。它很像<code>parse_args()</code>，但是它在接受到多余的命令行参数时不报错。相反的，返回一个tuple类型的命名空间和一个保存着余下的命令行字符的list。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse </span><br><span class="line">parser = argparse.ArgumentParser() </span><br><span class="line">parser.add_argument( </span><br><span class="line">    <span class="string">'--flag_int'</span>, </span><br><span class="line">    type=float, </span><br><span class="line">    default=<span class="number">0.01</span>, </span><br><span class="line">    help=<span class="string">'flag_int.'</span> </span><br><span class="line">) </span><br><span class="line">FLAGS, unparsed = parser.parse_known_args() </span><br><span class="line">print(FLAGS.flag_int) </span><br><span class="line">print(unparsed)</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>python argparse_test.py --flag_int 0.02 --double 0.03 a 1</code><br>0.02<br>[‘–double’, ‘0.03’, ‘a’, ‘1’]</p></blockquote><p>binbin师兄的项目中有所使用，可以看看</p><hr><p><br></p><h2 id="参数群组"><a href="#参数群组" class="headerlink" title="参数群组"></a>参数群组</h2><p><code>argparse</code>能将参数定义组合成“群组”。<strong>默认情况下是使用两个群组，一个是可选参数的群组，另一个是必须的位置参数的群组</strong>，这可以在程序的帮助信息中看到，使用<code>optional arguments</code>和<code>positional arguments</code>将群组分开，可以参考前面的位置参数和可选参数部分</p><p>在实际使用中，<strong>可以调整群组来提高帮助信息中群组的逻辑性，这样相关选项或值能记录在一起</strong>。可以使用自定义群组来重写之前的共享选项的示例，如在帮助信息中身份认证的选项就可以显示在一起：<br><strong>第一步</strong>：在基础解析器中使用<code>add_argument_group()</code>来<strong>创建一个“身份认证”群组</strong>，然后逐个添加身份认证相关的选项到该群组<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparser.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 创建名为authentication的群组</span></span><br><span class="line">group = parser.add_argument_group(<span class="string">'authentication'</span>)</span><br><span class="line"><span class="comment"># 给这个群组添加参数</span></span><br><span class="line">group.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">group.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure><p></p><p>以上内容保存在名为<code>argparse_parent_with_group.py</code>的文件中</p><p><strong>第二步</strong>：和之前parent中讲到的一样进行参数继承<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> argparse_parent_with_group</span><br><span class="line"><span class="comment"># 继承参数，注意parent中是ArgumentParser类，所以这里依然导入的是parser，而不是group</span></span><br><span class="line">parser = argparse.ArgumentParser(parents=[argparse_parent_with_group.parser])</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--local-arg'</span>, action=<span class="string">"store_true"</span>, default=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (parser.parse_args())</span><br></pre></td></tr></table></figure><p></p><p><strong>输出信息</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">python argparse_test.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">usage: argparse_test.py [-h] [--user USER] [--password PASSWORD] [--local-arg]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help           show this help message <span class="keyword">and</span> exit</span><br><span class="line">  --local-arg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的群组</span></span><br><span class="line">authentication:</span><br><span class="line">  --user USER</span><br><span class="line">  --password PASSWORD</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="创建子命令"><a href="#创建子命令" class="headerlink" title="创建子命令"></a>创建子命令</h2><p>有时候，我们可以根据功能将命令行分组成一系列相关的子命令，为了实现这种分组行为argparse提供了ArgumentParser.add_subparsers()方法，其使用如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_subparsers([title][, description][, prog]</span><br><span class="line">                              [, parser_class][, action][, option_string]</span><br><span class="line">                              [, dest][, required][, help][, metavar])</span><br></pre></td></tr></table></figure><p></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成参数分析器</span></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'cmd'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sub-commands</span></span><br><span class="line">sub_parser = parser.add_subparsers(title=<span class="string">'subcommands'</span>,</span><br><span class="line">                                description=<span class="string">'valid subcommands'</span>,</span><br><span class="line">                                help=<span class="string">'config subscommand help'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第一个分组，相当于单个分组中的argparse.ArgumentParser</span></span><br><span class="line">add_parser = sub_parser.add_parser(<span class="string">'add'</span>,help=<span class="string">'add user config'</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">add_parser.add_argument(<span class="string">'--name'</span>, required=<span class="keyword">True</span>, help=<span class="string">'user name'</span>)</span><br><span class="line">add_parser.add_argument(<span class="string">'--addr'</span>, required=<span class="keyword">False</span>, help=<span class="string">'user address'</span>)</span><br><span class="line">add_parser.add_argument(<span class="string">'--phone'</span>, required=<span class="keyword">False</span>, help=<span class="string">'phone number'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第二个分组</span></span><br><span class="line">delete_parser = sub_parser.add_parser(<span class="string">'delete'</span>, help=<span class="string">'delete user config'</span>)</span><br><span class="line">delete_parser.add_argument(<span class="string">'--name'</span>, required=<span class="keyword">True</span>, help=<span class="string">'user name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第三个分组</span></span><br><span class="line">show_parser = sub_parser.add_parser(<span class="string">'show'</span>, help=<span class="string">'show user config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><blockquote><p><code>python argparse_test.py -h</code><br>usage: cmd [-h] {add,delete,show} …</p><p>optional arguments:<br>-h, –help show this help message and exit</p><p>subcommands:<br>valid subcommands</p><p>{add,delete,show} config subscommand help<br>add add user config<br>delete delete user config<br>show show user config</p></blockquote><p><strong>上述过程讲解：</strong><br><code>ArgumentParser</code>对象使用<code>add_subparsers()</code>方法创建子命令组；该方法通常在调用的时候不传递参数，并返回一个特殊的action实例，这个实例只有一个方法：<code>add_parser()</code>；对这个实例分别调用<code>add_parser()</code>方法来创建子命令对应的<code>ArgumentParser</code>(包含了其所有可以使用的参数，还包含了一个子命令组名称的参数)，再调用这个<code>ArgumentParser</code>实例的<code>add_argument()</code>方法来添加子命令的参数。</p><p>从上述帮助输出可以看出，<strong>对整体使用-h不会返回每个子命令组详细的帮助信息，如果想查看每个子命令组详细的帮助信息需要使用<code>python argparse_test.py add -h</code></strong>:</p><blockquote><p><code>python argparse_test.py add -h</code><br>usage: cmd add [-h] –name NAME [–addr ADDR] [–phone PHONE]</p><p>optional arguments:<br>-h, –help show this help message and exit<br>–name NAME user name<br>–addr ADDR user address<br>–phone PHONE phone number</p></blockquote><p><mark>通过<code>ArgumentParser</code>的<code>set_defaults()</code>方法来设置不同的子命令执行的函数</mark>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置子命令add的执行函数为add_fn</span></span><br><span class="line">add_parser.set_defaults(func=add_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子命令delete的执行函数为delete_fn</span></span><br><span class="line">delete_parser.set_defaults(func=delete_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子命令show的执行函数为show_fn</span></span><br><span class="line">show_parser.set_defaults(func=show_fn)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="创建互斥参数"><a href="#创建互斥参数" class="headerlink" title="创建互斥参数"></a>创建互斥参数</h2><p>使用<code>ArgumentParser</code>的<code>add_mutually_exclusive_group()</code>来创建互斥参数组：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"calculate X to the power of Y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建互斥参数</span></span><br><span class="line">group = parser.add_mutually_exclusive_group()</span><br><span class="line">group.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbose"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">group.add_argument(<span class="string">"-q"</span>, <span class="string">"--quiet"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"x"</span>, type=int, help=<span class="string">"the base"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"y"</span>, type=int, help=<span class="string">"the exponent"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">answer = args.x**args.y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.quiet:</span><br><span class="line">    <span class="keyword">print</span> (answer)</span><br><span class="line"><span class="keyword">elif</span> args.verbose:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125;^&#123;&#125; == &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br></pre></td></tr></table></figure><p></p><p><strong>查看帮助信息</strong>：</p><blockquote><p><code>python argparse_test.py -h</code><br>usage: argparse_test.py [-h] <strong>[-v | -q]</strong> x y</p><p>calculate X to the power of Y</p><p>positional arguments:<br>x the base<br>y the exponent</p><p>optional arguments:<br>-h, –help show this help message and exit<br>-v, –verbose<br>-q, –quiet</p></blockquote><p><strong>如果同时使用会报错</strong>：</p><blockquote><p><code>python argparse_test.py -v -q</code><br>usage: argparse_test.py [-h] [-v | -q] x y<br><strong>argparse_test.py: error: argument -q/–quiet: not allowed with argument -v/–verbose</strong></p></blockquote><p><strong><code>add_mutually_exclusive_group(required=True)</code>支持<code>required=True</code>参数(但是不支持title和description参数)，表明两个互斥的参数中必须使用一个</strong></p><hr><p><br></p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ul><li>可以将<strong>共有的参数放在一个父参数文件中，然后其他的文件直接导入(<code>parent</code>的使用)</strong>，这样比较简单</li><li>参数群组(<code>add_argument_group()</code>)，<strong>可以自己组织参数出现的分组，看着比较清晰</strong>，如果没有必要用到子命令(<code>add_subparsers()</code>)的时候可以尝试一下</li><li><mark>如果传入参数只带有双引号，需要对双引号进行转义，否则接受的参数中将不含双引号</mark></li><li>如果传入的参数带有<mark>空格</mark>，传入时可以<strong>使用双引号将其括起来：<code>-d &quot;abc def&quot;</code></strong></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.jianshu.com/p/fef2d215b91d" target="_blank" rel="noopener">python argparse用法总结</a></li><li><a href="https://www.jianshu.com/p/0361cd8b8fec" target="_blank" rel="noopener">python命令行参数解析</a></li><li><a href="http://blog.konghy.cn/2016/06/30/python-argparse/" target="_blank" rel="noopener">Python 模块简介 – argparse</a></li><li><a href="https://www.cnblogs.com/xlqtlhx/p/8243592.html" target="_blank" rel="noopener">argarse.ArgumentParser.parse_known_args()解析</a></li><li><a href="http://blog.xiayf.cn/2013/03/30/argparse/" target="_blank" rel="noopener">非常好的讲解，但是适合回顾的时候看，需要基础</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-main函数的理解</title>
      <link href="/posts/32155.html"/>
      <url>/posts/32155.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇之前学习过的关于Python main函数的理解，主要学习了main函数的作用、在作为包引入以及直接运行时的区别，同时对Python的代码运行机制也有了一定的了解.</p></div><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><strong>程序入口：</strong><br>&emsp;&emsp;对于<strong>很多编程语言</strong>来说，<strong>程序都必须要有一个入口</strong>，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，<strong>C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始</strong>。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。<br>&emsp;&emsp;而 <strong>Python 则有不同</strong>，它<strong>属于脚本语言</strong>，不像编译型语言那样先将程序编译成二进制再运行，而是<strong>动态的逐行解释运行</strong>。也就是<strong>从脚本第一行开始运行，没有统一的入口</strong>，结合Python<strong>使用缩进对齐组织代码</strong>的执行，所有<strong>没有缩进的代码（非函数定义和类定义），都会被当成Python的main函数，在载入时自动执行</strong>。<br>&emsp;&emsp; 一个 Python 源码文件除了<strong>可以被直接运行</strong>外，还<strong>可以作为模块（也就是库）被导入</strong>。<strong>不管是导入还是直接运行，最顶层的代码都会被运行（没有设置缩进的代码）</strong>，<strong>而实际上在导入的时候，有一部分代码我们是不希望被运行的，这一部分代码可以放在main函数中，当作为模块进行导入时就不会被执行</strong></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'AAA'</span>)                <span class="comment">#没有所进的代码，会被直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'BBB'</span>)             <span class="comment">#函数中的内容，被调用后会被执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (__name__)              <span class="comment">#是内置变量，用于表示当前模块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment">#当name是main的时候执行</span></span><br><span class="line">   test()</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'CCC'</span>)</span><br></pre></td></tr></table></figure><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p><strong>直接运行文件的输出</strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line"></span><br><span class="line">__main__</span><br><span class="line"></span><br><span class="line">BBB</span><br><span class="line">CCC</span><br></pre></td></tr></table></figure><p></p><p>可以看出<strong>直接执行文件</strong>的时候<strong>先是两个print会被执行</strong>，并且从输出信息可以<strong>看出<code>__name__</code>是<code>__main__</code>，满足<code>if</code>的判断条件，所以<code>test()</code>函数会被执行，并且输出<code>CCC</code></strong>。</p><hr><h3 id="当成模块引入"><a href="#当成模块引入" class="headerlink" title="当成模块引入"></a>当成模块引入</h3><ul><li>将上述代码保存为<code>test_main.py</code>文件</li><li>在同一个目录下创建另一个文件，里面只写入<code>from test_main import test</code>，运行该文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只导入包的时候出现</span></span><br><span class="line"><span class="keyword">from</span> test_main <span class="keyword">import</span> test</span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件中继续写入 test()，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只写 test，输出</span></span><br><span class="line">AAA</span><br><span class="line">test_main</span><br><span class="line">&lt;function test at <span class="number">0x03433970</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>导入包的时候，和上面一样，两个print也会被直接执行</strong>，<strong>需要注意的是这里的<code>__name__</code>已经变成了<code>module</code>的名称（test_main）</strong>，由于<strong>此时的<code>__name__</code>不等于<code>__main___</code>，不满足if的条件，所以不会直接执行test函数和输出CCC</strong>；<strong>导入之后，调用其中的test函数（被导入的函数），原始的test函数就会被执行。</strong></p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>&emsp;&emsp;<strong><code>__name__ == &#39;__main__&#39;</code>含义是“Make a script both importable and executable”</strong>，也就是<strong>让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行</strong>。每个python模块(python文件)都包含内置的变量<code>__name__</code>，当运行模块被直接执行的时候，<code>__name__</code>等于<code>&#39;__main__&#39;</code>；如果import到其他模块中，则<code>__name__</code>等于模块名称(不包含后缀.py)。而在程序中的判断条件是<code>if __name__ == &#39;__main__&#39;</code>，所以当模块被直接执行时，<code>__name__ == &#39;__main__&#39;</code>结果为真；而当模块被import到其他模块中时，<code>__name__ == &#39;__main__&#39;</code>结果为假，就是不调用对应的方法。简单来说： <strong>如果模块是被直接运行的，则if语句中的代码块被运行，如果模块是被导入的，则if语句中的代码块不被运行</strong>。</p><div class="note info"><p>这个功能有一个用处：调试代码的时候，在<code>if __name__ == &#39;__main__&#39;</code>中加入一些我们的调试代码，我们可以<strong>让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</strong></p></div><hr><h2 id="典型的python文件结构"><a href="#典型的python文件结构" class="headerlink" title="典型的python文件结构"></a>典型的python文件结构</h2><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/python文件结构.gif"><br></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jb51.net/article/51892.htm" target="_blank" rel="noopener">浅析python 中<strong>name</strong> = ‘<strong>main</strong>‘ 的作用</a></li><li><a href="https://zhuanlan.zhihu.com/p/34366092" target="_blank" rel="noopener">python编程中的if <strong>name</strong> == ‘main’ 的作用和原理</a></li><li><a href="https://www.restran.net/2015/10/22/how-python-code-run/" target="_blank" rel="noopener">Python 源码剖析读书笔记</a></li><li><a href="http://blog.konghy.cn/2017/04/24/python-entry-program/" target="_blank" rel="noopener">Python 中的 if <strong>name</strong> == ‘<strong>main</strong>‘ 该如何理解</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用程序块</title>
      <link href="/posts/58475.html"/>
      <url>/posts/58475.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇博客总结一些常用的Python程序块，避免重复造轮子</p></div><a id="more"></a><h2 id="添加中文注释"><a href="#添加中文注释" class="headerlink" title="添加中文注释"></a>添加中文注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><hr><h2 id="正则匹配-分组、非贪婪"><a href="#正则匹配-分组、非贪婪" class="headerlink" title="正则匹配(分组、非贪婪)"></a>正则匹配(分组、非贪婪)</h2><p>正则匹配是经常使用的，也是经常容易出错的，这个给出比较常用的带<strong>分组</strong>和<strong>非贪婪</strong>模式的匹配：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">'&gt;AT1G01060.4 | Symbols: LHY, LHY1 | Homeodomain-like superfamily protein | chr1:33992-37061 REVERSE LENGTH=644'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配前面的AT1G01060</span></span><br><span class="line">pattern=re.compile(<span class="string">'^&gt;(.*?)\.'</span>)</span><br><span class="line"></span><br><span class="line">re.search(pattern,s).group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>‘AT1G01060’</p></blockquote><div class="note info"><ul><li>需要注意的：<code>&#39;^&gt;(.*?)\.&#39;</code>这里<code>?</code>加在<code>*</code>的后面，因为<code>*</code>才是贪婪匹配的来源；不应该加载<code>()</code>后面，那样起不到非贪婪匹配的作用</li><li><code>group(0)</code>或者<code>group()</code>表示的是整个匹配上的字符串，比如这里指的就是<code>&#39;&gt;AT1G01060.&#39;</code>；<code>group(1)</code>才是匹配的括号内的内容</li><li><code>re.match</code><strong>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None</strong>；而<code>re.search</code>匹配<strong>整个字符串，直到找到一个匹配</strong></li><li><strong><code>re.match</code> 和 <code>re.search</code> 是匹配一次 <code>re.findall</code> 匹配所有，返回列表</strong></li></ul></div><hr><h2 id="自动调用函数执行"><a href="#自动调用函数执行" class="headerlink" title="自动调用函数执行"></a>自动调用函数执行</h2><p>关于main函数的理解，请参考<a href="http://showteeth.tech/">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义主函数</span></span><br><span class="line">def main():</span><br><span class="line">    my_func()</span><br><span class="line">    my_func_1()</span><br><span class="line">    my_func_2()</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="输出固定长度的字串"><a href="#输出固定长度的字串" class="headerlink" title="输出固定长度的字串"></a>输出固定长度的字串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改every即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wrapped</span><span class="params">(string, every=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\n'</span>.join(string[i:i+every] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), every))</span><br></pre></td></tr></table></figure><hr><h2 id="字典相关操作："><a href="#字典相关操作：" class="headerlink" title="字典相关操作："></a>字典相关操作：</h2><h3 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的字典</span></span><br><span class="line">dic=&#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="string">'3'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用collections中的defaultdict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dic_test=defaultdict(list)</span><br><span class="line">dic_test[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 具体的形式：defaultdict(&lt;type 'list'&gt;, &#123;'a': [1]&#125;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="两个列表组成字典"><a href="#两个列表组成字典" class="headerlink" title="两个列表组成字典"></a>两个列表组成字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"></span><br><span class="line">dictionary = dict(zip(keys, values)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (dictionary) </span><br><span class="line"><span class="comment"># 输出: </span></span><br><span class="line"><span class="comment">#      &#123;'a': 1, 'c': 3, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方法创建方法都可以使用以下方法遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">  <span class="keyword">print</span> (k)</span><br><span class="line">  <span class="keyword">print</span> (v)</span><br></pre></td></tr></table></figure><hr><h3 id="字典是否有该键值"><a href="#字典是否有该键值" class="headerlink" title="字典是否有该键值"></a>字典是否有该键值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用in</span></span><br><span class="line"><span class="keyword">if</span> k <span class="keyword">in</span> dic.keys():</span><br><span class="line">print(k)</span><br></pre></td></tr></table></figure><hr><h3 id="将字典写入文件"><a href="#将字典写入文件" class="headerlink" title="将字典写入文件"></a>将字典写入文件</h3><h4 id="处理fasta"><a href="#处理fasta" class="headerlink" title="处理fasta"></a>处理fasta</h4><ul><li><strong>以下是将fasta文件格式生成的字典写入文件</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义每一行的字符数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wrapped</span><span class="params">(string, every=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\n'</span>.join(string[i:i+every] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), every))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将fasta格式文件产生的字典写入文件</span></span><br><span class="line"><span class="comment"># k是&gt;开头的信息</span></span><br><span class="line"><span class="comment"># v是核苷酸或者蛋白质序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dic_file</span><span class="params">(dic,out_file)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(out_file,<span class="string">'w'</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">out.write(k+<span class="string">'\n'</span>)</span><br><span class="line">out_s=write_wrapped(v, every=<span class="number">60</span>)</span><br><span class="line">out.write(out_s)</span><br><span class="line">out.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="处理值为列表"><a href="#处理值为列表" class="headerlink" title="处理值为列表"></a>处理值为列表</h4><p>处理普通的当值为列表时的字典，形如：<code>{key:[value1,value2,value3]}</code>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当字典value是列表的时候可将值先join起来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dic_file</span><span class="params">(dic,out_file)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(out_file,<span class="string">'w'</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">out.write(k+<span class="string">'\t'</span>)</span><br><span class="line">out_s=<span class="string">'\t'</span>.join(v)</span><br><span class="line">out.write(out_s)</span><br><span class="line">out.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="获取字典最值"><a href="#获取字典最值" class="headerlink" title="获取字典最值"></a>获取字典最值</h3><p><strong>利用<code>min(dict, key=dict.get)</code></strong>：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="number">3</span>:<span class="number">2</span>&#125;</span><br><span class="line">min(d, key=d.get)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     2</span></span><br></pre></td></tr></table></figure><p></p><p><strong>利用<code>lambda</code>函数</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到索引和值</span></span><br><span class="line">min(d.items(), key=lambda x: x[1])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#     (2, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只得到值</span></span><br><span class="line">min(d, key=lambda x: d[x])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#      2</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="判断最后一行文本"><a href="#判断最后一行文本" class="headerlink" title="判断最后一行文本"></a>判断最后一行文本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bug:if second last is same as last, this will be wrong </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">last_line=total_lines[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> line == last_line:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># fix bug above</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_last_line</span><span class="params">(in_file,line_num)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(in_file,<span class="string">'r'</span>) <span class="keyword">as</span> judge_file:</span><br><span class="line">pre_total_lines=judge_file.readlines()</span><br><span class="line">total_lines=[i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pre_total_lines]</span><br><span class="line">total_line_num=len(total_lines)</span><br><span class="line"><span class="keyword">if</span> line_num==total_line_num:</span><br><span class="line">tag=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> tag</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常见错误</title>
      <link href="/posts/61409.html"/>
      <url>/posts/61409.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要整理了在Python学习过程中遇到的具有典型性的问题，搜集起来，以免以后遇到同样的错误重新找解决方法。</p></div><a id="more"></a><h2 id="常规报错"><a href="#常规报错" class="headerlink" title="常规报错"></a>常规报错</h2><h2 id="pandas报错"><a href="#pandas报错" class="headerlink" title="pandas报错"></a>pandas报错</h2><h2 id="jupyter报错"><a href="#jupyter报错" class="headerlink" title="jupyter报错"></a>jupyter报错</h2><h3 id="jupyter启动报错"><a href="#jupyter启动报错" class="headerlink" title="jupyter启动报错"></a>jupyter启动报错</h3><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\Scripts\jupyter-notebook-script.py"</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from notebook.notebookapp import main</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\notebookapp.py"</span>, line 81, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .services.kernels.kernelmanager import MappingKernelManager</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\notebook\services\kernels\kernelmanager.py"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.session import Session</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\session.py"</span>, line 61, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jupyter_client.jsonutil import extract_dates, squash_dates, date_default</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\jupyter_client\jsonutil.py"</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from dateutil.parser import parse as _dateutil_parse</span><br><span class="line">  File <span class="string">"C:\Users\user\Anaconda3\lib\site-packages\dateutil\parser.py"</span>, line 158</span><br><span class="line">    l.append(<span class="string">"%s=%s"</span> % (attr, `value`))</span><br><span class="line">                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><hr><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall python-dateutil</span><br><span class="line">pip install python-dateutil</span><br></pre></td></tr></table></figure><hr><h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p>之前安装的将印象笔记转化为markdown格式的时候安装的包将某个包的版本降低了：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ever2simple 2.0 has requirement python-dateutil&lt;2.0, but you<span class="string">'ll have python-dateutil 2.8.0 which is incompatible.</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 其他技巧整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技巧整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-数组</title>
      <link href="/posts/46714.html"/>
      <url>/posts/46714.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要对Shell的数组进行了学习，主要内容包括<code>创建数组</code>、<code>数组赋值</code>、<code>读取数组</code>、<code>获取数组长度</code>、<code>获取数组使用的下标</code>、<code>在数组末尾添加元素</code>、<code>数组排序</code>、<code>删除数组</code>和<code>关联数组</code>。</p></div><a id="more"></a><h2 id="shell数组简介"><a href="#shell数组简介" class="headerlink" title="shell数组简介"></a>shell数组简介</h2><p>数组是可以存放多个值的一种数据结构，Bash shell也支持数组，但是其对数组的支持比较有限，下面列出了Bash shell数组的特征：</p><ul><li>Bash Shell <strong>只支持一维数组(不支持多维数组)</strong></li><li>初始化时<strong>不需要定义数组大小</strong></li><li>数组元素的<strong>下标由0开始</strong>(与大部分编程语言类似)</li><li>数组用<strong>括号来表示</strong>，<strong>元素用”空格”符号分割</strong>开</li></ul><hr><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="提前创建"><a href="#提前创建" class="headerlink" title="提前创建"></a>提前创建</h3><p><strong>特殊符号<code>( )</code></strong>被用于数组的声明中，因此可以使用如下命令提前创建数组：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array=(element1 element2 element3 ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组时直接指定元素的索引值</span></span><br><span class="line">array=([1]=element1 [2]=element2 [3]=element3)</span><br></pre></td></tr></table></figure><p></p><p>更多关于特殊符号<code>( )</code>的用法参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><p><strong>也可以使用declare命令创建数组</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array=<span class="string">'(element1 element2 element3 ...)'</span></span><br></pre></td></tr></table></figure><p></p><hr><h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p>数组变量就像其它 bash 变量一样命名，当<strong>被访问的时候，它们会被自动地创建</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[1]=foo</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">  foo</span><br></pre></td></tr></table></figure><p></p><p>上面是一个赋值并访问数组元素的例子，通过<code>a[1]=foo</code>，数组索引为1(开始于0)的元素被赋值为foo(索引为0的位置可以访问，但是输出为空)；通过<code>echo ${a[1]}</code>访问数组索引为1的元素，<code>${}</code>可以进行数组操作，具体的请看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><div class="note info"><p>可以不使用连续的下标创建数组，而且下标的范围没有限制</p></div><hr><h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>在上述创建数组的过程中其实已经实现了数组的赋值：</p><ul><li><strong>单个元素</strong>赋值：<code>array[index]=value</code></li><li><strong>多个元素</strong>赋值：<code>array=(element1 element2 element3 ...)</code></li><li><strong>多个元素结合索引</strong>进行赋值：<code>array=([1]=element1 [2]=element2 [3]=element3)</code></li></ul><p><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次赋值</span></span><br><span class="line">a=(a b c)</span><br><span class="line"><span class="comment"># $&#123;a[@]&#125;是获取数组所有元素，后面会讲到</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次赋值</span></span><br><span class="line">a=(d e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a b c<br>d e f g</p></blockquote><div class="note info"><ul><li>数组的<code>index</code>是<strong>一个大于或等于零的整数（或算术表达式）</strong></li><li>数组<strong>第一个元素的下标是0</strong>， 而不是1</li><li>数组<strong>元素的值可以是一个字符串或整数</strong></li><li><strong>在不指定索引的情况下，两次赋值会出现覆盖</strong></li></ul></div><hr><h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><h3 id="读取数组单个元素"><a href="#读取数组单个元素" class="headerlink" title="读取数组单个元素"></a>读取数组单个元素</h3><p>读取数组使用特殊符号<code>${}</code>，一般形式为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><p>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=A</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[3]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>A<br>2<br>3<br>4</p></blockquote><hr><h3 id="读取数组所有元素"><a href="#读取数组所有元素" class="headerlink" title="读取数组所有元素"></a>读取数组所有元素</h3><p><strong>如果想要获取数组的所有元素，使用<code>@</code> 或 <code>*</code></strong> :<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>1 2 3 4<br>1 2 3 4</p></blockquote><p><code>@</code>和<code>*</code>的区别和使用<a href="http://showteeth.tech/posts/55603.html"><code>$*</code>或<code>$@</code>得到所有脚本变量</a>的区别相同：</p><ul><li><strong>不使用双引号括起来时完全相同</strong>：都以”element1” “element2” … “elementn” 的形式输出所有参数</li><li><strong>使用双引号括起来时不同</strong>：<code>&quot;${!array[*]}&quot;</code> 会将所有的元素作为一个整体，以”element1 element2 … elementn”的形式输出所有元素；<code>&quot;${!array[@]}&quot;</code> 会将各个元素分开，以”element1” “element2” … “elementn” 的形式输出所有元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但不使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>不使用双引号括起来时输出结果完全相同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>使用双引号括起来时输出结果不同</strong>：</p><blockquote><p>1<br>2<br>3<br>4</p></blockquote><blockquote><p>1 2 3 4</p></blockquote><div class="note info"><ul><li>读取数组所有元素需要注意<code>${array[*]}</code>和<code>${array[@]}</code>加引号和不加引号输出结果的区别</li><li>任何引用一个<strong>不带下标的数组变量，则指的是数组元素0</strong></li></ul></div><hr><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>获取数组长度(元素个数)的方法与获取字符串长度的方法相同，仍然是使用特殊符号<code>${}</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>4</p></blockquote><p><strong>如果上面不是使用了<code>@</code>和<code>*</code>，而是使用了具体的索引位置，则会得到指定索引位置的元素长度：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[1]=test_length</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[1]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>11 &emsp;&emsp;&emsp;# 输出的是test_length的长度</p></blockquote><p>还有需要注意的地方是：<strong>如果赋值时数组的索引不是连续的，数组的长度不是最大索引对应的长度，而是有具体值的索引的个数，也就是说没有赋值的那些索引不计入数组长度(但是仍然可以通过索引访问，返回结果为空)</strong>。示例如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[100]=100</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>5 &emsp;&emsp;&emsp;# 这里输出结果是5，而不是101，即使最后一个有值的索引为100，但是5-99的索引位置并没有赋值，也就没有计入数组长度</p></blockquote><div class="note info"><ul><li><strong>使用<code>@</code>和<code>*</code></strong>获取的是<strong>数组的长度</strong></li><li><strong>使用具体的索引位置</strong>获取的是<strong>指定索引位置的元素长度</strong></li><li><strong>未赋值的索引不计入输入长度的计算</strong></li></ul></div><hr><h2 id="获取数组使用的下标"><a href="#获取数组使用的下标" class="headerlink" title="获取数组使用的下标"></a>获取数组使用的下标</h2><p>因为shell数组允许赋值的数组下标包含 “间隔”，所以确定哪些下标在数组中是具有值的有时候很关键：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[*]&#125;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>0 1 2 3 100</p></blockquote><p><strong>和前面提到的使用双引号和不使用双引号括起来输出结果不同相同，这里两种方法在使用双引号括起来的时候也会存在差异</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用$&#123;!array[@]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用$&#123;!array[*]&#125;，但使用双引号括起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!array[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><code>&quot;${!array[@]}&quot;</code>输出结果：</p><blockquote><p>0<br>1<br>2<br>3<br>100</p></blockquote><p><code>&quot;${!array[*]}&quot;</code>输出结果：</p><blockquote><p>0 1 2 3 100</p></blockquote><div class="note info"><ul><li>获取数组下标时需要注意<code>${!array[*]}</code>和<code>${!array[@]}</code>加引号和不加引号输出结果的区别</li><li><code>${array[*]}</code>和<code>${array[@]}</code>是获取数组所有元素的方法，而<code>!</code>具有取反的作用，<strong>数组元素的反理解为索引</strong>的话就很好记忆了</li></ul></div><hr><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><p>如果我们需要<strong>在数组末尾附加数据</strong>，那么知道数组中元素的个数是没用的，因为通过 <code>*</code> 和 <code>@</code>表示法返回的数值<strong>不能告诉我们使用的最大数组索引</strong>，并且<strong>直接不加索引继续赋值的话第二次的赋值会覆盖前一次的赋值结果</strong>。幸运地是，shell 为我们提供了一种解决方案：<strong>通过使用 <code>+=</code> 赋值运算符，我们能够自动地把值附加到数组末尾(索引接着最后一个索引)</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=(a b c)</span><br><span class="line"><span class="built_in">test</span>[100]=d</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>+=(e f g)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;test[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!test[@]&#125;</span></span><br><span class="line"><span class="comment">#输出：0 1 2 100 101 102 103</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>Shell 没有直接对数组元素排序的方法，但是可以通过获取值然后排序再利用排序后的值重新赋值给另一个数组即可：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=(a d c f e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将排序后的结果赋值给新数组，这里使用了循环接入管道的操作</span></span><br><span class="line"><span class="comment"># 可以不使用新数组，直接赋值给原始数组即可覆盖原始数组的值</span></span><br><span class="line">a_sorted=($(<span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;a[@]&#125;</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span> |sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在同一行输出新数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;a_sorted[*]&#125;</span>"</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>a c d e f</p></blockquote><hr><h2 id="删除数组相关操作"><a href="#删除数组相关操作" class="headerlink" title="删除数组相关操作"></a>删除数组相关操作</h2><p>删除数组相关操作都会使用 <code>unset</code> 命令</p><h3 id="删除整个数组"><a href="#删除整个数组" class="headerlink" title="删除整个数组"></a>删除整个数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> foo</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出为空</span></span><br></pre></td></tr></table></figure><hr><h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=(a b c d e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b c d e f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> <span class="string">'foo[2]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：a b d e f</span></span><br></pre></td></tr></table></figure><hr><h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>现在最新的 bash 版本支持关联数组了，<strong>关联数组使用字符串而不是整数作为数组索引(AWK只支持关联数组，但可以把数字下标转化为字符)</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用-A也可以使用-a</span></span><br><span class="line"><span class="comment"># 也可以直接在使用的时候创建</span></span><br><span class="line"><span class="built_in">declare</span> -A colors</span><br><span class="line">colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#ff0000 #0000ff #00ff00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种创建输出会出问题：</span></span><br><span class="line">array=([<span class="string">"red"</span>]=<span class="string">"#ff0000"</span> [<span class="string">"green"</span>]=<span class="string">"#00ff00"</span> [<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="comment"># 输出：#0000ff</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/chapter4/46.html" target="_blank" rel="noopener">shell-guide</a></li><li><a href="https://baijiahao.baidu.com/s?id=1608244941950314734&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/hanframe/p/3564313.html" target="_blank" rel="noopener">shell编程中使用数组进行操作</a></li><li><a href="http://www.runoob.com/linux/linux-shell-array.html" target="_blank" rel="noopener">Shell 数组</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系列(一):Git简介</title>
      <link href="/posts/60073.html"/>
      <url>/posts/60073.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在有了前面两篇转载的偏实战文章的学习之后，打算针对Git进行一系列的学习，这次是偏系统，因为在实战学习中发现有些命令和操作不是很懂，同时在这篇文章的参考链接中也给出了一些Git相关的系列教程</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></li><li><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5" target="_blank" rel="noopener">Git官方教程</a></li><li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/article-8478-1.html" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://www.softwhy.com/daima/git_code/" target="_blank" rel="noopener">Git实例</a></li><li></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-Git常用命令及日常问题集锦</title>
      <link href="/posts/13404.html"/>
      <url>/posts/13404.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的博客，主要记录了<code>Git</code>的常用命令，包括<code>新建代码库</code>、<code>Git相关配置</code>、<code>添加文件到暂存区</code>、<code>删除工作区文件</code>、<code>代码提交</code>、<code>分支操作</code>、<code>标签</code>、<code>查看信息</code>、<code>远程同步</code>，还整理了一些使用过程中<code>常见的问题</code>。</p></div><a id="more"></a><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><ul><li>在<strong>当前目录</strong>新建一个Git代码库(初始化)：<code>git init</code></li><li><strong>新建一个目录</strong>，<strong>将其初始化</strong>为Git代码库：<code>git init [project-name]</code></li><li><strong>下载一个项目和它的整个代码历史</strong>：<code>git clone [url]</code></li></ul><hr><h2 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h2><ul><li><strong>显示当前</strong>的Git配置：<code>git config --list</code></li><li><strong>编辑</strong>Git配置文件：<code>git config -e [--global]</code></li><li><strong>设置提交代码时的用户信息</strong>：<code>git config [--global] user.name &quot;[name]&quot;</code>和<code>git config [--global] user.email &quot;[email address]&quot;</code></li></ul><hr><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><ul><li><strong>添加</strong>指定<strong>文件</strong>到<strong>暂存区</strong>：<code>git add [file1] [file2] ...</code></li><li>添加指定<strong>目录到暂存区</strong>，<strong>包括子目录</strong>：<code>git add [dir]</code></li><li>添加<strong>当前目录的所有文件到暂存区</strong>：<code>git add .</code></li><li>添加<strong>每个变化</strong>前，都会<strong>要求确认</strong>(对于<strong>同一个文件的多处变化</strong>，可以实现<strong>分次提交</strong>)：<code>git add -p</code></li></ul><hr><h2 id="删除工作区文件"><a href="#删除工作区文件" class="headerlink" title="删除工作区文件"></a>删除工作区文件</h2><ul><li><strong>删除工作区</strong>文件，并且将这次删除<strong>放入暂存区</strong>：<code>git rm [file1] [file2] ...</code></li><li><strong>停止追踪</strong>指定文件，但该文件会<strong>保留在工作区</strong>：<code>git rm --cached [file]</code></li><li><strong>改名</strong>文件，并且将这个<strong>改名放入暂存区</strong>：<code>git mv [file-original] [file-renamed]</code></li></ul><hr><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><ul><li>提交<strong>暂存区到仓库区</strong>：<code>git commit -m [message]</code></li><li>提交<strong>暂存区的指定文件到仓库区</strong>：<code>git commit [file1] [file2] ... -m [message]</code></li><li>提交<strong>工作区自上次commit之后的变化，<u>直接到仓库区</u></strong>：<code>git commit -a</code><br><br></li><li>提交时<strong>显示所有diff信息</strong>：<code>git commit -v</code><br><br></li><li><strong>使用一次新的commit，替代上一次提交(如果代码没有任何新变化，则用来改写上一次commit的提交信息)</strong>：<code>git commit --amend -m [message]</code></li><li><strong>重做上一次commit，并包括指定文件的新变化</strong>：<code>git commit --amend [file1] [file2] ...</code></li></ul><hr><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ul><li><strong>列出</strong>所有<strong>本地分支</strong>：<code>git branch</code></li><li><strong>列出</strong>所有<strong>远程分支</strong>：<code>git branch -r</code></li><li><strong>列出</strong>所有<strong>本地分支和远程分支</strong>：<code>git branch -a</code><br><br></li><li><strong>新建</strong>一个分支，但<strong>依然停留在当前分支</strong>：<code>git branch [branch-name]</code></li><li><strong>新建</strong>一个分支，并<strong>切换到该分支</strong>：<code>git checkout -b [branch]</code></li><li><strong>新建</strong>一个分支，<strong>指向指定commit</strong>：<code>git branch [branch] [commit]</code></li><li><strong>新建</strong>一个分支，<strong>与指定的远程分支建立追踪关系(连接)</strong>：<code>git branch --track [branch] [remote-branch]</code><br><br></li><li><strong>切换</strong>到<strong>指定</strong>分支，并<strong>更新工作区</strong>：<code>git checkout [branch-name]</code></li><li><strong>切换</strong>到<strong>上一个</strong>分支：<code>git checkout -</code></li><li><strong>建立追踪关系(连接)</strong>，在<strong>现有分支</strong>与<strong>指定的远程分支</strong>之间：<code>git branch --set-upstream [branch] [remote-branch]</code><br><br></li><li><strong>合并指定分支</strong>到<strong>当前分支</strong>：<code>git merge [branch]</code></li><li><strong>选择一个commit</strong>，<strong>合并进当前分支</strong>：<code>git cherry-pick [commit]</code><br><br></li><li><strong>删除</strong>分支：<code>git branch -d [branch-name]</code></li><li><strong>删除远程</strong>分支：<code>git push origin --delete [branch-name]</code>或者<code>git branch -dr [remote/branch]</code></li></ul><hr><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><strong>列出</strong>所有tag：<code>git tag</code></li><li><strong>查看</strong>tag信息：<code>git show [tag]</code><br><br></li><li><strong>新建</strong>一个tag<strong>在当前commit</strong>：<code>git tag [tag]</code></li><li><strong>新建</strong>一个tag在<strong>指定commit</strong>：<code>git tag [tag] [commit]</code><br><br></li><li><strong>删除本地</strong>tag：<code>git tag -d [tag]</code></li><li><strong>删除远程</strong>tag：<code>git push origin :refs/tags/[tagName]</code><br><br></li><li><strong>提交指定</strong>tag：<code>git push [remote] [tag]</code></li><li><strong>提交所有</strong>tag：<code>git push [remote] --tags</code><br><br></li><li><strong>新建一个分支</strong>，<strong>指向某个tag</strong>：<code>git checkout -b [branch] [tag]</code></li></ul><hr><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul><li><strong>显示有变更的文件</strong>：<code>git status</code><br><br></li><li>显示<strong>暂存区</strong>和<strong>工作区的差异</strong>：<code>git diff</code></li><li>显示<strong>暂存区</strong>和<strong>上一个commit的差异</strong>：<code>git diff --cached [file]</code></li><li>显示<strong>工作区</strong>与<strong>当前分支最新commit之间的差异</strong>：<code>git diff HEAD</code></li><li>显示<strong>两次提交之间的差异</strong>：<code>git diff [commit_1] [commit_2]</code></li><li><strong>显示今天你写了多少行代码</strong>：<code>git diff --shortstat &quot;@{0 day ago}&quot;</code><br><br></li><li>显示<strong>某次提交</strong>的<strong>元数据和内容变化</strong>：<code>git show [commit]</code></li><li>显示<strong>某次提交发生变化的文件</strong>：<code>git show --name-only [commit]</code></li><li>显示<strong>某次提交时，某个文件的内容</strong>：<code>git show [commit]:[filename]</code><br><br></li><li><strong>显示当前分支的版本历史</strong>：<code>git log</code></li><li><strong>显示commit历史</strong>，以及<strong>每次commit发生变更的文件</strong>：<code>git log --stat</code></li><li><strong>根据关键词搜索提交历史</strong>：<code>git log -S [keyword]</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>每个commit占据一行</strong>：<code>git log [tag] HEAD --pretty=format:%s</code></li><li>显示<strong>某个commit之后</strong>的<strong>所有变动</strong>，<strong>其”提交说明”必须符合搜索条件</strong>：<code>git log [tag] HEAD --grep feature</code></li><li>显示<strong>某个文件的版本历史</strong>，<strong>包括文件改名</strong>：<code>git log --follow [file]</code>或者<code>git whatchanged [file]</code></li><li>显示<strong>指定文件</strong>相关的<strong>每一次diff</strong>：<code>git log -p [file]</code></li><li><strong>显示过去5次提交</strong>，且<strong>每个commit占据一行</strong>：<code>git log -5 --pretty --oneline</code><br><br></li><li><strong>记录几乎当前分支的所有改变，带版本号</strong>：<code>git reflog</code><br><br></li><li>显示<strong>所有提交过的用户</strong>，<strong>按提交次数排序</strong>：<code>git shortlog -sn</code></li><li>显示<strong>指定文件</strong>是<strong>什么人在什么时间修改过</strong>：<code>git blame [file]</code></li></ul><hr><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><ul><li><strong>下载远程仓库的所有变动</strong>：<code>git fetch [remote]</code></li><li><strong>取回远程仓库的变化</strong>，并<strong>与本地分支合并</strong>：<code>git pull [remote] [branch]</code><br><br></li><li>上传<strong>本地指定分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] [branch]</code></li><li><strong>强行</strong>推送<strong>当前分支</strong>到<strong>远程仓库</strong>，<strong>即使有冲突</strong>：<code>git push [remote] --force</code></li><li>推送<strong>所有分支</strong>到<strong>远程仓库</strong>：<code>git push [remote] --all</code><br><br></li><li><strong>显示所有远程仓库</strong>：<code>git remote -v</code></li><li>显示<strong>某个远程仓库</strong>的信息：<code>git remote show [remote]</code></li><li><strong>增加一个新的远程仓库</strong>，<strong>并命名</strong>：<code>git remote add [shortname] [url]</code></li></ul><hr><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li>恢复<strong>暂存区的指定文件</strong>到<strong>工作区</strong>：<code>git checkout [file]</code></li><li>恢复<strong>暂存区的所有文件</strong>到<strong>工作区</strong>：<code>git checkout .</code></li><li>恢复<strong>某个commit的指定文件</strong>到<strong>暂存区和工作区</strong>：<code>git checkout [commit] [file]</code><br><br></li><li>重置<strong>暂存区的指定文件</strong>，与<strong>上一次commit保持一致</strong>，但<strong>工作区不变</strong>：<code>git reset [file]</code></li><li>重置<strong>暂存区与工作区</strong>，与<strong>上一次commit保持一致</strong>：<code>git reset --hard</code></li><li>重置<strong>当前分支的指针为指定commit</strong>，同时<strong>重置暂存区</strong>，但<strong>工作区不变</strong>：<code>git reset [commit]</code></li><li>重置<strong>当前分支的HEAD为指定commit</strong>，同时<strong>重置暂存区和工作区</strong>，<strong>与指定commit一致</strong>：<code>git reset --hard [commit]</code></li><li>重置<strong>当前HEAD为指定commit</strong>，但<strong>保持暂存区</strong>和<strong>工作区不变</strong>：<code>git reset --keep [commit]</code><br><br></li><li><strong>新建一个commit</strong>，<strong>用来撤销指定commit(后者的所有变化都将被前者抵消，并且应用到当前分支)</strong>：<code>git revert [commit]</code><br><br></li><li><strong>暂时将未提交的变化移除，稍后再移入</strong>：<code>git stash</code>和<code>git stash pop</code></li></ul><div><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr><div class="RichText ztext Post-RichText"><h2 id="常见问题">常见问题</h2><h3 id="failed to push some refs to git">failed to push some refs to git</h3><p style="font-weight:700">Question1</p><div class="highlight"><pre><code class="language-text"><span></span>如何解决: failed to push some refs to git    </code></pre></div><p style="font-weight:700">Answer1</p><div class="highlight"><pre><code class="language-text"><span></span>git pull --rebase origin master  # 进行代码合并    git push -u origin master  # 即可完成代码上传    </code></pre></div><hr><h3 id="git pull未指定本地与远程连接报错">git pull未指定本地与远程连接报错</h3><p style="font-weight:700">Question2</p><p><code>If you wish to set tracking information for this branch you can do so with:</code></p><p><code>git branch --set-upstream-to=origin/ master</code></p><p style="font-weight:700">Answer2</p><p>指定当前工作分支跟远程仓库分支之间的联系</p><p><code>git branch --set-upstream master origin/master</code></p><hr><h3 id="获取最新代码报错">获取最新代码报错</h3><p style="font-weight:700">Question3</p><p><code>git pull</code> 获取最新代码报以下错误</p><p><code>fatal: refusing to merge unrelated histories</code></p><p style="font-weight:700">Answer3</p><p>git pull之后加上可选参数 --allow-unrelated-histories 强制合并</p><p><code>git pull origin master --allow-unrelated-histories</code></p><hr><h3 id="使用钩子报错">使用钩子报错</h3><p style="font-weight:700">Question4</p><p>使用钩子<code>pre-commit</code>，提交代码提示如下错误：</p><div class="highlight"><pre><code class="language-text"><span></span>$ git commit -m '.'    sh: eslint: command not found    pre-commit:    pre-commit: We've failed to pass the specified git pre-commit hooks as the `fix`    pre-commit: hook returned an exit code (1). If you're feeling adventurous you can    pre-commit: skip the git pre-commit hooks by adding the following flags to your commit:    pre-commit:    pre-commit:   git commit -n (or --no-verify)    pre-commit:    pre-commit: This is ill-advised since the commit is broken.    pre-commit:    </code></pre></div><p style="font-weight:700">Answer4</p><ul><li>打开项目中的<code>.git/hooks</code>文件夹，找到<code>pre-commit.sample</code>文件，将以下代码替换到文件中，或者，<code>npm install pre-commit --save</code>也可以，这个命令会自动执行以下操作。</li></ul><div class="highlight"><pre><code class="language-text"><span></span>#!/bin/bash    TSLINT="$(git rev-parse --show-toplevel)/node_modules/.bin/tslint"    for file in $(git diff --cached --name-only | grep -E '\.ts$')    do            git show ":$file" | "$TSLINT" "$file"            if [ $? -ne 0 ]; then                    exit 1            fi    done    </code></pre></div><ul><li>将<code>pre-commit.sample</code>文件名修改为<code>pre-commit</code>。</li></ul><hr><h3 id=".gitignore规则不生效">.gitignore规则不生效</h3><p style="font-weight:700">Question5</p><p><code>.gitignore规则不生效的解决办法</code></p><p style="font-weight:700">Answer5</p><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</p><div class="highlight"><pre><code class="language-text"><span></span>git rm -r --cached . 或者 git rm -r README.md    git add .    git commit -m 'update .gitignore'    </code></pre></div><p><br>作者：五月君<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/269298" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/26929</span><span class="invisible">8</span><span class="ellipsis"></span></a><br>来源：慕课网<br>本文首次发布于慕课网 ，转载请注明出处，谢谢合作</p></div><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-Git讲解与使用实战</title>
      <link href="/posts/13035.html"/>
      <url>/posts/13035.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇转载的文章，主要偏向实战，通过实战讲解Git的用法，比较全面，包括<code>创建版本库</code>、<code>版本回退</code>、<code>撤销修改和删除文件操作</code>、<code>远程仓库相关操作</code>以及<code>分支操作</code>，总的来说是一篇不错的文章。</p></div><a id="more"></a><div class="RichText ztext Post-RichText"><h2 id="简介与安装">Git简介与安装</h2><h3 id="Git是什么？">Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。工作原理 / 流程：</p><img 图片1 src="http://img.mukewang.com/59c31e4400013bc911720340.png" alt="图片描述" data-original="http://img.mukewang.com/59c31e4400013bc911720340.png" style="cursor:pointer;display:block"><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><hr><h3 id="SVN与Git的最主要的区别">SVN与Git的最主要的区别</h3><p><code>SVN</code>是<strong>集中式版本控制系统</strong>，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。<strong>集中式版本控制系统是必须联网才能工作</strong>，如果在<u>局域网</u>还可以，带宽够大，速度够快，如果在<u>互联网下</u>，如果网速慢的话，就纳闷了。</p><p><code>Git</code>是<strong>分布式版本控制系统</strong>，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就<strong>不需要联网</strong>了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><hr><h3 id="在windows上安装Git">在windows上安装Git</h3><p><code>msysgit</code>是 windows版的Git,如下：</p><img 图片2 src="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfa400019aee02460029.jpg" style="cursor:pointer;display:block"><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 "Git --&gt; Git Bash",如下：<br></p><img 图片3 src="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfd20001c2d602530073.jpg" style="cursor:pointer;display:block"><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：<br></p><img 图片4 src="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1cfe70001462e06680380.jpg" style="cursor:pointer;display:block"><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><img 图片5 src="http://img.mukewang.com/59c1d041000110d906460213.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1d041000110d906460213.jpg" style="cursor:pointer;display:block"><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p>注意：<code>git config --global</code> 参数，有了这个参数，表示<strong>你这台机器上所有的Git仓库都会使用这个配置</strong>，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><hr><br><h2 id="Git使用">Git使用</h2><h3 id="创建版本库">创建版本库</h3><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><img 图片6 src="http://img.mukewang.com/59c1d1060001909005780268.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d1060001909005780268.png" style="cursor:pointer;display:block"><p>pwd 命令是用于显示当前的目录。</p><h4 id="把这个目录变成git可以管理的仓库">把这个目录变成git可以管理的仓库</h4><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><img 图片7 src="http://img.mukewang.com/59c1d12b0001b08305270077.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d12b0001b08305270077.png" style="cursor:pointer;display:block"><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><img 图片8 src="http://img.mukewang.com/59c1d143000112df06120173.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d143000112df06120173.png" style="cursor:pointer;display:block"><hr><h4 id="把文件添加到版本库中">把文件添加到版本库中</h4><p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><b>示例demo：</b></p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p><strong>第一步：使用命令 <code>git add readme.txt</code>添加到暂存区</strong>里面去，如下：<br></p><img 图片9 src="http://img.mukewang.com/59c1d2080001e4bb04490080.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2080001e4bb04490080.png" style="cursor:pointer;display:block"><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p><strong>第二步：用命令 <code>git commit</code>告诉Git，把文件提交到仓库</strong>:<br></p><img 图片10 src="http://img.mukewang.com/59c1d2200001f05b04930121.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2200001f05b04930121.png" style="cursor:pointer;display:block"><p>这样我们就已经提交了一个readme.txt文件了</p><p><strong>第三步：使用命令<code>git status</code>来查看是否还有文件未提交</strong>，如下：<br></p><img 图片11 src="http://img.mukewang.com/59c1d2340001a87904690107.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2340001a87904690107.png" style="cursor:pointer;display:block"><p>说明没有任何文件未提交</p><p><strong>第四步：继续来修改readme.txt内容，比如我在下面添加一行2222222222内容，继续使用<code>git status</code>来查看下结果</strong>，如下：<br></p><img 图片12 src="http://img.mukewang.com/59c1d2500001634606170171.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2500001634606170171.png" style="cursor:pointer;display:block"><p>上面的命令告诉我们 readme.txt文件已被修改，但是<strong>未被提交的修改</strong>。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？</p><p><strong>第五步：使用<code>git diff readme.txt</code>查看文件到底改了什么内容</strong>，如下：<br></p><img 图片13 src="http://img.mukewang.com/59c1d2cb00010a0304960202.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2cb00010a0304960202.png" style="cursor:pointer;display:block"><p>如上可以看到，readme.txt文件内容从一行11111111改成二行添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是<code>git add</code>；第二步是：<code>git commit</code>)，如下：<br></p><img 图片14 src="http://img.mukewang.com/59c1d2ff00015a9606180342.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d2ff00015a9606180342.png" style="cursor:pointer;display:block"><hr><br><h3 id="版本回退">版本回退</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为<strong>33333333333333</strong>继续执行命令如下：</p><img 图片15 src="http://img.mukewang.com/59c1d32b00012ba604570139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d32b00012ba604570139.png" style="cursor:pointer;display:block"><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？</p><h4 id="使用命令 git log 查看历史记录">使用命令 git log 查看历史记录</h4><img 图片16 src="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d34e0001a1ac06050304.png" style="cursor:pointer;display:block"><p><code>git log</code>命令显示<strong>从最近到最远</strong>的修改日志，我们可以看到最近有三次提交，最近的一次是：增加内容为333333；上一次是添加内容222222；第一次默认是 111111.<br></p><p>如果<strong>嫌上面显示的信息太多的话，我们可以使用命令 <code>git log –pretty=oneline</code></strong>演示如下：<br></p><img 图片17 src="http://img.mukewang.com/59c1d3fc00013ad206040097.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d3fc00013ad206040097.png" style="cursor:pointer;display:block"><hr><h4 id="使用命令 git reset 进行版本回退">使用命令 git reset 进行版本回退</h4><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令：<br></p><ul><li>第一种是：<code>git reset --hard HEAD^</code>，那么如果要回退到<strong>上上个版本只需把HEAD^ 改成 HEAD^^，以此类推</strong></li><li>第二种是：<code>git reset --hard HEAD~1</code>，第一种方法如果要回退到前100个版本的话，肯定不方便，这时可以使用简便命令操作：<code>git reset --hard HEAD~100</code></li></ul><p><strong>未回退之前</strong>的readme.txt内容如下：<br></p><img 图片18 src="http://img.mukewang.com/59c1d4140001a0c404490165.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4140001a0c404490165.png" style="cursor:pointer;display:block"><p>如果想<strong>回退到上一个版本</strong>的命令如下操作：</p><img 图片19 src="http://img.mukewang.com/59c1d429000199fc04610105.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d429000199fc04610105.png" style="cursor:pointer;display:block"><p><strong>使用命令cat readme.txt查看下 readme.txt内容</strong>，如下：<br></p><img 图片20 src="http://img.mukewang.com/59c1d4470001fcdc04360085.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d4470001fcdc04360085.png" style="cursor:pointer;display:block"><p>可以看到，<strong>内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息</strong>，如下：<br></p><img 图片21 src="http://img.mukewang.com/59c1d45300012d9604800219.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d45300012d9604800219.png" style="cursor:pointer;display:block"><p>发现增加333333内容已经没有了</p><hr><h4 id="使用命令 git reset 结合 git reflog 进行版本号回退">使用命令 git reset 结合 git reflog 进行版本号回退</h4><p>如果现在想<strong>回退到最新的版本</strong>，如：有333333的内容要如何恢复呢？我们可以<strong>通过版本号回退</strong>，使用命令：<code>git reset --hard 版本号</code> ，但是现在的问题<strong>假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？</strong><br></p><p>可以<strong>通过<code>git reflog</code>命令获取到版本号</strong>，演示如下：<br></p><img 图片22 src="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d51a0001d5fc05100122.png" style="cursor:pointer;display:block"><p>通过上面的显示我们可以知道，增加内容3333的版本号是 <code>6fcfc89</code>。我们现在可以使用命令：<code>git reset --hard 6fcfc89</code>来恢复了，演示如下：<br></p><img 图片23 src="http://img.mukewang.com/59c1d53a0001b8b305050153.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d53a0001b8b305050153.png" style="cursor:pointer;display:block"><p>可以看到目前已经是最新的版本了。</p><hr><br><h3 id="理解工作区与暂存区的区别">理解工作区与暂存区的区别</h3><ul><li>工作区：就是你在<strong>电脑上看到的目录</strong>，比如目录下testgit里的文件(<code>.git</code>隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li><li>版本库(Repository)：<strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库</strong>。其中版本库里面存了很多东西，其中最重要的就是<strong>stage(暂存区)</strong>，还有Git为我们<strong>自动创建了第一个分支master</strong>,以及<strong>指向master的一个指针HEAD</strong>。</li></ul><p>我们前面说过使用<strong>Git提交文件到版本库有两步</strong>：</p><ul><li>第一步：是使用<code>git add</code>把文件添加进去，实际上就是把文件<strong>添加到暂存区</strong></li><li>第二步：使用<code>git commit</code>提交更改，实际上就是<strong>把暂存区的所有内容提交到当前分支上</strong></li></ul><p>继续使用demo来演示下：</p><p>我们在readme.txt再<u>添加一行内容为4444444</u>，接着在目录下<u>新建一个文件为test.txt 内容为test</u>，我们先用命令<code>git status</code>来查看下状态，如下：</p><img 图片24 src="http://img.mukewang.com/59c1d55a0001a3c306430241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d55a0001a3c306430241.png" style="cursor:pointer;display:block"><p>现在我们先<strong>使用<code>git add</code>命令把2个文件都添加到暂存区</strong>中，再使用<code>git status</code>来查看下状态，如下：</p><img 图片25 src="http://img.mukewang.com/59c1d56a0001a28704700241.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d56a0001a28704700241.png" style="cursor:pointer;display:block"><p>接着我们可以<strong>使用<code>git commit</code>一次性提交到分支上</strong>，如下：</p><img 图片26 src="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d57b0001b4fe06190166.png" style="cursor:pointer;display:block"><hr><br><h3 id="撤销修改和删除文件操作">撤销修改和删除文件操作</h3><h4 id="撤销修改">撤销修改</h4><p>现在在readme.txt文件里面增加一行内容为555555555555，我们先通过命令查看如下：<br></p><img 图片27 src="http://img.mukewang.com/59c1d5e40001806803930139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5e40001806803930139.png" style="cursor:pointer;display:block"><p>在我<strong>未提交之前</strong>，我发现添加5555555555555内容有误，所以我得马上<strong>恢复以前的版本</strong>，现在我可以有如下几种方法可以做修改：</p><ul><li>第一：如果我知道要删掉那些内容的话，直接<strong>手动更改</strong>去掉那些需要的文件，然后add添加到暂存区，最后commit掉</li><li>第二：使用<code>git reset --hard HEAD^</code>直接恢复到上一个版本</li><li>第三：使用撤销命令<code>git checkout --</code>，下面讲解如何使用撤销命令</li></ul><p>首先在做撤销之前，我们可以先用<code>git status</code>查看下当前的状态。如下所示：</p><img 图片28 src="http://img.mukewang.com/59c1d5fa0001b07806400168.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d5fa0001b07806400168.png" style="cursor:pointer;display:block"><p>可以发现，Git会告诉你，<strong><code>git checkout -- file</code>可以丢弃工作区的修改</strong>，例如使用<code>git checkout -- readme.txt</code>：</p><img 图片29 src="http://img.mukewang.com/59c1d6390001419705210140.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6390001419705210140.png" style="cursor:pointer;display:block"><p><strong>命令<code>git checkout --readme.txt</code>意思就是：把readme.txt文件在工作区做的修改全部撤销</strong>，这里有2种情况：</p><ul><li>readme.txt自动修改后，还<strong>没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态</strong></li><li>readme.txt<strong>已经放入暂存区了，接着又作了修改，撤销修改就回到<u>添加暂存区后</u>的状态</strong></li></ul><p><strong>也就是说<code>git checkout --readme.txt</code>只能撤销没有提交到暂存区的修改</strong></p><p>对于上面列举的<strong>第二种情况</strong>，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我<code>git add</code>添加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><img 图片30 src="http://img.mukewang.com/59c1d6ca0001782f06160482.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6ca0001782f06160482.png" style="cursor:pointer;display:block"><p><mark>注意：命令<code>git checkout -- readme.txt</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了。</mark></p><hr><h4 id="删除文件">删除文件</h4><p>假如我现在版本库testgit目录<u>添加一个文件b.txt,然后提交</u>，如下：<br></p><img 图片31 src="http://img.mukewang.com/59c1d6de0001a31606390392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d6de0001a31606390392.png" style="cursor:pointer;display:block"><p>如上：一般情况下，可以<strong>直接在文件目录中把文件删了</strong>，或者<strong>使用如上<code>rm</code>命令：<code>rm b.txt</code></strong>，如果我想<strong>彻底从版本库中删掉了此文件的话，可以再执行commit命令提交掉</strong>，现在目录是这样的：<br></p><img 图片32 src="http://img.mukewang.com/59c1d78200017e8f07030192.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d78200017e8f07030192.png" style="cursor:pointer;display:block"><hr><h4 id="撤销删除操作">撤销删除操作</h4><p>只要<strong><u>没有commit之前</u>，如果我想在版本库中恢复此文件如何操作呢？</strong>，可以使用如下命令<strong><code>git checkout -- b.txt</code></strong>，如下所示：</p><img 图片33 src="http://img.mukewang.com/59c1d7980001368e05570244.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7980001368e05570244.png" style="cursor:pointer;display:block"><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><img 图片34 src="http://img.mukewang.com/59c1d7b70001308907550258.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7b70001308907550258.png" style="cursor:pointer;display:block"><hr><br><h3 id="远程仓库">远程仓库</h3><h4 id="建立传输连接">建立传输连接</h4><p>以Github为例进行远程仓库的操作，首先需要建立本地Git仓库和Github仓库之间的传输(通过SSH加密的)连接</p><p><strong>第一步：创建SSHKey</strong>。在用户主目录下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入命令：<code>ssh-keygen -t rsa –C “youremail@example.com”</code>, 结果如下所示：</p><img 图片35 src="http://img.mukewang.com/59c1d7d7000120d107530169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7d7000120d107530169.png" style="cursor:pointer;display:block"><p>注意：<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第二步：在Github中添加公钥</strong>。登录Github,打开“settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴<code>id_rsa.pub</code>文件的内容。<br></p><img 图片36 src="http://img.mukewang.com/59c1d7ef0001c75411330860.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d7ef0001c75411330860.png" style="cursor:pointer;display:block"><p>点击Add Key，你就应该可以看到已经添加的key。<br></p><img 图片37 src="http://img.mukewang.com/59c1d8540001eb3707620373.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8540001eb3707620373.png" style="cursor:pointer;display:block"><hr><h4 id="添加远程库">添加远程库</h4><p><strong>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在Github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样Github的仓库可以作为备份，又可以其他人通过该仓库来协作。</strong></p><p>首先，登录Github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><img 图片38 src="http://img.mukewang.com/59c1d86a0001044b10840605.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d86a0001044b10840605.png" style="cursor:pointer;display:block"><p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br></p><img 图片39 src="http://img.mukewang.com/59c1d8850001b5ea10260661.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8850001b5ea10260661.png" style="cursor:pointer;display:block"><p>目前，在GitHub上的这个testgit仓库还是空的，GitHub提示我们，<strong>可以从这个仓库克隆出新的仓库</strong>，<strong>也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库</strong>。<br>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p><img 图片40 src="http://img.mukewang.com/59c1d8a70001c86206320252.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8a70001c86206320252.png" style="cursor:pointer;display:block"><p><strong>把本地库的内容推送到远程，使用<code>git push</code>命令，实际上是把当前分支master推送到远程。</strong></p><div class="note info"><p>由于远程库是空的，我们第一次推送master分支时，加上了<code>–u</code>参数，<strong>Git不但会把本地的master分支内容推送的远程新的master分支</strong>，还会<strong>把本地的master分支和远程的master分支关联起来</strong>，在以后的推送或者拉取时就可以简化命令。</p></div><p>推送成功后，可以立刻在Github页面中看到远程库的内容已经和本地一模一样了:<br></p><img 图片41 src="http://img.mukewang.com/59c1d8bb00019ff310480655.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d8bb00019ff310480655.png" style="cursor:pointer;display:block"><p><strong>从现在起，只要本地作了提交，就可以通过命令：<code>git push origin master</code>把本地master分支的最新修改推送到Github上了，现在你就拥有了真正的分布式版本库了。</strong></p><hr><h4 id="克隆远程库到本地">克隆远程库到本地</h4><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。现在我们想，假如<strong>远程库有新的内容了，我想克隆到本地来，如何克隆呢？</strong></p><p>首先，登录Github，创建一个新的仓库，名字叫testgit2，如下：</p><img 图片42 src="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d95e0001f0fc10450604.png" style="cursor:pointer;display:block"> <img 图片43 src="http://img.mukewang.com/59c1d97400014d4e10360484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d97400014d4e10360484.png" style="cursor:pointer;display:block"><p>接下来，使用命令<code>git clone</code>克隆一个本地库了。如下所示：</p><img 图片44 src="http://img.mukewang.com/59c1d9860001e0d806370127.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9860001e0d806370127.png" style="cursor:pointer;display:block"><p>操作完成后可以发现在我本地目录下生成testgit2目录了，如下所示：</p><img 图片45 src="http://img.mukewang.com/59c1d99500016a2e07130197.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d99500016a2e07130197.png" style="cursor:pointer;display:block"><hr><br><h3 id="分支操作">分支操作</h3><p>在版本回填退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<strong>主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p><strong>Git的分支操作主要包括：创建分支、合并分支、删除分支</strong></p><h4 id="创建分支">创建分支</h4><p>首先，我们来<strong>创建dev分支</strong>，然后<strong>切换到dev分支上</strong>，如下操作：</p><img 图片46 src="http://img.mukewang.com/59c1d9aa0001c15604080167.png" alt="图片描述" data-original="http://img.mukewang.com/59c1d9aa0001c15604080167.png" style="cursor:pointer;display:block"><div class="note info"><ul><li><strong><code>git checkout</code>命令加上<code>–b</code>参数表示创建并切换，相当于2条命令</strong>：<ul><li><strong><code>git branch dev</code>(新建分支)</strong></li><li><strong><code>git checkout dev</code>(切换分支)</strong></li></ul></li><li><strong><code>git branch</code>查看分支，会列出所有的分支，当前分支前面会添加一个星号</strong></li></ul></div><p>接下来我们<strong>在dev分支上</strong>继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><img 图片47 src="http://img.mukewang.com/59c1da3f0001b5b703890392.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da3f0001b5b703890392.png" style="cursor:pointer;display:block"><p>现在dev分支工作已完成，现在我们<strong>切换到主分支master</strong>上，继续查看readme.txt内容如下：</p><img 图片48 src="http://img.mukewang.com/59c1da520001d44c06340206.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da520001d44c06340206.png" style="cursor:pointer;display:block"><div class="note info"><p>不同分支上的内容修改是不共享的，如果想要共享需要使用合并操作，具体请看下文</p></div><hr><h4 id="合并分支">合并分支</h4><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令<code>git merge dev</code>如下所示：<br></p><img 图片49 src="http://img.mukewang.com/59c1da69000145ca05320255.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da69000145ca05320255.png" style="cursor:pointer;display:block"><ul><li><strong><code>git merge</code>命令用于合并指定分支到当前分支上</strong>，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的</li><li><strong>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快</strong></li></ul><hr><h4 id="删除分支">删除分支</h4><p>合并完成后，我们可以使用命令<code>git branch –d dev</code>删除dev分支了，操作如下：</p><img 图片50 src="http://img.mukewang.com/59c1da91000120cd06430139.png" alt="图片描述" data-original="http://img.mukewang.com/59c1da91000120cd06430139.png" style="cursor:pointer;display:block"><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><hr><h4 id="分支合并冲突">分支合并冲突</h4><p><mark>当我们同时在两个分支中修改同一个文件，并将其合并的时候会出现分支合并冲突</mark>，示例如下：<br><strong>首先</strong>，先新建一个新分支，比如名字叫fenzhi1，<strong>在readme.txt添加一行内容8888888，然后提交</strong>，如下所示：<br></p><img 图片51 src="http://img.mukewang.com/59c1db410001036105690462.png" alt="图片描述" data-original="http://img.mukewang.com/59c1db410001036105690462.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，我们现在<strong>切换到master分支上来，也在readme.txt最后一行添加内容，内容为99999999，然后提交</strong>，如下所示：</p><img 图片52 src="http://img.mukewang.com/59c1daaf0001133205840500.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daaf0001133205840500.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们在master分支上来合并fenzhi1，<strong>直接使用<code>git merge</code>会提示conflict，然后使用<code>git status</code>查看发现在两个分支中readme.txt都被修改了，此时打开readme.txt文件发现出现了冲突的内容显示</strong>，具体内容和操作截图如下：</p><img 图片53 src="http://img.mukewang.com/59c1daff000106eb06340589.png" alt="图片描述" data-original="http://img.mukewang.com/59c1daff000106eb06340589.png" style="cursor:pointer;display:block"><p><strong>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以手动对readme.txt文件进行如下修改后保存</strong>：<br></p><img 图片54 src="http://img.mukewang.com/59c1dbaf00015f2205770266.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbaf00015f2205770266.png" style="cursor:pointer;display:block"><p><strong>最后</strong>，使用命令<code>git log</code>命令查看分支合并的情况：<br></p><img 图片55 src="http://img.mukewang.com/59c1dbc50001076c04970869.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbc50001076c04970869.png" style="cursor:pointer;display:block"><hr><h4 id="分支合并模式">分支合并模式</h4><p><strong>通常合并分支时，Git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</strong><br>首先我们来做demo演示下：</p><div class="highlight"><pre><code class="language-text">            创建一个dev分支;            修改readme.txt内容;            添加到暂存区;            切换回主分支(master);            合并dev分支，使用命令 git merge –no-ff -m “注释” dev;            查看历史记录;        </code></pre></div><img 图片56 src="http://img.mukewang.com/59c1dbdc0001836d06030780.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dbdc0001836d06030780.png" style="cursor:pointer;display:block"><hr><h4 id="分支管理策略">分支管理策略</h4><div class="note info"><p><strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</strong></p></div><hr><h4 id="创建bug分支">创建bug分支</h4><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，<strong>每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</strong></p><p>例如，我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，<strong>当前的dev分支上的工作还没有提交</strong>，具体如下：</p><img 图片57 src="http://img.mukewang.com/59c1dc4e000141b306260166.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc4e000141b306260166.png" style="cursor:pointer;display:block"><p><strong>这里并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成</strong>。怎么办呢？还好，<strong>Git还提供了一个<code>stash</code>功能，可以把当前工作现场”隐藏起来”，等以后恢复现场后继续工作</strong>。如下：</p><img 图片58 src="http://img.mukewang.com/59c1dc63000121ff06510188.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc63000121ff06510188.png" style="cursor:pointer;display:block"><p>现在我可以通过创建issue-404分支来修复bug了，具体的实施步骤如下：</p><p><strong>首先</strong>，我们要<strong>确定在哪个分支上修复bug</strong>，比如我现在是在主分支master上来修复的，现在我要在master分支上<strong>创建</strong>一个临时分支，演示如下：</p><img 图片59 src="http://img.mukewang.com/59c1dc7000010f8506010533.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dc7000010f8506010533.png" style="cursor:pointer;display:block"><p><strong>然后</strong>，在<strong>修复完成</strong>后<strong>切换</strong>到master分支上，并完成<strong>合并</strong>，最后<strong>删除</strong>issue-404分支。演示如下：</p><img 图片60 src="http://img.mukewang.com/59c1dce00001c1ed06120441.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dce00001c1ed06120441.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们<strong>回到dev分支</strong>上干活:<br></p><img 图片61 src="http://img.mukewang.com/59c1dcfa00019c8104220136.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dcfa00019c8104220136.png" style="cursor:pointer;display:block"><p><strong>但是</strong>，我们发现<strong>工作区是干净的</strong>，那么我们工作现场去哪里呢？我们可以<strong>使用命令<code>git stash list</code>来查看工作现场</strong>。如下：</p><img 图片62 src="http://img.mukewang.com/59c1dd07000152b404340093.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd07000152b404340093.png" style="cursor:pointer;display:block"><p>通过<code>git stash list</code>发现工作现场还在，Git把<code>stash</code>内容存在某个地方了，但是需要<strong>恢复</strong>一下，可以使用如下2个方法：</p><ul><li><code>git stash apply</code>恢复，<strong>恢复后，<code>stash</code>内容并不删除，你需要使用命令<code>git stash drop</code>来删除</strong></li><li>另一种方式是使用<code>git stash pop</code>，<strong>恢复的同时把<code>stash</code>内容也删除了</strong></li></ul><p>示例如下：</p><img 图片63 src="http://img.mukewang.com/59c1dd1f000174d406380466.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd1f000174d406380466.png" style="cursor:pointer;display:block"><hr><h4 id="多人协作">多人协作</h4><h5 id="查看远程库的信息">查看远程库的信息</h5><p>当你从<strong>远程库克隆</strong>时候，<strong>实际上Git自动把本地的master分支和远程的master分支对应起来了，并且<u>远程库的默认名称是origin</u>。</strong></p><p>要<strong>查看远程库的信息</strong>，使用<code>git remote</code><br>要<strong>查看远程库的详细信息</strong>，使用<code>git remote –v</code>，具体操作如下：</p><img 图片64 src="http://img.mukewang.com/59c1dd7d000136fd06190169.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd7d000136fd06190169.png" style="cursor:pointer;display:block"><hr><h5 id="推送分支">推送分支</h5><p>推送分支就是<strong>把该分支上所有本地提交到远程库</strong>中，推送时<strong>要指定本地分支</strong>，这样Git就会<strong>把该分支推送到远程库对应的远程分支上</strong></p><p><strong>把本地分支推送到远程分支</strong>，使用<code>git push origin master</code></p><p>例如，我的<strong>Github(远程库)</strong>上的readme.txt代码如下：<br></p><img 图片65 src="http://img.mukewang.com/59c1dd90000164a508280459.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dd90000164a508280459.png" style="cursor:pointer;display:block"><p><strong>本地</strong>的readme.txt代码如下：<br></p><img 图片66 src="http://img.mukewang.com/59c1dda60001771804210205.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dda60001771804210205.png" style="cursor:pointer;display:block"><p>现在我想把<strong>本地更新</strong>的readme.txt代码<strong>推送到远程库</strong>中，使用命令如下：<br></p><img 图片67 src="http://img.mukewang.com/59c1ddbf0001271e05410203.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddbf0001271e05410203.png" style="cursor:pointer;display:block"><p>我们可以看到如上Git信息提示，推送成功，然后我们可以看看Github上的readme.txt内容 如下：</p><img 图片68 src="http://img.mukewang.com/59c1ddcf0001771f08100484.png" alt="图片描述" data-original="http://img.mukewang.com/59c1ddcf0001771f08100484.png" style="cursor:pointer;display:block"><p>可以看到推送成功了，如果我们现在要<strong>推送到其他分支</strong>，比如dev分支上，我们还是那个命令<code>git push origin dev</code></p><div class="note info"><p>那么一般情况下，那些分支要推送呢？</p><p><strong>master分支是主分支</strong>，因此要<strong>时刻与远程同步</strong>；一些<strong>修复bug分支不需要推送到远程去</strong>，可以<strong>先合并</strong>到主分支(或者dev分支)上，然后把主分支master(或者dev分支)推送到远程去</p></div><hr><h5 id="抓取分支">抓取分支</h5><p><strong>多人协作时，大家都会往master分支上推送各自的修改</strong>。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到Github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2，具体的协作步骤如下：</p><p><strong>首先</strong>，我要把dev分支也要<strong>推送</strong>到远程去，如下：</p><img 图片69 src="http://img.mukewang.com/59c1ded800014adf05030151.jpg" alt="图片描述" data-original="http://img.mukewang.com/59c1ded800014adf05030151.jpg" style="cursor:pointer;display:block"><p><strong>然后</strong>，进入testgit2目录，进行<strong>克隆</strong>远程的库到本地来(模拟的协作)，如下：<br></p><img 图片70 src="http://img.mukewang.com/59c1deb70001ec7605080170.png" alt="图片描述" data-original="http://img.mukewang.com/59c1deb70001ec7605080170.png" style="cursor:pointer;display:block"><p>现在目录下生成有如下所示：<br></p><img 图片71 src="http://img.mukewang.com/59c1defe0001942707180256.png" alt="图片描述" data-original="http://img.mukewang.com/59c1defe0001942707180256.png" style="cursor:pointer;display:block"><p><strong>接下来</strong>，我们的小伙伴要在dev分支上做开发，就必须<strong>把远程的origin的dev分支到本地来</strong>，于是可以<strong>使用命令创建本地dev分支：<code>git checkout –b dev origin/dev</code></strong>。创建完成后，小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时，如下：<br></p><img 图片72 src="http://img.mukewang.com/59c1df160001ef1e06020730.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df160001ef1e06020730.png" style="cursor:pointer;display:block"><p><strong>下一步</strong>，小伙伴们<strong>已经向origin/dev分支上推送了提交</strong>，而我在<strong>我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库</strong>时，如下：<br></p><img 图片73 src="http://img.mukewang.com/59c1df340001209306470759.png" alt="图片描述" data-original="http://img.mukewang.com/59c1df340001209306470759.png" style="cursor:pointer;display:block"><p>由上面可知：推送失败，<strong>因为我的小伙伴最新提交的和我试图推送的有冲突</strong>，<strong>解决的办法</strong>也很简单，上面已经提示我们，<strong>先用<code>git pull</code>把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</strong></p><img 图片74 src="http://img.mukewang.com/59c1dfa60001473e05940282.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfa60001473e05940282.png" style="cursor:pointer;display:block"><p><code>git pull</code>也失败了，原因是<strong>没有指定本地dev分支与远程origin/dev分支的链接</strong>，根据提示，<strong>设置dev和origin/dev的链接，使用<code>git branch --set-upstream dev origin/dev</code></strong>，如下：</p><img 图片75 src="http://img.mukewang.com/59c1dfc8000159c106460199.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dfc8000159c106460199.png" style="cursor:pointer;display:block"><p>这回git pull成功，但是<strong>合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</strong>。解决后，提交，再push。我们可以先来看看readme.txt内容：</p><img 图片76 src="http://img.mukewang.com/59c1dff70001a87605190277.png" alt="图片描述" data-original="http://img.mukewang.com/59c1dff70001a87605190277.png" style="cursor:pointer;display:block"><p>手动解决完后，接着再提交，再push到远程库里面去。如下所示：<br></p><img 图片77 src="http://img.mukewang.com/59c1e0130001843906050480.png" alt="图片描述" data-original="http://img.mukewang.com/59c1e0130001843906050480.png" style="cursor:pointer;display:block"><div class="note info"><p>总结一下，多人协作工作模式一般是这样的：</p><ul><li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li><li>如果<strong>推送失败</strong>，则因为远程分支比你的本地更新早，需要先用<code>git pull</code>试图合并；</li><li>如果<strong>合并有冲突</strong>，则需要解决冲突，并在本地提交，然后再用<code>git push origin branch-name</code>推送。</li></ul></div><p>感谢龙恩的贡献：<a href="http://link.zhihu.com/?target=http%3A//www.cnblogs.com/tugenhua0707/p/4050072.html" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">cnblogs.com/tugenhua070</span><span class="invisible">7/p/4050072.html</span><span class="ellipsis"></span></a></p><hr><br><p><strong>原文信息</strong>：<br>作者： 蘇小小<br>链接：<a href="http://link.zhihu.com/?target=http%3A//www.imooc.com/article/20411" class="external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://www.</span><span class="visible">imooc.com/article/20411</span><span class="invisible"></span></a><br>来源：慕课网</p></div><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell解析命令行过程以及eval命令</title>
      <link href="/posts/29719.html"/>
      <url>/posts/29719.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的过程以及eval命令</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML常用字符实体</title>
      <link href="/posts/45689.html"/>
      <url>/posts/45689.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结了HTML常用字符实体(在某些特殊情况下使用，如表格中插入竖线等)，包括<code>特色字符实体</code>、<code>常用字符实体</code>、<code>货币类字符实体</code>、<code>数字类字符实体</code>、<code>方向类字符实体</code>以及<code>其他字符实体</code>，以供需要时查阅</p></div><a id="more"></a><h2 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h2><p>一些字符在 HTML 中拥有特殊的含义，比如小于号<code>&lt;</code>用于定义 HTML 标签的开始，在这种情况下如果我们<strong>希望浏览器正确地显示这些字符</strong>，我们必须在 HTML 源码中<strong>插入字符实体</strong>来使HTML不将其当做具有特殊含义的字符，例如，要在 HTML 文档中显示小于号，我们需要这样写：<code>&amp;lt;</code> 或者 <code>&amp;#60;</code>。</p><p><strong>字符实体有三部分：</strong></p><ul><li>一个和号<code>&amp;</code></li><li>一个实体名称，或者 <code>#</code> 和一个实体编号</li><li>以及一个分号 <code>;</code></li></ul><p>使用<strong>实体名称</strong>而<strong>不是实体编号</strong>的<strong>好处</strong>在于，名称相对来说更容易记忆；而这么做的<strong>坏处</strong>是，并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。</p><p><strong>注意：实体对大小写敏感。</strong></p><hr><h2 id="特色HTML字符实体"><a href="#特色HTML字符实体" class="headerlink" title="特色HTML字符实体"></a>特色HTML字符实体</h2><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:20%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:40%}</style><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线，常用作菜单或导航中的分隔符</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>圆点，有时被用来作为菜单分隔符</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头，常用作网页“返回页面顶部”标识</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元标识</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2，数学中的平方，在数字处理中常用到，例如：<strong>1000²</strong></td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>心型，用来表达你的心</td></tr></tbody></table><hr><h2 id="常用HTML字符实体"><a href="#常用HTML字符实体" class="headerlink" title="常用HTML字符实体"></a>常用HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&nbsp;</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td>空格</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td>&amp;#38;</td><td>and符号，与</td></tr><tr><td>"</td><td>&amp;quot;</td><td>&amp;#34;</td><td>引号</td></tr><tr><td>©</td><td>&amp;copy;</td><td>&amp;#169;</td><td>版权标志</td></tr><tr><td>®</td><td>&amp;reg;</td><td>&amp;#187;</td><td>注册标志</td></tr><tr><td>™</td><td>&amp;trade;</td><td>&amp;#153;</td><td>商标标志</td></tr><tr><td>“</td><td>&amp;ldquo;</td><td>&amp;#147;</td><td>左双引号</td></tr><tr><td>”</td><td>&amp;rdquo;</td><td>&amp;#148;</td><td>右双引号</td></tr><tr><td>‘</td><td>&amp;lsquo;</td><td>&amp;#145;</td><td>做单引号</td></tr><tr><td>’</td><td>&amp;rsquo;</td><td>&amp;#146;</td><td>右单引号</td></tr><tr><td>«</td><td>&amp;laquo;</td><td>&amp;#171;</td><td>左三角双引号</td></tr><tr><td>»</td><td>&amp;raquo;</td><td>&amp;#187;</td><td>右三角双引号</td></tr><tr><td>‹</td><td>&amp;lsaquo;</td><td>&amp;#8249;</td><td>左三角单引号</td></tr><tr><td>›</td><td>&amp;rsaquo;</td><td>&amp;#8250;</td><td>右三角单引号</td></tr><tr><td>§</td><td>&amp;sect;</td><td>&amp;#167;</td><td>章节标志</td></tr><tr><td>¶</td><td>&amp;para;</td><td>&amp;#182;</td><td>段落标志</td></tr><tr><td>•</td><td>&amp;bull;</td><td>&amp;#149;</td><td>列表圆点（大）</td></tr><tr><td>·</td><td>&amp;middot;</td><td>&amp;#183;</td><td>列表圆点（中）</td></tr><tr><td>…</td><td>&amp;hellip;</td><td>&amp;#8230;</td><td>省略号</td></tr><tr><td>|</td><td>&nbsp;</td><td>&amp;#124;</td><td>竖线</td></tr><tr><td>¦</td><td>&amp;brvbar;</td><td>&amp;#166;</td><td>断的竖线</td></tr><tr><td>–</td><td>&amp;ndash;</td><td>&amp;#150;</td><td>短破折号</td></tr><tr><td>—</td><td>&amp;mdash;</td><td>&amp;#151;</td><td>长破折号</td></tr></tbody></table><hr><h2 id="货币类HTML字符实体"><a href="#货币类HTML字符实体" class="headerlink" title="货币类HTML字符实体"></a>货币类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>¤</td><td>&amp;curren;</td><td>&amp;#164;</td><td>一般货币符号</td></tr><tr><td>$</td><td>&nbsp;</td><td>&amp;#36;</td><td>美元符号</td></tr><tr><td>¢</td><td>&amp;cent;</td><td>&amp;#162;</td><td>分</td></tr><tr><td>£</td><td>&amp;pound;</td><td>&amp;#163;</td><td>英镑</td></tr><tr><td>¥</td><td>&amp;yen;</td><td>&amp;#165;</td><td>日元</td></tr><tr><td>€</td><td>&amp;euro;</td><td>&amp;#8364;</td><td>欧元</td></tr></tbody></table><hr><h2 id="数字类HTML字符实体"><a href="#数字类HTML字符实体" class="headerlink" title="数字类HTML字符实体"></a>数字类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&amp;#60;</td><td>小于号</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&amp;#62;</td><td>大于号</td></tr><tr><td>≤</td><td>&amp;le;</td><td>&amp;#8804;</td><td>小于等于号</td></tr><tr><td>≥</td><td>&amp;ge;</td><td>&amp;#8805;</td><td>大于等于号</td></tr><tr><td>×</td><td>&amp;times;</td><td>&amp;#215;</td><td>乘号</td></tr><tr><td>÷</td><td>&amp;divide;</td><td>&amp;#247;</td><td>除号</td></tr><tr><td>−</td><td>&amp;minus;</td><td>&amp;#8722;</td><td>减号</td></tr><tr><td>±</td><td>&amp;plusmn;</td><td>&amp;#177;</td><td>加/减 号</td></tr><tr><td>≠</td><td>&amp;ne;</td><td>&amp;#8800;</td><td>不等于号</td></tr><tr><td>¹</td><td>&amp;sup1;</td><td>&amp;#185;</td><td>上标1</td></tr><tr><td>²</td><td>&amp;sup2;</td><td>&amp;#178;</td><td>上标2</td></tr><tr><td>³</td><td>&amp;sup3;</td><td>&amp;#179;</td><td>上标3</td></tr><tr><td>½</td><td>&amp;frac12;</td><td>&amp;#189;</td><td>二分之一</td></tr><tr><td>¼</td><td>&amp;frac14;</td><td>&amp;#188;</td><td>四分之一</td></tr><tr><td>¾</td><td>&amp;frac34;</td><td>&amp;#190;</td><td>四分之三</td></tr><tr><td>‰</td><td>&amp;permil;</td><td>&amp;#8240;</td><td>千分率</td></tr><tr><td>°</td><td>&amp;deg;</td><td>&amp;#176;</td><td>度</td></tr><tr><td>√</td><td>&amp;radic;</td><td>&amp;#8730;</td><td>平方根</td></tr><tr><td>∞</td><td>&amp;infin;</td><td>&amp;#8734;</td><td>无限大</td></tr></tbody></table><hr><h2 id="方向类HTML字符实体"><a href="#方向类HTML字符实体" class="headerlink" title="方向类HTML字符实体"></a>方向类HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>←</td><td>&amp;larr;</td><td>&amp;#8592;</td><td>左箭头</td></tr><tr><td>↑</td><td>&amp;uarr;</td><td>&amp;#8593;</td><td>上箭头</td></tr><tr><td>→</td><td>&amp;rarr;</td><td>&amp;#8594;</td><td>右箭头</td></tr><tr><td>↓</td><td>&amp;darr;</td><td>&amp;#8595;</td><td>下箭头</td></tr><tr><td>↔</td><td>&amp;harr;</td><td>&amp;#8596;</td><td>左右箭头</td></tr><tr><td>↵</td><td>&amp;crarr;</td><td>&amp;#8629;</td><td>回车箭头</td></tr><tr><td>⌈</td><td>&amp;lceil;</td><td>&amp;#8968;</td><td>左上限</td></tr><tr><td><strong>⌉</strong></td><td>&amp;rceil;</td><td>&amp;#8969;</td><td>右上限</td></tr><tr><td><strong>⌊</strong></td><td>&amp;lfloor;</td><td>&amp;#8970;</td><td>左下限</td></tr><tr><td><strong>⌋</strong></td><td>&amp;rfloor;</td><td>&amp;#8971;</td><td>右下限</td></tr></tbody></table><hr><h2 id="其他HTML字符实体"><a href="#其他HTML字符实体" class="headerlink" title="其他HTML字符实体"></a>其他HTML字符实体</h2><table><thead><tr><th>字符</th><th>名字</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>♠</td><td>&amp;spades;</td><td>&amp;#9824;</td><td>黑桃</td></tr><tr><td>♣</td><td>&amp;clubs;</td><td>&amp;#9827;</td><td>梅花</td></tr><tr><td>♥</td><td>&amp;hearts;</td><td>&amp;#9829;</td><td>红桃，心</td></tr><tr><td>♦</td><td>&amp;diams;</td><td>&amp;#9830;</td><td>方块牌</td></tr><tr><td>◊</td><td>&amp;loz;</td><td>&amp;#9674;</td><td>菱形</td></tr><tr><td>†</td><td>&amp;dagger;</td><td>&amp;#8224;</td><td>匕首</td></tr><tr><td>‡</td><td>&amp;Dagger;</td><td>&amp;#8225;</td><td>双剑号</td></tr><tr><td>¡</td><td>&amp;iexcl;</td><td>&amp;#161;</td><td>反向感叹号</td></tr><tr><td>¿</td><td>&amp;iquest;</td><td>&amp;#191;</td><td>反向问号</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/cutdragonhit/p/9785350.html" target="_blank" rel="noopener">HTML实体符号</a></li><li><a href="https://www.cnblogs.com/zhangchenliang/p/4159374.html" target="_blank" rel="noopener">网页中常用HTML字符实体</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux通配符和正则表达式及其区别</title>
      <link href="/posts/37480.html"/>
      <url>/posts/37480.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了linux通配符和正则表达式及其区别，linux中常见通配符只有<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种，是由shell解析之后作为参数传给linux命令，而正则匹配字符则相对较多；注意正则匹配和通配符在命令中的使用区别：像<code>awk</code>、<code>sed</code>、<code>grep</code>使用正则表达式、像<code>find</code>、<code>ls</code>、<code>cp</code>使用通配符。</p></div><a id="more"></a><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls <span class="built_in">test</span>*.txt</span><br><span class="line">  test2.txt  test3.txt  test.txt</span><br><span class="line"></span><br><span class="line">ls d*.txt</span><br><span class="line">  ls: cannot access d*.txt: No such file or directory</span><br></pre></td></tr></table></figure><hr><h3 id="通配符的作用方式"><a href="#通配符的作用方式" class="headerlink" title="通配符的作用方式"></a>通配符的作用方式</h3><p><strong>通配符是由<code>shell</code>处理的</strong>(不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍), 它只会出现在命令的<strong>参数</strong>里(它不用在命令名称里， 也不用在操作符上)。<strong>当shell在参数中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个<u>普通字符传递给命令</u>，然后再由命令进行处理</strong>。总之，<strong>通配符实际上就是一种shell实现的路径扩展功能</strong>。在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。</p><p>我们回过头分析上面命令：</p><ul><li>在第2个命令中，<strong>test*.txt 实际shell搜索文件,找到了符合条件的文件，命令会变成</strong>：<code>ls test2.txt test3.txt test.txt</code> ,实际在执行<code>ls</code>时候传给它的<strong>参数</strong>是test2.txt test3.txt test.txt。</li><li>而命令3，<code>d*.txt</code> 由于当前目录下面没有这样的文件或目录，直接将<code>d*.txt</code>作为普通字符传给<code>ls</code>作为参数。这个时候<code>*</code>只是一个普通的 <code>ls</code>参数而已，已经<strong>失去了它通配意义</strong>。由于找不到文件，所以会出现：无法访问提示！</li></ul><p>了解了shell通配符，我们现在看下，shell常见通配符有哪些了。</p><hr><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:50%}</style><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>*</td><td>匹配 <strong>0 或多个</strong>字符</td><td>a*b：a与b之间可以有<strong>任意长度</strong>的任意字符, 也可以<strong>一个也没有</strong>, 如aabcb, axyzb, a012b, ab</td></tr><tr><td>?</td><td>匹配<strong>任意一个</strong>字符</td><td>a?b：a与b之间<strong>必须也只能有一个字符</strong>, 可以是任意字符, 如aab, abb, acb, a0b</td></tr><tr><td>[list]</td><td>匹配 <strong>list 中的任意单一字符</strong></td><td>a[xyz]b：a与b之间<strong>必须也只能有一个字符</strong>, 但只能是 x 或 y 或 z, 如: axb, ayb, azb</td></tr><tr><td>[!list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[!0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[^list]</td><td>匹配 <strong>除list 中的任意单一字符(一定要有一个)</strong></td><td>a[^0-9]b：a与b之间<strong>必须也只能有一个字符, 但不能是</strong>阿拉伯数字, 如axb, aab, a-b</td></tr><tr><td>[c1-c2]</td><td>匹配 <strong>c1-c2 中的任意单一字符</strong> 如：[0-9] [a-z]</td><td>a[0-9]b：0与9之间<strong>必须也只能有一个字符</strong> 如a0b, a1b… a9b</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)<strong>其一字符串</strong></td><td>a{abc,xyz,123}b：a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><div class="note info"><p>需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，<code>*</code>、<code>?</code>、<code>[]</code>、<code>{}</code>这几种</p></div><hr><h3 id="通配符示例"><a href="#通配符示例" class="headerlink" title="通配符示例"></a>通配符示例</h3><p><code>[!list]</code> 和<code>[^list]</code>：</p><blockquote><p><code>ls test[^1-2].txt</code><br>test3.txt</p></blockquote><blockquote><p><code>ls test[!1-2].txt</code><br>test3.txt</p></blockquote><p>注意不会出现test.txt，因为test和.txt之间必须要有一个字符，而test.txt不具备这个条件</p><hr><p><br></p><h2 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>^word</td><td>待搜寻的字串(word)在<strong>行首</strong></td><td>grep -n ‘^#’ regular_express.txt：搜寻行首为 # 开始的那一行，并列出行号</td></tr><tr><td>word$</td><td>待搜寻的字串(word)在<strong>行尾</strong></td><td>grep -n ‘!$’ regular_express.txt：将行尾为 ! 的那一行打印出来，并列出行号</td></tr><tr><td>.</td><td>代表<strong>一定有一个任意字符</strong>的字符</td><td>grep -n ‘e.e’ regular_express.txt：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定<strong>仅有一个字符，而空白字符也是字符！</strong></td></tr><tr><td>\</td><td>转义字符，将特殊符号的特殊意义去除</td><td>grep -n \’ regular_express.txt：搜寻含有单引号 ‘ 的那一行</td></tr><tr><td>*</td><td>重复<strong>零个到无穷多个的前一个字符</strong></td><td>grep -n ‘ess*’ regular_express.txt：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字串。另外，之前也可以紧接着一个 RE 字符，例如任意字符则为 “.”</td></tr><tr><td>[list]</td><td>字符集合，匹配list 中的任意单个字符</td><td>grep -n ‘g[ld]’ regular_express.txt：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思</td></tr><tr><td>[n1-n2]</td><td>字符范围，匹配n1-n2中的任意单个字符</td><td>grep -n ‘[A-Z]’ regular_express.txt：搜寻含有大写字母的那一行。需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关。</td></tr><tr><td>[^list]</td><td>字符集合，匹配 除list 中的任意单一字符(一定要有一个)</td><td>不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字</td></tr><tr><td>{n,m}</td><td>连续 n 到 m 个的前一个字符；若为 {n} 则是连续 n 个的前一个字符；若是 {n,} 则是连续 n 个以上的前一个字符</td><td>grep -n ‘go{2,3}g’ regular_express.txt：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)</td></tr></tbody></table><hr><h3 id="延伸正则表达式字符"><a href="#延伸正则表达式字符" class="headerlink" title="延伸正则表达式字符"></a>延伸正则表达式字符</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>重复<strong>一个或一个以上的前一个字符</strong></td><td>egrep -n ‘go+d’ regular_express.txt：搜寻 (god) (good) (goood)… 等等的字串，那个 o+ 代表一个以上的 o</td></tr><tr><td>?</td><td><strong>零个或一个的前一个字符</strong></td><td>egrep -n ‘go?d’ regular_express.txt：搜寻 (gd) (god) 这两个字串，那个 o? 代表空的或 1 个 o</td></tr><tr><td>&#124;</td><td>用<strong>或( or )的方式找出数个字串</strong></td><td>egrep -n ‘gd&#124;good’ regular_express.txt：搜寻 gd 或 good 这两个字串</td></tr><tr><td>()</td><td>找出<strong>群组字串</strong></td><td>egrep -n ‘g(la&#124;oo)d’ regular_express.txt：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来</td></tr><tr><td>()+</td><td><strong>多个重复群组的判别</strong></td><td>echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’</td></tr></tbody></table><div class="note info"><p><code>grep</code> <strong>默认仅支持基础正则表达式</strong>，如果要<strong>使用延伸型正则表达式</strong>，你可以使用 <code>grep -E</code> ， 不过更建议直接使用 <code>egrep</code>！直接区分指令比较好记忆！其实 <code>egrep</code> 与 <code>grep -E</code> 是类似命令别名的关系啦！</p></div><h2 id="通配符和正则表达式关系"><a href="#通配符和正则表达式关系" class="headerlink" title="通配符和正则表达式关系"></a>通配符和正则表达式关系</h2><ul><li>在<strong>文本过滤工具里，都是用正则表达式</strong>，比如像<code>awk</code>、<code>sed</code>、<code>grep</code>等，是针对文件的内容的；而<strong>通配符多用在文件名</strong>上，比如<code>find</code>、<code>ls</code>、<code>cp</code>等等</li><li>正则表达式中有部分与通配符是相近的含义，如<code>[list]</code>、<code>[n1-n2]</code>、<code>[^list]</code>，但也有一些差异非常大，如<code>*</code> <strong>在通配符中表示匹配0或多个</strong>字符(可以独立使用)，但<strong>在正则表达式中表示重复零个到无穷多个的<u>前一个字符</u></strong>(不能独立使用)</li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/17/1853344.html" target="_blank" rel="noopener">Linux Shell 通配符、元字符、转义符使用实例介绍</a></li><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://blog.csdn.net/swjtuwyp/article/details/51817472" target="_blank" rel="noopener">linux通配符和正则表达式</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-循环结构</title>
      <link href="/posts/16486.html"/>
      <url>/posts/16486.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇博客主要学习了<code>shell</code>的循环结构，包括<code>for</code>、<code>while</code>、<code>until</code>循环，重点学习了前两个，整理了这两种循环的不同使用情形，同时也学习了循环控制结构的<code>break</code>和<code>continue</code>语句</p></div><a id="more"></a><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环适用于<strong>已经知道需要进行多少次的循环</strong>，所以for循环也叫<strong>固定循环</strong>。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      程序段</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p>为了防止可能的字符分割(变量存在空格)问题，con1 con2 con3都需要被引用(使用双引号括起来)，关于字符分割的示例可以查看<a href="http://showteeth.tech/posts/58105.html">shell-if条件测试</a></p></div><hr><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用变量进行循环"><a href="#使用变量进行循环" class="headerlink" title="使用变量进行循环"></a>使用变量进行循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line">field1=$(cut -d <span class="string">' '</span> -f 1 test.txt)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;field1&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>this<br>that<br>there<br>those</p></blockquote><blockquote><p><code>name=&quot;my name is test&quot;</code><br><code>for i in ${name};do echo $i;done</code></p></blockquote><p><strong>输出</strong>：</p><blockquote><p>my<br>name<br>is<br>test</p></blockquote><hr><h4 id="使用seq命令进行循环"><a href="#使用seq命令进行循环" class="headerlink" title="使用seq命令进行循环"></a>使用seq命令进行循环</h4><p><strong>seq命令的用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line"></span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -f, --format=FORMAT      use <span class="built_in">printf</span> style floating-point FORMAT</span><br><span class="line">  -s, --separator=STRING   use STRING to separate numbers (default: \n)</span><br><span class="line">  -w, --equal-width        equalize width by padding with leading zeroes</span><br></pre></td></tr></table></figure><p></p><p><strong>默认用法</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>设置步长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 2 5`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>1<br>3<br>5</p></blockquote><p><strong>-w设置输出等长</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w 1 2 12`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>01<br>03<br>05<br>07<br>09<br>11</p></blockquote><hr><h4 id="使用特殊符号-进行循环"><a href="#使用特殊符号-进行循环" class="headerlink" title="使用特殊符号{}进行循环"></a>使用特殊符号{}进行循环</h4><p><strong>特殊符号<code>{}</code>用法</strong>:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  &#123;FIRST..LAST..INCREMENT &#125;</span><br><span class="line">  </span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br></pre></td></tr></table></figure><p></p><p>对<strong>数字</strong>循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字循环设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>1<br>3<br>5</p></blockquote><p>对<strong>字母</strong>循环：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字母循环也可以设置步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;a..d..2&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a&#123;a..d&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在特殊符号&#123;&#125;之前添加字符或者特殊符号&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..2&#125;&#123;a..d&#125;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>a<br>b<br>c<br>d</p></blockquote><blockquote><p>a<br>c</p></blockquote><blockquote><p>aa<br>ab<br>ac<br>ad</p></blockquote><blockquote><p>1a<br>1b<br>1c<br>1d<br>2a<br>2b<br>2c<br>2d</p></blockquote><p>特殊符号<code>{}</code>中的<strong>两个小数点来代表连续出现的意思</strong>，更多关于特殊符号<code>{}</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用特殊符号-进行循环-1"><a href="#使用特殊符号-进行循环-1" class="headerlink" title="使用特殊符号(())进行循环"></a>使用特殊符号(())进行循环</h4><p><strong>使用形式</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> （（ 初始值; 限制值; 执行步阶 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i=i+2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i+=2))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>特殊符号<code>(())</code>表示<strong>执行计算</strong>，和linux <code>let</code>命令相似，更多关于特殊符号<code>(())</code>的用法请参考<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p><hr><h4 id="使用通配符进行循环"><a href="#使用通配符进行循环" class="headerlink" title="使用通配符进行循环"></a>使用通配符进行循环</h4><p>通配符主要有星号(<code>*</code>)和问号(<code>?</code>)，用来<strong>模糊搜索文件</strong>。关于shell中常见的通配符以及通配符和正则表达式的区别请参考<a href="http://showteeth.tech/posts/37480.html">这篇文章</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">test</span>*.txt</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  test2.txt  </span><br><span class="line">  test3.txt  </span><br><span class="line">  test.txt  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="comment">#           ^  Bash 在检测到通配表达式时，</span></span><br><span class="line"><span class="comment">#+             会进行文件名扩展。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ls -l <span class="string">"<span class="variable">$file</span>"</span>  <span class="comment"># 列出 $PWD（当前工作目录）下的所有文件。</span></span><br><span class="line">  <span class="comment">#  回忆一下，通配符 "*" 会匹配所有的文件名，</span></span><br><span class="line">  <span class="comment">#+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  如果没有匹配到文件，那么它将会扩展为它自身。</span></span><br><span class="line">  <span class="comment">#  为了防止出现这种情况，需要设置 nullglob 选项。</span></span><br><span class="line">  <span class="comment">#+    (shopt -s nullglob)。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> [jx]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="variable">$file</span>    <span class="comment"># 删除当前目录下所有以 "j" 或 "x" 开头的文件。</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Removed file \"<span class="variable">$file</span>\""</span>.</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="每个元素多个参数"><a href="#每个元素多个参数" class="headerlink" title="每个元素多个参数"></a>每个元素多个参数</h4><p>用于循环的每个参数可以继续分解为多个参数，这里使用 <code>set</code> 命令<strong>强制解析循环内容中的每一个元素</strong>，并将元素的每一个部分分配给位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个行星与其到太阳的距离放在一起。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> planet <span class="keyword">in</span> <span class="string">"Mercury 36"</span> <span class="string">"Venus 67"</span> <span class="string">"Earth 93"</span> <span class="string">"Mars 142"</span> <span class="string">"Jupiter 483"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">set</span> -- <span class="variable">$planet</span>  <span class="comment">#  解析变量 "planet"</span></span><br><span class="line">                  <span class="comment">#+ 并将其每个部分赋值给位置参数。</span></span><br><span class="line">  <span class="comment"># "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。</span></span><br><span class="line">  <span class="comment"># 你可以使用数组来保存</span></span><br><span class="line">  <span class="comment">#         original_params=("$@")</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>        <span class="variable">$2</span>,000,000 miles from the sum"</span></span><br><span class="line">  <span class="comment">#-------两个制表符---将后面的一系列 0 连到参数 $2 上。</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><blockquote><p>Mercury 36,000,000 miles from the sum<br>Venus 67,000,000 miles from the sum<br>Earth 93,000,000 miles from the sum<br>Mars 142,000,000 miles from the sum<br>Jupiter 483,000,000 miles from the sum</p></blockquote><p>示例来源于<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part3/11_1_loops.html" target="_blank" rel="noopener">这本书</a></p><hr><h4 id="集成管道符"><a href="#集成管道符" class="headerlink" title="集成管道符"></a>集成管道符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$( find $directory -type 1 )</span>"</span>   <span class="comment"># -type 1 = 符号链接</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span> | sort</span><br></pre></td></tr></table></figure><blockquote><p><code>for i in test*.txt;do echo $i;done |wc -l</code></p></blockquote><blockquote><p>3</p></blockquote><hr><p><br></p><h2 id="while-until循环"><a href="#while-until循环" class="headerlink" title="while/until循环"></a>while/until循环</h2><p><code>while/until</code>循环适用于条件判断，<strong>条件成立则进行循环，具体多少次的循环不知道</strong>，只要条件成立即可，所以<code>while/until</code>循环也叫<strong>不定循环</strong>。<code>while</code>和<code>until</code>循环在进行条件判断时执行的是完全相反的操作，<code>while</code>是条件成立则进行循环，而<code>until</code>这是条件成立终止循环，是完全相反的，所以后续的学习主要集中于使用较多的<code>while</code>循环，<code>until</code>循环一样的道理，只是将条件判断改变即可。</p><h3 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止</span></span><br><span class="line"><span class="keyword">while</span> [ condition ]  <span class="comment"># 括号内的状态就是判断式</span></span><br><span class="line"><span class="keyword">do</span>                   <span class="comment"># do 是循环的开始！</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span>                 <span class="comment"># done 是循环的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 condition 条件成立时，就终止循环， 否则就持续进行循环的程序段(和while循环相反)</span></span><br><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>while</code>和<code>until</code>循环中当<strong>使用条件测试进行循环时和前面在if条件测试分支结构中使用的条件测试是相同的</strong>，具体的各种测试形式这里就不在列出，后续可以查看<a href="http://showteeth.tech/posts/58105.html">这篇文章</a></p></div><hr><h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="使用条件测试进行循环"><a href="#使用条件测试进行循环" class="headerlink" title="使用条件测试进行循环"></a>使用条件测试进行循环</h4><p>和 <code>if</code> 一样， 使用条件测试进行循环时 <code>while</code> 会计算一系列命令的退出状态。只要<strong>退出状态为零(条件测试执行成功)，它就执行循环内的命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=0  <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0  <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]   <span class="comment"># 变量使用双引号在进行变量替换的同时防止字符分割</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    i=$((<span class="variable">$i</span>+1))   <span class="comment"># 每次 i 都会增加 1 </span></span><br><span class="line">    s=$((<span class="variable">$s</span>+<span class="variable">$i</span>))  <span class="comment"># 每次都会加总一次！</span></span><br><span class="line">                  <span class="comment"># 使用了特殊符号$(())来执行计算</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is  <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p><mark>如果一个 while 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止，这个也和if命令相同:</mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环，输出this is true</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">false</span>;<span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is true"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><hr><h4 id="循环读取文件"><a href="#循环读取文件" class="headerlink" title="循环读取文件"></a>循环读取文件</h4><p>使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt </span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this is a test<br>that is a test<br>there is a test<br>those are tests</p></blockquote><p>也可以<strong>按字段读取文件的每行内容</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> field1 field2 field3 field4 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field1</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field3</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$field4</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><blockquote><p>this<br>is a test<br>that<br>is a test<br>there<br>is a test<br>those<br>are tests</p></blockquote><blockquote><p>this<br>is<br>a<br>test<br>that<br>is<br>a<br>test<br>there<br>is<br>a<br>test<br>those<br>are<br>tests<br><em>这是空行</em></p></blockquote><div class="note info"><ul><li>为了重定向文件到循环中，可以将重定向操作符放置到 <code>done</code> 语句之后。循环使用 <code>read</code> 从重定向文件中读取字段；<strong>这个 <code>read</code> 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾，这时候它的退出状态为非零数值，因此终止循环</strong>。</li><li><strong>指定字段数小于每行字段数</strong>：第一个字段为第一个空格之前的内容，剩下的所有字段为第二个字段(这里只指定了两个字段来读取每一行)</li><li><strong>指定字段数大于每行字段数</strong>：不足的字段使用空格填补</li></ul></div><hr><h4 id="集成管道符-1"><a href="#集成管道符-1" class="headerlink" title="集成管道符"></a>集成管道符</h4><p>上面使用使用<code>read</code>结合标准输入<code>&lt;</code>来读取文件的操作也可以使用管道符实现：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt|<span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">  this is a <span class="built_in">test</span></span><br><span class="line">  that is a <span class="built_in">test</span></span><br><span class="line">  there is a <span class="built_in">test</span></span><br><span class="line">  those are tests</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>因为管道将会在<strong>子 shell</strong> 中执行循环，<strong>当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失</strong>，记住这一点很重要(这个还没测试过，先mark一下)</p></div><hr><p><br></p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break-终止循环"><a href="#break-终止循环" class="headerlink" title="break-终止循环"></a>break-终止循环</h3><p><code>break</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳出当前所在的循环体(终止循环)，执行循环体之后的语句</strong>。</p><h4 id="终止单层循环"><a href="#终止单层循环" class="headerlink" title="终止单层循环"></a>终止单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"></span><br><span class="line">  <span class="built_in">break</span>---------+</span><br><span class="line">                |</span><br><span class="line">  commands      |</span><br><span class="line">  commands      | 跳出(终止)循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">                |</span><br><span class="line"><span class="keyword">done</span>            |</span><br><span class="line">                |</span><br><span class="line">commands&lt;-------+</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; <span class="built_in">break</span>  <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span>  $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"We have found a directory <span class="variable">$f</span>"</span></span><br></pre></td></tr></table></figure><p></p><p>在循环中一旦发现目录，则立即停止循环并退出</p><hr><h4 id="终止多层循环"><a href="#终止多层循环" class="headerlink" title="终止多层循环"></a>终止多层循环</h4><p><mark><code>break</code> 命令可以接受一个参数，普通的 <code>break</code> 命令<strong>仅仅跳出其所在的那层循环</strong>，而 <code>break N</code> 命令则可以<strong>跳出其上 N 层的循环</strong></mark><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outerloop</span>:   "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> innerloop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$innerloop</span> "</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$innerloop</span>"</span> -eq 3 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">break</span> 2 <span class="comment"># 尝试一下 break 2 看看会发生什么。</span></span><br><span class="line">             <span class="comment"># （它同时中止了内层和外层循环。）</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># ------------------------------------------</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>直接使用<code>break</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3<br>Group 2: 1 2 3<br>Group 3: 1 2 3<br>Group 4: 1 2 3<br>Group 5: 1 2 3</p></blockquote><p>使用了<code>break 2</code>的输出结果：</p><blockquote><p>Group 1: 1 2 3</p></blockquote><p>可以发现使用<code>break 2</code>不仅跳出了本层循环，还跳出了本层循环的外层循环，也就是跳出了2层循环</p><hr><h3 id="continue-进行下一次循环"><a href="#continue-进行下一次循环" class="headerlink" title="continue-进行下一次循环"></a>continue-进行下一次循环</h3><p><code>continue</code>语句：在<code>for</code>、<code>while</code>、<code>until</code>等循环语句中，用于<strong>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</strong>。</p><h4 id="影响单层循环"><a href="#影响单层循环" class="headerlink" title="影响单层循环"></a>影响单层循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]&lt;-------+</span><br><span class="line"><span class="keyword">do</span>                         |</span><br><span class="line">                           |</span><br><span class="line">  commands                 | 跳回当前循环，重新开始下一次循环（通常在循环体中与条件语句一起使用）</span><br><span class="line">  commands                 |</span><br><span class="line">                           |</span><br><span class="line">  <span class="built_in">continue</span> ----------------+</span><br><span class="line"></span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">commands</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -d <span class="string">"<span class="variable">$f</span>"</span> ] || <span class="built_in">continue</span>    <span class="comment"># 这种写法很简洁，如果想要使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line">    chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用常规的if条件测试分支结构就会比较复杂</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$f</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      chmod 3777 <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>如果是目录，添加权限；如果不是，跳过当前循环，continue 后面代码不再执行，而是直接执行下次循环。</p><hr><h4 id="影响多层循环"><a href="#影响多层循环" class="headerlink" title="影响多层循环"></a>影响多层循环</h4><p><mark>与 <code>break</code> 类似，<code>continue</code> 也可以接受一个参数，普通的 <code>continue</code> 命令<strong>仅仅影响其所在的那层循环</strong>，而 <code>continue N</code> 命令则可以<strong>影响其上 N 层的循环</strong></mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> outer <span class="keyword">in</span> I II III IV V           <span class="comment"># 外层循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span>; <span class="built_in">echo</span> -n <span class="string">"Group <span class="variable">$outer</span>: "</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">for</span> inner <span class="keyword">in</span> 1 2 3 4 5 6 7 8 9 10  <span class="comment"># 内层循环</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$inner</span>"</span> -eq 7 &amp;&amp; <span class="string">"<span class="variable">$outer</span>"</span> = <span class="string">"III"</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">continue</span> 2  <span class="comment"># 影响两层循环，包括“外层循环”。</span></span><br><span class="line">                  <span class="comment"># 将其替换为普通的 "continue"，那么只会影响内层循环。</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$inner</span> "</span>  <span class="comment"># 7 8 9 10 将不会出现在 "Group III."中。</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>直接使用<code>continue</code>的输出结果(只有第三组少了数字7)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6 8 9 10<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><p>使用了<code>continue 2</code>的输出结果(第三组7以后的数字全消失了)：</p><blockquote><p>Group I: 1 2 3 4 5 6 7 8 9 10<br>Group II: 1 2 3 4 5 6 7 8 9 10<br>Group III: 1 2 3 4 5 6<br>Group IV: 1 2 3 4 5 6 7 8 9 10<br>Group V: 1 2 3 4 5 6 7 8 9 10</p></blockquote><div class="note warning"><p><code>continue N</code> 结构<strong>不易理解并且可能在一些情况下有歧义，因此不建议使用</strong></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell-if条件测试</title>
      <link href="/posts/58105.html"/>
      <url>/posts/58105.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了shell中的条件测试命令，包括<code>test</code>命令、<code>[ ]</code>、<code>[[ ]]</code>、<code>(( ))</code>，主要介绍了前三个，其中<code>[ ]</code>和<code>[[ ]]</code>可以用在<strong>if条件测试分支结构</strong>中，两者之间的优缺点在文中也有讲解；也学习了<strong>if条件测试分支结构</strong>在多种情形下的多种形式以及<code>exit</code>命令设定程序退出状态</p></div><a id="more"></a><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>本来打算直接学习if判断分支结构，但是在阅读相关资料后发现if判断分支中的条件判断其实就是shell条件测试，所以这里先对shell的条件测试进行学习。shell的条件测试可以使用<code>test</code>命令、<code>[ ]</code>判断式、<code>[[ ]]</code>判断式以及<code>(( ))</code>判断式，其中<code>[ ]</code>和<code>[[ ]]</code>是if判断分支结构中主要使用的。</p><h3 id="test命令测试"><a href="#test命令测试" class="headerlink" title="test命令测试"></a>test命令测试</h3><p>test命令是 shell 环境中用于测试条件表达式的工具，当条件成立时，命令执行后的返回值为0，否则为其他数值。</p><h4 id="test命令结构"><a href="#test命令结构" class="headerlink" title="test命令结构"></a>test命令结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> ! EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -a EXPRESSION</span><br><span class="line">  <span class="built_in">test</span> EXPRESSION -o EXPRESSION</span><br></pre></td></tr></table></figure><p><mark><strong>test EXPRESSION</strong>执行结果并<strong>不会显示任何信息</strong>，如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</mark></p><p><strong>使用<code>$?</code></strong>：</p><blockquote><p><code>test -f test1.txt</code> # 不输出结果<br><code>echo $?</code> # $?返回最后运行的命令的结束代码</p></blockquote><blockquote><p>0 # 正常运行的命令结束代码为0，也就是条件成立</p></blockquote><blockquote><p><code>test -f test2.txt</code><br><code>echo $?</code></p></blockquote><blockquote><p>1 # 出错或者异常结束代码为非0，也就是条件不成立</p></blockquote><p><strong>使用<code>&amp;&amp;</code>和<code>||</code>的组合</strong>：</p><blockquote><p><code>test -f test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><p><strong>注意<code>&amp;&amp;</code>和<code>||</code>的顺序不能随意，如果上面的顺序调换</strong>：</p><blockquote><p><code>test -f test2.txt || echo &quot;Not exist&quot; &amp;&amp; echo &quot;exist&quot;</code><br>Not exist<br>exist</p></blockquote><p>上面的判断是按顺序执行的，具体<code>&amp;&amp;</code>和<code>||</code>前后命令的执行规则参考<a href="http://showteeth.tech/posts/55603.html">这篇博客</a></p><hr><h4 id="文件是否存在测试"><a href="#文件是否存在测试" class="headerlink" title="文件是否存在测试"></a>文件是否存在测试</h4><p>使用示例：<strong>test -e filename</strong></p><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-e</strong></td><td>该“文件名”<strong>是否存在</strong>（常用）</td></tr><tr><td><strong>-f</strong></td><td>该“文件名”是否存在且为<strong>文件</strong>（file）（常用）</td></tr><tr><td><strong>-d</strong></td><td>该“文件名”是否存在且为<strong>目录</strong>（directory）（常用）</td></tr><tr><td><strong>-s</strong></td><td>侦测该文件名是否存在且为“非空白文件”(<strong>文件大小不为0</strong>) （常用）</td></tr><tr><td>-b</td><td>该“文件名”是否存在且为一个 block device 设备</td></tr><tr><td>-c</td><td>该“文件名”是否存在且为一个 character device 设备</td></tr><tr><td>-S</td><td>该“文件名”是否存在且为一个 Socket 文件</td></tr><tr><td>-p</td><td>该“文件名”是否存在且为一个 FIFO （pipe） 文件</td></tr><tr><td>-L</td><td>该“文件名”是否存在且为一个<strong>链接文件</strong></td></tr></tbody></table><blockquote><p><code>test -f test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -e test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -d test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="权限测试"><a href="#权限测试" class="headerlink" title="权限测试"></a>权限测试</h4><p>使用示例：<strong>test -r filename</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>侦测该文件名是否存在且<strong>具有“可读”的权限</strong></td></tr><tr><td>-w</td><td>侦测该文件名是否存在且<strong>具有“可写”的权限</strong></td></tr><tr><td>-x</td><td>侦测该文件名是否存在且<strong>具有“可执行”的权限</strong></td></tr><tr><td>-u</td><td>侦测该文件名是否存在且具有“SUID”的属性</td></tr><tr><td>-g</td><td>侦测该文件名是否存在且具有“SGID”的属性</td></tr><tr><td>-k</td><td>侦测该文件名是否存在且具有“Sticky bit”的属性</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt</p></blockquote><blockquote><p><code>test -r test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -w test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><blockquote><p><code>test -x test1.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="文件之间的测试"><a href="#文件之间的测试" class="headerlink" title="文件之间的测试"></a>文件之间的测试</h4><p>使用示例：<strong>test file1 -nt file2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-nt</td><td>（<strong>newer than</strong>）判断 file1 是否比 file2 新</td></tr><tr><td>-ot</td><td>（<strong>older than</strong>）判断 file1 是否比 file2 旧</td></tr><tr><td>-ef</td><td>判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上（通过硬链接两个文件名指向相同的文件）</td></tr></tbody></table><blockquote><p>-rw-rw-r– 1 user user 0 Mar 14 20:36 test1.txt<br>-rw-rw-r– 1 user user 0 Mar 14 21:20 test2.txt</p></blockquote><blockquote><p><code>test test1.txt -nt test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><blockquote><p><code>test test1.txt -ot test2.txt &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist</p></blockquote><hr><h4 id="整数之间的测试"><a href="#整数之间的测试" class="headerlink" title="整数之间的测试"></a>整数之间的测试</h4><p>使用示例：<strong>test n1 -eq n2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>两数值相等 （<strong>equal</strong>）</td></tr><tr><td>-ne</td><td>两数值不等 （<strong>not equal</strong>）</td></tr><tr><td>-gt</td><td>n1 大于 n2 （<strong>greater than</strong>）</td></tr><tr><td>-lt</td><td>n1 小于 n2 （<strong>less tha</strong>n）</td></tr><tr><td>-ge</td><td>n1 大于等于 n2 （<strong>greater than or equal</strong>）</td></tr><tr><td>-le</td><td>n1 小于等于 n2 （<strong>less than or equal</strong>）</td></tr></tbody></table><blockquote><p><code>test 2 -eq 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>exist<br><code>test 2 -ne 2 &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>Not exist</p></blockquote><hr><h4 id="字符串的测试"><a href="#字符串的测试" class="headerlink" title="字符串的测试"></a>字符串的测试</h4><p>使用示例：<strong>test str1 == str2</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>test -z string</td><td>判定字串是否为 0 ，若 string <strong>为空字串(空格不为空)，则为 true</strong></td></tr><tr><td>test -n string</td><td>判定字串是否非为 0 ，若 string <strong>为空字串，则为 false</strong>。 -n 亦可省略</td></tr><tr><td>test str1 == str2</td><td>判定 str1 <strong>是否等于</strong> str2 ，若相等，则回传 true</td></tr><tr><td>test str1 != str2</td><td>判定 str1 <strong>是否不等于</strong> str2 ，若相等，则回传 false</td></tr></tbody></table><p>注意：<code>==</code>前后需要空格隔开，不用空格隔开可能会出问题</p><hr><h4 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h4><p>使用示例：<strong>test -r file -a -x file</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>（<strong>and</strong>）两状况同时成立！例如 <em>test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true</em>。</td></tr><tr><td>-o</td><td>（<strong>or</strong>）两状况任何一个成立！例如 <em>test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true</em>。</td></tr><tr><td>!</td><td>反向状态，如 <em>test ! -x file ，当 file 不具有 x 时，回传 true</em></td></tr></tbody></table><hr><div class="note info"><p><code>test</code>命令最需要注意的是：单纯的<code>test</code>命令不会返回任何信息，所以如果想要显示信息可以使用<code>$?</code>或者使用<code>&amp;&amp;</code>和<code>||</code>的组合来得到信息</p></div><hr><h3 id="判断式"><a href="#判断式" class="headerlink" title="[]判断式"></a>[]判断式</h3><div class="note info"><ul><li>条件测试会使用一个特殊的命令 <code>[</code>，等同于 <code>test</code> 命令，它是一个<strong>内建命令</strong>，写法更加简洁高效。该命令<strong>将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）</strong></li><li>Bash 在 2.02 版本中引入了扩展测试命令 <code>[[ ]]</code>，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， <code>[[</code> 是一个<strong>关键字 而非一个命令</strong>，Bash 将 <code>[[ $a -lt $b ]]</code> 视为一整条语句，执行并返回退出状态</li><li><code>[]</code>有<a href="http://showteeth.tech/posts/55603.html">几种不同的功能</a>，如果想要用来作为条件测试必须要注意<strong>中括号的两端以及判断符前后需要有空白字符来分隔</strong>，如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code></li></ul><ul><li>中括号和test命令的各种测试是相同的，<code>[ ]</code>判断式和test命令可以相互转换，比如<code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code>可以转换为test “$HOME” == “$MAIL”，所以上面提到的各种测试都可以在中括号中使用</li><li>在中括号 <code>[ ]</code> 内的<strong>每个元件都需要有空白键来分隔</strong></li><li>在中括号内的<strong>变量</strong>，最好都<strong>以双引号括号起来</strong></li><li>在中括号内的<strong>常数</strong>，最好都<strong>以单或双引号括号起来</strong></li><li><code>[ ]</code>以及<code>test</code>命令中所有的表达式和操作符都被 shell 看作是命令参数，对于 bash 有特殊含义的字符，比如说 <code>(</code>、 <code>)</code>、<code>&gt;</code>、<code>&lt;</code><strong>必须引起来或者是转义</strong></li></ul><ul><li>在复合测试中，仅仅引用字符串可能还不够，比如表达式<code>[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</code> 在<strong>某些 Bash 版本</strong>下，如果 <code>$string</code> 为空可能会出错。更加安全的方式是，<strong>对于可能为空的字符串，添加一个额外的字符</strong>，例如 <code>[ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]</code>（其中的 x 互相抵消）</li></ul></div><p><strong>[]判断式需要注意的问题-字符分割</strong>：</p><blockquote><p>test=”my name”<br>[ ${test} == “my” ]</p></blockquote><blockquote><p>bash: [: too many arguments</p></blockquote><p>上面的出错显示判断式中存在太多参数，但是明明就只有test一个参数，为什么会出现这个问题呢？因为 <code>${test}</code> 如果<strong>没有使用双引号括起来</strong>，那么上面的判定式会变成：</p><blockquote><p>[ my name == “my” ]</p></blockquote><p>如果写成这个样子就会发现问题，因为一个判断式仅能有两个数据的比对，上面 my 与 name 还有 “my” 就有三个数据！所以会出错，而我们需要的是：</p><blockquote><p>[ “my name” == “my” ]</p></blockquote><p>所以这就说明了(如果字符串中带有空格，以防万一都带上吧)需要<strong>使用双引号括起来，不用单引号</strong>的原因是单引号会<a href="http://showteeth.tech/posts/55603.html">防止任何变量替换</a></p><hr><h3 id="判断式-1"><a href="#判断式-1" class="headerlink" title="[[]]判断式"></a>[[]]判断式</h3><p>在 <strong>Bash(限制条件)</strong> 里，<code>[[ ]]</code> 是比 <code>[ ]</code> 更加通用的写法，使用 <code>[[ ]]</code> 代替<code>[ ]</code>可以避免很多逻辑错误。比如可以在 <code>[[ ]]</code> 中使用 <code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code> 和 <code>&gt;</code> 操作符，而在 <code>[ ]</code> 中使用则会报错</p><p>下面列出<code>[[ ]]</code> 比 <code>[ ]</code>更好用的几点：</p><h4 id="使用正则匹配"><a href="#使用正则匹配" class="headerlink" title="使用正则匹配"></a>使用正则匹配</h4><p>增加了一个重要的新的字符串表达式来使用正则匹配</p><blockquote><p><strong>string1 =~ regex</strong></p></blockquote><h4 id="不需要使用双引号"><a href="#不需要使用双引号" class="headerlink" title="不需要使用双引号"></a>不需要使用双引号</h4><p><code>[[ ]]</code>判断式<strong>不需要</strong>对其中的变量和常数使用<strong>双引号</strong>括起来：</p><blockquote><p><code>[[ ${test} == &quot;my&quot; ]] &amp;&amp; echo &quot;right&quot; || echo &quot;wrong&quot;</code><br>wrong</p></blockquote><h4 id="操作符支持模式匹配"><a href="#操作符支持模式匹配" class="headerlink" title="==操作符支持模式匹配:"></a>==操作符支持模式匹配:</h4><blockquote><p>FILE=foo.bar<br>if [[ $FILE == foo.* ]]; then<br>> echo “$FILE matches pattern ‘foo.*‘“<br>> fi</p></blockquote><blockquote><p>foo.bar matches pattern ‘foo.*’</p></blockquote><p>使<code>[[ ]]</code>有助于计算文件和路径名，如果<code>foo.*</code>外加了双引号就没有正则匹配的意思，单纯的字符相等的意思</p><h4 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h4><blockquote><p><code>[[ condition1 &amp;&amp; condition2 ]]</code> <code>[[ condition1 || condition2 ]]</code></p></blockquote><h4 id="对不同进制的数直接进行比较"><a href="#对不同进制的数直接进行比较" class="headerlink" title="对不同进制的数直接进行比较"></a>对不同进制的数直接进行比较</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">decimal=15</span><br><span class="line">octal=017   <span class="comment"># = 15 (十进制)</span></span><br><span class="line">hex=0x0f    <span class="comment"># = 15 (十进制)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span>       <span class="comment"># 15 不等于 017</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在单括号 [ ] 之间不会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$octal</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$octal</span>"</span>                <span class="comment"># 15 等于 017</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$octal</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 在双括号 [[ ]] 之间会进行进制转换。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$decimal</span>"</span> -eq <span class="string">"<span class="variable">$hex</span>"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> equals <span class="variable">$hex</span>"</span>                  <span class="comment"># 15 等于 0x0f</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$decimal</span> is not equal to <span class="variable">$hex</span>"</span></span><br><span class="line"><span class="keyword">fi</span>      <span class="comment"># 十六进制也可以进行转换。</span></span><br></pre></td></tr></table></figure><hr><h3 id="数值判断"><a href="#数值判断" class="headerlink" title="(())数值判断"></a>(())数值判断</h3><p>使用<strong>小于</strong>和<strong>大于</strong>符号，以及<code>==</code>用来测试是否相等，专为整数设计</p><p>不仔细讲解，因为这些也可以使用上面提到的<code>[ ]</code>和<code>[[ ]]</code>进行较好的替代，后续想学习可以参考：<a href="https://www.kancloud.cn/thinkphp/linux-command-line/39459" target="_blank" rel="noopener">文章一</a>、<a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/source/part2/07_1_test_constructs.html" target="_blank" rel="noopener">文章二</a>。</p><hr><p><br></p><h2 id="if条件测试分支结构"><a href="#if条件测试分支结构" class="headerlink" title="if条件测试分支结构"></a>if条件测试分支结构</h2><p>在学习<code>test</code>命令以及<code>[ ]</code>判断式过程中我们发现条件测试默认是不会返回任何信息的，如果想要进行操作或者返回信息就要使用<code>&amp;&amp;</code>或者<code>||</code>，这些其实和这里的if条件测试分支结构的作用的相同的，只是if条件测试分支结构可以支持的命令更加多和复杂，有利于大程序的编写。</p><p><strong>if条件测试分支结构工作原理</strong>：通过<strong>判断条件测试的退出状态</strong>，如果<strong>执行成功(命令退出状态为0)</strong>则执行<code>then</code>中的命令，<strong>否则(命令退出状态为非0)</strong>终止判断语句或者执行<code>else</code>或者执行下一层判断等。</p><h3 id="单层、简单条件判断式"><a href="#单层、简单条件判断式" class="headerlink" title="单层、简单条件判断式"></a>单层、简单条件判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  这里的条件判断式就是前面条件测试中使用的[]判断式</span><br></pre></td></tr></table></figure><hr><h3 id="多个表达式、多重判别"><a href="#多个表达式、多重判别" class="headerlink" title="多个表达式、多重判别"></a>多个表达式、多重判别</h3><p>前面在test命令中讲过关于使用多个表达式、多重判断的情况，在多个表达式之间<strong>使用-a表示and、-o表示or</strong>，示例如下：</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; -o &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p>如果想要使用<strong>多个括号将不同的表达式隔开</strong>可以使用<code>&amp;&amp;</code>和<code>||</code>:</p><blockquote><p><code>[ &quot;${yn}&quot; == &quot;Y&quot; ] || [ &quot;${yn}&quot; == &quot;y&quot; ]</code></p></blockquote><p><mark>上面的多重判别实际是写成了一个判断式的形式，而如果 if 之后跟随一系列命令(使用<code>;</code>隔开)，则将计算列表中的<strong>最后一个命令</strong>：</mark></p><blockquote><p><code>if false; true; then echo &quot;It&#39;s true.&quot;; fi</code> 因为true在后，所以得到退出状态为0，输出结果<br>It’s true.</p></blockquote><blockquote><p><code>if true; false; then echo &quot;It&#39;s true.&quot;; fi</code> 因为false在后，所以得到退出状态为非0，不输出结果</p></blockquote><hr><h3 id="双层判断式"><a href="#双层判断式" class="headerlink" title="双层判断式"></a>双层判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 一个条件判断，分成功进行与失败进行 （else）</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><hr><h3 id="多层、复杂判断式"><a href="#多层、复杂判断式" class="headerlink" title="多层、复杂判断式"></a>多层、复杂判断式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  <span class="comment"># 多个条件判断 （if ... elif ... elif ... else） 分多种不同情况执行</span></span><br><span class="line">  <span class="keyword">if</span> [ 条件判断式一 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式一成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">elif</span> [ 条件判断式二 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    当条件判断式二成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    当条件判断式一与二均不成立时，可以进行的指令工作内容；</span><br><span class="line">  <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><div class="note info"><p><code>if</code>、<code>elif</code>后面需要使用<code>then</code>，而<code>else</code>后面就不用使用<code>then</code>，因为<code>elif</code> 也是个判断式，因此出现 <code>elif</code> 后面都要接 <code>then</code> 来处理！但是 <code>else</code> 已经是最后的没有成立的结果了， 所以 <code>else</code> 后面并没有 <code>then</code></p></div><hr><h3 id="exit程序退出状态"><a href="#exit程序退出状态" class="headerlink" title="exit程序退出状态"></a>exit程序退出状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &lt;name&gt;"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>在运行此脚本时，如果没有输入参数，则提示正确的使用方法，<strong>非正常退出(exit 1)</strong>；否则，打印输入的参数，<strong>程序正常退出(exit 0)</strong>。</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/106.html" target="_blank" rel="noopener">鸟哥的linux私房菜</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="https://legacy.gitbook.com/book/linuxstory/advanced-bash-scripting-guide-in-chinese/details" target="_blank" rel="noopener">高级Bash脚本编程指南中文版</a></li><li><a href="https://www.cnblogs.com/IcanFixIt/p/6782513.html" target="_blank" rel="noopener">Linux Shell——流程控制</a></li><li><a href="http://man.linuxde.net/shell-script/shell-5" target="_blank" rel="noopener">条件测试操作与流程控制语句</a></li><li><a href="http://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">Shell 流程控制</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> shell编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成-pv-命令执行的进度信息</title>
      <link href="/posts/6225.html"/>
      <url>/posts/6225.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这个需要安装pv，需要root权限，后面在有root权限的机器上执行这个操作</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://linux.die.net/man/1/pv" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.poftut.com/linux-pv-command-tutorial-examples-monitor-progress-copybackupcompress/" target="_blank" rel="noopener">很好的英文示例讲解博客</a></li><li><a href="https://www.tecmint.com/monitor-copy-backup-tar-progress-in-linux-using-pv-command/" target="_blank" rel="noopener">英文示例博客</a></li><li><a href="https://wangchujiang.com/linux-command/c/pv.html" target="_blank" rel="noopener">中文讲解博客</a></li><li><a href="https://ywnz.com/linux/pv/" target="_blank" rel="noopener">中文讲解博客</a></li><li><a href="https://linux.cn/article-6734-1.html?pr" target="_blank" rel="noopener">中文讲解博客</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML块级标签和行内标签</title>
      <link href="/posts/8829.html"/>
      <url>/posts/8829.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这是一篇<a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">转载</a>的文章，主要记录了HTML的块级标签和行内标签各自包括的内容</p></div><a id="more"></a><h2 id="块级标签"><a href="#块级标签" class="headerlink" title="块级标签"></a>块级标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;address&gt;</td><td style="text-align:left">定义地址</td></tr><tr class="even"><td style="text-align:left">&lt;article&gt;</td><td style="text-align:left">定义文章</td></tr><tr class="odd"><td style="text-align:left">&lt;aside&gt;</td><td style="text-align:left">定义页面内容之外的内容</td></tr><tr class="even"><td style="text-align:left">&lt;audio&gt;</td><td style="text-align:left">定义声音内容</td></tr><tr class="odd"><td style="text-align:left">&lt;blockquote&gt;</td><td style="text-align:left">定义长的引用</td></tr><tr class="even"><td style="text-align:left">&lt;canvas&gt;</td><td style="text-align:left">定义图形</td></tr><tr class="odd"><td style="text-align:left">&lt;caption&gt;</td><td style="text-align:left">定义表格标题</td></tr><tr class="even"><td style="text-align:left">&lt;dd&gt;</td><td style="text-align:left">定义定义列表中项目的描述</td></tr><tr class="odd"><td style="text-align:left">&lt;div&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;dl&gt;</td><td style="text-align:left">定义定义列表</td></tr><tr class="odd"><td style="text-align:left">&lt;dt&gt;</td><td style="text-align:left">定义定义列表中的项目</td></tr><tr class="even"><td style="text-align:left">&lt;details&gt;</td><td style="text-align:left">定义元素的细节</td></tr><tr class="odd"><td style="text-align:left">&lt;fieldset&gt;</td><td style="text-align:left">定义围绕表单中元素的边框</td></tr><tr class="even"><td style="text-align:left">&lt;figcaption&gt;</td><td style="text-align:left">定义 figure 元素的标题</td></tr><tr class="odd"><td style="text-align:left">&lt;figure&gt;</td><td style="text-align:left">定义媒介内容的分组，以及它们的标题</td></tr><tr class="even"><td style="text-align:left">&lt;footer&gt;</td><td style="text-align:left">定义 section 或 page 的页脚</td></tr><tr class="odd"><td style="text-align:left">&lt;form&gt;</td><td style="text-align:left">定义供用户输入的 HTML 表单</td></tr><tr class="even"><td style="text-align:left">&lt;h1&gt; to &lt;h6&gt;</td><td style="text-align:left">定义 HTML 标题</td></tr><tr class="odd"><td style="text-align:left">&lt;header&gt;</td><td style="text-align:left">定义 section 或 page 的页眉</td></tr><tr class="even"><td style="text-align:left">&lt;hr&gt;</td><td style="text-align:left">定义水平线</td></tr><tr class="odd"><td style="text-align:left">&lt;legend&gt;</td><td style="text-align:left">定义 fieldset 元素的标题</td></tr><tr class="even"><td style="text-align:left">&lt;li&gt;</td><td style="text-align:left">定义列表的项目</td></tr><tr class="odd"><td style="text-align:left">&lt;menu&gt;</td><td style="text-align:left">定义命令的列表或菜单</td></tr><tr class="even"><td style="text-align:left">&lt;meter&gt;</td><td style="text-align:left">定义预定义范围内的度量</td></tr><tr class="odd"><td style="text-align:left">&lt;nav&gt;</td><td style="text-align:left">定义导航链接</td></tr><tr class="even"><td style="text-align:left">&lt;noframes&gt;</td><td style="text-align:left">定义针对不支持框架的用户的替代内容</td></tr><tr class="odd"><td style="text-align:left">&lt;noscript&gt;</td><td style="text-align:left">定义针对不支持客户端脚本的用户的替代内容</td></tr><tr class="even"><td style="text-align:left">&lt;ol&gt;</td><td style="text-align:left">定义有序列表</td></tr><tr class="odd"><td style="text-align:left">&lt;output&gt;</td><td style="text-align:left">定义输出的一些类型</td></tr><tr class="even"><td style="text-align:left">&lt;p&gt;</td><td style="text-align:left">定义段落</td></tr><tr class="odd"><td style="text-align:left">&lt;pre&gt;</td><td style="text-align:left">定义预格式文本</td></tr><tr class="even"><td style="text-align:left">&lt;section&gt;</td><td style="text-align:left">定义 section</td></tr><tr class="odd"><td style="text-align:left">&lt;table&gt;</td><td style="text-align:left">定义表格</td></tr><tr class="even"><td style="text-align:left">&lt;tbody&gt;</td><td style="text-align:left">定义表格中的主体内容</td></tr><tr class="odd"><td style="text-align:left">&lt;td&gt;</td><td style="text-align:left">定义表格中的单元</td></tr><tr class="even"><td style="text-align:left">&lt;tfoot&gt;</td><td style="text-align:left">定义表格中的表注内容（脚注）</td></tr><tr class="odd"><td style="text-align:left">&lt;th&gt;</td><td style="text-align:left">定义表格中的表头单元格</td></tr><tr class="even"><td style="text-align:left">&lt;thead&gt;</td><td style="text-align:left">定义表格中的表头内容</td></tr><tr class="odd"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="even"><td style="text-align:left">&lt;tr&gt;</td><td style="text-align:left">定义表格中的行</td></tr><tr class="odd"><td style="text-align:left">&lt;ul&gt;</td><td style="text-align:left">定义无序列表</td></tr></tbody></table><hr><p><br></p><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><table><thead><tr class="header"><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">&lt;a&gt;</td><td style="text-align:left">定义锚</td></tr><tr class="even"><td style="text-align:left">&lt;abbr&gt;</td><td style="text-align:left">定义缩写</td></tr><tr class="odd"><td style="text-align:left">&lt;acronym&gt;</td><td style="text-align:left">定义只取首字母的缩写</td></tr><tr class="even"><td style="text-align:left">&lt;b&gt;</td><td style="text-align:left">定义粗体字</td></tr><tr class="odd"><td style="text-align:left">&lt;bdo&gt;</td><td style="text-align:left">定义文字方向</td></tr><tr class="even"><td style="text-align:left">&lt;big&gt;</td><td style="text-align:left">定义大号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;br&gt;</td><td style="text-align:left">定义简单的折行</td></tr><tr class="even"><td style="text-align:left">&lt;button&gt;</td><td style="text-align:left">定义按钮 (push button)</td></tr><tr class="odd"><td style="text-align:left">&lt;cite&gt;</td><td style="text-align:left">定义引用(citation)</td></tr><tr class="even"><td style="text-align:left">&lt;code&gt;</td><td style="text-align:left">定义计算机代码文本</td></tr><tr class="odd"><td style="text-align:left">&lt;command&gt;</td><td style="text-align:left">定义命令按钮</td></tr><tr class="even"><td style="text-align:left">&lt;dfn&gt;</td><td style="text-align:left">定义定义项目</td></tr><tr class="odd"><td style="text-align:left">&lt;del&gt;</td><td style="text-align:left">定义被删除文本</td></tr><tr class="even"><td style="text-align:left">&lt;em&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;embed&gt;</td><td style="text-align:left">定义外部交互内容或插件</td></tr><tr class="even"><td style="text-align:left">&lt;i&gt;</td><td style="text-align:left">定义斜体字</td></tr><tr class="odd"><td style="text-align:left">&lt;img&gt;</td><td style="text-align:left">定义图像</td></tr><tr class="even"><td style="text-align:left">&lt;input&gt;</td><td style="text-align:left">定义输入控件</td></tr><tr class="odd"><td style="text-align:left">&lt;kbd&gt;</td><td style="text-align:left">定义键盘文本</td></tr><tr class="even"><td style="text-align:left">&lt;label&gt;</td><td style="text-align:left">定义 input 元素的标注</td></tr><tr class="odd"><td style="text-align:left">&lt;map&gt;</td><td style="text-align:left">定义图像映射</td></tr><tr class="even"><td style="text-align:left">&lt;mark&gt;</td><td style="text-align:left">定义有记号的文本</td></tr><tr class="odd"><td style="text-align:left">&lt;objec&gt;</td><td style="text-align:left">定义内嵌对象</td></tr><tr class="even"><td style="text-align:left">&lt;progress&gt;</td><td style="text-align:left">定义任何类型的任务的进度</td></tr><tr class="odd"><td style="text-align:left">&lt;q&gt;</td><td style="text-align:left">定义短的引用</td></tr><tr class="even"><td style="text-align:left">&lt;samp&gt;</td><td style="text-align:left">定义计算机代码样本</td></tr><tr class="odd"><td style="text-align:left">&lt;select&gt;</td><td style="text-align:left">定义选择列表（下拉列表）</td></tr><tr class="even"><td style="text-align:left">&lt;small&gt;</td><td style="text-align:left">定义小号文本</td></tr><tr class="odd"><td style="text-align:left">&lt;span&gt;</td><td style="text-align:left">定义文档中的节</td></tr><tr class="even"><td style="text-align:left">&lt;strong&gt;</td><td style="text-align:left">定义强调文本</td></tr><tr class="odd"><td style="text-align:left">&lt;sub&gt;</td><td style="text-align:left">定义下标文本</td></tr><tr class="even"><td style="text-align:left">&lt;sup&gt;</td><td style="text-align:left">定义上标文本</td></tr><tr class="odd"><td style="text-align:left">&lt;textarea&gt;</td><td style="text-align:left">定义多行的文本输入控件</td></tr><tr class="even"><td style="text-align:left">&lt;time&gt;</td><td style="text-align:left">定义日期/时间</td></tr><tr class="odd"><td style="text-align:left">&lt;tt&gt;</td><td style="text-align:left">定义打字机文本</td></tr><tr class="even"><td style="text-align:left">&lt;var&gt;</td><td style="text-align:left">定义文本的变量部分</td></tr><tr class="odd"><td style="text-align:left">&lt;video&gt;</td><td style="text-align:left">定义视频</td></tr><tr class="even"><td style="text-align:left">&lt;wbr&gt;</td><td style="text-align:left">定义可能的换行符</td></tr></tbody></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/d69878549d92" target="_blank" rel="noopener">关于两者之间的转换</a></li><li><a href="https://www.cnblogs.com/yanqiu/p/8987126.html" target="_blank" rel="noopener">HTML中块级元素和行内元素的总结和区分，本文内容摘自此文章</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载其他博主博客</title>
      <link href="/posts/52283.html"/>
      <url>/posts/52283.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇博客整理了转载博客到自己搭建的博客的方法，主要包括转载<strong>CSDN博客</strong>、<strong>博客园博客</strong>、<strong>简书</strong>以及<strong>其他自建博客</strong>等</p></div><a id="more"></a><h2 id="转载CSDN博客"><a href="#转载CSDN博客" class="headerlink" title="转载CSDN博客"></a>转载CSDN博客</h2><div id="article_content" class="article_content csdn-tracking-statistics tracking-click"><div class="markdown_views"><h3 id="检查"><a name="t2"></a><a target="_blank"></a>博客页面右键，点击【检查】</h3><img src="https://img-blog.csdn.net/20180205164141852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> 点击检查后，页面右侧出现<strong>html</strong>代码，如下图： <img src="https://img-blog.csdn.net/20180205164538679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="找内容"><a name="t3"></a><a target="_blank"></a>找到article_content内容</h3><img src="https://img-blog.csdn.net/20180205164709557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="复制"><a name="t4"></a><a target="_blank"></a>复制article_content内容</h3>在选中html的article_content代码处右键，点击<strong>【Copy】</strong>,再点击<strong>【Copy outerHTML】</strong>即可，至此，博客内容的html代码复制完成 <img src="https://img-blog.csdn.net/20180205164702137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDE2NTIyNzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="新建"><a name="t5"></a><a target="_blank"></a>新建markdown博客</h3><ul><li>如果是<strong>转载到CSDN博客</strong>需要注意：<strong>使用markdown编辑器</strong>，CSDN博客默认的是<a href="https://www.baidu.com/s?wd=html%E7%BC%96%E8%BE%91%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank"><strong>html编辑器</strong></a>，在博客设置中<strong>修改成markdown编辑器</strong>，在html编辑器中是无法将html代码转换成相应博客内容</li><li>如果是<strong>转载到自己搭建的博客</strong>，比如我的这个博客，需要注意：按照上述方法会得到<mark>很多的空格</mark>，这是因为直接使用html来编写markdown，只要存在换行(如标签换行)都会在最终生成的页面中得到一个空格，为了解决这个问题可以在整个<code>article_content</code>标签外加上<code>escape</code>标签即可，这个和<a href="http://showteeth.tech/posts/65136.html" target="_blank"><strong>插入html表格</strong></a>的处理是一样的</li><li>HTML <mark>区块标签间的 Markdown 格式语法将不会被处理</mark>，但 Markdown 语法在 HTML <mark>行内标签间是有效的</mark>，具体的行内标签和区块标签包含的内容见<mark><a href="http://showteeth.tech/posts/8829.html" target="_blank">这篇博客</a></mark></li><li>在手动更改html内容时需要注意：每个标题的<code>id</code>是<mark>不可以相同</mark>的，不然<strong>生成的目录会出问题</strong>，点击不能到达相应的标题(目录是根据<code>id</code>生成的)</li><li>最后特别要注意的是，我们发表转载文章的时候一定要标注<strong>转载</strong>，尊重原创！！</li></ul></div></div><hr><h2 id="转载博客园博客"><a href="#转载博客园博客" class="headerlink" title="转载博客园博客"></a>转载博客园博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>data-note-content</code>即可</p><hr><h2 id="转载简书博客"><a href="#转载简书博客" class="headerlink" title="转载简书博客"></a>转载简书博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>cnblogs_post_body</code>即可</p><hr><h2 id="转载其他自建博客"><a href="#转载其他自建博客" class="headerlink" title="转载其他自建博客"></a>转载其他自建博客</h2><p>将上述转载CSDN博客中<code>article_content</code>替换成<code>post-body</code>即可</p><p>其他博客依据上述规律<strong>找到对应的文章主体内容</strong>，然后按照转载CSDN博客的方法进行处理即可</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/zhongjianblackberry/article/details/79456338" target="_blank" rel="noopener">CSDN怎么转载别人的博客</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diff-比较文件差异</title>
      <link href="/posts/56778.html"/>
      <url>/posts/56778.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了使用<code>diff</code>命令对<strong>文件和目录</strong>进行比较，对文件比较时采用的是<strong>逐行进行比较</strong>；包括的参数有<code>-r</code>、<code>-q</code>、<code>-i</code>、<code>-s</code>、<code>-b</code>、<code>-y</code>、<code>-W</code>、<code>-c</code>、<code>-C</code>、<code>-u</code>和<code>-U</code>。</p></div><a id="more"></a><h2 id="diff简介"><a href="#diff简介" class="headerlink" title="diff简介"></a>diff简介</h2><p><code>diff</code>命令能<strong>比较(单个)文件或者目录</strong>内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，并<strong>以逐行的方式</strong>，比较文本文件的异同；如果指定<strong>比较的是目录</strong>，diff 命令会比较两个目录下名字相同但内容不同的文本文件，列出公共子目录和只在一个目录出现的文件和目录。</p><p><mark>这个和前面讲到的<code>comm</code>命令和<code>cmp</code>命令的不同之处在于</mark>：<code>diff</code>和<code>comm</code>命令都是以逐行的方式进行比较，而<code>cmp</code>是<strong>Compare two files byte by byte</strong>；同时<code>diff</code>命令可以比较<strong>单个文件</strong>，而<code>comm</code>和<code>cmp</code>都是针对的两个文件的比较，其中<code>comm</code>还需要文件是排过序的；<code>diff</code>命令还能用来对目录进行排序；感觉<code>diff</code>在比较两个文件或目录时是将两个文件当成了同一个文件修改前后的不同版本，通过<code>diff</code>可以知道新文件是在旧文件上进行了哪些操作得到的，得到的结果也更复杂。</p><p>总结一下三个命令的适用情形：<br></p><div class="note info"><ul><li>comm适合简单的比较，需要<strong>排序</strong>，<strong>逐行</strong>比较，用于比较的文件不是同一个文件的不同版本(新旧文件)，得到的结果<strong>简单清晰</strong>(文件求交、并、补等)，便于提取分析</li><li>cmp可以应用于对两个文件<strong>逐字节</strong>的比较，可以<strong>跳过一定的字节</strong>(个人感觉这个实用性不是很强，不同系统编码方式字节也有所不同)</li><li>diff适合<strong>逐行</strong>比较<strong>文件修改前后</strong>的区别(类似版本控制，新文件是旧文件经过什么操作得到的)，也可以<strong>对目录进行比较</strong>，但是输出<strong>结果较为复杂</strong>，还可以输出<strong>上下文</strong>关系的信息</li></ul></div><p></p><hr><h2 id="diff命令用法"><a href="#diff命令用法" class="headerlink" title="diff命令用法"></a>diff命令用法</h2><h3 id="diff命令格式"><a href="#diff命令格式" class="headerlink" title="diff命令格式"></a>diff命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  diff [OPTION]... FILES</span><br></pre></td></tr></table></figure><p><strong>Compare files line by line</strong></p><hr><h3 id="diff-options说明"><a href="#diff-options说明" class="headerlink" title="diff options说明"></a>diff options说明</h3><p>由于diff命令的参数较多，这里就不一一列举，详细请查看帮助文档，比较常用的请看用法实例。</p><hr><p><br></p><h2 id="diff用法实例"><a href="#diff用法实例" class="headerlink" title="diff用法实例"></a>diff用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Hi,<br>Hello,<br>How are you?<br>I am fine,<br>Thank you.</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Hello,<br>Hi,<br>How are you?<br>I am fine.</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><h4 id="比较两个文件"><a href="#比较两个文件" class="headerlink" title="比较两个文件"></a>比较两个文件</h4><blockquote><p><code>diff test1.txt test2.txt</code><br>1d0<br>&lt; Hi,<br>2a2<br>> Hi,<br>4,5c4<br>&lt; I am fine,<br>&lt; Thank you.<br>-–<br>> I am fine.</p></blockquote><p><strong>结果解读：</strong></p><ul><li>可以将test1.txt当做旧文件，test2.txt当做新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li><code>1d0</code>这一行意味着旧文件的第一行应该被<strong>删除(d)</strong>以使两个文件的第一行同步，<strong>旧文件中需要被删除的行</strong>以<code>&lt;</code>标记</li><li><code>2a2</code>行意味着<strong>新文件中的第二行应该加到旧文件的第二行后</strong>，要<strong>添加的行显示在输出的下一行</strong>用<code>&gt;</code>标记</li><li><code>4,5c4</code>这一行意味着在<strong>旧文件中的4到5行现在已被改变并且需要用新文件中的第4行代替</strong>，代替和删除的行分别用<code>&gt;</code>和<code>&lt;</code>表示，<code>---</code>用于隔开先后进行的不同操作，如先删除旧文件中的4到5行，然后再用新文件中的第4行代替，这两步之间使用<code>---</code>分割</li></ul><div class="note info"><ul><li><code>diff</code>命令的第一个参数被视为旧文件而第二个参数被视为新文件，通过比较看旧文件经过什么样的改变可以生成新文件</li><li>像<code>1d0</code>、<code>2a2</code>、<code>4,5c4</code>这种表达式可以用语法解码为 <strong>[旧文件的行号或者行的范围][行为][新文件的行号或者行的范围]</strong>，这里的<strong>行为</strong>可以是追加(<code>a，代表addition</code>)、删除(<code>d，代表deletion</code>)或者改变替换(<code>c，代表change</code>)</li><li><code>&lt;</code>代表删除的行，而<code>&gt;</code>代表添加的行，<code>---</code>用于改变替换(<code>c，代表change</code>)中分割先后的操作</li></ul></div><hr><h4 id="比较两个目录"><a href="#比较两个目录" class="headerlink" title="比较两个目录"></a>比较两个目录</h4><blockquote><p><code>ls new_dir/</code><br>comm_dir new_new_dir test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls new_dir/new_new_dir/</code> and <code>ls new_dir/comm_dir/</code><br>test1.txt test2.txt test3.txt</p></blockquote><blockquote><p><code>ls orig_dir/</code><br>comm_dir orig_orig_dir test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>ls orig_dir/orig_orig_dir/</code> and <code>ls orig_dir/comm_dir/</code><br>test1.txt test2.txt test4.txt</p></blockquote><blockquote><p><code>diff orig_dir/ new_dir/</code><br>Common subdirectories: new_dir/comm_dir and orig_dir/comm_dir # 两个目录共有的子目录，不会比较子目录中的文件信息<br>Only in new_dir/: new_new_dir # 只出现在new_dir中的目录，不会比较子目录中的文件信息<br>Only in orig_dir/: orig_orig_dir # 只出现在orig_dir中的目录，不会比较子目录中的文件信息<br>diff orig_dir/test1.txt new_dir/test1.txt # new_dir和orig_dir共有的同名文件内容的差异<br>0a1 # 具体的差异信息<br>> asdfaf # 具体的差异信息<br>Only in new_dir/: test3.txt # 只出现在new_dir中的文件<br>Only in orig_dir/: test4.txt # 只出现在orig_dir中的文件</p></blockquote><p><strong>比较两个目录可以找到每个目录共有的、独有的文件和目录信息；对于共有的子目录，不会继续比较子目录中的信息；对于共有的文件，会得出文件的差异信息</strong></p><hr><h3 id="r-比较子目录中的文件"><a href="#r-比较子目录中的文件" class="headerlink" title="-r-比较子目录中的文件"></a>-r-比较子目录中的文件</h3><p>上述对目录进行比较时默认不会比较子目录中的文件信息，使用-r参数可以对这些文件进行比较：</p><blockquote><p><code>diff -r orig_dir/ new_dir/</code><br>diff -r orig_dir/comm_dir/test1.txt new_dir/comm_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/comm_dir: test3.txt<br>Only in orig_dir/comm_dir: test4.txt<br>Only in new_dir/: new_new_dir<br>Only in orig_dir/: orig_orig_dir<br>diff -r orig_dir/test1.txt new_dir/test1.txt<br>0a1<br>> asdfaf<br>Only in new_dir/: test3.txt<br>Only in orig_dir/: test4.txt</p></blockquote><hr><h3 id="q-只显示有无差异"><a href="#q-只显示有无差异" class="headerlink" title="-q-只显示有无差异"></a>-q-只显示有无差异</h3><p>默认情况下如果文件存在差异会显示差异信息，使用<code>-q</code>参数只会显示有无差异不会显示具体的差异信息:</p><blockquote><p><code>diff -q test1.txt test2.txt</code><br>Files test1.txt and test2.txt differ</p></blockquote><hr><h3 id="i-忽略文件中文本大小写"><a href="#i-忽略文件中文本大小写" class="headerlink" title="-i-忽略文件中文本大小写"></a>-i-忽略文件中文本大小写</h3><blockquote><p><code>diff file1.txt file2.txt</code><br>1c1<br>&lt; hi<br>-–<br>> HI</p></blockquote><p>默认情况下是会区分文件中文本信息大小写的</p><blockquote><p><code>diff -i file1.txt file2.txt</code></p></blockquote><p>使用了<code>-i</code>参数没有输出内容，因为忽略大小写之后文件中文本信息是相同的</p><hr><h3 id="s-在文件内容相同条件下报告信息"><a href="#s-在文件内容相同条件下报告信息" class="headerlink" title="-s-在文件内容相同条件下报告信息"></a>-s-在文件内容相同条件下报告信息</h3><p>上面使用了<code>-i</code>参数得到了文件内容是相同的，这时默认就不会输出信息，如果想要在文件内容相同时报告文件内容是相同的，需要使用<code>-s</code>参数</p><blockquote><p><code>diff -is file1.txt file2.txt</code><br>Files file1.txt and file2.txt are identical</p></blockquote><hr><h3 id="b-忽略文本中的空格"><a href="#b-忽略文本中的空格" class="headerlink" title="-b-忽略文本中的空格"></a>-b-忽略文本中的空格</h3><blockquote><p><code>cat file1</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>cat file2</code><br>Hi, how are you?</p></blockquote><blockquote><p><code>diff file1 file2</code><br>1c1<br>&lt; Hi, how are you?<br>-–<br>> Hi, how are you?</p></blockquote><p>上述文件中的区别仅仅是file2多了一个空格，但是使用<code>diff</code>命令后仍然会输出不同，而常规情形下，这应该被认为是相同的，这时就可以使用<code>-b</code>参数</p><blockquote><p><code>diff -bs file1 file2</code><br>Files file1 and file2 are identical</p></blockquote><hr><h3 id="y-以并列的方式显示文件的异同之处"><a href="#y-以并列的方式显示文件的异同之处" class="headerlink" title="-y-以并列的方式显示文件的异同之处"></a>-y-以并列的方式显示文件的异同之处</h3><blockquote><p><code>diff -y test1.txt test2.txt</code><br>Hi, &lt;<br>Hello, Hello,<br>&gt; Hi,<br>How are you? How are you?<br>I am fine, | I am fine.<br>Thank you. &lt;</p></blockquote><ul><li><code>|</code>：表示前后2个文件内容存在差异</li><li><code>&gt;</code>：表示第一个文件删除的行</li><li><code>&lt;</code>：表示第二个文件增加的行</li></ul><hr><h3 id="W-在使用-y参数时，指定栏宽"><a href="#W-在使用-y参数时，指定栏宽" class="headerlink" title="-W-在使用-y参数时，指定栏宽"></a>-W-在使用-y参数时，指定栏宽</h3><p>如果指定的栏宽太窄，会显示每行的部分信息：</p><blockquote><p><code>diff -y -W 10 test1.txt test2.txt</code><br>Hi &lt;<br>He He<br>> Hi<br>Ho Ho<br>I | I<br>Th &lt;</p></blockquote><hr><h3 id="c-上下文格式输出"><a href="#c-上下文格式输出" class="headerlink" title="-c-上下文格式输出"></a>-c-上下文格式输出</h3><p>显示不同行的信息时一同显示上下文信息，默认是存在不同的上下3行：</p><blockquote><p><code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><ul><li><code>***</code>表示变动前的文件，<code>---</code>表示变动后的文件</li><li><code>*** 1,5 ****</code>表示变动前文件的1到5行，<code>--- 1,4 ----</code>表示变动后文件的1到4行</li><li>文件内容的每一行最前面，还有一个标记位<ul><li>如果为<code>空</code>，表示该行无变化</li><li>如果是感叹号（<code>!</code>），表示该行有改动</li><li>如果是减号（<code>-</code>），表示该行被删除</li><li>如果是加号（<code>+</code>），表示该行为新增</li></ul></li></ul><hr><h3 id="C-NUM-指定具体是上下文行数"><a href="#C-NUM-指定具体是上下文行数" class="headerlink" title="-C NUM-指定具体是上下文行数"></a>-C NUM-指定具体是上下文行数</h3><p>这个功能和上面的<code>-c</code>是相同的，只是<code>-c</code>只能是默认的上下3行，而<code>-C num</code>可以指定具体的上下文行数</p><blockquote><p><code>diff -C 3 test1.txt test2.txt</code> 等同于 <code>diff -c test1.txt test2.txt</code><br>*** test1.txt 2019-03-14 15:26:48.960323475 +0800<br>— test2.txt 2019-03-14 15:27:07.411322620 +0800</p><hr><p>*<strong> 1,5 **</strong><br>- Hi,<br>Hello,<br>How are you?<br>! I am fine,<br>! Thank you.<br>— 1,4 —-<br>Hello,<br>+ Hi,<br>How are you?<br>! I am fine.</p></blockquote><hr><h3 id="u-合并格式输出"><a href="#u-合并格式输出" class="headerlink" title="-u-合并格式输出"></a>-u-合并格式输出</h3><p>如果两个文件<strong>相似度很高</strong>，那么<strong>上下文格式的<code>diff</code>，将显示大量重复的内容</strong>，很浪费空间，这个时候使用合并格式输出<strong>将f1和f2的上下文(默认3行)合并在一起显示</strong>：</p><blockquote><p><code>diff -u test1.txt test2.txt</code><br>— test1.txt 2019-03-14 15:26:48.960323475 +0800<br>+++ test2.txt 2019-03-14 15:27:07.411322620 +0800<br>@@ -1,5 +1,4 @@<br>-Hi,<br>Hello,<br>+Hi,<br>How are you?<br>-I am fine,<br>-Thank you.<br>+I am fine.</p></blockquote><ul><li><code>---</code>表示变动前的文件，<code>+++</code>表示变动后的文件</li><li>变动的位置用两个<code>@</code>作为起首和结束，<code>-1,5</code>表示第一个文件的1到5行，<code>+1,4</code>表示第二个文件的1到4行</li><li>每一行最前面的标志位，<strong>空表示无变动</strong>，<strong>减号表示第一个文件删除的行</strong>，<strong>加号表示第二个文件新增的行</strong></li></ul><hr><h3 id="U-NUM-指定合并格式上下文的行数"><a href="#U-NUM-指定合并格式上下文的行数" class="headerlink" title="-U NUM-指定合并格式上下文的行数"></a>-U NUM-指定合并格式上下文的行数</h3><p>这个功能和上面的<code>-u</code>是相同的，只是<code>-u</code>只能是默认的上下3行，而<code>-U num</code>可以指定具体的上下文行数</p><hr><h3 id="结合patch进行内容更新"><a href="#结合patch进行内容更新" class="headerlink" title="结合patch进行内容更新"></a>结合patch进行内容更新</h3><p>这个暂时应该用不到，所以就不学习了，后期如果使用的话再进行学习补充，后面列出的参考链接有对应的示例。</p><hr><p><br></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><div class="note info"><ul><li>diff的<strong>几种输出模式</strong>：<strong>并列输出(-y)</strong>、<strong>上下文格式输出(-c)</strong>、<strong>合并格式输出(-u)</strong>之间的不兼容的，只能使用其中一种，参数不能混用</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/peida/archive/2012/12/12/2814048.html" target="_blank" rel="noopener">实例较多</a></li><li><a href="https://linux.cn/article-2298-1.html" target="_blank" rel="noopener">举例说明Linux diff 命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-diff.html" target="_blank" rel="noopener">参数讲解</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">清晰的讲解</a></li><li><a href="http://wiki.jikexueyuan.com/project/shell-learning/file-comparing-cmp-diff-patch.html" target="_blank" rel="noopener">文件比较 cmp，diff，patch</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmp-比较文件差异</title>
      <link href="/posts/62860.html"/>
      <url>/posts/62860.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章主要学习了<code>cmp</code>对<strong>两个文件</strong>进行比较，比较时是<strong>逐字节</strong>进行的；包括的参数：<code>-b</code>、<code>-i</code>、<code>-i</code>、<code>-l</code>、<code>-n</code>、<code>-s</code>以及<strong>显示运行进度</strong>。</p></div><a id="more"></a><h2 id="cmp简介"><a href="#cmp简介" class="headerlink" title="cmp简介"></a>cmp简介</h2><p><code>cmp</code>命令用于比较两个文件是否有差异；当相互比较的两个文件<strong>完全一样</strong>时，则该命令不会有输出结果；若发现<strong>有所差异</strong>，<strong>默认会标示出第一个不同之处的字符和列数编号</strong></p><p>若不指定任何文件名称或是所给予的文件名为<code>-</code>，则<code>cmp</code>指令会从标准输入读取数据</p><p><mark>这个和前面讲到的<code>comm</code>命令的不同之处在于</mark>：comm命令对已排序的文件进行比较并将结果分为3列，便于提取文件比较的结果，如得到两个文件的差集、交集、并集和对称差集等，而<code>cmp</code>命令侧重于比较两个文件差异，大多用于比较同一个文件修改之后和修改之前的差异，并且<code>cmp</code>比较文件不需要进行排序；<code>cmp</code>命令比较文件是<strong>byte by byte</strong>，而comm命令比较文件是<strong>line by line</strong>。</p><hr><p><br></p><h2 id="cmp命令用法"><a href="#cmp命令用法" class="headerlink" title="cmp命令用法"></a>cmp命令用法</h2><h3 id="cmp命令格式"><a href="#cmp命令格式" class="headerlink" title="cmp命令格式"></a>cmp命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  cmp [OPTION] FILE1 [FILE2 [SKIP1 [SKIP2]]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The optional SKIP1 and SKIP2 specify the number of bytes to skip</span></span><br><span class="line"><span class="comment"># at the beginning of each file (zero by default).</span></span><br></pre></td></tr></table></figure><p><strong>Compare two files byte by byte</strong></p><hr><h3 id="cmp-options说明"><a href="#cmp-options说明" class="headerlink" title="cmp options说明"></a>cmp options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–print-bytes</td><td>除了标明差异处所在之外，一并显示该字符所对应字符和字节值</td></tr><tr><td>-i SKIP</td><td>–ignore-initial=SKIP</td><td>跳过一定的字节数(不包括SKIP)</td></tr><tr><td>-i SKIP1:SKIP2</td><td>–ignore-initial=SKIP1:SKIP2</td><td>从两个文件中跳过不同的字节数，SKIP1是FILE1跳过的字节数，SKIP为FILE2跳过的字节数</td></tr><tr><td>-l</td><td>–verbose</td><td>显示所有不同字节的字节位置（和值）</td></tr><tr><td>-n</td><td>–bytes=LIMIT</td><td>限制要比较的字节数(包括LIMIT)</td></tr><tr><td>-s</td><td>–quiet, –silent</td><td>抑制正常生成的输出，只返回文件是否相同的退出码(可以通过<code>$?</code>得到)</td></tr></tbody></table><hr><h3 id="cmp-i选项可选单位"><a href="#cmp-i选项可选单位" class="headerlink" title="cmp -i选项可选单位"></a>cmp -i选项可选单位</h3><table><thead><tr><th>简写</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>kB</td><td>kilobytes</td><td>1000</td></tr><tr><td>K</td><td>kibibytes</td><td>1024</td></tr><tr><td>MB</td><td>megabytes</td><td>1,000,000</td></tr><tr><td>M</td><td>mebibytes</td><td>1,048,576</td></tr><tr><td>GB</td><td>gigabytes</td><td>1,000,000,000</td></tr><tr><td>G</td><td>gibibytes</td><td>1,073,741,824</td></tr></tbody></table><hr><p><br></p><h2 id="cmp用法实例"><a href="#cmp用法实例" class="headerlink" title="cmp用法实例"></a>cmp用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test1.txt</code><br>Absncn 50<br>Asldssja 60<br>Jslkadjls 85</p></blockquote><blockquote><p><code>cat test2.txt</code><br>Absncn 50<br>AsldssjE 62<br>Jslkadjls 85</p></blockquote><hr><h3 id="使用默认方式比较文件不同"><a href="#使用默认方式比较文件不同" class="headerlink" title="使用默认方式比较文件不同"></a>使用默认方式比较文件不同</h3><p>默认会告诉在第几行的第几个字节出现不同：</p><blockquote><p><code>cmp test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2</p></blockquote><p><strong>注意这里的<code>byte 18</code>来源：系统默认编码方式为UTF-8(查看方式见<a href="http://showteeth.tech/posts/56690.html">这篇文章</a>)，1个英文字符 = 1个字节；换行符占一个字节；空格占一个字节；第二行的结果存在差异的话，字符会从第一行的第一个开始算起，叠加的，不是单独每一行算</strong></p><h3 id="b-显示不同的字节及字节值"><a href="#b-显示不同的字节及字节值" class="headerlink" title="-b-显示不同的字节及字节值"></a>-b-显示不同的字节及字节值</h3><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is <strong>141 a 105 E</strong></p></blockquote><p><strong>只会显示第一个，不会显示所有的</strong>，具体是字母a和E不同，字节值分别为141和105(这个没算。。。)</p><hr><h3 id="i-跳过指定的字节"><a href="#i-跳过指定的字节" class="headerlink" title="-i-跳过指定的字节"></a>-i-跳过指定的字节</h3><blockquote><p><code>cmp -b -i 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 3</strong>, line 1 is 60 0 62 2</p></blockquote><p>跳过<strong>前18个之后开始的第3个字节</strong>，0和2不同</p><div class="note info"><p>注意这个是<strong>不包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置</p></div><hr><h3 id="i-从两个文件跳过不同数量的字节"><a href="#i-从两个文件跳过不同数量的字节" class="headerlink" title="-i-从两个文件跳过不同数量的字节"></a>-i-从两个文件跳过不同数量的字节</h3><blockquote><p><code>cmp -b -i 18:18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 3, line 1 is 60 0 62 2</p></blockquote><p>18:18：第一个文件跳过的字节数为18，第二个文件跳过的字节数也是18</p><hr><h3 id="l-显示所有不同字节的字节位置（和值）"><a href="#l-显示所有不同字节的字节位置（和值）" class="headerlink" title="-l-显示所有不同字节的字节位置（和值）"></a>-l-显示所有不同字节的字节位置（和值）</h3><blockquote><p><code>cmp -l test1.txt test2.txt</code><br>18 141 105<br>21 60 62</p></blockquote><p>输出结果：</p><ul><li>第一列（如上所示）表示不同<strong>字节的位置</strong>（字节数）</li><li>第二列表示<strong>第一个文件</strong>中不同字节的字节值</li><li>第三列表示<strong>第二个文件</strong>中不同字节的字节值</li></ul><p>前面的<code>-b</code>等参数只会显示<strong>第一个</strong>不同的字节位置和值，这里会<strong>显示所有的</strong>字节数字和值</p><hr><h3 id="n-限制要比较的字节数"><a href="#n-限制要比较的字节数" class="headerlink" title="-n-限制要比较的字节数"></a>-n-限制要比较的字节数</h3><p>最多只比较的字符数：</p><blockquote><p><code>cmp -n 17 test1.txt test2.txt</code><br><code>cmp -n 18 test1.txt test2.txt</code><br>test1.txt test2.txt differ: <strong>byte 18</strong>, line 2</p></blockquote><p>如果和<code>-i</code>参数联合使用：</p><blockquote><p><code>cmp -b -l -i 3 -n 18 test1.txt test2.txt</code><br>15 141 a 105 E<br>18 60 0 62 2</p></blockquote><p>注意这里相比于没有设置跳过字节会多出一行差异的结果，<strong>表明-n是相对字节位置，而不是绝对的字节位置</strong></p><p>和不使用<code>-i</code>的对比：</p><blockquote><p><code>cmp -b -l -n 18 test1.txt test2.txt</code><br>18 141 a 105 E</p></blockquote><div class="note info"><ul><li>注意这里是<strong>包括指定跳过的那个字节位置</strong>，比如这里的字节数为18的位置，因为包括了所以才会输出在byte18位置存在区别</li><li><strong>-n指定的是相对字节位置，而不是绝对字节位置</strong>，比如上面跳过前3个字符之后出现差异的就成了第15个字节位置的，同时因为-n设置为18向后推移3个字节，就会出现了第二个不同的位置，而如果不设置-i参数就不会得到第二个不同的位置</li></ul></div><hr><h3 id="s-抑制正常生成的输出，只返回反映文件是否相同的退出码"><a href="#s-抑制正常生成的输出，只返回反映文件是否相同的退出码" class="headerlink" title="-s-抑制正常生成的输出，只返回反映文件是否相同的退出码"></a>-s-抑制正常生成的输出，只返回反映文件是否相同的退出码</h3><blockquote><p><code>cmp -s -b test1.txt test2.txt</code></p></blockquote><p>没有输出结果，也就是原本需要输出的在哪一行存在差异都不会输出来了，然后查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果是<code>1</code>，表明文件是不相同的，这样可<strong>得到文件是否相同的信息，但是并不关注具体的差异在什么地方</strong></p><p>而如果不加<code>-s</code>就会正常输出：</p><blockquote><p><code>cmp -b test1.txt test2.txt</code><br>test1.txt test2.txt differ: byte 18, line 2 is 141 a 105 E</p></blockquote><p>同时不加<code>-s</code>查看查看命令的退出码：</p><blockquote><p>echo $?</p></blockquote><p>得到的结果和加了<code>-s</code>一样都返回的是<code>1</code></p><div class="note info"><p>在脚本中使用<code>cmp</code>命令时，此选项可以会派上用场。 例如，根据文件是否相同(通过访问命令的退出代码可以知道)来进行下一步的操作，这个时候我们可能并<strong>不关心具体文件的差异在什么地方，而是关心文件是不是有差异这个整体的结果</strong></p></div><h3 id="显示运行进度"><a href="#显示运行进度" class="headerlink" title="显示运行进度"></a>显示运行进度</h3><p>这个需要结合<a href="http://showteeth.tech/posts/6225.html">pv命令</a>，安装和使用<a href="http://showteeth.tech/posts/6225.html">pv命令</a>之后再进行学习，参考参考链接的前两个</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.howtoforge.com/linux-cmp-command/" target="_blank" rel="noopener">Linux cmp command tutorial for beginners （7 examples）</a></li><li><a href="https://www.howtoing.com/linux-cmp-command" target="_blank" rel="noopener">Linux初学者的cmp命令教程（7个例子）</a></li><li><a href="https://www.computerhope.com/unix/ucmp.htm" target="_blank" rel="noopener">Linux cmp command-关于-i参数单位的问题很好</a></li><li><a href="https://www.tutorialspoint.com/unix_commands/cmp.htm" target="_blank" rel="noopener">cmp - Unix, Linux Command</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>journey</title>
      <link href="/posts/34270.html"/>
      <url>/posts/34270.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这里写摘要，显示更好看</p></div><a id="more"></a><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><h3 id="磁器口"><a href="#磁器口" class="headerlink" title="磁器口"></a>磁器口</h3><ul><li>吃的：陈麻花-推荐<strong>陈昌银</strong>或者<strong>夏麻花</strong>、<strong>张老汉手工酸辣粉</strong>（磁器口必吃之一）</li><li>有很多文艺的小咖啡馆或者书店</li><li>磁器口的主街人满为患，商业化严重，<strong>更建议去侧街</strong>，也是咖啡馆一条街，客量少，店面装饰都很有文艺味儿，<strong>是来磁器口的正确打开方式</strong>。（在此安利一家咖啡馆——<strong>懒鱼时光馆</strong>，上图即是该咖啡馆，是一家有故事的咖啡馆）</li></ul><h3 id="洪崖洞"><a href="#洪崖洞" class="headerlink" title="洪崖洞"></a>洪崖洞</h3><ul><li><strong>晚上去</strong>，白天不好看，晚上有灯光</li><li>主要是建筑构造和风貌</li></ul><h3 id="南山一棵树观景台"><a href="#南山一棵树观景台" class="headerlink" title="南山一棵树观景台"></a>南山一棵树观景台</h3><ul><li>可以将重庆所有的美景尽收眼底！建议<strong>夜晚去</strong>，重庆的夜景很美很美很美！<ul><li>门票：门票30，学生证15</li></ul></li><li>吃的：泉水鸡、枇杷园（火锅）</li></ul><h3 id="十八梯"><a href="#十八梯" class="headerlink" title="十八梯"></a><del>十八梯</del></h3><ul><li>电影《从你的全世界路过》</li><li>十八梯是重庆渝中半岛的一条街，从重庆城的上半城（山顶）通到下半城（山脚），全部由石阶铺成，<strong>把山顶的繁华商业区和山下江边的老城区连起来</strong>。</li><li><strong>拆迁了</strong></li></ul><h3 id="朝天门两江游"><a href="#朝天门两江游" class="headerlink" title="朝天门两江游"></a>朝天门两江游</h3><ul><li>重庆很出名的两江交汇：<strong>长江与嘉陵江</strong></li><li>夜景</li></ul><h3 id="长江索道"><a href="#长江索道" class="headerlink" title="长江索道"></a>长江索道</h3><ul><li>到达对岸后不用着急回来可以在那边拍拍照，然后再返回来</li></ul><h3 id="皇冠大扶梯"><a href="#皇冠大扶梯" class="headerlink" title="皇冠大扶梯"></a>皇冠大扶梯</h3><ul><li>亚洲第二长的一级提升坡地大扶梯</li><li>这个扶梯<strong>不用刻意去</strong>，如果方便可以去坐坐，其实<em>就是一个长长的扶梯</em>，但是因为有坡度而且特别长所以很炫酷！</li></ul><h3 id="中山四路"><a href="#中山四路" class="headerlink" title="中山四路"></a>中山四路</h3><ul><li>历史遗迹很多，除了中国民主党派博物馆的特园外，此地还有桂园、周公馆、戴公馆、张骧公馆、国民政府总统府旧址等</li></ul><h3 id="解放碑"><a href="#解放碑" class="headerlink" title="解放碑"></a>解放碑</h3><ul><li><strong>解放碑是重庆的标志</strong>，特别是圣诞节和跨年的时候，大家会不约而同地去解放碑一同度过！场面壮观到每年都会提前进行封路。</li><li>解放碑那有一条<strong>好吃街</strong>，可以去吃吃～</li><li><strong>李串串</strong></li></ul><h3 id="两江影视城民国街"><a href="#两江影视城民国街" class="headerlink" title="两江影视城民国街"></a>两江影视城民国街</h3><ul><li>再现了百年老重庆风土人情</li><li>影视城里重现了当时的解放碑、磁器口、朝天门、十八梯，特别有意思</li><li>当地也可以<strong>租民国服装</strong></li></ul><h2 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h2><h3 id="重庆小面"><a href="#重庆小面" class="headerlink" title="重庆小面"></a>重庆小面</h3><h3 id="重庆火锅"><a href="#重庆火锅" class="headerlink" title="重庆火锅"></a>重庆火锅</h3><ul><li><strong>大龙火锅</strong>。以<strong>超辣</strong>闻名，吃这家店的人超级多，中午都得排很久的队</li></ul><h3 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h3><ul><li>串串推荐小郡肝、李记、怒火八零等等</li></ul><h3 id="酸辣粉-凉粉-冰粉凉虾-凉糕"><a href="#酸辣粉-凉粉-冰粉凉虾-凉糕" class="headerlink" title="酸辣粉/凉粉/冰粉凉虾/凉糕"></a>酸辣粉/凉粉/冰粉凉虾/凉糕</h3><ul><li><strong>莱得快</strong>的杂酱酸辣粉</li><li><strong>阿坤</strong>的杂酱酸辣粉、苕皮、海带，有点辣。但是阿坤里面有甜品所以可以也点一份甜品，防止被辣着，推荐它们的双皮奶。</li><li>好又来酸辣粉（口碑店家）、手工酸辣粉（视觉和味觉两不误）</li></ul><h3 id="麻辣鱼-酸菜鱼-尖椒兔"><a href="#麻辣鱼-酸菜鱼-尖椒兔" class="headerlink" title="麻辣鱼/酸菜鱼/尖椒兔"></a>麻辣鱼/酸菜鱼/尖椒兔</h3><ul><li>大渡口，店名是：<strong>霸王兔</strong></li></ul><h3 id="夜啤酒-万州烤鱼-烧烤"><a href="#夜啤酒-万州烤鱼-烧烤" class="headerlink" title="夜啤酒/万州烤鱼/烧烤"></a>夜啤酒/万州烤鱼/烧烤</h3><h3 id="奶制品"><a href="#奶制品" class="headerlink" title="奶制品"></a>奶制品</h3><ul><li>重庆本土的<strong>天友</strong>，以及后发的<strong>奶牛梦工厂</strong></li></ul><h2 id="参考路线"><a href="#参考路线" class="headerlink" title="参考路线"></a>参考路线</h2><ul><li><a href="https://www.zhihu.com/question/36219939/answer/109923082" target="_blank" rel="noopener">两天</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>comm-文件比较，文本文件的交集、差集与求差</title>
      <link href="/posts/39582.html"/>
      <url>/posts/39582.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章学习了使用<code>comm</code>命令对两个文件内容进行比较，注意文件<strong>需要排序</strong>，相比于其他比较文件的命令，<code>comm</code>可以将文件内容不同的分列显示，<strong>便于提取(文件求交、并、差、对称差等)所需要的内容</strong>，另外两个文件比较命令包括<a href="http://showteeth.tech/posts/62860.html">cmp</a>、<a href="http://showteeth.tech/posts/56778.html">diff</a>。</p></div><a id="more"></a><h2 id="comm用法"><a href="#comm用法" class="headerlink" title="comm用法"></a>comm用法</h2><p><code>comm</code>命令会<strong>一行行(line by line)地</strong>比较两个<mark>已排序文件</mark>的差异，并将其结果显示出来，如果没有指定任何参数，则会把<strong>结果分成3行显示</strong>：</p><ul><li>第1行<strong>仅</strong>是在<strong>第1个文件中</strong>出现过的列</li><li>第2行是<strong>仅</strong>在<strong>第2个文件中</strong>出现过的列</li><li>第3行则是在第1与第2个文件里<strong>都出现过</strong>的列。</li></ul><p>若给予的文件名称为<code>-</code>，则<code>comm</code>命令会从<strong>标准输入</strong>设备读取数据</p><h3 id="comm命令格式"><a href="#comm命令格式" class="headerlink" title="comm命令格式"></a>comm命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  comm [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="comm-options说明"><a href="#comm-options说明" class="headerlink" title="comm options说明"></a>comm options说明</h3><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:80%}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>不显示第1列（即不显示只在file1中找到的行）</td></tr><tr><td>-2</td><td>不显示第2列（即不显示只在file2中找到的行）</td></tr><tr><td>-3</td><td>不显示第3列（即不显示在两个文件中都找到的行）</td></tr><tr><td>–check-order</td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td>不判断所有输入文件是不是已经排好序</td></tr><tr><td>–output-delimiter=STR</td><td>指定输出结果的分隔符</td></tr></tbody></table><hr><p><br></p><h2 id="comm用法实例"><a href="#comm用法实例" class="headerlink" title="comm用法实例"></a>comm用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p>cat a.txt<br>aaa<br>bbb<br>ccc<br>111<br>ddd<br>eee<br>222</p></blockquote><blockquote><p>cat b.txt<br>bbb<br>ccc<br>aaa<br>hhh<br>ttt<br>jjj</p></blockquote><p>注意上面两个文件都没有排序，看看comm对没排序文件的处理</p><hr><h3 id="使用默认方式对文本进行比较"><a href="#使用默认方式对文本进行比较" class="headerlink" title="使用默认方式对文本进行比较"></a>使用默认方式对文本进行比较</h3><blockquote><p><code>comm a.txt b.txt</code><br>aaa<br>bbb<br>ccc<br>comm: file 1 is not in sorted order<br>comm: file 2 is not in sorted order<br>111<br>aaa<br>ddd<br>eee<br>222<br>hhh<br>ttt<br>jjj</p></blockquote><p>从上面可以看出，没排序comm命令会爆出问题，但是仍然会运行得到结果；发现因为没有排序的原因，第二个文件的<code>aaa</code>在第一个文件中也存在但是却被当成了file2独有的。<strong>总的来说就是如果没排序，comm命令会爆出问题但不会停止运行，并且结果会存在问题</strong>，正常结果如下：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><p>可以看出默认情况会输出三列，第一列是第一个文件独有的内容，第二列是第二个文件独有的内容，第三列是第三个文件独有的内容，各列是以制表符<code>\t</code>作为定界符，可以通过对定界符-制表符<code>\t</code>的操作来达到相应的目的。</p><p>由于参数较为简单，这里就不单独列出每个参数单独的用法的示例，主要给出<strong>参数组合用法以及和定界符组合使用的示例如下</strong>：</p><table><thead><tr><th>集合操作</th><th>含义及对应的参数组合</th></tr></thead><tbody><tr><td>A∩B</td><td>文件交集，-12</td></tr><tr><td>A∪B</td><td>文件的并集，将输出整合为一列，去掉定界符\t</td></tr><tr><td>A-B</td><td>差集，-23</td></tr><tr><td>B-A</td><td>差集，-13</td></tr><tr><td>A∆B</td><td>对称差集，并集减去交集，也就是去除文件中相同的部分，需要使用-3以及将剩下两列整合为一列</td></tr></tbody></table><h3 id="12-A∩B-文件交集"><a href="#12-A∩B-文件交集" class="headerlink" title="-12-A∩B-文件交集"></a>-12-A∩B-文件交集</h3><p>默认输出结果的第三列就是两个文件共有的部分：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -12 - &lt;(sort -k 1,1 b.txt)</code><br>aaa<br>bbb<br>ccc</p></blockquote><hr><h3 id="定界符-t-A∪B-文件的并集"><a href="#定界符-t-A∪B-文件的并集" class="headerlink" title="定界符\t-A∪B-文件的并集"></a>定界符\t-A∪B-文件的并集</h3><p>并集就是将三列输出结果合并：</p><blockquote><p><code>sort -k 1,1 a.txt |comm - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>aaa<br>bbb<br>ccc<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="23-A-B-差集"><a href="#23-A-B-差集" class="headerlink" title="-23-A-B-差集"></a>-23-A-B-差集</h3><p>差集就是在A中但是不在B中的部分，去掉第三列(A、B共有的)以及第二列B独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -23 - &lt;(sort -k 1,1 b.txt)</code><br>111<br>222<br>ddd<br>eee</p></blockquote><hr><h3 id="12-B-A-差集"><a href="#12-B-A-差集" class="headerlink" title="-12-B-A-差集"></a>-12-B-A-差集</h3><p>差集就是在B中但是不在A中的部分，去掉第三列(A、B共有的)以及第一列A独有的：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -13 - &lt;(sort -k 1,1 b.txt)</code><br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="3-定界符-t-A∆B-对称差集"><a href="#3-定界符-t-A∆B-对称差集" class="headerlink" title="-3+定界符\t-A∆B-对称差集"></a>-3+定界符\t-A∆B-对称差集</h3><p>对称差集就是两个文件独有的内容的并集：</p><blockquote><p><code>sort -k 1,1 a.txt |comm -3 - &lt;(sort -k 1,1 b.txt) |sed &#39;s/\t//g&#39;</code><br>111<br>222<br>ddd<br>eee<br>hhh<br>jjj<br>ttt</p></blockquote><hr><h3 id="多列文件的处理"><a href="#多列文件的处理" class="headerlink" title="多列文件的处理"></a>多列文件的处理</h3><p>多列文件处理会<strong>将一整行当成一个元素进行比较</strong>，来列出各个文件独有的、文件共有的信息，具体的每列代表的意思和单列文件相同，注意如果<strong>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠</strong></p><blockquote><p><code>cat c.txt</code><br>aaa 111<br>bbb 222</p></blockquote><blockquote><p><code>cat d.txt</code><br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><blockquote><p><code>comm c.txt d.txt</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><p>文件内容是使用<code>\t</code>作为分隔符，产生的结果输出会重叠：</p><blockquote><p><code>sed &#39;s/ /\t/&#39; c.txt |comm - &lt;(sed &#39;s/ /\t/&#39; d.txt)</code><br>aaa 111<br>aaa 222<br>bbb 222<br>ccc 333</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/comm" target="_blank" rel="noopener">comm命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-comm.html" target="_blank" rel="noopener">Linux comm命令</a></li><li><a href="https://www.cnblogs.com/nerxious/archive/2013/01/09/2853004.html" target="_blank" rel="noopener">简明Linux命令行笔记：comm</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda安装多版本python及常用命令</title>
      <link href="/posts/34297.html"/>
      <url>/posts/34297.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>anaconda作为python的包管理工具(现在已经不仅仅是python的，R的包以及其他很多包都有)非常使用和强大，这里主要学习了使用anaconda创建python2和python3环境，并在两者之间进行切换，最后还给出了anaconda的常用命令，后续还可以补充!</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本是通过anaconda给电脑安装的python3，但是今天在从github上下载使用一个package时候报错：</p><blockquote><p>SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(‘File does not exist: %s’ % filepath)?</p></blockquote><p>后来发现这个是因为<strong>python版本的问题</strong>，所以就需要<strong>重新再安装一个python2的环境</strong></p><hr><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><p>这个本来可以使用简单地打开<code>anaconda navigator</code>图形界面进行<code>creat</code>环境即可，但是秉承着想对anaconda进行学习的态度，这里主要使用命令行的形式。</p><h3 id="显示所有环境名字和路径"><a href="#显示所有环境名字和路径" class="headerlink" title="显示所有环境名字和路径"></a>显示所有环境名字和路径</h3><p>创建新环境之前先看看目前的电脑有哪些环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>发现电脑只有一个原装的<code>base</code>环境，也就是<code>python3</code>的环境以及我自己安装的<code>rstudio</code>环境，同时需要注意<strong>上面的<code>*</code>表明是当前使用的环境！</strong></p><hr><h3 id="创建环境并指定环境名称和python版本"><a href="#创建环境并指定环境名称和python版本" class="headerlink" title="创建环境并指定环境名称和python版本"></a>创建环境并指定环境名称和python版本</h3><p>这一步是使用<code>conda create</code>创建环境，同时指定环境的名称为<code>pyenv2_7</code>，使用的python版本为<code>python=2.7</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pyenv2_7 python=2.7</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="再次显示所有环境名字和路径"><a href="#再次显示所有环境名字和路径" class="headerlink" title="再次显示所有环境名字和路径"></a>再次显示所有环境名字和路径</h3><p>创建新环境再次查看现在所有的环境名称和对应的路径：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p></p><p>发现已经出现了新建的环境：</p><blockquote><p># conda environments:<br>#<br>base * C:\Users\14910\Anaconda3<br>pyenv2_7 C:\Users\14910\Anaconda3\envs\pyenv2_7<br>rstudio C:\Users\14910\Anaconda3\envs\rstudio</p></blockquote><p>由于只是创建了环境，还没有激活，所以当前使用的环境(<code>*</code>标记的)还是<code>base</code>环境，<strong>新建的环境需要激活才能够使用</strong></p><hr><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>为了能够使用新创建的环境还需要激活：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pyenv2_7</span><br></pre></td></tr></table></figure><p></p><p>为了验证环境是不是已经成功应用，检查python版本：</p><blockquote><p>python –version<br>Python 2.7.15 :: Anaconda, Inc.</p></blockquote><p>发现环境已经安装成功</p><hr><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><p>使用完成之后推出新建的环境，回到<code>base</code>环境：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p></p><p><strong>注意<code>conda deactivate</code>后面不需要跟退出的环境名，直接就退出当前环境，退出环境之后直接就进入了base环境</strong>。</p><hr><h2 id="anaconda-常用命令"><a href="#anaconda-常用命令" class="headerlink" title="anaconda 常用命令"></a>anaconda 常用命令</h2><ul><li>activate // 切换到base环境</li><li>activate learn // 切换到learn环境</li><li>conda deactivate // 退出当前环境</li><li>conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)</li><li>conda env list (conda env –info) // 列出conda管理的所有环境</li><li>conda list // 列出当前环境的所有包</li><li>conda install requests (pip install requests) // 安装requests包</li><li>conda remove requests (pip uninstall requests) // 卸载requets包</li><li>conda update requests // 更新requests包</li><li>conda remove -n learn –all // <strong>删除learn环境及下属所有包</strong></li><li>conda env export &gt; environment.yaml // <strong>导出当前环境的包信息</strong></li><li>conda env create -f environment.yaml // <strong>用配置文件创建新的虚拟环境</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/tangwenbo124/article/details/74784044" target="_blank" rel="noopener">ananconda创建新环境，python 2.7、3.5共存，pycharm 使用conda新环境，win10、linux下通用</a></li><li><a href="https://www.jb51.net/article/114614.htm" target="_blank" rel="noopener">利用Anaconda完美解决Python 2与python 3的共存问题</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成-使用Travis CI自动部署github项目</title>
      <link href="/posts/62916.html"/>
      <url>/posts/62916.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>linux系统，换电脑之后再写！</p></div><a id="more"></a><h2 id="开始于二级标题"><a href="#开始于二级标题" class="headerlink" title="开始于二级标题"></a>开始于二级标题</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://segmentfault.com/a/1190000011218410?utm_source=tag-newest" target="_blank" rel="noopener">Travis CI 自动化部署博客</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程</a></li><li><a href="https://www.cnblogs.com/zqzjs/p/6119750.html" target="_blank" rel="noopener">Travis CI用来持续集成你的项目</a></li><li><a href="https://www.cnblogs.com/morang/p/7228488.html" target="_blank" rel="noopener">使用travis-ci自动部署github上的项目</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理多个SSH公钥</title>
      <link href="/posts/51573.html"/>
      <url>/posts/51573.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>项目托管可能需要在多个平台上进行，这就需要设置多个SSH公钥来简化代码提交步骤，这里学习总结了同时使用多个SSH公钥提交代码至不同平台（coding pages、github）的方法</p></div><a id="more"></a><h2 id="SSH-key介绍"><a href="#SSH-key介绍" class="headerlink" title="SSH key介绍"></a>SSH key介绍</h2><p>SSH key提供了一种与GitHub或其他平台通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub或其他平台作为自己的remote端服务器，进行版本控制。</p><p>需要注意的是<strong>不同平台的SSH key各不相同</strong>，所以为了能在各个平台上方便地使用git进行版本控制，就需要设置多个SSH key。</p><p><strong>使用SSH key的步骤</strong>：</p><ul><li>在客户端生成SSH key（密钥对：公钥-&gt;锁头和私钥-&gt;钥匙，利用了公钥和私钥实现数据加密和解密）</li><li>在服务端的配置文件中加入你的公钥。（比如我们需要再GitHub中粘贴你的公钥）</li></ul><p><strong>具体原理</strong>：用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回远程主机，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。</p><hr><p><br></p><h2 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h2><p>默认情况下，使用<code>ssh-keygen</code>生成会在<code>C:\Users\user\.ssh</code>目录下生成SSH key(<code>id_rsa</code>和<code>id_rsa.pub(公钥)</code>)，为了使生成了SSH key互不干扰，所以需要使用<code>-f</code>参数进行设置生成了SSH key名称，不然可能会覆盖。</p><p>在<strong>git bash</strong>中输入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/keyname(eg:github)</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"YOUR_EMAIL@YOUREMAIL.COM"</span> -f ~/.ssh/coding_pages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-t：指定要创建的密钥类型，默认是 rsa ，可以省略</span><br><span class="line">-C：添加注释，比如邮箱；</span><br><span class="line">-f：指定用来保存密钥的文件名；</span><br><span class="line">-b：指定密钥长度；</span><br><span class="line">-e：读取openssh的私钥或者公钥文件；</span><br><span class="line">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；</span><br><span class="line">-l：显示公钥文件的指纹数据；</span><br><span class="line">-N：提供一个新密语；</span><br><span class="line">-P：提供（旧）密语；</span><br><span class="line">-q：静默模式；</span><br></pre></td></tr></table></figure><p></p><p>上述命令输入后，会出现<strong>如下提示</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line"><span class="comment"># Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span></span><br></pre></td></tr></table></figure><p></p><ul><li>可以不输入文件名，使用默认文件名（推荐），那么就会生成 github 和 github.pub 两个秘钥文件；</li><li>接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）；</li><li>也可以不输入密码，直接按回车，那么push的时候就不需要输入密码，直接提交到github上了；</li><li>将 github.pub 文件的内容添加到github上面的ssh key</li></ul><p>以上是生成一个的过程，生成另一个的过程也是相同的操作。</p><hr><p><br></p><h2 id="添加生成的SSH"><a href="#添加生成的SSH" class="headerlink" title="添加生成的SSH"></a>添加生成的SSH</h2><p>将上述得到的公钥(以<strong>pub结尾的文件</strong>内容复制到平台相应的ssh key添加部位)：</p><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/github_key.png"><br></div><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/coding_pages_key.png"><br></div><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在 <code>C:\Users\user\.ssh</code> 目录下新建一个config文件，并添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host 公司github的地址 如：github.com</span><br><span class="line">HostName 公司github的地址 如：github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host git.dev.tencent.com</span><br><span class="line">    HostName git.dev.tencent.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/coding_pages</span><br></pre></td></tr></table></figure><p>上述host地址的得到可以通过点击平台任意一个项目的<code>clone and download</code>看到，冒号<code>:</code>前面的就是host地址了</p><hr><p><br></p><h2 id="验证SSH-key是否添加成功"><a href="#验证SSH-key是否添加成功" class="headerlink" title="验证SSH key是否添加成功"></a>验证SSH key是否添加成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding pages</span></span><br><span class="line">ssh -T git@git.dev.tencent.com</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Hi showteeth! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><blockquote><p>Coding 提示: Hello showteeth, You’ve connected to Coding.net via SSH. This is a personal key.<br>showteeth，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</p></blockquote><p>到这里留完成了管理多个SSH公钥的步骤，接下来就可以不用输入密码地将代码托管到相应的平台上了!</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/3e57bb0f8185" target="_blank" rel="noopener">如何同时使用多个SSH公钥提交代码至不同平台</a></li><li><a href="https://blog.csdn.net/DBB_zifeng/article/details/71698865" target="_blank" rel="noopener">管理多个SSH公钥密钥</a></li><li><a href="https://www.jianshu.com/p/a869072a0092" target="_blank" rel="noopener">同一台电脑关于多个SSH KEY管理</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF转HTML-pdf2htmlex</title>
      <link href="/posts/40996.html"/>
      <url>/posts/40996.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>pdf2htmlex是一款将pdf文件转换为html文件的工具，在github上有接近8000个star！这里主要介绍了其安装和使用方法，安装在windows下是使用了docker。</p></div><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><p>由于电脑是windows系统，所以只能按照<a href="https://gist.github.com/cnstar9988/3571c66b49050d98df92142dc19fbb00" target="_blank" rel="noopener">这里</a>给定的教程进行安装，无奈尝试了很多次，最终都以失败告终，都有点想放弃使用这个工具了，但是后来尝试了其他工具如<a href="https://github.com/mgufrone/pdf-to-html" target="_blank" rel="noopener">pdf-to-html</a>，但是效果很差，出来的效果和原本的pdf差很多，所以还是放弃了。</p><p>最近忽然发现应该可以使用docker进行安装，所以尝试使用<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>，接下来就是安装和使用docker：</p><ul><li>注册docker账号然后下载</li><li>安装docker，这里注意如果电脑上安装了360会提示<strong>发现黑客新建用户帐号，建议阻止</strong>，鉴于360的一贯行为以及阻止后不能顺利安装，我选择了允许操作</li><li>安装完成之后会<strong>注销和重启电脑</strong>，这个按照提示操作即可</li><li>最后需要注意的是<strong>运行docker是在命令行形式下运行</strong>，而不是直接打开桌面的快捷方式</li></ul><hr><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>使用docker安装pdf2htmlex，可以参考<a href="https://github.com/BWITS/pdf2htmlEX_docker" target="_blank" rel="noopener">官方给出的教程</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><p>输入上述命令后<strong>发现错误</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> connection (Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span><br></pre></td></tr></table></figure><p></p><p>上网搜了一下，发现这个错误是因为网络原因导致无法拉取镜像，解决方法：<strong>使用国内的Docker仓库daocloud</strong>：</p><ul><li>进入<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daocloud关于docker加速器的网站</a>，找到<strong>配置 Docker 加速器</strong>下对应的操作系统，因为我使用的windows系统，所以选择windows系统下的<code>http://f1361db2.m.daocloud.io</code></li></ul><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/docker配置镜像2.png"><br></div><ul><li>将上述所得到的的地址写入<code>docker-&gt;setting-&gt;daemon-&gt;registry mirrors</code>中，然后<strong>apply</strong>，docker会提示<strong>restart</strong>：</li></ul><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/docker配置镜像.png"><br></div><ul><li>上述操作完成之后重新执行命令，发现下载速度飞快~~~</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bwits/pdf2htmlex-alpine</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="通过docker命令"><a href="#通过docker命令" class="headerlink" title="通过docker命令"></a>通过docker命令</h3><p>详细的使用参考<a href="https://github.com/coolwanglu/pdf2htmlEX/wiki/Quick-Start" target="_blank" rel="noopener">工具的github</a>，这里我只尝试较为简单的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX --zoom 1.8  resume.pdf</span><br></pre></td></tr></table></figure><p></p><p>用到的docker参数说明：</p><ul><li><code>-v</code>：挂载宿主机目录，~/pdf对应于C:\Users\user\pdf，/pdf的容器的目录，在容器启动后，容器内会自动创建/pdf目录，也就是冒号<code>:</code>前面的目录是宿主机目录，后面的目录是容器内目录。<strong>注意使用时docker会提示需要使用文件权限</strong>，如果宿主机目录放在C盘，还要输入电脑密码</li><li><code>--rm</code>：默认情况下，每个container在退出时，它的文件系统也会保存下来，该参数可以让docker在container结束时自动清理其所产生的数据</li><li><code>-ti</code>：以交互模式启动一个容器</li></ul><hr><h3 id="创建命令调用别名"><a href="#创建命令调用别名" class="headerlink" title="创建命令调用别名"></a>创建命令调用别名</h3><p>因为使用的docker安装，每次调用可能全长命令比较麻烦，所以这里使用alias创建命令别名-pdf2htmlEX：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己修改挂载目录</span></span><br><span class="line"><span class="built_in">alias</span> pdf2htmlEX=<span class="string">"docker run -ti --rm -v D:/pdf2html:/pdf bwits/pdf2htmlex pdf2htmlEX"</span></span><br></pre></td></tr></table></figure><p>这里一直没有成功不知道是为什么，总是显示<code>文件名、目录名或卷标语法不正确。</code>，但我直接使用命令不使用alias的方式却能正常使用，所以就没有继续使用这个</p><blockquote><p>系统自带的cmd是不支持alias的，我这里使用的是<a href="https://cmder.net/" target="_blank" rel="noopener">cmder</a>，很强大的命令行工具，关于如何在windows下配置这个工具，可以参考博客中关于配置cmder的文章</p></blockquote><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pdf2htmlex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coding_pages和mkdocs使用</title>
      <link href="/posts/54578.html"/>
      <url>/posts/54578.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>coding pages和mkdocs使用简介</p></div><a id="more"></a><h2 id="注册coding-pages"><a href="#注册coding-pages" class="headerlink" title="注册coding pages"></a>注册coding pages</h2><ul><li>前往其<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>，常规的注册方法即可</li><li>关于会员：<ul><li><a href="https://feedback.coding.net/topics/7257" target="_blank" rel="noopener">免费升级</a>好像</li><li>升级之前不可以创建项目，如果有项目需要转让或者删除，具体操作步骤<a href="https://dev.tencent.com/help/doc/account/up-to-tencent#CODING-3" target="_blank" rel="noopener">参考文章</a></li></ul></li></ul><hr><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>填写项目标识，项目标识在最后创建完pages之后就会显示为username.coding.me/项目标识/</li><li>项目名称填写：username.coding.me，相当于 github 上面的 name.github.io</li><li>创建完成即进入项目，选择代码下的代码浏览，创建<code>index.html</code>页面(注意名字一定要叫 <code>index.html</code>)，随意写一段话：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Coding Pages<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Coding!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>然后点击左侧<strong>代码</strong>下的 <strong>Pages 服务</strong>，选择<strong>静态 Pages 服务</strong>，一键创建pages</li><li>静态 Coding Pages 允许的部署分支来源为master 分支和coding-pages 分支，默认部署来源是master 分支，用户可在设置(右上角)里更改部署来源（实测发现只有master分支）。部署成功后后可通过<code>&lt;user_name&gt;.coding.me／&lt;project_name&gt;</code>形式的 URL 访问静态 Pages</li><li>如果需要自定义域名，这个也在pages服务中的设置(右上角)中进行设置</li></ul><hr><p><br></p><h2 id="结合mkdocs"><a href="#结合mkdocs" class="headerlink" title="结合mkdocs"></a>结合mkdocs</h2><h3 id="安装相关packages"><a href="#安装相关packages" class="headerlink" title="安装相关packages"></a>安装相关packages</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装mkdocs</span></span><br><span class="line">pip install mkdocs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure><hr><h3 id="常规用法："><a href="#常规用法：" class="headerlink" title="常规用法："></a>常规用法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">mkdocs new my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动内建服务器</span></span><br><span class="line">mkdocs serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点生成，创建了一个 site 新目录</span></span><br><span class="line">mkdocs build</span><br></pre></td></tr></table></figure><hr><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主题和头像</span></span><br><span class="line">theme:</span><br><span class="line">  name: material</span><br><span class="line">  favicon: <span class="string">'/dark_logo_16x16.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加页面</span></span><br><span class="line">nav:</span><br><span class="line">- 主页 : index.md</span><br><span class="line">- 软件 : about.md</span><br><span class="line">- 项目 : about.md</span><br><span class="line">- 关于 : about.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持中文搜索，虽然search功能(lunr.js)暂不直接支持中文，但测试发现设置为日语后，中文和英文搜索都可以使用</span></span><br><span class="line">extra:</span><br><span class="line">  search:</span><br><span class="line">    language: <span class="string">'jp'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加扩展</span></span><br><span class="line">markdown_extensions:</span><br><span class="line">  - admonition</span><br><span class="line">  - codehilite:</span><br><span class="line">      guess_lang: <span class="literal">false</span></span><br><span class="line">      linenums: <span class="literal">false</span></span><br><span class="line">  ......</span><br><span class="line"><span class="comment"># 自定义的CSS和JS</span></span><br><span class="line">extra_javascript:</span><br><span class="line">  - <span class="string">'js/extra.js'</span></span><br><span class="line">  - <span class="string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'</span></span><br><span class="line"></span><br><span class="line">extra_css:</span><br><span class="line">  - <span class="string">'css/extra.css'</span></span><br></pre></td></tr></table></figure><hr><h3 id="上传到coding-pages"><a href="#上传到coding-pages" class="headerlink" title="上传到coding pages"></a>上传到coding pages</h3><ul><li>将coding pages项目clone到本地：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里本想使用ssh的链接，但是失败，提示repo不存在，但是使用https的却可以成功，需要再看看问题</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.dev.tencent.com/showteeth/project.git bio_projects</span><br></pre></td></tr></table></figure><ul><li>将原本mkdoc目录下的文件拷进这个目录</li><li><p>部署到coding pages，详细参考<a href="https://www.mkdocs.org/user-guide/deploying-your-docs/" target="_blank" rel="noopener">官方教程</a></p><ul><li>自动将相应内容推送到项目的 master 分支上，默认会部署在 gh-pages 分支上，而我的账户好像只能部署在master分支上，所以只能修改分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdocs gh-deploy -b master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>输入链接即可访问</p></li></ul><p>最后吐槽一句：coding pages真的好慢好慢！！！！</p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.mkdocs.org/" target="_blank" rel="noopener">mkdocs的官方网站</a></li><li><a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs的github</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">mkdocs主题material的相关材料（拓展、代码高亮）</a></li><li><a href="https://docs.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">readthedocs的官方网站（介绍的比较简答，具体实施还是需要看mkdocs的网站说明）</a></li><li><a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs托管文档</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/syntax/note_style/" target="_blank" rel="noopener">支持的markdown语法</a></li><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">基于mkdocs-material搭建个人静态博客(含支持的markdown语法)</a></li><li><a href="https://docs.flc.io/more/github-travis-mkdocs-document/" target="_blank" rel="noopener">使用mkdocs搭建的文档库</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter主题、插件、技巧、server搭建</title>
      <link href="/posts/13473.html"/>
      <url>/posts/13473.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>针对默认的jupyter notebook的页面进行修改、增加一些插件使jupyter的使用更加方便，整理一些jupyter使用技巧，最后是关于搭建jupyter server的内容</p></div><a id="more"></a><h2 id="jupyter默认页面的修改"><a href="#jupyter默认页面的修改" class="headerlink" title="jupyter默认页面的修改"></a>jupyter默认页面的修改</h2><p>jupyter默认页面的修改主要是使用<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyter-themes</a>包。</p><h3 id="jupyter-themes安装"><a href="#jupyter-themes安装" class="headerlink" title="jupyter-themes安装"></a>jupyter-themes安装</h3><p>常规的<code>pip</code>安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install jupyterthemes</span></span><br><span class="line">pip install jupyterthemes</span><br><span class="line"></span><br><span class="line"><span class="comment"># upgrade to latest version</span></span><br><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure><ul><li>为了达到最好的效果，建议notebook的版本是<code>&gt;=5.6.0</code>，如果低于此版本可以使用<code>pip install --upgrade notebook</code>进行升级</li><li>refreshing / removing / resetting：如果想要恢复默认值或者使新采用的主题生效，可能需要清除浏览器缓存（不一定非要进行，看自己的浏览器和系统，真遇到情况可以参考<a href="https://github.com/dunovank/jupyter-themes/issues/86" target="_blank" rel="noopener">issue</a>）；进行上述操作后刷新浏览器肯定是要刷新浏览器的！</li><li>安装或其他问题直接上<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">github</a>找答案！</li></ul><hr><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jt  [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">    [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">    [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim]</span><br><span class="line">    [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout]</span><br><span class="line">    [-P] [-T] [-N] [-r] [-dfonts]</span><br></pre></td></tr></table></figure><p>具体的参数说明：</p><table><thead><tr><th>cl options</th><th>arg</th><th>default</th></tr></thead><tbody><tr><td>Usage help</td><td>-h</td><td>–</td></tr><tr><td>List Themes</td><td>-l</td><td>–</td></tr><tr><td>Theme Name to Install</td><td>-t</td><td>–</td></tr><tr><td>Code Font</td><td>-f</td><td>–</td></tr><tr><td>Code Font-Size</td><td>-fs</td><td>11</td></tr><tr><td>Notebook Font</td><td>-nf</td><td>–</td></tr><tr><td>Notebook Font Size</td><td>-nfs</td><td>13</td></tr><tr><td>Text/MD Cell Font</td><td>-tf</td><td>–</td></tr><tr><td>Text/MD Cell Fontsize</td><td>-tfs</td><td>13</td></tr><tr><td>Pandas DF Fontsize</td><td>-dfs</td><td>9</td></tr><tr><td>Output Area Fontsize</td><td>-ofs</td><td>8.5</td></tr><tr><td>Mathjax Fontsize (%)</td><td>-mathfs</td><td>100</td></tr><tr><td>Intro Page Margins</td><td>-m</td><td>auto</td></tr><tr><td>Cell Width</td><td>-cellw</td><td>980</td></tr><tr><td>Line Height</td><td>-lineh</td><td>170</td></tr><tr><td>Cursor Width</td><td>-cursw</td><td>2</td></tr><tr><td>Cursor Color</td><td>-cursc</td><td>–</td></tr><tr><td>Alt Prompt Layout</td><td>-altp</td><td>–</td></tr><tr><td>Alt Markdown BG Color</td><td>-altmd</td><td>–</td></tr><tr><td>Alt Output BG Color</td><td>-altout</td><td>–</td></tr><tr><td>Style Vim NBExt*</td><td>-vim</td><td>–</td></tr><tr><td>Toolbar Visible</td><td>-T</td><td>–</td></tr><tr><td>Name &amp; Logo Visible</td><td>-N</td><td>–</td></tr><tr><td>Kernel Logo Visible</td><td>-kl</td><td>–</td></tr><tr><td>Reset Default Theme</td><td>-r</td><td>–</td></tr><tr><td>Force Default Fonts</td><td>-dfonts</td><td>–</td></tr></tbody></table><p>github上有具体的示例用法，建议大家去看看，我这里挑选我最喜欢的配置如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t monokai -f firacode -fs 12 -cellw 70% -ofs 10 -dfs 11 -T -N -altp -lineh 140</span><br></pre></td></tr></table></figure><p></p><ul><li>上述命令是在cmd中输入进行配置，而不是在jupyter notebook中</li><li>-fs：字体大小</li><li>-ofs：输出字体大小</li><li>-dfs：pandas dataframe字体大小</li><li>-cellw：主体宽度</li><li>-T：显示导航栏</li><li>-N：显示文件名称</li><li>-altp：不显示格子左上角的number</li><li>-lineh：行高</li></ul><p>设置完成之后发现<strong>jupyter的logo没有完全显示出来</strong>，同时<strong>文件名称也只显示了一部分</strong>，这些需要修改，找到<code>C:\Users\username\.jupyter\custom</code>目录下的<code>custom.css</code>进行修改:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将none改为block来显示jupyter的logo --&gt;</span></span><br><span class="line">div#ipython_notebook &#123;</span><br><span class="line"> display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将height: initial修改为20px，这个可以自己设置 --&gt;</span></span><br><span class="line">span.save_widget span.filename &#123;</span><br><span class="line"> margin-left: 8px;</span><br><span class="line"> height: 22px;</span><br><span class="line"> font-size: 100%;</span><br><span class="line"> color: #a6e22e;</span><br><span class="line"> background-color: #282828;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述修改每次重新修改主题相关配置后都需要重新修改</p><p>修改绘图配置：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jupyterthemes <span class="keyword">import</span> jtplot</span><br><span class="line">jtplot.style(theme=<span class="string">'grade3'</span>,ticks=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p></p><hr><p><br></p><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>主要使用的包是<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">jupyter_contrib_nbextensions</a>，这是一个非常强大的包，里面包含了很多在jupyter notebook只很常用的插件，包括代码段、显示目录等等等，同时这个包还提供了一个链接：<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">A collection of various notebook extensions for Jupyter</a>，里面总结了可以用在jupyter notebook中的插件。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install the python package</span></span><br><span class="line"><span class="comment">## 这个安装经常失败，下载速度太慢了</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment">## 换用这个了</span></span><br><span class="line">pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install javascript and css files</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>上述两步安装完成之后就可以在jupyter的homo page看到如下的插件：</p><div align="center" width="600px"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/jupyter插件.png"><br></div><p>选取插件安装：</p><ul><li><strong>Code prettify</strong></li></ul><p>插件的快捷键：ctrl + l进行单个cell的prettify（也可以在选中cell时直接点击导航栏的小锤子按钮）、Ctrl-Shift-L进行所有的的prettify<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个插件安装后提示yapf没有安装</span></span><br><span class="line">pip install yapf</span><br></pre></td></tr></table></figure><p></p><p>After checking “Snippets Menu” in Configurable nbextensions, Snippets did’t appear in</p><ul><li><strong>Collapsible headings</strong>-折叠标题</li><li><strong>Snippets</strong>-自定义代码片段</li></ul><p>修改<code>C:\Users\user\AppData\Roaming\jupyter\nbextensions\snippets\snippets.json</code>来添加新的代码段，注意是上面的地址，<strong>而不是anaconda目录下的文件，如果修改了anaconda下的文件不起作用</strong>。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "name" : "common_use",</span><br><span class="line">    "code" : [</span><br><span class="line">        "import os",</span><br><span class="line">        "import sys",</span><br><span class="line">        "import numpy as np",</span><br><span class="line">        "import pandas as pd"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编辑完成之后想要生效需要重启jupyter notebook</p><ul><li><strong>Table of Contents (2)</strong>-显示目录结构</li></ul><p>这个和上面的jupyter-themes好像要有些冲突，导航栏遮挡部分的目录结构，现在还不知道有没有什么解决办法， 可以取舍一下</p><ul><li><strong>Highlight selected word</strong>-高亮代码中与选中部分相同的</li><li><strong>highlighter</strong>-高亮选中的文本</li><li><strong>ExecuteTime</strong>-显示每个cell的运行时间</li><li><strong>table_beautifier</strong>-让输出的table更好看</li><li><strong>Snippets Menu</strong>-和snippet类似，但是<mark>没有正常工作，需要看看为什么？？？</mark></li><li><strong>Hinterland</strong>-自动补全代码</li></ul><hr><p><br></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li><a href="https://www.jianshu.com/p/a85bc2a8fa56" target="_blank" rel="noopener">多行输出</a></li><li><a href="https://zhuanlan.zhihu.com/p/32600329" target="_blank" rel="noopener">关于Jupyter Notebook的28个技巧(快捷键、Magic命令等)</a></li></ul><h2 id="jupyter-server搭建"><a href="#jupyter-server搭建" class="headerlink" title="jupyter server搭建"></a>jupyter server搭建</h2><ul><li><a href="https://bitmingw.com/2017/07/09/run-jupyter-notebook-server/" target="_blank" rel="noopener">搭建 ipython/jupyter notebook 服务器</a></li><li><a href="https://jupyter-notebook.readthedocs.io/en/stable/public_server.html" target="_blank" rel="noopener">Running a notebook server</a></li></ul><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML中的实体空格与markdown空格缩进</title>
      <link href="/posts/58681.html"/>
      <url>/posts/58681.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了HTML中的6种实体空格以及在实际markdown写作中会涉及到的空格缩进应该使用哪种空格实体会比较好，最后发现使用<code>&amp;emsp;</code>-全角空格在中文markdown写作中是最合适的</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在markdown写作过程中，我们可能需要再文本中插入一些空格，比如中文的首行缩进，与word文档写作直接使用space键空两格即可出现空格不同，markdown不会识别这种空格(四个空格会代表代码块)，为了达到插入空格的效果就需要使用<strong>HTML中的空格实体</strong></p><hr><h2 id="HTML中的实体空格"><a href="#HTML中的实体空格" class="headerlink" title="HTML中的实体空格"></a>HTML中的实体空格</h2><p>HTML提供了6种空格实体（space entity），它们拥有不同的宽度，<strong>非断行空格（<code>&amp;nbsp;</code>）是常规空格的宽度，可运行于所有主流浏览器</strong>。其他几种空格（<code>&amp;ensp;</code>、<code>&amp;emsp;</code>、<code>&amp;thinsp;</code>、<code>&amp;zwnj;</code>、<code>&amp;zwj;</code>）在<strong>不同浏览器中宽度各异</strong></p><h3 id="amp-nbsp-不换行空格"><a href="#amp-nbsp-不换行空格" class="headerlink" title="&amp;nbsp;-不换行空格"></a><code>&amp;nbsp;</code>-不换行空格</h3><p>&emsp;&emsp;它叫不换行空格，全称是 <strong>No-Break Space</strong>，它是最常见和我们<em>使用最多</em>的空格，大多数的人可能只接触了<code>&amp;nbsp;</code>，它是<strong>按下space键产生的空格，一般两个<code>&amp;nbsp;</code>对应于一个中文字符</strong>。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个），要使用html实体表示才可累加，<strong>该空格占据宽度受字体影响明显而强烈</strong>。</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&nbsp;&nbsp;字体，前面有两个<code>&amp;nbsp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不同的！</p><hr><h3 id="amp-ensp-半角空格"><a href="#amp-ensp-半角空格" class="headerlink" title="&amp;ensp;-半角空格"></a><code>&amp;ensp;</code>-半角空格</h3><p>&emsp;&emsp;它叫<strong>半角空格</strong>，全称是 <strong>En Space</strong>，<code>en</code>是字体排印学的计量单位，为<code>em</code>宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母<code>n</code>的宽度。此空格传承空格家族一贯的特性：透明的，<strong>此空格有个相当稳健的特性，就是其占据的宽度正好是<u>1/2个中文宽度</u>，而且<mark>基本上不受字体影响</mark></strong></p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不变的，并且两格空格占据一个字体大小！</p><hr><h3 id="amp-emsp-全角空格"><a href="#amp-emsp-全角空格" class="headerlink" title="&amp;emsp;-全角空格"></a><code>&amp;emsp;</code>-全角空格</h3><p>&emsp;&emsp;它叫<strong>全角空格</strong>，全称是 <strong>Em Space</strong>，<code>em</code>是字体排印学的计量单位，相当于当前指定的点数。例如，<code>1 em</code>在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，<strong>此空格也有个相当稳健的特性，就是其占据的宽度正好是<u>1个中文宽度</u>，而且<mark>基本上不受字体影响</mark></strong>，和上面的<code>&amp;ensp;</code>-半角空格特性相同，但是是一个中文宽度</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&emsp;&emsp;字体，前面有两个<code>&amp;emsp;</code>空格</font></li></ul><p>发现在不同字体中，空格的大小是不变的，并且两格空格占据两个字体大小！</p><hr><h3 id="amp-thinsp-窄空格"><a href="#amp-thinsp-窄空格" class="headerlink" title="&amp;thinsp;-窄空格"></a><code>&amp;thinsp;</code>-窄空格</h3><p>&emsp;&emsp;它叫<strong>窄空格</strong>，全称是 <strong>Thin Space</strong>。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是<code>em</code>之六分之一宽(前面的<code>&amp;ensp;</code>-半角空格是<code>em</code>宽度的一半，<code>&amp;emsp;</code>-全角空格就是<code>em</code>宽度)</p><p>示例如下：</p><ul><li><font face="\5FAE\8F6F\96C5\9ED">微软雅黑&emsp;字体，前面有一个<code>&amp;emsp;</code>空格</font></li><li><font face="\9ED1\4F53">这是黑体&ensp;&ensp;字体，前面有两个<code>&amp;ensp;</code>空格</font></li><li><font face="\5B8B\4F53">这是宋体&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;&thinsp;字体，前面有六个<code>&amp;thinsp;</code>空格</font></li></ul><hr><h3 id="amp-zwnj-零宽不连字"><a href="#amp-zwnj-零宽不连字" class="headerlink" title="&amp;zwnj;-零宽不连字"></a><code>&amp;zwnj;</code>-零宽不连字</h3><p>&emsp;&emsp;它叫<strong>零宽不连字</strong>，全称是 <strong>Zero Width Non Joiner</strong>，简称“ZWNJ”，是一个<strong>不打印字符</strong>，放在<strong>电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制</strong>。<em>Unicode</em>中的零宽不连字<strong>字符映射为</strong>（zero width non-joiner，<code>U+200C</code>），HTML<strong>字符值引用</strong>为<code>&amp;#8204</code></p><h3 id="amp-zwj-零宽连字"><a href="#amp-zwj-零宽连字" class="headerlink" title="&amp;zwj;-零宽连字"></a><code>&amp;zwj;</code>-零宽连字</h3><p>&emsp;&emsp;它叫<strong>零宽连字</strong>，全称是 <strong>Zero Width Joiner</strong>，简称“ZWJ”，是一个<strong>不打印字符</strong>，放在某些需要<strong>复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果</strong>。零宽连字符的Unicode码位是<code>U+200D</code> (HTML:<code>&amp;#8205;</code>、<code>&amp;zwj;</code>）。</p><p>此外，<strong>浏览器还会把以下字符当作空白进行解析</strong>：空格<code>&amp;#x0020;</code>、制表位<code>&amp;#x0009;</code>、换行<code>&amp;#x000A;</code>、回车<code>&amp;#x000D;</code>和<code>&amp;#12288;</code>等等。</p><hr><h2 id="markdowm首行缩进方法"><a href="#markdowm首行缩进方法" class="headerlink" title="markdowm首行缩进方法"></a>markdowm首行缩进方法</h2><p>通过上述对HTML中实体空格的介绍，可以总结出以下几种可以用在markdown中充当首行缩进的方法：</p><ul><li>使用<code>&amp;emsp;</code>-全角空格，优点：占据的宽度正好是<u>1个中文宽度</u>，而且<strong>基本上不受字体影响</strong>，<strong>推荐使用这个进行首行缩进</strong></li><li>使用<code>&amp;ensp;</code>-半角空格，优点：占据的宽度正好是<u>1/2个中文宽度</u>，需要使用两格才能达到缩进效果，而且<strong>基本上不受字体影响</strong></li><li>使用<code>&amp;nbsp;</code>-不换行空格，缺点：<u>需要使用四个来代表两个中文字符</u>，并且<strong>受字体影响较大</strong></li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/31eade263e7a" target="_blank" rel="noopener">markdown空格缩进以及HTML空格实体</a></li><li><a href="https://blog.csdn.net/testcs_dn/article/details/78957685" target="_blank" rel="noopener">markdown编辑器中可以使用的6种空格标记</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结|位、字节、字符和编码</title>
      <link href="/posts/56690.html"/>
      <url>/posts/56690.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要讲解了编码、字符、字节、位的概念，以及不同编码情况下字节与字符的对应关系，主要包括<code>ASCII码</code>、<code>UTF-8编码</code>、<code>Unicode编码</code>、<code>UTF-16编码</code>和<code>UTF-32编码</code>。</p></div><a id="more"></a><h2 id="编码问题的由来，相关概念的理解"><a href="#编码问题的由来，相关概念的理解" class="headerlink" title="编码问题的由来，相关概念的理解"></a>编码问题的由来，相关概念的理解</h2><h3 id="字符与编码的发展"><a href="#字符与编码的发展" class="headerlink" title="字符与编码的发展"></a>字符与编码的发展</h3><p>从计算机对多国语言的支持角度看，大致可以分为三个阶段：<br><table><tr><th width="10%">　</th><th width="10%">系统内码</th><th width="60%">说明</th><th width="20%">系统</th></tr><tr><td>阶段一</td><td>ASCII</td><td>计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。</td><td>英文 DOS</td></tr><tr><td>阶段二</td><td>ANSI编码（本地化）</td><td>为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 <strong>2 个字节来表示 1 个字符</strong>。比如：汉字 '中' 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些 <strong>使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码</strong>。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。<strong>不同 ANSI 编码之间 互不兼容 </strong>，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 <strong>ANSI 编码</strong>的文本中。</td><td>中文 DOS，中文 Windows 95/98，日文 Windows 95/98</td></tr><tr><td>阶段三</td><td>UNICODE（国际化）</td><td>为了使国际间信息交流更加方便，国际组织制定了 <strong>UNICODE 字符集</strong>，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。</td><td>Windows NT/2000/XP，Linux，Java</td></tr></table></p><p>字符串在内存中的存放方法：</p><p>在 <strong>ASCII</strong> 阶段，<strong>单字节字符串</strong>使用<strong>一个字节存放一个字符（SBCS）</strong>。比如，”Bob123” 在内存中为：<br><u>42</u> <u>6F</u> <u>62</u> <u>31</u> <u>32</u> <u>33</u> <u>00</u><br>&nbsp;B&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0</p><p>在使用 <strong>ANSI 编码</strong>支持多种语言阶段，每个字符使用一个字节或多个字节来表示（MBCS），因此，这种方式存放的字符也被称作<strong>多字节字符</strong>。比如，”中文123” 在中文 Windows 95 内存中为7个字节，<strong>每个汉字占2个字节，每个英文和数字字符占1个字节</strong>：</p><p><u>D6 D0</u> <u>CE C4</u> <u>31</u> <u>32</u> <u>33</u> <u>00</u><br>&emsp;中&emsp;&emsp;文&emsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;\0</p><p>在 <strong>UNICODE</strong> 被采用之后，计算机存放字符串时，改为存放每个字符在 UNICODE 字符集中的序号。目前计算机<strong>一般使用 2 个字节（16 位）来存放一个序号（DBCS）</strong>，因此，这种方式存放的字符也被称作<strong>宽字节字符</strong>。比如，字符串 “中文123” 在 Windows 2000 下，内存中实际存放的是 5 个序号：</p><p><u>2D 4E</u> <u>87 65</u> <u>31 00</u> <u>32 00</u> <u>33 00</u> <u>00 00</u> &lt;-在 x86 CPU 中，低字节在前<br>&emsp;中&emsp;&emsp;文&emsp;&emsp;1&emsp;&emsp;2&emsp;&emsp;3&emsp;&emsp;\0<br>一共占 10 个字节</p><hr><h3 id="字符、字节、字符串"><a href="#字符、字节、字符串" class="headerlink" title="字符、字节、字符串"></a>字符、字节、字符串</h3><p>理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分：</p><table><tr><th width="10%">　</th><th width="70%">概念描述</th><th width="20%">举例</th></tr><tr><td>字符</td><td>人们使用的记号，抽象意义上的一个符号。</td><td>'1', '中', 'a', '$', '￥', ……</td></tr><tr><td>字节</td><td>计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。</td><td>0x01, 0x45, 0xFA, ……</td></tr><tr><td>ANSI字符串</td><td>在内存中，如果“字符”是以 <strong>ANSI 编码</strong>形式存在的，<strong>一个字符可能使用一个字节或多个字节</strong>来表示，那么我们称这种字符串为 <strong>ANSI 字符串</strong>或者<strong>多字节字符串</strong>。</td><td>"中文123"（占7字节）</td></tr><tr><td>UNICODE字符串</td><td>在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 <strong>UNICODE 字符串或者宽字节字符串</strong>。</td><td>L"中文123"（占10字节）</td></tr></table><p>由于不同 ANSI 编码所规定的标准是不相同的，因此，对于一个给定的<strong>多字节字符串</strong>，我们必须知道它采用的是哪一种编码规则，才能够知道它包含了哪些“字符”。而对于 <strong>UNICODE 字符串</strong>来说，不管在什么环境下，它所代表的“字符”内容总是不变的。</p><hr><h3 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h3><p>各个国家和地区所制定的不同 ANSI 编码标准中，都只规定了各自语言所需的“字符”。比如：汉字标准（GB2312）中没有规定韩国语字符怎样存储。这些 ANSI 编码标准所规定的内容包含两层含义：</p><ol><li>使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“<strong>字符集</strong>”。</li><li>规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“<strong>编码</strong>”。</li></ol><p>各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p><p>“<strong>UNICODE 字符集</strong>”包含了各种语言中使用到的所有“字符”。用来给 UNICODE 字符集编码的标准有很多种，比如：UTF-8, UTF-7, UTF-16, UnicodeLittle, UnicodeBig 等。</p><hr><h3 id="常用的编码简介"><a href="#常用的编码简介" class="headerlink" title="常用的编码简介"></a>常用的编码简介</h3><p>简单介绍一下常用的编码规则，为后边的章节做一个准备。在这里，我们根据编码规则的特点，把所有的编码分成三类：<br><table><tr><th width="15%">分类</th><th width="15%">编码标准</th><th width="70%">说明</th></tr><tr><td>单字节字符</td><td>ISO-8859-1</td><td>最简单的编码规则，每一个字节直接作为一个 UNICODE 字符。比如，[0xD6, 0xD0] 这两个字节，通过 iso-8859-1 转化为字符串时，将直接得到 [0x00D6, 0x00D0] 两个 UNICODE 字符，即 "ÖÐ"。反之，将 UNICODE 字符串通过 iso-8859-1 转化为字节串时，只能正常转化 0~255 范围的字符。</td></tr><tr><td>ANSI</td><td>GB2312,BIG5,Shift_JIS,ISO-8859-2 ……</td><td>把 UNICODE 字符串通过 ANSI 编码转化为“字节串”时，根据各自编码的规定，一个 UNICODE 字符可能转化成一个字节或多个字节。反之，将字节串转化成字符串时，也可能多个字节转化成一个字符。比如，[0xD6, 0xD0] 这两个字节，通过 GB2312 转化为字符串时，将得到 [0x4E2D] 一个字符，即 '中' 字。“ANSI 编码”的<strong>特点</strong>：1. 这些“ANSI 编码标准”都只能处理各自语言范围之内的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间的关系是人为规定的。</td></tr><tr><td>UNICODE</td><td>UTF-8,UTF-16, UnicodeBig ……</td><td>与“ANSI 编码”类似的，把字符串通过 UNICODE 编码转化成“字节串”时，一个 UNICODE 字符可能转化成一个字节或多个字节。<strong>与“ANSI 编码”不同的是</strong>：1. 这些“UNICODE 编码”能够处理所有的 UNICODE 字符。2. “UNICODE 字符”与“转换出来的字节”之间是可以通过计算得到的。</td></tr></table></p><p>我们实际上没有必要去深究每一种编码具体把某一个字符编码成了哪几个字节，我们<strong>只需要知道“编码”的概念就是把“字符”转化成“字节”就可以了</strong>。对于“UNICODE 编码”，由于它们是可以通过计算得到的，因此，在特殊的场合，我们可以去了解某一种“UNICODE 编码”是怎样的规则。</p><hr><p><br></p><h2 id="简介介绍区别"><a href="#简介介绍区别" class="headerlink" title="简介介绍区别"></a>简介介绍区别</h2><p><strong>位（bit）</strong>：计算机存储信息的最小单位，11001100是一个八位二进制数。</p><p><strong>字节（byte）</strong>：是一种计量单位，表示数据量多少，是计算机存储容量基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）</p><p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号，比如<code>1、2、3、A、B、C、~！·#￥%……—*（）——+、</code>等等。</p><p><strong>编码</strong>：把“字符”转化成“字节”</p><p>不同编码里，字符和字节的对应关系如下：</p><p>ASCII码：</p><ul><li>1个英文字母（不分大小写）= 1个字节的空间</li><li>1个中文汉字 = 2个字节的空间</li></ul><p>Unicode编码：</p><ul><li>1个英文字符 = 2个字节</li><li>英文标点 = 2个字节</li><li>1个中文（含繁体） = 2个字节</li><li>中文标点 = 2个字节</li></ul><p>UTF-8编码：</p><ul><li>1个英文字符 = 1个字节</li><li>英文标点 = 1个字节</li><li>1个中文（含繁体） = 3个字节</li><li>中文标点 = 3个字节</li></ul><p>UTF-16编码：</p><ul><li>一个英文字母字符或一个汉字字符存储都需要2个字节</li><li>Unicode扩展区的一些汉字存储需要4个字节</li></ul><p>UTF-32编码：</p><ul><li>世界上任何字符的存储都需要4个字节</li></ul><div class="note info"><p>unicode编码、UTF-8编码、UTF-16编码、UTF-32编码都是对Unicode字符集进行编码的实现方式</p></div><hr><h2 id="查看系统编码"><a href="#查看系统编码" class="headerlink" title="查看系统编码"></a>查看系统编码</h2><h3 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h3><blockquote><p><code>locale</code><br><strong>LANG=en_US.UTF-8</strong><br>LC_CTYPE=en_US.UTF-8<br>LC_NUMERIC=”en_US.UTF-8”<br>LC_TIME=”en_US.UTF-8”<br>LC_COLLATE=”en_US.UTF-8”<br>LC_MONETARY=”en_US.UTF-8”<br>LC_MESSAGES=”en_US.UTF-8”<br>LC_PAPER=”en_US.UTF-8”<br>LC_NAME=”en_US.UTF-8”<br>LC_ADDRESS=”en_US.UTF-8”<br>LC_TELEPHONE=”en_US.UTF-8”<br>LC_MEASUREMENT=”en_US.UTF-8”<br>LC_IDENTIFICATION=”en_US.UTF-8”<br>LC_ALL=</p></blockquote><p><strong>可以看出linux系统的默认编码是UTF-8</strong></p><h3 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h3><p>windows在dos环境下输入chcp：</p><blockquote><p><code>chcp</code><br>活动代码页: 936</p></blockquote><p><strong>活动代码页为：936，对应的编码格式为GBK</strong></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/u012156116/article/details/79923484" target="_blank" rel="noopener">字符与字节的区别</a></li><li><a href="http://www.regexlab.com/zh/encoding.htm" target="_blank" rel="noopener">字符，字节和编码</a></li><li><a href="https://www.cnblogs.com/yangxiaoqin/p/8460395.html" target="_blank" rel="noopener">位、字节、字符的区别</a></li><li><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">UTF-8和Unicode关系</a></li><li><a href="https://www.cnblogs.com/wpcockroach/p/3907324.html" target="_blank" rel="noopener">简单几句话总结Unicode，UTF-8和UTF-16</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单行命令嵌套</title>
      <link href="/posts/50164.html"/>
      <url>/posts/50164.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>单行命令嵌套，也就是一行命令使用另一行命令的结果，或者将命令的结果当做参数传给另一个命令，使用方法<code>command1 &lt;(command2)</code>.</p></div><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>将command2的结果作为command1的输入：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  command1 &lt;(command2)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>uniq命令去重常常需要先进行排序操作：</p><blockquote><p><code>uniq -c &lt;(sort uniq.txt)</code><br>1 i am test<br>2 i love test<br>1 i want go abroad<br>4 this is a test<br>1 those are good men<br>1 we are good men<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try</p></blockquote><p>当前上述也可以直接使用<strong>管道符<code>|</code></strong>来操作</p><p>但是如果是像<code>join</code>这种<strong>需要操作两个文件的</strong>，单纯地使用管道符就很难达到目的，<code>join</code>对指定列进行连接时也需要进行排序操作：</p><blockquote><p><code>cat test1.txt</code><br>aa 1 2<br>bb 2 3<br>cc 4 6<br>dd 3 3</p></blockquote><blockquote><p><code>cat test2.txt</code><br>aa 2 1<br>bb 8 2<br>ff 2 4<br>cc 4 4<br>dd 5 5</p></blockquote><p>管道符和命令嵌套合用：</p><blockquote><p><strong><code>sort -k 1,1 test2.txt |join -j 1 &lt;(sort -k 1,1 test1.txt) -</code></strong><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>当然也可以直接使用命令嵌套：</p><blockquote><p><strong><code>join -j 1 &lt;(sort -k 1,1 test1.txt) &lt;(sort -k 1,1 test2.txt)</code></strong><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cut-按列切分文件字段工具</title>
      <link href="/posts/64687.html"/>
      <url>/posts/64687.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文主要学习了Linux下对每一行文本按照给定的分隔符进行切割并按照指定的范围提取字段、字符或字节的命令<code>cut</code>，其主要选项包括：<code>-d</code>、<code>-f</code>、<code>--complement</code>、<code>-s</code>、<code>-c</code>、<code>-b</code>、<code>-n</code>和<code>--output-delimiter</code>。</p></div><a id="more"></a><h2 id="cut用法"><a href="#cut用法" class="headerlink" title="cut用法"></a>cut用法</h2><ul><li><code>cut</code>命令从文件的每一行剪切字节、字符或字段并将这些字节、字符或字段写至标准输出</li><li>如果不指定文件，<code>cut</code>命令将读取标准输入</li></ul><h3 id="cut命令格式"><a href="#cut命令格式" class="headerlink" title="cut命令格式"></a>cut命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  cut OPTION [FILE]</span><br></pre></td></tr></table></figure><hr><h3 id="cut-options说明"><a href="#cut-options说明" class="headerlink" title="cut options说明"></a>cut options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–bytes=LIST</td><td>以字节为单位进行分割，这些字节位置将忽略多字节字符边界，除非也指定了-n标志</td></tr><tr><td>-c</td><td>–characters=LIST</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>–delimiter=DELIM</td><td>自定义分隔符，默认为制表符tab</td></tr><tr><td>-f</td><td>–fields=LIST</td><td>与-d一同使用，显示指定字段的内容；也会打印不包含分隔符的行，除非指定了-s参数</td></tr><tr><td>-n</td><td></td><td>with -b: 取消分割多字节字符，仅和 -b 标志一起使用；如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出，否则该字符将被排除</td></tr><tr><td></td><td>–complement</td><td>补足被选择的字节、字符或字段</td></tr><tr><td>-s</td><td>–only-delimited</td><td>不打印没有包含分隔符的行，有利于去掉注释和标题</td></tr><tr><td></td><td>–output-delimiter=STRING</td><td>指定输出内容的分隔符</td></tr></tbody></table><hr><h3 id="cut指定字段、字符或字节范围的方法"><a href="#cut指定字段、字符或字节范围的方法" class="headerlink" title="cut指定字段、字符或字节范围的方法"></a>cut指定字段、字符或字节范围的方法</h3><p>指定字段、字符或字节范围有以下三种方法：</p><ul><li><strong>N-</strong>：获取<em>连续</em>范围，<strong>从第N个</strong>字节、字符、字段<strong>到结尾</strong>；</li><li><strong>N-M</strong>：获取<em>连续</em>范围，<strong>从第N个</strong>字节、字符、字段<strong>到第M个（包括M在内）</strong>字节、字符、字段；</li><li><strong>-M</strong>：获取<em>连续</em>范围，<strong>从第1个</strong>字节、字符、字段<strong>到第M个（包括M在内）</strong>字节、字符、字段</li><li><strong>N,M</strong>：获取<em>不连续</em>范围，得到<strong>第N个</strong>字节、字符、字段和<strong>第M个</strong>字节、字符、字段</li><li><strong>N,M,Z-P</strong>：获取<em>连续范围和不连续</em>范围，<strong>第N个</strong>字节、字符、字段、<strong>第M个</strong>字节、字符、字段以及<strong>从第Z个</strong>字节、字符、字段<strong>到第P个（包括P在内）</strong>字节、字符、字段</li></ul><div class="note info"><p>逗号(,)可以使用多个</p></div><hr><p><br></p><h2 id="cut用法实例"><a href="#cut用法实例" class="headerlink" title="cut用法实例"></a>cut用法实例</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><blockquote><p><code>cat cut.txt</code><br>No Name Mark Percent<br>01 tom 69 91<br>02 jack 71 87<br>03 alex 68 98</p></blockquote><h3 id="d-自定义分隔符"><a href="#d-自定义分隔符" class="headerlink" title="-d 自定义分隔符"></a>-d 自定义分隔符</h3><p><mark>默认-d是制表符tab，这个很关键，不是空白字符，同时自定义的分隔符必须是单个的字符，比如单个的空格，不能是两个或以上空格</mark></p><blockquote><p><code>cut -d &#39; &#39; -f 1 cut.txt</code><br>No<br>01<br>02<br>03</p></blockquote><blockquote><p><code>awk &#39;{print $1&quot;;&quot;$2&quot;;&quot;$3&quot;;&quot;$4}&#39; cut.txt |cut -d &#39;;&#39; -f 1</code><br>No<br>01<br>02<br>03</p></blockquote><hr><h3 id="f-提取指定字段内容"><a href="#f-提取指定字段内容" class="headerlink" title="-f 提取指定字段内容"></a>-f 提取指定字段内容</h3><p>选取<strong>单个filed</strong>如上面-d用法示例</p><p><strong>选取多个字段，直接将多个字段在-f选项后使用,分割即可：</strong></p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3 cut.txt</code></strong><br>No Mark<br>01 69<br>02 71<br>03 68</p></blockquote><p><strong>也可以使用<code>-</code>和<code>,</code>混用的方法：</strong></p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3-4 cut.txt</code></strong><br>No Mark Percent<br>01 69 91<br>02 71 87<br>03 68 98</p></blockquote><hr><h3 id="–complement-提取指定字段之外的内容"><a href="#–complement-提取指定字段之外的内容" class="headerlink" title="–complement 提取指定字段之外的内容"></a>–complement 提取指定字段之外的内容</h3><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,3 --complement cut.txt</code></strong><br>Name Percent<br>tom 91<br>jack 87<br>alex 98</p></blockquote><p><strong>这里得到的结果和上面单纯使用<code>-f</code>得到的结果可以说是互补的，因为<code>--complement</code>是提取指定字段之外的内容</strong></p><hr><h3 id="s-不打印没有包含分隔符的行"><a href="#s-不打印没有包含分隔符的行" class="headerlink" title="-s 不打印没有包含分隔符的行"></a>-s 不打印没有包含分隔符的行</h3><p>在cut.txt上增加一行文本，其分隔符和其他几行不同：</p><blockquote><p><code>cat cut.txt</code><br>#this-is-test<br>No Name Mark Percent<br>01 tom 69 91<br>02 jack 71 87<br>03 alex 68 98</p></blockquote><p><strong>默认情况，如果一行不包含分隔符，就会输出这一行</strong>：</p><blockquote><p>cut -d ‘ ‘ -f 1 cut.txt<br>#this-is-test<br>No<br>01<br>02<br>03</p></blockquote><p>为了防止上述情形出现，可以使用<code>-s</code>选项：</p><blockquote><p><code>cut -d &#39; &#39; -s -f 1 cut.txt</code><br>No<br>01<br>02<br>03</p></blockquote><p>可以发现，不包含空格作为分隔符的第一行就没有进行输出</p><hr><h3 id="c-提取指定字符范围的内容"><a href="#c-提取指定字符范围的内容" class="headerlink" title="-c 提取指定字符范围的内容"></a>-c 提取指定字符范围的内容</h3><blockquote><p><code>cat cut2.txt</code><br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz<br>abcdefghijklmnopqrstuvwxyz</p></blockquote><p><strong>指定连续范围：</strong></p><blockquote><p><code>cut -c -2 cut2.txt</code><br>ab<br>ab<br>ab<br>ab<br>ab</p></blockquote><blockquote><p><code>cut -c 5- cut2.txt</code><br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz<br>efghijklmnopqrstuvwxyz</p></blockquote><p><strong>指定不连续范围和连续范围（<code>,</code>和<code>-</code>混用）：</strong></p><blockquote><p><code>cut -c 1,3-5 cut2.txt</code><br>acde<br>acde<br>acde<br>acde<br>acde</p></blockquote><hr><h3 id="b-提取指定字符范围的内容"><a href="#b-提取指定字符范围的内容" class="headerlink" title="-b 提取指定字符范围的内容"></a>-b 提取指定字符范围的内容</h3><blockquote><p><code>cut -b 1-5 cut2.txt</code><br>abcde<br>abcde<br>abcde<br>abcde<br>abcde</p></blockquote><p><strong>这结果咋一看和前面的<code>-c</code>没有什么区别，这是因为操作对象都是英文字母，而在<code>ASCII码</code>和<code>UTF-8编码</code>中英文字母的字节和字符是相等的</strong>，具体的字节和字符的区别见<a href="http://showteeth.tech/posts/56690.html">这篇博客</a></p><p>由于我使用的<strong>vscode的默认编码方式为<code>utf-8</code></strong>，所以<strong>英文字母的字节和字符是相等的</strong>，而<strong>中文1个中文（含繁体） = 3个字节</strong>，为了凸显-b和-c的区别，下面采用中文进行测试：</p><blockquote><p><code>cat cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><blockquote><p><code>cut -b 1-3 cut3.txt</code> # cut -b <strong>1-2</strong> cut3.txt<strong>结果为空</strong>，因为需要三个字节才可以<br>星<br>星<br>星<br>星<br>星</p></blockquote><blockquote><p><code>cut -c 1-3 cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><div class="note info"><p>针对英文字符进行提取指定字符范围内容时，<code>-b</code>和<code>-c</code>选项没什么差别，因为在大部分编码方式中，英文字母的字节和字符是相等的，而针对中文就需要注意不同的编码方式对中文字符对应字节数的设置，当然<code>cut</code>命令还提供了了一个选项<code>-n</code>来解决上述<code>-b</code>可能遇到的问题</p></div><hr><h3 id="n-取消分割多字节字符"><a href="#n-取消分割多字节字符" class="headerlink" title="-n 取消分割多字节字符"></a>-n 取消分割多字节字符</h3><p><strong>该选项仅和 -b 选项一起使用</strong>，用来取消分割多字节字符</p><blockquote><p><code>cut -b 3 cut3.txt</code></p></blockquote><blockquote><p>cut -nb 3 cut3.txt<br>星<br>星<br>星<br>星<br>星</p></blockquote><blockquote><p><code>cut -nb 3,6,9 cut3.txt</code><br>星期一<br>星期二<br>星期三<br>星期四<br>星期五</p></blockquote><p>当<code>-nb</code>后面的数字为<code>3的整数倍（utf-8编码）</code>时就不会分割多字节字符，得到对应的字符，不过感觉这没啥大用处，一般都直接使用了<code>-c</code>参数来获取字符</p><hr><h3 id="–output-delimiter-STRING-指定输出内容是的分隔符"><a href="#–output-delimiter-STRING-指定输出内容是的分隔符" class="headerlink" title="–output-delimiter=STRING 指定输出内容是的分隔符"></a>–output-delimiter=STRING 指定输出内容是的分隔符</h3><blockquote><p><code>cut -d &#39; &#39; -f 1-3 --output-delimiter=$&#39;\t&#39; cut.txt</code><br>#this-is-test<br>No Name Mark<br>01 tom 69<br>02 jack 71<br>03 alex 68</p></blockquote><div class="note info"><p>注意这里指定输出分割符为tab的时候使用了<code>$&#39;\t&#39;</code>的方式，其中<code>$</code>和<code>单引号</code>都是必须的不能更改的，这个和<code>join</code>命令中指定分隔符的用法相同，具体原因查看<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/cut" target="_blank" rel="noopener">cut命令</a></li><li><a href="https://www.cnblogs.com/fulucky/p/8124858.html" target="_blank" rel="noopener">linux的cut命令</a></li><li><a href="https://www.cnblogs.com/longjshz/p/5792502.html" target="_blank" rel="noopener">Linux下的cut选取命令详解</a></li><li><a href="https://www.cnblogs.com/Hobbies/articles/4527447.html" target="_blank" rel="noopener">linux每日一命令–cut</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniq-去重</title>
      <link href="/posts/20744.html"/>
      <url>/posts/20744.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文学习了linux中准备对文本进行去重操作的<code>uniq</code>命令，其重要的参数包括<code>-c</code>、<code>-d</code>、<code>-D</code>、<code>-f</code>、<code>-s</code>、<code>-w</code>、<code>-i</code>、<code>-u</code>。这个命令通常与<a href="http://showteeth.tech/posts/61024.html">sort</a>一起使用。</p></div><a id="more"></a><h2 id="uniq用法"><a href="#uniq用法" class="headerlink" title="uniq用法"></a>uniq用法</h2><p>uniq命令是专门用来去除重复行的命令，使用时需要注意：</p><ul><li>对文本操作时，它一般会和<a href="http://showteeth.tech/posts/61024.html">sort命令</a>进行组合使用，因为<strong>uniq 不会检查重复的行，除非它们是相邻的</strong>，如果您想<strong>先对输入排序</strong>，使用<strong>sort -u</strong></li><li>对文本操作时，若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中<strong>字符前的空字符将被跳过</strong></li></ul><h3 id="uniq命令格式"><a href="#uniq命令格式" class="headerlink" title="uniq命令格式"></a>uniq命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  uniq [OPTION] [INPUT [OUTPUT]]</span><br><span class="line">  <span class="comment"># 从输入文件或者标准输入中过滤相邻的匹配行并将结果写入到输出文件或标准输出</span></span><br><span class="line">  <span class="comment"># 在不加options的情况下，匹配行将在首次出现处被合并</span></span><br></pre></td></tr></table></figure><hr><h3 id="uniq-options说明"><a href="#uniq-options说明" class="headerlink" title="uniq options说明"></a>uniq options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>–count</td><td>在每行前加上表示行出现次数</td></tr><tr><td>-d</td><td>–repeated</td><td>只输出重复的行，即出现次数&gt;=2的行，且只打印一次</td></tr><tr><td>-D</td><td>–all-repeated[=delimit-method]</td><td>仅显示重复的行，即出现次数&gt;=2的行，且打印重复行的所有行。其中delimit-method表示对重复行集合的分隔方式，有三种取值，分别为none（默认）、prepend和separate。</td></tr><tr><td>-u</td><td>–unique</td><td>只显示唯一的行，即出现次数等于1的行</td></tr><tr><td>-f</td><td>–skip-fields=N</td><td>忽略前N个<strong>字段</strong></td></tr><tr><td>-s</td><td>–skip-chars=N</td><td>和-f类似，不过-s是忽略前N个<strong>字符</strong></td></tr><tr><td>-w</td><td>–check-chars=N</td><td>指定每行要比较的前N个字符数</td></tr><tr><td>-i</td><td>–ignore-case</td><td>不区分大小写</td></tr><tr><td>-z</td><td>–zero-terminated</td><td>end lines with 0 byte, not newline</td></tr></tbody></table><hr><p><br></p><h2 id="uniq用法实例"><a href="#uniq用法实例" class="headerlink" title="uniq用法实例"></a>uniq用法实例</h2><h3 id="测试文本"><a href="#测试文本" class="headerlink" title="测试文本"></a>测试文本</h3><blockquote><p><code>cat uniq.txt</code><br>this is a test<br>this is a test<br><strong>this is a test</strong><br>i am test<br>i love test<br>i love test<br><strong>this is a test</strong><br>whom have a try<br>WhoM have a try<br>you have a try<br>i want go abroad<br>those are good men<br>we are good men</p></blockquote><h3 id="使用默认方式进行去重"><a href="#使用默认方式进行去重" class="headerlink" title="使用默认方式进行去重"></a>使用默认方式进行去重</h3><blockquote><p><code>uniq uniq.txt</code><br><em>this is a test</em><br>i am test<br>i love test<br><em>this is a test</em><br>whom have a try<br>WhoM have a try<br>you have a try<br>i want go abroad<br>those are good men<br>we are good men</p></blockquote><p>可以发现，<strong>uniq在计算重复的时候只会看相邻行</strong>，有一个<em>this is a test</em>没有和其他相邻，结果就被保留下来，当做非重复行</p><h3 id="c-显示行重复出现的次数"><a href="#c-显示行重复出现的次数" class="headerlink" title="-c 显示行重复出现的次数"></a>-c 显示行重复出现的次数</h3><blockquote><p><code>uniq -c uniq.txt</code><br>3 this is a test<br>1 i am test<br>2 i love test<br>1 this is a test<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try<br>1 i want go abroad<br>1 those are good men<br>1 we are good men</p></blockquote><p>依旧存在前面提到的问题，<strong>uniq在计算重复的时候只会看相邻行</strong>，和sort连用：</p><blockquote><p><code>sort uniq.txt |uniq -c</code><br>1 i am test<br>2 i love test<br>1 i want go abroad<br><strong>4 this is a test</strong><br>1 those are good men<br>1 we are good men<br>1 whom have a try<br>1 WhoM have a try<br>1 you have a try</p></blockquote><p>单纯使用sort命令去重的结果和上面是一样的，只是不能得到具体的重复数目，uniq功能更加强大：</p><blockquote><p><code>sort -u uniq.txt</code><br>i am test<br>i love test<br>i want go abroad<br>this is a test<br>those are good men<br>we are good men<br>whom have a try<br>WhoM have a try<br>you have a try</p></blockquote><hr><h3 id="d-只输出重复的行"><a href="#d-只输出重复的行" class="headerlink" title="-d 只输出重复的行"></a>-d 只输出重复的行</h3><blockquote><p><code>sort uniq.txt |uniq -dc</code><br>2 i love test<br>4 this is a test</p></blockquote><hr><h3 id="D-仅显示重复的行"><a href="#D-仅显示重复的行" class="headerlink" title="-D 仅显示重复的行"></a>-D 仅显示重复的行</h3><blockquote><p><code>sort uniq.txt |uniq -D</code><br>i love test<br>i love test<br>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><p>这个就<strong>不能和<code>-c</code>连用</strong>，因为重复行都显示出来了</p><h4 id="delimit-method-none"><a href="#delimit-method-none" class="headerlink" title="delimit-method=none"></a>delimit-method=none</h4><p>none表示不进行分隔，为<strong>默认选项</strong>，<code>uniq -D</code>等同于<code>uniq --all-repeated=none</code></p><p>注意使用<code>delimit-method</code>的时候就<strong>不能使用option的简写形式</strong>，<strong>必须使用完整参数</strong></p><hr><h4 id="delimit-method-prepend"><a href="#delimit-method-prepend" class="headerlink" title="delimit-method=prepend"></a>delimit-method=prepend</h4><p>prepend表示在每一个<strong>重复行集合前面</strong>插入一个空行</p><blockquote><p><strong><code>sort uniq.txt |uniq --all-repeated=prepend</code></strong></p><p>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><hr><h4 id="delimit-method-separate"><a href="#delimit-method-separate" class="headerlink" title="delimit-method=separate"></a>delimit-method=separate</h4><p>separate表示在每个<strong>重复行集合间</strong>插入一个空行</p><blockquote><p><strong><code>sort uniq.txt |uniq --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p></blockquote><hr><h3 id="f-忽略前N个字段"><a href="#f-忽略前N个字段" class="headerlink" title="-f 忽略前N个字段"></a>-f 忽略前N个字段</h3><blockquote><p><strong><code>sort uniq.txt |uniq -f 1 --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p><em>those</em> are good men<br><em>we</em> are good men</p><p><em>whom</em> have a try<br><em>WhoM</em> have a try</p></blockquote><blockquote><p><code>uniq -f 2 --all-repeated=separate uniq2.txt</code><br>this is a test<br>this are a test</p><p>my name is showteeth<br>your mmmm is showteeth</p></blockquote><div class="note info"><p><strong>-f是指定前N个field</strong>，而<strong>不是仅仅规定单独的field来进行判断是不是重复</strong>，如果<strong>仅仅想看某一列</strong>，可以<strong>将那一列放在第一个field</strong>，然后使用<code>-f</code>参数即可</p></div><hr><h3 id="s-忽略前N个字符"><a href="#s-忽略前N个字符" class="headerlink" title="-s 忽略前N个字符"></a>-s 忽略前N个字符</h3><blockquote><p><strong><code>sort uniq.txt |uniq -s 4 --all-repeated=separate</code></strong><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p><em>whom</em> have a try<br><em>WhoM</em> have a try<br><em>you</em> have a try</p></blockquote><hr><h3 id="w-指定每行要比较的前N个字符数"><a href="#w-指定每行要比较的前N个字符数" class="headerlink" title="-w 指定每行要比较的前N个字符数"></a>-w 指定每行要比较的前N个字符数</h3><blockquote><p><strong><code>sort uniq.txt |uniq -w 2 --all-repeated=separate</code></strong><br><em>i</em> am test<br><em>i</em> love test<br><em>i</em> love test<br><em>i</em> want go abroad</p><p><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>is is a test<br><em>th</em>ose are good men</p></blockquote><div class="note info"><p>注意这个参数和前面的<code>-f</code>、<code>-s</code>相同，都是<mark>前N个字段或者字符</mark>，而<strong>不是单纯地指定某一个字段或者字符</strong></p></div><hr><h3 id="i-不区分大小写"><a href="#i-不区分大小写" class="headerlink" title="-i 不区分大小写"></a>-i 不区分大小写</h3><blockquote><p><code>sort uniq.txt |uniq -i --all-repeated=separate</code><br>i love test<br>i love test</p><p>this is a test<br>this is a test<br>this is a test<br>this is a test</p><p>whom have a try<br>WhoM have a try</p></blockquote><hr><h3 id="u-只显示唯一的行"><a href="#u-只显示唯一的行" class="headerlink" title="-u 只显示唯一的行"></a>-u 只显示唯一的行</h3><blockquote><p><code>sort uniq.txt |uniq -u</code><br>i am test<br>i want go abroad<br>those are good men<br>we are good men<br><em>whom</em> have a try<br><em>WhoM</em> have a try<br>you have a try</p></blockquote><p>显示<strong>在忽略大小写情况下的唯一的行</strong>：</p><blockquote><p><code>sort uniq.txt |uniq -u -i</code><br>i am test<br>i want go abroad<br>those are good men<br>we are good men<br>you have a try</p></blockquote><p>上面的whom存在大小写区别的行就没排除在外</p><div class="note info"><p>不会显示去除了重复之后的保留的唯一重复行</p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/ftl1012/p/uniq.html" target="_blank" rel="noopener">Linux uniq命令详解</a></li><li><a href="https://blog.csdn.net/k346k346/article/details/70175532" target="_blank" rel="noopener">Linux命令——uniq命令</a></li><li><a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">实例详细说明linux下去除重复行命令uniq</a></li><li><a href="http://man.linuxde.net/uniq" target="_blank" rel="noopener">uniq命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>join-连接文本</title>
      <link href="/posts/5579.html"/>
      <url>/posts/5579.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文学习了可以按照指定<code>field</code>内容来将两个文件连接起来的<code>join</code>命令，其重要的参数包括<code>-1</code>、<code>-2</code>、<code>-j</code>、<code>-o</code>、<code>-t</code>、<code>-a</code>、<code>-e</code>、<code>-v</code>、<code>–nocheck-order</code>。</p></div><a id="more"></a><h2 id="join用法"><a href="#join用法" class="headerlink" title="join用法"></a>join用法</h2><ul><li><code>join</code>命令用来将<strong>两个文件</strong>中<strong>指定栏位内容相同的行连接起来</strong>，再输出到标准输出设备</li><li><strong>默认</strong>连接的栏位是有<strong>空白字符分隔</strong>的第一个栏位</li></ul><h3 id="join命令格式"><a href="#join命令格式" class="headerlink" title="join命令格式"></a>join命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  join [OPTION] FILE1 FILE2</span><br></pre></td></tr></table></figure><hr><h3 id="join-options说明"><a href="#join-options说明" class="headerlink" title="join options说明"></a>join options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>FILENUM</td><td>FILENUM 取1或者2，表示除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行，<strong>相当于指定左外链接还是右外连接</strong></td></tr><tr><td>-v</td><td>FILENUM</td><td>与-a相似 但只显示文件里没匹配上的行</td></tr><tr><td>-e</td><td>EMPTY</td><td>取值为字符串，将需要显示可是文件里不存在的域用此选项指定的字符取代</td></tr><tr><td>-i</td><td>–ignore-case</td><td>比较栏位内容时，忽略大小写的差异</td></tr><tr><td>-j</td><td>FIELD</td><td>-j指定一个域作为匹配字段，等同于 -1 FIELD -2 FIELD</td></tr><tr><td>-1</td><td>FIELD</td><td>以file1中FIELD字段进行匹配</td></tr><tr><td>-2</td><td>FIELD</td><td>以file2中FIELD字段进行匹配</td></tr><tr><td>-o</td><td>FORMAT</td><td>以指定格式输出</td></tr><tr><td>-t</td><td>CHAR</td><td>指定输入输出的分隔符，join 默认以空白字符做分隔符</td></tr><tr><td>–check-order</td><td></td><td>判断所有输入文件是不是已经排好序</td></tr><tr><td>–nocheck-order</td><td></td><td>不判断所有输入文件是不是已经排好序</td></tr></tbody></table><hr><p><br></p><h2 id="join用法实例"><a href="#join用法实例" class="headerlink" title="join用法实例"></a>join用法实例</h2><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><blockquote><p><code>cat test1.txt</code><br>aa 1 2<br>bb 2 3<br>cc 4 6<br>dd 3 3</p></blockquote><blockquote><p><code>cat test2.txt</code><br>aa 2 1<br>bb 8 2<br>ff 2 4<br>cc 4 4<br>dd 5 5</p></blockquote><h3 id="使用默认方式连接文件"><a href="#使用默认方式连接文件" class="headerlink" title="使用默认方式连接文件"></a>使用默认方式连接文件</h3><blockquote><p><code>join test1.txt test2.txt</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br><strong>join: file 2 is not in sorted order</strong></p></blockquote><p>上面的结果<strong>没有输出完整</strong>，同时输出了提示信息，<strong>file 2(test2.txt)没有进行没有进行排序</strong>，结合前面学习的<a href="http://showteeth.tech/posts/61024.html">sort</a>命令对其第一列进行排序并进行连接：</p><blockquote><p><code>sort -k 1,1 test2.txt |join test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>这次得到了完整的结果，同时注意在<strong>管道符</strong>后使用<code>-</code>表示<code>read standard input</code>也就是前面的sort的输出内容</p><div class="note info"><p>对某一列进行连接，就需要<strong>保证文件的这一列是排好序的</strong>，而不是只要对整个文件进行排序即可</p></div><hr><h3 id="–nocheck-order-检查是否排序"><a href="#–nocheck-order-检查是否排序" class="headerlink" title="–nocheck-order 检查是否排序"></a>–nocheck-order 检查是否排序</h3><p>针对上面出现的文件没有排序的问题，也可以在不报错的情况下直接输出部分结果，默认情况应该是<code>--check-order</code>的：</p><blockquote><p><code>join --nocheck-order test1.txt test2.txt</code><br>aa 1 2 2 1<br>bb 2 3 8 2</p></blockquote><p>这个感觉没啥意义，得不到正确结果</p><hr><h3 id="1、-2-指定连接列"><a href="#1、-2-指定连接列" class="headerlink" title="-1、-2 指定连接列"></a>-1、-2 指定连接列</h3><ul><li><code>-1</code>：指定<strong>文件1（写在前面的文件）</strong>中用于连接的列</li><li><code>-2</code>：指定<strong>文件2（写在后面的文件）</strong>中用于连接的列</li></ul><blockquote><p><code>sort -k 1,1 test2.txt |join -1 1 -2 1 test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>这个结果和上面默认的结果相同</p><p>让文件1的第2列与文件2的第3列进行连接（两列都是已经排好序的，不用再排序）：</p><blockquote><p><code>join -1 2 -2 3 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong></p></blockquote><p>可以发现<strong>文件1中的<code>cc 4 6</code>出现了两次</strong>，这是因为<em>文件2中在第3列上出现了2个4</em>，这2个4对应的行都和文件1中的对应的行进行连接，从而出现了2次</p><p>如果在文件1中增加一列重复的<code>cc 4 6</code>，得到如下结果：</p><blockquote><p><code>join -1 2 -2 3 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong><br><strong>4 cc 6 ff 2</strong><br><strong>4 cc 6 cc 4</strong></p></blockquote><p>即使<strong>存在重复，连接也会进行组合操作</strong>，得到2x2个结果</p><div class="note info"><ul><li><strong>默认情况下</strong>，对哪一列进行连接，输出的结果中，<strong>用于连接的那一列就会放在最前面</strong>，如果需要<strong>自定义输出内容和顺序</strong>，可以使用后面提到的<code>-o</code>参数进行修改</li><li>文件在指定的列上存在相同的，则会进行组合，比如各有2个相同的，则会得到2x2也就是4个结果（这里不管文件是否存在重复）</li></ul></div><hr><h3 id="j-指定用于连接的列"><a href="#j-指定用于连接的列" class="headerlink" title="-j 指定用于连接的列"></a>-j 指定用于连接的列</h3><p>如果两个文件中用于连接的列(field)相同，可以直接使用-j参数统一制定，不用使用上面那种-1、-2这种分别指定，较为简便：</p><blockquote><p><code>sort -k 1,1 test2.txt |join -j 1 test1.txt -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><hr><h3 id="o-自定义输出内容和顺序"><a href="#o-自定义输出内容和顺序" class="headerlink" title="-o 自定义输出内容和顺序"></a>-o 自定义输出内容和顺序</h3><p>输出文件1的第1列和第2列以及文件2的第1列和第3列：</p><blockquote><p><code>join -1 2 -2 3 -o 1.{1,2} 2.{1,3} test1.txt test2.txt</code><br>aa 1 aa 1<br>bb 2 bb 2<br>cc 4 ff 4<br>cc 4 cc 4</p></blockquote><div class="note info"><p>注意这里大括号<code>{}</code>的用法，详细请参考<a href="http://showteeth.tech/posts/55603.html">文章</a></p></div><hr><h3 id="t-指定分隔符"><a href="#t-指定分隔符" class="headerlink" title="-t 指定分隔符"></a>-t 指定分隔符</h3><blockquote><p><code>sort -k 1,1 test2.txt|awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39;|join -t $&#39;\t&#39; &lt;(awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$3}&#39; test1.txt) -</code><br>aa 1 2 2 1<br>bb 2 3 8 2<br>cc 4 6 4 4<br>dd 3 3 5 5</p></blockquote><p>指定<code>-t $&#39;\t&#39;</code>后，<strong>输出的内容也是以tab作为分隔的</strong>；使用<strong>默认的分隔符</strong>也能对上述案例进行连接，但是<strong>输出的是空格分隔</strong>，不管原始文件内是使用空格份额各还是tab分隔</p><div class="note info"><p>注意这里指定tab作为分隔符的方式，<strong><code>$&#39;\t&#39;</code>设定的原因（单引号+<code>$</code>）</strong>参考之前的<a href="http://showteeth.tech/posts/55603.html">这篇文章</a></p></div><hr><h3 id="a-指定外连接"><a href="#a-指定外连接" class="headerlink" title="-a 指定外连接"></a>-a 指定外连接</h3><p><strong>join默认进行的是内连接</strong>，也就是找到两个文件中在指定列上能够连接起来的行显示出现，但是要想显示共有的以及一个文件有一个文件没有的行就需要涉及到外连接，分为<strong>左外链接和右外连接和全外连接</strong>。<strong>左外链接指</strong>除了显示在指定列上能够连接起来的行外，还要把左边文件有，右边文件没有的行显示出来，右外连接类似，<strong>全外连接</strong>是将左边和右边的都显示出来，不管有没有连接上</p><p>设置<strong>左外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 **-a 1** test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br><strong>3 dd 3</strong></p></blockquote><p>设置<strong>右外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a 2 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br><strong>5 dd 5</strong></p></blockquote><p>设置<strong>全外连接</strong>：</p><blockquote><p><code>join -1 2 -2 3 -a1 -a2 test1.txt test2.txt</code><br>1 aa 2 aa 2<br>2 bb 3 bb 8<br>4 cc 6 ff 2<br>4 cc 6 cc 4<br>3 dd 3<br>5 dd 5</p></blockquote><p>这个顺序好像有点错乱，不管是文件1还是文件2的内容都靠左显示，使用-o指定输出内容：</p><blockquote><p><code>join -1 2 -2 3 -a1 -a2 -o 1.{1..3} 2.{1..3} test1.txt test2.txt</code><br>aa 1 2 aa 2 1<br>bb 2 3 bb 8 2<br>cc 4 6 ff 2 4<br>cc 4 6 cc 4 4<br>dd 3 3<br>dd 5 5</p></blockquote><p>发现文件1的内容靠左，文件2的内容前面会留有3个空格（文件1每一行的长度），刚好错开</p><hr><h3 id="e-指定替代字符"><a href="#e-指定替代字符" class="headerlink" title="-e 指定替代字符"></a>-e 指定替代字符</h3><p>在上面设置<strong>左外链接和右外连接</strong>的情况下，使用<code>-e</code>设置字符来填充某个文件没有的行的信息:</p><blockquote><p><code>join -1 2 -2 3 -a 2 -o 1.{1..3} 2.{1..3} -e &quot;empty&quot; test1.txt test2.txt</code><br>aa 1 2 aa 2 1<br>bb 2 3 bb 8 2<br>cc 4 6 ff 2 4<br>cc 4 6 cc 4 4<br>empty empty empty dd 5 5</p></blockquote><div class="note info"><p><strong>使用<code>-e</code>选项时必须也要设定<code>-o</code>选项</strong>，不然不能使用字符进行填充（可能是因为如-a参数使用中的不设置-o参数会使得结果显示出现问题，指定连接的列会在最左边显示，不能连接的行的内容不管是文件1还是文件2都会靠左显示，不能正确显示出内容和文件的对应关系）</p></div><hr><h3 id="v-显示未匹配行"><a href="#v-显示未匹配行" class="headerlink" title="-v 显示未匹配行"></a>-v 显示未匹配行</h3><blockquote><p><code>join -1 2 -2 3 -v 1 test1.txt test2.txt</code><br>3 dd 3</p></blockquote><blockquote><p><code>join -1 2 -2 3 -v 2 test1.txt test2.txt</code><br>5 dd 5</p></blockquote><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="指定多个列来进行链接"><a href="#指定多个列来进行链接" class="headerlink" title="指定多个列来进行链接"></a>指定多个列来进行链接</h3><p>因为join命令只支持单个field的连接，而指定多个field作为连接列又非常常用，所以这里给出了几种解决方法：</p><p><strong>思路一：既然join命令只支持单个field的连接，那就把多个field转化为单个field进行连接即可</strong><br>将上述test1.txt的第1列和第2列与test2.txt的第1列和第3列进行连接：</p><blockquote><p><strong><code>join -j 1 &lt;(awk &#39;{print $1&quot;-&quot;$2&quot;\t&quot;$0}&#39; test1.txt |sort -k 1,1) &lt;(awk &#39;{print $1&quot;-&quot;$3&quot;\t&quot;$0}&#39; test2.txt |sort -k 1,1)</code></strong><br><em>aa-1</em> aa 1 2 aa 2 1<br><em>bb-2</em> bb 2 3 bb 8 2<br><em>cc-4</em> cc 4 6 cc 4 4</p></blockquote><p>控制输出的时候可以使用<code>-o</code>参数对输出进行控制，来决定输出的内容</p><p><strong>思路二：通过处理其中一个文件得到匹配的fileds，然后利用<code>grep</code>命令在另一个文件中查找这个fields，得到最终的结果</strong><br>提取test1.txt的第1列和第2列作为pattern_file，在test2.txt文件中对齐进行查找：</p><blockquote><p><strong><code>cut -d &#39; &#39; -f 1,2 test1.txt |grep -f - &lt;(awk &#39;{print $1,$3,$2}&#39; test2.txt )</code></strong><br>aa 1 2<br>bb 2 8<br>cc 4 4</p></blockquote><p>注意这个<strong>只能得到test2.txt中的内容</strong>，而且还<strong>必须得调整列的位置</strong>，使<strong>test2.txt中需要和pattern_file进行连接的列进行对应（pattern_file是第1、2列，那就需要把test2.txt的第3列换到第2列的位置，和pattern_file进行对应）</strong>，不然不能查找结果。</p><p>还可以使用<code>awk</code>命令进行操作，具体参考<a href="https://stackoverflow.com/questions/2619562/joining-multiple-fields-in-text-files-on-unix" target="_blank" rel="noopener">这个链接</a></p><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.runoob.com/linux/linux-comm-join.html" target="_blank" rel="noopener">Linux join命令</a></li><li><a href="https://www.cnblogs.com/agilework/archive/2012/04/18/2454877.html" target="_blank" rel="noopener">linux下join命令的用法</a></li><li><a href="https://blog.csdn.net/K346K346/article/details/80237368" target="_blank" rel="noopener">Linux命令——join命令</a></li><li><a href="https://www.jianshu.com/p/97006b505cd6" target="_blank" rel="noopener">linux: join</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort-排序</title>
      <link href="/posts/61024.html"/>
      <url>/posts/61024.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>本文学习sort-对文件进行排序，主要包括了sort用法(命令格式、参数说明)、用法实例(各种参数：<code>-u</code>、<code>-n</code>、<code>-r</code>、<code>-k</code>、<code>-t</code>、<code>-o</code>、<code>-c</code>、<code>h</code>和<code>g</code>等的实例讲解)并在最后给出了几个非常常用的实战示例。</p></div><a id="more"></a><h2 id="sort用法"><a href="#sort用法" class="headerlink" title="sort用法"></a>sort用法</h2><ul><li><code>sort</code>命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</li><li><code>sort</code>命令既可以从<strong>特定的文件</strong>，也可以<strong>从stdin中获取输入</strong></li></ul><h3 id="sort命令格式"><a href="#sort命令格式" class="headerlink" title="sort命令格式"></a>sort命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">  sort [OPTION] [FILE]</span><br></pre></td></tr></table></figure><hr><h3 id="sort-options说明"><a href="#sort-options说明" class="headerlink" title="sort options说明"></a>sort options说明</h3><style>table th:first-of-type{width:15%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:60%}</style><table><thead><tr><th>参数</th><th>完整参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>–ignore-leading-blanks</td><td>忽略每行前面开始出的空格字符</td></tr><tr><td>-d</td><td>–dictionary-order</td><td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符</td></tr><tr><td>-f</td><td>–ignore-case</td><td>排序时，将小写字母视为大写字母，亦即忽略大小写</td></tr><tr><td>-g</td><td>–general-numeric-sort</td><td>按通用数值排序，支持科学计数法</td></tr><tr><td>-i</td><td>–ignore-nonprinting</td><td>排序时，除了040至176之间的ASCII字符外，忽略其他的字符</td></tr><tr><td>-M</td><td>–month-sort</td><td>将前面3个字母依照月份的缩写进行排序 (unknown) &lt; ‘JAN’ &lt; … &lt; ‘DEC’</td></tr><tr><td>-m</td><td>–merge</td><td>将几个排序号的文件进行合并</td></tr><tr><td>-h</td><td>–human-numeric-sort</td><td>使用易读性数字(例如： 2K 1G)</td></tr><tr><td>-n</td><td>–numeric-sort</td><td>依照数值的大小排序</td></tr><tr><td>-o</td><td>–output=FILE</td><td>将排序后的结果存入指定的文件</td></tr><tr><td>-r</td><td>–reverse</td><td>降序排序，默认为升序</td></tr><tr><td>-t</td><td>–field-separator=SEP</td><td>指定排序时所用的栏位分隔字符</td></tr><tr><td>-k</td><td>–key=POS1[,POS2]</td><td>排序从POS1开始，若指定POS2，则POS2结束，否则以pos1排序</td></tr><tr><td>-u</td><td>–unique</td><td>去除重复的行</td></tr><tr><td>-c</td><td>–check</td><td>检查文件是否已经按照顺序排序</td></tr></tbody></table><hr><p><br></p><h2 id="sort用法实例"><a href="#sort用法实例" class="headerlink" title="sort用法实例"></a>sort用法实例</h2><h3 id="使用默认方式对文件进行排序"><a href="#使用默认方式对文件进行排序" class="headerlink" title="使用默认方式对文件进行排序"></a>使用默认方式对文件进行排序</h3><p><code>sort</code> 命令将以<strong>默认的方式</strong>将文本文件的<strong>第一列以ASCII码的次序排列</strong>，并将结果<strong>输出到标准输出</strong><br>测试文件default.txt:</p><blockquote><p><code>cat default.txt</code><br>test 30<br>Hello 95<br>Linux 25</p></blockquote><blockquote><p><code>sort default.txt</code><br>Hello 95<br>Linux 25<br>test 30</p></blockquote><hr><h3 id="u-去除重复行"><a href="#u-去除重复行" class="headerlink" title="-u 去除重复行"></a>-u 去除重复行</h3><blockquote><p><code>cat uniq.txt</code><br>test 30<br>Hello 95<br>Linux 25<br>Linux 25<br>Linux 20</p></blockquote><p>文件中存在两行完全相同的信息，这将其去除:</p><blockquote><p><code>sort -u uniq.txt</code><br>Hello 95<br>Linux 20<br>Linux 25<br>test 30</p></blockquote><p><strong>会考察所有的列是否相同来进行去除，只有第一列相同是不会进行去除的</strong></p><h3 id="n-对数字进行排序"><a href="#n-对数字进行排序" class="headerlink" title="-n 对数字进行排序"></a>-n 对数字进行排序</h3><blockquote><p><code>cat num.txt</code><br>10<br>20<br>30<br>110<br>120<br>210</p></blockquote><p>sort默认会<strong>把所有列当成字符来进行排序</strong>，因为1小于3，所以110小于20：</p><blockquote><p><code>sort num.txt</code><br>10<br>110<br>120<br>20<br>210<br>30</p></blockquote><p>为了避免上述情况，需要使用<code>-n</code>选项，声明是数字进行排序，而不是字符：</p><blockquote><p><code>sort -n num.txt</code><br>10<br>20<br>30<br>110<br>120<br>210</p></blockquote><hr><h3 id="r-降序排列"><a href="#r-降序排列" class="headerlink" title="-r 降序排列"></a>-r 降序排列</h3><p>从上面的输出结果可以看出：sort默认进行的是升序排列，为了能够得到降序排列的结果，需要使用参数<code>-r</code>：</p><blockquote><p><code>sort -n -r num.txt</code> 等价于 <code>sort -nr num.txt</code><br>210<br>120<br>110<br>30<br>20<br>10</p></blockquote><hr><h3 id="k-指定排序开始-和结束-的位置"><a href="#k-指定排序开始-和结束-的位置" class="headerlink" title="-k 指定排序开始(和结束)的位置"></a>-k 指定排序开始(和结束)的位置</h3><h4 id="k选项的语法格式"><a href="#k选项的语法格式" class="headerlink" title="-k选项的语法格式"></a>-k选项的语法格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FStart.CStart Modifie,FEnd.CEnd Modifier   <span class="comment"># 详细划分</span></span><br><span class="line">-------Start--------,-------End--------    <span class="comment"># 整体划分</span></span><br><span class="line">FStart.CStart 选项  ,  FEnd.CEnd 选项       <span class="comment"># 详细划分解读</span></span><br></pre></td></tr></table></figure><ul><li>这个语法格式可以被其中的逗号<code>,</code>分为两大部分，<strong>Start部分</strong>和<strong>End部分</strong></li><li><code>Start</code>部分也<strong>由两部分组成</strong>:<ul><li><strong>Modifier</strong>部分是<strong>选项部分</strong>，可以用到b、d、f、i、n 或 r。</li><li><code>FStart.CStart</code>，其中<code>FStart</code>就是表示使用的<strong>域</strong>而<code>CStart</code>则表示<strong>在FStart域中</strong>从<strong>第几个字符开始算“排序首字符”</strong>。<code>C.Start</code>也是可以省略的，<u>省略的话就表示从本域的开头部分开始</u></li></ul></li><li>同理，在<code>End</code>部分中，你可以设定<code>FEnd.CEnd</code>，如果你<strong>省略.CEnd，则表示结尾到“域尾”，即<u>本域</u>的最后一个字符</strong>。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”</li><li><mark>如果直接省略了<code>End</code>部分，则会直接从指定的开始位置到一行的结束进行排序</mark></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>从<strong>公司英文名称（第一个域）</strong>的<strong>第二个字母</strong>开始进行排序：</p><blockquote><p><code>sort -k 1.2 salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p><strong>结果解读：</strong>使用了<code>-k 1.2</code>，表示对<strong>第一个域</strong>的<strong>第二个字符开始到本域的最后一个字符为止</strong>的字符串进行排序，结果是baidu因为第二个字母是a而名列榜首，sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三，guge只能排在第四了。</p><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序：</p><blockquote><p><code>sort -k 1.2 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>可以发现这个与预期的结果并不一致，和没有按照员工工资进行降序排序的结果相同，所以命令肯定存在问题。首先，<code>-k 3nr</code>没有起作用，相当于只是用前面的<code>-k 1.2</code>就可以达到效果，事实上也正是如此，因为<code>-k 1.2</code>表示对<strong>第一个域</strong>的<strong>第二个字符开始到本域的最后一个字符为止</strong>的字符串进行排序，按照上一个示例的分析，可以将这些结果分开，所以就不存在上面所说的<code>如果相同的按照员工工资进行降序排序</code>，因此后面的排序也就没有了意义。随后基于此我做了一个测试，在最后一行增加”google 110 4500”，这样就存在了<code>-k 1.2</code>不能讲所有的分开是现象，依旧使用上面的命令进行排序：</p><blockquote><p><code>sort -k 1.2 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 4500<br>google 110 5000<br>guge 50 3000</p></blockquote><p>发现上述并没有按照我预定的<code>-k 1.2</code>不能讲所有的分开，然后就按照第二个指定的<code>-k 3nr</code>进行排序，然后我去google上搜索相关问题发现<a href="https://unix.stackexchange.com/questions/78925/how-to-sort-by-multiple-columns?rq=1" target="_blank" rel="noopener">有个回答</a>说<mark>对多行进行排序时需要指定sort keys的开始和结束，如果没指定结束就会在一直到一行的末尾结束（可能是因为第一个key是主key），不会考虑后面继续设置的key</mark>，基于此，做了测试：</p><blockquote><p><code>sort -k 1.2,1 -k 3nr salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>google 110 4500<br>guge 50 3000</p></blockquote><p>最终得到了正确的结果，使用<code>-k 1.2,1</code>是<strong>省略.CEnd，则表示结尾到“域尾”</strong>，同时吸取上面的教训，为了严谨期间，虽然第3列是最后一列，也直接加上sort key的结束位置：<code>sort -k 1.2,1 -k 3,3nr salary.txt</code>，结果和上面相同</p><div class="note info"><ul><li><code>-k 3nr</code>：表示在第3列上进行按数字的降序进行排列</li><li><strong>对不同的列进行不同的排序方式时尤其需要指定sort key的结束为止，如果不指定，会以第一个key设置的为主，忽略后续key的设置，这个在对不同的列分别依据ascii和数字进行排序中非常常见</strong></li></ul></div><hr><h3 id="t-指定field分隔符"><a href="#t-指定field分隔符" class="headerlink" title="-t 指定field分隔符"></a>-t 指定field分隔符</h3><p>sort使用<code>-t</code>参数来<strong>指定分隔符</strong>，<strong>默认的分隔符为空格(包括空格和tab)</strong>:</p><blockquote><p><code>cat sep.txt</code><br>aaa:eee<br>ccc:eee<br>ddd:ddd<br>bbb:ccc<br>eee:bbb<br>eee:aaa</p></blockquote><p>以<code>:</code>为分隔符，对<strong>第二列</strong>进行排序：</p><blockquote><p><code>sort -t : -k 2 sep.txt</code><br>eee:aaa<br>eee:bbb<br>bbb:ccc<br>ddd:ddd<br>aaa:eee<br>ccc:eee</p></blockquote><p>当然也可以<strong>指定列来判断重复与否</strong>，并进行删除：</p><blockquote><p><code>sort -t : -uk 2 sep.txt</code><br>eee:aaa<br>eee:bbb<br>bbb:ccc<br>ddd:ddd<br>aaa:eee</p></blockquote><hr><h3 id="o-输出到文件"><a href="#o-输出到文件" class="headerlink" title="-o 输出到文件"></a>-o 输出到文件</h3><p>输出到文件也可以使用重定向<code>&gt;</code>进行操作，但是<strong>如果使用重定向想要写入原文件，这个时候不但写不进去，还把原文件清空了</strong></p><p>这个问题可以很好的使用<code>-o</code>参数解决，<code>-o</code>后面接原文件，即<strong>可将重排序的结果写入原文件</strong></p><h3 id="c-检查文件是否已经排序"><a href="#c-检查文件是否已经排序" class="headerlink" title="-c 检查文件是否已经排序"></a>-c 检查文件是否已经排序</h3><p><strong>如果乱序，则输出第一个乱序的行的相关信息</strong></p><blockquote><p><code>sort -c uniq.txt</code><br>sort: uniq.txt:2: disorder: Hello 95</p></blockquote><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="对多行进行排序并进行去重"><a href="#对多行进行排序并进行去重" class="headerlink" title="对多行进行排序并进行去重"></a>对多行进行排序并进行去重</h3><p>示例文件：含有google共有三行，其中有两行1、2列是完全相同的，有一行是第一列是相同的：</p><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br><strong>google 110 5000</strong><br>guge 50 3000<br><strong>google 110 4500</strong><br><strong>google 120 4500</strong></p></blockquote><p><strong>对1、2列进行排序并删除在这两列上的重复行：</strong></p><blockquote><p><code>sort -uk 1,2 salary.txt</code><br>baidu 100 5000<br><strong>google 110 5000</strong><br><strong>google 120 4500</strong><br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>可以发现达到了目的</p><p>只针对第一列来看：</p><blockquote><p><code>sort -uk 1 salary.txt</code><br>baidu 100 5000<br>google 110 4500<br>google 110 5000<br>google 120 4500<br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>这个并没有达到目的，和前面提到的<code>-k</code>选项中提到的一样，<strong>必须要指定终止位置</strong>，<strong>不然会比较整个行</strong>，这样最终结果是没有重复的，如果在上面文件中<strong>故意加一行重复的</strong>，还果真如此，比较的是整个行：</p><blockquote><p><code>cat salary.txt</code><br>baidu 100 5000<br>sohu 100 4500<br>google 110 5000<br>guge 50 3000<br>google 110 4500<br><strong>google 120 4500</strong><br><strong>google 120 4500</strong></p></blockquote><blockquote><p><code>sort -uk 1 salary.txt</code><br>baidu 100 5000<br>google 110 4500<br>google 110 5000<br><strong>google 120 4500</strong><br>guge 50 3000<br>sohu 100 4500</p></blockquote><p>增加终止位置，得到预期结果：</p><blockquote><p><code>sort -uk 1,1 salary.txt</code><br>baidu 100 5000<br>google 110 5000<br>guge 50 3000<br>sohu 100 4500</p></blockquote><p><strong>第一列相同的行中进行去重复保留的是原始文件中第一个出现的</strong></p><hr><h3 id="对文件大小进行排序"><a href="#对文件大小进行排序" class="headerlink" title="对文件大小进行排序"></a>对文件大小进行排序</h3><p><code>-h</code>：排序时使用易读性数字(例如： 2K 1G)</p><p><strong>统计目录下子目录的大小，并按大小进行降序排列：</strong></p><blockquote><p><code>du -h |sort -hr</code> # <code>du -h</code>统计目录下子目录的大小<br>2.6G ./test2<br>2.6G . # 整个目录大小<br>6.8M ./test<br>4.0K ./test3</p></blockquote><hr><h3 id="系统进程内存占用排序"><a href="#系统进程内存占用排序" class="headerlink" title="系统进程内存占用排序"></a>系统进程内存占用排序</h3><p><code>-g</code>：按通用数值排序，支持科学计数法</p><blockquote><p><code>ps aux |less -S</code><br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p></blockquote><blockquote><p><code>ps aux|sort -gr -k 4|head -n 5|awk &#39;{print $2,$3,$4}&#39;</code><br>10742 0.0 0.8<br>3916 99.5 0.7<br>110870 99.5 0.4<br>131268 99.5 0.3<br>66967 0.0 0.0</p></blockquote><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html" target="_blank" rel="noopener">linux sort 命令详解</a></li><li><a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort命令</a></li><li><a href="http://www.runoob.com/linux/linux-comm-sort.html" target="_blank" rel="noopener">Linux sort命令</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串截取方法</title>
      <link href="/posts/43811.html"/>
      <url>/posts/43811.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>字符串截取在平常的工作中非常常用，这里总结常用的截取方法，便于查阅和温习，主要包括：<code>${}</code>的<strong>字符串截取</strong>和<strong>正则匹配</strong>、<code>cut</code>命令的<code>-c</code>参数、<code>awk</code>的<code>substr</code>函数和<code>FS</code>内置参数以及<code>expr</code>的<code>substr</code>表达式</p></div><a id="more"></a><h2 id="使用-进行截取"><a href="#使用-进行截取" class="headerlink" title="使用${}进行截取"></a>使用<code>${}</code>进行截取</h2><p><code>${}</code>是一种非常常用的linux特殊符号，一般来说共有五种不同的功能，具体的是哪五种功能，之前已经写过<a href="http://showteeth.tech/posts/55603.html">一篇博文</a>，这里就不赘述了，这里主要用示例的形式讲解其中与字符串截取相关的两种功能：<strong>字符串截取</strong>和<strong>正则匹配替换</strong>。</p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><ul><li><code>${str:offest}</code>：从<strong>字符串尾端（左侧）下标offset(含)开始截取到末尾</strong>的子串</li><li><code>${str:offest:length}</code>：从<strong>字符串尾端（左侧）下标offset(含)开始向后截取长度为length</strong>的子串，长度超出不报错</li><li><code>${str:0-offset:length}</code>：从<strong>字符串尾端（右侧）下标offset(含)开始以及<u>向后</u>截取长度为length</strong>的子串</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"http://showteeth.tech/posts/55603.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取从下标5到字符串结尾的子串，注意下标是从0开始的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从下标5开始截取长度为10的子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5:10&#125;</span></span><br><span class="line"><span class="comment"># 字符长度超出不会报错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:5:40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右数下标15开始截取长度为10的子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:0-15:10&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="http://showteeth.tech/posts/55603.html">http://showteeth.tech/posts/55603.html</a><br>ttp://showteeth.tech/posts/55603.html<br>//showteeth.tech/posts/55603.html</p></blockquote><blockquote><p>//showteet<br>//showteeth.tech/posts/55603.html</p></blockquote><blockquote><p>osts/55603</p></blockquote><div class="note info"><ul><li><code>下标（offset）</code>从0开始 <strong>（注意与使用<code>awk</code>的<code>substr</code>函数进行字符截取不同）</strong></li><li><code>${str:0-offset:length}</code>是从字串右侧开始数坐标，然后和正常的一样，向后截取长度</li></ul></div><hr><h3 id="正则匹配替换"><a href="#正则匹配替换" class="headerlink" title="正则匹配替换"></a>正则匹配替换</h3><ul><li><code>${\#parameter}</code>：获取变量长度</li><li><code>${parameter#word}</code>、<code>${parameter##word}</code>：<strong>从头开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>#</code>为<strong>最短</strong>匹配，<code>##</code>为<strong>最长</strong>匹配</li><li><code>${parameter%word}</code>、<code>${parameter%%word}</code>：<strong>从尾开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>%</code>为<strong>最短</strong>匹配，<code>%%</code>为<strong>最长</strong>匹配</li><li><code>${parameter/pattern/string}</code>、<code>${parameter//pattern/string}</code>：使用string替换pattern，<code>/</code>表示<strong>只替换一次</strong>；<code>//</code>表示<strong>全部替换</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取变量长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边开始删除第一次出现子字符串即其左边字符，保留右边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str#*/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边开始删除最后一次出现子字符串即其左边字符，保留符号最右边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str##*/&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始删除第一次出现子字符串即其右边字符，保留左边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%/*&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右边开始删除最后一次出现子字符串即其右边字符，保留最左边字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%%/*&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换，只替换第一次出现的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str/\//%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换，所有匹配的都进行替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str//\//%&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>38</p></blockquote><blockquote><p>/showteeth.tech/posts/55603.html<br>55603.html</p></blockquote><blockquote><p><a href="http://showteeth.tech/posts">http://showteeth.tech/posts</a><br>http:</p></blockquote><blockquote><p>http:%/showteeth.tech/posts/55603.html<br>http:%%showteeth.tech%posts%55603.html</p></blockquote><div class="note info"><ul><li><code>#</code>在<code>%</code>的左边，所以<code>#</code>是从左向右删除字符，保留右边子串，而<code>%</code>是从右向左删除字符，保留左边字符</li><li>一个<code>#</code>或<code>%</code>是匹配并删除第一次出现的pattern，而<code>##</code>或<code>%%</code>是匹配并删除最后一次出现的pattern（相当于贪婪匹配）</li><li>上述的<code>parameter</code>都是可以不用引用的，因为<code>${var}</code>本来就和<code>$var</code>是一个意思</li></ul></div><hr><p><br></p><h2 id="使用awk进行截取"><a href="#使用awk进行截取" class="headerlink" title="使用awk进行截取"></a>使用awk进行截取</h2><p>使用<code>awk</code>中的<code>substr</code>函数，<code>substr()</code>用于从字符串中<strong>指定位置</strong>和<strong>长度</strong>截取出子串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usage：</span><br><span class="line">  substr(s, i [, n])</span><br><span class="line">    s 待截取的字符串</span><br><span class="line">    i 索引位置，从1开始，按照字符计算、非字节</span><br><span class="line">    n 要截取的长度，默认或者填写长度超出字符尾，则截取到字符尾</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |awk <span class="string">'&#123;print substr($str,5,10)&#125;'</span></span><br></pre></td></tr></table></figure><blockquote><p>://showtee</p></blockquote><p>也可以使用<code>awk</code>指定<strong>输入分割符</strong>的方式截取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |awk -v FS=<span class="string">"/"</span> <span class="string">'&#123; print $3 &#125;'</span></span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>注意这里与使用<code>${}</code>进行字符串截取不同，这里字符的<strong>索引开始为1</strong>，而上面<code>${}</code>索引<strong>开始位置为0</strong></li><li><code>FS</code>是awk内置的系统变量，表示<strong>域分隔符</strong>，默认为空白字符（空格），使用时需要结合<code>-v</code>来传递参数</li></ul></div><hr><p><br></p><h2 id="使用cut进行截取"><a href="#使用cut进行截取" class="headerlink" title="使用cut进行截取"></a>使用cut进行截取</h2><p><strong>直接通过范围得到子串：</strong><br><code>cut</code>命令的<code>-c</code>参数：<strong>仅显示行中指定范围的字符</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |cut -c 2-6</span><br></pre></td></tr></table></figure><p></p><blockquote><p>ttp:/</p></blockquote><div class="note warning"><ul><li>注意这里与使用<code>${}</code>进行字符串截取<strong>不同</strong>，与使用<code>awk</code>的<code>substr</code>函数进行字符截取<strong>相同</strong>，这里字符的<strong>索引开始为1</strong>，而上面<code>${}</code>索引<strong>开始位置为0</strong></li><li><code>cut</code> <code>-c</code> 后面接的是<code>index的起始和终止范围</code>，而不是像前面的<code>awk</code>和<code>${}</code>一样是<strong>index</strong>和<strong>length</strong>的组合</li></ul></div><p><strong>利用cut按分割符分割来得到子串：</strong></p><ul><li><code>cut</code>命令的<code>-d</code>参数：<strong>指定字段的分隔符，默认的字段分隔符为”TAB”</strong></li><li><code>cut</code>命令的<code>-f</code>参数：<strong>指定需要显示的字段</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> |cut -d / -f 3</span><br></pre></td></tr></table></figure><blockquote><p>showteeth.tech</p></blockquote><div class="note info"><p><code>cut</code>命令的<code>-d</code>和<code>-f</code>参数合用主要用于得到被<strong>已知分隔符</strong>分割的<strong>一块子串</strong></p></div><hr><p><br></p><h2 id="使用expr进行截取"><a href="#使用expr进行截取" class="headerlink" title="使用expr进行截取"></a>使用expr进行截取</h2><p><code>expr</code>用于计算表达式变量的值，其中有表达式：<code>substr String StartPosition Length</code>，表示<strong>从String的StartPosition开始截取Length的子串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr substr <span class="variable">$str</span> 2 6</span><br></pre></td></tr></table></figure><blockquote><p>ttp://</p></blockquote><div class="note info"><ul><li>注意每个单词之间都有空格，不带空格会出错</li><li>索引位置也是从1开始，和<code>awk</code>的<code>substr</code>函数、<code>cut</code>命令的<code>-c</code>参数相同，和<code>${}</code>不同</li></ul></div><hr><p><br></p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><div class="note info"><ul><li>一般最为常用的是<code>${}</code>的<strong>正则匹配替换</strong>方法(保留字符串最左或者最右的子串)，同时awk和cut使用的也非常多</li><li>使用需要提供索引位置的方法时需要注意索引的开始位置：<ul><li><code>awk</code>的<code>substr</code>函数、<code>cut</code>命令的<code>-c</code>参数还有expr的substr表达式索引都是从1开始</li><li><code>${str:offest:length}</code>方法的索引则开始于0</li></ul></li><li><code>${}</code>、<code>cut</code>命令的<code>-c</code>参数以及<code>awk</code>的<code>FS</code>内置参数都是用于通过<strong>已知分割符</strong>得到相应的<strong>一块子串</strong>，而不是具体地通过索引位置</li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数计算、浮点计算并保留小数</title>
      <link href="/posts/28430.html"/>
      <url>/posts/28430.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在linux中进行整数计算、浮点计算并保留小数，主要包括：使用<code>expr</code>进行<strong>整数运算</strong>以及<strong>简单的字符串操作</strong>、<code>let</code>、<code>(( ))</code>、<code>$(())与declare -i</code>、<code>$[]</code>进行<strong>整数运算</strong>、使用<code>bc</code>进行<strong>浮点运算</strong>和<strong>进制转换</strong>以及使用<code>awk</code>进行<strong>浮点运算</strong>。</p></div><a id="more"></a><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>shell中默认的操作都是字符操作，如果想要进行数学运算，简单的shell操作可能得不到预期的结果：</p><blockquote><p>a=1<br>b=1<br>echo $a + $b<br><strong>1 + 1</strong></p></blockquote><p>所以为了执行数学计算就需要有专门的命令来进行操作，以下介绍几种常用的命令和特殊符号。</p><h3 id="expr-整数或字符串表达式计算"><a href="#expr-整数或字符串表达式计算" class="headerlink" title="expr 整数或字符串表达式计算"></a>expr 整数或字符串表达式计算</h3><p><code>expr</code>语法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 表达式</span><br></pre></td></tr></table></figure><p></p><p>表达式说明:</p><ul><li><strong><code>expr</code>只能用于整数计算</strong></li><li>用<strong>空格隔开</strong>每个项</li><li><strong>用<code>/</code>(反斜杠)放在shell特定的字符</strong>前面</li><li><strong>对包含空格和其他特殊字符的字符串要用引号括起来</strong></li></ul><h4 id="整数计算"><a href="#整数计算" class="headerlink" title="整数计算"></a>整数计算</h4><table><tr><th width="10%">类别</th><th width="20%">语法</th><th width="70%">说明</th></tr><tr><td rowspan="2">四则运算</td><td>expr1 \| expr2</td><td>如果 expr1 不是零或 null 则传回 expr1，否则传回 expr2</td></tr><tr><td>expr1 \&amp; expr2</td><td>如果 expr1 及 expr2 都不为零或 null，则传回 expr1，否则传回 0</td></tr><tr><td rowspan="5">四则运算</td><td>expr1 + expr2</td><td>传回 expr1 加 expr2 后的值</td></tr><tr><td>expr1 - expr2</td><td>传回 expr1 减 expr2 后的值</td></tr><tr><td>expr1\* expr2</td><td>传回 expr1 乘 expr2 后的值</td></tr><tr><td>expr1 / expr2</td><td>传回 expr1 除 expr2 后的整数位值（小数位直接丢弃，不四舍五入）</td></tr><tr><td>expr1 % expr2</td><td>传回 expr1 除 expr2 的余数</td></tr><tr><td rowspan="6">大小判断</td><td>expr1 \&gt; expr2</td><td>如果 expr1 大于 expr2 则传回 1，否则传回 0。如果 expr1 及 expr2 都是数字，则是以数字大小判断，否则是以文字判断。以下皆同</td></tr><tr><td>expr1 \&lt; expr2</td><td>如果 expr1 小于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 = expr2</td><td>如果 expr1 等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 != expr2</td><td>如果 expr1 不等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 \&gt;= expr2</td><td>如果 expr1 大于或等于 expr2 则传回 1，否则传回 0</td></tr><tr><td>expr1 \&lt;= expr2</td><td>如果 expr1 小于或等于 expr2 则传回 1，否则传回 0</td></tr></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">expr 2+3</span><br><span class="line">expr 2 + 3</span><br><span class="line"></span><br><span class="line">expr 2 * 3</span><br><span class="line">expr 2 \* 3</span><br><span class="line"></span><br><span class="line">expr 5 / 3</span><br><span class="line"></span><br><span class="line">expr 2 % 3</span><br></pre></td></tr></table></figure><blockquote><p>2+3 # 2和3之间没有空格，直接被输出，没有进行计算<br>5 # 输出正确结果</p></blockquote><blockquote><p>expr: syntax error # 因为没有对<code>*</code>进行转义，所以报错<br>6 # 转义后输出正确结果</p></blockquote><blockquote><p>1 # 直接去掉余数，不进行四舍五入</p></blockquote><blockquote><p>2 # 输出余数</p></blockquote><hr><h4 id="字符串表达式计算"><a href="#字符串表达式计算" class="headerlink" title="字符串表达式计算"></a>字符串表达式计算</h4><p>因为<code>expr</code>用于字符串计算并不常见，所以这里不仔细了解，只了解几个个人感觉比较常用的，需要了解的可以参考<a href="https://blog.csdn.net/guhong5153/article/details/6542995" target="_blank" rel="noopener">这篇博客</a></p><p><strong>计算字串长度(length)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr length <span class="string">"this is a test"</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>14</p></blockquote><p><strong>截取子串(substr)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># substr String StartPosition Length</span></span><br><span class="line">expr substr <span class="string">"this is a test"</span> 3 5</span><br></pre></td></tr></table></figure><p></p><blockquote><p>is is</p></blockquote><p><strong>匹配第一个字符(串)出现的位置(index)：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr index <span class="string">"this is a test"</span> is</span><br></pre></td></tr></table></figure><p></p><blockquote><p>3</p></blockquote><div class="note info"><p>注意四则运算中的<code>*</code>需要进行转义处理，同时还有条件判断中的<code>|</code> <code>&amp;</code>和大小判断中的<code>&gt;</code> <code>&lt;</code>都需要进行转义处理</p></div><hr><p><br></p><h3 id="let-运算并赋值"><a href="#let-运算并赋值" class="headerlink" title="let-运算并赋值"></a>let-运算并赋值</h3><p><code>let</code> 命令是 BASH 中用于计算的工具，用于<strong>执行一个或多个表达式</strong>，变量计算中<strong>不要加上 <code>$</code> 来表示变量(否则会报错)</strong>。如果表达式中<strong>包含了空格或其他特殊字符，则必须引起来</strong>(可以看出来与<code>expr</code>命令每个都需要空格隔开不同，<code>let</code>命令最好不要有空格)。</p><ul><li>自加操作：<code>let no++</code></li><li>自减操作：<code>let no--</code></li><li>简写形式 <code>let no+=10</code>，<code>let no-=20</code>，分别等同于 <code>let no=no+10</code>，<code>let no=no-20</code></li></ul><blockquote><p>let var +=1 //存在空格但是不带引号会报错<br>-bash: let: +=1: syntax error: operand expected (error token is “+=1”)</p></blockquote><blockquote><p>let “var +=1” //增加引号即可<br>echo $var<br>2</p></blockquote><blockquote><p>let $var+=1 //加上 <code>$</code> 来表示变量会报错<br>-bash: let: 2+=1: attempted assignment to non-variable (error token is “+=1”)</p></blockquote><blockquote><p>let var+=1 //不加 <code>$</code> 正常<br>echo $var<br>3</p></blockquote><blockquote><p>a=1<br>b=2<br>let c=a+b //赋值操作<br>echo $c<br>3</p></blockquote><hr><h3 id="执行计算"><a href="#执行计算" class="headerlink" title="((  )) 执行计算"></a>(( )) 执行计算</h3><p>和linux<code>let</code>指令相似，比<code>let</code>命令好的方面是<strong>可以在括号内加空格，不会报错</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自加操作</span></span><br><span class="line">a=5;b=7</span><br><span class="line">((a--));<span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用在for循环中</span></span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;5;i++));<span class="keyword">do</span> <span class="built_in">echo</span>  <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">((c=b+1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加空格</span></span><br><span class="line">(( c = b + 1 ))</span><br></pre></td></tr></table></figure><hr><h3 id="与declare-i-整数运算"><a href="#与declare-i-整数运算" class="headerlink" title="$(())与declare -i 整数运算"></a>$(())与declare -i 整数运算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i total=<span class="variable">$firstnu</span>*<span class="variable">$secnu</span></span><br><span class="line">total=$((<span class="variable">$firstnu</span>*<span class="variable">$secnu</span>))</span><br></pre></td></tr></table></figure><p>区别就是<strong>小方括号内可以加上空格符，也是合法的写法</strong>，而declare -i 不可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2*3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2* 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错</span></span><br><span class="line">total=$((2*3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取</span></span><br><span class="line">a=5;b=7;c=2</span><br><span class="line"><span class="built_in">echo</span> $((a+b*c))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>+<span class="variable">$b</span>*<span class="variable">$c</span>))</span><br></pre></td></tr></table></figure><p><code>declare -i</code>加空格报错：</p><blockquote><p>bash: declare: 2<em>: syntax error: operand expected (error token is “</em>“)</p></blockquote><p><code>$(())</code>在等号左右加空格报错：</p><blockquote><p>bash: 6: command not found</p></blockquote><p><strong><code>$(())</code>进制转化：将其他进制转成十进制数显示出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值</span></span><br><span class="line"><span class="built_in">echo</span> $((N<span class="comment">#xx))</span></span><br></pre></td></tr></table></figure><hr><h3 id="运算"><a href="#运算" class="headerlink" title="$[]运算"></a>$[]运算</h3><blockquote><p>a=1<br><code>echo $[a+1]</code><br>2</p></blockquote><blockquote><p>echo $[c=a+1]<br>2 //会先输出运算的结果<br>echo $c<br>2 //也会赋值</p></blockquote><hr><p><br></p><h2 id="浮点计算并保留小数"><a href="#浮点计算并保留小数" class="headerlink" title="浮点计算并保留小数"></a>浮点计算并保留小数</h2><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p><code>bc</code>命令是任意精度计算器语言，通常在linux下当计算器用, 它类似基本的计算器, 使用这个计算器可以做基本的数学运算。</p><p>常用的运算：</p><ul><li>+ 加法</li><li>- 减法</li><li>* 乘法</li><li>/ 除法</li><li>^ 指数</li><li>% 余数</li><li>sqrt 开方</li></ul><p>语法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc (选项) (参数)</span><br></pre></td></tr></table></figure><p></p><p>在shell中直接输入<code>bc</code>即可进入交互式界面，类似于没有图形界面的计算器，输入表达式得到结果<br>具体用法不详细讲解，可以参考<a href="https://www.cnblogs.com/lovevivi/p/4359296.html" target="_blank" rel="noopener">这篇博客</a></p><p><strong>实际进行浮点运算常用的方法是通过管道符：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage:</span><br><span class="line">  <span class="built_in">echo</span>  <span class="string">'scale=num; expression'</span>|bc</span><br><span class="line">    num：表示保留的小数点后位数</span><br><span class="line">    expression：表示计算表达式</span><br></pre></td></tr></table></figure><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;2/3'</span> |bc</span><br></pre></td></tr></table></figure><blockquote><p>.66</p></blockquote><p><strong>可以发现上述输出结果中并没有0(因为结果小于0)，如果想要显示可以使用</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2;a=2/3;if( length(a) == scale(a) ) print 0;print a ,"\n"'</span> |bc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>0.66</p></blockquote><p><strong>bc还能用来进行进制的转换：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usage：</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"obase=base;ibase=base;num"</span> | bc</span><br><span class="line">    obase:输出数字的进制，默认值为10</span><br><span class="line">    ibase:输入数字的进制，默认值为10</span><br><span class="line">    num:进行进制转换的数字</span><br><span class="line">    obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的</span><br></pre></td></tr></table></figure><p></p><p>obase如果放在ibase后可能会出错：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># obase一定要放在ibase前，因为ibase设置后，后面的数字都是以ibase的进制来换算的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"obase=10;ibase=2;110"</span> | bc</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ibase=2;obase=10;110"</span> | bc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>6<br>110</p></blockquote><hr><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk中的计算，默认支持浮点运算：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> |awk <span class="string">'&#123;print 2/3&#125;'</span></span><br></pre></td></tr></table></figure><p></p><p><strong>格式化输出：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line"><span class="built_in">echo</span> |awk <span class="string">'&#123;printf("%.2f\n" , 3/50)&#125;'</span></span><br></pre></td></tr></table></figure><p></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中特殊符号用法</title>
      <link href="/posts/55603.html"/>
      <url>/posts/55603.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>Linux常见特殊符号作用，包括<code>#</code>、<code>~</code>、<code>~+</code>、<code>~-</code>、<code>;</code>、<code>;;</code>、<code>.</code>、<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>`</code>、<code>,</code>、<code>/</code>、<code>\</code>、<code>|</code>、<code>!</code>、<code>:</code>、<code>*</code>、<code>**</code>、<code>$</code>、<code>$$</code>、<code>?</code>、<code>${}</code>、<code>$*</code>、<code>$@</code>、<code>$#</code>、<code>$(())</code>、<code>(())</code>、<code>()</code>、<code>{}</code>、<code>[]</code>、<code>[[]]</code>、<code>||</code> 、<code>&amp;&amp;</code>、<code>\&lt;...\&gt;</code>和文件操作符以及重定向。</p></div><a id="more"></a><h2 id="号-注释"><a href="#号-注释" class="headerlink" title="#号-注释"></a>#号-注释</h2><p>在脚本中 <code>#</code>也常出现在一行的<strong>开头</strong>,或者位于<strong>完整指令之后</strong>,这类情况表示符号后边是<strong>注解文字,不会被执行</strong>，如果被<u>用在指令</u>中，或者<u>引号、双引号括住</u>的话，或者<u>在反斜线的后面</u>，那他就变成<strong>一般符号</strong>，不具上述的特殊功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#this line is comments</span></span><br></pre></td></tr></table></figure><hr><h2 id="home目录"><a href="#home目录" class="headerlink" title="~ home目录"></a>~ home目录</h2><p>代表使用者的<strong>home目录</strong>：<code>cd ~</code>表示进入home目录；也可以<strong>直接在符号后加上某帐户</strong>的名称：<code>cd ~user</code>表示进入这个user的home目录；或者<strong>当成是路径的一部份</strong>：<code>~/bin</code></p><p><code>~+</code>表示当前的工作目录</p><p><code>~-</code>表示上一个工作目录，这个在目录切换很好用啊，<code>cd ~-</code>直接<strong>进入上一次cd之前的目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">echo</span> ~+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入上一次cd之前的目录</span></span><br><span class="line"><span class="built_in">cd</span> ~-</span><br><span class="line"><span class="comment"># 进入上一次cd之前目录下的test目录</span></span><br><span class="line"><span class="built_in">cd</span> ~-/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure><hr><h2 id="分号"><a href="#分号" class="headerlink" title="; 分号"></a>; 分号</h2><p><strong>连续命令之间起到连接作用</strong>，命令之间没有依赖，<mark>不管上一条命令是否执行成功，分号后的命令都会执行</mark>。</p><hr><h2 id="连续分号"><a href="#连续分号" class="headerlink" title=";;连续分号"></a>;;连续分号</h2><p>专用在<code>case（多分支条件判断）</code>的选项，担任 <code>Terminator</code> 的角色</p><hr><h2 id="点号-dot"><a href="#点号-dot" class="headerlink" title=". 点号(dot)"></a>. 点号(dot)</h2><ul><li>在<strong>目录</strong>中：一个<code>.</code>表示当前目录，两个<code>..</code>表示上层目录</li><li>在<strong>文件命名</strong>中：以<code>.</code>开头的文件表明该文件是<strong>隐藏文件</strong>，需要使用<code>ls -a</code>才能看到</li><li>在<strong>正则表达式</strong>中：一个逗号表示一个任意字符（换行符 \n 之外），如果想要匹配<code>.</code>，需要使用转义<code>\.</code>。</li></ul><h2 id="‘’-单引号"><a href="#‘’-单引号" class="headerlink" title="‘’ 单引号"></a>‘’ 单引号</h2><p>被单引号用括住的内容，将被视为<code>单一字串</code>。在<mark>引号内的代表变量的<code>$</code>符号，没有作用</mark>，也就是说，他被视为一般符号处理，<strong>防止任何变量替换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$test'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">'s/hello/$test/'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p><code>$</code>test</p></blockquote><blockquote><p><code>$</code>test WORLD</p></blockquote><hr><h2 id="“”-双引号"><a href="#“”-双引号" class="headerlink" title="“” 双引号"></a>“” 双引号</h2><p>被双引号用括住的内容，将被视为<code>单一字串</code>。它<mark>防止通配符扩展，但允许变量替换</mark>，这点与单引号的处理方式不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$test</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">"s/hello/<span class="variable">$test</span>/"</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>hello</p></blockquote><blockquote><p>HELLO WORLD</p></blockquote><hr><h2 id="反引号"><a href="#反引号" class="headerlink" title="`` 反引号"></a>`` 反引号</h2><p>在前面的<strong>单双引号，括住的是字串</strong>，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用反引号来做，被<strong>反引号括住的内容是可以执行的</strong>。</p><p>与反引号相同可以用来进行命令执行的还有<code>$()</code>，两者的区别在于<mark>如果是使用反引号执行命令在进行命令嵌套时会比较麻烦，而使用<code>$()</code>进行命令的嵌套会比较简单</mark>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$test</span>`</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$test</span>)</span><br></pre></td></tr></table></figure><p>命令嵌套：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$test</span>))</span><br></pre></td></tr></table></figure><p>不等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$test</span>``</span><br></pre></td></tr></table></figure><p><strong>反引号遇到第一个匹配的反引号就结束，之间的内容会当做命令运行，可以使用转义字符<code>\</code>解决嵌套问题</strong></p><p>等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> \`<span class="built_in">echo</span> <span class="variable">$test</span>\``</span><br></pre></td></tr></table></figure><div class="note info"><p>所以还是使用<code>$()</code>来得到命令执行结果更为简便，但是不需要嵌套时两者差不多</p></div><hr><h2 id="逗号"><a href="#逗号" class="headerlink" title=", 逗号"></a>, 逗号</h2><p>这个符号常运用在运算当中当做<strong>区隔用途</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1,$2,$3,$4&#125;'</span> filename</span><br></pre></td></tr></table></figure><hr><h2 id="斜线"><a href="#斜线" class="headerlink" title="/ 斜线"></a>/ 斜线</h2><ul><li>在路径表示时，<strong>分割不同级别的目录</strong></li><li>单一的斜线<code>/</code>表示根目录，和上面的<code>~</code>表示的家目录不同</li><li>在四则运算中，代表<strong>除法的符号</strong></li></ul><h2 id="反斜线"><a href="#反斜线" class="headerlink" title="\ 反斜线"></a>\ 反斜线</h2><p>在交互模式下的escape字元，有几个作用</p><ul><li>放在<strong>指令前</strong>，有<strong>取消 aliases</strong>的作用；</li><li>放在<strong>特殊符号</strong>前，则该<strong>特殊符号的作用消失（转义）</strong>；</li><li>放在<strong>指令的最末端</strong>，表示指令<strong>连接下一行</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l</span></span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消ll代表ls -l，在ll之前防止反斜线表示暂时取消别名的功能，将 ll 指令还原</span></span><br><span class="line">\ll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转义，取消变量应用</span></span><br><span class="line">\<span class="variable">$test</span></span><br></pre></td></tr></table></figure><p>最终ll结果输出：</p><blockquote><p>bash: ll: command not found</p></blockquote><hr><h2 id="管道符"><a href="#管道符" class="headerlink" title="| 管道符"></a>| 管道符</h2><p><strong>连结上个指令的标准输出，做为下个指令的标准输入</strong>。</p><hr><h2 id="惊叹号"><a href="#惊叹号" class="headerlink" title="! 惊叹号"></a>! 惊叹号</h2><ul><li>通常它代表反逻辑的作用，如<code>!=</code>表示不等于</li><li>匹配模式取反：<code>sed -n &#39;1,2!p&#39; test.txt</code>表示打印第1、2行之外的行；<code>ls a[!0-9]</code>表示显示除了a0, a1 …. a9 这几个文件的其他文件</li><li>在历史命令（history）中：<ul><li><code>!number</code> ：表示执行history中<strong>第number条命令</strong></li><li><code>!!</code>：表示执行<strong>上一条命令</strong></li><li><code>!command</code>：执行<strong>最近一条command为开头的命令</strong></li><li><code>!$</code>：表示<strong>最近一条命令的第二个字符信息</strong></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line">!!</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>mkdir test<br>mkdir: cannot create directory `test’: File exists</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line">!$</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>test</p></blockquote><hr><h2 id="冒号"><a href="#冒号" class="headerlink" title=": 冒号"></a>: 冒号</h2><ul><li>在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0</li><li><code>: &gt; f</code>：相当于<code>cat/dev/null&gt;f</code>，这样不仅写法简短了，而且执行效率也好上许多</li><li><code>: ${HOSTNAME?} ${USER?} ${MAIL?}</code>这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 <code>test</code> 或<code>if</code>这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。<strong>(这个具体还没试验过)</strong></li><li>添加环境变量时需要使用<code>:</code>分割，比如<code>PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla</code></li></ul><h2 id="星号"><a href="#星号" class="headerlink" title="* 星号"></a>* 星号</h2><ul><li>在<code>文件名扩展(Filename expansion)</code>上，用来代表<strong>0到无穷多个任意字符</strong></li><li>在<code>正则表达式（Regular Expressions）</code>中，代表<strong>重复零个到无穷多个的<u>前一个字符</u></strong>，而代销<strong>0到无穷多个任意字符</strong>是使用<code>.*</code>。</li><li>在运算时，它则代表 “乘法”</li></ul><div class="note info"><p><code>*</code>在不同地方不同的用法需要注意，尤其是代表<strong>0到无穷多个任意字符</strong>、<strong>重复零个到无穷多个的<u>前一个字符</u></strong>这方面。</p></div><hr><h2 id="次方运算"><a href="#次方运算" class="headerlink" title="** 次方运算"></a>** 次方运算</h2><p>两个星号在运算时代表 “次方” 的意思。</p><hr><h2 id="和"><a href="#和" class="headerlink" title="$和$$"></a>$和$$</h2><ul><li>引用变量的前导符号，如<code>var=&quot;test&quot; echo $var</code></li><li>在正则表达式里被定义为<code>行的最末端 (end-of-line)</code>，这个常用在<code>grep</code>、<code>sed</code>、<code>awk</code> 以及 <code>vim(vi)</code> 当中</li><li>在bash中<code>$</code>本身也是个变量。代表的是<strong>目前这个shell的进程代码</strong>，即所谓的<code>PID（Process ID）</code><ul><li><code>$$</code> Shell本身的PID（ProcessID）</li><li><code>$!</code> Shell最后运行的后台Process的PID</li><li><code>$?</code> 最后运行的命令的结束代码（返回值），一般指令程序倘若执行成功，其回传值为 0，失败为 1。</li><li>其他参考<a href="https://www.cnblogs.com/chjbbs/p/6393935.html" target="_blank" rel="noopener">该博客</a></li></ul></li><li><mark><code>$</code>后接引号（单双引号），单引号可以使引号内的内容被特殊对待：会将某些反斜线序列(如<code>\n</code>，<code>\t</code>，<code>\&quot;</code>，<code>\&#39;</code>等)继续转义(<code>\t-&gt;tab</code>;<code>\n-&gt;换行</code>)，而不认为它是字面符号(如果没有<code>$</code>符号，单引号会强制将string翻译为字面符号，包括反斜线)；而双引号则没有上述效果，<code>$&quot;string&quot;</code>和<code>&quot;string&quot;</code>是完全等价的，使用<code>$&quot;&quot;</code>只是为了保证本地化</mark></li></ul><blockquote><p><code>echo &#39;a\nb&#39;</code><br>a\nb</p></blockquote><p>上述结果<strong>并没有和预期的一样在a、b之间进行换行</strong>，这是因为<strong>单引号中的<code>\n</code>被看成了字面意思，就是反斜线加上n</strong>，而不是特殊的换行的意思</p><p>如果在前面加上<code>$</code>：</p><blockquote><p><code>echo $&#39;a\nb&#39;</code><br>a<br>b</p></blockquote><p>这个结果和预期的一样，<strong>因为<code>$</code>将<code>\n</code>翻译成了换行</strong>，而不是单纯的反斜线加上n，这个在join命令指定分隔符时会用到，具体参考介绍<a href="http://showteeth.tech/posts/5579.html">join用法的文章</a></p><p>如果将上述单引号转换为双引号：</p><blockquote><p><code>echo $&quot;a\nb&quot;</code><br>a\nb</p></blockquote><p>发现在使用<strong>双引号</strong>的情况下，得到的结果<strong>和没使用<code>$</code>是一样的</strong>，这和前面说的<code>$&quot;string&quot;</code>和<code>&quot;string&quot;</code>是完全等价的是相符的。</p><p><strong>常见的需要注意使用<code>$</code>和单引号的转义字符包括</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\a    alert (bell)</span><br><span class="line">\b    backspace</span><br><span class="line">\e</span><br><span class="line">\E    an escape character</span><br><span class="line">\f    form feed</span><br><span class="line">\n    new line</span><br><span class="line">\r    carriage <span class="built_in">return</span></span><br><span class="line">\t    horizontal tab</span><br><span class="line">\v    vertical tab</span><br><span class="line">\\    backslash</span><br><span class="line">\<span class="string">'    single quote</span></span><br><span class="line"><span class="string">\"    double quote</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="问号"><a href="#问号" class="headerlink" title="? 问号"></a>? 问号</h2><ul><li>在<code>文件名扩展(Filename expansion)</code>上扮演的角色是<code>匹配一个任意的字符</code>，但不包含空字符，注意是<strong>一个字符，不能是0个也不能是两个</strong>，注意和正则表达式的用法区分。比如：<code>ls a?c.txt</code>可以得到abc.txt和amc.txt 但是不能得到abbc.txt，也不能得到ac.txt</li><li>在正则表达式式中，<code>?</code>表示匹配<strong>前面的字符0次或1次</strong>，<strong>不是任意字符</strong>，注意和文件名拓展的区分。<mark>同时在正则表达式中还可以用来表示非贪婪匹配</mark></li><li>在<code>bash</code>中，这个变量是<strong>上一个执行的命令所回传的值</strong>。当我们执行某些命令时，这些命令都会回传一个执行后的代码，一般说，<u>如果成功执行该命令，则会回传一个0值</u>，如果执行过程<u>发生错误</u>，就会回传错误代码，一般<u>以非0的数值来替代</u></li></ul><hr><h2 id="变量的正规表达式"><a href="#变量的正规表达式" class="headerlink" title="${} 变量的正规表达式"></a>${} 变量的正规表达式</h2><p>一般情况下，<code>$var</code>与<code>${var}</code>是没有区别的，但是用<code>${}</code>会<strong>比较精确的界定变量名称的范围</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个明确说明了var才是变量</span></span><br><span class="line"><span class="variable">$&#123;var&#125;</span>_suffix</span><br><span class="line"></span><br><span class="line"><span class="variable">$var_suffix</span></span><br></pre></td></tr></table></figure><h3 id="参数替换"><a href="#参数替换" class="headerlink" title="${} 参数替换"></a>${} 参数替换</h3><ul><li><code>${var_name}</code> 等价于<code>$var_name</code>（通常用这种简写方式）</li><li><code>$(var:-default)</code> 和 <code>$(var-default)</code><ul><li><code>$(var:-default)</code>：当<strong>var为空或未定义</strong>时<strong>整个表达式的值为default</strong></li><li><code>$(var-default)</code>：当且<strong>仅当var未定义</strong>时<strong>整个表达式的值为default</strong></li></ul></li><li><code>$(var:=default)</code> 和 <code>$(var=default)</code><ul><li><code>$(var:=default)</code>：当var<strong>为空或未定义</strong>时<strong>整个表达式的值为default</strong>，<strong>并且将var的值设置为default</strong></li><li><code>$(var=default)</code>：当且<strong>仅当var未定义</strong>时<strong>整个表达式的值为default</strong>，<strong>并且将var的值设置为default</strong></li></ul></li><li><code>$(var:?default)</code> 和 <code>$(var?message)</code><ul><li><code>$(var:?message)</code>：当var<strong>为空或未定义</strong>时，<strong>打印错误信息</strong>，信息内容为message表示的值</li><li><code>$(var?message)</code>：当且<strong>仅当var未定义</strong>时，<strong>打印错误信息</strong>，信息内容为message表示的值</li></ul></li><li><code>$(var:+default)</code> 和 <code>$(var+default)</code><ul><li><code>$(var:+default)</code>：当<strong>var已定义且不为空</strong>时整个表达式的值为default</li><li><code>$(var+default)</code>：当<strong>var已定义时</strong>整个表达式的值为default(<strong>不管var是否是空</strong>)</li></ul></li></ul><hr><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="${} 字符串截取"></a>${} 字符串截取</h3><ul><li><code>${str:offest}</code>：从下标<strong>offset(含)开始截取到末尾</strong>的子串</li><li><code>${str:offest:length}</code>：从<strong>下标offset(含)开始向后截取长度为length</strong>的子串，长度超出不报错</li><li><code>${str:offest:index}</code>：</li></ul><hr><h3 id="变量匹配"><a href="#变量匹配" class="headerlink" title="${} 变量匹配"></a>${} 变量匹配</h3><p><code>${!prefix*}</code>、<code>${!prefix@}</code>：将带有<strong>前缀为prefix的变量名打印</strong>出来</p><hr><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="${} 数组操作"></a>${} 数组操作</h3><ul><li><code>${!name[@]}</code>、<code>${!name[*]}</code>：将<strong>数组name的所有<code>下标</code></strong>返回，如果<em>变量name不是数组则返回0,不存在则空</em></li><li><code>${name[@]}</code>、<code>${name[*]}</code>：将<strong>数组name的所有<code>元素</code></strong>返回，如果<em>变量name不是数组则返回name的值,不存在则空</em></li><li><code>${\#name[@]}</code>、<code>${\#name[*]}</code>：返回<strong>数组元素总个数</strong></li><li><code>${name[index]}</code>：将<strong>数组name的index处的<code>元素</code></strong>返回，如果<em>变量name不是数组且index为0时返回name的值</em>，<em>变量或索引index处的元素不存在则返回空</em></li><li><code>${\#name[index]}</code>：返回<strong>数组name的index处的<code>元素长度</code></strong></li><li><code>name[index]=xyz</code>：<strong>数组name的index处的元素重新<code>赋值</code></strong></li></ul><div class="note info"><p>上面的<code>${\#name[@]}</code>中对<code>#</code>做了转义处理，不然博客可能报错，参考<a href="https://github.com/hexojs/hexo/issues/2904" target="_blank" rel="noopener">github issue</a>，正常情况下使用时不用加<code>\</code>进行转义。</p></div><hr><h3 id="正则匹配替换"><a href="#正则匹配替换" class="headerlink" title="${} 正则匹配替换"></a>${} 正则匹配替换</h3><ul><li><code>${parameter#word}</code>、<code>${parameter##word}</code>：<strong>从头开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>#</code>为<strong>最短</strong>匹配，<code>##</code>为<strong>最长</strong>匹配</li><li><code>${parameter%word}</code>、<code>${parameter%%word}</code>：<strong>从尾开始</strong>扫描word(pattern)，将匹配word(pattern)的字符过滤掉，<code>%</code>为<strong>最短</strong>匹配，<code>%%</code>为<strong>最长</strong>匹配</li><li><code>${parameter/pattern/string}</code>、<code>${parameter//pattern/string}</code>：使用string替换pattern，<code>/</code>表示<strong>只替换一次</strong>；<code>//</code>表示<strong>全部替换</strong></li><li><code>${\#parameter}</code>：获取变量长度</li></ul><div class="note info"><p>上述的<code>parameter</code>都是可以不用引用的，因为<code>${var}</code>本来就和<code>$var</code>是一个意思</p></div><hr><h2 id="得到脚本变量"><a href="#得到脚本变量" class="headerlink" title="$* 得到脚本变量"></a>$* 得到脚本变量</h2><p><code>$*</code>引用script的执行引用变量，引用参数的算法与一般指令相同，<strong>script本身为0</strong>，其后第一个为1，然后依此类推。引用变量的代表方式如下：<code>$0</code>, <code>$1</code>, <code>$2</code>, <code>$3</code>, <code>${10}</code>, <code>${11}</code>，注意个位数的，可直接使用数字，但<strong>两位数以上，则必须使用 {} 符号来括住</strong>。</p><p><code>$*</code> 则是代表<strong>所有引用变量</strong>的符号，使用时得视情况加上双引号，如<code>echo &quot;$*&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash example.sh var1 var2 var3</span><br><span class="line"><span class="comment"># $0是example.sh、$1是var1、$2是var2、$3是var3</span></span><br></pre></td></tr></table></figure><hr><h2 id="得到脚本变量-1"><a href="#得到脚本变量-1" class="headerlink" title="$@ 得到脚本变量"></a>$@ 得到脚本变量</h2><ul><li><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的<strong>所有参数</strong>，<strong>不被双引号(“ “)包含时</strong>，都以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> … <code>&quot;$n&quot;</code> 的形式输出所有参数</li><li>但是<strong>当它们被双引号(“ “)包含时</strong>，<code>&quot;$*&quot;</code> 会将<strong>所有的参数作为一个整体</strong>，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以<code>&quot;$1&quot;</code> <code>&quot;$2&quot;</code> … <code>&quot;$n&quot;</code> 的形式输出所有参数</li><li>也就是说<code>$@</code>不管有没有被双引号包围，其输出结果<strong>都是单个的变量形式</strong>，而<code>$*</code>在<strong>不被双引号</strong>包围时输出<strong>单个变量的形式</strong>，<strong>被双引号包围</strong>时，所有的参数<strong>以整体的形式输出</strong></li></ul><hr><h2 id="变量总数"><a href="#变量总数" class="headerlink" title="$# 变量总数"></a>$# 变量总数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出变量总数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="与declare-i-整数运算"><a href="#与declare-i-整数运算" class="headerlink" title="$(())与declare -i 整数运算"></a>$(())与declare -i 整数运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i total=<span class="variable">$firstnu</span>*<span class="variable">$secnu</span></span><br><span class="line">total=$((<span class="variable">$firstnu</span>*<span class="variable">$secnu</span>))</span><br></pre></td></tr></table></figure><p>区别就是小方括号内可以加上空格符，也是合法的写法，而declare -i 不可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2*3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不正确的写法（加了空格），total=2* 3任何一处存在空格都不可以</span></span><br><span class="line"><span class="built_in">declare</span> -i total=2* 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换用$(())，注意等号和计算公式之间不能存在空格，不然也会报错</span></span><br><span class="line">total=$((2*3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(())内的变量可以直接使用变量名称，也可以通过引用的方式获取</span></span><br><span class="line">a=5;b=7;c=2</span><br><span class="line"><span class="built_in">echo</span> $((a+b*c))</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$a</span>+<span class="variable">$b</span>*<span class="variable">$c</span>))</span><br></pre></td></tr></table></figure><p><code>declare -i</code>加空格报错：</p><blockquote><p>bash: declare: 2<em>: syntax error: operand expected (error token is “</em>“)</p></blockquote><p><code>$(())</code>在等号左右加空格报错：</p><blockquote><p>bash: 6: command not found</p></blockquote><p><strong><code>$(())</code>进制转化：将其他进制转成十进制数显示出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N为进制，xx为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值</span></span><br><span class="line"><span class="built_in">echo</span> $((N<span class="comment">#xx))</span></span><br></pre></td></tr></table></figure><hr><h2 id="执行计算"><a href="#执行计算" class="headerlink" title="((  )) 执行计算"></a>(( )) 执行计算</h2><p>和linux<code>let</code>指令相似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=5;b=7</span><br><span class="line">((a--));<span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;5;i++));<span class="keyword">do</span> <span class="built_in">echo</span>  <span class="variable">$i</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h2 id="指令群组"><a href="#指令群组" class="headerlink" title="(  ) 指令群组"></a>( ) 指令群组</h2><p>用括号将一串连续指令括起来，这被称为指令群组</p><p>指令群组有一个特性，shell会以产生subshell来执行这组指令，因此，在<strong>指令群组所定义的变量，仅作用于指令群组本身</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"test"</span></span><br><span class="line">(<span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>);<span class="built_in">echo</span> <span class="variable">$test</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>/home/usr<br>test</p></blockquote><p><strong><code>( )</code>也可被用于数组的声明中：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array=(element1 element2 element3)</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="大括号"><a href="#大括号" class="headerlink" title="{ } 大括号"></a>{ } 大括号</h2><h3 id="作为代码块"><a href="#作为代码块" class="headerlink" title="作为代码块"></a>作为代码块</h3><p><strong>代码块</strong>，又被称为内部组，这个结构事实上创建了一个<strong>匿名函数</strong>。与上面小括号中的指令群组不同，花括号内的命令不会新开一个子shell运行，即<strong>脚本余下部分仍可使用括号内变量</strong>，因此，这样写 script也是相当好的一件事。尤其对<em>输出输入的重导向</em>上，这个做法可<strong>精简 script 的复杂度</strong>。括号内的<strong>命令间用分号隔开</strong>，<strong>最后一个也必须有分号</strong>。<strong><code>{}</code>的第一个命令和左括号之间必须要有一个空格</strong>。</p><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个命令和左括号之间没有空格</span></span><br><span class="line">&#123;<span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一个命令没有分号</span></span><br><span class="line">&#123; <span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确用法</span></span><br><span class="line">&#123; <span class="built_in">cd</span> ~ ; <span class="built_in">test</span>=`<span class="built_in">pwd</span>` ;<span class="built_in">echo</span> <span class="variable">$test</span>;&#125;;<span class="built_in">echo</span> <span class="variable">$test</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>第一个命令和左括号之间没有空格</strong>报错：</p><blockquote><p>bash: {cd: command not found<br>/home/user/test}<br>/home/user/test</p></blockquote><p><strong>最后一个命令没有分号</strong>报错：</p><blockquote><p>> ^C</p></blockquote><p>正确输出：</p><blockquote><p>/home/user<br>/home/user</p></blockquote><h3 id="作为拓展"><a href="#作为拓展" class="headerlink" title="作为拓展"></a>作为拓展</h3><p>通配(globbing)将<strong>对花括号中的文件名做扩展</strong>。在大括号中，<strong>不允许有空白</strong>，<strong>除非</strong>这个空白被引用或转义。</p><ul><li>对大括号中的以逗号分割的<strong>文件列表进行拓展</strong>。如 <code>touch {a,b}.txt</code> 结果为<code>a.txt</code> <code>b.txt</code></li><li>对大括号中以点点<code>（..）</code>分割的<strong>顺序文件列表起拓展作用</strong>，如：<code>touch {a..d}.txt</code> 结果为<code>a.txt</code> <code>b.txt</code> <code>c.txt</code> <code>d.txt</code></li><li>对大括号中以点点<code>（..）</code>分割的<strong>顺序文件列表起拓展作用</strong>，如 <code>for i in {1..2};do echo $i;done</code> 结果为<code>1</code> <code>2</code></li></ul><h3 id="进行组合"><a href="#进行组合" class="headerlink" title="进行组合"></a>进行组合</h3><p>大括号<code>{}</code>里面的内容以<strong>逗号分隔</strong>，两个或多个大括号内的内容进行组合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3x3的组合，中间的短横线是分割线，可以自定义</span></span><br><span class="line">mkdir &#123;userA,userB,userC&#125;-&#123;home,bin,data&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行嵌套使用</span></span><br><span class="line">chown root /usr/&#123;ucb/&#123;ex,edit&#125;,lib/&#123;ex?.?*,how_ex&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="中括号"><a href="#中括号" class="headerlink" title="[ ] 中括号"></a>[ ] 中括号</h2><ul><li>在<strong>通配符和正则表达式</strong>中<code>[]</code>代表一定有一个在中括号内的字符，例如<code>[abcd]</code>代表一定有一个字符，可能是a、b、c、d这四个任何一个，<code>[num1-num2]</code>表示范围、<code>[^]</code>表示非</li><li><strong>流程控制</strong>中，扮演括住判断式的作用，<code>[]</code>中可用的比较运算符只有<code>==</code>和<code>!=</code>，两者<strong>都是用于字符串比较的</strong>，<strong>不可用于整数比较</strong>，<strong>整数比较只能使用<code>-eq</code>，<code>-gt</code>这种形式</strong>。无论是字符串比较还是整数比较<strong>都不支持大于号小于号</strong>。如果实在想用，对于字符串比较可以使用<strong>转义形式</strong>，如果比较<code>&quot;ab&quot;</code>和<code>&quot;bc&quot;</code>：<code>[ ab &lt; bc ]</code>，结果为真，也就是返回状态为0。<strong><code>[ ]</code>中的逻辑与和逻辑或使用-a 和-o 表示</strong></li><li>在一个array结构的上下文中，中括号用来引用数组的索引</li></ul><hr><h2 id="双中括号"><a href="#双中括号" class="headerlink" title="[[  ]] 双中括号"></a>[[ ]] 双中括号</h2><ul><li>这组符号与先前的 <code>[]</code> 符号，基本上作用相同，但是<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code>和<code>&gt;</code> 操作符能够正常存在于<code>[[ ]]</code>条件判断结构中，但是如果出现在<code>[ ]</code>结构中的话，会报错。</li><li><strong>支持字符串的模式匹配</strong>，使用<code>=~</code>操作符时甚至支持shell的<strong>正则表达式</strong>，字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如<code>[[ hello == hell? ]]</code>，结果为真。<strong><code>[[ ]]</code>中匹配字符串或通配符，不需要引号</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># [[ 2\&lt;3 ]] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ 2 -lt 3 ]] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ 2 \&lt; 3 ]] &amp;&amp; echo true || false</span></span><br><span class="line">-bash: 期待二元条件运算符</span><br><span class="line">-bash: `\&lt;<span class="string">' 附近有语法错误，这是因为空格的原因</span></span><br><span class="line"><span class="string">[root@localhost ~]# [ 2 \&lt; 3 ] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="string">true</span></span><br><span class="line"><span class="string">[root@localhost ~]# [ 2 &lt; 3 ] &amp;&amp; echo true || false</span></span><br><span class="line"><span class="string">-bash: 3: 没有那个文件或目录</span></span><br></pre></td></tr></table></figure><hr><h2 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="|| 逻辑符号"></a>|| 逻辑符号</h2><p>在中括号中<code>[]</code>代表 <code>or</code> 逻辑的符号</p><p>在命令行中：<br><code>cmd1||cmd2</code><br>若<strong>cmd1执行完毕且正确执行($?=0)</strong>，则cmd2<strong>不执行</strong><br>若<strong>cmd1执行完毕且为错误($?≠0)</strong>，则开始<strong>执行cmd2</strong></p><hr><h2 id="amp-amp-逻辑符号"><a href="#amp-amp-逻辑符号" class="headerlink" title="&amp;&amp; 逻辑符号"></a>&amp;&amp; 逻辑符号</h2><p>在中括号中<code>[]</code>代表 <code>and</code> 逻辑的符号</p><p>在命令行中如下:<br><code>cmd1&amp;&amp;cmd2</code><br>若<strong>cmd1执行完毕且正确执行（$?=0）</strong>,则<strong>开始执行cmd2</strong><br>若<strong>cmd1执行完毕且为错误（$?≠0）</strong>，则<strong>cmd2不执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果./symbol/abc目录不存在则创建这个目录，成功后在目录下创建hehe文件</span></span><br><span class="line">ls ./symbol/abc || mkdir  ./symbol/abc &amp;&amp; touch ./symbol/abc/hehe</span><br></pre></td></tr></table></figure><blockquote><p>目录不存在，ls的报错信息<br>ls: cannot access ./symbol/abc: No such file or directory</p></blockquote><hr><h2 id="lt-…-gt-单字边界"><a href="#lt-…-gt-单字边界" class="headerlink" title="\&lt;…\&gt; 单字边界"></a>\&lt;…\&gt; 单字边界</h2><p>这组符号在规则表达式中，被定义为”边界”的意思。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除能完整匹配This这个单词的行</span></span><br><span class="line">sed <span class="string">'/\&lt;This\&gt;/d'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="文件操作符合输出-输入重定向"><a href="#文件操作符合输出-输入重定向" class="headerlink" title="文件操作符合输出/输入重定向"></a>文件操作符合输出/输入重定向</h2><ul><li><code>&gt;</code>：表示重定向</li><li><code>&amp;</code>：表示等同于的意思</li><li>文件描述符是和文件的输入、输出相关联的非负整数，Linux内核（kernel）利用文件描述符（file descriptor）来访问文件。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。常见的文件描述符是stdin、stdout和stderr。</li></ul><p><strong>常用的文件描述符如下：</strong></p><table><thead><tr><th>文件描述符</th><th>名称</th><th>常用缩写</th><th>默认值</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td>stdin</td><td>键盘</td></tr><tr><td>1</td><td>标准输出</td><td>stdout</td><td>屏幕</td></tr><tr><td>2</td><td>标准错误输出</td><td>stderr</td><td>屏幕</td></tr></tbody></table><p><strong>在简单地用<code>&lt;</code>或<code>&gt;</code>时，相当于使用 <code>0&lt;</code> 或 <code>1&gt;</code>，注意文件描述符和重定向符号之间不能存在空格，同时也可以将<code>&gt;</code>改为<code>&gt;&gt;</code>追加而不是覆盖文本信息</strong></p><ul><li><code>cmd &gt; file</code>等同于<code>cmd 1&gt; file</code>：把cmd命令的<strong>输出重定向到文件file中</strong>，如果file已经存在，则<strong>覆盖原有文件</strong></li><li><code>cmd &gt;&gt; file</code>等同于<code>cmd 1&gt;&gt; file</code>：把cmd命令的<strong>输出重定向到文件file中</strong>，如果file已经存在，则把信息<strong>加在原有文件后面</strong></li><li><code>cmd &lt; file</code>等同于<code>cmd 0&lt; file</code>：使cmd命令从<strong>file</strong>读入，<strong>必须是文件</strong>，不能是字符</li><li><code>cmd &lt;&lt; text</code>等同于<code>cmd 0&lt;&lt; text</code>：从命令行读取输入，直到一个与text字符相同的行结束</li><li><code>cmd 2&gt; file</code>：把cmd命令的<strong>标准错误输出重定向到文件file中</strong>，如果file已经存在，则<strong>覆盖原有文件</strong></li><li><code>cmd 2&gt;&gt; file</code>：把cmd命令的<strong>标准错误输出重定向到文件file中</strong>，如果file已经存在，则把信息<strong>加在原有文件后面</strong></li><li><code>cmd &gt;&amp;n</code>等同于<code>cmd 1&gt;&amp;n</code>：把输出重定向到文件描述符n，通过对<code>&amp;</code>的解读：标准输出的重定向等同于文件描述符n</li><li><code>cmd m&gt;&amp;n</code> ：把输出到文件符m的信息重定向到文件描述符n</li></ul><p><strong>从命令行读取输入：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; wang &gt; haha.txt</span><br></pre></td></tr></table></figure><p></p><p>从命令行得到输入，直到出现<code>wang</code>为止</p><blockquote><p><code>cat &lt;&lt; wang &gt;haha.txt</code><br>> test<br>> test2<br>> wang</p></blockquote><ul><li><code>cmd &lt;&lt;&lt; word</code>：将word(字符)，注意不是上面的file读入</li></ul><p><strong>标准错误输出：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># test.file不存在，没有任何错误提示，正常运行</span></span><br><span class="line">cat test.file 2&gt; out.txt  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 与上面的方法结果相同，错误的信息都被输入到了out.txt中</span></span><br><span class="line">cat test.file &amp;&gt; out.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将错误输出丢弃到/dev/null中，/dev/null是一个特殊的设备文件，这个文件接受到任何数据都会被丢系，通常被称为位桶、黑洞</span></span><br><span class="line">cat test.file  2&gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将标准输出重定向大list.txt文件中，标准错误输出重定向到list.err文件中</span></span><br><span class="line">cat test.file  1&gt; list.txt   2&gt; list.err</span><br></pre></td></tr></table></figure><p><strong>将标准错误stderr与stdout一同重定向到test.log文件:</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将标准输出重定向到test.log中，然后文件描述符2（标准错误输出）的重定向等同于文件描述符1（标准输出）</span></span><br><span class="line">./test.sh &gt;test.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>文件描述符支持自定义，<a href="http://man.linuxde.net/shell-script/shell-2" target="_blank" rel="noopener">参考文章</a></p></div><hr><p><br></p><h2 id="实战总结"><a href="#实战总结" class="headerlink" title="实战总结"></a>实战总结</h2><h3 id="得到数字用于循环的方法汇总"><a href="#得到数字用于循环的方法汇总" class="headerlink" title="得到数字用于循环的方法汇总"></a>得到数字用于循环的方法汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5);<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;6;i++));<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; ;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h3 id="转义字符总结"><a href="#转义字符总结" class="headerlink" title="转义字符总结"></a>转义字符总结</h3><p>有时候，我们想让<code>通配符</code>或者<code>元字符</code>变成<strong>普通字符</strong>，不需要使用它，那么这里我们就需要用到<code>转义符</code>了，shell提供转义符有三种：</p><table><tr><th width="20%">字符</th><th width="80%">说明</th></tr><tr><td>‘’(单引号)</td><td>又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)</td></tr><tr><td>“”(双引号)</td><td>又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替</td></tr><tr><td>\(反斜杠)</td><td>又叫转义，去除其后紧跟的元字符或通配符的特殊意义</td></tr></table><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.chinaunix.net/uid-16946891-id-5088144.html" target="_blank" rel="noopener">linux 特殊符号大全</a></li><li><a href="https://www.cnblogs.com/dirt2/p/5991033.html" target="_blank" rel="noopener">Linux命令中特殊符号，排版更好看</a></li><li><a href="https://www.jianshu.com/p/986e88819441" target="_blank" rel="noopener">Linux中的特殊符号及含义</a></li><li><a href="http://www.178linux.com/35067" target="_blank" rel="noopener">linux中特殊符号用法</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用内容总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用内容总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日总结和计划</title>
      <link href="/posts/51961.html"/>
      <url>/posts/51961.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>2019-2-24开始的每日学习总结与计划</p></div><a id="more"></a><style type="text/css">.tg{border-collapse:collapse;border-spacing:0;border-color:#999}.tg td{font-family:Arial,sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#f7fdfa}.tg th{font-family:Arial,sans-serif;font-size:14px;font-weight:400;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ade4}.tg .tg-phtq{background-color:#d2e4fc;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-hmp3{background-color:#d2e4fc;text-align:left;vertical-align:top}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><h2 id="2019-2-24"><a href="#2019-2-24" class="headerlink" title="2019-2-24"></a>2019-2-24</h2><h3 id="今日学习完成情况"><a href="#今日学习完成情况" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sed</td><td class="tg-phtq">学习了基本语法、掌握了选项i、n、e、f以及命令s、p、g</td><td class="tg-hmp3">2小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">markdown</td><td class="tg-0pky">完成了markdown基本语法的学习</td><td class="tg-0lax">3个小时</td></tr></table><div class="note success"><p>今日学习情况总结：首先是学习了markdown基本语法，收获了很多，比如html块元素是必须要进行留空白行的、有序列表前的数字不关键、创建表格以及进行相应的优化（还不够完善）等新内容；也开始学习了linux基本命令sed，对其使用有了基本的了解，明天还要接着学习！</p></div><hr><h3 id="明日学习哪些内容"><a href="#明日学习哪些内容" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>markdown表格的优化（宽度调整）</del></li><li><del>shell中特殊符号的学习</del></li><li><del>sed命令的学习</del></li></ul></div><hr><p><br></p><h2 id="2019-2-25"><a href="#2019-2-25" class="headerlink" title="2019-2-25"></a>2019-2-25</h2><h3 id="今日学习完成情况-1"><a href="#今日学习完成情况-1" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令-sed</td><td class="tg-phtq">完成了sed的学习</td><td class="tg-hmp3">大概3个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是完成了sed命令的学习，学习过程中发现sed和之前学的其他命令如awk、grep等有很多相似之处，有了之前的基础学起来更加容易理解，果然是学的越多学得越快！！！通过对sed命令的学习，在以后处理文本时就又增加了一个非常有力的工具！</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-1"><a href="#明日学习哪些内容-1" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li><del>shell中特殊符号的处理</del></li><li><p>~~markdown表格的优化（宽度调整）</p></li><li><p><del>开始学习师兄安排的任务</del></p></li></ul></div><hr><p><br></p><h2 id="2019-3-17"><a href="#2019-3-17" class="headerlink" title="2019-3-17"></a>2019-3-17</h2><h3 id="今日学习完成情况-2"><a href="#今日学习完成情况-2" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">shell编程</td><td class="tg-phtq">完成了shell编程数组的学习</td><td class="tg-hmp3">2个小时</td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要学习了shell数组的相关操作，shell数组相对比较简单，同时也只支持一维数组，具有一定的局限性。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-2"><a href="#明日学习哪些内容-2" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>学习pv命令，完善pv命令相应的文章</li><li><del>开始学习师兄安排的任务</del></li></ul></div><hr><p><br></p><h2 id="2019-3-18"><a href="#2019-3-18" class="headerlink" title="2019-3-18"></a>2019-3-18</h2><h3 id="今日学习完成情况-3"><a href="#今日学习完成情况-3" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">其他技巧整理</td><td class="tg-0pky">常用程序块、常见错误、main函数的理解</td><td class="tg-0lax">2个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是在完成师兄交代的任务，同时也Python相关内容进行了整理，包括常见错误、常用程序块以及之前学习过的main函数的理解</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-3"><a href="#明日学习哪些内容-3" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>学习pv命令，完善pv命令相应的文章</li><li><del>学习参数传递，然后修改重构项目文件</del></li></ul></div><hr><p><br></p><h2 id="2019-3-19"><a href="#2019-3-19" class="headerlink" title="2019-3-19"></a>2019-3-19</h2><h3 id="今日学习完成情况-4"><a href="#今日学习完成情况-4" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用模块</td><td class="tg-0pky">argparse-解析命令行参数</td><td class="tg-0lax">一天</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> 其他内容</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是学习了Python用于命令行参数传递的模块argparse，在学习的过程中发现Python官方库的讲解非常详细，会先给出示例，然后对齐进行详细的讲解，我也比较喜欢这种讲解模式，以后可以多看看，学习学习，同时也发现了比较炫酷的方面就是子命令的使用。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-4"><a href="#明日学习哪些内容-4" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>学习pv命令，完善pv命令相应的文章</li><li><del>完成师兄的交代的项目</del></li><li><del>完成图床的搭建</del></li></ul></div><hr><p><br></p><h2 id="2019-3-20"><a href="#2019-3-20" class="headerlink" title="2019-3-20"></a>2019-3-20</h2><h3 id="今日学习完成情况-5"><a href="#今日学习完成情况-5" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-square"></i> Python</td><td class="tg-0pky"></td><td class="tg-0pky"></td><td class="tg-0lax"></td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">博客完善</td><td class="tg-0pky">基于阿里云搭建了图床，基本抛弃了七牛云</td><td class="tg-0lax">3个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是完成了师兄说的项目内容以及完成了博客图床的搭建，还是花钱的东西好使，七牛云需要认证是真的麻烦</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-5"><a href="#明日学习哪些内容-5" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>学习pv命令，完善pv命令相应的文章</li><li><del>项目相关</del></li><li><del>学习logging模块</del></li><li><del>完成cat命令的学习</del></li><li><del>完善argparse的用法</del></li><li><del>博客转载的项目，动手搞一搞，启动</del></li><li><del>安装sublime text3显示大纲的插件(打开的两个Github)</del></li></ul></div><hr><p><br></p><h2 id="2019-3-21"><a href="#2019-3-21" class="headerlink" title="2019-3-21"></a>2019-3-21</h2><h3 id="今日学习完成情况-6"><a href="#今日学习完成情况-6" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> Linux</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用模块</td><td class="tg-0pky">继续完善了模块argparse</td><td class="tg-0lax">2个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">docker学习、sublime text3插件安装</td><td class="tg-0pky">部署完成了第一个docker镜像、配置了sublime text3</td><td class="tg-0lax">4个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是对师兄说的项目内容进行了完善，同时也这对这个项目制作了第一个镜像，果然万事开头难，制作第一个镜像的过程中需要了很多问题，但是还好都得到了解决，同时通过这个项目也对docker有了一定的了解，为后面详细学习docker打下了基础。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-6"><a href="#明日学习哪些内容-6" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>学习pv命令，完善pv命令相应的文章</li><li><del>学习logging模块</del></li><li><del>完成cat命令的学习</del></li><li>博客转载的项目</li></ul></div><h2 id="2019-3-22"><a href="#2019-3-22" class="headerlink" title="2019-3-22"></a>2019-3-22</h2><h3 id="今日学习完成情况-7"><a href="#今日学习完成情况-7" class="headerlink" title="今日学习完成情况"></a>今日学习完成情况</h3><table class="tg"><tr><th class="tg-c3ow" width="10%">类别</th><th class="tg-c3ow" width="35%">学习内容</th><th class="tg-c3ow" width="45%">大致描述</th><th class="tg-baqh" width="10%">大概用时</th></tr><tr><td class="tg-phtq"><i class="fa fa-check-square"></i> Linux</td><td class="tg-phtq">常用基本命令</td><td class="tg-phtq">cat-显示、读取或者拼接文本内容</td><td class="tg-hmp3">1.5h</td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> Python</td><td class="tg-0pky">常用模块</td><td class="tg-0pky">完成了logging模块常规使用部分</td><td class="tg-0lax">3个小时</td></tr><tr><td class="tg-phtq"><i class="fa fa-square"></i> 机器学习</td><td class="tg-phtq"></td><td class="tg-phtq"></td><td class="tg-hmp3"></td></tr><tr><td class="tg-0pky"><i class="fa fa-check-square"></i> 其他内容</td><td class="tg-0pky">git系列</td><td class="tg-0pky">总结了一些Git使用实战</td><td class="tg-0lax">0.5个小时</td></tr></table><div class="note success"><p>今日学习情况总结：今天主要是在学习logging模块以及cat命令，都比较简单，上午主要是完善了Docker，将其上传到了Github，其中遇到的问题已经记录并形成了文章。在学习logging模块过程中发现需要看源码(参考的那篇文章)，果然大佬都是会看源码的，所以需要了解看源码的方法。后续需要学习的Linux命令都比较简单，比较的大的和重要的命令前面都已经学习过了，所以后续对Linux命令的学习可以插缝进行。</p></div><p>每日学习之后不要忘了：<br><i class="fa fa-check-square"></i> 修改todo list<br><i class="fa fa-check-square"></i> 修改对应文章中的链接<br><i class="fa fa-check-square"></i> 在前一天对应的学习任务上画删除线</p><hr><h3 id="明日学习哪些内容-7"><a href="#明日学习哪些内容-7" class="headerlink" title="明日学习哪些内容"></a>明日学习哪些内容</h3><p><strong>明日学习计划总览：</strong></p><div class="note info"><ul><li>学习pv命令，完善pv命令相应的文章</li><li>完成logging模块</li><li>和xupeng、yufeng一起学习机器学习</li><li>Python查看包的源代码的方法</li><li>博客转载的项目</li><li>给姐姐筛选一下材料</li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结和计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/posts/65136.html"/>
      <url>/posts/65136.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这篇文章总结markdown基础语法，便于后续查找和使用。<a href="http://showteeth.tech/posts/37746.html">另有一篇next-markdown技巧和模板</a>总结了博客写作中常用的markdown技巧和模板，有些并不是原生的markdown语法，但是写作效果很好看，需要的时候可以查阅这个。</p></div><a id="more"></a><h2 id="markdown特性"><a href="#markdown特性" class="headerlink" title="markdown特性"></a>markdown特性</h2><ul><li>Markdown 的目标是实现<strong>易读易写</strong></li><li><strong>兼容HTML</strong>，不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了，不过<em>有一些标签需要特殊注意</em></li><li><strong>特殊字符转换</strong>：特殊字符如HTML中需要特殊处理的字符<code>&lt;</code>和<code>&amp;</code>，markdown会将其自动转化为<code>&amp;lt;</code> 和 <code>&amp;amp;</code>这种实体的形式（虽然在markdown中看不到，但是实际上在生成html时markdown自动将其转化为上述实体的形式），但是如果是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 不会对它做任何转换。附上<a href="http://showteeth.tech/posts/45689.html">HTML 中有用的字符实体</a></li></ul><div class="note warning"><ul><li>在markdown使用HTML标签<mark>需要特殊注意的是 HTML 的区块元素</mark>，比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在<strong>前后加上空行</strong>与其它内容区隔开，还要求它们的<strong>开始标签与结尾标签不能用制表符或空格来缩进</strong>;Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上<em>不必要</em>的 <code>&lt;p&gt;</code> 标签</li><li>HTML 区块标签间的 Markdown 格式语法将<strong>不会被处理</strong>，如<code>&lt;p&gt;这是**一个**测试&lt;/p&gt;</code>中一个不会加粗显示</li><li>HTML 的行内标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用</li><li>与处在 HTML 区块标签间不同，<strong>Markdown 语法在 HTML 行内标签间是有效的</strong></li><li>具体的HTML区块标签和行内标签有哪些，请参考<a href="http://showteeth.tech/posts/8829.html">这篇转载的文章</a></li></ul></div><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h3><h4 id="换行和段落"><a href="#换行和段落" class="headerlink" title="换行和段落"></a>换行和段落</h4><p>在markdown中进行<strong>换行</strong>操作：一行<strong>文本末尾增加两个以上的空格然后回车</strong>，如果<strong>只使用回车，不添加或者没加够空格看上去两行的文字会变为一行</strong>。</p><p>markdown<strong>区分段落的关键</strong>是：这两行文字之间<strong>是否有空行</strong>，空行的定义是显示上看起来像是空的，便会被视为空行。比如，若某一行<strong>只包含空格和制表符，则该行也会被视为空行</strong>。如果这两行文字之间有空行，就代表这两行文字为两个段落，如果这两行文字之间没有空行，仅仅使用另个以上空格加回车进行换行，这两行文字仍旧是属于同一个段落。</p><div class="note info"><ul><li>得到空行的方法：在上一行<strong>文本末尾加上两个以上空格然后回车</strong>，<strong>再加上<code>&lt;br /&gt;</code>即可</strong></li><li>两个段落之间有一个空行就可以证明其为两个段落，再多的空行也不会在html中渲染（上述添加<code>&lt;br /&gt;</code>制造空行的方式除外，增加几个<code>&lt;br /&gt;</code>就会有几个空行）。</li></ul></div><hr><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>markdown依据<code>#</code>的数量，支持六级的标题，一个<code>#</code>代表一级标题，<strong>用于标题的<code>#</code>数目最多为6个</strong>，当数目<strong>大于6个时不再以标题的形式显现</strong>，如<code>####### 7</code>将直接显示为####### 7，而不是以标题的形式。<br><br><br>当然也可以选择闭合标题的<code>#</code>，在标题之后加上若干数目的<code>#</code>，标题的级别是依据标题之前的<code>#</code>数目决定，和之后的<code>#</code>数目无关。如<code># 1 ##########</code>还是代表的1级标题。</p><hr><h4 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h4><ul><li>markdown使用<code>&gt;</code>进行引用</li><li><strong>段落内多行一同进行区块引用</strong>可以在每一行之前都加上<code>&gt;</code>，也可以进行偷懒，在整个<strong>段落</strong>的第一行加上<code>&gt;</code>引用一整行</li><li>引用可以进行<strong>嵌套</strong>，如加两个&gt;&gt;三个&gt;&gt;&gt;</li></ul><blockquote><p>这是一句引用</p><blockquote><p>这也是一个引用</p><blockquote><p>当然，这个还是一个引用</p></blockquote></blockquote></blockquote><ul><li>使用blockquotes标签进行引用，可以修改文字颜色以及左边框颜色。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">"color:red;border-left: 3px solid #F44336;"</span>&gt;</span>使用blockquotes标签进行引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><blockquote style="color:red;border-left:3px solid #f44336">使用blockquotes标签进行引用</blockquote><ul><li>引用的<strong>区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; #### 这是一个标题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1.   这是第一行列表项</span><br><span class="line">&gt; 2.   这是第二行列表项</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">"color:red;border-left: 3px solid #F44336;"</span>&gt;</span>使用blockquotes标签进行引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">&gt; **引用**结束</span><br></pre></td></tr></table></figure><hr><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>markdown支持<strong>有序列表</strong>、<strong>无序列表</strong>和<strong>任务列表</strong>。</p><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表使用<strong>星号</strong>、<strong>加号</strong>或是<strong>减号</strong>作为列表标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>有序列表则使用<strong>数字接着一个英文句点</strong>作为列表标记。值得注意的是有序列表<mark>中英文句号前面的数字并不重要</mark>，也就是说<strong>可以是完全相同或者不连续的数字</strong>，这些都不会影响最终解析得到的html信息，<strong>得到的结果都是相同的</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br></pre></td></tr></table></figure><h5 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h5><p><strong>依赖模块</strong>: <code>pymdownx.tasklist</code></p><p><strong>用法</strong>: <code>- [ ]</code> 或 <code>- [x]</code>，其中 <strong><code>[ ]</code>表示不打勾</strong>，<strong><code>[x]</code>表示打勾</strong>，<strong><code>-</code>可以用<code>+</code>或<code>*</code>替代</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit</span><br><span class="line">- [x] Nulla lobortis egestas semper</span><br><span class="line">- [x] Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est</span><br><span class="line">- [ ] Vestibulum convallis sit amet nisi a tincidunt</span><br><span class="line">    - [x] In hac habitasse platea dictumst</span><br><span class="line">    - [x] In scelerisque nibh non dolor mollis congue sed et metus</span><br><span class="line">    - [x] Sed egestas felis quis elit dapibus, ac aliquet turpis mattis</span><br><span class="line">    - [ ] Praesent sed risus massa</span><br><span class="line">- [x] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</span><br><span class="line">- [ ] Nulla vel eros venenatis, imperdiet enim id, faucibus nisi</span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果：</strong></p><ul><li style="list-style:none"><input type="checkbox" checked> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li><li style="list-style:none"><input type="checkbox" checked> Nulla lobortis egestas semper</li><li style="list-style:none"><input type="checkbox" checked> Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est</li><li style="list-style:none"><input type="checkbox"> Vestibulum convallis sit amet nisi a tincidunt<ul><li style="list-style:none"><input type="checkbox" checked> In hac habitasse platea dictumst</li><li style="list-style:none"><input type="checkbox" checked> In scelerisque nibh non dolor mollis congue sed et metus</li><li style="list-style:none"><input type="checkbox" checked> Sed egestas felis quis elit dapibus, ac aliquet turpis mattis</li><li style="list-style:none"><input type="checkbox"> Praesent sed risus massa</li></ul></li><li style="list-style:none"><input type="checkbox" checked> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li><li style="list-style:none"><input type="checkbox"> Nulla vel eros venenatis, imperdiet enim id, faucibus nisi</li></ul><h5 id="多级列表"><a href="#多级列表" class="headerlink" title="多级列表"></a>多级列表</h5><p>多级列表的产生：先得到一级列表，然后使用<code>tab键</code>将后续的列表依次缩进即可得到多级列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* this is a test </span><br><span class="line">  * this is a test </span><br><span class="line">    * this is a test</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><ul><li>this is a test<ul><li>this is a test<ul><li>this is a test</li></ul></li></ul></li></ul><h5 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h5><p>列表项目<strong>可以包含多个段落</strong>，每个项目下的段落都<strong>必须缩进 4 个空格或是 1 个制表符</strong>。</p><p>段落的<strong>每一行都可以进行缩进</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span><br><span class="line">    mi posuere lectus.</span><br><span class="line"></span><br><span class="line">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span><br><span class="line">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span><br><span class="line">    sit amet velit.</span><br><span class="line"></span><br><span class="line">2.  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ol><li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p><p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p></li><li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li></ol><p>当然也支持<strong>只对段落首行进行缩进</strong>，和上面的段落每行都缩进结果是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line">    This is the second paragraph in the list item. You're</span><br><span class="line">only required to indent the first line. Lorem ipsum dolor</span><br><span class="line">sit amet, consectetuer adipiscing elit.</span><br><span class="line"></span><br><span class="line">*   Another item in the same list.</span><br></pre></td></tr></table></figure><h5 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h5><p>如果要在<strong>列表项目内放进引用</strong>，那 <code>&gt;</code> 就需要缩进：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line">    &gt; This is a blockquote</span><br><span class="line">    &gt; inside a list item.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><p>A list item with a blockquote:</p><blockquote><p>This is a blockquote<br>inside a list item.</p></blockquote></li></ul><h5 id="包含代码块的列表"><a href="#包含代码块的列表" class="headerlink" title="包含代码块的列表"></a>包含代码块的列表</h5><p>如果要<strong>放代码块</strong>的话，该代码块就需要缩进两次，也<strong>就是 8 个空格或是 2 个制表符</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   一列表项包含一个列表区块：</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">代码写在这</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note warning"><ul><li>如果在<strong>行首出现数字-句点-空白</strong>，可能会误认为是有序列表，要避免这样的状况，你可以在句点前面加上<strong>反斜杠</strong>，如1986. What a great season.</li><li>标记后面最少有一个<strong>空格</strong>或<strong>制表符</strong></li><li><mark>必须和前后文本存在空行</mark>，不然列表可能<strong>不能正确解析</strong>以及后面的文本可能<strong>出现偏移</strong>。</li></ul></div><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h5 id="使用markdown原生的方式插入表格"><a href="#使用markdown原生的方式插入表格" class="headerlink" title="使用markdown原生的方式插入表格"></a>使用markdown原生的方式插入表格</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td><em>短文本</em></td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><div class="note warning"><ul><li>表格的语句<mark>上一行必须为空行</mark>，不然表格不生效;</li><li>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;</li><li>-的数量至少有一个;</li><li>|、-、:之间的多余空格会被忽略，不影响布局;</li><li>表格内容中可以套用其他用法，如加粗、斜体等；</li><li><mark>直接在markdown原生表格之前添加html样式（style）也可以对表格样式进行修改</mark>。</li></ul></div><h5 id="设置表格宽度自适应"><a href="#设置表格宽度自适应" class="headerlink" title="设置表格宽度自适应"></a>设置表格宽度自适应</h5><p>解决了按照<strong>第一列表头宽度进行自适应</strong>的问题：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table th:first-of-type &#123;</span></span><br><span class="line"><span class="undefined">width: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>为每一列单独设置宽度：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">35%</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">45%</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span>第四列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在markdown原生表格之前加上如下内容，设置每一列宽度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table th:first-of-type &#123;</span></span><br><span class="line"><span class="undefined">width: 15%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">table th:nth-of-type(2) &#123;</span></span><br><span class="line"><span class="undefined">width: 25%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">table th:nth-of-type(3) &#123;</span></span><br><span class="line"><span class="undefined">width: 60%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>第一列占整个表格宽度的10%、第二列占35%、第三列占45%、第四列占10%。</p><div class="note warning"><ul><li><code>th:first-of-type</code> 的意思是每个 <code>&lt;th&gt;</code> 为其父级的<strong>第一个元素</strong>，就是指第一列的表头，同理第二、三个使用 <code>th:nth-of-type(2)</code>、<code>th:nth-of-type(3)</code></li><li>修改表头的宽度表头对应的列的宽度也就得到了修改</li><li>这里有一篇关于markdown表格样式优化的<a href="https://www.tuicool.com/articles/mueEZjr" target="_blank" rel="noopener">文章</a>，包括<code>鼠标悬停变色</code>、<code>表格滚动条</code>、<code>隔行变色</code>、<code>表头不换行</code>和<code>首列不换行</code>等优化</li><li><strong>excel也能导出html</strong>，先在excel中创建表格，然后保存为html，最后复制其中的表格，<a href="https://blog.csdn.net/sunbocong/article/details/81033915" target="_blank" rel="noopener">参考文章</a></li></ul></div><h5 id="表格对齐问题"><a href="#表格对齐问题" class="headerlink" title="表格对齐问题"></a>表格对齐问题</h5><ul><li>-:表示内容和标题栏居右对齐；</li><li>:-表示内容和标题栏居左对齐；</li><li>:-:表示内容和标题栏居中对齐；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| :------ | :------: | ------: |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th style="text-align:left">一个普通标题</th><th style="text-align:center">一个普通标题</th><th style="text-align:right">一个普通标题</th></tr></thead><tbody><tr><td style="text-align:left"><em>短文本</em></td><td style="text-align:center">中等文本</td><td style="text-align:right">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:center">短文本</td><td style="text-align:right">中等文本</td></tr></tbody></table><h5 id="使用html插入表格"><a href="#使用html插入表格" class="headerlink" title="使用html插入表格"></a>使用html插入表格</h5><p>上述markdown原生的方法只能创建一些简单的表格，如果想创建复杂的表格，如<mark>合并单元格</mark>、<mark>调整表格颜色</mark>等就需要直接使用html进行创建表格。</p><p>实现合并单元格：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>b1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>b2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>b3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>c2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>c3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>最终效果：</strong></p><table><br><tr><br><th>项目1</th><br><th>项目2</th><br><th>项目3</th><br></tr><br><tr><br><td>a1</td><br><td colspan="2">a2</td><br></tr><br><tr><br><td rowspan="2">b1</td><br><td>b2</td><br><td>b3</td><br></tr><br><tr><br><td>c2</td><br><td>c3</td><br></tr><br></table><div class="note info"><ul><li><code>table</code>标签：定义 HTML 表格</li><li><code>tr</code> 元素定义表格<code>行</code></li><li><code>th</code> 元素定义<code>表头</code></li><li><code>td</code> 元素定义表格<code>单元</code></li><li><code>td</code>标签下的<code>colspan（跨列-合并一行的多列）及rowspan（跨行-合并一列的多行）</code>属性进行单元格的合并。</li></ul></div><h5 id="使用html插入表格需要注意空行"><a href="#使用html插入表格需要注意空行" class="headerlink" title="使用html插入表格需要注意空行"></a>使用html插入表格需要注意空行</h5><p>markdown在处理上述的表格时会<strong>产生大量的空行</strong>，除非将整个表格写成一行，不然空行的书目和整个html代码占的行数相同，解决方法是加上<code>escape</code>标签，将整个table套起来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">escape</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>b1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>b2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>b3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>c2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>c3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">escape</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><table><tr><th>项目1</th><th>项目2</th><th>项目3</th></tr><tr><td>a1</td><td colspan="2">a2</td></tr><tr><td rowspan="2">b1</td><td>b2</td><td>b3</td></tr><tr><td>c2</td><td>c3</td></tr></table><h5 id="偷懒方法之直接复制html代码"><a href="#偷懒方法之直接复制html代码" class="headerlink" title="偷懒方法之直接复制html代码"></a>偷懒方法之直接复制html代码</h5><p>从上面html代码可以看出来写着比较麻烦，为了解决这个问题，这里有一个专门生成<code>Latex</code>、<code>html</code>、<code>markdown</code>、<code>text</code>、<code>mediawiki</code>支持的表格源码的网站，只需要选取相应的内容即可，还可以<strong>调整表格颜色</strong>，生成相应的css样式。</p><a class="btn" href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>生成表格源码的网站</a><h5 id="在markdown表格显示竖线"><a href="#在markdown表格显示竖线" class="headerlink" title="在markdown表格显示竖线"></a>在markdown表格显示竖线</h5><p>在使用markdown表格时如果想要显示竖线，仅仅使用转义是不能成功的，需要使用HTML实体，竖线的HTML实体为<code>&amp;#124;</code>，一个竖线就使用一个<code>&amp;#124;</code>两个竖线就使用两个<code>&amp;#124;&amp;#124;</code>，使用HTML实体后，网页会自动将其显示为<code>|</code>，关于HTML中的常用字符实体请参考<a href="http://showteeth.tech/posts/45689.html">这篇文章</a></p><hr><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块有两种写法：使用反引号加代码语言种类，代码写完后面也跟三个相同的符号（这种方法最为常用）；第二种写法就是简单地缩进 4 个空格或是 1 个制表符就可以。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个普通段落：</span><br><span class="line"></span><br><span class="line">    这是一个代码区块。</span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>需要和<strong>普通段落之间存在空行</strong></li><li><strong>最后的三个反引号之后不能存在空格</strong>，不然会出错</li></ul></div><hr><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>你可以在一行中用<mark>三个以上</mark>的<code>星号</code>、<code>减号</code>、<code>底线</code>来<strong>建立一个分隔线</strong>，<em>行内不能有其他东西</em>。你也<em>可以在星号或是减号中间插入空格</em>。下面每种写法都可以建立分隔线：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">_____</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><hr><hr><hr><hr><hr><hr><div class="note info"><p>使用带空格的<code>星号</code>、<code>减号</code>、<code>底线</code>建立空格线，空格线会粗一些。</p></div><hr><p><br></p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>markdown支持两种形式的链接语法：<code>行内式</code>和<code>参考式</code>两种形式，一般行内式使用较为简单和普遍，所以这里就采用行内式的方式。</p><p>链接的使用形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/ "Title")</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br><a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a></p><div class="note info"><ul><li>方括号内的文字（an example）表示链接作用的文字</li><li>圆括号内部第一个是链接地址</li><li>第二个是title：鼠标移到链接文字上显示的内容</li></ul></div><p>如果你是要链接到<strong>同样主机的资源，你可以使用相对路径</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">See my [About](/about/) page for details.</span><br></pre></td></tr></table></figure><p><mark>关于参考式链接:</mark></p><ul><li>参考式的链接其实重点不在于它比较好写，而是它比较好读</li><li>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断</li><li>具体关于参考是的讲解可以参考<a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">这篇文章</a>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        "Google"</span><br><span class="line">  [2]: http://search.yahoo.com/  "Yahoo Search"</span><br><span class="line">  [3]: http://search.msn.com/    "MSN Search"</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><hr><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5><p>markdown使用星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被<code>*</code>或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code>标签包围，显示出斜体的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于*斜体*的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<em>斜体</em>的测试</p><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5><p>markdown使用两个星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被两个<code>*</code>或 <code>_</code> 包围的字词会被转成用 <code>&lt;strong&gt;</code>（加粗显示）包围，显示出加粗的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于**加粗**的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<strong>加粗</strong>的测试</p><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5><p>使用以上的斜体和加粗叠加可以实现斜体和加粗的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于***斜体加粗***的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<strong><em>斜体</em></strong>的测试</p><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><p>要加删除线的文字左右分别用<code>两个~~</code>号包起来，这个也可以叠加斜体以及加粗标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是关于~~删除线~~的测试</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p>这是关于<del>删除线</del>的测试</p><div class="note info"><ul><li>星号<code>*</code>和底线<code>_</code>与被包围的文字之间不能有空格，不然星号<code>*</code>和底线<code>_</code>就会被当成普通的字符显示</li><li>如果想加入普通的星号<code>*</code>和底线<code>_</code>，你可以用反斜线，如</li></ul></div><hr><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>行内插入代码，可以直接使用反引号（<code>`</code>）将代码包围起来即可。如<code>&lt;div&gt; &lt;/div&gt;</code>就是写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span><br></pre></td></tr></table></figure><p><mark>行内代码中加入反引号：</mark>可以用<strong>多个反引号来开启和结束代码区段</strong>，同时起始和结束端都可以放入一个空白，<em>起始端后面一个，结束端前面一个</em>，这样你就可以<strong>在区段的一开始就插入反引号</strong>：如 A backtick-delimited string in a code span: <code>`foo`</code>、三个反引号就是写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`` `foo` ``</span><br><span class="line"># 三个反引号在hexo博客中显示可能会出问题</span><br><span class="line">`` ``` ``</span><br></pre></td></tr></table></figure><hr><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><h5 id="使用markdown语法插入图片："><a href="#使用markdown语法插入图片：" class="headerlink" title="使用markdown语法插入图片："></a>使用markdown语法插入图片：</h5><p>使用markdown插入图片与插入链接类似，也有两种方式：<strong>行内式和参考式</strong>，这里讲解的主要为行内式。关于参考式的用法可以<em>参考链接参考式</em>的用法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="comment">&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown插入图片"></p><center><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown+center标签居中插入图片"><br></center><div class="note info"><p><code>Optional title</code> 是用来在鼠标移到图片上时显示的title</p></div><div class="note warning"><p>使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别</p></div><hr><h5 id="html代码插入图片"><a href="#html代码插入图片" class="headerlink" title="html代码插入图片"></a>html代码插入图片</h5><p><strong>针对使用markdown插入图片的缺点，使用html语句可以很好的解决</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用img标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"图片名称"</span> <span class="attr">align</span>=<span class="string">center</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用div标签包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png"</span>  <span class="attr">title</span>=<span class="string">"使用html插入图片"</span>  <span class="attr">alt</span>=<span class="string">"图片名称"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" width="300" height="200" alt="图片名称" title="使用html插入图片" align="center"></p><div align="center"><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" title="使用html插入图片" alt="图片名称"><br></div><div class="note warning"><ul><li>不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；</li><li>推荐使用div标签包裹img标签。</li></ul></div><hr><p><br></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>markdown支持以下这些符号前面<strong>加上反斜杠来帮助插入普通的符号</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="常见错误原因集锦"><a href="#常见错误原因集锦" class="headerlink" title="常见错误原因集锦"></a>常见错误原因集锦</h3><div class="note warning"><ul><li>html<strong>块级元素上下没有空格</strong>，块级元素是指 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签</li><li><strong>列表</strong>与前后内容之间没有空格</li><li><strong>列表</strong>内容和标记之间没有空格</li><li><strong>换行操作</strong>只回车没有在上一行文本末尾增加两个以上空格</li><li><strong>停止引用</strong>需要和下一行文本空行（另起一段），不然也会被引用进去</li><li><strong>代码</strong>最后的<code>`</code> <code></code>之后不能存在空格，不然会将后面的内容也写入代码内</li><li><strong>强调</strong>，不管是加粗还是斜体，<strong>标记<code>*</code>或`</strong><code>不能与文本之间存在距离**，不然会失效，标记会显示成标记本身，即</code>*<code>或</code>**`</li><li><strong>表格</strong>的语句<mark>上一行必须为空行</mark>，不然表格不生效</li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener">markdown融合单元单元格问题</a></li><li><a href="http://www.tablesgenerator.com/text_tables" target="_blank" rel="noopener">Latex|html|markdown|text|mediawiki制作表格并得到相应源代码的利器</a></li><li><a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></li><li><a href="http://wow.kuapp.com/markdown/basic.html" target="_blank" rel="noopener">Markdown: Basics （快速入门）</a></li><li><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">Markdown 基本语法</a></li><li><a href="https://github.com/guoyunsky/Markdown-Chinese-Demo" target="_blank" rel="noopener">Markdown-Chinese-Demo</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 其他内容学习 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed-文本处理工具</title>
      <link href="/posts/1752.html"/>
      <url>/posts/1752.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>sed处理文本，包括sed命令的基本格式、参数和命令说明、文本的替换、打印、删除、增加、插入以及其他常用的技巧（分组、传入参数、命令连用以及对文件进行读取和写入等）。</p></div><a id="more"></a><h2 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h2><p>sed是一种流编辑器，它是文本处理中非常中的工具，能够<strong>完美的配合正则表达式</strong>使用，功能不同凡响。处理时，把<strong>当前处理的行</strong>存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，<strong>接着处理下一行，这样不断重复，直到文件末尾（和awk都是对文件和输入的每一行进行操作）</strong>。<strong>文件内容并没有改变</strong>，除非你使用重定向存储输出。</p><p>sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><hr><h2 id="sed-用法"><a href="#sed-用法" class="headerlink" title="sed 用法"></a>sed 用法</h2><h3 id="sed-命令格式"><a href="#sed-命令格式" class="headerlink" title="sed 命令格式"></a>sed 命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: </span><br><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...</span><br><span class="line"></span><br><span class="line">sed [options] <span class="string">'command'</span> file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure><hr><h3 id="sed-options说明"><a href="#sed-options说明" class="headerlink" title="sed options说明"></a>sed options说明</h3><table><tr><th width="20%">参数</th><th width="20%">完整参数</th><th width="60%">说明</th></tr><tr><td>-e script</td><td>–expression=script</td><td>以选项中的指定的script来处理输入的文本文件，直接在命令行模式上进行sed动作编辑，此为默认选项</td></tr><tr><td>-f script</td><td>–files=script</td><td>以选项中的指定的script文件来处理输入的文本文件</td></tr><tr><td>-i</td><td>–in-place</td><td>直接在原位修改原文件</td></tr><tr><td>-n</td><td>–quiet –silent</td><td>仅显示script处理后的结果</td></tr><tr><td>-V</td><td>–version</td><td>显示版本信息</td></tr><tr><td>-h</td><td>–help</td><td>显示帮助</td></tr></table><hr><h3 id="sed-command说明"><a href="#sed-command说明" class="headerlink" title="sed command说明"></a>sed command说明</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>在当前行下面插入文本。</td></tr><tr><td>i</td><td>在当前行上面插入文本。</td></tr><tr><td>c</td><td>把选定的行改为新的文本。</td></tr><tr><td>d</td><td>删除，删除选择的行</td></tr><tr><td>D</td><td>删除模板块的第一行</td></tr><tr><td>s</td><td>替换指定字符</td></tr><tr><td>h</td><td>拷贝模板块的内容到内存中的缓冲区</td></tr><tr><td>H</td><td>追加模板块的内容到内存中的缓冲区</td></tr><tr><td>g</td><td>获得内存缓冲区的内容，并替代当前模板块中文本</td></tr><tr><td>G</td><td>获得内存缓冲区的内容，并追加到当前模板块文本的后面</td></tr><tr><td>l</td><td>列表不能打印字符的清单</td></tr><tr><td>n</td><td>读取下一个输入行，用下一个命令处理新的行而不是第一个命令</td></tr><tr><td>N</td><td>追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码</td></tr><tr><td>p</td><td>打印模板块的行</td></tr><tr><td>P</td><td>打印模板块的第一行</td></tr><tr><td>q</td><td>退出sed</td></tr><tr><td>b label</td><td>分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾</td></tr><tr><td>r file</td><td>从file中读行</td></tr><tr><td>t label</td><td>if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾</td></tr><tr><td>T label</td><td>错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾</td></tr><tr><td>w file</td><td>写并追加模板块到file末尾</td></tr><tr><td>W file</td><td>写并追加模板块的第一行到file末尾</td></tr><tr><td>!</td><td>表示后面的命令对所有没有被选定的行发生作用</td></tr><tr><td>=</td><td>打印当前行号</td></tr><tr><td>#</td><td>把注释扩展到第一个换行符以前</td></tr></tbody></table><hr><h3 id="sed-正则匹配元字符集"><a href="#sed-正则匹配元字符集" class="headerlink" title="sed 正则匹配元字符集"></a>sed 正则匹配元字符集</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配行开始，如：/^sed/匹配所有以sed开头的行。</td></tr><tr><td>$</td><td>匹配行结束，如：/sed$/匹配所有以sed结尾的行。</td></tr><tr><td>.</td><td>匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</td></tr><tr><td>*</td><td>匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</td></tr><tr><td>[]</td><td>匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。</td></tr><tr><td>[^]</td><td>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</td></tr><tr><td>(..)</td><td>匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。</td></tr><tr><td>&amp;</td><td>保存搜索字符用来替换其他字符，如s/love/&amp;/，love这成love。</td></tr><tr><td>&lt;</td><td>匹配单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</td></tr><tr><td>&gt;</td><td>匹配单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</td></tr><tr><td>x{m}</td><td>重复字符x，m次，如：/0{5}/匹配包含5个0的行。</td></tr><tr><td>x{m,}</td><td>重复字符x，至少m次，如：/0{5,}/匹配至少有5个0的行。</td></tr><tr><td>x{m,n}</td><td>重复字符x，至少m次，不多于n次，如：/0{5,10}/匹配5~10个0的行。</td></tr></tbody></table><hr><p><br></p><h2 id="sed-用法实例"><a href="#sed-用法实例" class="headerlink" title="sed 用法实例"></a>sed 用法实例</h2><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><blockquote><p><code>cat test.txt</code><br>my cat’s name is betty<br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><h4 id="sed-替换标记"><a href="#sed-替换标记" class="headerlink" title="sed 替换标记"></a>sed 替换标记</h4><style>table th:first-of-type{width:10%}</style><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>g</td><td>表示行内全面替换</td></tr><tr><td>p</td><td>表示打印行</td></tr><tr><td>w</td><td>表示把行写入一个文件</td></tr><tr><td>x</td><td>表示互换模板块中的文本和缓冲区中的文本</td></tr><tr><td>y</td><td>表示把一个字符翻译为另外的字符（但是不用于正则表达式）</td></tr><tr><td>\1</td><td>子串匹配标记</td></tr><tr><td>&amp;</td><td>已匹配字符串标记</td></tr></tbody></table><hr><h4 id="sed-s-替换指定字符"><a href="#sed-s-替换指定字符" class="headerlink" title="sed s 替换指定字符"></a>sed s 替换指定字符</h4><p>将每一行文本中的This替换为sub<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">'s/is/are/'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略-e</span></span><br><span class="line">sed  <span class="string">'s/is/are/'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name are betty<br>Th<strong>are</strong> <strong>is</strong> your dog<br>my dog’s name are frank<br>Th<strong>are</strong> <strong>is</strong> your fish<br>my fareh’s name is george<br>Th<strong>are</strong> <strong>is</strong> your goat<br>my goat’s name are adam</p></blockquote><div class="note info"><ul><li>option的默认就是-e，所以-e可以省略</li><li><code>s命令</code>：替换指定字符指的是每一行的第一个发生替换，第二个以及后续的不会发生替换</li></ul></div><hr><h4 id="只打印那些发生替换的行"><a href="#只打印那些发生替换的行" class="headerlink" title="只打印那些发生替换的行"></a>只打印那些发生替换的行</h4><p><code>-n选项</code>和<code>p命令</code>一起使用表示<code>只打印</code>那些发生替换的行</p><div class="note info"><ul><li><code>-n选项</code>:仅显示script处理后的结果</li><li><code>p命令</code>:打印模板块的行</li><li>选项、命令、命令三者连用就是：打印处理后的模板块的行</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'s/is/are/p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name <strong>are</strong> betty<br>Th<strong>are</strong> is your dog<br>my dog’s name <strong>are</strong> frank<br>Th<strong>are</strong> is your fish<br>my f<strong>are</strong>h’s name is george<br>Th<strong>are</strong> is your goat<br>my goat’s name <strong>are</strong> adam</p></blockquote><hr><h4 id="全局替换"><a href="#全局替换" class="headerlink" title="全局替换"></a>全局替换</h4><p><code>g命令</code>表示行内全面替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  <span class="string">'s/is/are/g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><blockquote><p>my cat’s name <strong>are</strong> betty<br>Th<strong>are</strong> <strong>are</strong> your dog<br>my dog’s name <strong>are</strong> frank<br>Th<strong>are</strong> <strong>are</strong> your f<strong>are</strong>h<br>my f<strong>are</strong>h’s name <strong>are</strong> george<br>Th<strong>are</strong> <strong>are</strong> your goat<br>my goat’s name <strong>are</strong> adam</p></blockquote><div class="note info"><ul><li>注意与<code>单独的s命令</code>的结果对比</li><li><code>命令s</code>、<code>命令g</code>之间的<strong>顺序是固定的</strong></li></ul></div><hr><h4 id="从第几处开始替换"><a href="#从第几处开始替换" class="headerlink" title="从第几处开始替换"></a>从第几处开始替换</h4><p>从第二处开始替换：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/is/are/2'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>输出结果:</strong></p><blockquote><p>my cat’s name is betty<br>This are your dog<br>my dog’s name is frank<br>Th<em>is</em> <strong>are</strong> your f<em>is</em>h<br>my fish’s name are george<br>This are your goat<br>my goat’s name is adam</p></blockquote><div class="note info"><p>数字后面可以接<code>命令g</code>或者<code>命令p</code>等</p></div><p><strong>从每行中第N除开始全局替换：</strong></p><p><code>g命令</code><strong>之前加上数字N</strong>，表示从第N处之后的匹配开始全局替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/is/are/2g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>my cat’s name <strong>is</strong> betty<br>Th<strong>is</strong> <strong>are</strong> your dog<br>my dog’s name is frank<br>Th<strong>is</strong> <strong>are</strong> your f<strong>are</strong>h<br>my fish’s name are george<br>This are your goat<br>my goat’s name is adam</p></blockquote><div class="note info"><p>从第二处（包括）开始，后面的所有匹配上的都被替换掉了</p></div><hr><h3 id="以行为单位进行替换"><a href="#以行为单位进行替换" class="headerlink" title="以行为单位进行替换"></a>以行为单位进行替换</h3><p><code>命令c</code>：把选定的行改为新的文本</p><p>将第2-5行的内容取代成为this is sub of line 2-5<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c 和文字之间有没有空行都可以</span></span><br><span class="line">sed <span class="string">'2,5c this is sub of line 2-5'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br><em>this is sub of line 2-5</em><br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><p><strong>替换为多行的内容，只需要通过<code>\n</code>进行文本的换行即可：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2,5cthis is sub of line 2-5 \nthis is a second sub'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br><em>this is sub of line 2-5</em><br><em>this is a second sub</em><br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="原位修改文件"><a href="#原位修改文件" class="headerlink" title="原位修改文件"></a>原位修改文件</h3><p><code>选项i</code>：在文件的<strong>原位修改，不在屏幕输出</strong>，如果<strong>-i后跟着suffix</strong>，则会产生备份文件，形式为<code>原文件名suffix</code>。</p><p><code>命令g</code>也可以替换为其他命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i_suffix <span class="string">'s/is/are/g'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p><code>ls</code><br>test.txt<br>test.txt_suffix</p></blockquote><blockquote><p><code>cat test.txt</code><br>my cat’s name are betty<br>Thare are your dog<br>my dog’s name are frank<br>Thare are your fareh<br>my fareh’s name are george<br>Thare are your goat<br>my goat’s name are adam</p></blockquote><hr><h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符/"></a>定界符/</h3><p>命令中字符 <code>/</code> 在sed中作为<code>定界符</code>使用，也<strong>可以使用任意的定界符</strong>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用冒号替代</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">'s:sk:ma:4g'</span></span><br><span class="line"><span class="comment"># 使用竖线替代</span></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">'s|sk|ma|4g'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>sksksk<strong>mamama</strong></p></blockquote><blockquote><p>sksksk<strong>mamama</strong></p></blockquote><div class="note info"><ul><li>定界符出现在样式内部时，需要进行<strong>转义</strong>或者直接<strong>更换定界符</strong></li><li>这个定界符个人感觉其实是用来作为<strong>正则匹配</strong>的，和<code>awk</code>用法相似</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/bin'</span> |sed <span class="string">'s/\/usr/\/test/g'</span></span><br><span class="line"><span class="comment"># 直接更换定界符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/bin'</span> |sed <span class="string">'s|/usr|/test|g'</span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>/test/local/bin</p></blockquote><blockquote><p>/test/local/bin</p></blockquote><hr><h3 id="已匹配字符串标记-amp"><a href="#已匹配字符串标记-amp" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><ul><li><code>&amp;</code>：已经匹配上的内容暂存在这个变量中，方便对已匹配内容进行处理</li></ul><p>正则表达式<code>\w\+</code>匹配每一个单词，使用<code>[&amp;]</code>替换它，<code>&amp;</code>对应之前所匹配到的单词：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span> line | sed <span class="string">'s/\w\+/[&amp;]/g'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo test is a test line |sed &#39;s/\w\+/[&amp;]/g&#39;</code><br>[test] [is] [a] [test] [line]</p></blockquote><div class="note info"><ul><li>从上面可以看出，这种方法主要是用来针对<strong>一次匹配多个字符串</strong>，然后<strong>对多个字符串进行分开处理</strong>，而不是使用相同的处理（如使用同一个字符替换）</li></ul></div><hr><h3 id="分组标记-1-、-2"><a href="#分组标记-1-、-2" class="headerlink" title="分组标记\1 、\2"></a>分组标记\1 、\2</h3><ul><li><code>\1</code> 、<code>\2</code>：表示正则匹配的分组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">'s/digit \([0-9]\)/\1/'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo this is digit 7 in a number |sed &#39;s/digit \([0-9]\)/\1/&#39;</code><br>this is 7 in a number</p></blockquote><p>命令中digit 7，被替换成7。样式匹配到的子串是7，<code>\(..\)</code>用于匹配子串，对于匹配到的<strong>第一个子串</strong>标记为<code>\1</code>，依此类推匹配到的<strong>第二个结果</strong>就是<code>\2</code>,例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> aaa BBB | sed <span class="string">'s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo aaa BBB | sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;</code><br>BBB aaa</p></blockquote><div class="note info"><ul><li>括号需要进行转义</li></ul></div><hr><h3 id="传入变量-引用"><a href="#传入变量-引用" class="headerlink" title="传入变量-引用"></a>传入变量-引用</h3><p><code>sed</code>作为文本处理工具，可能经常需要传入变量来进行操作，这里提供了关于传入变量的方法，但是需要注意的是，<mark>如果表达式内部存在变量字符串，<strong>command的单引号就要变成双引号</strong></mark>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="string">"HELLO"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello WORLD"</span> |sed <span class="string">"s/hello/<span class="variable">$test</span>/"</span></span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>echo &quot;hello WORLD&quot; |sed &quot;s/hello/$test/&quot;</code><br>HELLO WORLD</p></blockquote><hr><h3 id="组合多个命令"><a href="#组合多个命令" class="headerlink" title="组合多个命令 ;"></a>组合多个命令 ;</h3><p>命令组合在Linux中是非常常见的，一般是使用<code>管道符</code>，在sed命令中可以使用<code>;</code>分割命令，这种用法同样和<code>awk</code>使用非常相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'表达式'</span> | sed <span class="string">'表达式'</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'表达式; 表达式'</span></span><br></pre></td></tr></table></figure><hr><h3 id="多个命令连用-e"><a href="#多个命令连用-e" class="headerlink" title="多个命令连用 -e"></a>多个命令连用 -e</h3><p><strong>选项-e本就是sed的默认选项</strong>，用于说明使用的是command而不是文件命令形式，多个命令连用，<strong>注意是有前后顺序的连用</strong>，在连用的command之前加上-e即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">'1,5d'</span> -e <span class="string">'s/my/MY/'</span> test.txt</span><br></pre></td></tr></table></figure><p>先删除test.txt文件中的第1、5行，输出删除的内容，然后对这两行进行将my替换为MY。</p><p><strong>最终结果：</strong></p><blockquote><p>This is your goat<br>MY goat’s name is adam</p></blockquote><div class="note info"><p>这个方式进行命令的连用和上面使用分号<code>;</code>将不同命令连写的方式<strong>效果相同</strong></p></div><hr><h3 id="使用-连用命令"><a href="#使用-连用命令" class="headerlink" title="使用{}连用命令"></a>使用<code>{}</code>连用命令</h3><p>使用<code>{}</code>将需要连用的命令包围，并使用<code>;</code>将多个命令隔开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/This/&#123;s/This/this/;n;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><div class="note info"><ul><li><code>命令n</code>：当前匹配行的下一行</li><li><code>选项n</code>：仅显示script处理后的结果</li></ul></div><hr><h3 id="选定行的范围-逗号"><a href="#选定行的范围-逗号" class="headerlink" title="选定行的范围 ,(逗号)"></a>选定行的范围 ,(逗号)</h3><p>选取行的范围来对文本进行处理，可以使用在不同行之间加逗号<code>,</code>的方式</p><p>打印从<strong>第5行开始</strong>到<strong>第一个包含以this开始的行之间的所有行</strong>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'5,/^This/p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p>sed -n ‘5,/^This/p’ test.txt<br>my fish’s name is george<br>This is your goat</p></blockquote><div class="note info"><ul><li>行的索引<strong>开始于1</strong></li><li>需要注意的是：是包含尾部的，<code>5,7p</code>是<strong>包含</strong>第七行的</li><li>选取行号之后不仅仅可以用来做打印，还可以进行其他操作，具体见本文<strong>使用实战</strong></li></ul></div><hr><h3 id="打印命令-p"><a href="#打印命令-p" class="headerlink" title="打印命令 p"></a>打印命令 p</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印第3行</span></span><br><span class="line">sed -n <span class="string">'3p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第3-5行</span></span><br><span class="line">sed -n <span class="string">'3,5p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字和正则表达式连用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第1行开始，第一次出现This结束之间的行（起始行固定，终止行第一次正则匹配位置）</span></span><br><span class="line">sed -n <span class="string">'1,/This/p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始行固定，终止行第一次正则匹配位置</span></span><br><span class="line">sed -n <span class="string">"/my cat's name is betty/,/This/p"</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次匹配到This的行到第3行，然后再输出所有匹配到This的行</span></span><br><span class="line">sed -n <span class="string">'/This/,3p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果含有This的行在第1行之后，则打印所有含有This的行</span></span><br><span class="line">sed -n <span class="string">'/This/,1p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始行和终止行都不固定，打印全文</span></span><br><span class="line">sed -n <span class="string">'/my/,/This/p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;3p&#39; test.txt</code><br>my dog’s name is frank</p></blockquote><blockquote><p><code>sed -n &#39;3,5p&#39; test.txt</code><br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george</p></blockquote><blockquote><p><code>sed -n &#39;1,/This/p&#39; test.txt</code><br>my cat’s name is betty<br>This is your dog</p></blockquote><blockquote><p><code>sed -n &quot;/my cat&#39;s name is betty/,/This/p&quot; test.txt</code><br>my cat’s name is betty<br>This is your dog</p></blockquote><blockquote><p><code>sed -n &#39;/This/,3p&#39; test.txt</code><br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>This is your goat</p></blockquote><blockquote><p><code>sed -n &#39;/This/,1p&#39; test.txt</code><br>This is your dog<br>This is your fish<br>This is your goat</p></blockquote><blockquote><p><code>sed -n &#39;/my/,/This/p&#39; test.txt</code><br>my cat’s name is betty<br>This is your dog<br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><div class="note warning"><ul><li>使用<strong>打印命令p</strong>时需要注意，<strong>sed默认会打印出所有的行</strong>（命令d除外，只会打印保留下来的行），所以<strong>想要打印出特定修改过的行需要加上选项n</strong>，如果不加，<mark>匹配上的行会打印两遍</mark></li><li>使用正则表达式进行匹配打印时需要特别小心</li><li>如果数字在前面，是<strong>从数字开始</strong>到<strong>第一次匹配到正则表达式的部分（1就是从1开始，3就是从3开始看后面第一次匹配的）</strong></li><li><mark>如果数字在后面，正则表达式在前面，那么一定会将全文中包含正则表达式的全部输出，其他部分如果数字大于正则表达式第一次出现的行，则输出正则表达式第一次出现的行到数字之间的其他内容，如果数字小于正则表达式第一次出现的行，那就只会打印包含正则表达式的行。<strong>全文匹配正则表达式的输出以及正则表达式第一次出现的行到数字之间的其他内容输出</strong></mark></li><li>如果<strong>前后都为正则表达式</strong>，则<strong>输出全文内容</strong></li><li>关于上述正则表达式我的理解：因为数字是完全确定的，开始和结束行都很确定，所以可以很明确输出想要的结果，但是如果是正则表达式的话，不是唯一的匹配结果（段落中有几行都可以匹配上），那么如果正则表达式在前，则不知道从第几行开始当起始行，所以如果数字大于第一个匹配位置所在的行，那么以第一个匹配位置所在的行为起始行到数字规定的终止行之间的行都会输出，同时起始行可能有很多（其他位置也有匹配），所以还会输出其他匹配位置作为开始，这时如果数字小于第二个匹配位置的话，就只会输出匹配正则表达式的行，同时如果数字大于第二个匹配位置，由于第一个匹配位置的输出已经包含第二个位置，所以不会再输出一遍第二个匹配位置到终止行的信息</li></ul></div><div class="note info"><p>说了很多，总结一下：<mark>使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。</mark></p></div><hr><h3 id="匹配模式取反-！"><a href="#匹配模式取反-！" class="headerlink" title="匹配模式取反 ！"></a>匹配模式取反 ！</h3><p>打印除第一行和第二行之外的其他行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'1,2!p'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;1,2!p&#39; test.txt</code><br>my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><h3 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号 ="></a>显示行号 =</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/my/&#123;=;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;/my/{=;p}&#39; test.txt</code><br>1<br>my cat’s name is betty<br>3<br>my dog’s name is frank<br>5<br>my fish’s name is george<br>7<br>my goat’s name is adam</p></blockquote><hr><h3 id="删除命令-d"><a href="#删除命令-d" class="headerlink" title="删除命令 d"></a>删除命令 d</h3><ul><li><code>命令d</code>：删除，删除选择的行</li></ul><h4 id="删除空白行"><a href="#删除空白行" class="headerlink" title="删除空白行"></a>删除空白行</h4><blockquote><p><code>cat test2.txt</code><br>my cat’s name is betty</p><p>this is your this dog</p><p>my dog’s name is this frank</p><p>this is your fish</p><p>my fish’s name is this george</p><p>this is your goat</p><p>my goat’s name is this adam</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^$/d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>this is your this dog<br>my dog’s name is this frank<br>this is your fish<br>my fish’s name is this george<br>this is your goat<br>my goat’s name is this adam</p></blockquote><div class="note info"><ul><li>空白行的表示方法：<code>^$</code> (开头和结尾之间的内容为空)</li></ul></div><hr><h4 id="删除含有固定单词的行"><a href="#删除含有固定单词的行" class="headerlink" title="删除含有固定单词的行"></a>删除含有固定单词的行</h4><p><code>&lt;</code>：匹配单词的开始，注意需要转义<br><code>&gt;</code>：匹配单词的结束，注意需要转义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/\&lt;This\&gt;/d'</span> test.txt</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>sed &#39;/\&lt;This\&gt;/d&#39; test.txt</code><br>my cat’s name is betty<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><hr><h4 id="正则匹配删除-删除文件中所有以my开头的行"><a href="#正则匹配删除-删除文件中所有以my开头的行" class="headerlink" title="正则匹配删除-删除文件中所有以my开头的行"></a>正则匹配删除-删除文件中所有以my开头的行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>this is your this dog</p><p>this is your fish</p><p>this is your goat</p></blockquote><hr><h4 id="从某一行开始删除"><a href="#从某一行开始删除" class="headerlink" title="从某一行开始删除"></a>从某一行开始删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2,$d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed &#39;2,$d&#39; test2.txt</code><br>my cat’s name is betty</p></blockquote><div class="note info"><ul><li>最后一行：<code>$</code></li><li>首行不是<code>^</code>，直接使用1</li></ul></div><hr><h4 id="删除文件最后一行"><a href="#删除文件最后一行" class="headerlink" title="删除文件最后一行"></a>删除文件最后一行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'$d'</span> test2.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty</p><p>this is your this dog</p><p>my dog’s name is this frank</p><p>this is your fish</p><p>my fish’s name is this george</p><p>this is your goat</p></blockquote><div class="note info"><ul><li>最后一行：<code>$</code></li><li>可以发现前面删掉空行的操作没有影响原始文件，如果想修改原始文件，可以加上<code>选项i</code></li></ul></div><hr><h3 id="写入文件-w命令"><a href="#写入文件-w命令" class="headerlink" title="写入文件 w命令"></a>写入文件 w命令</h3><p>在test.txt中所有包含my的行都被<strong>写入test2.txt</strong>里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/my/w test2.txt'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>cat test2.txt</code><br>my cat’s name is betty<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><hr><h3 id="从文件读入-r命令"><a href="#从文件读入-r命令" class="headerlink" title="从文件读入 r命令"></a>从文件读入 r命令</h3><p>file里的内容被读进来，<strong>显示在与test.txt匹配的行后面</strong>，如果<strong>匹配多行</strong>，则file的内容将<strong>显示在所有匹配行的下面</strong>：</p><blockquote><p>cat test1.txt<br>aaaaaaaa</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/my/r test1.txt'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><strong>my</strong> cat’s name is betty<br><em>aaaaaaaaa</em><br>This is your dog<br><strong>my</strong> dog’s name is frank<br><em>aaaaaaaaa</em><br>This is your fish<br><strong>my</strong> fish’s name is george<br><em>aaaaaaaaa</em><br>This is your goat<br><strong>my</strong> goat’s name is adam<br><em>aaaaaaaaa</em></p></blockquote><hr><h3 id="追加文件-a"><a href="#追加文件-a" class="headerlink" title="追加文件 a\"></a>追加文件 a\</h3><p><strong>追加与上述读取不同</strong>，虽然两者<strong>都是讲在匹配的行下增加文本信息</strong>，但是读取处理的是<strong>两个文件</strong>，追加处理的是<strong>一个文件和一行或多行文本</strong>。</p><p><strong>a后面的反斜杠可有可无</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/a\this is a test line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><em>my</em> cat’s name is betty<br><em>this is a test line</em><br>This is your dog<br><em>my</em> dog’s name is frank<br><em>this is a test line</em><br>This is your fish<br><em>my</em> fish’s name is george<br><em>this is a test line</em><br>This is your goat<br><em>my</em> goat’s name is adam<br><em>this is a test line</em></p></blockquote><p>同样也可以通过追加操作也<strong>增加两行甚至多行内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/a\this is a test line \nthis is second line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>通过使用<code>\n</code>进行换行操作来达到增加多行的目的</strong></p><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>this is a test line<br><em>this is second line</em><br>This is your dog<br>my dog’s name is frank<br>this is a test line<br><em>this is second line</em><br>This is your fish<br>my fish’s name is george<br>this is a test line<br><em>this is second line</em><br>This is your goat<br>my goat’s name is adam<br>this is a test line<br><em>this is second line</em></p></blockquote><div class="note info"><p>如果命令a之前什么都不加，表明给在每一行下都增加文本<br>当然，a之前也可以是单纯的数字</p></div><hr><h3 id="插入操作-i"><a href="#插入操作-i" class="headerlink" title="插入操作 i\"></a>插入操作 i\</h3><p>插入操作和上述追加和读取操作都不同，<mark>插入是在匹配行的上面进行插入，而追加和读取是在匹配行的下方进行的追加</mark>，同时插入和追加操作都是针对单个文件和一行或多行文本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/i\this is insert line'</span> test.txt</span><br></pre></td></tr></table></figure><blockquote><p><em>this is insert line</em><br>my cat’s name is betty<br>This is your dog<br><em>this is insert line</em><br>my dog’s name is frank<br>This is your fish<br><em>this is insert line</em><br>my fish’s name is george<br>This is your goat<br><em>this is insert line</em><br>my goat’s name is adam</p></blockquote><p><strong>在匹配文本上方插入多行的操作与追加类似，都是使用<code>\n</code>换行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/^my/i\this is insert line \nthis is second insert line'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p>this is insert line<br><em>this is second insert line</em><br>my cat’s name is betty<br>This is your dog<br>this is insert line<br><em>this is second insert line</em><br>my dog’s name is frank<br>This is your fish<br>this is insert line<br><em>this is second insert line</em><br>my fish’s name is george<br>This is your goat<br>this is insert line<br><em>this is second insert line</em><br>my goat’s name is adam</p></blockquote><hr><h3 id="匹配行的下一行-n命令"><a href="#匹配行的下一行-n命令" class="headerlink" title="匹配行的下一行 n命令"></a>匹配行的下一行 n命令</h3><p>打印匹配字符串的下一行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个写法会使得以my开头的行被打印两遍，是错误的</span></span><br><span class="line">sed <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法是仅显示script处理后的结果</span></span><br><span class="line">sed -n <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><p></p><p><strong>最终结果：</strong></p><blockquote><p><code>sed -n &#39;/my/{n;p}&#39; test.txt</code><br>hhhh is your dog<br>This is your fish<br>This is your goat</p></blockquote><p><strong>在原始test文件中增加了一行用于防止和普通的替换混淆</strong></p><p>如果my被匹配，则<strong>移动到匹配行的下一行</strong>，<strong>替换这一行</strong>的this为This,并打印该行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/my/&#123;n;s/This/this/; &#125;'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述式子不等于</span></span><br><span class="line">sed <span class="string">'/my/n;s/This/this/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终输出：</strong></p><blockquote><p>my cat’s name is betty<br>hhhh is your dog<br><strong>This</strong> is your dog<br>my dog’s name is frank<br><strong>this</strong> is your fish<br>my fish’s name is george<br><strong>this</strong> is your goat<br>my goat’s name is adam</p></blockquote><p><strong>不是以my为开头的下一行的This不会被替换为this</strong></p><div class="note info"><p>注意<code>花括号{}</code>，不能丢掉</p></div><p><mark>使用grep、awk得到匹配行的下一行</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -A 1 my test.txt</span><br><span class="line">sed -n <span class="string">'/my/&#123;n;p&#125;'</span> test.txt</span><br><span class="line">awk <span class="string">'/my/&#123;getline; print&#125;'</span> test.txt</span><br></pre></td></tr></table></figure><hr><h3 id="字符变换-y命令"><a href="#字符变换-y命令" class="headerlink" title="字符变换 y命令"></a>字符变换 y命令</h3><p>把1~10行内所有<strong>abcde转变为大写</strong>，注意，<strong>正则表达式元字符不能使用这个命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1,10y/abcde/ABCDE/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my CAt’s nAmE is BEtty<br>hhhh is your Dog<br>This is your Dog<br>my Dog’s nAmE is frAnk<br>This is your fish<br>my fish’s nAmE is gEorgE<br>This is your goAt<br>my goAt’s nAmE is ADAm</p></blockquote><div class="note info"><ul><li>注意这个和<strong>普通的替换不同</strong>，替换是将abcde这个字符串进行替换为ABCDE字符串，而这里是将<strong>a、b、c、d、e变为大写</strong>；</li><li>与通过<strong>已匹配字符串&amp;</strong>也不同，这个更为简单</li></ul></div><hr><h3 id="显示分隔符等详细信息-l命令"><a href="#显示分隔符等详细信息-l命令" class="headerlink" title="显示分隔符等详细信息 l命令"></a>显示分隔符等详细信息 l命令</h3><p>如果想知道文件内容的具体分割符，以及其他不能打印的字符信息可以使用’l’命令：</p><blockquote><p><code>sed -n &#39;l&#39; test3.txt</code><br>tab<code>\t</code>sep<code>\t</code>end<code>$</code><br>blank sep end<code>$</code><br>adsfaaaaaaaaaaaaaaaaafdadfasdfasdfasdfasdfsaaavfcadsasd asda asafdafa<code>\</code><br>sd<code>$</code></p></blockquote><p><strong>每行显示30个字符（包括最后的<code>\</code>）</strong>:</p><blockquote><p><code>sed -n &#39;l30&#39; test3.txt</code><br>tab<code>\t</code>sep<code>\t</code>end<code>$</code><br>blank sep end<code>$</code><br>adsfaaaaaaaaaaaaaaaaafdadfasd<code>\</code><br>fasdfasdfasdfsaaavfcadsasd as<code>\</code><br>da asafdafasd<code>$</code></p></blockquote><div class="note info"><p><code>l</code>命令用明确的形式显示模版空间的数据：</p><ul><li>以<code>C-style</code>的<strong>转义形式显示不能打印的字符(换行符、制表符等)</strong>和<strong>本身的<code>\Char</code>形式</strong></li><li><strong>长的行将进行分割</strong>，以字符<code>\</code>结尾的行<strong>表示分割</strong>，以字符<code>$</code>结尾的行表示<strong>分割结束</strong></li><li><code>n</code>指定显示行的长度，超过就进行分割；<strong>若为0表示不分割所有行</strong>；没有指定时就取命令行选项<code>-l</code>的设置，再没有就取<strong>默认值70</strong>。这是GNU的扩展功能</li></ul></div><hr><h3 id="打印奇数行或偶数行"><a href="#打印奇数行或偶数行" class="headerlink" title="打印奇数行或偶数行"></a>打印奇数行或偶数行</h3><h4 id="方法一：通过下一行（命令n）的方式"><a href="#方法一：通过下一行（命令n）的方式" class="headerlink" title="方法一：通过下一行（命令n）的方式"></a>方法一：通过下一行（命令n）的方式</h4><p><strong>打印奇数行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'p;n'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>my cat’s name is betty<br>This is your dog<br>This is your fish<br>This is your goat</p></blockquote><p><strong>打印偶数行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'n;p'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p>hhhh is your dog<br>my dog’s name is frank<br>my fish’s name is george<br>my goat’s name is adam</p></blockquote><div class="note info"><ul><li><code>命令n在前</code>而<code>p在后</code>为打印偶数行</li><li><code>命令p在前</code>而<code>n在后</code>为打印奇数行</li><li><code>命令n</code>为当前匹配的下一行</li></ul></div><hr><h4 id="方法二：简单方法"><a href="#方法二：简单方法" class="headerlink" title="方法二：简单方法"></a>方法二：简单方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印奇数行</span></span><br><span class="line">sed -n <span class="string">'1~2p'</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印偶数行</span></span><br><span class="line">sed -n <span class="string">'2~2p'</span> test.txt</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="使用实战"><a href="#使用实战" class="headerlink" title="使用实战"></a>使用实战</h2><h3 id="在开头添加start"><a href="#在开头添加start" class="headerlink" title="在开头添加start"></a>在开头添加start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要里面的空格也是有用的</span></span><br><span class="line">sed <span class="string">'s/^/start /'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><code>sed &#39;s/^/start /&#39; test.txt</code><br>start my cat’s name is betty<br>start This is your dog<br>start my dog’s name is frank<br>start This is your fish<br>start my fish’s name is george<br>start This is your goat<br>start my goat’s name is adam</p></blockquote><hr><h3 id="在结尾增加end"><a href="#在结尾增加end" class="headerlink" title="在结尾增加end"></a>在结尾增加end</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要里面的空格也是有用的</span></span><br><span class="line">sed <span class="string">'s/$/ END/'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><blockquote><p><code>sed &#39;s/$/ END/&#39; test.txt</code><br>my cat’s name is betty END<br>This is your dog END<br>my dog’s name is frank END<br>This is your fish END<br>my fish’s name is george END<br>This is your goat END<br>my goat’s name is adam END</p></blockquote><hr><h3 id="在前三行之前增加-号做注释"><a href="#在前三行之前增加-号做注释" class="headerlink" title="在前三行之前增加#号做注释"></a>在前三行之前增加#号做注释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1,3s/^/# /'</span> test.txt</span><br></pre></td></tr></table></figure><p><strong>最终结果：</strong></p><blockquote><p><code>sed &#39;1,3s/^/# /&#39; test.txt</code><br># my cat’s name is betty<br># This is your dog<br># my dog’s name is frank<br>This is your fish<br>my fish’s name is george<br>This is your goat<br>my goat’s name is adam</p></blockquote><hr><p><br></p><h2 id="使用技巧及注意事项"><a href="#使用技巧及注意事项" class="headerlink" title="使用技巧及注意事项"></a>使用技巧及注意事项</h2><ul><li>使用<strong>打印命令p</strong>时需要注意，<strong>sed默认会打印出所有的行</strong>（命令d除外，只会打印保留下来的行），所以<strong>想要打印出特定修改过的行需要加上选项n</strong></li><li>区分<code>选项</code>和<code>命令</code>的<strong>关系和书写相对位置</strong>（如选项和命令都有n，但是作用却不同）</li></ul><div class="note info"><p>使用正则表达式进行匹配打印时需要特别小心，总结一下：<mark>使用正则表达式结果要想正确，起始行必须固定（可以使用数字或者使用唯一匹配的正则表达式），这样才会输出起始行到终止行之间的内容，如果终止行是正则表达式，则会输出起始行到第一次匹配到正则表达式的终止行之间的内容。</mark></p></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://man.linuxde.net/sed" target="_blank" rel="noopener">sed命令</a></li><li><a href="https://www.cnblogs.com/ctaixw/p/5860221.html" target="_blank" rel="noopener">sed命令详解，很多关于实战的讲的很好！！！</a></li><li><a href="https://www.cnblogs.com/maxincai/p/5146338.html" target="_blank" rel="noopener">sed命令用法</a></li><li><a href="https://github.com/dongweiming/sed_and_awk/blob/master/index.html" target="_blank" rel="noopener">sed_and_awk，github上148星</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常用基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大致计划</title>
      <link href="/posts/18198.html"/>
      <url>/posts/18198.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>对于想学习内容的大致实施计划，需要根据实际情况灵活更改。</p></div><a id="more"></a><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><div class="note success"><ul><li>Linux的内容比较细小，可以使用零散的时间来学习；</li><li>机器学习的内容需要学习的连贯性，需要大量时间学习和理解；</li><li>Python学习还好，介于Linux和机器学习内容之间；</li><li>其他内容的学习不是很急切，但是一些工具性的可以先学习，比如git以及markdown，时间需求不是很大；</li><li>可以将Linux中比较大的内容和其他内容学习中比较小的内容搭配，比如sed命令和下面的markdown搭配这种；</li><li>大块的内容比如机器学习和Python可以放在晚上10-1点半之间（每天3个小时）？这个还需要考虑；</li><li>机器学习和Python学习的内容可以放在github上。</li></ul></div><h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="机器学习学习"><a href="#机器学习学习" class="headerlink" title="机器学习学习"></a>机器学习学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><hr><p><br></p><h2 id="其他内容学习"><a href="#其他内容学习" class="headerlink" title="其他内容学习"></a>其他内容学习</h2><div class="note info"><br><i></i> 一个常用命令的学习<br><i></i> 总结一个常用内容<br><i></i> shell编程一个技巧<br></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他想学习的内容</title>
      <link href="/posts/49862.html"/>
      <url>/posts/49862.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>其他想学习的内容汇总，包括Latex排版、git使用、readthedocs+mkdocs静态网站、markdown学习、docker学习以及snakemake等内容，如果遇到后续会持续添加。</p></div><a id="more"></a><h2 id="markdown学习"><a href="#markdown学习" class="headerlink" title="markdown学习"></a>markdown学习</h2><p>&emsp;&emsp;在后面的学习中，我将尽可能使用markdown进行文档的编写，这样看着更加美观，所以有必要对齐进行完善的学习，同时在真正的语法与在博客中遇到的可能有所差别，所以这里的将主要关注一些基础的语法，其他在博客写作中常用的可以参考之前写的博客。</p><div><br><a class="btn" href="http://showteeth.tech/posts/65136.html"><i class="fa fa-telegram fa-lg fa-fw"></i>markdown基础语法学习</a><br></div><div><br><a class="btn" href="http://showteeth.tech/posts/37746.html"><i class="fa fa-telegram fa-lg fa-fw"></i>next-markdown技巧和模板</a><br></div><hr><p><br></p><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><p>&emsp;&emsp;接触到github之后，git操作是经常需要使用的，所以对其进行学习非常有必要。</p><div><br><a class="btn" href="http://showteeth.tech/posts/13035.html"><i class="fa fa-telegram fa-lg fa-fw"></i>转载-Git讲解与使用实战</a><br></div><br><div><br><a class="btn" href="http://showteeth.tech/posts/13404.html"><i class="fa fa-telegram fa-lg fa-fw"></i>转载-Git常用命令及日常问题集锦</a><br></div><hr><p><br></p><h2 id="Latex排版"><a href="#Latex排版" class="headerlink" title="Latex排版"></a>Latex排版</h2><p>&emsp;&emsp;第一次真正见识到latex是看到清本大佬使用latex对课程<mark>论文进行排版</mark>以及<mark>数学公式编写</mark>，觉得非常牛逼，同时也反思了自己的本科经历，果然大佬就是大佬！啥也不说了学习吧。</p><div><br><a class="btn" href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>一份其实很短的 LaTeX 入门文档</a><br></div><div><br><a class="btn" href="http://liyangbit.com/math/jupyter-latex/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Markdown中输入数学公式及LaTex常用数学符号整理</a><br></div><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>刘海洋-latex入门</a><br></div><hr><p><br></p><h2 id="readthedocs-mkdocs静态网站"><a href="#readthedocs-mkdocs静态网站" class="headerlink" title="readthedocs+mkdocs静态网站"></a>readthedocs+mkdocs静态网站</h2><p>&emsp;&emsp;在binbin师兄的带领下，也算是接触了一下readthedocs+mkdocs静态网站（写技术文档），感觉也挺好看的，可以用来展示自己使用markdown编写的一些文本，主要是指项目。</p><div><br><a class="btn" href="https://www.mkdocs.org/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>mkdocs的官方网站</a><br></div><hr><h3 id="好用的参考"><a href="#好用的参考" class="headerlink" title="好用的参考"></a>好用的参考</h3><div class="note info"><ul><li><a href="https://cyent.github.io/markdown-with-mkdocs-material/" target="_blank" rel="noopener">很好的教程</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/extensions/admonition/" target="_blank" rel="noopener">mkdocs可用的拓展</a></li></ul></div><hr><p><br></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>&emsp;&emsp;docker是开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><div><br><a class="btn" href="http://showteeth.tech/posts/371.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Docker-构建第一个docker镜像</a><br></div><div><br><a class="btn" href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Docker——从入门到实践</a><br></div><hr><p><br></p><h2 id="snakemake"><a href="#snakemake" class="headerlink" title="snakemake"></a>snakemake</h2><p>&emsp;&emsp;snakemake是用来编写任务流程的工具。</p><div><br><a class="btn" href="https://www.jianshu.com/p/14b9eccc0c0e" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>snakemake使用笔记</a><br></div><div><br><a class="btn" href="https://slowkow.com/notes/snakemake-tutorial/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>snakemake-tutorial</a><br></div><div><br><a class="btn" href="https://www.jianshu.com/p/8e57fd2b81b2" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>使用Snakemake搭建分析流程</a><br></div><div><br><a class="btn" href="https://www.jianshu.com/p/14b9eccc0c0e" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>实例-binbin师兄写的</a><br></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> 其他内容学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习学习计划</title>
      <link href="/posts/130.html"/>
      <url>/posts/130.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>需要学习的机器学习内容汇总，包括自己总结的学习路线、书本和视频内容学习、竞赛等实战项目、很好的博主和网站以及收藏的shell相关书本等相关内容。</p></div><a id="more"></a><h2 id="自己规划的学习路线"><a href="#自己规划的学习路线" class="headerlink" title="自己规划的学习路线"></a>自己规划的学习路线</h2><h3 id="第一阶段-经典课程学习"><a href="#第一阶段-经典课程学习" class="headerlink" title="第一阶段-经典课程学习"></a>第一阶段-经典课程学习</h3><p>&emsp;&emsp;我觉得可以先通过一些<strong>经典课程</strong>，比如<strong>吴恩达老师</strong>或者<strong>林轩田老师</strong>在Coursera上的课程视频来对机器学习有一个初步了解，并通过课程配套的<strong>编程习题</strong>来动手实现一下算法，来提升一些感性的认识。</p><hr><h3 id="第二阶段-经典教材学习"><a href="#第二阶段-经典教材学习" class="headerlink" title="第二阶段-经典教材学习"></a>第二阶段-经典教材学习</h3><p>&emsp;&emsp;之后再选择一本<strong>经典教材</strong>，学习其中<strong>理论和算法的基础部分</strong>。同时也可以尝试把讲到的算法实现一下，这样将书本和实践结合起来的办法，我觉得比较有效，这个过程的学习可以<strong>与第一个阶段同时进行</strong>，学习经典的书本的时候参考视频可以加深理解，目前很多书本都有相应的视频学习课程。</p><hr><h3 id="第三阶段-实战"><a href="#第三阶段-实战" class="headerlink" title="第三阶段-实战"></a>第三阶段-实战</h3><p>&emsp;&emsp;通过这两个阶段的学习，已经<strong>掌握了机器学习的基本原理</strong>，并且对常用的经典算法，如boosting, svm, logistic regression乃至neural network比较熟悉以后，就可以考虑做一个<strong>大的project</strong>, 例如尝试参加一个在线的<strong>数据科学竞赛</strong>，通过这样一个过程，可能就能真正体会到入门的感觉。</p><hr><h3 id="第三阶段-提升"><a href="#第三阶段-提升" class="headerlink" title="第三阶段-提升"></a>第三阶段-提升</h3><p>&emsp;&emsp;借助一些比较经典的、但是也需要一些基础的书来进行提升阶段的学习。</p><div class="note info">如果只是想在毕业之后能找到算法工程师的工作，《统计学习方法》、CS229、CS231N、《deep learning》这些书再加上leetcode、数据挖掘比赛、以及相关项目经验就已经足够</div><hr><p><br></p><h2 id="课程与教材学习"><a href="#课程与教材学习" class="headerlink" title="课程与教材学习"></a>课程与教材学习</h2><p>&emsp;&emsp;现在机器学习部分主要是想根据书本进行学习，同时借助相应的视频课程，也就是上面自己总结学习路线的第一个和第二个阶段。</p><div class="note default"><br><i class="fa fa-square"></i> 《统计学习方法》（李航）<br><i class="fa fa-square"></i> 《机器学习》（周志华）<br><i class="fa fa-square"></i> ISL(An Introduction to Statistical Learning: with Applications in R)<br><i class="fa fa-square"></i> 机器学习Machine-Learning<br><i class="fa fa-square"></i> 《机器学习实战》<br><i class="fa fa-square"></i> 《机器学习实战：基于Scikit-Learn和TensorFlow》<br><i class="fa fa-square"></i> 机器学习基石、技法视频<br><i class="fa fa-square"></i> 吴恩达机器学习视频<br><i class="fa fa-square"></i> ISL配套视频<br><i class="fa fa-square"></i> 上交张志华统计机器学习视频<br></div><hr><h3 id="《统计学习方法》（李航）"><a href="#《统计学习方法》（李航）" class="headerlink" title="《统计学习方法》（李航）"></a>《统计学习方法》（李航）</h3><div class="note info"><br>这本书比较精炼，基本上是把模型推导一遍然后给出一个很简单的例子帮助你理解（完整的解释与论证）。<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>《统计学习方法》（李航）</a><hr><h3 id="《机器学习》（周志华）"><a href="#《机器学习》（周志华）" class="headerlink" title="《机器学习》（周志华）"></a>《机器学习》（周志华）</h3><div class="note info"><br>比较简单，有些只是提及，并没有很好地解释和证明，更系统和全面一点；是偏教材的书籍，需要有人引导才能更好地使用。<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>《机器学习》（周志华）</a><hr><h3 id="ISL-An-Introduction-to-Statistical-Learning-with-Applications-in-R"><a href="#ISL-An-Introduction-to-Statistical-Learning-with-Applications-in-R" class="headerlink" title="ISL(An Introduction to Statistical Learning: with Applications in R)"></a>ISL(An Introduction to Statistical Learning: with Applications in R)</h3><div class="note info"><br>ESL的基础书，统计学习的入门书，通俗易懂；监督学习占了大部分篇幅，我觉得这本书最好的部分就是模型的讨论都围绕variance和bias的trade-off展开，还有就是对模型的整体性能。<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>ISL(An Introduction to Statistical Learning: with Applications in R)</a><hr><h3 id="机器学习Machine-Learning"><a href="#机器学习Machine-Learning" class="headerlink" title="机器学习Machine-Learning"></a>机器学习Machine-Learning</h3><div class="note info"><br>github上别人总结的学习路径，可以看看。<br></div><a class="btn" href="https://github.com/JustFollowUs/Machine-Learning" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>机器学习Machine-Learning</a><hr><h3 id="《机器学习实战》"><a href="#《机器学习实战》" class="headerlink" title="《机器学习实战》"></a>《机器学习实战》</h3><div class="note info"><br>用最基本的pyton语法，从底层上让你构建代码；理论讲的不是很清楚不是很透彻<br></div><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>《机器学习实战》</a><hr><h3 id="《机器学习实战：基于Scikit-Learn和TensorFlow》"><a href="#《机器学习实战：基于Scikit-Learn和TensorFlow》" class="headerlink" title="《机器学习实战：基于Scikit-Learn和TensorFlow》"></a>《机器学习实战：基于Scikit-Learn和TensorFlow》</h3><div class="note info"><br>评价较好<br></div><a class="btn" href="https://wizardforcel.gitbooks.io/hands-on-ml-with-sklearn-and-tf/content/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>《机器学习实战：基于Scikit-Learn和TensorFlow》</a><hr><h3 id="机器学习基石、技法视频"><a href="#机器学习基石、技法视频" class="headerlink" title="机器学习基石、技法视频"></a>机器学习基石、技法视频</h3><div><br><a class="btn" href="https://www.bilibili.com/video/av36731342?from=search&seid=9794092689876019617" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>机器学习基石视频</a><br></div><div><br><a class="btn" href="https://www.bilibili.com/video/av36760800?from=search&seid=9794092689876019617" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>机器学习基技法视频</a><br></div><hr><h3 id="吴恩达机器学习视频"><a href="#吴恩达机器学习视频" class="headerlink" title="吴恩达机器学习视频"></a>吴恩达机器学习视频</h3><a class="btn" href="https://www.bilibili.com/video/av9912938?from=search&seid=12568278012054372391" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>吴恩达机器学习视频</a><hr><h3 id="ISL配套视频"><a href="#ISL配套视频" class="headerlink" title="ISL配套视频"></a>ISL配套视频</h3><a class="btn" href="https://www.bilibili.com/video/av31018744/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>ISL配套视频</a><hr><h3 id="上交张志华统计机器学习视频"><a href="#上交张志华统计机器学习视频" class="headerlink" title="上交张志华统计机器学习视频"></a>上交张志华统计机器学习视频</h3><a class="btn" href="https://www.bilibili.com/video/av24367356?from=search&seid=9713216174558800309" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>上交张志华统计机器学习视频</a><hr><p><br></p><h2 id="机器学习实战项目"><a href="#机器学习实战项目" class="headerlink" title="机器学习实战项目"></a>机器学习实战项目</h2><h3 id="好的项目"><a href="#好的项目" class="headerlink" title="好的项目"></a>好的项目</h3><p>&emsp;&emsp;搜集的好的机器学习项目</p><div class="note default"><br><i class="fa fa-square"></i> AI项目实战<br></div><h4 id="AI项目实战"><a href="#AI项目实战" class="headerlink" title="AI项目实战"></a>AI项目实战</h4><a class="btn" href="[https://www.bilibili.com/video/av24367356?from=search&seid=9713216174558800309](https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&mid=2651007079&idx=2&sn=ce6c0bca93524953faadb247076c54f3&chksm=8bad9b90bcda12866997c37169bc32ba7327cce704849eb47b99ad9dc3bbb2bdb14ef98bb60d&mpshare=1&scene=1&srcid=1120LZcC29PgcfzRodOBFIiC#rd)"><i class="fa fa-telegram fa-lg fa-fw"></i>AI项目实战</a><hr><p><br></p><h3 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h3><div class="note info"><ul><li><a href="https://www.kaggle.com/competitions" target="_blank" rel="noopener">Kaggle</a></li><li><a href="http://www.tipdm.org/bdrace/index.html" target="_blank" rel="noopener">“泰迪杯”数据挖掘挑战赛</a></li><li><a href="http://bdc.saikr.com/bdc" target="_blank" rel="noopener">中国高校计算机大赛——大数据挑战赛</a></li><li><a href="https://www.kesci.com/home/competition" target="_blank" rel="noopener">Kesci 科赛</a></li><li><a href="https://challenger.ai/?lan=zh" target="_blank" rel="noopener">AI Challenger 全球AI挑战赛</a></li><li><a href="https://www.datafountain.cn/" target="_blank" rel="noopener">datafountain-DF竞赛平台</a></li><li><a href="http://student.saschampion.com/" target="_blank" rel="noopener">sas中国高校数据分析大赛</a></li><li><a href="http://www.sescn.org.cn" target="_blank" rel="noopener">统计建模大赛</a></li><li><a href="http://gmcm.seu.edu.cn/" target="_blank" rel="noopener">研究生数学建模竞赛</a></li><li><a href="http://www.m2ct.org/index.jsp" target="_blank" rel="noopener">深圳杯数学建模挑战赛</a></li><li><a href="http://shumo.neepu.edu.cn/index.php/Home/Index/index.html" target="_blank" rel="noopener">电工杯数学建模</a></li></ul></div><table><thead><tr><th style="text-align:center">竞赛名称</th><th style="text-align:center">时间范围</th><th style="text-align:center">所需时间</th></tr></thead><tbody><tr><td style="text-align:center">“泰迪杯”数据挖掘挑战赛</td><td style="text-align:center">3.31 4.11 4.15</td><td style="text-align:center">差不多一个半月</td></tr><tr><td style="text-align:center">中国高校计算机大赛-大数据挑战赛</td><td style="text-align:center">5.26 7.25 8.20</td><td style="text-align:center">差不多三个月</td></tr><tr><td style="text-align:center">研究生数学建模竞赛</td><td style="text-align:center">9.10 9.13 9.15 9.19 9.20 9.21</td><td style="text-align:center">三天</td></tr><tr><td style="text-align:center">深圳杯数学建模挑战赛</td><td style="text-align:center">4.15 6.10 8月下旬</td><td style="text-align:center">不详</td></tr><tr><td style="text-align:center">电工杯数学建模</td><td style="text-align:center">5.23 5.25 5.28 7.15</td><td style="text-align:center">不详</td></tr><tr><td style="text-align:center">统计建模大赛</td><td style="text-align:center">5-6月</td><td style="text-align:center">不详</td></tr><tr><td style="text-align:center">sas中国高校数据分析大赛</td><td style="text-align:center">10.10</td><td style="text-align:center">不详</td></tr></tbody></table><hr><p><br></p><h3 id="竞赛对应的教程学习"><a href="#竞赛对应的教程学习" class="headerlink" title="竞赛对应的教程学习"></a>竞赛对应的教程学习</h3><div class="note info"><ul><li><a href="http://www.chioka.in/kaggle-competition-solutions/" target="_blank" rel="noopener">Kaggle Competition Past Solutions</a></li><li><a href="https://zhuanlan.zhihu.com/p/25686876" target="_blank" rel="noopener">Kaggle入门，看这一篇就够了</a></li><li><a href="https://www.jianshu.com/p/47ede942df77" target="_blank" rel="noopener">Kaggle比赛：Text Normalization for English银牌全程记录</a></li><li><a href="http://scarletpan.github.io/2017/04/28/summary-of-get-a-silver-medal-in-kaggle/" target="_blank" rel="noopener">Kaggle 首战拿银总结</a></li><li><a href="https://www.kaggle.com/xirudieyi/house-prices" target="_blank" rel="noopener">House Prices: 比赛经验分享</a></li><li><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">Kaggle泰坦尼克</a></li><li><a href="https://dnc1994.com/2016/04/rank-10-percent-in-first-kaggle-competition/" target="_blank" rel="noopener">如何在 Kaggle 首战中进入前 10%</a></li><li><a href="https://blog.csdn.net/u012162613/article/details/41929171" target="_blank" rel="noopener">大数据竞赛平台——Kaggle 入门篇</a></li><li><a href="https://study.163.com/course/introduction.htm?courseId=1003551009#/courseDetail?tab=1" target="_blank" rel="noopener">Python机器学习kaggle案例</a></li><li><a href="https://www.kesci.com/home/project/5a0575cd60680b295c1ecff2" target="_blank" rel="noopener">DATA TRAIN | 数据分析学习计划</a></li><li><a href="http://chinavis.org/2019/" target="_blank" rel="noopener">可视化与可视分析</a></li></ul></div><hr><p><br></p><h2 id="优秀的博主和网站"><a href="#优秀的博主和网站" class="headerlink" title="优秀的博主和网站"></a>优秀的博主和网站</h2><div class="note info"><ul><li><a href="http://redstonewill.com/" target="_blank" rel="noopener">机器学习、深度学习各种资料，很完善</a></li><li><a href="https://github.com/ageron/handson-ml" target="_blank" rel="noopener">Jupyter notebooks Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.</a></li><li><a href="http://www.apachecn.org/" target="_blank" rel="noopener">各种资源的中文翻译</a></li><li><a href="https://plushunter.github.io/" target="_blank" rel="noopener">人大机器学习笔记</a></li><li><a href="https://www.cnblogs.com/maybe2030/" target="_blank" rel="noopener">机器学习算法</a></li><li><a href="https://blog.csdn.net/c406495762/column/info/16415" target="_blank" rel="noopener">Python3机器学习</a></li><li><a href="https://blog.csdn.net/pipisorry" target="_blank" rel="noopener">机器学习、深度学习</a></li><li><a href="http://bourneli.github.io/" target="_blank" rel="noopener">鹅厂大佬</a></li><li><a href="https://www.jianshu.com/p/516f009c0875" target="_blank" rel="noopener">Scikit-learn使用总结</a></li></ul></div><hr><p><br></p><h2 id="收藏的机器学习相关书本和笔记"><a href="#收藏的机器学习相关书本和笔记" class="headerlink" title="收藏的机器学习相关书本和笔记"></a>收藏的机器学习相关书本和笔记</h2><div class="note info"><ul><li><a href="https://zhuanlan.zhihu.com/p/51171643" target="_blank" rel="noopener">李沐 动手学深度学习</a></li><li><a href="https://yoyoyohamapi.gitbooks.io/mit-ml/content/" target="_blank" rel="noopener">斯坦福机器学习笔记</a></li><li><a href="https://wizardforcel.gitbooks.io/hands-on-ml-with-sklearn-and-tf/content/" target="_blank" rel="noopener">Sklearn 与 TensorFlow 机器学习实用指南</a></li><li><a href="https://github.com/apachecn/hands-on-ml-zh" target="_blank" rel="noopener">Sklearn 与 TensorFlow 机器学习实用指南</a></li><li><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">scikit-learn (sklearn) 官方文档中文版</a></li><li><a href="https://github.com/Ming-Lian/Machine-Learning-Course-in-UCAS" target="_blank" rel="noopener">国科大机器学习课程&amp;机器学习笔记</a></li><li><a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">AiLearning: 机器学习 - MachineLearning - ML、深度学习 - DeepLearning - DL、自然语言处理 NLP</a></li><li><a href="https://feisky.xyz/machine-learning/" target="_blank" rel="noopener">机器学习算法</a></li><li><a href="https://machine-learning-python.kspax.io/" target="_blank" rel="noopener">機器學習：使用Python</a></li><li><a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/" target="_blank" rel="noopener">Neural Networks and Deep Learning中文</a></li><li><a href="https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/" target="_blank" rel="noopener">神经网络与深度学习另一个版本</a></li><li><a href="https://accepteddoge.com/machine-learning-yearning-cn/docs/home/" target="_blank" rel="noopener">机器学习训练秘籍</a></li><li><a href="https://github.com/imhuay/Algorithm_Interview_Notes-Chinese" target="_blank" rel="noopener">Algorithm_Interview_Notes-Chinese</a></li><li><a href="https://github.com/ageron/tf2_course" target="_blank" rel="noopener">Notebooks for my “Deep Learning with TensorFlow 2 and Keras” course</a></li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习计划</title>
      <link href="/posts/22463.html"/>
      <url>/posts/22463.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>需要学习的Python内容汇总，包括面向对象、常用模块使用、其他技巧整理、常用工具整理、实战项目、优秀的博主和网站以及收藏的Python相关书本等相关内容。</p></div><a id="more"></a><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>&emsp;&emsp;这个是我一直想要学习的内容，但是由于诸多原因还没能学习，所以把这个放在了Python学习的第一位。</p><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>面向对象</a><br></div><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>面向对象-网页收藏夹</a><br></div><hr><p><br></p><h2 id="Python标准库"><a href="#Python标准库" class="headerlink" title="Python标准库"></a>Python标准库</h2><div><br><a class="btn" href="https://www.cnblogs.com/vamei/tag/Python/default.html?page=2" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>vamei的博客</a><br></div><div><br><a class="btn" href="https://www.cnblogs.com/wj5633/tag/Python%E6%A0%87%E5%87%86%E5%BA%93/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>博客</a><br></div><div><br><a class="btn" href="https://www.cnblogs.com/rollenholt/category/313456.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>博客</a><br></div><hr><p><br></p><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><p>&emsp;&emsp;这里是一些比较常用的模块的学习。</p><div class="note default"><br><i class="fa fa-square"></i> numpy-数组与矩阵运算<br><i class="fa fa-square"></i> matplotlib-绘图<br><i class="fa fa-square"></i> Seaborn-绘图<br><i class="fa fa-square"></i> SciPy-科学计算<br><i class="fa fa-check-square"></i> argparse-命令行选项与参数解析<br><i class="fa fa-square"></i> Bokeh-交互式数据可视化<br><i class="fa fa-square"></i> HDF5-大数据存储与读取<br><i class="fa fa-square"></i> tqdm-显示运行进度条<br><i class="fa fa-square"></i> logging-日志<br><i class="fa fa-square"></i> glob-文件操作相关模块<br><i class="fa fa-square"></i> os-处理文件和目录<br><i class="fa fa-square"></i> sys-程序与python解释器的交互<br><i class="fa fa-square"></i> rpy2-调用R语言<br><i class="fa fa-square"></i> collections-内建的一个集合模块<br><br></div><hr><h3 id="numpy-数组与矩阵运算"><a href="#numpy-数组与矩阵运算" class="headerlink" title="numpy-数组与矩阵运算"></a>numpy-数组与矩阵运算</h3><div><br><a class="btn" href="https://wklchris.github.io/Py3-numpy.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-数组与矩阵运算</a><br></div><div><br><a class="btn" href="https://mp.weixin.qq.com/s/5TB0_7gcv5CHV5KyRHGD7Q" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>numpy-数组与矩阵运算</a><br></div><hr><h3 id="matplotlib-绘图"><a href="#matplotlib-绘图" class="headerlink" title="matplotlib-绘图"></a>matplotlib-绘图</h3><a class="btn" href="https://matplotlib.org/users/pyplot_tutorial.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>matplotlib-绘图</a><hr><h3 id="Seaborn-绘图"><a href="#Seaborn-绘图" class="headerlink" title="Seaborn-绘图"></a>Seaborn-绘图</h3><a class="btn" href="https://zhuanlan.zhihu.com/p/27435863" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Seaborn-绘图</a><hr><h3 id="SciPy-科学计算"><a href="#SciPy-科学计算" class="headerlink" title="SciPy-科学计算"></a>SciPy-科学计算</h3><a class="btn" href="https://www.kancloud.cn/wizardforcel/scipy-lecture-notes/129867" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>SciPy-科学计算</a><hr><h3 id="argparse-命令行选项与参数解析"><a href="#argparse-命令行选项与参数解析" class="headerlink" title="argparse-命令行选项与参数解析"></a>argparse-命令行选项与参数解析</h3><a class="btn" href="http://showteeth.tech/posts/19941.html"><i class="fa fa-telegram fa-lg fa-fw"></i>argparse-命令行选项与参数解析</a><hr><h3 id="Bokeh-交互式数据可视化"><a href="#Bokeh-交互式数据可视化" class="headerlink" title="Bokeh-交互式数据可视化"></a>Bokeh-交互式数据可视化</h3><a class="btn" href="https://zhuanlan.zhihu.com/p/52093055" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Bokeh-交互式数据可视化</a><hr><h3 id="HDF5-大数据存储与读取"><a href="#HDF5-大数据存储与读取" class="headerlink" title="HDF5-大数据存储与读取"></a>HDF5-大数据存储与读取</h3><a class="btn" href="https://www.jianshu.com/p/ae12525450e8" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>HDF5-大数据存储与读取</a><hr><h3 id="tqdm-显示运行进度条"><a href="#tqdm-显示运行进度条" class="headerlink" title="tqdm-显示运行进度条"></a>tqdm-显示运行进度条</h3><a class="btn" href="https://tqdm.github.io/" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>tqdm-显示运行进度条</a><hr><h3 id="logging-日志"><a href="#logging-日志" class="headerlink" title="logging-日志"></a>logging-日志</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>logging-日志</a><hr><h3 id="glob-文件操作相关模块"><a href="#glob-文件操作相关模块" class="headerlink" title="glob-文件操作相关模块"></a>glob-文件操作相关模块</h3><a class="btn" href="https://www.jianshu.com/p/542e55b29324" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>glob-文件操作相关模块</a><hr><h3 id="os-处理文件和目录"><a href="#os-处理文件和目录" class="headerlink" title="os-处理文件和目录"></a>os-处理文件和目录</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>os-处理文件和目录</a><hr><h3 id="sys-程序与python解释器的交互"><a href="#sys-程序与python解释器的交互" class="headerlink" title="sys-程序与python解释器的交互"></a>sys-程序与python解释器的交互</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>sys-程序与python解释器的交互</a><hr><h3 id="rpy2-调用R语言"><a href="#rpy2-调用R语言" class="headerlink" title="rpy2-调用R语言"></a>rpy2-调用R语言</h3><div><br><a class="btn" href="https://blog.csdn.net/suzyu12345/article/details/50587267" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>rpy2-调用R语言</a><br></div><div><br><a class="btn" href="https://www.cnblogs.com/lyrichu/p/6819079.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>rpy2-调用R语言</a><br></div><hr><h3 id="collections-内建的一个集合模块"><a href="#collections-内建的一个集合模块" class="headerlink" title="collections-内建的一个集合模块"></a>collections-内建的一个集合模块</h3><div><br><a class="btn" href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>collections-内建的一个集合模块</a><br></div><hr><p><br></p><h2 id="其他技巧整理"><a href="#其他技巧整理" class="headerlink" title="其他技巧整理"></a>其他技巧整理</h2><p>&emsp;&emsp;这部分内容虽然不是具体的模块，但是对他们的理解和应用对于Python的学习非常有益处。</p><div class="note default"><br><i class="fa fa-check-square"></i> main函数的理解<br><i class="fa fa-check-square"></i> Python常用程序块<br><i class="fa fa-check-square"></i> Python常见错误<br><i class="fa fa-square"></i> 接入pipeline<br></div><hr><h3 id="main函数的理解"><a href="#main函数的理解" class="headerlink" title="main函数的理解"></a>main函数的理解</h3><div><br><a class="btn" href="http://showteeth.tech/posts/32155.html"><i class="fa fa-telegram fa-lg fa-fw"></i>main函数的理解</a><br></div><hr><h3 id="Python常用程序块"><a href="#Python常用程序块" class="headerlink" title="Python常用程序块"></a>Python常用程序块</h3><div><br><a class="btn" href="http://showteeth.tech/posts/58475.html"><i class="fa fa-telegram fa-lg fa-fw"></i>main函数的理解</a><br></div><hr><h3 id="Python常见错误"><a href="#Python常见错误" class="headerlink" title="Python常见错误"></a>Python常见错误</h3><div><br><a class="btn" href="http://showteeth.tech/posts/61409.html"><i class="fa fa-telegram fa-lg fa-fw"></i>main函数的理解</a><br></div><hr><h3 id="接入pipeline"><a href="#接入pipeline" class="headerlink" title="接入pipeline"></a>接入pipeline</h3><div><br><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>接入pipeline</a><br></div><hr><p><br></p><h2 id="常用工具整理"><a href="#常用工具整理" class="headerlink" title="常用工具整理"></a>常用工具整理</h2><h3 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h3><div><br><a class="btn" href="http://showteeth.tech/posts/13473.html"><i class="fa fa-telegram fa-lg fa-fw"></i>jupyter主题、插件、技巧、server搭建</a><br></div><hr><p><br></p><h2 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h2><p>&emsp;&emsp;这部分是收集的一些实战项目，可以在学习的过程中穿插学习，巩固对知识的掌握</p><p></p><div class="note default"><br><i class="fa fa-check-square"></i> Python-博客转载项目<br><i class="fa fa-square"></i> 以撸代码的形式学习Python<br><i class="fa fa-square"></i> Python项目-w3cschool<br><i class="fa fa-square"></i> 电影分析-爬虫+可视化<br><i class="fa fa-square"></i> 12个Python实战项目教程<br><i class="fa fa-square"></i> Python练手项目推荐<br><i class="fa fa-square"></i> Python100例测试<br></div><br><p></p><hr><h3 id="Python-博客转载项目"><a href="#Python-博客转载项目" class="headerlink" title="Python-博客转载项目"></a>Python-博客转载项目</h3><a class="btn" href="http://showteeth.tech/posts/26003.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Python-博客转载项目-博客</a> <a class="btn" href="https://github.com/showteeth/blog_reprint" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python-博客转载项目-code</a><hr><h3 id="以撸代码的形式学习Python"><a href="#以撸代码的形式学习Python" class="headerlink" title="以撸代码的形式学习Python"></a>以撸代码的形式学习Python</h3><a class="btn" href="https://github.com/xianhu/LearnPython" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>以撸代码的形式学习Python</a><hr><h3 id="Python项目-w3cschool"><a href="#Python项目-w3cschool" class="headerlink" title="Python项目-w3cschool"></a>Python项目-w3cschool</h3><a class="btn" href="https://123.w3cschool.cn/python_projects" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>以撸代码的形式学习Python</a><hr><h3 id="电影分析-爬虫-可视化"><a href="#电影分析-爬虫-可视化" class="headerlink" title="电影分析-爬虫+可视化"></a>电影分析-爬虫+可视化</h3><a class="btn" href="https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247487205&idx=1&sn=82bbe82f1274b8dd6b83ad24aeb08203&chksm=9b5faa03ac2823159ce36c35f7e2c96519737994f6b5efab2190203341eedc65310c1db15cc6&mpshare=1&scene=1&srcid=1127wHAXUaLUP0tzR8jyduMA#rd" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>电影分析-爬虫+可视化</a><hr><h3 id="12个Python实战项目教程"><a href="#12个Python实战项目教程" class="headerlink" title="12个Python实战项目教程"></a>12个Python实战项目教程</h3><a class="btn" href="https://mp.weixin.qq.com/s?__biz=MzUzMjk1MDI0OQ==&mid=2247484138&idx=1&sn=43417bbcd4094bc8bd05dfe037025e6d&chksm=faaa3f6ccdddb67a02b78ae74af243785556c41021e93cf2f847aec6317e62fb0d426feda057&mpshare=1&scene=1&srcid=1126FWvmWRNX8eJdim9fEufv#rd" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>12个Python实战项目教程</a><hr><h3 id="Python练手项目推荐"><a href="#Python练手项目推荐" class="headerlink" title="Python练手项目推荐"></a>Python练手项目推荐</h3><a class="btn" href="https://www.zhihu.com/question/29372574" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python练手项目推荐</a><hr><h3 id="Python100例测试"><a href="#Python100例测试" class="headerlink" title="Python100例测试"></a>Python100例测试</h3><a class="btn" href="http://www.runoob.com/python/python-100-examples.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>Python100例测试</a><hr><p><br></p><h2 id="优秀的博主和网站"><a href="#优秀的博主和网站" class="headerlink" title="优秀的博主和网站"></a>优秀的博主和网站</h2><div class="note info"><ul><li><a href="https://www.cnblogs.com/yyds/" target="_blank" rel="noopener">云游道士</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰</a></li><li><a href="http://liyangbit.com/" target="_blank" rel="noopener">Python数据之道</a></li><li><a href="http://www.liujiangblog.com/course/python/1" target="_blank" rel="noopener">刘江的博客及教程</a></li></ul></div><hr><p><br></p><h2 id="收藏的Python相关书本"><a href="#收藏的Python相关书本" class="headerlink" title="收藏的Python相关书本"></a>收藏的Python相关书本</h2><div class="note info"><ul><li><a href="https://jackaudrey.gitbooks.io/python-numpy/content/" target="_blank" rel="noopener">Python之numpy教程</a></li><li><a href="https://wizardforcel.gitbooks.io/matplotlib-user-guide/content/1.html" target="_blank" rel="noopener">Matplotlib用户指南</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p25_creating_cached_instances.html" target="_blank" rel="noopener">类与对象</a></li><li><a href="https://l1nwatch.gitbooks.io/writing_solid_python_code_gitbook/content/" target="_blank" rel="noopener">编写高质量代码改善 Python 程序的 91 个建议</a></li><li><a href="https://wizardforcel.gitbooks.io/core-python-2e/content/" target="_blank" rel="noopener">Python 核心编程 第二版</a></li><li><a href="https://eastlakeside.gitbooks.io/interpy-zh/content/" target="_blank" rel="noopener">Python进阶</a></li><li><a href="https://xidianwlc.gitbooks.io/python-data-structrue-and-algrothms/content/" target="_blank" rel="noopener">Python数据结构与算法</a></li><li><a href="https://wizardforcel.gitbooks.io/matplotlib-intro-tut/content/" target="_blank" rel="noopener">Python 数据科学入门教程</a></li><li><a href="https://wizardforcel.gitbooks.io/hands-on-ml-with-sklearn-and-tf/content/" target="_blank" rel="noopener">Sklearn 与 TensorFlow 机器学习实用指南</a></li><li><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">scikit-learn (sklearn) 官方文档中文版</a></li><li><a href="https://wizardforcel.gitbooks.io/sklearn-cookbook/content/" target="_blank" rel="noopener">Scikit-learn 秘籍</a></li><li><a href="https://github.com/apachecn/python_data_analysis_and_mining_action" target="_blank" rel="noopener">python数据分析与挖掘实战的代码笔记</a></li><li><a href="https://germey.gitbooks.io/python3webspider/content/" target="_blank" rel="noopener">Python3网络爬虫开发实战</a></li><li><a href="https://datartisan.gitbooks.io/begining-text-mining-with-python/content/" target="_blank" rel="noopener">Python 文本数据分析初学指南</a></li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习计划</title>
      <link href="/posts/34794.html"/>
      <url>/posts/34794.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>需要学习的Linux内容汇总，包括基本命令、其他一些常用的总结、shell编程、小技巧、其他博主的命令总结、很好的博主和网站以及收藏的shell相关书本等相关内容。</p></div><a id="more"></a><h2 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h2><p>&emsp;&emsp;这些命令是在工作和学习中常用的一些命令，有些我之前系统的学习过，但是学习的笔记都存放在我的印象笔记上，等有时间了会把这些笔记整理到这个博客上（回顾之前学习的内容），感觉博客上面记笔记会比较清爽，便于后期回顾学习，还没有系统学习过的命令后期都将直接呈现在这个博客上。下面列出了需要学习的常用命令，接下来将依据这个进行学习，同时在学习中遇到新的常用命令也会进行补充和完善，同时这一页主要是一个综括页，具体的每一个命令的学习笔记都将单独的页面展示，但是可以通过这个页面直接链接过去。</p><div class="note primary"><br><i class="fa fa-check-square"></i> awk系列-强大的文本处理语言<br><i class="fa fa-check-square"></i> find-搜索文件名<br><i class="fa fa-check-square"></i> grep-搜索文件内容<br><i class="fa fa-check-square"></i> sed-文本处理工具<br><i class="fa fa-check-square"></i> sort-排序<br><i class="fa fa-check-square"></i> uniq-去重<br><i class="fa fa-check-square"></i> join-连接文本<br><i class="fa fa-check-square"></i> cut-按列切分文件字段工具<br><i class="fa fa-check-square"></i> comm-文件比较，文本文件的交集、差集与求差<br><i class="fa fa-check-square"></i> cmp-文件比较命令<br><i class="fa fa-check-square"></i> diff-文件比较命令<br><i class="fa fa-check-square"></i> cat-显示、读取或拼接文件内容<br><i class="fa fa-check-square"></i> more和less-查看文本内容<br><i class="fa fa-square"></i> wget-下载网站文件或网页<br><i class="fa fa-square"></i> curl-命令行下的高级网络工具<br><i class="fa fa-square"></i> nohup-不挂断地运行命令<br><i class="fa fa-square"></i> 打印输出<br><i class="fa fa-square"></i> 数据归档和解压缩<br><i class="fa fa-square"></i> paste-按列合并文件<br><i class="fa fa-square"></i> split-按大小分割文件<br><i class="fa fa-square"></i> csplit-根据文本内容切割文件<br><i class="fa fa-square"></i> scp-跨平台复制命令<br><i class="fa fa-square"></i> shuf-随机打乱文件<br><i class="fa fa-square"></i> seq-产生固定步长整数<br><i class="fa fa-square"></i> ps-报告当前系统的进程状态<br><i class="fa fa-square"></i> rsnyc-远程数据同步<br><i class="fa fa-square"></i> xargs-将输入转换成命令行参数<br><i class="fa fa-square"></i> read-从键盘或文件中获取标准输入<br><i class="fa fa-square"></i> time-计算命令执行花费的时间<br><i class="fa fa-square"></i> 获取时间日期格式和延时<br><i class="fa fa-square"></i> pv-命令执行的进度信息<br></div><hr><h3 id="awk系列-强大的文本处理语言"><a href="#awk系列-强大的文本处理语言" class="headerlink" title="awk系列-强大的文本处理语言"></a>awk系列-强大的文本处理语言</h3><p>该系列包括13个小节，已经学习完毕 ，笔记都保存在印象笔记上。</p><hr><h3 id="find-搜索文件名"><a href="#find-搜索文件名" class="headerlink" title="find-搜索文件名"></a>find-搜索文件名</h3><hr><h3 id="grep-搜索文件内容"><a href="#grep-搜索文件内容" class="headerlink" title="grep-搜索文件内容"></a>grep-搜索文件内容</h3><hr><h3 id="sed-文本处理工具"><a href="#sed-文本处理工具" class="headerlink" title="sed-文本处理工具"></a>sed-文本处理工具</h3><a class="btn" href="http://showteeth.tech/posts/1752.html"><i class="fa fa-telegram fa-lg fa-fw"></i>sed-文本处理工具</a><hr><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort-排序"></a>sort-排序</h3><a class="btn" href="http://showteeth.tech/posts/61024.html"><i class="fa fa-telegram fa-lg fa-fw"></i>sort-排序</a><hr><h3 id="uniq-去重"><a href="#uniq-去重" class="headerlink" title="uniq-去重"></a>uniq-去重</h3><a class="btn" href="http://showteeth.tech/posts/20744.html"><i class="fa fa-telegram fa-lg fa-fw"></i>uniq-去重</a><hr><h3 id="join-连接文本"><a href="#join-连接文本" class="headerlink" title="join-连接文本"></a>join-连接文本</h3><a class="btn" href="http://showteeth.tech/posts/5579.html"><i class="fa fa-telegram fa-lg fa-fw"></i>join-连接文本</a><hr><h3 id="cut-按列切分文件字段工具"><a href="#cut-按列切分文件字段工具" class="headerlink" title="cut-按列切分文件字段工具"></a>cut-按列切分文件字段工具</h3><a class="btn" href="http://showteeth.tech/posts/64687.html"><i class="fa fa-telegram fa-lg fa-fw"></i>cut-按列切分文件字段工具</a><hr><h3 id="comm-文件比较，文本文件的交集、差集与求差"><a href="#comm-文件比较，文本文件的交集、差集与求差" class="headerlink" title="comm-文件比较，文本文件的交集、差集与求差"></a>comm-文件比较，文本文件的交集、差集与求差</h3><a class="btn" href="http://showteeth.tech/posts/39582.html"><i class="fa fa-telegram fa-lg fa-fw"></i>comm-文件比较，文本文件的交集、差集与求差</a><hr><h3 id="cmp-文件比较命令"><a href="#cmp-文件比较命令" class="headerlink" title="cmp-文件比较命令"></a>cmp-文件比较命令</h3><a class="btn" href="http://showteeth.tech/posts/62860.html"><i class="fa fa-telegram fa-lg fa-fw"></i>cmp-文件比较命令</a><hr><h3 id="diff-文件比较命令"><a href="#diff-文件比较命令" class="headerlink" title="diff-文件比较命令"></a>diff-文件比较命令</h3><a class="btn" href="http://showteeth.tech/posts/56778.html"><i class="fa fa-telegram fa-lg fa-fw"></i>diff-文件比较命令</a><hr><h3 id="cat-显示、读取或拼接文件内容"><a href="#cat-显示、读取或拼接文件内容" class="headerlink" title="cat-显示、读取或拼接文件内容"></a>cat-显示、读取或拼接文件内容</h3><a class="btn" href="http://showteeth.tech/posts/24399.html"><i class="fa fa-telegram fa-lg fa-fw"></i>cat-显示、读取或拼接文件内容</a><hr><h3 id="more和less-查看文本内容"><a href="#more和less-查看文本内容" class="headerlink" title="more和less-查看文本内容"></a>more和less-查看文本内容</h3><a class="btn" href="http://showteeth.tech/posts/24399.html"><i class="fa fa-telegram fa-lg fa-fw"></i>more和less-查看文本内容</a><hr><h3 id="wget-下载网站文件或网页"><a href="#wget-下载网站文件或网页" class="headerlink" title="wget-下载网站文件或网页"></a>wget-下载网站文件或网页</h3><a class="btn" href="http://man.linuxde.net/wget" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>wget-下载网站文件或网页</a><hr><h3 id="curl-命令行下的高级网络工具"><a href="#curl-命令行下的高级网络工具" class="headerlink" title="curl-命令行下的高级网络工具"></a>curl-命令行下的高级网络工具</h3><a class="btn" href="http://man.linuxde.net/curl" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>curl-下载网站文件或网页</a><hr><h3 id="nohup-不挂断地运行命令"><a href="#nohup-不挂断地运行命令" class="headerlink" title="nohup-不挂断地运行命令"></a>nohup-不挂断地运行命令</h3><a class="btn" href="https://www.cnblogs.com/EasonJim/p/6850009.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>nohup-不挂断地运行命令</a><hr><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><a class="btn" href="http://man.linuxde.net/shell-script/shell-1" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>打印输出</a><hr><h3 id="数据归档和解压缩"><a href="#数据归档和解压缩" class="headerlink" title="数据归档和解压缩"></a>数据归档和解压缩</h3><a class="btn" href="http://man.linuxde.net/shell-script" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>数据归档和解压缩</a><hr><h3 id="paste-按列合并文件"><a href="#paste-按列合并文件" class="headerlink" title="paste-按列合并文件"></a>paste-按列合并文件</h3><a class="btn" href="http://man.linuxde.net/paste" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>paste-按列合并文件</a><hr><h3 id="split-按大小分割文件"><a href="#split-按大小分割文件" class="headerlink" title="split-按大小分割文件"></a>split-按大小分割文件</h3><a class="btn" href="http://man.linuxde.net/split" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>split-按大小分割文件</a><hr><h3 id="csplit-根据文本内容切割文件"><a href="#csplit-根据文本内容切割文件" class="headerlink" title="csplit-根据文本内容切割文件"></a>csplit-根据文本内容切割文件</h3><a class="btn" href="http://man.linuxde.net/csplit" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>csplit-根据文本内容切割文件</a><hr><h3 id="scp-跨平台复制命令"><a href="#scp-跨平台复制命令" class="headerlink" title="scp-跨平台复制命令"></a>scp-跨平台复制命令</h3><a class="btn" href="http://man.linuxde.net/scp" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>scp-跨平台复制命令</a><hr><h3 id="shuf-随机打乱文件"><a href="#shuf-随机打乱文件" class="headerlink" title="shuf-随机打乱文件"></a>shuf-随机打乱文件</h3><a class="btn" href="https://linux.cn/article-9635-1.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>shuf-随机打乱文件</a><hr><h3 id="seq-产生固定步长整数"><a href="#seq-产生固定步长整数" class="headerlink" title="seq-产生固定步长整数"></a>seq-产生固定步长整数</h3><a class="btn" href="https://man.linuxde.net/seq" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>seq-产生固定步长整数</a><hr><h3 id="ps-报告当前系统的进程状态"><a href="#ps-报告当前系统的进程状态" class="headerlink" title="ps-报告当前系统的进程状态"></a>ps-报告当前系统的进程状态</h3><a class="btn" href="https://wangchujiang.com/linux-command/c/ps.html" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>ps-报告当前系统的进程状态</a><hr><h3 id="rsnyc-远程数据同步"><a href="#rsnyc-远程数据同步" class="headerlink" title="rsnyc-远程数据同步"></a>rsnyc-远程数据同步</h3><a class="btn" href="http://man.linuxde.net/rsync" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>rsnyc-远程数据同步</a><hr><h3 id="xargs-将输入转换成命令行参数"><a href="#xargs-将输入转换成命令行参数" class="headerlink" title="xargs-将输入转换成命令行参数"></a>xargs-将输入转换成命令行参数</h3><a class="btn" href="http://man.linuxde.net/xargs" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>xargs-将输入转换成命令行参数</a><hr><h3 id="read-从键盘或文件中获取标准输入"><a href="#read-从键盘或文件中获取标准输入" class="headerlink" title="read-从键盘或文件中获取标准输入"></a>read-从键盘或文件中获取标准输入</h3><a class="btn" href="http://man.linuxde.net/read" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>read-从键盘或文件中获取标准输入</a><hr><h3 id="time-计算命令执行花费的时间"><a href="#time-计算命令执行花费的时间" class="headerlink" title="time-计算命令执行花费的时间"></a>time-计算命令执行花费的时间</h3><a class="btn" href="http://man.linuxde.net/time" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>time-计算命令执行花费的时间</a><hr><h3 id="获取时间日期格式和延时"><a href="#获取时间日期格式和延时" class="headerlink" title="获取时间日期格式和延时"></a>获取时间日期格式和延时</h3><a class="btn" href="http://man.linuxde.net/shell-script" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>获取时间日期格式和延时</a><hr><h3 id="pv-命令执行的进度信息"><a href="#pv-命令执行的进度信息" class="headerlink" title="pv-命令执行的进度信息"></a>pv-命令执行的进度信息</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>pv-命令执行的进度信息</a><hr><p><br></p><h2 id="其他一些常用内容总结"><a href="#其他一些常用内容总结" class="headerlink" title="其他一些常用内容总结"></a>其他一些常用内容总结</h2><p>&emsp;&emsp;这些虽然不是具体的linux命令，但是在具体学习中页非常实用，所以有必要进行积累和整理。</p><div class="note default"><br><i class="fa fa-check-square"></i> Linux中特殊符号用法<br><i class="fa fa-check-square"></i> 浮点计算并保留小数<br><i class="fa fa-check-square"></i> 字符串截取方法<br><i class="fa fa-check-square"></i> 单行命令嵌套<br><i class="fa fa-check-square"></i> 输入输出重定向<br></div><hr><h3 id="Linux中特殊符号用法"><a href="#Linux中特殊符号用法" class="headerlink" title="Linux中特殊符号用法"></a>Linux中特殊符号用法</h3><a class="btn" href="http://showteeth.tech/posts/55603.html"><i class="fa fa-telegram fa-lg fa-fw"></i>Linux中特殊符号用法</a><hr><h3 id="浮点计算并保留小数"><a href="#浮点计算并保留小数" class="headerlink" title="浮点计算并保留小数"></a>浮点计算并保留小数</h3><a class="btn" href="http://showteeth.tech/posts/28430.html"><i class="fa fa-telegram fa-lg fa-fw"></i>浮点计算并保留小数</a><hr><h3 id="字符串截取方法"><a href="#字符串截取方法" class="headerlink" title="字符串截取方法"></a>字符串截取方法</h3><a class="btn" href="http://showteeth.tech/posts/43811.html"><i class="fa fa-telegram fa-lg fa-fw"></i>字符串截取方法</a><hr><h3 id="单行命令嵌套"><a href="#单行命令嵌套" class="headerlink" title="单行命令嵌套"></a>单行命令嵌套</h3><a class="btn" href="http://showteeth.tech/50164.html"><i class="fa fa-telegram fa-lg fa-fw"></i>单行命令嵌套</a><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><a class="btn" href="http://showteeth.tech/posts/55603.html"><i class="fa fa-telegram fa-lg fa-fw"></i>输入输出重定向</a><hr><p><br></p><h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><p>&emsp;&emsp;这一块平常接触没有那些常用命令那么频繁，但是也很多很实用（不用为了一个简单的目的去编写一个Python脚本），所以这里需要系统的学习一下。</p><div class="note default"><br><i class="fa fa-check-square"></i> 传递参数<br><i class="fa fa-check-square"></i> 循环结构<br><i class="fa fa-check-square"></i> if判断<br><i class="fa fa-square"></i> 数组<br><i class="fa fa-check-square"></i> 数学运算<br></div><hr><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><a class="btn" href="http://showteeth.tech/posts/16486.html"><i class="fa fa-telegram fa-lg fa-fw"></i>循环结构</a><hr><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><a class="btn" href="http://showteeth.tech/posts/58105.html"><i class="fa fa-telegram fa-lg fa-fw"></i>if判断</a><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><a class="btn" href="http://man.linuxde.net/shell-script/shell-4" target="_blank" rel="noopener"><i class="fa fa-telegram fa-lg fa-fw"></i>传递参数</a><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><a class="btn" href="http://showteeth.tech/posts/46714.html"><i class="fa fa-telegram fa-lg fa-fw"></i>数组</a><hr><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><a class="btn" href="http://showteeth.tech/posts/28430.html"><i class="fa fa-telegram fa-lg fa-fw"></i>数学运算</a><hr><p><br></p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>&emsp;&emsp;这里总结一下使用常用命令以及进行shell编程的一些常用小技巧。</p><h3 id="awk使用技巧"><a href="#awk使用技巧" class="headerlink" title="awk使用技巧"></a>awk使用技巧</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>awk使用技巧</a><hr><h3 id="shell技巧-非shell脚本"><a href="#shell技巧-非shell脚本" class="headerlink" title="shell技巧-非shell脚本"></a>shell技巧-非shell脚本</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>shell技巧-非shell脚本</a><hr><h3 id="shell脚本技巧"><a href="#shell脚本技巧" class="headerlink" title="shell脚本技巧"></a>shell脚本技巧</h3><a class="btn" href="http://showteeth.tech/"><i class="fa fa-telegram fa-lg fa-fw"></i>shell脚本技巧</a><hr><p><br></p><h2 id="其他博主的命令总结"><a href="#其他博主的命令总结" class="headerlink" title="其他博主的命令总结"></a>其他博主的命令总结</h2><p>&emsp;&emsp;其他优秀的博主整理的常用命令，可作为自查以及必要时查阅。</p><div class="note info"><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxODM4MjA5MA==&amp;mid=2247487779&amp;idx=2&amp;sn=792e34b6d074f91368a4b2bafc1b1d03&amp;chksm=97ea3b46a09db2504a99d0105f4c24e995df7404b9603bd6ecaa53ff789df12dc785c8d5e8aa&amp;mpshare=1&amp;scene=1&amp;srcid=1124yMS6YBS7wVs10BXncBTP#rd" target="_blank" rel="noopener">97条 Linux 常用命令总结</a></li><li><a href="http://weiyanying.com/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">文件与目录基础自查</a></li></ul></div><hr><p><br></p><h2 id="很好的博主和网站"><a href="#很好的博主和网站" class="headerlink" title="很好的博主和网站"></a>很好的博主和网站</h2><div class="note info"><ul><li><a href="http://www.zsythink.net/" target="_blank" rel="noopener">大佬博客，讲解非常细致</a></li><li><a href="http://man.linuxde.net/shell-script" target="_blank" rel="noopener">常用命令和shell总结、很完善</a></li><li><a href="http://man.linuxde.net/" target="_blank" rel="noopener">查询各种linux命令，基本都有且分类清楚</a></li><li><a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">查询各种linux命令，基本都有</a></li><li><a href="https://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/default.html?page=4" target="_blank" rel="noopener">其他博主的每日一个linux命令</a></li><li><a href="https://www.jb51.net/list/list_235_1.htm" target="_blank" rel="noopener">讲解以及实际问题代码</a></li></ul></div><hr><p><br></p><h2 id="收藏的shell相关书本"><a href="#收藏的shell相关书本" class="headerlink" title="收藏的shell相关书本"></a>收藏的shell相关书本</h2><div class="note info"><ul><li><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/" target="_blank" rel="noopener">鸟哥的Linux私房菜：基础学习篇</a></li><li><a href="https://linuxstory.gitbooks.io/advanced-bash-scripting-guide-in-chinese/content/" target="_blank" rel="noopener">高级Bash脚本编程指南</a></li><li><a href="https://tinylab.gitbooks.io/shellbook/content/zh/preface/01-chapter1.html" target="_blank" rel="noopener">Shell 编程范例</a></li><li><a href="https://nicesu.gitbooks.io/shell-guide/content/" target="_blank" rel="noopener">shell脚本</a></li><li><a href="https://www.kancloud.cn/thinkphp/linux-command-line/39431" target="_blank" rel="noopener">linux command line中文版</a></li></ul></div><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>next-markdown技巧和模板-持续更新</title>
      <link href="/posts/37746.html"/>
      <url>/posts/37746.html</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>博客中常用markdown的样式和模板</p></div><a id="more"></a><h2 id="markdown技巧"><a href="#markdown技巧" class="headerlink" title="markdown技巧"></a>markdown技巧</h2><h3 id="分割线和空行"><a href="#分割线和空行" class="headerlink" title="分割线和空行"></a>分割线和空行</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">上面是分割线</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">上面是空行</span><br></pre></td></tr></table></figure><p></p><hr><br><strong>上面是分割线</strong><br><br><br><strong>上面是空行</strong><p></p><hr><h3 id="markdown引用以及html写法"><a href="#markdown引用以及html写法" class="headerlink" title="markdown引用以及html写法"></a>markdown引用以及html写法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>引用内容<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果前后间隙很小，可以像下面这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>引用内容<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><blockquote>引用内容</blockquote><p></p><blockquote>引用内容</blockquote><p></p><hr><h3 id="居中和右对齐"><a href="#居中和右对齐" class="headerlink" title="居中和右对齐"></a>居中和右对齐</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 居中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 右对齐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:right"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><center>内容</center><div style="text-align:right">内容</div><hr><h3 id="字体大小和颜色"><a href="#字体大小和颜色" class="headerlink" title="字体大小和颜色"></a>字体大小和颜色</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#FF0000"</span> <span class="attr">size</span>=<span class="string">"8px"</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#FFFF00"</span> <span class="attr">size</span>=<span class="string">"6px"</span>&gt;</span>黄色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#00FF00"</span> <span class="attr">size</span>=<span class="string">"4px"</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><font color="#FF0000" size="8px">红色</font></li><li><font color="#FFFF00" size="6px">黄色</font></li><li><font color="#00FF00" size="4px">绿色</font></li><li>更多颜色请查看 <a href="http://www.bootcss.com/p/websafecolors" target="_blank" rel="noopener">web安全色</a>、<a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="noopener">颜色对照表</a></li></ul><hr><h3 id="字体高亮显示"><a href="#字体高亮显示" class="headerlink" title="字体高亮显示"></a>字体高亮显示</h3><div class="note info">使用mark标签进行标记，高亮显示文档中的文字</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span>这是一个标记<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">使用mark标签进行标记，<span class="tag">&lt;<span class="name">mark</span>&gt;</span>高亮显示<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>文档中的文字</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p>使用mark标签进行标记，<mark>高亮显示</mark>文档中的文字</p><hr><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td><em>短文本</em></td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><div class="note warning"><ul><li>表格的语句<mark>上一行必须为空行</mark>，不然表格不生效;</li><li>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略;</li><li>-的数量至少有一个;</li><li>|、-、:之间的多余空格会被忽略，不影响布局;</li><li>表格内容中可以套用其他用法，如加粗、斜体等。</li></ul></div><h4 id="表格对齐问题"><a href="#表格对齐问题" class="headerlink" title="表格对齐问题"></a>表格对齐问题</h4><ul><li>-:表示内容和标题栏居右对齐；</li><li>:-表示内容和标题栏居左对齐；</li><li>:-:表示内容和标题栏居中对齐；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| :------ | :------: | ------: |</span><br><span class="line">| *短文本* | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><table><thead><tr><th style="text-align:left">一个普通标题</th><th style="text-align:center">一个普通标题</th><th style="text-align:right">一个普通标题</th></tr></thead><tbody><tr><td style="text-align:left"><em>短文本</em></td><td style="text-align:center">中等文本</td><td style="text-align:right">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:center">短文本</td><td style="text-align:right">中等文本</td></tr></tbody></table><a class="btn" href="http://showteeth.tech/posts/65136.html"><i class="fa fa-telegram fa-lg fa-fw"></i>合并单元格、修改表格样式</a><hr><h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo list"></a>Todo list</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><br><li><i class="fa fa-check-square"></i> 已完成</li><br><li><i class="fa fa-square"></i> 未完成</li><br></ul><hr><h3 id="Note-嵌套-Todo-list"><a href="#Note-嵌套-Todo-list" class="headerlink" title="Note 嵌套 Todo list"></a>Note 嵌套 Todo list</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一共有两种写法，效果看下面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 已完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 未完成</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br></p><div class="note primary"><br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br></div><div class="note primary"><br><p><br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-check-square"></i> 已完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br><i class="fa fa-square"></i> 未完成<br></p><br></div><hr><h3 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ```[language] [title] [url] [link-text] --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意前后都，上面演示如果后面加了会出错</li><li>language表示代码语言</li><li><code>title</code>表示出现在代码框左上角的标题</li><li><code>url</code>表示超链接地址</li><li><code>link-text</code>表示超链接的名称</li><li>这 4 项应该是根据<em>空格来分隔</em>，而不是[]，故请不要加[]。除非如果你想<strong>写后面两个</strong>，但不想写前面两个，那么就<strong>必须加 []</strong> 了，要这样写：[] [] [url] [link text] <strong>个人只验证出可以加title，url和text没验证成功。</strong></li></ul><p><strong>效果如下：</strong><br></p><figure class="highlight html"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note info">各种支持语言的名称可以查看<a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" target="_blank" rel="noopener">这篇文章</a></div><hr><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`test`</span><br></pre></td></tr></table></figure><hr><h3 id="Font-Awesome"><a href="#Font-Awesome" class="headerlink" title="Font Awesome"></a>Font Awesome</h3><div class="note default">放大图标的方法示例：</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 普通</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 变大 33%</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download fa-2x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 两倍大</span><br><span class="line"></span><br><span class="line">#fa-fw：ensuring proper alignment of the icons</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download fa-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 图标和文字之间合适间距</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><ul><li><i class="fa fa-download"></i> 普通</li><li><i class="fa fa-download fa-lg"></i> 变大 33%</li><li><i class="fa fa-download fa-2x"></i> 两倍大</li><li><i class="fa fa-download fa-fw"></i> 图标和文字之间合适间距</li></ul><div class="note info"><code>fa-fw</code>：ensuring proper alignment of the icons</div><hr><h3 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h3><div class="note info">next主题的note标签功能我一发现就爱上了，实在很好看啊~~~~</div><p>首先该功能可以在<code>next\_config.yml</code>配置文件中进行配置，默认是打开的，但是可以挑选自己喜欢的模式。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Note tag (bs-callout).</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure><p></p><p>我自己选择了其中的<code>flat style</code>，其用法如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note default"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>default<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>primary<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note success"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>success<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note info"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>info<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note warning"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>warning<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger no-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger no-icon<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">note danger, note danger, note danger</span><br><span class="line">note danger, note danger, note danger</span><br><span class="line">note danger, note danger, note danger</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>效果如下：</strong></p><div class="note default"><p>default</p></div><br><div class="note primary"><p>primary</p></div><br><div class="note success"><p>success</p></div><br><div class="note info"><p>info</p></div><br><div class="note warning"><p>warning</p></div><br><div class="note danger"><p>danger</p></div><br><div class="note danger no-icon"><p>danger no-icon</p></div><div class="note danger"><p>note danger, note danger, note danger<br>note danger, note danger, note danger<br>note danger, note danger, note danger</p></div><div class="note info"><code>next\_config.yml</code>三种样式的具体情况请看<a href="https://github.com/iissnan/hexo-theme-next/pull/1697" target="_blank" rel="noopener">网站</a></div><hr><h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><div class="note info">该标签也是在<code>next\_config.yml</code>配置文件中，默认是打开的</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Usage:</span><br><span class="line">*</span><br><span class="line">* &#123;% label [class] %&#125;Content&#123;% endlabel %&#125;</span><br><span class="line">*</span><br><span class="line">* [class] : default | primary | success | info | warning | danger.</span><br><span class="line">*           If not defined, default class will be selected.</span><br></pre></td></tr></table></figure><span class="label default">default</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label default@default %&#125;</span><br></pre></td></tr></table></figure><span class="label primary">primary</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label primary@primary %&#125;</span><br></pre></td></tr></table></figure><span class="label success">success</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label success@success %&#125;</span><br></pre></td></tr></table></figure><span class="label info">info</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label info@info %&#125;</span><br></pre></td></tr></table></figure><span class="label warning">warning</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label warning@warning %&#125;</span><br></pre></td></tr></table></figure><span class="label danger">danger</span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label danger@danger %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lorem &#123;% label @ipsum %&#125; &#123;% label primary@dolor sit %&#125; amet, consectetur &#123;% label success@adipiscing elit, %&#125; sed &#123;% label info@do eiusmod %&#125; tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line"></span><br><span class="line">Ut enim *&#123;% label warning @ad %&#125;* minim veniam, quis **&#123;% label danger @nostrud %&#125;** exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</span><br><span class="line"></span><br><span class="line">Duis aute irure dolor in reprehenderit in voluptate ~~&#123;% label default @velit %&#125;~~ <span class="tag">&lt;<span class="name">mark</span>&gt;</span>esse<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br>Lorem <span class="label default">ipsum</span> <span class="label primary">dolor sit</span> amet, consectetur <span class="label success">adipiscing elit,</span> sed <span class="label info">do eiusmod</span> tempor incididunt ut labore et dolore magna aliqua.</p><p>Ut enim <em><span class="label warning">ad</span></em> minim veniam, quis <strong><span class="label danger">nostrud</span></strong> exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p><p>Duis aute irure dolor in reprehenderit in voluptate <del><span class="label default">velit</span></del> <mark>esse</mark> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p><div class="note info"><a href="https://almostover.ru/2016-01/hexo-theme-next-test/#" target="_blank" rel="noopener">更多相关使用请看网站</a></div><hr><h3 id="Tab-选项卡"><a href="#Tab-选项卡" class="headerlink" title="Tab 选项卡"></a>Tab 选项卡</h3><div class="note info">该标签也是在<code>next\_config.yml</code>配置文件中</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 3</span><br></pre></td></tr></table></figure><div class="note info">用法讲解：</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tabs.js | global hexo script.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">&#123;% tabs [Unique name], [index] %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab [Tab caption]@[icon] --&gt;</span></span><br><span class="line">Any content (support inline tags too).</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">[Unique name]      : Unique name of tabs block tag without comma.</span><br><span class="line">                   Will be used in #id's as prefix for each tab with their index numbers.</span><br><span class="line">                   If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span><br><span class="line">                   Only for current url of post/page must be unique!</span><br><span class="line">[index]            : Index number of active tab.</span><br><span class="line">                   If not defined, first tab (1) will be selected.</span><br><span class="line">                   If index is -1, no tab will be selected. It's will be something like spoiler.</span><br><span class="line">                   May be not defined.</span><br><span class="line">[Tab caption]      : Caption of current tab.</span><br><span class="line">                   If not caption specified, unique name with tab index suffix will be used as caption of tab.</span><br><span class="line">                   If not caption specified, but specified icon, caption will empty.</span><br><span class="line">                   May be not defined.</span><br><span class="line">[icon]             : Font awesome icon.</span><br><span class="line">                    May be not defined.</span><br></pre></td></tr></table></figure><h4 id="设定选中第二个选项卡"><a href="#设定选中第二个选项卡" class="headerlink" title="设定选中第二个选项卡"></a>设定选中第二个选项卡</h4><p>应用示例：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 2 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**这是选项卡 1** 呵呵哈哈哈哈哈哈</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**这是选项卡 2** 额。。。</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**这是选项卡 3** 哇，你找到我了！</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>效果如下：</strong><br></p><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong> 额。。。</p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了！</p></div></div></div><p></p><div class="note info"><p>tabs 选项卡, 2：<br>选项卡表示选项卡的名称，如果为tab，得到的选项卡显示为tab 1、tab 2、tab 3；<br>2 表示一开始在第二个选项卡，非必须，若数值为 -1 则隐藏选项卡内容(也就是不显示呵呵哈哈哈哈哈哈这一些话，点击之后才会显示)。</p></div><hr><h4 id="自定义每个选项卡的名称"><a href="#自定义每个选项卡的名称" class="headerlink" title="自定义每个选项卡的名称"></a>自定义每个选项卡的名称</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Fourth unique name %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab Solution 1 --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 2 --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 3 --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br></p><div class="tabs" id="fourth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fourth-unique-name-1">Solution 1</a></li><li class="tab"><a href="#fourth-unique-name-2">Solution 2</a></li><li class="tab"><a href="#fourth-unique-name-3">Solution 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="fourth-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="fourth-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div><p></p><div class="note info">上面的solution 1、2、3即为自定义的，每个tab都可以设置自己的</div><hr><h4 id="每个tab只显示图标"><a href="#每个tab只显示图标" class="headerlink" title="每个tab只显示图标"></a>每个tab只显示图标</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Fifth unique name %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab @text-width --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab @amazon --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab @bold --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br></p><div class="tabs" id="fifth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fifth-unique-name-1"><i class="fa fa-text-width" style="text-align:center"></i></a></li><li class="tab"><a href="#fifth-unique-name-2"><i class="fa fa-amazon" style="text-align:center"></i></a></li><li class="tab"><a href="#fifth-unique-name-3"><i class="fa fa-bold" style="text-align:center"></i></a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="fifth-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="fifth-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div><p></p><div class="note info">上面的<code>@amazon</code>即为图标icon</div><hr><h4 id="既显示图标有显示名称"><a href="#既显示图标有显示名称" class="headerlink" title="既显示图标有显示名称"></a>既显示图标有显示名称</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Sixth unique name %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab Solution 1@text-width --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 2@amazon --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab Solution 3@bold --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><div class="note warning">这个貌似会报错</div><hr><h4 id="制作链接，快速访问多个tabs组"><a href="#制作链接，快速访问多个tabs组" class="headerlink" title="制作链接，快速访问多个tabs组"></a>制作链接，快速访问多个tabs组</h4><div class="note info">参见<a href="https://almostover.ru/2016-01/hexo-theme-next-test/" target="_blank" rel="noopener">网址</a></div><hr><h4 id="tabs中套用其他标签"><a href="#tabs中套用其他标签" class="headerlink" title="tabs中套用其他标签"></a>tabs中套用其他标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Tags %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"></span><br><span class="line">1. One</span><br><span class="line">2. Two</span><br><span class="line">3. Three</span><br><span class="line"></span><br><span class="line">Tabbed code block:</span><br><span class="line"></span><br><span class="line">nano /etc</span><br><span class="line"></span><br><span class="line">&#123;% code %&#125;</span><br><span class="line">code block tag</span><br><span class="line">code block tag</span><br><span class="line">code block tag</span><br><span class="line">&#123;% endcode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default %&#125;</span><br><span class="line">Note default tag.</span><br><span class="line">&#123;% endnote %&#125;&#123;% youtube A1Qb4zfurA8 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"></span><br><span class="line">* Five</span><br><span class="line">* Six</span><br><span class="line">* Seven</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">&#123;% youtube rX3W5evpeJE %&#125;</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br></p><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><a href="#tags-1">Tags 1</a></li><li class="tab"><a href="#tags-2">Tags 2</a></li><li class="tab"><a href="#tags-3">Tags 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tags-1"><p><strong>This is Tab 1.</strong></p><ol><li>One</li><li>Two</li><li>Three</li></ol><p>Tabbed code block:</p><pre><code>nano /etc</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code block tag</span><br><span class="line">code block tag</span><br><span class="line">code block tag</span><br></pre></td></tr></table></figure><div class="note default"><p>Note default tag.</p></div><div class="video-container"><iframe src="//www.youtube.com/embed/A1Qb4zfurA8" frameborder="0" allowfullscreen></iframe></div></div><div class="tab-pane" id="tags-2"><p><strong>This is Tab 2.</strong></p><ul><li>Five</li><li>Six</li><li>Seven</li></ul><div class="note primary"><div class="video-container"><iframe src="//www.youtube.com/embed/rX3W5evpeJE" frameborder="0" allowfullscreen></iframe></div></div></div><div class="tab-pane" id="tags-3"><p><strong>This is Tab 3.</strong></p><div class="note success"><p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.</p></div></div></div></div><p></p><hr><h3 id="按钮样式"><a href="#按钮样式" class="headerlink" title="按钮样式"></a>按钮样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># fa-lg：放大图标33%</span><br><span class="line"># fa-fw：图标和文字之间合理间距显示</span><br><span class="line"># download：图标的名称，fa-download，这里只写download即可</span><br><span class="line">&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-rotate-90 %&#125;</span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong><br><a class="btn" href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>更多关于按钮的使用点这里</a></p><div class="text-center"><br><a class="btn" href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>更多关于按钮的使用点这里</a><br></div><a class="btn" href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-rotate-90"></i>更多关于按钮的使用点这里</a><div class="note info">点击上面的按钮可以跳转到另一个网址，查看更过关于按钮的操作</div><div class="note success"><ul><li>可以将其放在html语句中进行居中等各种操作</li><li>btn后跟着点击按钮之后想访问的链接</li><li>fa-lg：放大图标33%</li><li>fa-fw：图标和文字之间合理间距显示</li><li>fa-rotate-90：顺时针旋转90度</li><li>download：图标的名称，fa-download，这里只写download即可</li></ul></div><hr><p><br></p><h2 id="插入照片"><a href="#插入照片" class="headerlink" title="插入照片"></a>插入照片</h2><p>因为图片功能在markdown语法中比较常用，所以将其单列出来，便于查找。</p><h3 id="使用七牛作为图床"><a href="#使用七牛作为图床" class="headerlink" title="使用七牛作为图床"></a>使用七牛作为图床</h3><p>用法实例：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将其插入html语句中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">&#123;% qnimg test2.png title:"test" alt:"图片说明" 'class:class1 class2' extend:?imageView2/2/w/600 %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><div class="note info"><ul><li>title：鼠标移到图片上显示的名称</li><li>alt：图片不能正常加载时显示的说明文字</li><li>extend:?imageView2/2/w/600 ：表示生成宽度最多600px的缩略图</li></ul></div><div class="note warning"><p>已经放弃七牛图床，并采用阿里云作为图床，具体请参考<a href="http://showteeth.tech/posts/41221.html">这篇文章</a></p></div><hr><h3 id="常规markdown语法"><a href="#常规markdown语法" class="headerlink" title="常规markdown语法"></a>常规markdown语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="comment">&lt;!-- 居中操作可以使用center标签将上述包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">![图片描述，相当于alt](https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png "Optional title，相当于title")</span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown插入图片"></p><center><br><img src="https://showteeth.oss-cn-beijing.aliyuncs.com/blog_img/test2.png" alt="markdown_pic" title="使用markdown+center标签居中插入图片"><br></center><div class="note info"><p><code>Optional title</code> 是用来在鼠标移到图片上时显示的title</p></div><div class="note warning"><p>使用markdown插入图片的缺点：一般的宽和高等属性不好修改，各个编辑器支持的写法可能有区别</p></div><hr><h3 id="html代码插入图片"><a href="#html代码插入图片" class="headerlink" title="html代码插入图片"></a>html代码插入图片</h3><p><strong>针对使用markdown插入图片的缺点，使用html语句可以很好的解决</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用img标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pn9abh3rj.bkt.clouddn.com/test.png"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"图片名称"</span> <span class="attr">align</span>=<span class="string">center</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用div标签包裹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pn9abh3rj.bkt.clouddn.com/test.png"</span>  <span class="attr">title</span>=<span class="string">"使用html插入图片"</span>  <span class="attr">alt</span>=<span class="string">"图片名称"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果：</strong></p><p><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" width="300" height="200" alt="图片名称" title="使用html插入图片" align="center"></p><div align="center"><br><img src="http://pn9abh3rj.bkt.clouddn.com/test.png" title="使用html插入图片" alt="图片名称"><br></div><div class="note warning"><ul><li>不推荐使用这个img标签来进行对齐操作，容易和文本混在一起，居中的时候还好；</li><li>推荐使用div标签包裹img标签。</li></ul></div><hr><p><br></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><div class="note success"><ul><li><strong>博客一般都以二级标题开始写起</strong></li><li><strong>html代码如div标签后面一定要空行</strong></li><li><strong>标签之间一般都是可以嵌套的</strong></li><li><strong>插入图片推荐使用div标签包裹img标签实现</strong></li><li><strong>写完一段记得空行！！！尽量每写完一段就空一行，尤其是代码段和文字之间，不然可能会出现markdown语法不能识别的情况（前面的错误可能导致后续很多语法都不能正常识别，在找错误的时候看第一个不能识别的位置）</strong></li></ul></div><hr><p><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/" target="_blank" rel="noopener">很详细很好的技巧文章</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">也是很好的教程，可结合上一个看</a></li><li><a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" target="_blank" rel="noopener">支持highlight的语言</a></li><li><a href="https://almostover.ru/2016-01/hexo-theme-next-test/#" target="_blank" rel="noopener">note、label、button、tab使用讲解及示例</a></li><li><a href="https://github.com/iissnan/hexo-theme-next/pull/1697" target="_blank" rel="noopener">note、label、tab使用讲解及示例</a></li></ul><p><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 博客 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
